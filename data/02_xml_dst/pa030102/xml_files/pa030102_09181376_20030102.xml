<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005144A1-20030102-D00000.TIF SYSTEM "US20030005144A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005144A1-20030102-D00001.TIF SYSTEM "US20030005144A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005144A1-20030102-D00002.TIF SYSTEM "US20030005144A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005144A1-20030102-D00003.TIF SYSTEM "US20030005144A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005144A1-20030102-D00004.TIF SYSTEM "US20030005144A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005144A1-20030102-D00005.TIF SYSTEM "US20030005144A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030005144A1-20030102-D00006.TIF SYSTEM "US20030005144A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030005144A1-20030102-D00007.TIF SYSTEM "US20030005144A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030005144A1-20030102-D00008.TIF SYSTEM "US20030005144A1-20030102-D00008.TIF" NDATA TIF>
<!ENTITY US20030005144A1-20030102-D00009.TIF SYSTEM "US20030005144A1-20030102-D00009.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005144</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09181376</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>19981028</filing-date>
<continued-prosecution-application>This is a publication of a continued prosecution application (CPA) filed under 37 CFR 1.53(d).</continued-prosecution-application>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F015/173</ipc>
</classification-ipc-primary>
<classification-ipc-secondary>
<ipc>G06F015/16</ipc>
</classification-ipc-secondary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>709</class>
<subclass>235000</subclass>
</uspc>
</classification-us-primary>
<classification-us-secondary>
<uspc>
<class>709</class>
<subclass>250000</subclass>
</uspc>
</classification-us-secondary>
<classification-us-secondary>
<uspc>
<class>709</class>
<subclass>224000</subclass>
</uspc>
</classification-us-secondary>
</classification-us>
<title-of-invention>EFFICIENT CLASSIFICATION MANIPULATION AND CONTROL OF NETWORK TRANSMISSIONS BY ASSOCIATING NETWORK FLOWS WITH RULE BASED FUNCTIONS</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>ROBERT</given-name>
<family-name>ENGEL</family-name>
</name>
<residence>
<residence-us>
<city>GREENWICH</city>
<state>CT</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>TSIPORA P.</given-name>
<family-name>BARZILAI</family-name>
</name>
<residence>
<residence-non-us>
<city>TEL AVIV</city>
<country-code>IL</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>DILIP DINKAR</given-name>
<family-name>KANDLUR</family-name>
</name>
<residence>
<residence-us>
<city>YORKTOWN HEIGHTS</city>
<state>NY</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>ASHISH</given-name>
<family-name>MEHRA</family-name>
</name>
<residence>
<residence-us>
<city>WHITE PLAINS</city>
<state>NY</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>LOUIS J PERCELLO</name-1>
<name-2>INTELLECTUAL PROPERTY LAW DEPT</name-2>
<address>
<address-1>IBM CORPORATION</address-1>
<address-2>P O BOX 218</address-2>
<city>YORKTOWN HEIGHTS</city>
<state>NY</state>
<postalcode>10598</postalcode>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A computer connected to one or more networks through appropriate network interfaces is used to classify, manipulate, and/or control communications, e.g., packets sent and/or received over the network by one or more applications executing in the computer. Each application is connected to the network through one or more sockets to enable this communication. The computer also comprises one or more rule sets of one or more rules. A socket set of one or more of the sockets is associated with only one of the rule sets. The rules in the rule set are used to control one or more of the packets communicated by the applications communicating over the socket(s) associated with the respective rule set. Rules can be added to the rule set, deleted from the rule set, or modified in order to classify, manipulate, and/or control the communication of the packets, e.g. to control the rate at which the packets are sent or to provide certain security functions. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">FIELD OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> This invention relates to the field of identifying and controlling packets sent to and received from a networking environment, particularly one or more of the following the internet, intranet, cable, and any other of packet switching networks. More specifically, the invention relates to a way to control how packets are transmitted from an application to the network and how packets received from the network are passed to the application. </paragraph>
</section>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> Applications using the Internet for transmission of data and media have huge business opportunities and controlling how information is sent from an application to a network and passed from a network to an application is a critical element. For electronic business it is important that data is manipulated before it is sent to an untrusted network and manipulated after it has left the untrusted network such that one or more of privacy, authenticity and data integrity is assured. For real time information like audio and/or video, it is more important to be able to guarantee an acceptable level of service to make it a successful business. For pervasive computing applications it is critically important that a new class of user machines, such as thin clients and application-specific Tier 0 devices, with widely varying resource capabilities are able to avail of Internet application services without excessive demands on their limited resources. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> &ldquo;Internet Media&rdquo; transmission includes sending media packets (containing any of the following: n-dimensional images, animation, music, text, movies, video shots, still pictures, voice, data, etc.) over packet switching networks (e.g., a wide area network&mdash;WAN&mdash;and/or local area network&mdash;LAN) between two or more computers with special application software. Internet Telephony is a particular version of Internet Media where packets contain voice information (and sometimes video information). When the voice processed by an input device is captured at a source computer, an application running on the source computer will transform the continuous voice analog signals into a series of discrete digitally compressed packets. There are some well known industry standards to define this transformation process and the format of these discrete (often digitally compressed) packets, for example, PCM, GSM, G.723, etc. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> There are other known processes defined by standards (e.g., IP, UDP, TCP and RTP protocols) to augment the packets with necessary headers and trailers so that these packets can travel over the common packet switching network(s) to a destination computer. With these headers and trailers, packets usually travel over the packet switching network(s) independently. At the destination computer, arriving packets are stored in a buffer and are then transformed back into the form which is close to the original analog signal. The same industry standard (e.g., PCM, GSM, G.723, etc.) defines this transformation. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> Enhancing a network transmission over a non trusted network with security features comprises but is not limited to any one or more of the following: </paragraph>
<paragraph id="P-0006" lvl="2"><number>&lsqb;0006&rsqb;</number> message integrity allows a recipient of a transmission to verify that the contents of the transmission have not been altered by a third party. It usually involves the computation of a Message Authentication Code (MAC) that is computed over the content of the transmission. </paragraph>
<paragraph id="P-0007" lvl="2"><number>&lsqb;0007&rsqb;</number> privacy guarantees that no unauthorized party can get access to the information. It involves encryption at the sending end and decryption at the receiving end. </paragraph>
<paragraph id="P-0008" lvl="2"><number>&lsqb;0008&rsqb;</number> authentication allows a recipient of a transmission to verify the ID of the sender. </paragraph>
</section>
<section>
<heading lvl="1">STATEMENT OF PROBLEMS WITH THE PRIOR ART </heading>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> Quality is a serious problem in sending media over packet switching networks, including Internet and Intranets. This problem comes from the two general characteristics of packet switching networks, namely: (A) most users are connected to the Internet over a low bandwidth link (e.g. dialup over a phone line to the Internet Service Provider); (B) a large number of users may connect to the Internet using heterogeneous resource-limited machines and devices, e.g., thin clients, handheld devices, set-top boxes, and Web appliances; (C) currently there is no standard that is generally implemented and allows to differentiate priorities of real time traffic from non real time traffic. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> Generally, the prior art systems do not control well how packets are transmitted from an application to the network and/or how packets are received from the network and passed to the application. Here control includes but is not limited to the following: controlling the temporal spacing and the temporal frequency of packets, controlling the security features (encryption, message integrity, authentication) of one or more packets. This lack of control causes several problems, among them packet transmission delay. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> For two-way Internet media transmission, long delays are fatal and packet losses also have an impact on the quality of the transmission. Delays occur when packets are buffered, which happens usually in routers, where packets from different incoming links arrive at the same time and have to be multiplexed on fewer or slower outgoing links. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> One prior art system for reducing delays is describe in RFC 2205 &ldquo;Resource ReSerVation Protocol&rdquo;. It defines a protocol to establish a reservation for specific transmission sessions on a given path. This enables routers to give packets belonging to a reserved flow a higher priority. The consequence is that they can be transmitted from one router to the next with little or no queuing. This reduces the delay for such packets significantly. The problem with this prior art system is that it doesn&apos;t scale very well, since the router needs to store the priority for all of these sessions. In addition, there is a current lack of a universally accepted policy that restricts everybody from establishing a reservation for a session. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> Another prior art system is described in the IETF draft &ldquo;Differentiated Services&rdquo;. It defines a more scaleable way to give different priorities to different flows. However, this technique is not yet mature enough to be standardized, let alone to be implemented. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> Both of the prior art systems are implemented on network equipment (routers) within the network. Since the Internet is not one homogenous, centrally administered network but comprises many different networks that are under the administrative control of different organizations, it is currently not possible for an end system to obtain a better than best effort quality over the Internet. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> An example of a typical prior art networking system <highlight><bold>100</bold></highlight> for transmitting real time information, including voice and data, and non real time information, is shown as a block diagram in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. The networking system <highlight><bold>100</bold></highlight> comprises a plurality of computers (generally <highlight><bold>160</bold></highlight>) that are connected to one or more networks <highlight><bold>130</bold></highlight> through well known network connectors such as modems and/or LAN adapters <highlight><bold>150</bold></highlight>. The computers <highlight><bold>160</bold></highlight> typically can be any generally known computer system, such as a personal computer (like an IBM ThinkPad) or workstation (like an IBM RS6000), or a device with possibly limited memory and a possibly less powerful central processing unit like a set-top box, a hand held device such as a Palm Pilot, or other Web-based application devices. For a one way communication, one computer <highlight><bold>160</bold></highlight> would be the source computer <highlight><bold>160</bold></highlight>S originating the transmission of information and one or more of the computers <highlight><bold>160</bold></highlight> would be the destination computer <highlight><bold>160</bold></highlight>D that would receive the information. However, in many applications, both the source computer <highlight><bold>160</bold></highlight>S and the destination computer <highlight><bold>160</bold></highlight>D functions are contained in a single computer, e.g. <highlight><bold>160</bold></highlight>, that can perform both transmission, sending and receiving functions, to enable point to point two way, one to many, and/or many to many communications. The computers <highlight><bold>160</bold></highlight> will have well known input and output devices like microphones <highlight><bold>131</bold></highlight>, speakers <highlight><bold>132</bold></highlight>, keyboards, mice, cameras, video recorders, screens, recorders, music instruments, pen inputs, touch screens (not shown), etc. The combination of one or more multimedia interfaces <highlight><bold>133</bold></highlight>, e.g. a sound card and/or video card <highlight><bold>133</bold></highlight>, network interface software <highlight><bold>134</bold></highlight>, and one or more network connections <highlight><bold>150</bold></highlight> converts signals from an analog continuous form <highlight><bold>135</bold></highlight> to a digital (and typically compressed) packetized form <highlight><bold>120</bold></highlight>. Through the network connector <highlight><bold>150</bold></highlight>, the packets are exchanged over the networks <highlight><bold>130</bold></highlight> between the computers <highlight><bold>160</bold></highlight>. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> The computers <highlight><bold>160</bold></highlight> might also use a network client <highlight><bold>195</bold></highlight> (e.g. a World Wide Web browser, an ftp client and other well known clients) to interact with a network server <highlight><bold>170</bold></highlight> (e.g. a World Wide Web server, an ftp server and other well known servers). The computers <highlight><bold>160</bold></highlight> therefore behave as a client to the data server <highlight><bold>170</bold></highlight> and as source and/or destination in the media transmission between them (the server <highlight><bold>170</bold></highlight> and client <highlight><bold>160</bold></highlight>). </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> The network(s) <highlight><bold>130</bold></highlight> can be any type of packet switching network which include but is (are) not limited to the Internet, intranets, extranets, wide area networks (WANs), local area networks (LANs), phone networks, and/or any combination or interconnection of such networks. Typically these networks comprise access points <highlight><bold>140</bold></highlight>, routers <highlight><bold>110</bold></highlight>, and network links (typically <highlight><bold>175</bold></highlight>). Network links <highlight><bold>175</bold></highlight> connect these routers <highlight><bold>110</bold></highlight> and access points <highlight><bold>140</bold></highlight> to form the network <highlight><bold>130</bold></highlight>. These routers <highlight><bold>110</bold></highlight>, access points <highlight><bold>140</bold></highlight>, and network links <highlight><bold>175</bold></highlight> are typically operated by one or more Internet service providers (ISP). Access points <highlight><bold>140</bold></highlight> are the gateways to outside world of the closed network. Various computers <highlight><bold>160</bold></highlight> can access the network <highlight><bold>130</bold></highlight> via access points <highlight><bold>140</bold></highlight> by well known connections including: dial-up connections, dedicated line connections, cable connections, satellite connections, and other forms of well known connections. The computers could also be attached to the network with a wireless interface based on transmission of radio waves, infrared and other well known interfaces. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> Known standard protocols (IP protocol, PPP protocol, LAN protocol, etc.) support various computers <highlight><bold>160</bold></highlight> to exchange data and messages independently of the connection being used between the network connectors <highlight><bold>150</bold></highlight> and the access points <highlight><bold>140</bold></highlight>. Particularly, User Diagram Protocol (UDP) and Real-Time Protocol (RTP) provide the ways for computers to exchange real-time Internet media packets over the network <highlight><bold>130</bold></highlight>. Other known standard protocols (TCP protocol, HTTP protocol) are better suited for transmission of non real time information like data transmission. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> In the example of <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, the destination computer <highlight><bold>160</bold></highlight>D is receiving real time UDP/RTP packets <highlight><bold>120</bold></highlight> over the network <highlight><bold>130</bold></highlight>. At the same time the destination computer <highlight><bold>160</bold></highlight> downloads data from the World Wide Web server <highlight><bold>170</bold></highlight>. Since both flows of packets have the same destination, they merge at a merging point <highlight><bold>190</bold></highlight> either on a router <highlight><bold>110</bold></highlight> within the network or at the access point <highlight><bold>140</bold></highlight> that connects the Destination Computer <highlight><bold>160</bold></highlight>D to the network <highlight><bold>130</bold></highlight>. Merging the flows means that packets are interleaved temporally. As it is usually not possible to give a higher priority to the real time packets, every packet will be put at the end of the merging buffer. This can add a significant delay to the packet transmission time and reduce the quality of the real time transmission to an intolerable level. Since the network is not under the control of the administrators/operators of the computers <highlight><bold>160</bold></highlight> and <highlight><bold>170</bold></highlight>, the quality of the media transmission <highlight><bold>120</bold></highlight> can not be controlled is usually not acceptable. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> Security is a addressed in a prior art system called the Secure Socket Layer protocol (SSL). It is also known under the name Transport Layer Security (TLS). It allows to provide security features to an individual TCP connection. However, it uses a specific API (Application Programmer Interface) that is different from the interface usually used to transmit and receive data to/from the network. This means that existing applications that want to make use of security features need to be modified to use this specific API. Since SSL is based on a reliable transport mechanism it is only specified for TCP transmissions. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> Another standard dealing with security issues is called IP Security (IPsec). It defines how to setup a security association or a secure tunnel between to points connected to a network. Packets are classified for transmission over the tunnel based on source port, destination port, source address, destination address, and the protocol. However, it is no possible to make the classification dependent on a process/thread group or ID or a specific sending or receiving application. Associating a packet with the required security features is usually done using a filter that finds the required security features based on a lookup of the classification parameters of the packet. This can be a computationally expensive process. </paragraph>
</section>
<section>
<heading lvl="1">OBJECTS OF THE INVENTION </heading>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> An object of this invention is a general way to efficiently control and manipulate packets sent to the network and pass packets received from the network to the application based upon one or more criteria. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> An object of this invention is a general way to efficiently control and manipulate packets sent to the network and pass packets received from the network to the application based upon one or more of the following criteria: packet source address, packet destination address, packet source port, packet destination port, protocol type of the packet, and the type of application that sends or receives the packet. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> An object of this invention is a system and method to provide better quality to an end-to-end Internet media transmission between two points which are connected by one or more packet switching networks, by rate shaping all other transmissions that are destined to one of the two points. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> An object of this invention is a system and method to reduce the delay, the delay variation, and the loss rate of an end-to-end Internet media transmission between two points which are connected by one or more packet switching networks and exchange other data as well by rate shaping all other transmission having the same destination. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> An object of this invention is a system and method for a source computer, and a destination computer, to negotiate and determine an aggregate rate to which all transmission from the source computer to the destination computer is limited. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> An object of this invention is a system and method that reduces the transmission delay variance and the packet loss rate of a transmission over one or more packet switched networks from a source to a destination computer that are attached to these networks by rate shaping the transmission at the source computer. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> An object of this invention is a system and method to control the temporal spacing and frequency of packets sent to the network from an application and packets received from a network and sent to the application of a set of one or more network transmission sessions, according to an aggregate policy, so that all transmission sessions are treated alike and fair. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> An object of the invention is to control encryption, authentication, and message integrity of packets sent to and received from the network based on an efficient lookup/association of the security features and the packets. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> An object of the invention is to give similar security features to a specific set of packets sent to or received from the network. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> An object of the invention is to give similar security features to a specific set of packets sent to or received from the network, that can be identified using one or more of the following: packet source address, packet destination address, packet source port, packet destination port, protocol type of the packet, and the type of the application that sends or receives the packet. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> An object of the invention is to enhance a software application with features including but not limited to temporal spacing and frequency of packets and security like encryption, authentication and message integrity without having to modify the application. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> This invention is a system and method for classifying, manipulating, and/or controlling communications, e.g., packets transmitted over a network. A computer, e.g. a server, connected to one or more networks contains applications that communicate over the network through a network interface by sending and receiving packets. Each application is connected to the network through one or more sockets to enable this communication. The computer also comprises one or more rule sets of one or more rules. A socket set of one or more of the sockets is associated with only one of the rule sets. The rules in the rule set are used to control one or more of the packets communicated by the applications communicating over the socket(s) associated with the respective rule set. In one preferred embodiment, the rules in the rule set can be added, modified and deleted to classify, manipulate, and/or control the communication of the packets, e.g. to control the rate at which the packets are sent or to provide certain security functions.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a block diagram of a prior art network. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a block diagram of a network showing a novel server and client computer connected to the network. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a data structure of the present invention showing rule sets associated with socket sets in the server. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a block diagram of the functional blocks of one preferred embodiment of the present invention. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> comprises <cross-reference target="DRAWINGS">FIGS. 5A, 5B</cross-reference>, and <highlight><bold>5</bold></highlight>C, which are flow charts showing &ldquo;add rule&rdquo;, &ldquo;modify rule&rdquo;, and &ldquo;delete rule&rdquo; processes, respectively. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is a flowchart showing the process how sockets are classified and associated with rules. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> is a flowchart of the rate shaping process. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> is a diagram of the message flow between the client and server communicating client constraints. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference> is an optional client process that is executed on the client to communicate client constraints to the server.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF THE INVENTION </heading>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a block diagram of a networking system <highlight><bold>200</bold></highlight> showing a network server <highlight><bold>170</bold></highlight> (e.g., a World Wide Web server) that contains a novel packet control mechanism (packet controller) <highlight><bold>200</bold></highlight>, a client/destination <highlight><bold>160</bold></highlight>D which comprises an optional novel client bandwidth determinator <highlight><bold>210</bold></highlight>, and a client/source <highlight><bold>160</bold></highlight>S connected to the network <highlight><bold>130</bold></highlight>. Note that components of the networking system <highlight><bold>200</bold></highlight> that are in the prior art were described in <cross-reference target="DRAWINGS">FIG. 1</cross-reference> and have the same numerical designators. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> Client <highlight><bold>160</bold></highlight>D includes but is not limited to any of the following computing devices: A computer, like a PC (e.g., IBM Aptiva), workstation (e.g., IBM RS/6000) a labtop/notebook (e.g., IBM Thinkpad), a network computer, or a set top box, a low end device like a hand held device (e.g., a PalmPilot, a smart cellular/desktop phone, or other application-specific devices) or any other general purpose computer. The computer is attached to the network <highlight><bold>130</bold></highlight> over any type of interface like wireless, dialup using a modem, ISDN, ADSL, cable, etc. The client/destination <highlight><bold>160</bold></highlight>D acts both as a receiver of media like audio, voice and/or video, and as a client <highlight><bold>195</bold></highlight> to a network server <highlight><bold>170</bold></highlight>. An example client program would be a World Wide Web browser, the client side of a File Transfer Protocol (FTP) connection, a PointCast client, etc. The network <highlight><bold>130</bold></highlight> could be any packet switched network such as the public Internet or private corporate intranets. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> The client <highlight><bold>160</bold></highlight>D optionally contains a client bandwidth determinator <highlight><bold>210</bold></highlight> that allows local determination of the bandwidth that is available for the network server to download data to the client. Bandwidth includes but is not limited to any one or more of the following parameters: peak rate and average rate at which packets are sent from the network server to the client, maximum burst sizes at which packets can be sent at the peak rate, and the maximum length of the packets. These control parameters are described in more detail in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>. In the following, we use the term &ldquo;rate&rdquo; interchangeably with bandwidth. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> The network server <highlight><bold>170</bold></highlight> can be any of the following: A general data server (e.g. ftp server), a World Wide Web server or proxy, a database server, a mainframe, or any other general purpose computer used in a generally well known server application, etc. It could also be a streaming media (audio or video) server (e.g., RealAudio or RealVideo) that streams multimedia data to requesting clients on demand. It is also possible that the network server is used as a front end for a database server or mainframe and allows such a device to be indirectly connected to the network (e.g., the Internet). Note that the server could transmit data to clients using a variety of transport protocols, e.g., Transmission Control Protocol (TCP) or User Datagram Protocol (UDP). </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> The network server <highlight><bold>170</bold></highlight> contains a packet controller <highlight><bold>200</bold></highlight> that can includes but is not limited to on or more of the following mechanisms that: control the timing and the frequency at which packets are sent to the network <highlight><bold>130</bold></highlight>, control the timing at which packets received from the network are passed to the application, control the size of packets sent to the network, control the size at which data is passed to the application, and control the security features of packets sent out to the network and received from the network. The packet controlling mechanism <highlight><bold>200</bold></highlight> has a data structure <highlight><bold>300</bold></highlight> and the functional software blocks <highlight><bold>400</bold></highlight> that work together to allow efficient association of packets with the controlling mechanisms that should be applied. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a block diagram representation of a data structure <highlight><bold>300</bold></highlight> of the present invention showing rule sets associated with socket sets in the network server <highlight><bold>170</bold></highlight>. A network server like a WWW server software usually creates several processes or threads <highlight><bold>300</bold></highlight> whose instances are depicted as <highlight><bold>300</bold></highlight><highlight><italic>a, </italic></highlight><highlight><bold>300</bold></highlight><highlight><italic>b, </italic></highlight><highlight><bold>300</bold></highlight><highlight><italic>c </italic></highlight>and that implement a network protocol to receive and transmit data (e.g., the HTTP protocol for WWW servers). In the following we will use the term application to include both process and thread. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> Each of the applications uses a well defined interface to receive data from the network and transmit data to the network. In most popular operating systems, this interface is called a socket <highlight><bold>310</bold></highlight>, whose instances are depicted as <highlight><bold>310</bold></highlight><highlight><italic>a</italic></highlight>-<highlight><bold>310</bold></highlight><highlight><italic>f. </italic></highlight>In the following we call socket any abstraction or service of an operation system that allows to send data to a network and allows to receive data from a network. Therefore, the term socket comprises but is not limited to sockets as used in UNIX and derived operating systems like AIX, FreeBSD, NetBSD, Ultrix, IRIX, Linux and other well known operating systems, OS/2, OS390, and winsock or socket (API) as used in Windows 3.x, Windows 95/98 and Windows NT. A socket <highlight><bold>310</bold></highlight> usually contains network protocol state <highlight><bold>315</bold></highlight> that is dependent on the protocol and can comprise but is not limited to any or more of the following parameters: amount of data in the socket buffer, socket blocking or non blocking, high water and low water mark for the socket and other well known parameters. The network protocol state instances are depicted as <highlight><bold>315</bold></highlight><highlight><italic>a</italic></highlight>-<highlight><bold>315</bold></highlight><highlight><italic>f</italic></highlight>. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> A rule set database <highlight><bold>340</bold></highlight> has rule sets <highlight><bold>330</bold></highlight> whose instances are depicted as <highlight><bold>330</bold></highlight><highlight><italic>a, </italic></highlight><highlight><bold>330</bold></highlight><highlight><italic>b, </italic></highlight><highlight><bold>330</bold></highlight><highlight><italic>c. </italic></highlight>In a preferred embodiment, the rule sets <highlight><bold>330</bold></highlight> are connected using a linked list <highlight><bold>350</bold></highlight>. Iteration through the rule sets is therefore possible by walking down the list. In alternative embodiments, in addition to the linked list, a hash table can be used to find a specific rule more efficiently. The hashing is carried out on parameters such as the source port, destination port, destination address, and source address, and the protocol. Every rule set can be associated with zero or more sockets. An example of hashing is to form a long number out of the source/destination address (usually 32 bits), source/destination port (usually 16 bits), and the protocol type (usually 8 bit), yielding a <highlight><bold>104</bold></highlight> bit number by just appending the bits of all the field. A hash function, e.g. a modulo function reduces this big number to a smaller set of hash buckets (e.g. 1021 buckets). Since the number of rules in the system is relatively small (smaller than the number of hash buckets) there is a good chance that each bucket contains one rule that can be found using the computationally efficient hash function. More details to hashing can be found in &ldquo;Introduction to algorithms&rdquo; by Corment, Leiserson Rivest, published by Mc Graw Hill. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> In a preferred embodiment, a rule set (e.g. rule set instances <highlight><bold>330</bold></highlight><highlight><italic>a, </italic></highlight><highlight><bold>330</bold></highlight><highlight><italic>b, </italic></highlight><highlight><bold>330</bold></highlight><highlight><italic>c</italic></highlight>) comprises a data structure <highlight><bold>350</bold></highlight> depicted as <highlight><bold>350</bold></highlight><highlight><italic>a, </italic></highlight><highlight><bold>350</bold></highlight><highlight><italic>b, </italic></highlight><highlight><bold>350</bold></highlight><highlight><italic>c </italic></highlight>comprising any one or more of the following: flow parameters (typically <highlight><bold>362</bold></highlight>), control parameters (typically <highlight><bold>364</bold></highlight>), and state parameters (typically <highlight><bold>366</bold></highlight>). </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> For example, a rule could comprise a source address X and a destination address Y (these could be IP addresses, IPX or any other well known types of addresses) as flow parameters (meaning that all other flow parameters are wildcards). Therefore, the rule would apply to all transmissions from X to Y and Y to X. As an example, it could also contain the following control parameters: key W, encryption algorithm Z, applicable to outgoing transmissions for every other packet. Therefore, every other packet coming from X and going to Y would be encrypted with encryption key W, using the encryption algorithm Z. In this case, the rule state would consist of a single bit that is toggled with the sending of each packet and that indicates if encryption needs to be applied or not. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> Rules can also be classified into types. Rule types comprise but are not limited to any one or more of the following: rule types controlling the frequency and spacing with which packets or data is delivered, rule types controlling security features of a transmission. Rule types can apply on the sending side, controlling packets sent to the network, and on the receiving side, controlling how packets/data is delivered to the application. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> The flow parameters <highlight><bold>362</bold></highlight> describe the extent of the rules, or more specifically which packets need to be controlled. They comprise, but are not limited to, any one or more of the following: source port, source address, destination port, destination address, protocol, the type of sending/receiving application. Any one or more of the former parameters can be a wildcard, denoted by a * (asterisk). As an example, the following flow &lcub;source port&equals;*; source address&equals;9.2.23.129; destination port&equals;80; destination address&equals;9.2.24.4; protocol&equals;TCP, application&equals;*&rcub; would comprise all TCP connections with IP address 9.2.23.129 and any port on one end, and IP address 9.2.23.4 and port 80 on the other end. That is, source and destination port/address are not related to the direction in which the packets travel that are controlled, but are needed to achieve a mapping with the socket which uses these parameters. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> Using that many parameters to describe a flow is usually not possible for systems located in the network (not end systems) that try to implement similar control functions (e.g. a router, or Packeteers PacketShaper). The five parameters source/destination address, source/destination port and the protocol type can be found in packets transmitted by protocols like TCP/IP, UDP/IP and other well known protocols. Therefore, these packets can be identified by a system located within the network. However, the parameter application type is usually not contained in these packets and cannot always be inferred from the other parameters in general. Hence, a router or packet shaper within the network could not get this information by just looking at the packets and could therefore not necessarily perform a classification based on application type. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> The control parameters <highlight><bold>364</bold></highlight> and control state <highlight><bold>366</bold></highlight> are used to control and manipulate the sending and receiving of packets. In a preferred embodiment, the control parameters <highlight><bold>364</bold></highlight> comprise any one or more of the following: an indication if the rule applies to the sending side, the receiving side or both sides; an indication, which part of the software (like a function, a procedure, a macro, calling a method on an object or any other well known methods to invoke a piece of software code) needs to be executed; and the parameters necessary for the execution of that code. The control state is usually needed to keep variables between two executions of the respective piece of code. </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> Controlling and manipulating packets includes but is not limited to any one or more of the following rule types: </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> Controlling the frequency, the interval, and the size of packets sent to the network and of packets received from the network and being sent to the application, providing mechanisms for privacy, message/packet integrity and authentication. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> In a preferred embodiment, the frequency/interval rule type controls the frequency and the interval of packet delivery by using a &ldquo;leaky bucket&rdquo; scheme. The leaky bucket scheme is specified in ITU-T recommendation I.371, &ldquo;Traffic Control and Congestion Control in B-ISDN&rdquo;, March 1993. The leaky bucket scheme uses 2 leaky buckets; one to monitor the peak rate and one to monitor the average rate. The leaky bucket scheme is used to determine if a packet can be delivered or if the packet has to be delayed. In the case of a rule applying for sending, delaying means leaving the packet in the socket buffer. In the case of a rule applying for receiving, delay means not delivering the packet to the network or not delivering it to the application. A scheme with two leaky buckets allows to ensure that the transmission never exceeds a peak rate, and that a long term maximum average is not exceeded. The detailed implementation of a preferred embodiment with 2 leaky buckets is shown in <cross-reference target="DRAWINGS">FIG. 7</cross-reference>. The control parameters in this case would comprise a peak rate p, an average rate a, a maximum peak rate buffer depth max_pdepth, a maximum average buffer depth max_adepth, and a maximum packet size S. These parameters are all depicted and described in more detailed in <cross-reference target="DRAWINGS">FIG. 7</cross-reference>. </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> As an example, the control parameters are shown that apply to a rule guaranteeing the following: that the maximum bit rate of a transmission does not exceed 5 kb/s, that the average bit rate is limited to 1 kb/s, that the maximum burst of packets (packets transmitted at the peak rate) does not exceed 1024 bytes, and that the maximum packet size is 512. The control parameters in this case are: p&equals;5 kb/s; a&equals;1 kb/s; S&equals;512bytes; max_pdepth&equals;512bytes; max_adepth&equals;1024bytes. and a pointer to piece of code that implements the leaky bucket scheme as shown in <cross-reference target="DRAWINGS">FIG. 7</cross-reference>. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> Rules can also be used for controlling security. These rules are called security rule types. The security rule type controls the security of a transmission by applying security features on some or all of the packets. On the sending side such security features include but are not limited to any one or more of the following encrypting packets with the purpose of guaranteeing privacy to a transmission, adding a message authentication code (MAC) to a message with the purpose of allowing the recipient to verify the integrity of the message, and signing the message with the purpose of allowing a recipient to be able to verify the authenticity of the sender. On the receiving side such security features include but are not limited to any one or more of the following: decrypting a message, or not passing unsecure, non-encrypted messages on to the application, verifying the message integrity and discarding a message/packet if it has been altered, verifying the authenticity of the sender and discarding packets that come unauthenticated. </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> As an example, control parameters are shown that are used on the receiving side to decrypt and authenticate messages and discard messages that have been altered: Decryption algorithm&equals;DES; hash function&equals;MD5; authentication algorithm&equals;RSA, and a pointer to a software function that can be described with the following pseudocode (the control state would include the actual keys needed like RSA key and DES key):  
<table-cwu id="TABLE-US-00001">
<number>1</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>processPacket(packetPayload) &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>verify the RSA signature of the payload using my RSA key;</entry>
</row>
<row>
<entry></entry>
<entry>if signature does not match then discard the packet;</entry>
</row>
<row>
<entry></entry>
<entry>create a MD5 hash;</entry>
</row>
<row>
<entry></entry>
<entry>compare result with the hash contained in the packetPayload;</entry>
</row>
<row>
<entry></entry>
<entry>if it does not match then discard the packet;</entry>
</row>
<row>
<entry></entry>
<entry>decrypt the packet using the DES key;</entry>
</row>
<row>
<entry></entry>
<entry>notify application to pick up the decrypted payload;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>&rcub;</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> The control state parameters are initialized in step <highlight><bold>710</bold></highlight> when a new rule is added to the rule database. In the case of frequency/spacing rules, the state is usually initialized to fixed values as shown in <cross-reference target="DRAWINGS">FIG. 7</cross-reference>, step <highlight><bold>715</bold></highlight>. For security rules, the control state can comprise keys, that can be established using well known key exchange protocols like SSL, ISAKMP/Oakley and other well known key exchange protocols. </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> This invention forms a bidirectional association between rule sets and sockets since a socket is always involved in sending and receiving packets to and from the network. The bidirectional association <highlight><bold>330</bold></highlight> is depicted as <highlight><bold>320</bold></highlight><highlight><italic>a</italic></highlight>-<highlight><bold>320</bold></highlight><highlight><italic>f. </italic></highlight>In the example of <cross-reference target="DRAWINGS">FIG. 3</cross-reference> the rule set <highlight><bold>330</bold></highlight><highlight><italic>a </italic></highlight>is associated with socket <highlight><bold>310</bold></highlight><highlight><italic>a, </italic></highlight><highlight><bold>310</bold></highlight><highlight><italic>b, </italic></highlight><highlight><bold>310</bold></highlight><highlight><italic>c </italic></highlight>using the associations <highlight><bold>320</bold></highlight><highlight><italic>a, </italic></highlight><highlight><bold>320</bold></highlight><highlight><italic>b, </italic></highlight><highlight><bold>320</bold></highlight><highlight><italic>c </italic></highlight>the rule set <highlight><bold>330</bold></highlight><highlight><italic>b </italic></highlight>is associated with sockets <highlight><bold>310</bold></highlight><highlight><italic>d, </italic></highlight><highlight><bold>310</bold></highlight><highlight><italic>e </italic></highlight>using associations <highlight><bold>320</bold></highlight><highlight><italic>d, </italic></highlight><highlight><bold>320</bold></highlight><highlight><italic>e </italic></highlight>and rule set <highlight><bold>330</bold></highlight><highlight><italic>c </italic></highlight>is associated with socket <highlight><bold>310</bold></highlight><highlight><italic>f </italic></highlight>using the association <highlight><bold>320</bold></highlight><highlight><italic>f</italic></highlight>. The details of how to create, use, and delete these associations are described in <cross-reference target="DRAWINGS">FIGS. 4, 5</cross-reference>, and <highlight><bold>6</bold></highlight>. Having a bidirectional association between sockets and rule sets is important for the following two reasons: </paragraph>
<paragraph id="P-0065" lvl="1"><number>&lsqb;0065&rsqb;</number> 1. Efficiently finding the sockets associated with a rule set is important when a rule is deleted (as described in step <highlight><bold>442</bold></highlight> and following of <cross-reference target="DRAWINGS">FIG. 4</cross-reference>), because all the associations between the rule set and possibly many sockets has to be removed. Instead of having to iterate through a list of sockets to find which socket is associated with the rule set, it is preferable to be able to find the sockets quickly, starting from the rule. This can be efficiently done using the one to many association <highlight><bold>320</bold></highlight>. In a preferred embodiment, this association can be implemented as a linked list to sockets that is stored in the rule set. Each socket only needs to have a single pointer to the rule set. </paragraph>
<paragraph id="P-0066" lvl="1"><number>&lsqb;0066&rsqb;</number> 2. Efficiently finding the rule set associated with each socket is important to find the control state <highlight><bold>366</bold></highlight> and control parameters <highlight><bold>364</bold></highlight> when the socket needs to send out a packet., or when a packet is received, since these parameters are needed to manipulate and control the packets (as shown in <cross-reference target="DRAWINGS">FIG. 7</cross-reference> for the example of spacing/frequency type of rule). Finding the rule set associated with a socket is also done when a socket disconnects as shown in step <highlight><bold>444</bold></highlight> and following of <cross-reference target="DRAWINGS">FIG. 4</cross-reference>. </paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a block diagram of the functional blocks <highlight><bold>400</bold></highlight> of one preferred embodiment of the present invention. In one preferred embodiment these blocks are implemented in software. It shows the functional blocks necessary to create, modify and delete the data structure described in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>. </paragraph>
<paragraph id="P-0068" lvl="0"><number>&lsqb;0068&rsqb;</number> Each functional block (represented by a square) contains a clearly defined module. This module is activated by a trigger event represented by a circle. The circles <highlight><bold>440</bold></highlight>-<highlight><bold>449</bold></highlight> represent typical trigger events. Trigger events include but are not limited to any one or more of the following: A trigger event can be caused by an application that manipulates a rule (<highlight><bold>440</bold></highlight>-<highlight><bold>442</bold></highlight>), an application that changes the state of a socket (<highlight><bold>443</bold></highlight>, <highlight><bold>444</bold></highlight>), an event that causes an attempt to send data to the network (<highlight><bold>445</bold></highlight>-<highlight><bold>447</bold></highlight>), or an event that is caused by the receipt of a packet or that causes an attempt to receive data on a socket (<highlight><bold>448</bold></highlight>-<highlight><bold>449</bold></highlight>). In a preferred embodiment each trigger event is a call to a function (or more general a piece of software) and the parameters of the trigger event are the parameters that are passed in the function. </paragraph>
<paragraph id="P-0069" lvl="0"><number>&lsqb;0069&rsqb;</number> The functional block <highlight><bold>450</bold></highlight> validates if the manipulation of a rule (caused by a trigger event <highlight><bold>440</bold></highlight>-<highlight><bold>442</bold></highlight>) is valid. This block is very specific to the environment and the security constraints the invention is placed in. In the following we describe possible policies for rule validation for the trigger events <highlight><bold>440</bold></highlight>-<highlight><bold>442</bold></highlight>. </paragraph>
<paragraph id="P-0070" lvl="0"><number>&lsqb;0070&rsqb;</number> An add rule (<highlight><bold>440</bold></highlight>), modify rule (<highlight><bold>441</bold></highlight>), delete rule (<highlight><bold>442</bold></highlight>) trigger event can be issued by an application (e.g., a WWW server that has determined the available bandwidth to a client), or a management policy that e.g. defines security features for certain flows. In the former case, a network server gets a request for the transmission of data and, based on previous knowledge or by learning how much bandwidth is available on the link to the requester, triggers the adding of a rule <highlight><bold>440</bold></highlight> that limits the bandwidth used by the transmission. This bandwidth can change during the transmission and the rule can be updated by triggering a modify rule event <highlight><bold>441</bold></highlight>. When the transmission is over, the rule is deleted (trigger event delete rule <highlight><bold>442</bold></highlight>). </paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> In the latter case, e.g. a management policy can be implemented by a user or a software agent, that sets up the security rules or they can be stored in a file together with temporal information on when rules need to be added, changed, deleted. As an example, a policy can restrict clear text transmission of telnet sessions to a server. This is achieved by adding a rule that contains the TCP protocol, three wildcards for the foreign port and the IP addresses, and the local TCP port used for telnet. All socket connections going to that port would then mandate packet encryption. Unencrypted packets on the receiving side would for example be discarded by the rule. </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> The rule validation <highlight><bold>450</bold></highlight> comprises but is not limited to verifying if a rule is &ldquo;grammatically correct&rdquo; (e.g. that there are no nonexistent protocols, negative port numbers, IP addresses of incorrect length, etc.), if the issuer of the trigger has the permission to do so etc. In one security context, manipulating rules might be restricted to a Webmaster, in another context the WWW server application might change the rules itself Some users/applications might not be allowed to setup rules other might only be allowed to change rules. If the validation is not successful an error is returned to the calling entity, otherwise the trigger event is passed on the rule processing block <highlight><bold>500</bold></highlight>. As an example, the following pseudo code validates the trigger events <highlight><bold>440</bold></highlight>-<highlight><bold>442</bold></highlight>.  
<table-cwu id="TABLE-US-00002">
<number>2</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<thead>
<row>
<entry></entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
<entry>validate(triggerEvent) &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="49PT" align="left"/>
<colspec colname="1" colwidth="168PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>IF issuer of triggerEvent is authorized AND</entry>
</row>
<row>
<entry></entry>
<entry>IF time to apply triggerEvent is ok AND</entry>
</row>
<row>
<entry></entry>
<entry>IF trigger event is &lsquo;grammatically&rsquo; correct AND</entry>
</row>
<row>
<entry></entry>
<entry>.....</entry>
</row>
<row>
<entry></entry>
<entry>THEN pass on trigger event to block 500</entry>
</row>
<row>
<entry></entry>
<entry>ELSE ignore trigger event and return</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> The algorithm for the functional block <highlight><bold>500</bold></highlight> is described in more detail in <cross-reference target="DRAWINGS">FIG. 5</cross-reference> and is used to add, modify and delete rules shown in <cross-reference target="DRAWINGS">FIG. 3</cross-reference> and the associations they have with sockets. </paragraph>
<paragraph id="P-0074" lvl="0"><number>&lsqb;0074&rsqb;</number> The trigger event &lsquo;connect socket&rsquo; <highlight><bold>443</bold></highlight> occurs when an application on the server establishes a TCP connection or when it creates a connected UDP socket. This newly connected socket has then to be matched with every rule to check for a possible necessary association. This is done in the functional block <highlight><bold>600</bold></highlight> which is described in detail in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>. </paragraph>
<paragraph id="P-0075" lvl="0"><number>&lsqb;0075&rsqb;</number> Upon the trigger event &lsquo;disconnect socket&rsquo; <highlight><bold>444</bold></highlight>, which occurs e.g. when a TCP connection terminates or a UDP socket is disconnected, the socket is disassociated from any rule set. Disassociation here means breaking up the bidirectional association <highlight><bold>320</bold></highlight><highlight><italic>a</italic></highlight>-<highlight><bold>320</bold></highlight><highlight><italic>f </italic></highlight>shown in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>. The following pseudo code serves as an example.  
<table-cwu id="TABLE-US-00003">
<number>3</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>disconnectSocket(s) &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>IF socket is associated with a rule set r</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="35PT" align="left"/>
<colspec colname="1" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>THEN</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>find the pointer to socket s in the linked list;</entry>
</row>
<row>
<entry></entry>
<entry>remove the pointer from the linked list;</entry>
</row>
<row>
<entry></entry>
<entry>remove the pointer from socket s to rule r</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>&rcub;</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0076" lvl="0"><number>&lsqb;0076&rsqb;</number> In a preferred embodiment, a timer is used if there are shaping/frequency rules in the system. This timer times out periodically and triggers a &lsquo;timeout triggered send&rsquo; <highlight><bold>445</bold></highlight>. This can be useful e.g. to send out packets that have been delayed before as shown in <cross-reference target="DRAWINGS">FIG. 7</cross-reference> step <highlight><bold>720</bold></highlight> when the leaky bucket test is not true. For other types of rules, a similar timeout mechanism might be used as well. </paragraph>
<paragraph id="P-0077" lvl="0"><number>&lsqb;0077&rsqb;</number> Attempting to send a packet includes but is not limited to the following: a timeout triggered send <highlight><bold>445</bold></highlight> occurs when the timer associated with the control mechanism and provided by the operating system fires (i.e., expires). It is enough to have a single timer, that fires and resets itself automatically, in the system. The granularity of the timer determines the maximum frequency with which controlling occurs, in the case where it is the only triggering event. On the other hand, a finer granularity of the timer means that more CPU time is spent iterating over the sockets and applying the control mechanism. </paragraph>
<paragraph id="P-0078" lvl="0"><number>&lsqb;0078&rsqb;</number> The application triggered send <highlight><bold>446</bold></highlight> is issued by an application like a WWW server (after a browser has requested to receive a certain WWW page) or data part of an FTP server (after an ftp client has requested a certain file) that tries to send data to the network. </paragraph>
<paragraph id="P-0079" lvl="0"><number>&lsqb;0079&rsqb;</number> A protocol triggered send is caused by specific protocols. For example, the TCP protocol updates its internal state, whenever it receives an acknowledgment from the peer. An acknowledgment signifies that the peer has successfully received data and that the sender/server might be able to send more. The TCP protocol then evaluates if sending more data is permitted and issues a protocol triggered send. </paragraph>
<paragraph id="P-0080" lvl="0"><number>&lsqb;0080&rsqb;</number> All three send trigger events (<highlight><bold>445</bold></highlight>-<highlight><bold>447</bold></highlight>) have to pass through the control mechanism <highlight><bold>700</bold></highlight>, which applies the control function contained in the rule. A specific example, where the control mechanism limits the rate on the sending side, is provided in more detail in <cross-reference target="DRAWINGS">FIG. 7</cross-reference>. </paragraph>
<paragraph id="P-0081" lvl="0"><number>&lsqb;0081&rsqb;</number> The receive trigger event (<highlight><bold>448</bold></highlight>) occurs when the application wants to receive a message on a socket, while the packet arrival trigger event (<highlight><bold>449</bold></highlight>) occurs when a packet arrives from the network for a socket. Both these trigger events have to pass through the control mechanism <highlight><bold>460</bold></highlight>, which decides how the arrived packets are processed with respect to the associated rules before being received by the application. For example, shaping rules for incoming packets may specify that the server accepts no more than a certain rate of FTP or HTTP connection requests (i.e., TCP connection setup packets). Such rules can reduce the possibility of denial-of-service attacks, for example, and also provision a portion of server receive resources under policy control. The associated rules may also specify the rate at which data contained in arriving packets is delivered to the application socket for subsequent receives. </paragraph>
<paragraph id="P-0082" lvl="0"><number>&lsqb;0082&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> comprises <cross-reference target="DRAWINGS">FIGS. 5A, 5B</cross-reference>, and <highlight><bold>5</bold></highlight>C, which are flow charts showing how the rule processing functional block handles &ldquo;add rule&rdquo;, &ldquo;modify rule&rdquo;, and &ldquo;delete rule&rdquo; trigger events. These trigger events and why and when they occurred are described in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>. </paragraph>
<paragraph id="P-0083" lvl="0"><number>&lsqb;0083&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5A</cross-reference> describes the processing of an add rule event. An add rule event <highlight><bold>440</bold></highlight> carries control and flow parameters to create a new rule as described in <highlight><bold>350</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 3</cross-reference>. Step <highlight><bold>511</bold></highlight> searches for a rule with identical flow parameters. If the search was successful (branch true of <highlight><bold>512</bold></highlight>) then an error is returned <highlight><bold>513</bold></highlight>, as duplicates are not allowed (instead, if a rule for a flow needs to be changed the modify rule trigger <highlight><bold>441</bold></highlight> has to be used). If the rule has a different set of flow parameters from all other rules (branch false of <highlight><bold>512</bold></highlight>), it is added to the database in <highlight><bold>514</bold></highlight>. Note that it is possible that two rules with different flow parameters match for the same socket (because of the use of wildcards). In this case, the better matching rule takes precedence and is associated with the socket. This is described in the following. </paragraph>
<paragraph id="P-0084" lvl="0"><number>&lsqb;0084&rsqb;</number> The following steps show for each socket if it needs to be disassociated with any previous rule and associated with the new rule or be associated with the new rule for the first time. Disassociating a socket from a previous rule to associate it with a new rule is necessary if the new rule has flow parameters that match better with the socket parameters than the flow parameters of the old rule. To test for a better match a cost function is defined that determines how costly a match is. Every rule in the system should always be associated with the socket that yields the lowest cost match. Finding the lowest cost match is described in detail in <cross-reference target="DRAWINGS">FIG. 6</cross-reference> where the reverse initial situation exists: a socket needs to be matched with the best matching rule instead of a rule needing to be matched with all sockets that match. </paragraph>
<paragraph id="P-0085" lvl="0"><number>&lsqb;0085&rsqb;</number> Step <highlight><bold>515</bold></highlight> shows that an iteration over all sockets is performed. Most operating systems keep a linked list containing all sockets. Iterating over the sockets means just following the elements of the linked list. Alternately, a hash table may also be constructed to efficiently identify the set of sockets that most closely match the flow parameters in the new rule. In the following the current socket is denominated as socket s. </paragraph>
<paragraph id="P-0086" lvl="0"><number>&lsqb;0086&rsqb;</number> Step <highlight><bold>516</bold></highlight> checks if the new rule r needs to be associated with the current socket s under consideration. Two functions are defined (match and cost) which are used in the test. The function match(s, r) is true if for a socket s if the IP source address, IP destination address, source port, destination port, protocol, and application type are identical to the corresponding fields in the flow parameters of the rule with one exception. An * (asterisk) in a field in the flow parameters is always considered to be a match as shown in the following pseudo-code  
<table-cwu id="TABLE-US-00004">
<number>4</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>match(s,r) &lcub;</entry>
</row>
<row>
<entry>IF (s.source_address &equals; r.source_address OR r.source_address&equals;*) AND</entry>
</row>
<row>
<entry>(s.destination_address &equals; r.destination_address OR r.destination_address&equals;*) AND</entry>
</row>
<row>
<entry>if (s.source_port &equals; r.source_port OR r.source_port&equals;*) AND</entry>
</row>
<row>
<entry>(s.destination_port &equals; r.destination_port OR r.destination_port&equals;*) AND</entry>
</row>
<row>
<entry>s.protocol &equals; r.protocol OR r.protocol&equals;*)</entry>
</row>
<row>
<entry>THEN return TRUE</entry>
</row>
<row>
<entry>ELSE return FALSE</entry>
</row>
<row>
<entry>&rcub;</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0087" lvl="0"><number>&lsqb;0087&rsqb;</number> There are two cases which are treated differently for a match. If the socket was not associated with a rule before and the flow parameters match, step <highlight><bold>517</bold></highlight> is performed. If the socket was associated with a rule before, then step <highlight><bold>517</bold></highlight> is only performed if the new match is better. In other words the new match is better if the cost function for the socket and the rule is lower than the cost function for the socket and the rule it used to be associated with. Step <highlight><bold>517</bold></highlight> breaks up any old association (if any) by associating the current socket s with the new rule r. The cost function is shown in steps <highlight><bold>615</bold></highlight>-<highlight><bold>645</bold></highlight> and the value it produces is contained in the variable localCost at step <highlight><bold>645</bold></highlight>. </paragraph>
<paragraph id="P-0088" lvl="0"><number>&lsqb;0088&rsqb;</number> Step <highlight><bold>518</bold></highlight> checks if the iteration has covered all sockets in which case it is stopped <highlight><bold>519</bold></highlight> or if there are more sockets left in which case step <highlight><bold>515</bold></highlight> will find the next socket to be evaluated. </paragraph>
<paragraph id="P-0089" lvl="0"><number>&lsqb;0089&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5B</cross-reference> describes the processing of a modify rule trigger event. The modify rule trigger event is described in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>. The modify rule event <highlight><bold>441</bold></highlight> identifies the rule and the new flow and/or control parameters. Step <highlight><bold>531</bold></highlight> locates the rule using a hash function over the IP source and destination addresses, the source and destination ports, the protocol, and the application type. If the rule is not found (step <highlight><bold>532</bold></highlight>) an error is returned in <highlight><bold>533</bold></highlight>. If the rule is found, the control parameters <highlight><bold>364</bold></highlight> contained in the data structure <highlight><bold>350</bold></highlight> of the found rule are updated in <highlight><bold>534</bold></highlight> using the parameters of the trigger event. After updating of the control parameters, the new control state values have to be verified for correctness. An example where control state parameters need to be updated is shown in <cross-reference target="DRAWINGS">FIG. 7</cross-reference>. </paragraph>
<paragraph id="P-0090" lvl="0"><number>&lsqb;0090&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5C</cross-reference> describes the processing of a delete rule trigger event <highlight><bold>442</bold></highlight>. As parameters it contains the flow parameters that uniquely identify the rule that has to be deleted. In step <highlight><bold>551</bold></highlight>, the rule is located in the rule database using the hash function over the IP source and destination address, and the source and destination port for this protocol. If the rule is not found in test <highlight><bold>552</bold></highlight> then an error is returned in <highlight><bold>553</bold></highlight>. If the rule has been successfully located, it is disassociated from all sockets and removed from the database. For all the sockets that have been associated with the rule, the classifier described in <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is used to see if there are any other rules that now match best with the disassociated sockets. </paragraph>
<paragraph id="P-0091" lvl="0"><number>&lsqb;0091&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is a flowchart showing a rule classification and association process <highlight><bold>600</bold></highlight> that is used to create bidirectional associations <highlight><bold>320</bold></highlight> between rule sets <highlight><bold>330</bold></highlight> and sockets <highlight><bold>310</bold></highlight>. It is triggered by a request <highlight><bold>443</bold></highlight> to classify a newly connected socket and associate it with the best matching rule. The request comprises the following flow parameters &lcub;source IP address, destination IP address, source port, destination port, protocol, application&rcub; depending on how the system is setup. </paragraph>
<paragraph id="P-0092" lvl="0"><number>&lsqb;0092&rsqb;</number> In step <highlight><bold>605</bold></highlight> local variables globalCost and matchingRule are set to zero. </paragraph>
<paragraph id="P-0093" lvl="0"><number>&lsqb;0093&rsqb;</number> In this preferred embodiment we find the best matching rule by iterating over all the rules and picking the rule with the least cost matching function as shown in steps <highlight><bold>620</bold></highlight>-<highlight><bold>640</bold></highlight>. In another embodiment, the hash function might be applied first for the socket parameters as they are, next to the socket parameters where one parameter is replaced with an asterisk (do this for every parameter), next where 2 socket parameters are replaced by asterisks (do this for all possible combinations) then 3,4 and 5 parameters replaced with an asterisk. Depending on how many rules generally are in the database this might be a slower or faster approach to find the best matching socket. Either of the approaches are done in step <highlight><bold>610</bold></highlight>. </paragraph>
<paragraph id="P-0094" lvl="0"><number>&lsqb;0094&rsqb;</number> The following steps <highlight><bold>615</bold></highlight>-<highlight><bold>640</bold></highlight> determine if the selected rule matches the socket and what the cost associated with the match is. The cost function can yield three types of values: The value zero for a perfect match, meaning that none of the parameters in the rule was a wildcard (asterisk). It can yield a no match as shown in step <highlight><bold>630</bold></highlight> (no flow). Lastly, it can yield a positive, non zero value that signifies a costlier match the higher the number is. The cost function allows to parameterize the cost of a wildcard match by associating a specific cost to each of the parameters with which the connect function is triggered. </paragraph>
<paragraph id="P-0095" lvl="0"><number>&lsqb;0095&rsqb;</number> In step <highlight><bold>615</bold></highlight> the local variable wildcard is set to zero. Step <highlight><bold>620</bold></highlight> starts with the choosing, of the first of the 5 parameters shown in the box. In subsequent rounds all the parameters are picked one after another. The parameters can be chosen in any order. </paragraph>
<paragraph id="P-0096" lvl="0"><number>&lsqb;0096&rsqb;</number> Step <highlight><bold>625</bold></highlight> tests if the corresponding flow parameters of the rule is a * (asterisk). Only if the rule contains a wildcard, the cost function has to be used to determine the overall cost of an eventual match. If the test of <highlight><bold>625</bold></highlight> is false then the fields of the rule and the socket are compared for equality in step <highlight><bold>630</bold></highlight>. If the two fields are different, the rule does not match the socket and any further matching for this rule is not necessary. In this case, the next rule is considered for matching in step <highlight><bold>610</bold></highlight>. If the two fields are equal step <highlight><bold>640</bold></highlight> is executed next. If in test <highlight><bold>625</bold></highlight> the rule field contains a * (asterisk) the cost for such a match is added to localCost of matching this rule with the socket. The cost for a wildcard match can be different for each field of a rule and allows to give priorities in case there are two rules which have an equal number of wildcard matches but where the association with one rule is preferred over the association with the other. The cost of a wildcard match for each field can be statically stored and is obtained in step <highlight><bold>670</bold></highlight>. Step <highlight><bold>640</bold></highlight> checks if there are more fields that need to be compared. If so, then the next field is selected in step <highlight><bold>620</bold></highlight>. If there are no fields left, the socket and the rule have been tested for a matching in all fields and the testing was positive. In the following step <highlight><bold>645</bold></highlight> the cost of this latest match is compared with the cost of the best match so far. If the cost of this (local) match is smaller than the cost of the best match (global) so far, then this match replaces the former best (global) match in step <highlight><bold>650</bold></highlight>. Otherwise the next rule is examined for matching. In step <highlight><bold>650</bold></highlight> the new best match is stored in matchingRule, together with the cost associated with that match (globalCost). Note that the cost of any match that did not involve a wildcard is zero. Since there is only exactly one such match possible (rules with identical flow parameters are not permitted), there is a unique best match possible. Test <highlight><bold>655</bold></highlight> checks for more rules that have not been examined yet. If there are more rules, the next rule is examined in step <highlight><bold>610</bold></highlight>. If there are no more rules, the socket can be associated with the best matching rule that is contained in the variable matchingRule <highlight><bold>660</bold></highlight>. Note that it is possible that no rule matches a socket and that in this case the socket is a prior art socket that is controlled by any rule. </paragraph>
<paragraph id="P-0097" lvl="0"><number>&lsqb;0097&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> is an example of a rule control mechanism <highlight><bold>700</bold></highlight> that implements rate control at the sending side. It could also be applied to control the rate at which packets are passed to the application on the receiving side. It allows to reduce the rate between the network server and the client. This can be useful if the client has other concurrent sessions, (e.g. audio/video sessions) that might be impacted by the server-client transmission if it is not rate controlled. </paragraph>
<paragraph id="P-0098" lvl="0"><number>&lsqb;0098&rsqb;</number> The packet shaping process is based on a &lsquo;leaky bucket&rsquo; scheme, that uses two leaky buckets. One leaky bucket is used to monitor conformance to the peak rate p, the other one is used to monitor conformance to the average rate a. In the following an intuitive explanation of one leaky bucket is given. The leaky bucket has a certain capacity to store credits. These credits are measured in bytes. Whenever the shaping timer expires, both leaky buckets are filled with a different amount of credits. The amount of credits added to the peak rate monitoring bucket is T*p , the amount added to the average rate monitoring bucket is T*a where T is the interval of the shaping timer. This is shown in step <highlight><bold>710</bold></highlight> and explained in more detail below. The bucket cannot be filled more than its maximum capacity (max_pdepth and max_adepth for peak and average rate buckets, respectively). At any time, it is only possible to send as much data as is accounted for in both buckets (cannot send more than the credit available). If data is sent, the credit of both buckets (pdepth, adepth) is decrement by the amount of data sent. </paragraph>
<paragraph id="P-0099" lvl="0"><number>&lsqb;0099&rsqb;</number> As shown in <cross-reference target="DRAWINGS">FIG. 4</cross-reference> the packet shaping process can be triggered by 3 different events. The most common trigger event is an application trying to send data to the network using a connected socket. This is the trigger event <highlight><bold>446</bold></highlight>. Another trigger event that involves the same order of processing, is a protocol triggered event <highlight><bold>447</bold></highlight>. Such an event could be a timeout of the protocol used to transmit data (e.g. in the case of TCP, a retransmission timeout causes the TCP protocol to retransmit data), or feedback from the network or the peer that it is ready to receive more data (e.g. in the case of TCP an Acknowledgment from the receiving end, that opens the sending window and can cause new packets to be sent). The third trigger event is caused by the control mechanism itself It occurs when the control timer expires (step <highlight><bold>445</bold></highlight>) and causes a filling of the leaky buckets in the case where the rule implements a control mechanism for the rate. Whenever the shaping timer expires the following steps will be performed for all rules. This is achieved by iterating over the linked list containing the rule database shown in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>. Step <highlight><bold>750</bold></highlight> replenishes the content of both buckets. The peak leaky bucket is incremented by T*p, the average leaky bucket by T*a. While in the preferred embodiment, the value of &ldquo;T&rdquo; is the same for both the peak leaky bucket and the average leaky bucket, each bucket, could have different values of &ldquo;T&rdquo;. </paragraph>
<paragraph id="P-0100" lvl="0"><number>&lsqb;0100&rsqb;</number> Since T is associated with the timer, this would mean that more than one timer has to be employed. Steps <highlight><bold>750</bold></highlight>-<highlight><bold>770</bold></highlight> insure that the new content of the bucket does not exceed the maximum bucket size. Step <highlight><bold>755</bold></highlight> tests if the new content (pdepth) is larger than the maximum depth of the bucket (max_pdepth). If the test is true, pdepth is reduced to the maximum size allowable in step <highlight><bold>760</bold></highlight>. Steps <highlight><bold>760</bold></highlight> and <highlight><bold>765</bold></highlight> check for an overflow of the leaky bucket monitoring the average rate and reduce the depth (adpeth) to the maximum allowable for the average leaky bucket. Then the processing merges with that of <highlight><bold>446</bold></highlight> and <highlight><bold>447</bold></highlight> in step <highlight><bold>720</bold></highlight>. Reducing pdepth and adepth to their maximum values does not impact the packets since these parameters only indicate the amount of credits contained in the respective leaky bucket. Therefore, no packets are discarded in the process. </paragraph>
<paragraph id="P-0101" lvl="0"><number>&lsqb;0101&rsqb;</number> The first step <highlight><bold>720</bold></highlight> in the actual shaping process is to verify if new data can be sent to the network without violating the shaping rule. The test is true only if both leaky buckets contain credits (i.e. pdepth&gt;0 and adepth&gt;0) AND if the socket buffer contains data to send (b&gt;0). If any of these conditions is not met the shaping mechanism returns (<highlight><bold>725</bold></highlight>). The socket buffer does not always necessarily contain data when the shaping mechanism is invoked. For example, after a timeout triggered send the shaping mechanism is invoked but the application might not have any data to send. </paragraph>
<paragraph id="P-0102" lvl="0"><number>&lsqb;0102&rsqb;</number> Step <highlight><bold>730</bold></highlight> determines the maximum size of the packet that can be sent out. The maximum size is the minimum of the following parameters: The amount of credits (bytes) available in any of the two leaky buckets (pdepth, adepth), the amount of data in the socket buffer that is ready to be sent out (b), the maximum size of the packet as specified in the shaping parameters (S), and the maximum transmission unit as defined in the network protocol (MTU). The minimum of these parameters defines the length of the packet that can be sent out. </paragraph>
<paragraph id="P-0103" lvl="0"><number>&lsqb;0103&rsqb;</number> Step <highlight><bold>735</bold></highlight> then tests if the network protocol allows to send a packet of that size. For example, if the network protocol that is used is UDP (a datagram protocol) then the protocol does not allow to fragment a datagram into two UDP packets. In this case, the shaping mechanism returns (<highlight><bold>725</bold></highlight>) and has to wait until enough credits have been accumulated in the leaky buckets that the whole record can be sent out in one shot. Note, that a misconfiguration of the packet size S could prevent any large UDP packets from being sent. Therefore, setting up a shaping rule needs careful consideration with respect to the network protocol it applies to. </paragraph>
<paragraph id="P-0104" lvl="0"><number>&lsqb;0104&rsqb;</number> Step <highlight><bold>740</bold></highlight> consists of the actual sending out of a packet of length &ldquo;len&rdquo; to the network, involving all lower network protocol layers. In addition, the packet headers also have to be formed according to the network protocol used. In step <highlight><bold>745</bold></highlight> the leaky bucket state is updated to account for the packet that has been successfully sent. The number of credits in the average and in the peak leaky bucket is reduced by len. Steps <highlight><bold>720</bold></highlight>-<highlight><bold>745</bold></highlight> are then repeated until the condition <highlight><bold>720</bold></highlight> is no longer true in which case the shaping process terminates the current round. </paragraph>
<paragraph id="P-0105" lvl="0"><number>&lsqb;0105&rsqb;</number> For the flow diagram comprising the timeout triggered send, a plurality of sockets might be ready to send data at step <highlight><bold>720</bold></highlight>. If the notion of fairness among sockets is not important the set of sockets associated with one shaping rule might be iterated always in the same order. In general, this allows the sockets that appear early in the iteration, to send more data than sockets appearing later in the iteration if the rule implements a temporal constraint (intuitively, the sockets early in the list use up all the credits). This is not a problem for WWW applications where it does not matter if one part or the other within a Web site is built up faster. It is more important that the aggregate rate is not exceeded. </paragraph>
<paragraph id="P-0106" lvl="0"><number>&lsqb;0106&rsqb;</number> In an embodiment, where fairness is important (i.e. all sockets are supposed to get an equal share of the total shaping rate), a better strategy is to iterate over the socket set associated with one rule in the same order, starting with a different socket in each round. This can be easily implemented by marking the socket that is supposed to send first in the next round. If the socket has data to send in the next round the marker is advanced to the next socket, otherwise the marker remains. </paragraph>
<paragraph id="P-0107" lvl="0"><number>&lsqb;0107&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> is a diagram of the message flow <highlight><bold>800</bold></highlight> between the client and server communicating client constraints. Client constraints can be divided into two categories: constraints of the network bandwidth between the client and the peer it is communicating with, and constraints within the client itself The latter constraints comprise any one or more of the following: limited memory and limited CPU power as they are common in thin clients, set-top boxes, and hand held devices like cellular phones, pagers, palmtops, etc. For a server to setup a new rule that controls the rate of a connection, it has to have some information what reasonable shaping parameters should be. </paragraph>
<paragraph id="P-0108" lvl="0"><number>&lsqb;0108&rsqb;</number> In one preferred embodiment, the network server would try to measure the bandwidth that is available between the server and the client. This can be done actively by sending probes into the network, or passively by monitoring the packets that are sent to the client anyway. By keeping track of past available bandwidth, the current bandwidth can be estimated. </paragraph>
<paragraph id="P-0109" lvl="0"><number>&lsqb;0109&rsqb;</number> In another embodiment, the network server <highlight><bold>170</bold></highlight> and the client source <highlight><bold>160</bold></highlight>S are collocated. The client source knows the parameters of the transmission that is in process between itself and the client destination <highlight><bold>160</bold></highlight>D. It might also have some prior information about the bandwidth with which the client is connected to the Internet. It then passes this information on to the network server which sets up a new shaping rule to limit the transmission rate between itself and the client/destination to guarantee a good quality of the transmission between the two clients. </paragraph>
<paragraph id="P-0110" lvl="0"><number>&lsqb;0110&rsqb;</number> In another embodiment, the client/destination <highlight><bold>160</bold></highlight>D and the server <highlight><bold>170</bold></highlight> communicate to enable the server to setup reasonable shaping parameters. This communication <highlight><bold>800</bold></highlight> is shown in <cross-reference target="DRAWINGS">FIG. 8</cross-reference>. It contains a server <highlight><bold>170</bold></highlight> that communicates with the client/destination <highlight><bold>160</bold></highlight>D to determine the parameters for the shaping rule. The communication usually starts with a request <highlight><bold>830</bold></highlight> from the client. This can be an HTTP request like GET, or POST, or a request for data within an FTP session. When the server realizes that it is involved in a session with this client it deploys an applet <highlight><bold>840</bold></highlight> to determine the client constraints. A detailed description of the applet process is given in <cross-reference target="DRAWINGS">FIG. 9</cross-reference>. This step could be omitted if the client side already has the necessary software (e.g. cached or stored from a previous session, or it could be contained as a plug-in within the WWW browser, etc.). </paragraph>
<paragraph id="P-0111" lvl="0"><number>&lsqb;0111&rsqb;</number> In another embodiment the server side would just offer a form-like web page where the user can annotate the maximum bandwidth with which he wishes to communicate with the server. </paragraph>
<paragraph id="P-0112" lvl="0"><number>&lsqb;0112&rsqb;</number> In another embodiment, the server memorizes the bandwidth available for a transmission. When the transmission stops and a new transmission starts to the same client, this information can be used to set up a new shaping rule. Another possibility is to keep track of the available bandwidth to clients that are &lsquo;close&rsquo; to a specific client. Closeness could be measured by the number of bits in the IP address prefix that are equal (the longer the common prefix, the closer they are). In this case, every client within a certain range of a client, whose available bandwidth is known, would be treated alike. </paragraph>
<paragraph id="P-0113" lvl="0"><number>&lsqb;0113&rsqb;</number> Determination of the shaping parameters is indicated in <highlight><bold>850</bold></highlight>. It is described in more details in <cross-reference target="DRAWINGS">FIG. 9</cross-reference>. Once the shaping parameters are determined, they are communicated to the server in <highlight><bold>860</bold></highlight>. The server can react in three ways when it gets the shaping parameter report indicating that client constraints exist. These are indicated with <highlight><bold>870</bold></highlight>: </paragraph>
<paragraph id="P-0114" lvl="2"><number>&lsqb;0114&rsqb;</number> If no prior shaping rule has been in place a new rule would be set up (using the trigger event <highlight><bold>440</bold></highlight>) that limits the flow (all the connections) between the server and the client. Such a rule would typically look like &lcub;source address&equals;server address; source port&equals;*; destination address&equals;client address; destination port&equals;*; application&equals;*;&plus;shaping parameters&rcub;. </paragraph>
<paragraph id="P-0115" lvl="2"><number>&lsqb;0115&rsqb;</number> If a shaping rule is already in place (due to an earlier or ongoing parallel session with the client) this rule might have to be modified using a trigger event <highlight><bold>442</bold></highlight>. The shaping parameters would be adapted according to the new bandwidth constraints. </paragraph>
<paragraph id="P-0116" lvl="2"><number>&lsqb;0116&rsqb;</number> If the server realizes that the bandwidth constraints have disappeared, (e.g. the client has terminated a voice over IP call with a peer) the rules pertaining to the client can be deleted using a trigger event <highlight><bold>442</bold></highlight>. This allows the server to make full use of the existing bandwidth between itself and the client. </paragraph>
<paragraph id="P-0117" lvl="0"><number>&lsqb;0117&rsqb;</number> Finally, the server sends the requested data in <highlight><bold>880</bold></highlight>, shaped according to the best matching rule. Note that the <cross-reference target="DRAWINGS">FIG. 8</cross-reference> is only an example of one possible message flow. For example, the report of shaping parameters <highlight><bold>860</bold></highlight> could be repeated periodically or whenever there is a significant change in bandwidth. It is also possible that the server starts sending data right away <highlight><bold>880</bold></highlight>, using a shaping rule of a previous session with the same client. </paragraph>
<paragraph id="P-0118" lvl="0"><number>&lsqb;0118&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference> is an optional client process <highlight><bold>900</bold></highlight> that is executed on the client to communicate client constraints to the server. This is necessary for a network server to determine the shaping parameters. The client process is installed permanently or is deployed from the server as described in <cross-reference target="DRAWINGS">FIG. 8</cross-reference>. It provides a more detailed description of step <highlight><bold>850</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 8</cross-reference>. The optional client process <highlight><bold>900</bold></highlight> impacts the server <highlight><bold>170</bold></highlight> in so far that the communication of client constraints can trigger the events <highlight><bold>440</bold></highlight>-<highlight><bold>442</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>. </paragraph>
<paragraph id="P-0119" lvl="0"><number>&lsqb;0119&rsqb;</number> After initialization <highlight><bold>905</bold></highlight>, the client determines the bandwidth (step <highlight><bold>910</bold></highlight>) with which it is connected to the network. This can be done by detecting the modem parameters or by prompting the user for the corresponding input. The client process then determines the bandwidth used by the real time media transmission that is supposed to be protected from ordinary data transmission in step <highlight><bold>920</bold></highlight>. This can be done by analyzing the media software configuration or by prompting the user. The &lsquo;free&rsquo;bandwidth, i.e. the bandwidth available for other transmission like downloading data from the network server ist then determined in step <highlight><bold>930</bold></highlight>. As an example, if the average bandwidth used by the media transmission is 10 kbit/s and the modem speed is 28 kbit/s the &lsquo;free&rsquo; bandwidth is 18 kbit/s. Usually, packets do not arrive nicely spaced out. Therefore, the free bandwidth should be reduced to compensate for variation in the arrival of packets for both sessions to guarantee a reasonable delay and delay variation for the media transmission. </paragraph>
<paragraph id="P-0120" lvl="0"><number>&lsqb;0120&rsqb;</number> Steps <highlight><bold>920</bold></highlight> and <highlight><bold>930</bold></highlight> can also be determined by analyzing the quality of the media transmission. In this case, the client process keeps track of the average delay of media transmission packets (e.g. by using the statistics provided by the Real Time Control Protocol RTCP). When the delay increases, this signifies that the available bandwidth from the server should be decreased. When the delay decreases, the available bandwidth from the server can possibly be increased. It is even possible to give the full bandwidth to the server in cases where the media transmission is paused temporarily (e.g. pause within a phone call, pause due to rewinding of a video tape on the client/source, etc.). </paragraph>
<paragraph id="P-0121" lvl="0"><number>&lsqb;0121&rsqb;</number> In step <highlight><bold>940</bold></highlight>, the available bandwidth is reported to the server. The client program can calculate the shaping parameters either directly, or provide the server with the acquired information. Reports might be sent in regular intervals or only when the available bandwidth between the client and the server changes significantly. </paragraph>
<paragraph id="P-0122" lvl="0"><number>&lsqb;0122&rsqb;</number> In the preceding descriptions shaping rules have been explained in greater detail (e.g. in <cross-reference target="DRAWINGS">FIG. 7</cross-reference>). Note, that a rule can be used for other purposes as well. The main goal of a rule is to control the behavior of a set of sockets using a bidirectional association. Above, different behavior was related to setting different bandwidth limits to different sets. Actually, different rules pertaining to the same flow can form a rule set. </paragraph>
<paragraph id="P-0123" lvl="0"><number>&lsqb;0123&rsqb;</number> Other uses of this invention include, but are not limited to, the following. </paragraph>
<paragraph id="P-0124" lvl="2"><number>&lsqb;0124&rsqb;</number> Rate shaping a flow (a set of network sessions) with the purpose of reducing the probability that subsequent packets of the same sessions get lost due to a buffer overflow in or at the edge of the network. For streaming applications, where video and/or audio is sent while being simultaneously played out at the client side, limiting the bandwidth and pacing out the packets can limit the necessary buffers at the receiving (client) end. In addition, experiments show that rate shaping (pacing out the packets in constant intervals) reduces the average packet loss rate, the average packet delay, and the average packet delay variations. </paragraph>
<paragraph id="P-0125" lvl="2"><number>&lsqb;0125&rsqb;</number> A network server might be subject to security considerations. For example, a company WWW server might be accessed from employees within the firewall, but also from employees working remotely, outside the firewall. Setting up rules allows to selectively encrypt, authenticate flows to outside employees to guarantee privacy and authenticity. Instead of defining bandwidth parameters, the shaping parameters would consist of security parameters like the encryption technology, the encryption keys, etc. </paragraph>
<paragraph id="P-0126" lvl="2"><number>&lsqb;0126&rsqb;</number> Rate shaping a flow (a set of network sessions) with the purpose of differentiating priorities of packets between different flows. This can be useful e.g. to give faster access to customers who order products over a web site, than to visitors of the web site who are just looking for general information. An end system usually has access to information that a router in the network does not possess. Therefore, it is possible to describe a flow based on the application type as specified at the end system. The flow parameters of a rule do not necessarily need to contain all parameters. It is always possible to put a wildcard value in an unknown parameter. Therefore, it is possible to give priority to a secure WWW transaction (listening on port <highlight><bold>443</bold></highlight>) over a regular WWW transaction (listening on port <highlight><bold>80</bold></highlight>) by limiting the bandwidth of all flows using source port <highlight><bold>80</bold></highlight>. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">We claim: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A server connected through one or more network interfaces to one or more networks, each of the networks connected to one or more clients, the server having one or more memories and one or more central processing units (CPUs) and further comprising: 
<claim-text>one or more applications executed by one or more of the CPUs, each application using one or more sockets connected to the networks to communicate over the networks; </claim-text>
<claim-text>one or more rule sets containing one or more rules; and </claim-text>
<claim-text>one or more socket sets of one or more of the connected sockets, each of the socket sets associated with only one of the rule sets, the rule set controlling one or more ; packets sent by the applications on each of the sockets in the associated socket set. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. A server, as in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, where the association between a rule set and a socket is based on any one or more of the following attributes of the socket: a source address of the server, a destination address of the client, a source port of the server, a destination port of the client, a protocol type, and an application type. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. A server, as in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, where the rule set controls the timing of the sending procedure of the packets to the network or the sending of received packets to the application on any socket in the associated socket set in one or more of the following ways: limiting the average rate of delivered packets, limiting the peak rate of delivered packets, limiting the size of the burst of packets delivered at the peak rate, and limiting the size of sent packets. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. A server, as in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, where the rule set controls the security of the packets sent on any of the sockets in the associated socket set in one or more of the following ways: using an encryption key, using the encryption technique, how often to encrypt, packet authentication, how often to authenticate packets, method of authentication, when to prevent packet sending. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. A server, as in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, where the rule set controls all the packets sent from any socket in the associated socket set in the same way. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. A server, as in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, where the association between one or more of the socket sets and the rule set is bidirectional. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. A server connected through one or more network interfaces to one or more networks, each of the networks connected to one or more clients, the server having one or more memories and one or more central processing units (CPUs) and further comprising: 
<claim-text>one or more applications executed by one or more of the CPUs, each application using one or more sockets to communicate over the network; </claim-text>
<claim-text>one or more rule sets of one or more rules, one or more of the rules containing one or more client constraints; and </claim-text>
<claim-text>one or more socket sets of one or more of the connected sockets, each of the socket sets associated with only one of the rule sets, the rule set controlling one or more packets sent by each of the sockets in the associated socket set. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. A server, as in <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference>, where the client constraints include any one or more of the following: a client with limited access bandwidth to the network, a client with limited bandwidth to the server, one or more other network sessions involving the client, a client with limited computational power, and a client with limited memory. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. A server, as in <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference>, where the client constraints are communicated to the server from a client constraint determinator that executes on the client to determine the client constraints. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. A server, as in <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference>, where the client constraints are communicated to the server from an agent computer that has a concurrent second session with the client. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. A server, as in <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference>, where the client constraints are assumed or extrapolated based on previous observations, or communication with clients with similar constraints, or clients located close to each other. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. A server, as in <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference>, where the client constraints are determined using human input. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. A server, as in <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference>, where client constraint is a client bandwidth constraint and the rule set controls the packets to be sent slower because the client has concurrent audio and/or video sessions. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. A server, as in <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference>, where the rule set controls using any one or more of the following shaping mechanisms: limiting the average rate of sent packets, limiting the peak rate of packets, limiting the size of the burst of packets that are sent out at the peak rate, and limiting the size of the packets sent. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. A server, as in <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference>, where the client constraints are thin client constraints. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. A server, as in <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference>, where the thin client constraints are imposed by any one or more of the following thin clients, that are tier-zero devices: a set-top box, a hand held device, a Palm Pilot, a Web appliance, and a Web-based application device. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. A server, as in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, where the rule set controls the temporal spacing of successive packets to slow down the transmission. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. A server, as in <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference>, where one of the applications is one of the following: a video stream, an audio stream, a video and audio stream, and a large data stream. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. A method, executed by a computer system, the computer system having one or more network connections to one or more networks, the method comprising the steps of: 
<claim-text>verifying that there is information to be communicated between one or more applications executing on the computer system over one or more of the network connections; </claim-text>
<claim-text>verifying that the information can be communicated as determined by one or more rules in a rule set associated with the connection; and </claim-text>
<claim-text>communicating the information if the rules are satisfied. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. A method, as in <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference>, where the information is modified to modified information if the rules are not satisfied, the modified information satisfying the rules. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. A computer connected through a connection on one or more network interfaces to one or more networks, the computer comprising: 
<claim-text>means for verifying that there is information to be communicated between one or more applications executing on the computer system over one or more of the network connections; </claim-text>
<claim-text>means for verifying that the information can be communicated as determined by one or more rules in a rule set associated with the connection; and </claim-text>
<claim-text>means for communicating the information if the rules are satisfied.</claim-text>
</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>4</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005144A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005144A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005144A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005144A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005144A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005144A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030005144A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030005144A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030005144A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00009">
<image id="EMI-D00009" file="US20030005144A1-20030102-D00009.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
