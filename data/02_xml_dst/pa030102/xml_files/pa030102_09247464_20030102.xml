<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005172A1-20030102-D00000.TIF SYSTEM "US20030005172A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005172A1-20030102-D00001.TIF SYSTEM "US20030005172A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005172A1-20030102-D00002.TIF SYSTEM "US20030005172A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005172A1-20030102-D00003.TIF SYSTEM "US20030005172A1-20030102-D00003.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005172</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09247464</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>19990209</filing-date>
<continued-prosecution-application>This is a publication of a continued prosecution application (CPA) filed under 37 CFR 1.53(d).</continued-prosecution-application>
</domestic-filing-data>
<foreign-priority-data>
<priority-application-number>
<doc-number>9815825.6</doc-number>
</priority-application-number>
<filing-date>19980722</filing-date>
<country-code>GB</country-code>
</foreign-priority-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F009/00</ipc>
</classification-ipc-primary>
<classification-ipc-secondary>
<ipc>G06F009/54</ipc>
</classification-ipc-secondary>
<classification-ipc-secondary>
<ipc>G06F015/163</ipc>
</classification-ipc-secondary>
<classification-ipc-secondary>
<ipc>G06F009/46</ipc>
</classification-ipc-secondary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>709</class>
<subclass>316000</subclass>
</uspc>
</classification-us-primary>
<classification-us-secondary>
<uspc>
<class>709</class>
<subclass>101000</subclass>
</uspc>
</classification-us-secondary>
</classification-us>
<title-of-invention>APPARATUS, METHOD AND COMPUTER PROGRAM PRODUCT FOR CLIENT/SERVER COMPUTING WITH IMPROVED CORRESPONDENCE BETWEEN TRANSACTION IDENTIFIERS WHEN SUPPORTING SUBORDINATE RESOURCE MANAGER(S)</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>AMANDA ELIZABETH</given-name>
<family-name>CHESSELL</family-name>
</name>
<residence>
<residence-non-us>
<city>ALTON</city>
<country-code>GB</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
</inventors>
<correspondence-address>
<name-1>IBM CORPORATION</name-1>
<name-2></name-2>
<address>
<address-1>3039 CORNWALLIS RD.</address-1>
<address-2>DEPT. T81 / B503, PO BOX 12195</address-2>
<city>REASEARCH TRIANGLE PARK</city>
<state>NC</state>
<postalcode>27709</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A server for use in a client/server computing system which coordinates the processing of distributed transactions in the client/server computing system, has: (a) a basic transaction service having a table which associates a server thread with transactional information identifying a transaction currently assigned to the server thread, the transactional information being in a format of the basic transaction service, and the information including a first transactional identifier; and (b) means for maintaining synchronism between the transactional information in the format of the basic transaction service and transactional information in a format of a subordinate resource manager when a server thread switches from one transaction to another transaction, including a mapping means for mapping between the first transactional identifier and a second transactional identifier, wherein the second transactional identifier is associated with a class defining at least one abstract method, the class having a subclass which provides transactional information in the format of the subordinate resource manager. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">FIELD OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> The invention relates to the field of client/server (also known as &ldquo;distributed&rdquo;) computing, where one computing device (&ldquo;the client&rdquo;) requests another computing device (&ldquo;the server&rdquo;) to perform part of the client&apos;s work. The client and server can also be both located on the same physical computing device. </paragraph>
</section>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> Client/server computing has become more and more important over the past few years in the information technology world. This type of distributed computing allows one machine to delegate some of its work to another machine that might be, for example, better suited to perform that work. For example, the server could be a high-powered computer running a database program managing the storage of a vast amount of data, while the client is simply a desktop personal computer (PC) which requests information from the database to use in one of its local programs. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> The benefits of client/server computing have been even further enhanced by the use of a well-known computer programming technology called object-oriented programming (OOP), which allows the client and server to be located on different (heterogeneous) &ldquo;platforms&rdquo;. A platform is a combination of the specific hardware/software/operating system/communication protocol which a machine uses to do its work. OOP allows the client application program and server application program to operate on their own platforms without worrying how the client application&apos;s work requests will be communicated and accepted by the server application. Likewise, the server application does not have to worry about how the OOP system will receive, translate and send the server application&apos;s processing results back to the requesting client application. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> Details of how OOP techniques have been integrated with heterogeneous client/server systems are explained in U.S. Pat. No. 5,440,744 and European Patent Published Application No. EP 0 677,943 A2. These latter two publications are hereby incorporated by reference. However, an example of the basic architecture will be given below for contextual understanding of the invention&apos;s environment. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> As shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, the client computer <highlight><bold>10</bold></highlight> (which could, for example, be a personal computer having the IBM OS/2 operating system installed thereon) has an application program <highlight><bold>40</bold></highlight> running on its operating system (&ldquo;IBM&rdquo; and &ldquo;OS/2&rdquo; are trademarks of the International Business Machines corporation). The application program <highlight><bold>40</bold></highlight> will periodically require work to be performed on the server computer <highlight><bold>20</bold></highlight> and/or data to be returned from the server <highlight><bold>20</bold></highlight> for subsequent use by the application program <highlight><bold>40</bold></highlight>. The server computer <highlight><bold>20</bold></highlight> can be, for example, a high-powered mainframe computer running on IBM&apos;s MVS operating system (&ldquo;MVS&rdquo; is also a trademark of the IBM corp.). For the purposes of the present invention it is irrelevant whether the requests for communications services to be carried out by the server are instigated by user interaction with the first application program <highlight><bold>40</bold></highlight>, or whether the application program <highlight><bold>40</bold></highlight> operates independently of user interaction and makes the requests automatically during the running of the program. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> When the client computer <highlight><bold>10</bold></highlight> wishes to make a request for the server computer <highlight><bold>20</bold></highlight>&apos;s services, the first application program <highlight><bold>40</bold></highlight> informs the first logic means <highlight><bold>50</bold></highlight> of the service required. It may for example do this by sending the first logic means the name of a remote procedure along with a list of input and output parameters. The first logic means <highlight><bold>50</bold></highlight> then handles the task of establishing the necessary communications with the second computer <highlight><bold>20</bold></highlight> with reference to definitions of the available communications services stored in the storage device <highlight><bold>60</bold></highlight>. All the possible services are defined as a cohesive framework of object classes <highlight><bold>70</bold></highlight>, these classes being derived from a single object class. Defining the services in this way gives rise to a great number of advantages in terms of performance and reusability. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> To establish the necessary communication with the server <highlight><bold>20</bold></highlight>, the first logic means <highlight><bold>50</bold></highlight> determines which object class in the framework needs to be used, and then creates an instance of that object at the server, a message being sent to that object so as to cause that object to invoke one of its methods. This gives rise to the establishment of the connection with the server computer <highlight><bold>20</bold></highlight> via the connection means <highlight><bold>80</bold></highlight>, and the subsequent sending of a request to the second logic means <highlight><bold>90</bold></highlight>. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> The second logic means <highlight><bold>90</bold></highlight> then passes the request on to the second application program <highlight><bold>100</bold></highlight> (hereafter called the service application) running on the server computer <highlight><bold>20</bold></highlight> so that the service application <highlight><bold>100</bold></highlight> can perform the specific task required by that request, such as running a data retrieval procedure. Once this task has been completed the service application may need to send results back to the first computer <highlight><bold>10</bold></highlight>. The server application <highlight><bold>100</bold></highlight> interacts with the second logic means <highlight><bold>90</bold></highlight> during the performance of the requested tasks and when results are to be sent back to the first computer <highlight><bold>10</bold></highlight>. The second logic means <highlight><bold>90</bold></highlight> establishes instances of objects, and invokes appropriate methods of those objects, as and when required by the server application <highlight><bold>100</bold></highlight>, the object instances being created from the cohesive framework of object classes stored in the storage device <highlight><bold>110</bold></highlight>. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> Using the above technique, the client application program <highlight><bold>40</bold></highlight> is not exposed to the communications architecture. Further the service application <highlight><bold>100</bold></highlight> is invoked through the standard mechanism for its environment; it does not know that it is being invoked remotely. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> The Object Management Group (OMG) is an international consortium of organizations involved in various aspects of client/server computing on heterogeneous platforms with distributed objects as is shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. The OMG has set forth published standards by which client computers (e.g. <highlight><bold>10</bold></highlight>) communicate (in OOP form) with server machines (e.g. <highlight><bold>20</bold></highlight>). As part of these standards, an Object Request Broker (called CORBA- the Common Object Request Broker Architecture) has been defined, which provides the object-oriented bridge between the client and the server machines. The ORB decouples the client and server applications from the object oriented implementation details, performing at least part of the work of the first and second logic means <highlight><bold>50</bold></highlight> and <highlight><bold>90</bold></highlight> as well as the connection means <highlight><bold>80</bold></highlight>. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> As part of the CORBA software structure, the OMG has set forth standards related to &ldquo;transactions&rdquo; and these standards are known as the OTS or Object Transaction Service. See, e.g., CORBA Object Transaction Service Specification 1.0, OMG Document 94.8.4. Computer implemented transaction processing systems are used for critical business tasks in a number of industries. A transaction defines a single unit of work that must either be fully completed or fully purged without action. For example, in the case of a bank automated teller machine from which a customer seeks to withdraw money, the actions of issuing the money, reducing the balance of money on hand in the machine and reducing the customer&apos;s bank balance must all occur or none of them must occur. Failure of one of the subordinate actions would lead to inconsistency between the records and the actual occurrences. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> Distributed transaction processing involves a transaction that affects resources at more than one physical or logical location. In the above example, a transaction affects resources managed at the local automated teller device as well as bank balances managed by a bank&apos;s main computer. Such transactions involve one particular client computer (e.g., <highlight><bold>10</bold></highlight>) communicating with one particular server computer (e.g., <highlight><bold>20</bold></highlight>) over a series of client requests which are processed by the server. The OMG&apos;s OTS is responsible for co-ordinating these distributed transactions. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> Usually, an application running on a client process begins a transaction which may involve calling a plurality of different servers, each of which will initiate a server process to make changes to its local database according to the instructions contained in the transaction. The transaction finishes by either committing the transaction (and thus all servers finalize the changes to their local databases) or aborting the transaction (and thus all servers &ldquo;rollback&rdquo; or ignore the changes to their local databases). To communicate with the servers during the transaction (e.g., instructing them to either commit or abort their part in the transaction) one of the processes involved must maintain state data for the transaction. This usually involves the process to set up a series of transaction state objects, one of which is a Coordinator object which coordinates the transaction with respect to the various server processes. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> The basic software architecture involved in providing an implementation of the OTS is shown in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>. A client process <highlight><bold>21</bold></highlight> which wants to begin a transaction (e.g., to withdraw money from a bank account) locates a process which is capable of creating and holding the transaction objects that will maintain the state of the transaction. As the modern tendency is to create clients that are &ldquo;thin&rdquo; (and thus have only the minimum functionality), the client process <highlight><bold>21</bold></highlight> will usually not be able to maintain the transaction objects locally and must look for a server process for this purpose. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> The OTS (or another service, such as the CORBA Lifecycle service) selects server A process <highlight><bold>22</bold></highlight> on which to create the transaction state objects <highlight><bold>221</bold></highlight> (which include the Coordinator object, Control object and Terminator object). Upon locating the server A process <highlight><bold>22</bold></highlight>, client process <highlight><bold>21</bold></highlight> sends (arrow with encircled number <highlight><bold>1</bold></highlight>) a message to server A process <highlight><bold>22</bold></highlight> to instruct server A process <highlight><bold>22</bold></highlight> to create the transaction state objects <highlight><bold>221</bold></highlight>. The Control object (known in the OTS as CosTransactions::Control) provides access to the other two transaction state objects. The Terminator object (known in the OTS as CosTransactions::Terminator) is used to end the transaction. The Coordinator object (known in the OTS as CosTransactions::Coordinator) maintains a list, in local storage <highlight><bold>222</bold></highlight>, of resource objects (known in the OTS as CosTransactions::Resource) that have made updates to their respective data during the transaction. This list is required so that the Coordinator object can consistently call the resource objects at the end of the transaction to command them to commit their transactional changes (make their local data changes final) or to rollback such changes (bring the local data back to the state it was in before the transaction started). A rollback would be necessary, for example, where the transaction could not finish because one of the resources was not working properly. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> Server A process <highlight><bold>22</bold></highlight> then creates the transaction state objects <highlight><bold>221</bold></highlight> and sends a reply (arrow with encircled number <highlight><bold>2</bold></highlight>) containing the transaction context to client <highlight><bold>21</bold></highlight>. Client <highlight><bold>21</bold></highlight> then sends, for example, a debit bank account command (arrow with encircled number <highlight><bold>3</bold></highlight>) to server B process <highlight><bold>23</bold></highlight> (the process containing the resource, for example, bank account, object <highlight><bold>231</bold></highlight> which the client process <highlight><bold>21</bold></highlight> wishes to withdraw money from). This latter command carries with it the transaction context supplied to the client <highlight><bold>21</bold></highlight> by the server A process <highlight><bold>22</bold></highlight>. In this way, the resource object <highlight><bold>231</bold></highlight> in process <highlight><bold>23</bold></highlight> can register itself (arrow with encircled number <highlight><bold>4</bold></highlight>) with the transaction objects <highlight><bold>221</bold></highlight> in process <highlight><bold>22</bold></highlight> so that the resource object <highlight><bold>231</bold></highlight> can be commanded (arrow with encircled number <highlight><bold>5</bold></highlight>) to commit or rollback by the transaction state objects <highlight><bold>221</bold></highlight> at the end of the transaction. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> In the above operation, when the transaction state objects <highlight><bold>221</bold></highlight> are created, they must log information about themselves and the transaction they represent in local storage <highlight><bold>222</bold></highlight>, so that the transaction will be recoverable in case of a server failure which temporarily prevents the server A process <highlight><bold>22</bold></highlight> from continuing with the transaction. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> As part of the transaction, the client process <highlight><bold>21</bold></highlight> then makes similar calls to server C process <highlight><bold>24</bold></highlight> (to access the resource object <highlight><bold>241</bold></highlight>) and server D process <highlight><bold>24</bold></highlight> (to access the resource object <highlight><bold>251</bold></highlight>). Server B process <highlight><bold>23</bold></highlight>, in carrying out its part of the transaction, may need to call another server process, such as server E process <highlight><bold>26</bold></highlight>, to access the resource objects <highlight><bold>261</bold></highlight>, <highlight><bold>262</bold></highlight> and <highlight><bold>263</bold></highlight> located in process <highlight><bold>26</bold></highlight>. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> Since the number of server processes and resources involved in <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is becoming large, the need for careful synchronization of all of the database changes involved becomes readily apparent. The usual way to go about achieving this synchronization is to carry out a two-phase commit process when the client <highlight><bold>21</bold></highlight> issues a command to end the transaction. The transaction objects <highlight><bold>221</bold></highlight> first command (phase <highlight><bold>1</bold></highlight>) each of their directly registered resources (<highlight><bold>231</bold></highlight>, <highlight><bold>241</bold></highlight> and <highlight><bold>251</bold></highlight> in the <cross-reference target="DRAWINGS">FIG. 2</cross-reference> example) to prepare to commit their database changes. Phase <highlight><bold>1</bold></highlight> is also known as the prepare stage of a transaction, as the resources are being prepared for the finalization of their data changes, which will take place in phase <highlight><bold>2</bold></highlight>. Each of these resources then responds to the transaction objects <highlight><bold>221</bold></highlight> to indicate that it has prepared to commit its changes, and the resources will not allow any more changes to be made to the databases. This response is, in effect, a vote, signifying that this particular resource is voting that the transaction should be committed. After issuing their votes, the resources are then said to be sitting &ldquo;in doubt&rdquo; (also known as in a &ldquo;prepared&rdquo; state) waiting for the transaction objects <highlight><bold>221</bold></highlight> to give a synchronized final command (phase <highlight><bold>2</bold></highlight>) to commit all database changes made during the transaction. This latter final command is only given if all resources have voted that the transaction should be committed. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> Server B process <highlight><bold>23</bold></highlight>, which has called another server process <highlight><bold>26</bold></highlight>, would carry out its own two-phase commit protocol with respect to the resource objects <highlight><bold>261</bold></highlight>, <highlight><bold>262</bold></highlight>, and <highlight><bold>263</bold></highlight>, as part of its participation in the main two-phase commit protocol discussed above. That is, server B process <highlight><bold>23</bold></highlight> would send a prepare command to its directly registered resources <highlight><bold>261</bold></highlight>, <highlight><bold>262</bold></highlight> and <highlight><bold>263</bold></highlight>, and receive a vote from each of them, before server B process <highlight><bold>23</bold></highlight> sends a consolidated reply to server A process <highlight><bold>22</bold></highlight>. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> Rather than voting that a transaction be committed, a resource can also vote that a transaction should be rolled back. A rollback vote would be issued by a resource if that resource had a problem while making its data changes during the transaction (e.g., some type of write error had occurred while a resource was making a local data change). The receipt of a rollback vote from at least one resource will cause the transaction objects <highlight><bold>221</bold></highlight> to rollback the entire transaction. This is in keeping with the fact that a transaction is an all or nothing prospect: either all resource changes in a transaction are committed or none are. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> Oftentimes, it is useful for a server running an implementation of the CORBA OTS to access resources being managed by a resource manager which uses a transaction service different from the CORBA transaction service. Each such transaction service is unique in that it has its own way of recovering from system crashes, its own way of identifying a transaction and for basically allowing servers to communicate with each other during the running of a transaction. IBM&apos;s Component Broker Connector product (&ldquo;component Broker Connector&rdquo; is a trademark of IBM Corp.), which was first announced in May of 1997, exploits the idea that transactions on external (also known as subordinate) resource managers such as XA enabled databases (which are described in Distributed Transactions Processing: The XA&plus; Specification Version 2, ISBN 1-85912-046-6, Document Number: S423, published in the United Kingdom by the Open Group, June 1994) can be controlled by a CORBA OTS implementation through the use of specialist implementations of the CosTransactions::Resource interface which are local to (i.e., in the same server process as) and registered with the CosTransactions::Coordinator object for the appropriate local transaction. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> In a server running a transaction service (e.g., a Component Broker server running an implementation of the CORBA OTS), there is a design assumption that the work being done by a thread in the server is automatically assumed to be part of the transaction that has been associated with the thread. This transaction is called the current transaction and one of the responsibilities of the CORBA OTS is to return information about the current transaction when requested. The CORBA OTS, therefore, maintains a mapping between the threads in the server and the transactions associated with them. For example, the CORBA OTS keeps the following map:  
<table-cwu id="TABLE-US-00001">
<number>1</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="91PT" align="center"/>
<colspec colname="2" colwidth="126PT" align="left"/>
<thead>
<row>
<entry namest="1" nameend="2" align="center">TABLE 1</entry>
</row>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
<row>
<entry>thread identifier</entry>
<entry>transaction information</entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>x</entry>
<entry>transaction name (a character string)</entry>
</row>
<row>
<entry></entry>
<entry>costransactions: :otid_t</entry>
</row>
<row>
<entry></entry>
<entry>local id (an integer)</entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0024" lvl="7"><number>&lsqb;0024&rsqb;</number> Thus, for each thread identifier (e.g., thread x), a group of transaction information for the current transaction running on the corresponding thread is stored in the mapping table. This group of transaction information includes a transaction name (which is represented by a character string), the costransactions::otid_t identifier (used by the CORBA OTS to identify a transaction) and a local id (an integer used for quick reference to a transaction). The CORBA OTS implementation can then be asked to provide the transaction information of the current transaction running on a thread. It is very common for a thread to frequently switch between transactions, and when a thread switches to a new transaction, the above mapping table must be updated with the new transaction information to reflect the fact that the thread now has a different transaction as its current transaction. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> The software code that interfaces between the CORBA OTS and the SRM products also needs to maintain a mapping between the thread identifier and the current transaction. However, the information that each SRM needs about the transaction relates to that SRM&apos;s version of the transaction identification data and not the CORBA OTS&apos;s version of such data. As stated above, each transaction service has its own format for identifying a transaction. The CORBA OTS uses the CosTransactions::otid_t format, the XA specification, used primarily by databases, uses the XID format and IBM&apos;s SNA sync point (sync-level <highlight><bold>2</bold></highlight>) services architecture uses the LUWId format. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> As there are many different types of transaction services available, it is highly conceivable that it will be necessary to provide support for the CORBA OTS to call a plurality of different subordinate resource managers potentially in the same transaction, each SRM having its own transaction service associated therewith. For example, it might also be useful to provide support for SNA sync-level <highlight><bold>2</bold></highlight> enabled resource managers (also known as APPC) as well as an XA-based SRM. Co-pending IBM patent application docket number UK9-98-056, filed as UK patent application no. GB 9815207.7 on Jul. 15, 1998, places a mapping layer between the CORBA OTS and the various SRMs so that the SRMs can easily be added to the overall server architecture without requiring modification to the basic OTS transaction service. However, since each SRM has its own format for identifying a transaction, separate mapping lists of thread identifier versus transaction information would have to be maintained for each supported SRM. Whenever a transaction is moved from one thread to another in the server by the OTS, each such mapping list needs to be updated in addition to the updating of the OTS&apos;s own mapping table (i.e., Table 1). This creates a large administrative burden in trying to keeping all of such lists in synchronization with each other, and in synchronization with the OTS&apos;s main list (e.g., Table 1). Also, the plurality of lists itself adds much complexity to the overall software architecture of a transaction server apparatus, thus making such apparatus more expensive to design and maintain. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> There is a great need in this art for a transaction server which is more efficiently implemented so that it can better support subordinate resource manager(s) to take part in a transaction. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> According to a first aspect, the present invention provides a server for use in a client/server computing system which coordinates the processing of distributed transactions in the client/server computing system, the server has: </paragraph>
<paragraph id="P-0029" lvl="2"><number>&lsqb;0029&rsqb;</number> (a) a basic transaction service having a table which associates a server thread with transactional information identifying a transaction currently assigned to the server thread, the transactional information being in a format of the basic transaction service, and the information including a first transactional identifier; and </paragraph>
<paragraph id="P-0030" lvl="2"><number>&lsqb;0030&rsqb;</number> (b) means for maintaining synchronism between the transactional information in the format of the basic transaction service and transactional information in a format of a subordinate resource manager when a server thread switches from one transaction to another transaction, including a mapping means for mapping between the first transactional identifier and a second transactional identifier, wherein the second transactional identifier is associated with a class defining at least one abstract method, the class having a subclass which provides transactional information in the format of the subordinate resource manager. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> According to a second aspect, the invention provides a method of operating a server for use in a client/server computing system which coordinates the processing of distributed transactions in the client/server computing system, the method comprising steps of: receiving a request for transactional information of a current transaction in a format of a subordinate resource manager;looking up a first transactional identifier in a table which associates a server thread with transactional information identifying a transaction currently assigned to the server thread, the transactional information being in a format of the basic transaction service, and the information including the first transactional identifier; using the first transactional identifier to look up a second transactional identifier in a table for mapping between the first transactional identifier and a second transactional identifier, wherein the second transactional identifier is associated with a class defining at least one abstract method, the class having a subclass which provides transactional information in the format of the subordinate resource manager; obtaining the transactional information of the current transaction in the format of the subordinate resource manager from an implementation of the subclass; and returning the transactional information of the current transaction in the format of a subordinate resource manager as requested. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> According to a third aspect, the invention provides a computer program product stored on a computer readable storage medium for, when run on a computer, carrying out the functionality of the second aspect. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> Thus, with the present invention, whenever the basic transaction service (e.g., the OTS) changes the thread/transaction association, only the basic transaction service mapping list (i.e., Table <highlight><bold>1</bold></highlight>) need be updated, and there is no need to make corresponding changes in similar mapping lists for each supported SRM. There is a single implementation of the code that manages the mapping between an SRM&apos;s transaction information format and the OTS&apos;s transaction information format. This saves development time and greatly simplifies the process of maintaining the server apparatus.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> The invention will be better understood by the below description of preferred embodiments thereof to be read while referring to the following figures. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a block diagram of a well-known heterogeneous client/server architecture using object technology, in the context of which preferred embodiments of the present invention can be applied; </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a block diagram showing an implementation of an object-based transaction server which serves as background to the present invention; </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a block diagram showing a transaction server implementation according to a preferred embodiment of the present invention; and </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a class diagram showing the class relationship between some of the classes according to a preferred embodiment of the present invention.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS </heading>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> The preferred embodiment of the present invention describes an enhancement (i.e., OTS Subordinate Resource Manager, called hereinafter, OTS-SRM, software block <highlight><bold>32</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>) to a basic transaction service CORBA OTS implementation (e.g., software block <highlight><bold>31</bold></highlight>) so that transactional information in the format used by any number of subordinate resource managers (e.g., software blocks <highlight><bold>33</bold></highlight>, <highlight><bold>34</bold></highlight> and <highlight><bold>35</bold></highlight>) can be easily kept synchronized with the dynamically changing list of thread identifier versus transactional information in the format used by the basic transaction service in the CORBA OTS <highlight><bold>31</bold></highlight>. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> The software block <highlight><bold>32</bold></highlight> is provided with classes from which objects can be instantiated in order to provide a single implementation of the code that manages the mapping between an SRM&apos;s transaction information and the OTS&apos;s transaction information. This saves development time and simplifies the process of maintaining the product. This mapping is static so that only the OTS code (i.e., Table 1) is affected when transactions move from thread to thread. This reduces the chance of the transactional information in the SRMs&apos;formats getting out of step with the transactional information in the format of the basic transaction service. The SRM code is isolated from the mechanism used to look up the &ldquo;e-current transaction&rdquo; in the OTS. This means that the SRM code can be reused in a different transaction service implementation. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> The OTS <highlight><bold>31</bold></highlight> still maintains a mapping object <highlight><bold>311</bold></highlight> of threadId to transaction information (as it did for example in Table 1 discussed above), such a map being held in an object. One of the fields in this transaction information stores a unique number for the transaction called the localId. The OTS-SRM <highlight><bold>32</bold></highlight> also provides, for each SRM, an implementation of a class called OTSSRMGlobalIdmap, which manages a map of localIds to OTSSRMGlobalId objects (described below). The OTSSRMGlobalIdmap object also contains methods and data for extracting the transaction information from the OTS <highlight><bold>31</bold></highlight> (and caches it for performance). The implementation of the OTSSRMGlobalId class is also provided by the OTS extension <highlight><bold>32</bold></highlight>. Each SRM mapping code portion (i.e., OTS-XA <highlight><bold>321</bold></highlight> and OTS-APPC <highlight><bold>322</bold></highlight>) of the OTS extension <highlight><bold>32</bold></highlight> has an instance of the OTSSRMGlobalIdmap which is called to ask for the &ldquo;current&rdquo; GlobalId object. The OTSSRMGlobalIdMap asks the OTS <highlight><bold>31</bold></highlight> for the current localId and then looks in the map for the corresponding OTSSRMGlobalId object. If one does not exist for the transaction, it is created (which involves extracting information about the transaction from the OTS) and added to the map. Either way, an OTSSRMGlobalId object is returned to the SRM mapping code. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> An OTSSRMGlobalId object also caches information from the OTS <highlight><bold>31</bold></highlight>, as well as storing the address of an OTSSRMTranId object, which is an abstract class (a class with abstract methods). Each SRM mapping code portion provides its own tranId subclass (e.g., OTSAPPCLUWId <highlight><bold>53</bold></highlight> or OTSXAXId <highlight><bold>52</bold></highlight>) which inherits from the superclass OTSSRMTranId class <highlight><bold>51</bold></highlight>, as illustrated by the class diagram of <cross-reference target="DRAWINGS">FIG. 4</cross-reference> (of course other subclasses of superclass <highlight><bold>51</bold></highlight> can be derived should more SRMs be supported). These SRM mapping subclasses (eg OTSAPPCLUWId and OTSXAXId) hold all of the information that relates to their SRM product&apos;s view of the transaction. Because the subclasses inherit from the superclass OTSSRMTranId, the subclasses can be stored and extracted from the OTSSRMGlobalId object and so the association between different SRM&apos;s and the OTS transaction is maintained with little coding required by each SRM mapping implementation. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> The overall software architecture of the transaction server according to the preferred embodiment will now be described. The basic transaction service CORBA OTS <highlight><bold>31</bold></highlight> contains a mapping table object <highlight><bold>311</bold></highlight> which keeps track of which transaction is currently associated with each of the server&apos;s threads (as described above in conjunction with Table 1). The extension <highlight><bold>32</bold></highlight> of the OTS <highlight><bold>31</bold></highlight> has separate SRM mapping code portions, one portion <highlight><bold>321</bold></highlight> for SRM <highlight><bold>33</bold></highlight> (called OTS-XA, since it maps between the OTS and the XA SRM <highlight><bold>33</bold></highlight>) and another portion <highlight><bold>322</bold></highlight> for SRM <highlight><bold>34</bold></highlight> (called OTS-APPC, since it maps between the OTS and the SNA APPC SRM <highlight><bold>34</bold></highlight>). Other SRM mapping code portions could be provided should other SRMs (e.g., <highlight><bold>35</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>) be plugged in to the extension <highlight><bold>32</bold></highlight>. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> OTS-XA <highlight><bold>321</bold></highlight> includes a single instantiation <highlight><bold>3211</bold></highlight> of the GlobalIdMap class, an instantiation <highlight><bold>3212</bold></highlight> of the GlobalId class (one for each transaction) and an instantiation <highlight><bold>3213</bold></highlight> of the OTSSRMTranId class <highlight><bold>51</bold></highlight> (one for each transaction). OTS-APPC <highlight><bold>322</bold></highlight> includes a single instantiation <highlight><bold>3221</bold></highlight> of the GlobalIdMap class (one for each transaction), an instantiation <highlight><bold>3222</bold></highlight> of the GlobalId class (one for each transaction) and an instantiation <highlight><bold>3223</bold></highlight> of the OTSSRMTranId class <highlight><bold>51</bold></highlight> (one for each transaction). </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> The way in which these objects interact will now be further described. A calling object (not shown), that needs to know the XID for the current OTS transaction, calls the GlobalIdMap object <highlight><bold>3211</bold></highlight> of the OTS-XA mapping block <highlight><bold>321</bold></highlight> and asks the GlobalIdMap to get the globalId of the current transaction. The calling object is asking for the globalId of the current transaction because once this globalId is known, the calling object can then ask the corresponding GlobalId object for the XID of the current transaction. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> The GlobalIdMap object <highlight><bold>3211</bold></highlight> has a mapping list of localId&apos;s versus globalId&apos;s so it does not know what the globalId of the current transaction is. The GlobalIdmap object <highlight><bold>3211</bold></highlight> first needs to know the localId of the current transaction so that it can then use its mapping list to get the corresponding current globalId. Therefore, in order to determine the localId of the current transaction, the GlobalIdMap <highlight><bold>3211</bold></highlight> calls the map table object <highlight><bold>311</bold></highlight> of the OTS <highlight><bold>31</bold></highlight>, which returns the localId of the current transaction. The GlobalIdMap <highlight><bold>3211</bold></highlight> then takes this current localId and looks up the current globalId in the GlobalIdMap&apos;s mapping list of localId&apos;s versus globalId&apos;s. (If, upon looking in its mapping list, the GlobalIdMap object <highlight><bold>3211</bold></highlight> finds that there is no globalId stored against this current localId, the GlobalIdMap object <highlight><bold>3212</bold></highlight> sends a create command to a new GlobalId object in order to create a new GlobalID object to represent this current transaction). The GlobalIdMap <highlight><bold>3211</bold></highlight> then returns the current globalId to the calling object that requested it. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> The calling object that requested the current globalId then makes a call to the GlobalId object <highlight><bold>3212</bold></highlight> requesting that the GlobalId object <highlight><bold>3212</bold></highlight> provide the calling object with the TranId, which is the XID (in the case of the XA-SRM <highlight><bold>33</bold></highlight>). (If the GlobalId object <highlight><bold>3212</bold></highlight> returns a NULL reply, indicating that the OTSSRMTranId object has not yet been created, the calling object sends a create command to the XA SRM <highlight><bold>33</bold></highlight> which in turn sends an add command to the GlobalId <highlight><bold>3212</bold></highlight> to add the OTSSRMTranId). Since the GlobalId <highlight><bold>3212</bold></highlight> holds a reference to the OTSSRMTranId <highlight><bold>3213</bold></highlight>, the GlobalId <highlight><bold>3212</bold></highlight> then simply calls the OTSSRMTranId <highlight><bold>3212</bold></highlight> to obtain the XID that corresponds to the current transaction, which is then sent to the calling object. It should be noted that when the OTSSRMTranId <highlight><bold>3213</bold></highlight> is called to get the TranId, this method call is an abstract method in the OTSSRMTranId class <highlight><bold>51</bold></highlight>, meaning that the OTSSRMTranId object <highlight><bold>3213</bold></highlight> does not contain an implementation of this method, but rather the OTSSRMTranId object <highlight><bold>3213</bold></highlight> of superclass <highlight><bold>51</bold></highlight> contains a pointer to an instantiation (not shown) of its OTSXAXId subclass <highlight><bold>52</bold></highlight>, such an instantiation holding the XA transactional information (including the XID which was requested by the calling object). </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> This implementation is better than prior implementations because the SRMs are associating their transactional information with a fixed value for the transaction (the globalId) rather than trying to keep their own map of tranId information in step with the OTS. In addition, all of the mapping code and the code interacts with the OTS is common. This simplifies the implementation of the current and future SRMs. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> In summary, the OTS <highlight><bold>31</bold></highlight> has a mapping object <highlight><bold>311</bold></highlight> which maps from threadId to transaction information, such transaction information being in the format of the OTS.  
<table-cwu id="TABLE-US-00002">
<number>2</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>OTS</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="28PT" align="left"/>
<colspec colname="3" colwidth="126PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>threadId</entry>
<entry>&verbar;-&gt;</entry>
<entry>transaction information</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry></entry>
<entry>(this includes a &ldquo;localId&rdquo; number for</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry></entry>
<entry>the transaction)</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0050" lvl="7"><number>&lsqb;0050&rsqb;</number> The OTS-XA <highlight><bold>321</bold></highlight> takes a localId that it receives from the OTS&apos;s mapping object <highlight><bold>311</bold></highlight> and maps it to a GlobalId object which in turn identifies a TranId object, which is where the transaction information in the XA format is found.  
<table-cwu id="TABLE-US-00003">
<number>3</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>OTS-XA</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="28PT" align="left"/>
<colspec colname="3" colwidth="126PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>localId</entry>
<entry>&verbar;-&gt;</entry>
<entry>GlobalId object &plus; TranId object</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0051" lvl="7"><number>&lsqb;0051&rsqb;</number> Likewise, the OTS-APPC <highlight><bold>322</bold></highlight> takes a localId that it receives from the OTS&apos;s mapping object <highlight><bold>311</bold></highlight>, and maps it to a GlobalId object which in turn identifies a TranId object, which is where the transaction information in the APPC format is found.  
<table-cwu id="TABLE-US-00004">
<number>4</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>OTS-APPC</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="28PT" align="left"/>
<colspec colname="3" colwidth="126PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>localId</entry>
<entry>&verbar;-&gt;</entry>
<entry>GlobalId object &plus; TranId object</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> The integration support for each subordinate resource manager (SRM) thus provides a class that inherits from the TranId class which it creates a single instance (object) of when it is loaded in to the server. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> Thus, by providing the OTS-SRM class as an abstract class (i.e., a superclass with abstract methods), the combined software blocks <highlight><bold>31</bold></highlight> and <highlight><bold>32</bold></highlight> can be kept generic in terms of subordinate resource manager implementations. Each subordinate resource manager that then is to be supported is a member of a separate class which inherits from this common generic superclass, thus adding the specifics that relate to the transaction service of the corresponding subordinate resource manager. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> While the CORBA OTS has been described in the preferred embodiment as the basic transaction service (e.g., <highlight><bold>31</bold></highlight>) which is controlling/coordinating the transaction and making calls to subordinate resource managers, the use of other transaction services as the basic transaction service besides CORBA OTS is also possible. For example, in another embodiment, the basic transaction service could be the XA transaction service and the CORBA OTS could be the transaction service of an SRM. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">I claim: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A server apparatus for use in a client/server computing system which coordinates the processing of distributed transactions in the client/server computing system, the apparatus comprising: 
<claim-text>(a) a basic transaction service having a table which associates a server thread with transactional information identifying a transaction currently assigned to the server thread, the transactional information being in a format of the basic transaction service, and the information including a first transactional identifier; and </claim-text>
<claim-text>(b) means for maintaining synchronism between the transactional information in the format of the basic transaction service and transactional information in a format of a subordinate resource manager when a server thread switches from one transaction to another transaction, including a mapping means for mapping between the first transactional identifier and a second transactional identifier, wherein the second transactional identifier is associated with a class defining at least one abstract method, the class having a subclass which provides transactional information in the format of the subordinate resource manager. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein the basic transaction service is the Common Object Request Broker&apos;s Object Transaction Service. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein the subordinate resource manager is an XA resource manager. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein the first transactional identifier is represented by an integer. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. A method of operating a server for use in a client/server computing system which coordinates the processing of distributed transactions in the client/server computing system, the method comprising steps of: 
<claim-text>receiving a request for transactional information of a current transaction in a format of a subordinate resource manager; </claim-text>
<claim-text>looking up a first transactional identifier in a table which associates a server thread with transactional information identifying a transaction currently assigned to the server thread, the transactional information being in a format of the basic transaction service, and the information including the first transactional identifier; </claim-text>
<claim-text>using the first transactional identifier to look up a second transactional identifier in a table for mapping between the first transactional identifier and a second transactional identifier, wherein the second transactional identifier is associated with a class defining at least one abstract method, the class having a subclass which provides transactional information in the format of the subordinate resource manager; </claim-text>
<claim-text>obtaining the transactional information of the current transaction in the format of the subordinate resource manager from an implementation of the subclass; and </claim-text>
<claim-text>returning the transactional information of the current transaction in the format of a subordinate resource manager as requested. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference> wherein the basic transaction service is the Common Object Request Broker&apos;s Object Transaction Service. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference> wherein the subordinate resource manager is an XA resource manager. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference> wherein the first transactional identifier is represented by an integer. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. A computer program product stored on a computer ireadable storage medium for, when run on a computer, carrying out a server processing method for use in a client/server computing system which coordinates the processing of distributed transactions, said method comprising steps of: 
<claim-text>receiving a request for transactional information of a current transaction in a format of a subordinate resource manager; </claim-text>
<claim-text>looking up a first transactional identifier in a table which associates a server thread with transactional information identifying a transaction currently assigned to the server thread, the transactional information being in a format of the basic transaction service, and the information including the first transactional identifier; </claim-text>
<claim-text>using the first transactional identifier to look up a second transactional identifier in a table for mapping between the first transactional identifier and a second transactional identifier, wherein the second transactional identifier is associated with a class defining at least one abstract method, the class having a subclass which provides transactional information in the format of the subordinate resource manager; </claim-text>
<claim-text>obtaining the transactional information of the current transaction in the format of the subordinate resource manager from an implementation of the subclass; and </claim-text>
<claim-text>returning the transactional information of the current transaction in the format of a subordinate resource manager as requested.</claim-text>
</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>2</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005172A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005172A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005172A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005172A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
