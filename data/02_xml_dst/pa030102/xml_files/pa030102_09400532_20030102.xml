<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030004931A1-20030102-P00001.TIF SYSTEM "US20030004931A1-20030102-P00001.TIF" NDATA TIF>
<!ENTITY US20030004931A1-20030102-P00002.TIF SYSTEM "US20030004931A1-20030102-P00002.TIF" NDATA TIF>
<!ENTITY US20030004931A1-20030102-P00003.TIF SYSTEM "US20030004931A1-20030102-P00003.TIF" NDATA TIF>
<!ENTITY US20030004931A1-20030102-P00004.TIF SYSTEM "US20030004931A1-20030102-P00004.TIF" NDATA TIF>
<!ENTITY US20030004931A1-20030102-P00005.TIF SYSTEM "US20030004931A1-20030102-P00005.TIF" NDATA TIF>
<!ENTITY US20030004931A1-20030102-P00006.TIF SYSTEM "US20030004931A1-20030102-P00006.TIF" NDATA TIF>
<!ENTITY US20030004931A1-20030102-P00007.TIF SYSTEM "US20030004931A1-20030102-P00007.TIF" NDATA TIF>
<!ENTITY US20030004931A1-20030102-P00008.TIF SYSTEM "US20030004931A1-20030102-P00008.TIF" NDATA TIF>
<!ENTITY US20030004931A1-20030102-P00009.TIF SYSTEM "US20030004931A1-20030102-P00009.TIF" NDATA TIF>
<!ENTITY US20030004931A1-20030102-P00010.TIF SYSTEM "US20030004931A1-20030102-P00010.TIF" NDATA TIF>
<!ENTITY US20030004931A1-20030102-P00011.TIF SYSTEM "US20030004931A1-20030102-P00011.TIF" NDATA TIF>
<!ENTITY US20030004931A1-20030102-P00012.TIF SYSTEM "US20030004931A1-20030102-P00012.TIF" NDATA TIF>
<!ENTITY US20030004931A1-20030102-P00013.TIF SYSTEM "US20030004931A1-20030102-P00013.TIF" NDATA TIF>
<!ENTITY US20030004931A1-20030102-P00014.TIF SYSTEM "US20030004931A1-20030102-P00014.TIF" NDATA TIF>
<!ENTITY US20030004931A1-20030102-P00015.TIF SYSTEM "US20030004931A1-20030102-P00015.TIF" NDATA TIF>
<!ENTITY US20030004931A1-20030102-D00000.TIF SYSTEM "US20030004931A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030004931A1-20030102-D00001.TIF SYSTEM "US20030004931A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030004931A1-20030102-D00002.TIF SYSTEM "US20030004931A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030004931A1-20030102-D00003.TIF SYSTEM "US20030004931A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030004931A1-20030102-D00004.TIF SYSTEM "US20030004931A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030004931A1-20030102-D00005.TIF SYSTEM "US20030004931A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030004931A1-20030102-D00006.TIF SYSTEM "US20030004931A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030004931A1-20030102-D00007.TIF SYSTEM "US20030004931A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030004931A1-20030102-D00008.TIF SYSTEM "US20030004931A1-20030102-D00008.TIF" NDATA TIF>
<!ENTITY US20030004931A1-20030102-D00009.TIF SYSTEM "US20030004931A1-20030102-D00009.TIF" NDATA TIF>
<!ENTITY US20030004931A1-20030102-D00010.TIF SYSTEM "US20030004931A1-20030102-D00010.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030004931</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09400532</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>19990921</filing-date>
<continued-prosecution-application>This is a publication of a continued prosecution application (CPA) filed under 37 CFR 1.53(d).</continued-prosecution-application>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F007/00</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>707</class>
<subclass>003000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>MANAGING RESULTS OF FEDERATED SEARCHES ACROSS HETEROGENEOUS DATASTORES WITH A FEDERATED RESULT SET CURSOR OBJECT</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>BASUKI N.</given-name>
<family-name>SOETARMAN</family-name>
</name>
<residence>
<residence-us>
<city>LOS GATOS</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>ROBERT NELSON</given-name>
<family-name>SUMMERS</family-name>
</name>
<residence>
<residence-us>
<city>SAN JOSE</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>SUGHRUE MION ZINN MACPEAK &amp; SEAS</name-1>
<name-2></name-2>
<address>
<address-1>2100 PENNSYLVANIA AVENUE NW</address-1>
<city>WASHINGTON</city>
<state>DC</state>
<postalcode>20037-3213</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A method, apparatus, and article of manufacture for managing results of federated searches across heterogeneous datastores with a federated result set cursor object. One or more commands are executed in a computer to perform a datastore operation at a computer. Data is located in one or more datastores. A cursor is set to the located data in each datastore. A set of cursors to the located data is returned. </paragraph>
</subdoc-abstract>
<subdoc-description>
<cross-reference-to-related-applications>
<heading lvl="1">CROSS-REFERENCE TO RELATED APPLICATIONS </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> This application is related to the following co-pending and commonly-assigned patent applications: </paragraph>
<paragraph id="P-0002" lvl="2"><number>&lsqb;0002&rsqb;</number> application Ser. No. ______, entitled &ldquo;THE ARCHITECTURE AND IMPLEMENTATION OF A DYNAMIC RMI SERVER CONFIGURATION HIERARCHY TO SUPPORT FEDERATED SEARCH AND UPDATE ACROSS HETEROGENEOUS DATASTORES,&rdquo; filed on same date herewith, by Kehsing J. Chou et al., attorney&apos;s docket number ST9-99-093; </paragraph>
<paragraph id="P-0003" lvl="2"><number>&lsqb;0003&rsqb;</number> application Ser. No. ______, entitled &ldquo;THE DESIGN AND IMPLEMENTATION OF A CLIENT/SERVER FRAMEWORK FOR FEDERATED MULTI-SEARCH AND UPDATE ACROSS HETEROGENEOUS DATASTORES,&rdquo; filed on same date herewith, by Kehsing J. Chou et al., attorney&apos;s docket number ST9-99-094; </paragraph>
<paragraph id="P-0004" lvl="2"><number>&lsqb;0004&rsqb;</number> application Ser. No. ______, entitled &ldquo;ARCHITECTURE TO ENABLE SEARCH GATEWAYS AS PART OF FEDERATED SEARCH,&rdquo; filed on same date herewith, by Kehsing J. Chou et al., attorney&apos;s docket number ST9-99-097; </paragraph>
<paragraph id="P-0005" lvl="2"><number>&lsqb;0005&rsqb;</number> application Ser. No. ______, entitled &ldquo;DELAYED DELIVERY OF QUERY RESULTS OR OTHER DATA FROM A FEDERATED SERVER TO A FEDERATED CLIENT UNTIL SUCH INFORMATION IS NEEDED,&rdquo; filed on same date herewith, by M. W. Huang et al., attorney&apos;s docket number ST9-99-123; </paragraph>
<paragraph id="P-0006" lvl="2"><number>&lsqb;0006&rsqb;</number> application Ser. No. ______, entitled &ldquo;IMPROVED EXTENDED DATA OBJECT ARCHITECTURE FOR HANDLING MULTI-STREAMING AND COMPLEX MULTI-DIMENSIONAL FILES,&rdquo; filed on same date herewith, by Kehsing J. Chou et al., attorney&apos;s docket number ST9-99-139; </paragraph>
<paragraph id="P-0007" lvl="2"><number>&lsqb;0007&rsqb;</number> application Ser. No. 08/852,062, entitled &ldquo;CLASS HIERARCHY FOR OBJECT AGGREGATION REPRESENTATION OF RELATIONAL DATABASE ROWS WITH CELLS HAVING NONTRADITIONAL DATATYPES,&rdquo; filed on May 6, 1997, by Daniel T. Chang et al., attorney&apos;s docket number ST9-97-032; </paragraph>
<paragraph id="P-0008" lvl="2"><number>&lsqb;0008&rsqb;</number> application Ser. No. 08/852,055, entitled &ldquo;FLEXIBLE OBJECT REPRESENTATION OF RELATIONAL DATABASE CELLS HAVING NONTRADITIONAL DATATYPES,&rdquo; filed on May 6, 1997, by Daniel T. Chang et al., attorney&apos;s docket number ST9-97-033; </paragraph>
<paragraph id="P-0009" lvl="2"><number>&lsqb;0009&rsqb;</number> application Ser. No. 09/052,678, entitled &ldquo;MANAGING RESULTS OF FEDERATED SEARCHES ACROSS HETEROGENEOUS DATASTORES WITH A FEDERATED COLLECTION OBJECT,&rdquo; filed on Apr. 1, 1998, by Daniel T. Chang et al., attorney&apos;s docket number ST9-98-016; </paragraph>
<paragraph id="P-0010" lvl="2"><number>&lsqb;0010&rsqb;</number> application Ser. No. 09/052,680, entitled &ldquo;FEDERATED SEARCHING OF HETEROGENEOUS DATASTORES USING A FEDERATED DATASTORE OBJECT,&rdquo; filed on Apr. 1, 1998, by Daniel T. Chang et al., attorney&apos;s docket number ST9-98-017; and </paragraph>
<paragraph id="P-0011" lvl="2"><number>&lsqb;0011&rsqb;</number> application Ser. No. 09/052,679, entitled &ldquo;FEDERATED SEARCHING OF HETEROGENEOUS DATASTORES USING A FEDERATED QUERY OBJECT,&rdquo; filed on Apr. 1, 1998, by Daniel T. Chang et al., attorney&apos;s docket number ST9-98-018; </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> each of which is incorporated by reference herein.</paragraph>
</cross-reference-to-related-applications>
<summary-of-invention>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> 1. Field of the Invention </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> This invention relates in general to database management systems performed by computers, and in particular, to managing results of federated searches across heterogeneous datastores with a federated result set cursor object. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> 2. Description of Related Art </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> The present invention relates to a system and method for representing and searching multiple heterogeneous datastores and managing the results of such searches. Datastore is a term used to refer to a generic data storage facility, such as a relational data base, flat-file, hierarchical data base, etc. Heterogeneous is a term used to indicate that the datastores need not be similar to each other. For example, each datastore may store different types of data, such as image or text, or each datastore may be based on a different theory of data model, such as Digital Library/VisualInfo or Domino Extended Search (DES). </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> For nearly half a century computers have been used by businesses to manage information such as numbers and text, mainly in the form of coded data. However, business data represents only a small part of the world&apos;s information. As storage, communication and information processing technologies advance, and as their costs come down, it becomes more feasible to digitize other various types of data, store large volumes of it, and be able to distribute it on demand to users at their place of business or home. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> New digitization technologies have emerged in the last decade to digitize images, audio, and video, giving birth to a new type of digital multimedia information. These multimedia objects are quite different from the business data that computers managed in the past, and often require more advanced information management system infrastructures with new capabilities. Such systems are often called &ldquo;digital libraries.&rdquo;</paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> Bringing new digital technologies can do much more than just replace physical objects with their electronic representation. It enables instant access to information; supports fast, accurate, and powerful search mechanisms; provides, new &ldquo;experiential&rdquo; (i.e. virtual reality) user interfaces; and implements new ways of protecting the rights of information owners. These properties make digital library solutions even more attractive and acceptable not only to corporate IS organizations, but to the information owners, publishers and service providers. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> Generally, business data is created by a business process (an airline ticket reservation, a deposit at the bank, and a claim processing at an insurance company are examples). Most of these processes have been automated by computers and produce business data in digital form (text and numbers). Therefore it is usually structured coded data. Multimedia data, on the contrary, cannot be fully pre-structured (its use is not fully predictable) because it is the result of the creation of a human being or the digitization of an object of the real world (x-rays, geophysical mapping, etc.) rather than a computer algorithm. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> The average size of business data in digital form is relatively small. A banking record&mdash;including a customers name, address, phone number, account number, balance, etc.&mdash;represents at most a few hundred characters, i.e. few hundreds/thousands of bits. The digitization of multimedia information (image, audio, video) produces a large set of bits called an &ldquo;object&rdquo; or &ldquo;blobs&rdquo; (Binary Large Objects). For example, a digitized image of the parchments from the Vatican Library takes as much as the equivalent of 30 million characters (30 MB) to be stored. The digitization of a movie, even after compression, may take as much as the equivalent of several billions of characters (3-4 GB) to be stored. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> Multimedia information is typically stored as much larger objects, ever increasing in quantity and therefore requiring special storage mechanisms. Classical business computer systems have not been designed to directly store such large objects. Specialized storage technologies may be required for certain types of information, e.g. media streamers for video or music. Because certain multimedia information needs to be preserved &ldquo;forever&rdquo; it also requires special storage management functions providing automated back-up and migration to new storage technologies as they become available and as old technologies become obsolete. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> Finally, for performance reasons, the multimedia data is often placed in the proximity of the users with the system supporting multiple distributed object servers. This often requires a logical separation between applications, indices, and data to ensure independence from any changes in the location of the data. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> The indexing of business data is often imbedded into the data itself. When the automated business process stores a person&apos;s name in the column &ldquo;NAME,&rdquo; it actually indexes that information. Multimedia information objects usually do not contain indexing information. This &ldquo;meta data&rdquo; needs to be created in addition by developers or librarians. The indexing information for multimedia information is often kept in &ldquo;business like&rdquo; databases separated from the physical object. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> In a Digital Library (DL), the multimedia object can be linked with the associated indexing information, since both are available in digital form. Integration of this legacy catalog information with the digitized object is crucial and is one of the great advantages of DL technology. Different types of objects can be categorized differently as appropriate for each object type. Existing standards like MARC records for libraries, Finding Aids for archiving of special collections, etc . . . can be used when appropriate. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> The indexing information used for catalog searches in physical libraries is mostly what one can read on the covers of the books: authors name, title, publisher, ISBN, . . . enriched by other information created by librarians based on the content of the books (abstracts, subjects, keywords, . . . ). In digital libraries, the entire content of books, images, music, films, etc . . . are available and &ldquo;new content&rdquo; technologies are needed; technologies for full text searching, image content searching (searching based on color, texture, shape, etc . . . ), video content searching, and audio content searching. The integrated combination of catalog searches (e.g. SQL) with content searches will provide more powerful search and access functions. These technologies can also be used to partially automate further indexing, classification, and abstracting of objects based on content. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> To harness the massive amounts of information spread throughout these networks, it has become necessary for a user to search numerous storage facilities at the same time without having to consider the particular implementation of each storage facility. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> Object-oriented approaches are generally better suited for such complex data management. The term &ldquo;object-oriented&rdquo; refers to a software design method which uses &ldquo;classes&rdquo; and &ldquo;objects&rdquo; to model abstract or real objects. An &ldquo;object&rdquo; is the main building block of object-oriented programming, and is a programming unit which has both data and functionality (i.e., &ldquo;methods&rdquo;). A &ldquo;class&rdquo; defines the implementation of a particular kind of object, the variables and methods it uses, and the parent class it belongs to. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> Some known programming tools that can be used for developing search and result-management frameworks include IBM VisualAge C&plus;&plus;, Microsoft Visual C&plus;&plus;, Microsoft Visual J&plus;&plus;, and Java. A result set cursor is a feature supported by modem database management systems, such as relational databases (e.g., DB2, Oracle, Sybase, Informix, etc.). A result set cursor is an indicator that indicates the location of data. All conventional result set cursors are flat in that they provide a single cursor to the retrieved data. Consequently, all implementations of result set cursors in the above mentioned frameworks are also flat implementations. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> There is a need in the art for an improved federated system. In particular, there is a need in the art for managing results of federated searches across heterogeneous datastores with a federated result set cursor object. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> To overcome the limitations in the prior art described above, and to overcome other limitations that will become apparent upon reading and understanding the present specification, the present invention discloses a method, apparatus, and article of manufacture for managing results of federated searches across heterogeneous datastores with a federated result set cursor object. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> According to an embodiment of the invention, one or more commands are executed in a computer to perform a datastore operation at a computer. Data is located in one or more datastores. A cursor is set to the located data in each datastore. A set of cursors to the located data is returned.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> Referring now to the drawings in which like reference numbers represent corresponding parts throughout: </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a diagram illustrating a computer architecture that could be used in accordance with the present invention; </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a diagram illustrating a class hierarchy for Data Object classes; </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a diagram illustrating a class hierarchy for Datastore classes; </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a diagram illustrating a conceptual view of a federated result set cursor object; </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a diagram of an extended Grand Portal architecture; </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is a diagram illustrating individual datastores and federated compositions; </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> is a diagram illustrating a conceptual view of a federated result set cursor object </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> is a diagram illustrating one use of the present invention; </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference> is a flow diagram illustrating steps performed by a federated datastore to process a query; and </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10</cross-reference> is a flow diagram illustrating steps performed by a federated datastore to process a fetch. </paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT </heading>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> In the following description of the preferred embodiment, reference is made to the accompanying drawings which form a part hereof, and in which is shown by way of illustration a specific embodiment in which the invention may be practiced. It is to be understood that other embodiments may be utilized and structural and functional changes may be made without departing from the scope of the present invention. </paragraph>
</section>
<section>
<heading lvl="1">Federated Architecture </heading>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a diagram illustrating a computer architecture that could be used in accordance with the present invention. The present invention is described herein by way of example and is not intended to be limited to the described embodiment. The description of the preferred embodiment is based on, but certainly not limited to, the IBM design of Java Grand Portal Class Library, the Digital Library Java Application Programming Interface (API). </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> The Java Grand Portal <highlight><bold>120</bold></highlight> is comprised of client and server classes. In particular, Java Grand Portal is a set of Java classes which provides access and manipulation of local or remote data stored in Digital Library storage facilities. It uses Java APIs based on OMG-Object Query Services (OQS) and a Dynamic Data Object protocol, which is a part of OMG/Persistence Object Services. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> The Java APIs provide multi-search capabilities such as: </paragraph>
<paragraph id="P-0048" lvl="2"><number>&lsqb;0048&rsqb;</number> 1. Searching within a given datastore using one or a combination of supported query types, i.e. </paragraph>
<paragraph id="P-0049" lvl="3"><number>&lsqb;0049&rsqb;</number> Parametric query&mdash;Queries requiring an exact match on the condition specified in the query predicate and the data values stored in the datastore. </paragraph>
<paragraph id="P-0050" lvl="3"><number>&lsqb;0050&rsqb;</number> Text query&mdash;Queries on the content of text fields for approximate match with the given text search expression, e.g. the existence (or non-existence) of certain phrases or word-stems. </paragraph>
<paragraph id="P-0051" lvl="3"><number>&lsqb;0051&rsqb;</number> Image query&mdash;Queries on the content of image fields for approximate match with the given image search expression, e.g. image with certain degree of similarity based on color percentages, layout, or texture. </paragraph>
<paragraph id="P-0052" lvl="2"><number>&lsqb;0052&rsqb;</number> 2. Each search type is supported by one or more search-engines. </paragraph>
<paragraph id="P-0053" lvl="2"><number>&lsqb;0053&rsqb;</number> 3. Searching on the results of a previous search. </paragraph>
<paragraph id="P-0054" lvl="2"><number>&lsqb;0054&rsqb;</number> 4. Searching involving heterogeneous datastores. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> The Digital Library Grand Portal classes provide a convenient API for Java application users; the applications can be located at local or remote sites. Java classes will typically reside on both server and client sides; both sides providing the same interface. The client side of Java classes communicates with the server side to access data in the Digital Library through the network. Communication between client and server sides is done by these classes; it is not necessary to add any additional programs. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> In particular, <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is an architectural diagram outlining the structure of the federated search for Digital Library repositories using the federated datastore <highlight><bold>100</bold></highlight>, comprised of a federated datastore client and server. A federated datastore <highlight><bold>100</bold></highlight> is a virtual datastore which combines several heterogeneous datastore <highlight><bold>102</bold></highlight> into a consistent and unified conceptual view. This view, or a federated schema, is established via schema mapping <highlight><bold>104</bold></highlight> of the underlying datastores. The users interact with a federated datastore <highlight><bold>100</bold></highlight> using the federated schema, without needing to know about the individual datastores <highlight><bold>102</bold></highlight> which participate in the federated datastore <highlight><bold>100</bold></highlight>. </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> One embodiment of the invention provides a federated result set cursor object across heterogeneous datastores. In one embodiment of the invention, one or more classes implement the federated result set cursor object, and one or more methods are provided to manipulate the federated result set cursor object. In one embodiment, the class definitions and methods reside at the federated datastore client and server. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> The federated datastore <highlight><bold>100</bold></highlight> does not have a corresponding back-end client. Since it is a virtual datastore, the federated datastore <highlight><bold>100</bold></highlight> relies on the underlying physical back-end client associated with it, such as the DL client (i.e., Digital Library client), OnDemand, VisualInfo, DB2, etc. Digital Library, OnDemand, VisualInfo, and DB2 are all products from International Business Machines Corporation. As mentioned before, this association is established by a schema mapping component <highlight><bold>104</bold></highlight>. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> The communication between the federated datastore <highlight><bold>100</bold></highlight> client and server can be done by any appropriate protocol. On top of Java Grand Portal client classes, the users can develop application programs using, for example, any existing Java Beans <highlight><bold>122</bold></highlight> development environment. </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> The federated datastore <highlight><bold>100</bold></highlight> coordinates query evaluation, data-access, and transaction processing of the participating heterogeneous datastores <highlight><bold>102</bold></highlight>. Given the federated schema, a multi-search query can be formulated, executed, and coordinated to produce results in the form of a datastore-neutral dynamic data object. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> Note that each heterogeneous datastore and the federated datastore are created using one datastore definition or superclass. The federated datastore <highlight><bold>100</bold></highlight> and the heterogeneous datastores <highlight><bold>102</bold></highlight> are all subclasses of a class called Datastore, therefore, all of these datastores <highlight><bold>100</bold></highlight> and <highlight><bold>102</bold></highlight> have the same interface. Therefore, a user would be able to access the federated datastore <highlight><bold>100</bold></highlight> and the heterogeneous datastores <highlight><bold>102</bold></highlight> in a consistent and uniform manner. </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> Additionally, the objects stored in the federated datastore <highlight><bold>100</bold></highlight> and the heterogeneous datastores <highlight><bold>102</bold></highlight> are subclasses of a Data Object class. The Data Object class includes subclasses for dynamic data objects (DDOs) and extended data objects (XDOs). A DDO has attributes, with type, value, and properties. The value of an attribute can be a reference to another DDO or XDO, or a collection of DDOs or XDOs. </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a diagram illustrating a class hierarchy for Data Object classes. The objects stored in and manipulated by the datastores and fetch operations belong to data object classes. These objects are returned as the result of a fetch, or created and used in CRUD (add, retrieve, update, delete) operations. </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> A Data Object Base <highlight><bold>200</bold></highlight> is an abstract base class for all data objects known by datastores. It has a protocol attribute, that indicates to the datastore which interface can be used to operate on this object. A XDOBase <highlight><bold>210</bold></highlight> is the base class used to represent user-defined-types (UDT) or large objects. In particular, the XDOBase <highlight><bold>210</bold></highlight> is the base class for some user-defined types <highlight><bold>212</bold></highlight> and XDOs <highlight><bold>214</bold></highlight>. A XDO <highlight><bold>214</bold></highlight> represents complex UDTs or large objects (LOB). This object can exist stand-alone or as a part of a DDO <highlight><bold>236</bold></highlight>. Therefore, it has a persistent object identifier and CRUD operations capabilities. </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> Blob <highlight><bold>216</bold></highlight> is a base class for BLOBs as a placeholder to share all generic operations pertaining to BLOBs. Clob <highlight><bold>218</bold></highlight> is a base class for CLOBs (Character Large Objects) as a placeholder to share all generic operations pertaining to CLOBs. DBClob <highlight><bold>220</bold></highlight> is a base class for DBCLOBs (database character large object) as a placeholder to share all generic operations pertaining to DBCLOBs. BlobDB2 <highlight><bold>222</bold></highlight> represents a BLOB specific to DB2, and BlobDL <highlight><bold>22</bold></highlight> represents a BLOB specific to DL. Similarly, though not shown, there may be subclasses for ClobDB2, ClobDL, etc. </paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> A Data Object <highlight><bold>230</bold></highlight> is a base class for PersistentObject <highlight><bold>232</bold></highlight> and DDOBase <highlight><bold>234</bold></highlight>. A PersistentObject <highlight><bold>232</bold></highlight> represents a specific object whose code is statically generated and compiled. This type of object will not be covered in this document. A DDOBase <highlight><bold>234</bold></highlight> is a base class for a dynamic data object <highlight><bold>236</bold></highlight> (without the CRUD methods). A DDO (Dynamic Data Object) <highlight><bold>236</bold></highlight> represents generic data objects which are constructed dynamically at runtime. This object fits well with query and browsing activities in Grand Portal where objects are only known and generated at runtime. It supports the CRUD operations (add, retrieve, update, and delete), and, with the help of its associated datastore, a DDO can put itself into and out of the datastore. </paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> One skilled in the art would recognize that these are only example classes and subclasses and other structures maybe used for objects and other classes or subclasses may be added to or removed from the tree shown in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>. </paragraph>
<paragraph id="P-0068" lvl="0"><number>&lsqb;0068&rsqb;</number> With respect to the notion of &ldquo;federation&rdquo;, each participating datastore preserves the right to maintain its &ldquo;personality&rdquo;, i.e. its own query language, data-model or schema, method of interaction, etc, and at the same time cooperating in a federation to provide a federated schema. This design allows the users to preserve the natural view to their favorite datastore as well as access them in conjunction with other datastores in a federated context. </paragraph>
<paragraph id="P-0069" lvl="0"><number>&lsqb;0069&rsqb;</number> The federated datastore <highlight><bold>100</bold></highlight> can combine the participating native datastores in two ways: </paragraph>
<paragraph id="P-0070" lvl="2"><number>&lsqb;0070&rsqb;</number> With mapping. As described above, mapping of concepts across participating datastores is established to provide a unified conceptual view. Based on this federated schema, federated queries with both join and union expressions can be formulated. </paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> Without mapping. In this case, the federated datastore <highlight><bold>100</bold></highlight> only reflects the union of each participating datastore&apos;s conceptual view. Although it coordinates query processing and data-access for each underlying datastore, the federated datastore <highlight><bold>100</bold></highlight> must accept queries in each datastore&apos;s native language since the query translation process can not be performed without mapping. In addition, since there is no conceptual mapping between datastores, the FederatedQuery <highlight><bold>19</bold></highlight> results can only reflect the union of results from each datastore. </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> The embodiment of the invention is incorporated into one or more software programs that reside at the federated datastore <highlight><bold>100</bold></highlight>. Generally, the software programs and the instructions derived therefrom, are all tangibly embodied in a computer-readable medium, e.g. one or more of the data storage devices, which may be connected to the federated datastore <highlight><bold>100</bold></highlight>. Moreover, the software programs and the instructions derived therefrom, are all comprised of instructions which, when read and executed by the computer system <highlight><bold>100</bold></highlight>, causes the computer system <highlight><bold>100</bold></highlight> to perform the steps necessary to implement and/or use the present invention. Under control of an operating system, the software programs and the instructions derived therefrom, may be loaded from the data storage devices into a memory of the federated datastore <highlight><bold>100</bold></highlight> for use during actual operations. </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> Thus, the present invention may be implemented as a method, apparatus, or article of manufacture using standard programming and/or engineering techniques to produce software, firmware, hardware, or any combination thereof. The term &ldquo;article of manufacture&rdquo; (or alternatively, &ldquo;computer program product&rdquo;) as used herein is intended to encompass a computer program accessible from any computer-readable device, carrier, or media. Of course, those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope of the present invention. </paragraph>
<paragraph id="P-0074" lvl="0"><number>&lsqb;0074&rsqb;</number> Those skilled in the art will recognize that the exemplary environment illustrated in <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is not intended to limit the present invention. Indeed, those skilled in the art will recognize that other alternative hardware environments may be used without departing from the scope of the present invention. </paragraph>
</section>
<section>
<heading lvl="1">Federated Datastore </heading>
<paragraph id="P-0075" lvl="0"><number>&lsqb;0075&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a diagram illustrating a class hierarchy for Datastore classes. A main datastore class <highlight><bold>300</bold></highlight> is an abstract base class (i.e., superclass) for all datastores. In particular, some datastore classes that are based on the datastore class <highlight><bold>300</bold></highlight> and inherit its characteristics are the following: a DL Datastore class <highlight><bold>302</bold></highlight>, a VisualInfo Datastore class <highlight><bold>304</bold></highlight>, a Federated Datastore class <highlight><bold>306</bold></highlight>, and an OnDemand Datastore class <highlight><bold>308</bold></highlight>. It is to be understood that the techniques of the invention may be applied to any data source and is not limited to the mentioned datastores. </paragraph>
<paragraph id="P-0076" lvl="0"><number>&lsqb;0076&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a diagram illustrating one composition of a federated datastore. The federated datastore <highlight><bold>400</bold></highlight> connects to heterogeneous datastores <highlight><bold>402</bold></highlight>, <highlight><bold>404</bold></highlight>, <highlight><bold>406</bold></highlight>, and <highlight><bold>408</bold></highlight>. As illustrated, a federated datastore <highlight><bold>406</bold></highlight> may connect to and be nested under federated datastore <highlight><bold>400</bold></highlight>. Additionally, the federated datastore <highlight><bold>406</bold></highlight> may connect to heterogeneous datastores <highlight><bold>410</bold></highlight>, <highlight><bold>412</bold></highlight>, and <highlight><bold>414</bold></highlight>. The depicted architecture is only a sample, and one skilled in the art would recognize that other examples fall within the scope of the invention. </paragraph>
<paragraph id="P-0077" lvl="0"><number>&lsqb;0077&rsqb;</number> In the preferred embodiment, the federated datastore <highlight><bold>100</bold></highlight> takes query strings expressed in a federated query language. An example class definition for the federated datastore (DKDatastoreFed.java) <highlight><bold>100</bold></highlight> is set forth below.  
<table-cwu id="TABLE-US-00001">
<number>1</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="273PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>DKDatastoreFed.java</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>package com.ibm.mm.sdk.server;</entry>
</row>
<row>
<entry></entry>
<entry>public class DKDatastoreFed extends dkAbstractDataStore</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>implements DKConstantFed,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="84PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>DKConstant,</entry>
</row>
<row>
<entry></entry>
<entry>DKMessageIdFed,</entry>
</row>
<row>
<entry></entry>
<entry>DKMessageId,</entry>
</row>
<row>
<entry></entry>
<entry>dkFederation,</entry>
</row>
<row>
<entry></entry>
<entry>java.io.Serializable</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub;</entry>
</row>
<row>
<entry></entry>
<entry>public dkCollection listEntities() throws DKException, Exception</entry>
</row>
<row>
<entry></entry>
<entry>public String&lsqb;&rsqb; listEntityNames() throws DKException, Exception</entry>
</row>
<row>
<entry></entry>
<entry>public String&lsqb;&rsqb; listTextEntityNames() throws DKException, Exception</entry>
</row>
<row>
<entry></entry>
<entry>public String&lsqb;&rsqb; listParmEntityNames() throws DKException, Exception</entry>
</row>
<row>
<entry></entry>
<entry>public dkCollection listEntityAttrs(String entityName) throws DKException, Exception</entry>
</row>
<row>
<entry></entry>
<entry>public String&lsqb;&rsqb; listEntityAttrNames(String entityName) throws DKException, Exception</entry>
</row>
<row>
<entry></entry>
<entry>public String registerMapping(DKNVPair sourceMap) throws DKException, Exception</entry>
</row>
<row>
<entry></entry>
<entry>public void unRegisterMapping(String mappingName) throws DKException, Exception</entry>
</row>
<row>
<entry></entry>
<entry>public String&lsqb;&rsqb; listMappingNames() throws DKException, Exception</entry>
</row>
<row>
<entry></entry>
<entry>public dkSchemaMapping getMapping(String mappingName) throws DKException,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Exception</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>public synchronized dkExtension getExtension(String extensionName) throws</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>DKException, Exception</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>public synchronized void addExtension(String extensionName,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>dkExtension extensionObj) throws DKException, Exception</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>public synchronized void removeExtension(String extensionName) throws</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>DKException, Exception</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>public synchronized String&lsqb;&rsqb; listExtensionNames() throws DKException, Exception</entry>
</row>
<row>
<entry></entry>
<entry>public DKDDO createDDO(String objectType,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="35PT" align="left"/>
<colspec colname="1" colwidth="238PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>int Flags) throws DKException, Exception</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>public dkCollection listSearchTemplates() throws DKException, Exception</entry>
</row>
<row>
<entry></entry>
<entry>public String&lsqb;&rsqb; listSearchTemplateNames() throws DKException, Exception</entry>
</row>
<row>
<entry></entry>
<entry>public dkSearchTemplate getSearchTemplate(String templateName) throws</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>DKException, Exception</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>public void destroy() throws DKException, Exception</entry>
</row>
<row>
<entry></entry>
<entry>public synchronized string addRemoveCursor (dkResultSetCursor iCurt int action)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>throws DKException, Exception</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>public dkDatastore datastoreByServerName (String dsType, String dsName)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>throws DKException, Exception</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>public void changePassword (String serverName,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>String user Id,</entry>
</row>
<row>
<entry></entry>
<entry>String oldPwd,</entry>
</row>
<row>
<entry></entry>
<entry>String newPwd)</entry>
</row>
<row>
<entry></entry>
<entry>throws DKException, Exception</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>public void requestConnection (String serverName,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>String userId,</entry>
</row>
<row>
<entry></entry>
<entry>String passwd,</entry>
</row>
<row>
<entry></entry>
<entry>String connectString)</entry>
</row>
<row>
<entry></entry>
<entry>throws DKException, Exception</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>public void excludeServer (Sting serverName, String templateName)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>throws DKException, Exception</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>public boolean isServerExcluded (String serverName, String templateName)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>throws DKException, Exception, java.rmi.RemoteException</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>public String&lsqb;&rsqb; listExcludedServers(String templateName) throws DKException,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Exception</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>public void clearExcludedServers(String templateName) throws DKException,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Exception</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;;</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0078" lvl="0"><number>&lsqb;0078&rsqb;</number> The following methods are part of the federated datastore class: 
<image file="US20030004931A1-20030102-P00001.TIF" id="EMI-00001"></image>
<image file="US20030004931A1-20030102-P00002.TIF" id="EMI-00002"></image>
<image file="US20030004931A1-20030102-P00003.TIF" id="EMI-00003"></image>
<image file="US20030004931A1-20030102-P00004.TIF" id="EMI-00004"></image>
<image file="US20030004931A1-20030102-P00005.TIF" id="EMI-00005"></image>
<image file="US20030004931A1-20030102-P00006.TIF" id="EMI-00006"></image>
<image file="US20030004931A1-20030102-P00007.TIF" id="EMI-00007"></image>
<image file="US20030004931A1-20030102-P00008.TIF" id="EMI-00008"></image>
<image file="US20030004931A1-20030102-P00009.TIF" id="EMI-00009"></image>
<image file="US20030004931A1-20030102-P00010.TIF" id="EMI-00010"></image>
<image file="US20030004931A1-20030102-P00011.TIF" id="EMI-00011"></image>
<image file="US20030004931A1-20030102-P00012.TIF" id="EMI-00012"></image>
<image file="US20030004931A1-20030102-P00013.TIF" id="EMI-00013"></image>
<image file="US20030004931A1-20030102-P00014.TIF" id="EMI-00014"></image>
<image file="US20030004931A1-20030102-P00015.TIF" id="EMI-00015"></image>
</paragraph>
<paragraph id="P-0079" lvl="0"><number>&lsqb;0079&rsqb;</number> Gets a reference to the specified datastore. The datastore must be connected, otherwise it will return null even if one is found. First, it will look in the free connection pool. If none found, it will look under the connection pool held by active cursors.  
<table-cwu id="TABLE-US-00002">
<number>2</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="266PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>public void changePassword (String serverName,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="252PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>String user Id,</entry>
</row>
<row>
<entry></entry>
<entry>String oldPwd,</entry>
</row>
<row>
<entry></entry>
<entry>String newPwd)</entry>
</row>
<row>
<entry></entry>
<entry>throws DKException, Exception</entry>
</row>
<row>
<entry></entry>
<entry>Changes the password of a given user Id for a specified server. Administrator only</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="266PT" align="left"/>
<tbody valign="top">
<row>
<entry>function.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="252PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Parameters:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>userId</entry>
<entry>-the user-id</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>oldPwd</entry>
<entry>-the old password</entry>
</row>
<row>
<entry></entry>
<entry>newPwd</entry>
<entry>-the new password</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="266PT" align="left"/>
<tbody valign="top">
<row>
<entry>public void requestConnection (String serverName,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="252PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>String userId,</entry>
</row>
<row>
<entry></entry>
<entry>String passwd,</entry>
</row>
<row>
<entry></entry>
<entry>String connectString)</entry>
</row>
<row>
<entry></entry>
<entry>throws DKException, Exception</entry>
</row>
<row>
<entry></entry>
<entry>Requests a connection to a particular server with the given userid, password &amp;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="266PT" align="left"/>
<tbody valign="top">
<row>
<entry>connectString.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="252PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Parameters:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>userId</entry>
<entry>-the user Id</entry>
</row>
<row>
<entry></entry>
<entry>passwd</entry>
<entry>-the password</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>connectString</entry>
<entry>-the connect string to logon</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="266PT" align="left"/>
<tbody valign="top">
<row>
<entry>public void excludeServer (String serverName, String templateName)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="252PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>throws DKException, Exception</entry>
</row>
<row>
<entry></entry>
<entry>Requests the named server to be skipped for the named search template.</entry>
</row>
<row>
<entry></entry>
<entry>Parameters:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="63PT" align="left"/>
<colspec colname="2" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>serverName</entry>
<entry>-a back end server name</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="238PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>templateName - a search template name</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="266PT" align="left"/>
<tbody valign="top">
<row>
<entry>public boolean isServerExcluded (String serverName, String templateName)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="252PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>throws DKException, Exception, java.rmi.RemoteException</entry>
</row>
<row>
<entry></entry>
<entry>Checks if the given server is in the excluded list for the named search template.</entry>
</row>
<row>
<entry></entry>
<entry>Parameters:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="63PT" align="left"/>
<colspec colname="2" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>serverName</entry>
<entry>-a back end server name</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="238PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>templateName - a search template name</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="252PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Returns:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="238PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>true or false</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="266PT" align="left"/>
<tbody valign="top">
<row>
<entry>public String&lsqb;&rsqb; listExcludedServers(String templateName) throws DKException, Exception</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="252PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Lists all the excluded servers for the named search template</entry>
</row>
<row>
<entry></entry>
<entry>Parameters:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="238PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>s - templateName - a search template name</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="252PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Returns:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="238PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>an array of server names that were excluded during search</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="266PT" align="left"/>
<tbody valign="top">
<row>
<entry>public void clearExcludedServers(String templateName) throws DKException, Exception</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="252PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Clears all the excluded servers for the named search template</entry>
</row>
<row>
<entry></entry>
<entry>Parameters:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="238PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>s - templateName - a search template name</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0080" lvl="0"><number>&lsqb;0080&rsqb;</number> The following is sample syntax of a federated query string. However, it is to be understood that other syntax, including other parameters, may be used for the federated query string without departing from the scope of the invention.  
<table-cwu id="TABLE-US-00003">
<number>3</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>PARAMETRIC_SEARCH&equals;(&lsqb;ENTITY&equals;entity_name,&rsqb;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lsqb;MAX_RESULTS&equals;maximum_results,&rsqb;</entry>
</row>
<row>
<entry></entry>
<entry>&lsqb;COND&equals;(conditional_expression)&rsqb;</entry>
</row>
<row>
<entry></entry>
<entry>&lsqb;; ...&rsqb;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>);</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lsqb;OPTION&equals;(&lsqb;CONTENT&equals;yes_no&rsqb;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>)&rsqb;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>&lsqb;and_or</entry>
</row>
<row>
<entry>TEXT_SEARCH&equals;(COND&equals;(text_search_expression)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>);</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lsqb;OPTION&equals;(&lsqb;SEARCH_INDEX&equals;&lcub;search_index_name &verbar;</entry>
</row>
<row>
<entry></entry>
<entry>(index_list) &rcub;;&rsqb;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lsqb;MAX_RESULTS&equals;maximum_results;&rsqb;</entry>
</row>
<row>
<entry></entry>
<entry>&lsqb;TIME_LIMIT&equals;time_limit&rsqb;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>)&rsqb;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>&rsqb;</entry>
</row>
<row>
<entry>&lsqb;and_or</entry>
</row>
<row>
<entry>IMAGE_SEARCH&equals;(COND&equals;(image_search_expression)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>);</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>OPTION&equals;(&lsqb;SEARCH_INDEX&equals;&lcub;search_index_name &verbar;</entry>
</row>
<row>
<entry></entry>
<entry>(index_list) &rcub;;&rsqb;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&thinsp;&lsqb;MAX_RESULTS&equals;maximum_results;&rsqb;</entry>
</row>
<row>
<entry></entry>
<entry>&thinsp;&lsqb;TIME_LIMIT&equals;time_limit&rsqb;</entry>
</row>
<row>
<entry></entry>
<entry>)&rsqb;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>&rsqb;</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0081" lvl="0"><number>&lsqb;0081&rsqb;</number> There are several mechanisms for users to submit federated queries for execution. For example, users can create a federated query string and pass it to a federated query object and then invoke an execute or evaluate method on that object to trigger the query processing. Alternatively, a user can pass the federated query string to the execute or evaluate method in the federated datastore to process the query directly. The query string will be parsed into a federated query canonical form (query expression), which is essentially a datastore neutral representation of the query. In case the input query comes from a graphical user interface (GUI) based application, the query does not need to be parsed and the corresponding canonical form can be directly constructed. </paragraph>
<paragraph id="P-0082" lvl="0"><number>&lsqb;0082&rsqb;</number> The query canonical form is the input for the federated query processor module. This module will perform the following tasks: </paragraph>
<paragraph id="P-0083" lvl="2"><number>&lsqb;0083&rsqb;</number> Query translation. Translates the query canonical form into several native queries that corresponds to each native datastore associated to this federated datastore. The translation information is obtained from the schema mapping. </paragraph>
<paragraph id="P-0084" lvl="2"><number>&lsqb;0084&rsqb;</number> Data conversion. Converts data in the query into a native data type for each of the associated native datastores. This process uses the mapping and conversion mechanisms described in the schema mapping. </paragraph>
<paragraph id="P-0085" lvl="2"><number>&lsqb;0085&rsqb;</number> Data filtering. Filters only the relevant data during the construction of native queries. </paragraph>
<paragraph id="P-0086" lvl="0"><number>&lsqb;0086&rsqb;</number> Each native query is submitted to the corresponding native datastore for execution. Initially, the results returned are cursors to the data in each datastore. </paragraph>
<paragraph id="P-0087" lvl="0"><number>&lsqb;0087&rsqb;</number> The end-result of an initial query is a federated result set cursor object, which is a virtual collection (i.e., at this time, data has not actually been retrieved) of cursors to objects in each of the native datastores. </paragraph>
<paragraph id="P-0088" lvl="0"><number>&lsqb;0088&rsqb;</number> The user can retrieve the actual data using a fetch. When a fetch is issued for data, the data is returned by the native datastores to the federated query results processor module, which will do the following: </paragraph>
<paragraph id="P-0089" lvl="2"><number>&lsqb;0089&rsqb;</number> Data conversion. Converts data from the native type into a federated type according to the mapping information. </paragraph>
<paragraph id="P-0090" lvl="2"><number>&lsqb;0090&rsqb;</number> Data filtering. Filters the results to include only the requested data. </paragraph>
<paragraph id="P-0091" lvl="2"><number>&lsqb;0091&rsqb;</number> Result merging. Merges the results from several native datastores into a federated collection. </paragraph>
<paragraph id="P-0092" lvl="0"><number>&lsqb;0092&rsqb;</number> The federated result set cursor object provides the facility to separate query results according to the source native datastores. To do such a processing, the user/application may either use the federated cursor to fetch data or a native datastore cursor to fetch data from a particular datastore. </paragraph>
<paragraph id="P-0093" lvl="0"><number>&lsqb;0093&rsqb;</number> A FederatedQuery represents and executes queries across heterogeneous datastores. This query can be a combination of a DL parametric query, OnDemand query, and other query types involving supported datastores. To retrieve data from each datastore, the federated datastore delegates the query processing task to each of the native datastores.  
<table-cwu id="TABLE-US-00004">
<number>4</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>DKFederatedQuery.java</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>package com.ibm.mm.sdk.common.DKFederatedQuery</entry>
</row>
<row>
<entry></entry>
<entry>public class DKFederatedQuery</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>extends Object</entry>
</row>
<row>
<entry></entry>
<entry>implements dkQuery, DKConstant, DKMessageId, Serializable</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub;</entry>
</row>
<row>
<entry></entry>
<entry>public DKFederatedQuery(dkDatastore creator,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>String queryString)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>public DKFederatedQuery(dkDatastore creator,</entry>
</row>
<row>
<entry></entry>
<entry>public DKFederatedQuery(DKFederatedQuery fromQuery)</entry>
</row>
<row>
<entry></entry>
<entry>public void prepare(DKNVPair params&lsqb;&rsqb;) throws DKException,</entry>
</row>
<row>
<entry></entry>
<entry>Exception</entry>
</row>
<row>
<entry></entry>
<entry>public void execute(DKNVPair params&lsqb;&rsqb;) throws DKException,</entry>
</row>
<row>
<entry></entry>
<entry>Exception</entry>
</row>
<row>
<entry></entry>
<entry>public int status()</entry>
</row>
<row>
<entry></entry>
<entry>public Object result() throws DKException, Exception</entry>
</row>
<row>
<entry></entry>
<entry>public dkResultSetCursor resultSetCursor() throws DKException,</entry>
</row>
<row>
<entry></entry>
<entry>Exception</entry>
</row>
<row>
<entry></entry>
<entry>public short qlType()</entry>
</row>
<row>
<entry></entry>
<entry>public String queryString()</entry>
</row>
<row>
<entry></entry>
<entry>public dkDatastore getDatastore()</entry>
</row>
<row>
<entry></entry>
<entry>public void setDatastore(dkDatastore ds) throws DKException,</entry>
</row>
<row>
<entry></entry>
<entry>Exception</entry>
</row>
<row>
<entry></entry>
<entry>public String getName()</entry>
</row>
<row>
<entry></entry>
<entry>public void setName(String name)</entry>
</row>
<row>
<entry></entry>
<entry>public int numberOfResults()</entry>
</row>
<row>
<entry></entry>
<entry>&rcub;;</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0094" lvl="0"><number>&lsqb;0094&rsqb;</number> The following methods are part of the federated query class:  
<table-cwu id="TABLE-US-00005">
<number>5</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>public DKFederatedQuery(dkDatastore creator,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>String queryString)</entry>
</row>
<row>
<entry></entry>
<entry>Constructs a Federated query.</entry>
</row>
<row>
<entry></entry>
<entry>Parameters:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>creator - datastore</entry>
</row>
<row>
<entry></entry>
<entry>queryString - a query string</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>public DKFederatedQuery(dkDatastore creator,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>DKCQExpr queryExpr)</entry>
</row>
<row>
<entry></entry>
<entry>Constructs a Federated query</entry>
</row>
<row>
<entry></entry>
<entry>Parameters:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>creator - datastore</entry>
</row>
<row>
<entry></entry>
<entry>queryExpr - a query expression</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>public DKFederatedQuery(DKFederatedQuery fromQuery)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Constructs a Federated query from a Federated query object.</entry>
</row>
<row>
<entry></entry>
<entry>Parameters:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>fromQuery - Federated query</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>public void prepare(DKNVPair params&lsqb;&rsqb;) throws DKException, Exception</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Prepares a query.</entry>
</row>
<row>
<entry></entry>
<entry>Parameters:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>params - additional prepare query option in name/value pair</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>public void execute(DKNVPair params&lsqb;&rsqb;) throws DKException, Exception</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Executes a query.</entry>
</row>
<row>
<entry></entry>
<entry>Parameters:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>params - additional query option in name/value pair</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>public int status()</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Gets query status.</entry>
</row>
<row>
<entry></entry>
<entry>Returns:</entry>
</row>
<row>
<entry></entry>
<entry>query status</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>public Object result() throws DKException, Exception</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Gets query result.</entry>
</row>
<row>
<entry></entry>
<entry>Returns:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>query result in a DKResults object</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>public dkResultSetCursor resultSetCursor() throws DKException,</entry>
</row>
<row>
<entry>Exception</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Gets query result.</entry>
</row>
<row>
<entry></entry>
<entry>Returns:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>query result in a dkResultSetCursor object</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>public short qlType()</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Gets query type.</entry>
</row>
<row>
<entry></entry>
<entry>Returns:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>query type</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>public String queryString()</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Gets query string</entry>
</row>
<row>
<entry></entry>
<entry>Returns:</entry>
</row>
<row>
<entry></entry>
<entry>query string</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>public dkDatastore getDatastore()</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Gets the reference to the owner datastore object.</entry>
</row>
<row>
<entry></entry>
<entry>Returns:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>the dkDatastore object</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>public void setDatastore(dkDatastore ds) throws DKException, Exception</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Sets the reference to the owner datastore object.</entry>
</row>
<row>
<entry></entry>
<entry>Parameters:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>ds - a datastore</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>public String getName()</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Gets query name.</entry>
</row>
<row>
<entry></entry>
<entry>Returns:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>name of this query</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>public void setName(String name)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Sets query name.</entry>
</row>
<row>
<entry></entry>
<entry>Parameters:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>name - new name to be set to this query object</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>public int numberOfResults()</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Gets the number of query results.</entry>
</row>
<row>
<entry></entry>
<entry>Returns:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>number of query results</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
</section>
<section>
<heading lvl="1">Schema Mapping </heading>
<paragraph id="P-0095" lvl="0"><number>&lsqb;0095&rsqb;</number> A schema mapping represents a mapping between the schema in a datastore with the structure of the data-object that the user wants to process in memory. Schema mapping has been generally described in U.S. patent application Ser. Nos. 08/276,382 and 08/276,747, also assigned to IBM. </paragraph>
<paragraph id="P-0096" lvl="0"><number>&lsqb;0096&rsqb;</number> A federated schema is the conceptual schema of a federated datastore <highlight><bold>100</bold></highlight>, which defines a mapping between the concepts in the federated datastore <highlight><bold>100</bold></highlight> to concepts expressed in each participating datastore schema. In general, a schema mapping handles the difference between how the data are stored in the datastore (as expressed by the datastore&apos;s conceptual schema) and how the user wants to process them in the application program. This mapping can also be extended to incorporate relationship associations among entities in a federated datastore, e.g., associating an employee&apos;s name with the appropriate department name. Since the mapping process can be a bit tedious, it is usually done with the help of a typical GUI-oriented schema mapping program. </paragraph>
<paragraph id="P-0097" lvl="0"><number>&lsqb;0097&rsqb;</number> In addition to schema-mapping information involving the mapping of entities and attributes, a federated datastore <highlight><bold>100</bold></highlight> must also have access to the following information: </paragraph>
<paragraph id="P-0098" lvl="2"><number>&lsqb;0098&rsqb;</number> User-id and password mapping. To support single sign-on features, each user-id in the federated datastore <highlight><bold>100</bold></highlight> needs to be mapped to its corresponding user-ids in the native datastores. </paragraph>
<paragraph id="P-0099" lvl="2"><number>&lsqb;0099&rsqb;</number> Datastore registration. Each native datastore needs to be registered so it can be located and logged-on to by the federated datastore <highlight><bold>100</bold></highlight> processes on behalf of its users. </paragraph>
</section>
<section>
<heading lvl="1">Extended Grand Portal Architecture </heading>
<paragraph id="P-0100" lvl="0"><number>&lsqb;0100&rsqb;</number> In one embodiment, the invention is used within an extended Grand Portal Architecture. <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a diagram of an extended Grand Portal architecture. A Grand Portal client for a federated client datastore <highlight><bold>500</bold></highlight> is connected to a Grand Portal server for a federated server datastore <highlight><bold>502</bold></highlight>. Another federated client/server system <highlight><bold>504</bold></highlight> may be connected to the federated server <highlight><bold>502</bold></highlight>. A Grand Portal client/server system for an OnDemand (OD) datastore <highlight><bold>506</bold></highlight> may be part of the federation. Additionally, a Grand Portal client/server system for a Digital Library/VisualInfo (DL/VI) datastore <highlight><bold>508</bold></highlight> may be part of the federation. As with any of the datastores discussed herein, a user may access the client or the server directly. Therefore, user applications may reside at either the client or the server. </paragraph>
<paragraph id="P-0101" lvl="0"><number>&lsqb;0101&rsqb;</number> A Grand Portal client for a DES datastore <highlight><bold>510</bold></highlight> or a Grand Portal server for a DES datastore <highlight><bold>512</bold></highlight> may each be connected to the federation. While the DL/VI datastore enables searching a DL/VI Library server and the OD datastore enables searching of an OnDemand datastore, the DES datastore enables searching of multiple other datastores. In particular, the DES datastore enables searching of a Lotus Notes server <highlight><bold>514</bold></highlight>, a Web <highlight><bold>516</bold></highlight>, a file system <highlight><bold>518</bold></highlight>, and a relational database <highlight><bold>520</bold></highlight>. </paragraph>
<paragraph id="P-0102" lvl="0"><number>&lsqb;0102&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is a diagram illustrating individual datastores and federated compositions. In particular, a datastore can be configured as a stand-alone or as part of a federation. Additionally, a federated datastore can be composed of any number of datastores, including other federated datastores. Stand-alone datastores may be accessed directly by a user. The following are example stand-alone datastores in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>: a Digital Library (DL) datastore <highlight><bold>600</bold></highlight>, an OnDemand datastore <highlight><bold>602</bold></highlight>, a VisualInfo/<highlight><bold>400</bold></highlight> datastore <highlight><bold>604</bold></highlight>, a Domino.Doc datastore <highlight><bold>606</bold></highlight>, or a ImagePlus/<highlight><bold>390</bold></highlight> datastore <highlight><bold>608</bold></highlight>. Additionally, a DES datastore <highlight><bold>610</bold></highlight> maybe a stand alone in that it is not part of a federated composition. A federated composition <highlight><bold>612</bold></highlight> may include individual datastores <highlight><bold>614</bold></highlight> and <highlight><bold>616</bold></highlight>, another federated datastore <highlight><bold>618</bold></highlight>, and a search gateway to a DES datastore <highlight><bold>620</bold></highlight>. In turn, the DES datastore <highlight><bold>620</bold></highlight> enables searching a Lotus Notes database <highlight><bold>622</bold></highlight>, searching the Web <highlight><bold>624</bold></highlight>, searching a file system <highlight><bold>626</bold></highlight>, or searching a relational database <highlight><bold>628</bold></highlight> (e.g., DB2, Oracle, or ODBC). </paragraph>
</section>
<section>
<heading lvl="1">Managing Results of Federated Searches Across Heterogeneous Datastores with a Federated Result Set Cursor Object </heading>
<paragraph id="P-0103" lvl="0"><number>&lsqb;0103&rsqb;</number> An embodiment of the invention provides a federated result set cursor object. In particular, when a search is performed in a federated datastore, each &ldquo;heterogeneous&rdquo; or &ldquo;native&rdquo; datastore is searched. Then, a federated result set cursor object is returned, which points to the data. A cursor is an indicator that indicates the beginning of a set of data (e.g., records, files, etc.). A federated result set cursor object comprises a federated cursor that may be used to fetch data sequentially from each datastore and a native cursor for each native datastore that may be used to fetch data from a particular native datastore. For example, if the federated cursor initially points to data in a first datastore, serial fetches may be used to retrieve each piece of data in the first datastore, then the cursor is moved to another datastore, and fetches are used to retrieve data in this datastore. If a native datastore cursor is used to fetch data, the data is retrieved from the specified native datastore starting at the cursor position. </paragraph>
<paragraph id="P-0104" lvl="0"><number>&lsqb;0104&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> is a diagram illustrating a conceptual view of a federated result set cursor object. The federated result set cursor object contains <highlight><bold>700</bold></highlight> contains several individual cursors. The individual cursors include native cursors <highlight><bold>704</bold></highlight>, <highlight><bold>706</bold></highlight>, <highlight><bold>708</bold></highlight>, and <highlight><bold>710</bold></highlight>. A user or application may use any one of these cursors to fetch data. </paragraph>
<paragraph id="P-0105" lvl="0"><number>&lsqb;0105&rsqb;</number> When searching is performed in a federated datastore, the federated engine searches each heterogeneous datastore connected to the federated datastore. The federated engine may retrieve data from each separate datastore. Thus, the federated engine needs a technique for providing the data retrieved from multiple datastores in a single result set. </paragraph>
<paragraph id="P-0106" lvl="0"><number>&lsqb;0106&rsqb;</number> In one embodiment of the invention, one or more classes implement the federated result set cursor object, and one or more methods are provided to manipulate the federated result set cursor object. In one embodiment, the class definitions and methods reside at the federated datastore client and server. </paragraph>
<paragraph id="P-0107" lvl="0"><number>&lsqb;0107&rsqb;</number> In an object-oriented application, a result set cursor class is defined as a virtual collection in which the elements of the collection can be fetched one by one using fetch methods. One embodiment of the invention provides a data structure and methods to group data objects resulting from a query in a special result set cursor object. </paragraph>
<paragraph id="P-0108" lvl="0"><number>&lsqb;0108&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> is a diagram illustrating one use of the present invention. A federated datastore client <highlight><bold>800</bold></highlight> is connected to a federated datastore server <highlight><bold>802</bold></highlight>. The federated datastore server <highlight><bold>802</bold></highlight> is connected to several native datastores. The native datastores include a DL (Digital Library) datastore <highlight><bold>804</bold></highlight>, a VisualInfo datastore <highlight><bold>806</bold></highlight>, and an OnDemand datastore <highlight><bold>808</bold></highlight>. Initially, if a user or application program would like to retrieve data from the native datastores, the user or application program initiates a query <highlight><bold>810</bold></highlight> at the federated datastore client <highlight><bold>800</bold></highlight>. Although not shown, a user or application program may also initiate a query directly at the federated datastore server <highlight><bold>802</bold></highlight>. </paragraph>
<paragraph id="P-0109" lvl="0"><number>&lsqb;0109&rsqb;</number> The federated datastore client <highlight><bold>800</bold></highlight> passes the query to the federated datastore server <highlight><bold>802</bold></highlight>. Note that the federated datastore server <highlight><bold>802</bold></highlight> is able to determine the type of data to be retrieved (i.e., image or text) and recognizes which type of query each native datastore <highlight><bold>804</bold></highlight>, <highlight><bold>806</bold></highlight>, and <highlight><bold>808</bold></highlight> is able to process. Therefore, the federated datastore server <highlight><bold>802</bold></highlight> determines which native datastores are to receive the query. In this example, the federated datastore server <highlight><bold>802</bold></highlight> requests each native datastore <highlight><bold>804</bold></highlight>, <highlight><bold>806</bold></highlight>, and <highlight><bold>808</bold></highlight> to process the query. </paragraph>
<paragraph id="P-0110" lvl="0"><number>&lsqb;0110&rsqb;</number> Each native datastore <highlight><bold>804</bold></highlight>, <highlight><bold>806</bold></highlight>, and <highlight><bold>808</bold></highlight> performs a search for the requested data and sets a cursor to the data found in that native datastore <highlight><bold>804</bold></highlight>, <highlight><bold>806</bold></highlight>, and <highlight><bold>808</bold></highlight>. The cursors are returned to the federated datastore client <highlight><bold>800</bold></highlight> in a federated result set cursor object <highlight><bold>812</bold></highlight>. The federated result set cursor object <highlight><bold>812</bold></highlight> contains three circles that represent the three native datastore cursors. Additionally, the federated datastore server <highlight><bold>802</bold></highlight> selects one of the native datastore cursors as a beginning point for iterating through the found data. This selected native datastore cursor will be referred to in this example as a federated cursor. </paragraph>
<paragraph id="P-0111" lvl="0"><number>&lsqb;0111&rsqb;</number> At this time, a user or application program can submit a fetch request to actually retrieve desired data. For example, a user or application program may submit a fetch <highlight><bold>814</bold></highlight> specifying one of the cursors (i.e., a federated cursor or a native cursor). Then, the federated datastore client <highlight><bold>800</bold></highlight> passes the fetch <highlight><bold>814</bold></highlight> to the federated datastore server <highlight><bold>802</bold></highlight>. The federated datastore server <highlight><bold>802</bold></highlight> obtains the data at the specified cursor location. In particular, the federated datastore server <highlight><bold>802</bold></highlight> requests the data from a particular native datastore. The native datastore returns the data at the cursor location. The federated datastore server <highlight><bold>802</bold></highlight> processes the data, including converting the data using a schema mapping to place the data in a form desired by a user or application program. </paragraph>
<paragraph id="P-0112" lvl="0"><number>&lsqb;0112&rsqb;</number> The data is returned to a user or application program from the federated datastore server <highlight><bold>802</bold></highlight> via the federated datastore client <highlight><bold>800</bold></highlight>. The user or application program may submit additional fetch requests to obtain additional data. In particular, the user or application program may specify different cursors for each fetch request. Additionally, a user or application program may fetch the next piece of data using a fetch next command. </paragraph>
<paragraph id="P-0113" lvl="0"><number>&lsqb;0113&rsqb;</number> The results in the result set may be accessed with multiple techniques. For example, several result set cursors of data objects maybe aggregated while preserving each individual datastore result set cursor information. That is, the federated result set cursor object contains a federated cursor as well as native cursors. Each native datastore has a cursor indicating a position for reading the data in that datastore, and the federated cursor indicates a position for reading data from one of the datastores. Each result set cursor may be treated as one whole unit of a federated cursor, while the ability to access each individual result set cursor is preserved. </paragraph>
<paragraph id="P-0114" lvl="0"><number>&lsqb;0114&rsqb;</number> This structure is provided via a federated result set cursor object. The result set cursor object contains methods that allow a user or application program to fetch elements from the virtual collection. </paragraph>
<paragraph id="P-0115" lvl="0"><number>&lsqb;0115&rsqb;</number> An example class definition for a federated result set cursor (DKResultSetCursorFed.java) is set forth below.  
<table-cwu id="TABLE-US-00006">
<number>6</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="294PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>DKResultSetCursorFed.java</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="280PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>package com.ibm.mm.sdk.server;</entry>
</row>
<row>
<entry></entry>
<entry>public class DKResultSetCursorFed extends dkAbstractResultSetCursor</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="252PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>implements DKConstantFed, DKMessageIdFed</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="280PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub;</entry>
</row>
<row>
<entry></entry>
<entry>public DKResultSetCursorFed (DKDatastoreFed ds,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="70PT" align="left"/>
<colspec colname="1" colwidth="224PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>DKNVPair parm</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="238PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>throws DKException, Exception parms&lsqb;&rsqb;)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="280PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>public boolean isScrollable( ) throws DKException, Exception;</entry>
</row>
<row>
<entry></entry>
<entry>public boolean isUpdatable( ) throws DKException, Exception;</entry>
</row>
<row>
<entry></entry>
<entry>public boolean isValid( ) throws DKException, Exception;</entry>
</row>
<row>
<entry></entry>
<entry>public boolean isOpen( ) throws DKException, Exception;</entry>
</row>
<row>
<entry></entry>
<entry>public boolean isBegin( ) throws DKException, Exception;</entry>
</row>
<row>
<entry></entry>
<entry>public boolean isEnd( ) throws DKException, Exception;</entry>
</row>
<row>
<entry></entry>
<entry>public boolean isBetween( ) throws DKException, Exception;</entry>
</row>
<row>
<entry></entry>
<entry>public int getPosition( ) throws DKException, Exception;</entry>
</row>
<row>
<entry></entry>
<entry>public void setPosition(int position, Object value) throws DKException, Exception;</entry>
</row>
<row>
<entry></entry>
<entry>public void setToNext( ) throws DKException, Exception;</entry>
</row>
<row>
<entry></entry>
<entry>public DKDDO fetchObject( ) throws DKException, Exception;</entry>
</row>
<row>
<entry></entry>
<entry>public DKDDO fetchNext( ) throws DKException, Exception;</entry>
</row>
<row>
<entry></entry>
<entry>public boolean fetchNext(int how_many, dkCollection collection) throws DKException,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="252PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Exception;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="280PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>public Object fetchObjectByName(String dataItemName) throws DKException, Exception;</entry>
</row>
<row>
<entry></entry>
<entry>public Object fetchNextByName(String dataItemName) throws DKException, Exception;</entry>
</row>
<row>
<entry></entry>
<entry>public boolean fetchNextByName(String dataItemName, int how_many, Object &lsqb;&rsqb; array)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="252PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>throws DKException, Exception;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="280PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>public DKDDO findObject(int position, String predicate) throws DKException, Exception;</entry>
</row>
<row>
<entry></entry>
<entry>public void deleteObject( ) throws DKException, Exception;</entry>
</row>
<row>
<entry></entry>
<entry>public void updateObject(DKDDO ddo) throws DKException, Exception;</entry>
</row>
<row>
<entry></entry>
<entry>public DKDDO newObject( ) throws DKException, Exception;</entry>
</row>
<row>
<entry></entry>
<entry>public void addObject(DKDDO ddo) throws DKException, Exception;</entry>
</row>
<row>
<entry></entry>
<entry>public void open( ) throws DKException, Exception;</entry>
</row>
<row>
<entry></entry>
<entry>public void open(DKNVPair parms&lsqb;&rsqb;) throws DKException, Exception;</entry>
</row>
<row>
<entry></entry>
<entry>public void close( ) throws DKException, Exception;</entry>
</row>
<row>
<entry></entry>
<entry>public void destroy( ) throws DKException, Exception;</entry>
</row>
<row>
<entry></entry>
<entry>public String datastoreName( ) throws Exception;</entry>
</row>
<row>
<entry></entry>
<entry>public String datastoreType( ) throws Exception;</entry>
</row>
<row>
<entry></entry>
<entry>public DKHandle handle(String type) throws Exception;</entry>
</row>
<row>
<entry></entry>
<entry>public int cardinality( ) throws Exception;</entry>
</row>
<row>
<entry></entry>
<entry>public synchronized dkResultSetCursorfetchNextRSCursor( ) throws DKException, Exception;</entry>
</row>
<row>
<entry></entry>
<entry>public synchronized void addRSCursor(dkResultSetCursor rsCursor);</entry>
</row>
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0116" lvl="0"><number>&lsqb;0116&rsqb;</number> The following methods are part of the federated result set cursor class: </paragraph>
<paragraph id="P-0117" lvl="1"><number>&lsqb;0117&rsqb;</number> public boolean isScrollable( ) throws DKException, Exception; </paragraph>
<paragraph id="P-0118" lvl="0"><number>&lsqb;0118&rsqb;</number> Scrollable indicator that returns true if cursor can be scrolled forward and backward. </paragraph>
<paragraph id="P-0119" lvl="1"><number>&lsqb;0119&rsqb;</number> public boolean isUpdatable( ) throws DKException, Exception; </paragraph>
<paragraph id="P-0120" lvl="0"><number>&lsqb;0120&rsqb;</number> Updatable indicator that returns true if cursor is updatable. </paragraph>
<paragraph id="P-0121" lvl="1"><number>&lsqb;0121&rsqb;</number> public boolean isValid( ) throws DKException, Exception; </paragraph>
<paragraph id="P-0122" lvl="0"><number>&lsqb;0122&rsqb;</number> Valid indicator that returns true if cursor is valid. </paragraph>
<paragraph id="P-0123" lvl="1"><number>&lsqb;0123&rsqb;</number> public boolean isOpen( ) throws DKException, Exception; </paragraph>
<paragraph id="P-0124" lvl="0"><number>&lsqb;0124&rsqb;</number> Open indicator that returns true if cursor is in an opened state. </paragraph>
<paragraph id="P-0125" lvl="1"><number>&lsqb;0125&rsqb;</number> public boolean isBegin( ) throws DKException, Exception; </paragraph>
<paragraph id="P-0126" lvl="0"><number>&lsqb;0126&rsqb;</number> Begin indicator that returns true if cursor is positioned at the beginning. </paragraph>
<paragraph id="P-0127" lvl="1"><number>&lsqb;0127&rsqb;</number> public boolean isEnd( ) throws DKException, Exception; </paragraph>
<paragraph id="P-0128" lvl="0"><number>&lsqb;0128&rsqb;</number> End indicator that returns true if cursor is positioned at the end. </paragraph>
<paragraph id="P-0129" lvl="1"><number>&lsqb;0129&rsqb;</number> public boolean isBetween( ) throws DKException, Exception; </paragraph>
<paragraph id="P-0130" lvl="0"><number>&lsqb;0130&rsqb;</number> Between data objects in cursor indicator that returns true if cursor is in between data objects in the cursor. </paragraph>
<paragraph id="P-0131" lvl="1"><number>&lsqb;0131&rsqb;</number> public int getPosition( ) throws DKException, Exception; </paragraph>
<paragraph id="P-0132" lvl="0"><number>&lsqb;0132&rsqb;</number> Gets the current cursor position and returns the current cursor position. </paragraph>
<paragraph id="P-0133" lvl="1"><number>&lsqb;0133&rsqb;</number> public void setPosition(int position, Object value) throws DKException, Exception; </paragraph>
<paragraph id="P-0134" lvl="0"><number>&lsqb;0134&rsqb;</number> Sets the cursor to the given position, with the parameter position providing a cursor position option and the parameter value providing a cursor position value. </paragraph>
<paragraph id="P-0135" lvl="1"><number>&lsqb;0135&rsqb;</number> public void setToNext( ) throws DKException, Exception; </paragraph>
<paragraph id="P-0136" lvl="0"><number>&lsqb;0136&rsqb;</number> Sets cursor to point to the position of the next data object in the cursor. </paragraph>
<paragraph id="P-0137" lvl="1"><number>&lsqb;0137&rsqb;</number> public DKDDO fetchObject( ) throws DKException, Exception; </paragraph>
<paragraph id="P-0138" lvl="0"><number>&lsqb;0138&rsqb;</number> Fetches the element in the cursor at the current position and returns a DDO. </paragraph>
<paragraph id="P-0139" lvl="1"><number>&lsqb;0139&rsqb;</number> public DKDDO fetchNext( ) throws DKException, Exception; </paragraph>
<paragraph id="P-0140" lvl="0"><number>&lsqb;0140&rsqb;</number> Sets cursor to point to the position of the next data object and fetches the element in the cursor at that position and returns a DDO. </paragraph>
<paragraph id="P-0141" lvl="1"><number>&lsqb;0141&rsqb;</number> public boolean fetchNext(int how_many, dkCollection collection) throws DKException, Exception; </paragraph>
<paragraph id="P-0142" lvl="0"><number>&lsqb;0142&rsqb;</number> Fetches the next N elements of the cursor and inserts them into the given collection, with the parameter how_many indicating how many elements the user or application program wants to be returned in the collection and the parameter collection indicating the collection where elements that are fetched are stored. Returns true if there is at least one data object returned. </paragraph>
<paragraph id="P-0143" lvl="1"><number>&lsqb;0143&rsqb;</number> public Object fetchObjectByName(String dataItemName) throws DKException, Exception; </paragraph>
<paragraph id="P-0144" lvl="0"><number>&lsqb;0144&rsqb;</number> Fetches the data item value in the cursor at the current position by data item name, with the parameter dataItemName indicating a data item name, and returns an Object. </paragraph>
<paragraph id="P-0145" lvl="1"><number>&lsqb;0145&rsqb;</number> public Object fetchNextByName(String dataItemName) throws DKException, Exception; </paragraph>
<paragraph id="P-0146" lvl="0"><number>&lsqb;0146&rsqb;</number> Sets cursor to point to the position of the next data object and fetches the data item value in the cursor at that position by data item name, with the parameter dataItemName indicating a data item name, and returns an Object. </paragraph>
<paragraph id="P-0147" lvl="1"><number>&lsqb;0147&rsqb;</number> public boolean fetchNextByName(String dataItemName, int how_many, Object &lsqb; &rsqb; array) throws DKException, Exception; </paragraph>
<paragraph id="P-0148" lvl="0"><number>&lsqb;0148&rsqb;</number> Fetches the next N data item values of the cursor and inserts them into the given array, with the parameter dataItemName indicating a data item name, the parameter how_many indicating how many data item values the user or application program wants to be returned in the collection, and with the parameter array indicating an array where the data item values that are fetched are stored. Returns true if there is at least one data item value returned. </paragraph>
<paragraph id="P-0149" lvl="1"><number>&lsqb;0149&rsqb;</number> public DKDDO findObject(int position, String predicate) throws DKException, Exception; </paragraph>
<paragraph id="P-0150" lvl="0"><number>&lsqb;0150&rsqb;</number> Finds the data object which satisfies the given predicate, moves the cursor to that position, fetches the data object, and returns a DDO. </paragraph>
<paragraph id="P-0151" lvl="1"><number>&lsqb;0151&rsqb;</number> public void deleteObject( ) throws DKException, Exception; </paragraph>
<paragraph id="P-0152" lvl="0"><number>&lsqb;0152&rsqb;</number> Deletes element at the current cursor position from the datastore. </paragraph>
<paragraph id="P-0153" lvl="1"><number>&lsqb;0153&rsqb;</number> public void updateObject(DKDDO ddo) throws DKException, Exception; </paragraph>
<paragraph id="P-0154" lvl="0"><number>&lsqb;0154&rsqb;</number> Updates element at the current cursor position from the datastore. </paragraph>
<paragraph id="P-0155" lvl="1"><number>&lsqb;0155&rsqb;</number> public DKDDO newObject( ) throws DKException, Exception; </paragraph>
<paragraph id="P-0156" lvl="0"><number>&lsqb;0156&rsqb;</number> Constructs a new DDO of the same type as the items in the result and returns a DDO. </paragraph>
<paragraph id="P-0157" lvl="1"><number>&lsqb;0157&rsqb;</number> public void addObject(DKDDO ddo) throws DKException, Exception; </paragraph>
<paragraph id="P-0158" lvl="0"><number>&lsqb;0158&rsqb;</number> Adds an element to the datastore. </paragraph>
<paragraph id="P-0159" lvl="1"><number>&lsqb;0159&rsqb;</number> public void open( ) throws DKException, Exception; </paragraph>
<paragraph id="P-0160" lvl="0"><number>&lsqb;0160&rsqb;</number> Opens the cursor. This re-executes the query and repositions the cursor to the beginning. </paragraph>
<paragraph id="P-0161" lvl="1"><number>&lsqb;0161&rsqb;</number> public void open(DKNVPair parms&lsqb; &rsqb;) throws DKException, Exception; </paragraph>
<paragraph id="P-0162" lvl="0"><number>&lsqb;0162&rsqb;</number> Opens the cursor. This re-executes the query and repositions the cursor to the beginning. The parameter parms allows for parameters to be passed in for the reexecution of the query. </paragraph>
<paragraph id="P-0163" lvl="1"><number>&lsqb;0163&rsqb;</number> public void close( ) throws DKException, Exception </paragraph>
<paragraph id="P-0164" lvl="0"><number>&lsqb;0164&rsqb;</number> Closes the cursor and invalidates the result set. </paragraph>
<paragraph id="P-0165" lvl="1"><number>&lsqb;0165&rsqb;</number> public void destroy( ) throws DKException, Exception; </paragraph>
<paragraph id="P-0166" lvl="0"><number>&lsqb;0166&rsqb;</number> Destroys the cursor. This method allows for cleanup, before garbage-collection is done on this class. </paragraph>
<paragraph id="P-0167" lvl="1"><number>&lsqb;0167&rsqb;</number> public String datastoreName( ) throws Exception; </paragraph>
<paragraph id="P-0168" lvl="0"><number>&lsqb;0168&rsqb;</number> Gets the datastore name and returns the datastore name. </paragraph>
<paragraph id="P-0169" lvl="1"><number>&lsqb;0169&rsqb;</number> public String datastoreType( ) throws Exception; </paragraph>
<paragraph id="P-0170" lvl="0"><number>&lsqb;0170&rsqb;</number> Gets the datastore type and returns the datastore type. </paragraph>
<paragraph id="P-0171" lvl="1"><number>&lsqb;0171&rsqb;</number> public DKHandle handle(String type) throws Exception; </paragraph>
<paragraph id="P-0172" lvl="0"><number>&lsqb;0172&rsqb;</number> Gets a cursor handle with the parameter type indicating a type of cursor handle desired and returns a cursor handle. </paragraph>
<paragraph id="P-0173" lvl="1"><number>&lsqb;0173&rsqb;</number> public int cardinality( ) throws Exception; </paragraph>
<paragraph id="P-0174" lvl="0"><number>&lsqb;0174&rsqb;</number> Gets the number of query results and returns the number of query results. </paragraph>
<paragraph id="P-0175" lvl="1"><number>&lsqb;0175&rsqb;</number> public synchronized dkResultSetCursor fetchNextRSCursor( ) throws DKException, Exception; </paragraph>
<paragraph id="P-0176" lvl="0"><number>&lsqb;0176&rsqb;</number> Fetches the next result set cursor. </paragraph>
<paragraph id="P-0177" lvl="1"><number>&lsqb;0177&rsqb;</number> public synchronized void addRSCursor(dkResultSetCursor rsCursor); </paragraph>
<paragraph id="P-0178" lvl="0"><number>&lsqb;0178&rsqb;</number> Adds a resultSet cursor to this federated cursor. </paragraph>
<paragraph id="P-0179" lvl="0"><number>&lsqb;0179&rsqb;</number> The client application program may create and use a federated result set cursor object and fetch elements from the whole result set cursor across native datastore cursor (i.e., individual cursor) boundaries. Alternatively, the client application program may access each individual result set cursor and fetch elements from each group of results originated from a particular datastore. </paragraph>
<paragraph id="P-0180" lvl="0"><number>&lsqb;0180&rsqb;</number> One practical use of a federated collection object is to represent results of a query against several heterogeneous datastores. The embodiment of the invention allows an object oriented application program to manipulate data objects resulting from a multi-search query to heterogeneous datastores in a federated result set cursor that embodies result set cursors from each heterogeneous datastore. The federated result set cursor also preserves the sub-grouping relationships of data objects contained in the result set cursors from each heterogeneous datastore. </paragraph>
<paragraph id="P-0181" lvl="0"><number>&lsqb;0181&rsqb;</number> Such a result set cursor is very useful to represent the results of a query against heterogeneous datastores. The combined results of the multi-search query is a result set cursor that contains a result set cursor from each datastore. The client application program has a choice of fetching from the whole combined results with a flat result set cursor or to fetch from each datastore result set cursor individually while preserving the sub-grouping information and relationships. </paragraph>
<paragraph id="P-0182" lvl="0"><number>&lsqb;0182&rsqb;</number> This federated result set cursor would be created by the federated datastore to represent the results of a federated multi-search query. </paragraph>
<paragraph id="P-0183" lvl="0"><number>&lsqb;0183&rsqb;</number> A result set cursor is a feature supported by modem data base management systems, such as relational databases (e.g., DB2, Oracle, Sybase, Informix, etc.). All conventional result set cursors are flat in that they provide a single cursor to the retrieved data. </paragraph>
<paragraph id="P-0184" lvl="0"><number>&lsqb;0184&rsqb;</number> On the other hand, the embodiment of the invention provides a nested result set cursor, which can have any amount of depth, with each result set cursor containing data objects resulting from a query against a specific datastore. The nested or federated result set cursor aggregates the query results from a set of heterogeneous datastores. The nested or federated result set cursor may be used with a federated datastore and a federated query object to store the results of a query against heterogeneous datastores. </paragraph>
<paragraph id="P-0185" lvl="0"><number>&lsqb;0185&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference> is a flow diagram illustrating steps performed by a federated datastore to process a query. In block <highlight><bold>900</bold></highlight>, the federated datastore receives a query requesting data from the federated datastore. In block <highlight><bold>902</bold></highlight>, the federated datastore identifies which heterogeneous datastores connected to the federated datastore should process the query. In block, <highlight><bold>904</bold></highlight>, the federated datastore forwards the query to each identified heterogeneous datastore. In block <highlight><bold>906</bold></highlight>, the federated datastore receives a native cursor from each heterogeneous datastore that located data, with the native cursor indicating a beginning of the located data. In block <highlight><bold>908</bold></highlight>, the federated datastore selects one of the native cursors as a beginning point for iterating through the located data. In block <highlight><bold>910</bold></highlight>, the federated datastore generates a federated result set cursor object with each native cursor. In block <highlight><bold>912</bold></highlight>, the federated datastore returns a federated result set cursor object in response to the query. </paragraph>
<paragraph id="P-0186" lvl="0"><number>&lsqb;0186&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10</cross-reference> is a flow diagram illustrating steps performed by a federated datastore to process a fetch. In block <highlight><bold>1000</bold></highlight>, the federated datastore receives a fetch requesting physical data be retrieved from the federated datastore. Note that the fetch can be for more than one piece of data and can indicate that a next piece of data is to be retrieved. In block <highlight><bold>1102</bold></highlight>, the federated datastore determines whether the fetch references a federated cursor. If the fetch references a federated cursor, the federated datastore continues to block <highlight><bold>1004</bold></highlight>, otherwise, the federated datastore continues to block <highlight><bold>1006</bold></highlight>. In block <highlight><bold>1004</bold></highlight>, the federated datastore submits a request for physical data from the heterogeneous datastore in which the federated cursor identifies data. In block <highlight><bold>1006</bold></highlight>, the federated datastore submits a request for physical data from the heterogeneous datastore in which the native cursor identifies data. In block <highlight><bold>1008</bold></highlight>, the federated datastore receives data from the heterogenous datastore. In block <highlight><bold>1010</bold></highlight>, the federated datastore processes the received data, including performing conversion via schema mapping, if necessary. In block <highlight><bold>1012</bold></highlight>, the federated datastore returns the physical data in response to the fetch. </paragraph>
</section>
<section>
<heading lvl="1">Conclusion </heading>
<paragraph id="P-0187" lvl="0"><number>&lsqb;0187&rsqb;</number> This concludes the description of the preferred embodiment of the invention. The following describes some alternative embodiments for accomplishing the present invention. For example, any type of computer, such as a mainframe, minicomputer, personal computer, mobile device, or embedded system, or computer configuration, such as a timesharing mainframe, local area network, or standalone personal computer, could be used with the techniques of the present invention. </paragraph>
<paragraph id="P-0188" lvl="0"><number>&lsqb;0188&rsqb;</number> The foregoing description of the preferred embodiment of the invention has been presented for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. It is intended that the scope of the invention be limited not by this detailed description, but rather by the claims appended hereto. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method of executing one or more commands in a computer to perform a datastore operation at a computer, the method comprising the steps of: 
<claim-text>locating data in one or more datastores; </claim-text>
<claim-text>setting a cursor to the located data in each datastore; and </claim-text>
<claim-text>returning a set of cursors to the located data. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein one of the cursors is a federated cursor. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein one of the cursors is a native cursor. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising receiving a fetch command to retrieve located data. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00004">claim 4</dependent-claim-reference>, wherein the fetch command specifies one of the cursors. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference>, further comprising retrieving located data identified by the specified cursor. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. An apparatus for executing one or more commands in a computer, comprising: 
<claim-text>a computer having a datastore; and </claim-text>
<claim-text>one or more computer programs, performed by the computer, for locating data in one or more datastores, setting a cursor to the located data in each datastore, and returning a set of cursors to the located data. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference>, wherein one of the cursors is a federated cursor. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference>, wherein one of the cursors is a native cursor. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference>, further comprising receiving a fetch command to retrieve located data. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein the fetch command specifies one of the cursors. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, further comprising retrieving located data identified by the specified cursor. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. An article of manufacture comprising a program storage medium readable by a computer and embodying one or more instructions executable by the computer to perform method steps for executing one or more commands to perform a datastore operation at the computer, the method comprising the steps of: 
<claim-text>locating data in one or more datastores; </claim-text>
<claim-text>setting a cursor to the located data in each datastore; and </claim-text>
<claim-text>returning a set of cursors to the located data. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The article of manufacture of <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference>, wherein one of the cursors is a federated cursor. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The article of manufacture of <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference>, wherein one of the cursors is a native cursor. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The article of manufacture of <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference>, further comprising receiving a fetch command to retrieve located data. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The article of manufacture of <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, wherein the fetch command specifies one of the cursors. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The article of manufacture of <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference>, further comprising retrieving located data identified by the specified cursor.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>2</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030004931A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030004931A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030004931A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030004931A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030004931A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030004931A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030004931A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030004931A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030004931A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00009">
<image id="EMI-D00009" file="US20030004931A1-20030102-D00009.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00010">
<image id="EMI-D00010" file="US20030004931A1-20030102-D00010.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
