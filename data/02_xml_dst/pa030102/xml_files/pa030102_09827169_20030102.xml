<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030002447A1-20030102-M00001.NB SYSTEM "US20030002447A1-20030102-M00001.NB" NDATA NB>
<!ENTITY US20030002447A1-20030102-M00001.TIF SYSTEM "US20030002447A1-20030102-M00001.TIF" NDATA TIF>
<!ENTITY US20030002447A1-20030102-M00002.NB SYSTEM "US20030002447A1-20030102-M00002.NB" NDATA NB>
<!ENTITY US20030002447A1-20030102-M00002.TIF SYSTEM "US20030002447A1-20030102-M00002.TIF" NDATA TIF>
<!ENTITY US20030002447A1-20030102-M00003.NB SYSTEM "US20030002447A1-20030102-M00003.NB" NDATA NB>
<!ENTITY US20030002447A1-20030102-M00003.TIF SYSTEM "US20030002447A1-20030102-M00003.TIF" NDATA TIF>
<!ENTITY US20030002447A1-20030102-M00004.NB SYSTEM "US20030002447A1-20030102-M00004.NB" NDATA NB>
<!ENTITY US20030002447A1-20030102-M00004.TIF SYSTEM "US20030002447A1-20030102-M00004.TIF" NDATA TIF>
<!ENTITY US20030002447A1-20030102-M00005.NB SYSTEM "US20030002447A1-20030102-M00005.NB" NDATA NB>
<!ENTITY US20030002447A1-20030102-M00005.TIF SYSTEM "US20030002447A1-20030102-M00005.TIF" NDATA TIF>
<!ENTITY US20030002447A1-20030102-M00006.NB SYSTEM "US20030002447A1-20030102-M00006.NB" NDATA NB>
<!ENTITY US20030002447A1-20030102-M00006.TIF SYSTEM "US20030002447A1-20030102-M00006.TIF" NDATA TIF>
<!ENTITY US20030002447A1-20030102-M00007.NB SYSTEM "US20030002447A1-20030102-M00007.NB" NDATA NB>
<!ENTITY US20030002447A1-20030102-M00007.TIF SYSTEM "US20030002447A1-20030102-M00007.TIF" NDATA TIF>
<!ENTITY US20030002447A1-20030102-M00008.NB SYSTEM "US20030002447A1-20030102-M00008.NB" NDATA NB>
<!ENTITY US20030002447A1-20030102-M00008.TIF SYSTEM "US20030002447A1-20030102-M00008.TIF" NDATA TIF>
<!ENTITY US20030002447A1-20030102-M00009.NB SYSTEM "US20030002447A1-20030102-M00009.NB" NDATA NB>
<!ENTITY US20030002447A1-20030102-M00009.TIF SYSTEM "US20030002447A1-20030102-M00009.TIF" NDATA TIF>
<!ENTITY US20030002447A1-20030102-M00010.NB SYSTEM "US20030002447A1-20030102-M00010.NB" NDATA NB>
<!ENTITY US20030002447A1-20030102-M00010.TIF SYSTEM "US20030002447A1-20030102-M00010.TIF" NDATA TIF>
<!ENTITY US20030002447A1-20030102-M00011.NB SYSTEM "US20030002447A1-20030102-M00011.NB" NDATA NB>
<!ENTITY US20030002447A1-20030102-M00011.TIF SYSTEM "US20030002447A1-20030102-M00011.TIF" NDATA TIF>
<!ENTITY US20030002447A1-20030102-M00012.NB SYSTEM "US20030002447A1-20030102-M00012.NB" NDATA NB>
<!ENTITY US20030002447A1-20030102-M00012.TIF SYSTEM "US20030002447A1-20030102-M00012.TIF" NDATA TIF>
<!ENTITY US20030002447A1-20030102-M00013.NB SYSTEM "US20030002447A1-20030102-M00013.NB" NDATA NB>
<!ENTITY US20030002447A1-20030102-M00013.TIF SYSTEM "US20030002447A1-20030102-M00013.TIF" NDATA TIF>
<!ENTITY US20030002447A1-20030102-M00014.NB SYSTEM "US20030002447A1-20030102-M00014.NB" NDATA NB>
<!ENTITY US20030002447A1-20030102-M00014.TIF SYSTEM "US20030002447A1-20030102-M00014.TIF" NDATA TIF>
<!ENTITY US20030002447A1-20030102-M00015.NB SYSTEM "US20030002447A1-20030102-M00015.NB" NDATA NB>
<!ENTITY US20030002447A1-20030102-M00015.TIF SYSTEM "US20030002447A1-20030102-M00015.TIF" NDATA TIF>
<!ENTITY US20030002447A1-20030102-D00000.TIF SYSTEM "US20030002447A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030002447A1-20030102-D00001.TIF SYSTEM "US20030002447A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030002447A1-20030102-D00002.TIF SYSTEM "US20030002447A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030002447A1-20030102-D00003.TIF SYSTEM "US20030002447A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030002447A1-20030102-D00004.TIF SYSTEM "US20030002447A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030002447A1-20030102-D00005.TIF SYSTEM "US20030002447A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030002447A1-20030102-D00006.TIF SYSTEM "US20030002447A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030002447A1-20030102-D00007.TIF SYSTEM "US20030002447A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030002447A1-20030102-D00008.TIF SYSTEM "US20030002447A1-20030102-D00008.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030002447</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09827169</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010406</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>H04J001/16</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>370</class>
<subclass>254000</subclass>
</uspc>
</classification-us-primary>
<classification-us-secondary>
<uspc>
<class>370</class>
<subclass>252000</subclass>
</uspc>
</classification-us-secondary>
</classification-us>
<title-of-invention>Distributed actuation allocation for large assemblies of implementation units</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Warren</given-name>
<middle-name>B.</middle-name>
<family-name>Jackson</family-name>
</name>
<residence>
<residence-us>
<city>San Francisco</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Markus</given-name>
<middle-name>P.J.</middle-name>
<family-name>Fromherz</family-name>
</name>
<residence>
<residence-us>
<city>Palo Alto</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<assignee>
<organization-name>Xerox Corporation</organization-name>
<assignee-type>02</assignee-type>
</assignee>
<correspondence-address>
<name-1>OLIFF &amp; BERRIDGE, PLC</name-1>
<name-2></name-2>
<address>
<address-1>P.O. BOX 19928</address-1>
<city>ALEXANDRIA</city>
<state>VA</state>
<postalcode>22320</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">Apparatus and methods that approximately solve an actuation allocation problem by breaking the solution into modules, which may or may not be overlapping. The solution to the actuation allocation problem is expressed in terms of solutions for each of the modules. The solutions for the modules serve as constraints for a solution of the optimization problem on each module. The optimization problem for each module is decomposed into further modules until the modules consist of a small enough number of individual implementation units so that the solution for the module can be solved using conventional optimization techniques. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> 1. Field of Invention </paragraph>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> This invention is directed to apparatus and methods of actuation allocation of a group of implementation units. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> 2. Description of Related Art </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> Smart matter systems are systems with a large number of elements such as sensors, actuators, and/or allocators. A major problem for such systems is to coordinate the actions of many elements in order to obtain a desired result or goal for the entire smart matter system. The desired result is achieved by controlling or allocating a particular action to each individual actuator to obtain a cumulative actuation over all the actuators. The desired individual actuation of each actuator can be achieved in a number of ways. However, the actuation must be accomplished in some optimal or near-optimal way while satisfying a number of constraints. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> For systems having a relatively small number of actuators, it is relatively easy to determine the desired individual actuation to obtain an overall system actuation, e.g., using an exhaustive search method. Unfortunately, the number of ways to produce a desired collective result increases exponentially with the number of actuators to be controlled. Thus, the problem of allocating actuation among a number of actuators becomes considerably more difficult as the number of actuators increases in the smart matter regime. Moreover, as the number of actuators increases, the time available to compute the allocation often decreases because of the need to communicate the allocation decision to the increased number of actuators. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> A related art method of allocating actuators involves an exhaustive search technique, whereby a systematic search is conducted through all possible actuation allocations that are able to accomplish the desired result. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> Another related art method of allocating actuation involves solving a mixed integer nonlinear programming problem. The allocation problem is cast as a mixed integer nonlinear programming problem over a set of continuous and integer variables to select the actuation for each actuator. Various methods, such as branch-and-bound, Bender&apos;s decomposition, and outer approximations are used to solve mixed integer nonlinear programming problems. These methods solve the optimization problem without integer constraints and then incrementally enforce the integer constraints. The result is that, rather than computing all of the exponential number of combinations that are possible, only promising branches of the search tree are computed with the expense of solving a nonlinear optimization problem at each node of the tree. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> Other related art methods to solve the constrained optimization for the actuator allocation use standard optimization methods such as interior point or active set methods. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> However, these related art methods have numerous disadvantages and shortfalls. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> The related art method of allocating actuation through an exhaustive search technique may operate within certain acceptable parameters for smart matter systems that require control of only a relatively small number of actuators, because all of the possible solutions can be computed in a relatively short period of time. However, the computational effort for exhaustive search grows exponentially with the number of actuators and the number of actuator states, and is therefore not feasible if the number of actuators increases beyond a certain limit, which is typically less than 10 depending on the processor speed and control bandwidth desired. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> The related art method of using mixed integer nonlinear programming to allocate actuators also has disadvantages. The computations at each branch are more complex because they involve the solution of a constrained nonlinear programming problem at each step. Moreover, the algorithms for this method require full knowledge of the system in a central location, and the allocations are difficult to distribute among a number of processors. Thus, for methods employing nonlinear programming techniques, if the hardware of a system is modular in nature, extensive communication is required to provide the central allocator with the required information. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> The related art methods of allocating actuators using standard optimization techniques also have disadvantages. These types of methods require solutions that result in large deviations from optimality, because the solutions are restricted to binary values and numbers of actuators less than 100. These techniques also require universal knowledge about the system and therefore make heavy use of communications, which constitutes a large cost in distributed systems. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> As a result of the shortcomings of the above related art methods, new methods and apparatus for allocating actuation are needed for smart matter systems. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> The present invention provides methods and apparatus that hierarchically decompose an actuation allocation and balance the need for rapid computation against optimality. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> The present invention separately provides methods and apparatus that are able to allocate actuation for systems having differing numbers of implementation units, ranging from a few implementation units (e.g., 10) to a large number of implementation units (greater than 10000). </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> The present invention separately provides methods and apparatus for allocating control of implementation units that minimize the need for communication with a system controller. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> The present invention separately provides methods and apparatus that use continuous high level solutions to break an actuator allocation problem into smaller problems that can be solved in an optimal way or by breaking the smaller allocation problem down into yet smaller problems. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> The present invention separately provides methods and apparatus that decompose a plurality of actuators into groups of actuators and further deocompose the groups into smaller groups, such as modules and submodules, until the groups include a number of actuators that a local optimal search can be performed, wherein the positions of the actuators do not have to be known for the decomposition of the actuators and the details of a submodule are not required to be known by the module that includes the submodule. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> The present invention separately provides methods and apparatus that decomposes a plurality of actuators into groups of actuators wherein the grouping of actuators can be an arbitrary grouping. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> The present invention separately provides methods and apparatus wherein the time to compute the near optimal actuator allocation scales with the number of actuators. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> The present invention separately provides methods and apparatus for allocating actuation that are hierarchical in nature so the computation of the allocation of the actuators is adaptable to the structure of the smart matter system and the smart matter communication system. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> The present invention separately provides methods and apparatus for actuator allocation that are suitable for tiled actuation. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> The present invention separately provides methods for actuator allocation that are capable of being implemented by multiprocessors. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> These and other features and advantages of this invention are described in or are apparent from the following detailed description of various exemplary embodiments of the apparatus and methods according to this invention.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> Various exemplary embodiments of systems and methods according to this invention will be described in detail, with reference to the following figures, wherein: </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a schematic of an exemplary embodiment of a many element system according to this invention; </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a schematic of an exemplary embodiment of an air jet paper transport system, according to this invention; </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a schematic of an exemplary embodiment of an array of actuators, according to this invention; </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is flow chart outlining an exemplary embodiment of a method for allocating an overall objective for a smart matter system, according to this invention; </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a schematic of an exemplary embodiment of a physical heuristic grouping of an array of actuators, according to this invention; </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is a schematic of an exemplary embodiment of a logical heuristic grouping of an array of actuators, according to this invention; </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> is a chart displaying a method of error allocation throughout a plurality of subdomains according to one exemplary embodiment of the present invention; </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> is a chart showing a pictorial representation of a sample rms combined error over the grid for an optimal allocation algorithm; </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference> is a chart showing a grid of evaluated force/torque points (within circle); </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10</cross-reference> is a chart showing the scaling of rms error and computation time for an optimal flat allocation algorithm; </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 11</cross-reference> is bar graph showing rms, maximum and individual errors for the central region of the force/torque grid for four different allocation algorithms; </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 12</cross-reference> is a chart showing the scaling of computation time of four different allocation algorithms; and </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 13</cross-reference> is a chart showing the scaling of error of three different allocation algorithms.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF PREFERRED EMBODIMENTS </heading>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> There are many types of many element systems that include implementation units, wherein an overall goal of the entire system is desired, but because of the aforementioned problems, it is difficult to allocate instructions to the implementation units to obtain that overall goal. The present invention provides for allocating that overall goal to groups of implementation units, i.e. subdomains or implementation modules, as well as individual implementation units. Thus, according to the present invention, an array of implementation units is divided into subdomains where the desired goal is provided to the subdomains. Also, in accordance with the present invention, the subdomains can also be divided into further subdomains and the process can be continued until the last subdomains have a sufficiently small number of implementation units to perform a local optimal search. The subdomains do not have to align exactly with any particular implementation unit, but rather they can represent an arbitrary grouping of implementation units. Further, the positions or arrangements of the implementation units do not have to be known for decomposition of the overall goal and the details of the lower level subdomains can be hidden from upper level subdomains. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a schematic that shows one exemplary embodiment of a many element system <highlight><bold>100</bold></highlight> having a distributed actuation allocation, according to this invention. The system <highlight><bold>100</bold></highlight> can be any type of system that is used in any number of different types of applications, such as but not limited to an air jet paper transport systems, robotic systems and the like. System <highlight><bold>100</bold></highlight> includes a system allocator <highlight><bold>110</bold></highlight>, a plurality of implementation units <highlight><bold>120</bold></highlight>, an input device <highlight><bold>130</bold></highlight>, a controller <highlight><bold>135</bold></highlight> and at least one sensor <highlight><bold>140</bold></highlight>. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> The plurality of implementation units <highlight><bold>120</bold></highlight> includes individual implementation units <highlight><bold>150</bold></highlight>. The implementation units <highlight><bold>150</bold></highlight>, under the control of the allocator <highlight><bold>110</bold></highlight>, operate to create a desired result or action. In various exemplary embodiments, the plurality of implementation units <highlight><bold>120</bold></highlight> are an array of implementation units. In various exemplary embodiments, the implementation units <highlight><bold>150</bold></highlight> are actuators. In other various exemplary embodiments, the implementation units <highlight><bold>150</bold></highlight> are air jets that act upon a piece of paper to move the paper from one position to another. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> The input device <highlight><bold>130</bold></highlight> communicates with the controller <highlight><bold>135</bold></highlight> along communication link <highlight><bold>132</bold></highlight>. The input device <highlight><bold>130</bold></highlight> provides the controller <highlight><bold>135</bold></highlight> with an overall objective. In various exemplary embodiments the input device <highlight><bold>130</bold></highlight> is a computer or a software program configured to generate the overall objective for the system <highlight><bold>100</bold></highlight>. In other various exemplary embodiments the input source <highlight><bold>130</bold></highlight> is, but is not limited to, a joystick, mouse, or other graphical input source read by a computer where the objective for the system <highlight><bold>100</bold></highlight> is related to the output of the graphical input source. In other various exemplary embodiments, the input source <highlight><bold>130</bold></highlight> is a higher-level control element or elements of a system that includes system <highlight><bold>100</bold></highlight>. An example of a higher-level control element is a job scheduler of a printing system which sends paper motion goals (desired trajectories) to a paper handler (an example of a system <highlight><bold>100</bold></highlight>). </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> It should be appreciated that in various exemplary embodiments, the overall objective can be, but is not limited to, a trajectory of an object or in other various exemplary embodiments, a desired state of the implementation units. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> The at least one sensor <highlight><bold>140</bold></highlight> communicates with the controller <highlight><bold>135</bold></highlight> along a communications link <highlight><bold>142</bold></highlight>. The at least one sensor <highlight><bold>140</bold></highlight> monitors or detects the current status of the actuation of the plurality of implementation units <highlight><bold>150</bold></highlight> and provides the status information to the controller <highlight><bold>135</bold></highlight> along communications link <highlight><bold>142</bold></highlight>. In other various exemplary embodiments, the at least one sensor <highlight><bold>140</bold></highlight> detects the status of an object upon which the plurality of implementation units <highlight><bold>150</bold></highlight> act. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> The controller <highlight><bold>135</bold></highlight> receives the overall objective from the input source <highlight><bold>130</bold></highlight>. The controller <highlight><bold>135</bold></highlight> computes a system goal, based on the overall objective. In various exemplary embodiments that include at least one sensor <highlight><bold>140</bold></highlight>, the controller <highlight><bold>135</bold></highlight> receives the current status information from the at least one sensor <highlight><bold>140</bold></highlight> and computes instructions, based on the overall objective and the current status information. In various exemplary embodiments, the controller <highlight><bold>135</bold></highlight> is a proportional derivative controller. It should be appreciated that any known or later developed controller may be used as controller <highlight><bold>135</bold></highlight>. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> In various exemplary embodiments the system goal is a force allocation, instruction or goal for the implementation units <highlight><bold>150</bold></highlight> to achieve. In various exemplary embodiments, the system goal is a continuous value. In other various exemplary embodiments, the system goal is a discrete value. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> The allocator <highlight><bold>110</bold></highlight> receives the instructions from the controller <highlight><bold>135</bold></highlight>. The allocator <highlight><bold>110</bold></highlight> implements an allocation algorithm to determine which implementation units should be actuated in order to achieve the overall objective for the system <highlight><bold>100</bold></highlight>. The allocator <highlight><bold>110</bold></highlight> communicates with the plurality of implementation units <highlight><bold>120</bold></highlight> along at least one communication link <highlight><bold>112</bold></highlight>. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> In various exemplary embodiments, the plurality of implementation units <highlight><bold>120</bold></highlight> are divided into groups of implementation units. The groups of implementation units can be further divided until the number of implementation units in the groups is sufficiently small enough to allow the allocator <highlight><bold>110</bold></highlight> to perform a local optimal allocation search. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> The plurality of implementation units are divided into a plurality of implementation unit modules <highlight><bold>170</bold></highlight> and <highlight><bold>180</bold></highlight>. In various exemplary embodiments the implementation unit modules <highlight><bold>170</bold></highlight> include individual implementation units <highlight><bold>150</bold></highlight>. In various exemplary embodiments the implementation unit modules <highlight><bold>180</bold></highlight> include at least one other implementation unit module <highlight><bold>170</bold></highlight> as a submodule. In various exemplary embodiments, more than one of the implementation unit modules <highlight><bold>170</bold></highlight> include the same individual implementation unit <highlight><bold>150</bold></highlight>, (this arrangement is not shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>). In various exemplary embodiments, more than the implementation unit module <highlight><bold>180</bold></highlight> includes the same implementation unit module <highlight><bold>170</bold></highlight> (this arrangement is not shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>). It is understood that the plurality of implementation units <highlight><bold>150</bold></highlight> may be further divided and grouped in many varying arrangements. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> In various exemplary embodiments, the allocator <highlight><bold>110</bold></highlight> allocates the overall objective to the plurality of implementation units <highlight><bold>120</bold></highlight> by expressing the overall objective in terms of solutions, module allocation, sub-goals, sub-objectives or sub-instructions for each of the modules <highlight><bold>170</bold></highlight> and <highlight><bold>180</bold></highlight>. The solutions for each of the modules <highlight><bold>170</bold></highlight> and <highlight><bold>180</bold></highlight> serve as constraints for a solution for the overall objective allocation. The solution for each module <highlight><bold>170</bold></highlight> may in turn be decomposed into further subsolutions for submodules, thus providing hierarchical decomposition. The hierarchical decomposition can be continued by the allocator <highlight><bold>110</bold></highlight> until the submodules include a sufficiently small enough number of individual implementation units <highlight><bold>150</bold></highlight> so that the allocation solution for that submodule can be performed quickly using a conventional technique, such as but not limited to an exhaustive search technique. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> In various exemplary embodiments, the allocator <highlight><bold>110</bold></highlight> includes a plurality of allocation levels. In an exemplary embodiment, shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, the allocator <highlight><bold>110</bold></highlight> has a top level <highlight><bold>116</bold></highlight>, a middle level <highlight><bold>117</bold></highlight> and a bottom level <highlight><bold>118</bold></highlight>. In various exemplary embodiments, the allocator <highlight><bold>110</bold></highlight> includes as few as one allocation level to as many allocation levels as necessary to communicate to all implementation units such that the allocation can be performed within desired time constraints. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> The top level <highlight><bold>116</bold></highlight> includes a module allocator <highlight><bold>191</bold></highlight>. The middle level <highlight><bold>117</bold></highlight> includes module allocators <highlight><bold>192</bold></highlight> and <highlight><bold>193</bold></highlight>. The bottom allocation level <highlight><bold>118</bold></highlight> includes module allocators <highlight><bold>194</bold></highlight>, <highlight><bold>195</bold></highlight>, <highlight><bold>196</bold></highlight> and <highlight><bold>197</bold></highlight>. The allocation levels <highlight><bold>116</bold></highlight>, <highlight><bold>117</bold></highlight> and <highlight><bold>118</bold></highlight> are arranged in a hierarchical arrangement, whereby the module allocator <highlight><bold>191</bold></highlight> in the top level <highlight><bold>116</bold></highlight> controls the module allocators <highlight><bold>192</bold></highlight> and <highlight><bold>193</bold></highlight> of the middle level <highlight><bold>117</bold></highlight>. The module allocator <highlight><bold>192</bold></highlight> of the middle allocator level <highlight><bold>117</bold></highlight> controls the module allocators <highlight><bold>194</bold></highlight> and <highlight><bold>195</bold></highlight> in the bottom allocation level. The module allocator <highlight><bold>193</bold></highlight> of the middle allocation level <highlight><bold>117</bold></highlight> controls the module allocators <highlight><bold>196</bold></highlight> and <highlight><bold>197</bold></highlight> of the bottom allocation level <highlight><bold>118</bold></highlight>. The module allocators <highlight><bold>194</bold></highlight>, <highlight><bold>195</bold></highlight>, <highlight><bold>196</bold></highlight> and <highlight><bold>197</bold></highlight> of the bottom level <highlight><bold>118</bold></highlight> control respective groups of implementation units <highlight><bold>170</bold></highlight> or individual implementation units <highlight><bold>150</bold></highlight>. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> It should be appreciated that the controller <highlight><bold>135</bold></highlight> and actuator <highlight><bold>110</bold></highlight> shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference> can be implemented as portions of a suitable system, manager or programmed general purpose computer. Alternatively, the controller <highlight><bold>135</bold></highlight> and actuator <highlight><bold>110</bold></highlight> can be implemented using an ASIC, a FPGA, a PEDL, a PLA, or a PAL, or using physically distinct hardware circuits, such as discrete logic elements or discrete circuit elements. The particular form the controller <highlight><bold>135</bold></highlight> and actuator <highlight><bold>110</bold></highlight> shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference> will take is a design choice. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> The links <highlight><bold>112</bold></highlight>, <highlight><bold>132</bold></highlight>, <highlight><bold>137</bold></highlight> and <highlight><bold>142</bold></highlight> can each be any known or later developed device or system for connecting the array of implementation units <highlight><bold>120</bold></highlight>, the goal generation device <highlight><bold>130</bold></highlight>, and the at least one sensor <highlight><bold>140</bold></highlight>, respectively, to the allocator <highlight><bold>110</bold></highlight>, including a wire, a direct cable connection, a connection over a wide area network or a local area network, a connection over an intranet, a wireless connection, a connection over the Internet, or a connection over any other distributed processing network or system. In general, the links <highlight><bold>112</bold></highlight>, <highlight><bold>132</bold></highlight>, <highlight><bold>137</bold></highlight> and <highlight><bold>142</bold></highlight> can be any known or later developed communication system or structure usable to connect the respective devices. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> It should be appreciated that the plurality of implementation units <highlight><bold>120</bold></highlight>, the input device <highlight><bold>130</bold></highlight>, the controller <highlight><bold>135</bold></highlight> and the allocator <highlight><bold>110</bold></highlight> do not have to be physically located together. Furthermore, it should be appreciated that the allocator <highlight><bold>110</bold></highlight> and the controller <highlight><bold>135</bold></highlight> can be integrated into a single device. It should also be appreciated that the input source <highlight><bold>130</bold></highlight>, the controller <highlight><bold>135</bold></highlight> and the allocator <highlight><bold>110</bold></highlight> can be integrated into a single device. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> shows an air jet paper transport system <highlight><bold>200</bold></highlight>, which is one exemplary embodiment of a many implementation unit system <highlight><bold>100</bold></highlight>. The system <highlight><bold>200</bold></highlight> includes a controller/allocator <highlight><bold>210</bold></highlight>, which is an exemplary embodiment of a device that includes a controller integrated with an allocator. In various exemplary embodiments the controller/allocator <highlight><bold>210</bold></highlight> includes hierarchical allocation levels similar to the allocator <highlight><bold>110</bold></highlight>. </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> The system <highlight><bold>200</bold></highlight> also includes an array of air jets <highlight><bold>220</bold></highlight> and a input source <highlight><bold>230</bold></highlight>, and a plurality of sensors <highlight><bold>240</bold></highlight>. These devices are exemplary embodiments of the array <highlight><bold>120</bold></highlight>, the input device <highlight><bold>130</bold></highlight> and the at least one sensors <highlight><bold>140</bold></highlight>, respectively. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> Further, the controller/allocator <highlight><bold>210</bold></highlight> is in communication with the input source <highlight><bold>230</bold></highlight> via communication link <highlight><bold>232</bold></highlight>, the sensors <highlight><bold>240</bold></highlight> via communication link <highlight><bold>242</bold></highlight> and the air jets via communication link <highlight><bold>222</bold></highlight>. Links <highlight><bold>222</bold></highlight>, <highlight><bold>232</bold></highlight> and <highlight><bold>242</bold></highlight> are exemplary embodiments of links <highlight><bold>122</bold></highlight>, <highlight><bold>132</bold></highlight> and <highlight><bold>142</bold></highlight>. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> Disposed along link <highlight><bold>222</bold></highlight> is at least one valve driver device <highlight><bold>224</bold></highlight>, which controls the opening and closing of the individual air jet valves <highlight><bold>250</bold></highlight> based on instructions received from the allocator via link <highlight><bold>222</bold></highlight>. The at least one valve driver device <highlight><bold>224</bold></highlight> may be any known or later developed valve driver device. </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> Disposed along link <highlight><bold>242</bold></highlight> is at least one sensor readout <highlight><bold>242</bold></highlight>, which receives signals from the sensors <highlight><bold>240</bold></highlight> via conventional techniques and/or devices, and provides the sensor signals to the controller <highlight><bold>210</bold></highlight> via link <highlight><bold>242</bold></highlight>. The sensor read out <highlight><bold>242</bold></highlight> may be any known or later developed device. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> An object <highlight><bold>260</bold></highlight> is disposed over the array of air jets <highlight><bold>250</bold></highlight>. In this exemplary embodiment, the object <highlight><bold>260</bold></highlight> is a piece of paper. The air jets <highlight><bold>250</bold></highlight> will, under the control of the controller/allocator <highlight><bold>210</bold></highlight>, move the object <highlight><bold>260</bold></highlight> to a particular position or orientate the object <highlight><bold>260</bold></highlight> in a particular orientation. </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> The sensors <highlight><bold>240</bold></highlight> are dispersed throughout the array <highlight><bold>220</bold></highlight>. In various exemplary embodiments, the sensors <highlight><bold>240</bold></highlight> are CMOS image sensor bars located throughout the actuation surface. The sensors are wired to detect edge positions of the object <highlight><bold>260</bold></highlight>. The spacing of the sensors <highlight><bold>240</bold></highlight> is such that, for typically sheet sizes of paper, there are always at least four points where a paper edge intersects the sensors <highlight><bold>240</bold></highlight>. Thus, the x, y, and angular positions of the object <highlight><bold>260</bold></highlight> can be determined as the object <highlight><bold>200</bold></highlight> moves over the array <highlight><bold>220</bold></highlight>. In various exemplary embodiments, read-outs of the sensors <highlight><bold>240</bold></highlight> and position calculation take well less than 1 ms. </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> In various exemplary embodiments, the array of air jets <highlight><bold>220</bold></highlight> includes 576 angled air jets. The angled air jets are oriented in one of four different directions (left, right, up, and down) and distributed equally in the array <highlight><bold>220</bold></highlight>. In this exemplary embodiment, the array of air jets <highlight><bold>220</bold></highlight> may be thought of as consisting of 36 (or 6&times;6) &ldquo;tiles&rdquo;/actuator modules <highlight><bold>270</bold></highlight> of air jets. In various exemplary embodiments, each tile/actuator module <highlight><bold>270</bold></highlight> includes sixteen (or 4&times;4) air jets. The actuator modules <highlight><bold>270</bold></highlight> can be grouped together to form larger actuation modules <highlight><bold>280</bold></highlight>. In embodiments that include the large actuator modules <highlight><bold>280</bold></highlight>, the actuator modules <highlight><bold>270</bold></highlight> can be thought of as submodule actuators of the larger module actuator <highlight><bold>280</bold></highlight>. In accordance with the present invention, it should be appreciated that the larger actuator modules <highlight><bold>280</bold></highlight> could be grouped together to form even larger actuator modules and that the actuator modules <highlight><bold>270</bold></highlight> could be further decomposed into further actuation submodules. </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> In various exemplary embodiments, individually computer-addressable electrostatic flap valves control the flow of air through each air jet <highlight><bold>250</bold></highlight>. Note, the source of the air is not shown. The air from a jet impinges on the object <highlight><bold>260</bold></highlight>. In an exemplary embodiment, wherein the object <highlight><bold>160</bold></highlight> is a sheet of paper, the air coming from the air jets <highlight><bold>250</bold></highlight> makes the paper float above the array <highlight><bold>220</bold></highlight>. In various exemplary embodiments, the paper floats roughly 2 mm above the exit of the air-jets <highlight><bold>250</bold></highlight>. Due to the viscous drag of the air against the paper, a force is applied to the paper largely confined in a small circular region around the impact point of the air on the paper. Forces on the order of 10<highlight><superscript>&minus;4 </superscript></highlight>Nt per jet for supply pressures of 1 kPa are typical. See Biegelsen, David K; Panides, Elias; Swartz, Lars E; Jackson, Warren B; Berlin, Andrew A. Characterization of Shear Stress Field Induced By Obliquely Impinging Air Jets, MEMS-Vol. 1, Microelectromechanical Systems (MEMS) (ASME 1999), pp. 385-389, which is incorporated herein by reference. </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> The forces of each air jet <highlight><bold>250</bold></highlight> add together as a linear superposition. Because the valves of each air jet <highlight><bold>250</bold></highlight> are either open or closed, each air jet <highlight><bold>250</bold></highlight> is essentially a binary force actuator. The entire array <highlight><bold>220</bold></highlight> can be viewed as a distributed array of binary force actuators. In various exemplary embodiments, the response time of an air jet <highlight><bold>250</bold></highlight>, namely the time it takes for an air jet <highlight><bold>250</bold></highlight> to respond to a command, depends on the voltage applied to the flap valve of the air jet <highlight><bold>250</bold></highlight>, as well as the air supply pressure. In various exemplary embodiments, the response time of an air jet <highlight><bold>250</bold></highlight> is typically on the order of 1-2 ms. </paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> The state of object <highlight><bold>260</bold></highlight> can be described by six values. Particularly, the object <highlight><bold>260</bold></highlight> can have an x position, a y position, an angular position, a velocity in the x direction, a velocity in the y direction and an angular velocity about an axis (z axis) perpendicular to the plane of the air jets. </paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> The controller/allocator <highlight><bold>210</bold></highlight> must choose from these multiple air jets <highlight><bold>250</bold></highlight> to apply the necessary forces to move the object <highlight><bold>260</bold></highlight> toward a desired overall objective. This arrangement illustrates that the problem of force allocation to actuators is an instance of the general problem of allocating a desired macro-level actuation to the micro-level actuators of a highly distributed system. In this exemplary embodiment, the actuators are binary air jets, which creates an integer programming problem. The controller/allocator <highlight><bold>210</bold></highlight> employs allocation methods, according to this invention, that solves these problems. </paragraph>
<paragraph id="P-0068" lvl="0"><number>&lsqb;0068&rsqb;</number> As the object <highlight><bold>260</bold></highlight> moves across the array <highlight><bold>220</bold></highlight>, the positions of sheet edges are sensed by the sensors <highlight><bold>240</bold></highlight>. These sensor readings are used by the controller/allocator <highlight><bold>210</bold></highlight> to compute the x, y, and angular positions of the object <highlight><bold>260</bold></highlight>. This position information over time is used to also compute the x, y and angular velocities of the object <highlight><bold>260</bold></highlight>. The positions and velocities of the object <highlight><bold>260</bold></highlight>, are the object state. The controller/allocator <highlight><bold>210</bold></highlight> computes the object state and compares it to a desired state given by a predetermined or dynamic trajectory, which is originally based on the overall objective from the input source <highlight><bold>230</bold></highlight>. </paragraph>
<paragraph id="P-0069" lvl="0"><number>&lsqb;0069&rsqb;</number> In various exemplary embodiments, the controller/allocator <highlight><bold>210</bold></highlight> includes a plurality of allocation levels, each having at least one module allocator, not shown in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, which are arranged in a hierarchical manner. The plurality of module allocators are used to compute the desired x and y forces and a torque about the z-axis (perpendicular to the object <highlight><bold>260</bold></highlight>) for each larger module actuator <highlight><bold>280</bold></highlight> and for each module actuator <highlight><bold>270</bold></highlight>,submodule. These forces are then allocated to the individual air jets <highlight><bold>250</bold></highlight> that together apply the desired actuation forces to the object <highlight><bold>260</bold></highlight>. In various exemplary embodiments, this control cycle is executed once every millisecond. It should be appreciated, that in other various exemplary embodiments, the controller/allocator <highlight><bold>210</bold></highlight> may include additional and/or separate allocation devices having module allocators to assist in allocating the overall objective. </paragraph>
<paragraph id="P-0070" lvl="0"><number>&lsqb;0070&rsqb;</number> Exemplary paper transport systems are disclosed in the following: (1) Berlin, Andrew; Biegelsen, David; Cheung, Patrick; Fromherz, Markus; Goldberg, David; Jackson, Warren; Panides, Elias; Preas, Bryan; Reich, James; and Swartz, Lars, &ldquo;Paper Transport Using Modulated Airjet Arrays,&rdquo; IS&amp;Ts NIP 15:1999 International Conference on Digital Printing Technologies, Orlando, Fla., October, 1999, pp. 285-288; and (2) Biegelsen, David; Berlin, Andrew; Cheung, Patrick; Fromherz, Markus; Goldberg, David; Jackson, Warren; Preas, Bryan; Reich, James; and Swartz, Lars, &ldquo;AirJet Paper Mover: An Example of Meso-Scale MEMS,&rdquo; SPIE, Micromachined Devices and Components VI, Santa Clara, Calif. Vol 4176, September, 2000, pp. 122-129. </paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> shows one exemplary embodiment of an array of air jets <highlight><bold>320</bold></highlight>, which is an exemplary embodiment of the array of actuators <highlight><bold>120</bold></highlight>. </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> The array <highlight><bold>320</bold></highlight> includes a plurality of air jets <highlight><bold>350</bold></highlight>. The array <highlight><bold>320</bold></highlight> has been modeled as a set of N jets on a 2-d grid. An air jet i (i in 1, . . . , N) is represented by its: </paragraph>
<paragraph id="P-0073" lvl="7"><number>&lsqb;0073&rsqb;</number> position (x<highlight><subscript>xi</subscript></highlight>,y<highlight><subscript>xi</subscript></highlight>); </paragraph>
<paragraph id="P-0074" lvl="7"><number>&lsqb;0074&rsqb;</number> force domains d<highlight><subscript>xi </subscript></highlight>and d<highlight><subscript>yi</subscript></highlight>; and </paragraph>
<paragraph id="P-0075" lvl="7"><number>&lsqb;0075&rsqb;</number> forces f<highlight><subscript>xi </subscript></highlight>and f<highlight><subscript>yi </subscript></highlight>(f<highlight><subscript>xi</subscript></highlight>&egr;d<highlight><subscript>xi</subscript></highlight>,f<highlight><subscript>yi</subscript></highlight>&egr;d<highlight><subscript>yi</subscript></highlight>). </paragraph>
<paragraph id="P-0076" lvl="0"><number>&lsqb;0076&rsqb;</number> The position (x<highlight><subscript>i </subscript></highlight>identified as <highlight><bold>352</bold></highlight>, y<highlight><subscript>i </subscript></highlight>identified as <highlight><bold>354</bold></highlight>) is given relative to the center of mass <highlight><bold>362</bold></highlight> of an object <highlight><bold>360</bold></highlight>. In various exemplary embodiments, the center of mass <highlight><bold>362</bold></highlight> is approximated. However, in other various exemplary embodiments, the center of mass <highlight><bold>362</bold></highlight> is provided to the controller or the system is calibrated to learn the center of mass <highlight><bold>362</bold></highlight>. In various exemplary embodiments, only the actuators under the object <highlight><bold>360</bold></highlight> at the time of interest are modeled. </paragraph>
<paragraph id="P-0077" lvl="0"><number>&lsqb;0077&rsqb;</number> A force domain of an individual air jet <highlight><bold>350</bold></highlight> may be a continuous interval d<highlight><subscript>i</subscript></highlight>&equals;&lsqb;f<highlight><subscript>min</subscript></highlight>,f<highlight><subscript>max</subscript></highlight>&rsqb; or a discrete set of possible values d<highlight><subscript>i</subscript></highlight>&equals;&lcub;f<highlight><subscript>min</subscript></highlight>, f<highlight><subscript>min</subscript></highlight>&plus;f<highlight><subscript>inc</subscript></highlight>, f<highlight><subscript>min</subscript></highlight>&plus;2f<highlight><subscript>inc</subscript></highlight>, . . . , f<highlight><subscript>max</subscript></highlight>&rcub; for some increment value f<highlight><subscript>inc</subscript></highlight>. In various exemplary embodiments, an air jet <highlight><bold>350</bold></highlight> can only apply an x-force <highlight><bold>390</bold></highlight> or a y-force <highlight><bold>395</bold></highlight> in either a positive or a negative direction. In various exemplary embodiments, the air jet <highlight><bold>350</bold></highlight> can only be on or off because of a binary valve that controls the air flow through the air jet <highlight><bold>350</bold></highlight>. Thus, for an x directional air-jet, the force domain is  
<math-cwu id="MATH-US-00001">
<number>1</number>
<math>
<mtable>
  <mtr>
    <mtd>
      <mrow>
        <msub>
          <mi>d</mi>
          <mrow>
            <mi>x</mi>
            <mo>&it;</mo>
            <mstyle>
              <mtext>&emsp;</mtext>
            </mstyle>
            <mo>&it;</mo>
            <mi>i</mi>
          </mrow>
        </msub>
        <mo>=</mo>
        <mrow>
          <mo>{</mo>
          <mrow>
            <mrow>
              <mtable>
                <mtr>
                  <mtd>
                    <mrow>
                      <mo>{</mo>
                      <mrow>
                        <mn>0</mn>
                        <mo>,</mo>
                        <msub>
                          <mi>f</mi>
                          <mi>max</mi>
                        </msub>
                      </mrow>
                      <mo>}</mo>
                    </mrow>
                  </mtd>
                  <mtd>
                    <mrow>
                      <mo>(</mo>
                      <mrow>
                        <mrow>
                          <mi>positive</mi>
                          <mo>&it;</mo>
                          <mstyle>
                            <mtext>&emsp;</mtext>
                          </mstyle>
                          <mo>&it;</mo>
                          <mi>x</mi>
                        </mrow>
                        <mo>-</mo>
                        <mi>jet</mi>
                      </mrow>
                      <mo>)</mo>
                    </mrow>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd>
                    <mrow>
                      <mo>{</mo>
                      <mrow>
                        <mrow>
                          <mo>-</mo>
                          <msub>
                            <mi>f</mi>
                            <mi>max</mi>
                          </msub>
                        </mrow>
                        <mo>,</mo>
                        <mn>0</mn>
                      </mrow>
                      <mo>}</mo>
                    </mrow>
                  </mtd>
                  <mtd>
                    <mrow>
                      <mo>(</mo>
                      <mrow>
                        <mrow>
                          <mi>negative</mi>
                          <mo>&it;</mo>
                          <mstyle>
                            <mtext>&emsp;</mtext>
                          </mstyle>
                          <mo>&it;</mo>
                          <mi>x</mi>
                        </mrow>
                        <mo>-</mo>
                        <mi>jet</mi>
                      </mrow>
                      <mo>)</mo>
                    </mrow>
                  </mtd>
                </mtr>
              </mtable>
              <mo>&it;</mo>
              <mstyle>
                <mtext>&NewLine;</mtext>
              </mstyle>
              <mo>&it;</mo>
              <msub>
                <mi>d</mi>
                <mrow>
                  <mi>y</mi>
                  <mo>&it;</mo>
                  <mstyle>
                    <mtext>&emsp;</mtext>
                  </mstyle>
                  <mo>&it;</mo>
                  <mi>i</mi>
                </mrow>
              </msub>
            </mrow>
            <mo>=</mo>
            <mi>&varnothing;</mi>
          </mrow>
        </mrow>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mi>Eq</mi>
        <mo>.</mo>
        <mstyle>
          <mtext>&emsp;</mtext>
        </mstyle>
        <mo>&it;</mo>
        <mrow>
          <mo>(</mo>
          <mn>1</mn>
          <mo>)</mo>
        </mrow>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
<mathematica-file id="MATHEMATICA-00001" file="US20030002447A1-20030102-M00001.NB"/>
<image id="EMI-M00001" wi="216.027" he="33.1128" file="US20030002447A1-20030102-M00001.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph lvl="0"><in-line-formula>d<highlight><subscript>yi</subscript></highlight>&equals;&Oslash;</in-line-formula></paragraph>
<paragraph id="P-0078" lvl="0"><number>&lsqb;0078&rsqb;</number> The equivalent holds for y-directional air-jets. In various exemplary. embodiments, the time for a jet valve to switch states is generally on the order of the control cycle, namely 1-2 milliseconds, and thus negligible relative to the motion of the object <highlight><bold>360</bold></highlight>. Thus, it is assumed for the following discussion purposes that the jet valves can switch states (open and closed) instantaneously. </paragraph>
<paragraph id="P-0079" lvl="0"><number>&lsqb;0079&rsqb;</number> In various exemplary embodiments, the air jets <highlight><bold>350</bold></highlight> may be grouped together to form tiles. It should be understood that each actuator module <highlight><bold>370</bold></highlight> may contain any number of individual air jets <highlight><bold>350</bold></highlight>. The air jet module <highlight><bold>370</bold></highlight> may contain both x-directional and y-directional air jets, and thus have both an x-force component <highlight><bold>372</bold></highlight> and a y-force component <highlight><bold>374</bold></highlight>. For example, the maximum force for a module air jet <highlight><bold>370</bold></highlight> with n x-jets and n y-jets, with equal numbers of jets in positive and negative directions, is f<highlight><subscript>MAX</subscript></highlight>&equals;{fraction (n/2)} f<highlight><subscript>max </subscript></highlight>in either direction. Thus, the domains for such a module air-jet <highlight><bold>370</bold></highlight> are: </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>d</italic></highlight><highlight><subscript>x</subscript></highlight><highlight><italic>i&equals;d</italic></highlight><highlight><subscript>y</subscript></highlight><highlight><italic>i&equals;&lcub;&minus;f</italic></highlight><highlight><subscript>MAX</subscript></highlight><highlight><italic>,&minus;f</italic></highlight><highlight><subscript>MAX</subscript></highlight><highlight><italic>&plus;f</italic></highlight><highlight><subscript>max</subscript></highlight>, . . . , 0, . . . , <highlight><italic>f</italic></highlight><highlight><subscript>MAX</subscript></highlight>&rcub;&emsp;&emsp;Eq. (2) </in-line-formula></paragraph>
<paragraph id="P-0080" lvl="0"><number>&lsqb;0080&rsqb;</number> The actuator module <highlight><bold>370</bold></highlight> has a position (x<highlight><subscript>xi </subscript></highlight>identified as <highlight><bold>376</bold></highlight>, Y<highlight><subscript>xi </subscript></highlight>identified as <highlight><bold>378</bold></highlight>) that may be given as the centroid of the bounding box or the average position of air jets <highlight><bold>350</bold></highlight> within its bounds. </paragraph>
<paragraph id="P-0081" lvl="0"><number>&lsqb;0081&rsqb;</number> In various exemplary embodiments, an air jet module includes a group of actuator modules <highlight><bold>370</bold></highlight>, rather than individual actuators <highlight><bold>350</bold></highlight>. An example of such an air jet module is identified as <highlight><bold>380</bold></highlight>. The air jet module <highlight><bold>380</bold></highlight> is similar to the air jet module <highlight><bold>370</bold></highlight> in that it can have both x and y force components, a position, and a force domain. </paragraph>
<paragraph id="P-0082" lvl="0"><number>&lsqb;0082&rsqb;</number> Together, the air jets <highlight><bold>350</bold></highlight> in an air jet module <highlight><bold>370</bold></highlight> or the entire system or array of actuators <highlight><bold>320</bold></highlight> deliver an x-force F<highlight><subscript>x</subscript></highlight>, a y-force F<highlight><subscript>y</subscript></highlight>, and a z-torque T<highlight><subscript>z </subscript></highlight>to the object <highlight><bold>360</bold></highlight>. </paragraph>
<paragraph id="P-0083" lvl="0"><number>&lsqb;0083&rsqb;</number> In various exemplary embodiments, an actuator module i contributes additively with forces f<highlight><subscript>xi </subscript></highlight>and f<highlight><subscript>yi </subscript></highlight>to the system&apos;s x and y-forces, respectively. Furthermore, the force f<highlight><subscript>xi </subscript></highlight>contributes with &minus;y<highlight><subscript>i</subscript></highlight>f<highlight><subscript>xi </subscript></highlight>to the z-torque (about the center of mass <highlight><bold>362</bold></highlight> of the object <highlight><bold>360</bold></highlight>), and the force f<highlight><subscript>yi </subscript></highlight>contributes with x<highlight><subscript>i</subscript></highlight>f<highlight><subscript>yi</subscript></highlight>. In other words, the z-torque delivered by the actuator module i is t<highlight><subscript>zi</subscript></highlight>&equals;x<highlight><subscript>i</subscript></highlight>f<highlight><subscript>yi</subscript></highlight>&minus;y<highlight><subscript>i</subscript></highlight>f<highlight><subscript>xi</subscript></highlight>. In various exemplary embodiments, the same holds for individual air jets <highlight><bold>350</bold></highlight>, except that each air jet <highlight><bold>350</bold></highlight> delivers only either an x-force or a y-force. The total x-force F<highlight><subscript>x</subscript></highlight>, y-force F<highlight><subscript>y</subscript></highlight>, and z-torque T<highlight><subscript>z </subscript></highlight>acting on the object <highlight><bold>360</bold></highlight> are determined according to the following linear summation model:  
<math-cwu id="MATH-US-00002">
<number>2</number>
<math>
<mtable>
  <mtr>
    <mtd>
      <mrow>
        <mrow>
          <msub>
            <mi>F</mi>
            <mi>x</mi>
          </msub>
          <mo>=</mo>
          <mrow>
            <munderover>
              <mo>&Sum;</mo>
              <mrow>
                <mi>i</mi>
                <mo>=</mo>
                <mn>1</mn>
              </mrow>
              <mi>N</mi>
            </munderover>
            <mo>&it;</mo>
            <msub>
              <mi>f</mi>
              <mrow>
                <mi>x</mi>
                <mo>&it;</mo>
                <mstyle>
                  <mtext>&emsp;</mtext>
                </mstyle>
                <mo>&it;</mo>
                <mi>i</mi>
              </mrow>
            </msub>
          </mrow>
        </mrow>
        <mo>&it;</mo>
        <mstyle>
          <mtext>&NewLine;</mtext>
        </mstyle>
        <mo>&it;</mo>
        <mrow>
          <msub>
            <mi>F</mi>
            <mi>y</mi>
          </msub>
          <mo>=</mo>
          <mrow>
            <munderover>
              <mo>&Sum;</mo>
              <mrow>
                <mi>i</mi>
                <mo>=</mo>
                <mn>1</mn>
              </mrow>
              <mi>N</mi>
            </munderover>
            <mo>&it;</mo>
            <msub>
              <mi>f</mi>
              <mrow>
                <mi>y</mi>
                <mo>&it;</mo>
                <mstyle>
                  <mtext>&emsp;</mtext>
                </mstyle>
                <mo>&it;</mo>
                <mi>i</mi>
              </mrow>
            </msub>
          </mrow>
        </mrow>
        <mo>&it;</mo>
        <mstyle>
          <mtext>&NewLine;</mtext>
        </mstyle>
        <mo>&it;</mo>
        <mrow>
          <msub>
            <mi>T</mi>
            <mi>z</mi>
          </msub>
          <mo>=</mo>
          <mrow>
            <mrow>
              <munderover>
                <mo>&Sum;</mo>
                <mrow>
                  <mi>i</mi>
                  <mo>=</mo>
                  <mn>1</mn>
                </mrow>
                <mi>N</mi>
              </munderover>
              <mo>&it;</mo>
              <mrow>
                <msub>
                  <mi>x</mi>
                  <mi>i</mi>
                </msub>
                <mo>&it;</mo>
                <msub>
                  <mi>f</mi>
                  <mrow>
                    <mi>y</mi>
                    <mo>&it;</mo>
                    <mstyle>
                      <mtext>&emsp;</mtext>
                    </mstyle>
                    <mo>&it;</mo>
                    <mi>i</mi>
                  </mrow>
                </msub>
              </mrow>
            </mrow>
            <mo>-</mo>
            <mrow>
              <munderover>
                <mo>&Sum;</mo>
                <mrow>
                  <mi>i</mi>
                  <mo>=</mo>
                  <mn>1</mn>
                </mrow>
                <mi>N</mi>
              </munderover>
              <mo>&it;</mo>
              <mrow>
                <msub>
                  <mi>y</mi>
                  <mi>i</mi>
                </msub>
                <mo>&it;</mo>
                <msub>
                  <mi>f</mi>
                  <mrow>
                    <mi>x</mi>
                    <mo>&it;</mo>
                    <mstyle>
                      <mtext>&emsp;</mtext>
                    </mstyle>
                    <mo>&it;</mo>
                    <mi>i</mi>
                  </mrow>
                </msub>
              </mrow>
            </mrow>
          </mrow>
        </mrow>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mi>Eq</mi>
        <mo>.</mo>
        <mstyle>
          <mtext>&emsp;</mtext>
        </mstyle>
        <mo>&it;</mo>
        <mrow>
          <mo>(</mo>
          <mn>3</mn>
          <mo>)</mo>
        </mrow>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
<mathematica-file id="MATHEMATICA-00002" file="US20030002447A1-20030102-M00002.NB"/>
<image id="EMI-M00002" wi="216.027" he="81.1377" file="US20030002447A1-20030102-M00002.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0084" lvl="0"><number>&lsqb;0084&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> displays one exemplary embodiment of a method of hierarchically allocating a force for a many actuator system, in accordance with the present invention. In various exemplary embodiments, this method is employed by an allocator within a many actuator system. In other various exemplary embodiments, this method is employed by a plurality of level allocators within a many actuator system. </paragraph>
<paragraph id="P-0085" lvl="0"><number>&lsqb;0085&rsqb;</number> Because the number of actuators greatly exceeds the dimensionality of a control command (desired goal) U, wherein U&equals;(F<highlight><subscript>x</subscript></highlight>F<highlight><subscript>y</subscript></highlight>T<highlight><subscript>z</subscript></highlight>), there are many ways of assigning the actuation to the actuators. In general, it is desirable to use the additional degrees of freedom to attain other desirable goals and thus select the most desirable allocation out of many possible actuator configurations. In other words, the force allocation problem can be viewed as a constrained optimization problem, where the constraints are both the domain constraints of the actuators and the relations between individual actuators and the total delivered forces (Eq. (2) and Eq. (3)). This optimization problem is solved at each control time step in order to determine which actuators should be activated. Precise generation of the required action is not usually possible because the actuation is discrete. In general such a discrete optimization problem is NP-hard, i.e., actuation assignment computation scales exponentially with the number of actuators. On the other hand, for arrays of actuators having a large number of actuators, the actuation approaches a continuum limit, and the problem becomes easy to solve approximately. Therefore, a desirable property for a force allocation method is to solve the discrete optimization problem optimally for small numbers of jets, provide a near-optimal solution for intermediate numbers of jets, and approach the continuum for large numbers of jets, as is accomplished by the present invention. </paragraph>
<paragraph id="P-0086" lvl="0"><number>&lsqb;0086&rsqb;</number> In various exemplary embodiments for methods of allocating forces according to the present invention, an optimal assignment of actuation can be obtained by an exhaustive search, a discrete optimization solver, or a lookup table of precomputed solutions for a small number of actuators (e.g., equal to or less than 10 for the air jet example running with a loop time of 1 ms on a typical digital signal processor). In various exemplary embodiments for methods of allocating forces according to the present invention, the allocation problem is decomposed into smaller sub-problems in a near optimal manner using continuous solutions as approximations, for a large number of actuators (e.g. equal to or greater than 10 for the air jet example running with a loop time of 1 ms on a typical digital signal processor). In other various exemplary embodiments, each sub-problem may be further decomposed into yet smaller sub-problems, or, if sufficiently small, the sub-problem is solved optimally using conventional methods, such as, but not limited to, look-up tables. </paragraph>
<paragraph id="P-0087" lvl="0"><number>&lsqb;0087&rsqb;</number> In various exemplary embodiments of a method for allocating a force according to the present invention, decomposition into sub-problems includes dividing the actuators into modules (groups of actuators) and then assigning responsibility to produce a required force to each module. </paragraph>
<paragraph id="P-0088" lvl="0"><number>&lsqb;0088&rsqb;</number> The exemplary method shown in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, begins in step S<highlight><bold>400</bold></highlight> and proceeds to step S<highlight><bold>405</bold></highlight>, wherein the goal that needs to be allocated is received. In various exemplary embodiments, the goal is a force. A particular level controlled by either a system allocator or a module allocator is received. In various exemplary embodiments, the goal received is the overall goal that is received by the allocator <highlight><bold>110</bold></highlight> from the goal generation device <highlight><bold>130</bold></highlight>. In other various exemplary embodiments, the goal received is a force allocation from an allocator <highlight><bold>114</bold></highlight> in the top level <highlight><bold>116</bold></highlight> received by an allocator <highlight><bold>114</bold></highlight> located within the middle level <highlight><bold>117</bold></highlight>. </paragraph>
<paragraph id="P-0089" lvl="0"><number>&lsqb;0089&rsqb;</number> In various exemplary embodiments, the top level allocation is identified as Allocate(U, I, n), wherein: U represents the overall task for the entire array of actuators and is represented as U&equals;(F<highlight><subscript>x</subscript></highlight>F<highlight><subscript>y</subscript></highlight>T<highlight><subscript>z</subscript></highlight>)<highlight><superscript>T</superscript></highlight>; I is an identifier string or list of numbers, which denotes the level of the system (the top level is level <highlight><bold>1</bold></highlight> and an I of &ldquo;1.2&rdquo; indicates module <highlight><bold>2</bold></highlight> in level <highlight><bold>2</bold></highlight> within the top level <highlight><bold>1</bold></highlight>); the n denotes the number of modules or jets within this level (for the top level, n is 1). </paragraph>
<paragraph id="P-0090" lvl="0"><number>&lsqb;0090&rsqb;</number> In step S<highlight><bold>410</bold></highlight>, the first module is selected, i.e. i, which is an index representing modules within a level, is set to be equal to one. For the exemplary top level <highlight><bold>116</bold></highlight>, shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, there is only one allocator and thus only one module. Accordingly, that module is selected. For the exemplary middle level <highlight><bold>117</bold></highlight>, shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, there are two modules, each corresponding to an allocator <highlight><bold>114</bold></highlight>. For the exemplary bottom level <highlight><bold>118</bold></highlight>, shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, there are four modules, each corresponding to an allocator <highlight><bold>114</bold></highlight>. </paragraph>
<paragraph id="P-0091" lvl="0"><number>&lsqb;0091&rsqb;</number> The method proceeds to step S<highlight><bold>415</bold></highlight>, wherein the current module i is decomposed. To decompose a module, whether it is for the entire system, i.e. the top level, or for a sub level, such as the middle level, a decomposition function is used. In various exemplary embodiments, the decomposition function is represented as: </paragraph>
<paragraph lvl="0"><in-line-formula>&lsqb;n<highlight><subscript>i</subscript></highlight>,r<highlight><subscript>i</subscript></highlight>,w<highlight><subscript>i</subscript></highlight>&rsqb;&equals;Decompose(I,i) </in-line-formula></paragraph>
<paragraph id="P-0092" lvl="0"><number>&lsqb;0092&rsqb;</number> The decomposition process selects module i in level I and returns the number n<highlight><subscript>i </subscript></highlight>of actuators or submodules, submodule position r<highlight><subscript>i</subscript></highlight>&equals;(x<highlight><subscript>i</subscript></highlight>y<highlight><subscript>i</subscript></highlight>), and weights w<highlight><subscript>i </subscript></highlight>for the allocation function, which are discussed further below. This decomposition function makes heuristic choices, which are discussed further below, for hierarchical decomposition of the module. If no (further) hierarchical decomposition is desired, i.e., it is not desired to split the current module into so-called sub-modules or subdomains, then this function decomposes module i into its n<highlight><subscript>i </subscript></highlight>actual jets, as would be done, for example, with the modules within the bottom level <highlight><bold>118</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. The grouping of the plurality of actuators into actuator modules may be predetermined or computed dynamically based on, for example, a load-balancing criterion. </paragraph>
<paragraph id="P-0093" lvl="0"><number>&lsqb;0093&rsqb;</number> A plurality of actuators may be grouped into actuator modules in varying ways. In various exemplary embodiments, the physical layout of the plurality of actuators is followed, e.g., each cluster of actuators between the sensors becomes a module. An exemplary embodiment of a physical heuristic decomposition of an array of actuators is shown in <cross-reference target="DRAWINGS">FIG. 5</cross-reference> (i.e. &ldquo;tiles&rdquo;). The advantage of a physical heuristic is that a modular structure of the system leads to a corresponding modular structure of the allocation algorithm. In various exemplary embodiments, for an 8&frac12; by 11 inch sheet of paper, which covers about 360 jets, the physical heuristic decomposes the area under the sheet into about 40 modules with up to about 16 actual jets in each module. A module entirely covered by the sheet contains 16 actual jets, with 4 jets for each direction. Even with discrete valves and a single-jet force of f<highlight><subscript>max</subscript></highlight>, such a module provides near-continuous force domains for f<highlight><subscript>xi </subscript></highlight>and f<highlight><subscript>yi</subscript></highlight>: </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>d</italic></highlight><highlight><subscript>xi</subscript></highlight><highlight><italic>&equals;d</italic></highlight><highlight><subscript>yi</subscript></highlight>&equals;&lcub;&minus;4<highlight><italic>f</italic></highlight><highlight><subscript>max</subscript></highlight>,&minus;3<highlight><italic>f</italic></highlight><highlight><subscript>max</subscript></highlight>,&minus;2<highlight><italic>f</italic></highlight><highlight><subscript>max</subscript></highlight><highlight><italic>f</italic></highlight><highlight><subscript>max</subscript></highlight>, 0,<highlight><italic>f</italic></highlight><highlight><subscript>max</subscript></highlight>, 2<highlight><italic>f</italic></highlight><highlight><subscript>max</subscript></highlight>3<highlight><italic>f</italic></highlight><highlight><subscript>max</subscript></highlight>, 4<highlight><italic>f</italic></highlight><highlight><subscript>max</subscript></highlight>&rcub;</in-line-formula></paragraph>
<paragraph id="P-0094" lvl="0"><number>&lsqb;0094&rsqb;</number> Another exemplary grouping heuristic is a &ldquo;follow the constraints&rdquo; or a logical heuristic. An exemplary embodiment of a logical heuristic grouping of the plurality of actuators is shown in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>. For example, all x jets with the same y position are interchangeable with respect to the constraints in Eq. (4) which is shown and explained below. </paragraph>
<paragraph id="P-0095" lvl="0"><number>&lsqb;0095&rsqb;</number> Rows of x jets with the same y position and columns of y jets with the same x position lead to particularly simple allocation functions within a row or column. In one exemplary embodiment, a decomposition of jets where the N modules are divided into N<highlight><subscript>x </subscript></highlight>&ldquo;x modules,&rdquo; each with only x-directed jets with a common y position y<highlight><subscript>i</subscript></highlight>, and N<highlight><subscript>y </subscript></highlight>&ldquo;y modules,&rdquo; each with only y-directed jets with a common x position x<highlight><subscript>i</subscript></highlight>, is shown in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>. With such an arrangement, the weighting features, (w<highlight><subscript>xi</subscript></highlight>w<highlight><subscript>yi</subscript></highlight>)&equals;(n<highlight><subscript>xi</subscript></highlight>0) for an x module with n<highlight><subscript>xi </subscript></highlight>jets and (0n<highlight><subscript>yi</subscript></highlight>) for a y module containing n<highlight><subscript>yi </subscript></highlight>jets. </paragraph>
<paragraph id="P-0096" lvl="0"><number>&lsqb;0096&rsqb;</number> Grouping/decomposing at one level can greatly simplify the force allocation at another subordinate level. In various exemplary embodiments, for an 8&frac12; by 11 inch sheet of paper, the logical heuristic groups the area under the sheet into about 50 modules, each with up to about 12 individual jets. </paragraph>
<paragraph id="P-0097" lvl="0"><number>&lsqb;0097&rsqb;</number> Referring again to <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, in step S<highlight><bold>420</bold></highlight>, the sub-goal is determined for the current module. In various exemplary embodiments, the sub-goal is a force. The sub-goal or force is represented as: </paragraph>
<paragraph lvl="0"><in-line-formula>u<highlight><subscript>i</subscript></highlight>&equals;Solve(U, n<highlight><subscript>i</subscript></highlight>, r<highlight><subscript>i</subscript></highlight>, w<highlight><subscript>i</subscript></highlight>, n) </in-line-formula></paragraph>
<paragraph id="P-0098" lvl="7"><number>&lsqb;0098&rsqb;</number> where U&equals;(F<highlight><subscript>x </subscript></highlight>F<highlight><subscript>y </subscript></highlight>T<highlight><subscript>z</subscript></highlight>)<highlight><superscript>T </superscript></highlight>is the desired total force for all modules at the current level, n is the number of modules at the current level, all other inputs are those determined by the decomposition, and output u<highlight><subscript>i</subscript></highlight>&equals;(f<highlight><subscript>xi</subscript></highlight>f<highlight><subscript>yi</subscript></highlight>t<highlight><subscript>zi</subscript></highlight>)<highlight><superscript>T </superscript></highlight>is the computed allocation for module i. In various exemplary embodiments, U is the overall force generated by the goal generation device <highlight><bold>130</bold></highlight>, for example. In other various exemplary embodiments, U is a force allocation instruction from a module from a level that is higher than the level of the current module. Depending on the level in the hierarchy or the number of submodules in the module, step S<highlight><bold>420</bold></highlight> will use instantiations of Eqs. (5) and (6), which are shown and described below. </paragraph>
<paragraph id="P-0099" lvl="0"><number>&lsqb;0099&rsqb;</number> In step S<highlight><bold>425</bold></highlight>, it is determined whether the level that the current module is in is the bottom level of the entire array of actuators. The level is the bottom level if the module is not decomposed into further submodules. In other words, the current module does not allocate any forces to a module in a lower level, but rather the module will provide instructions to the actuators. If the current module level is not the bottom level, then the method proceeds to step S<highlight><bold>430</bold></highlight>, wherein the sub-goal is allocated to modules in the next lower level. This allocation is represented as Allocate (ui, I.i, ni). Otherwise, if in step S<highlight><bold>425</bold></highlight> it is determined that the level that the current module is in is the bottom level, then the method proceeds to step S<highlight><bold>435</bold></highlight>, wherein the sub-goal, is assigned to individual actuators. An assignment function is represented as follows: </paragraph>
<paragraph lvl="0"><in-line-formula>u<highlight><subscript>Ii</subscript></highlight>&equals;Assign(u<highlight><subscript>i</subscript></highlight>,I.i) </in-line-formula></paragraph>
<paragraph id="P-0100" lvl="0"><number>&lsqb;0100&rsqb;</number> The assignment function assigns the desired actuation U<highlight><subscript>Ii </subscript></highlight>to the actuators in module I.i. In other words, given desired actuation u<highlight><subscript>i</subscript></highlight>&equals;(f<highlight><subscript>xi</subscript></highlight>f<highlight><subscript>yi t</subscript></highlight><highlight><subscript>zi</subscript></highlight>)<highlight><superscript>T </superscript></highlight>and a single actuator, the assignment function may choose f<highlight><subscript>xi </subscript></highlight>for an x jet and f<highlight><subscript>yi </subscript></highlight>for a y jet. For discrete domains, assignment may also apply a thresholding function to choose an element from the domain. For example, for an x jet with domain &lcub;0,f<highlight><subscript>max</subscript></highlight>&rcub;, Assign may return f<highlight><subscript>max </subscript></highlight>if f<highlight><subscript>xi </subscript></highlight>is greater than f<highlight><subscript>max</subscript></highlight>/2 and 0 otherwise. For a module with multiple jets, the assignment process may perform an optimal search. Since allocation is local to a module, it is also possible to precompute optimal assignments and reduce a force assignment to a lookup operation. </paragraph>
<paragraph id="P-0101" lvl="0"><number>&lsqb;0101&rsqb;</number> The following methods of generating an optimal allocation and assignment of a desired force U given a number of modules (consisting of groups of actuators or single actuators) are used for steps S<highlight><bold>430</bold></highlight> and S<highlight><bold>435</bold></highlight>. In various exemplary embodiments, there are N modules with air jets in x and y directions. Each module is located at a position (x<highlight><subscript>i</subscript></highlight>,y<highlight><subscript>i</subscript></highlight>) (i&equals;1, . . . , N) relative to the center of mass of the object, i.e., the module applies its force at position (x<highlight><subscript>i</subscript></highlight>,y<highlight><subscript>i</subscript></highlight>). In various exemplary embodiments, the jets should not work against each other while producing U (i.e., actuation should be minimal). Hence, a possible constrained optimization problem capturing such desired behavior is:  
<math-cwu id="MATH-US-00003">
<number>3</number>
<math>
<mtable>
  <mtr>
    <mtd>
      <mrow>
        <mrow>
          <mrow>
            <munder>
              <mrow>
                <mi>min</mi>
                <mo>&it;</mo>
                <mstyle>
                  <mtext>&emsp;</mtext>
                </mstyle>
                <mo>&it;</mo>
                <mi>i</mi>
                <mo>&it;</mo>
                <mstyle>
                  <mtext>&emsp;</mtext>
                </mstyle>
                <mo>&it;</mo>
                <mi>m</mi>
                <mo>&it;</mo>
                <mstyle>
                  <mtext>&emsp;</mtext>
                </mstyle>
                <mo>&it;</mo>
                <mi>i</mi>
                <mo>&it;</mo>
                <mstyle>
                  <mtext>&emsp;</mtext>
                </mstyle>
                <mo>&it;</mo>
                <mi>z</mi>
                <mo>&it;</mo>
                <mstyle>
                  <mtext>&emsp;</mtext>
                </mstyle>
                <mo>&it;</mo>
                <mi>e</mi>
              </mrow>
              <mrow>
                <msub>
                  <mi>f</mi>
                  <mrow>
                    <mi>x</mi>
                    <mo>&it;</mo>
                    <mstyle>
                      <mtext>&emsp;</mtext>
                    </mstyle>
                    <mo>&it;</mo>
                    <mi>i</mi>
                  </mrow>
                </msub>
                <mo>,</mo>
                <msub>
                  <mi>f</mi>
                  <mrow>
                    <mi>y</mi>
                    <mo>&it;</mo>
                    <mstyle>
                      <mtext>&emsp;</mtext>
                    </mstyle>
                    <mo>&it;</mo>
                    <mi>i</mi>
                  </mrow>
                </msub>
              </mrow>
            </munder>
            <mo>&it;</mo>
            <mstyle>
              <mtext>&emsp;</mtext>
            </mstyle>
            <mo>&it;</mo>
            <mfrac>
              <mn>1</mn>
              <mn>2</mn>
            </mfrac>
            <mo>&it;</mo>
            <mrow>
              <munderover>
                <mo>&Sum;</mo>
                <mrow>
                  <mi>i</mi>
                  <mo>=</mo>
                  <mn>1</mn>
                </mrow>
                <mi>N</mi>
              </munderover>
              <mo>&it;</mo>
              <mfrac>
                <msubsup>
                  <mi>f</mi>
                  <mrow>
                    <mi>x</mi>
                    <mo>&it;</mo>
                    <mstyle>
                      <mtext>&emsp;</mtext>
                    </mstyle>
                    <mo>&it;</mo>
                    <mi>i</mi>
                  </mrow>
                  <mn>2</mn>
                </msubsup>
                <msubsup>
                  <mi>w</mi>
                  <mrow>
                    <mi>x</mi>
                    <mo>&it;</mo>
                    <mstyle>
                      <mtext>&emsp;</mtext>
                    </mstyle>
                    <mo>&it;</mo>
                    <mi>i</mi>
                  </mrow>
                  <mn>2</mn>
                </msubsup>
              </mfrac>
            </mrow>
          </mrow>
          <mo>+</mo>
          <mrow>
            <mfrac>
              <mn>1</mn>
              <mn>2</mn>
            </mfrac>
            <mo>&it;</mo>
            <mrow>
              <munderover>
                <mo>&Sum;</mo>
                <mrow>
                  <mi>i</mi>
                  <mo>=</mo>
                  <mn>1</mn>
                </mrow>
                <mi>N</mi>
              </munderover>
              <mo>&it;</mo>
              <mfrac>
                <msubsup>
                  <mi>f</mi>
                  <mrow>
                    <mi>y</mi>
                    <mo>&it;</mo>
                    <mstyle>
                      <mtext>&emsp;</mtext>
                    </mstyle>
                    <mo>&it;</mo>
                    <mi>i</mi>
                  </mrow>
                  <mn>2</mn>
                </msubsup>
                <msubsup>
                  <mi>w</mi>
                  <mrow>
                    <mi>y</mi>
                    <mo>&it;</mo>
                    <mstyle>
                      <mtext>&emsp;</mtext>
                    </mstyle>
                    <mo>&it;</mo>
                    <mi>i</mi>
                  </mrow>
                  <mn>2</mn>
                </msubsup>
              </mfrac>
            </mrow>
          </mrow>
        </mrow>
        <mo>&it;</mo>
        <mstyle>
          <mtext>&NewLine;</mtext>
        </mstyle>
        <mo>&it;</mo>
        <mrow>
          <mrow>
            <mrow>
              <mi>subject</mi>
              <mo>&it;</mo>
              <mstyle>
                <mtext>&emsp;</mtext>
              </mstyle>
              <mo>&it;</mo>
              <mi>to</mi>
              <mo>&it;</mo>
              <mstyle>
                <mtext>&emsp;</mtext>
              </mstyle>
              <mo>&it;</mo>
              <msub>
                <mi>F</mi>
                <mi>x</mi>
              </msub>
            </mrow>
            <mo>=</mo>
            <mrow>
              <munderover>
                <mo>&Sum;</mo>
                <mrow>
                  <mi>i</mi>
                  <mo>=</mo>
                  <mn>1</mn>
                </mrow>
                <mi>N</mi>
              </munderover>
              <mo>&it;</mo>
              <msub>
                <mi>f</mi>
                <mrow>
                  <mi>x</mi>
                  <mo>&it;</mo>
                  <mstyle>
                    <mtext>&emsp;</mtext>
                  </mstyle>
                  <mo>&it;</mo>
                  <mi>i</mi>
                </mrow>
              </msub>
            </mrow>
          </mrow>
          <mo>,</mo>
          <mrow>
            <msub>
              <mi>F</mi>
              <mi>y</mi>
            </msub>
            <mo>=</mo>
            <mrow>
              <munderover>
                <mo>&Sum;</mo>
                <mrow>
                  <mi>i</mi>
                  <mo>=</mo>
                  <mn>1</mn>
                </mrow>
                <mi>N</mi>
              </munderover>
              <mo>&it;</mo>
              <msub>
                <mi>f</mi>
                <mrow>
                  <mi>y</mi>
                  <mo>&it;</mo>
                  <mstyle>
                    <mtext>&emsp;</mtext>
                  </mstyle>
                  <mo>&it;</mo>
                  <mi>i</mi>
                </mrow>
              </msub>
            </mrow>
          </mrow>
          <mo>,</mo>
          <mrow>
            <msub>
              <mi>T</mi>
              <mi>z</mi>
            </msub>
            <mo>=</mo>
            <mrow>
              <mrow>
                <munderover>
                  <mo>&Sum;</mo>
                  <mrow>
                    <mi>i</mi>
                    <mo>=</mo>
                    <mn>1</mn>
                  </mrow>
                  <mi>N</mi>
                </munderover>
                <mo>&it;</mo>
                <mrow>
                  <msub>
                    <mi>x</mi>
                    <mi>i</mi>
                  </msub>
                  <mo>&it;</mo>
                  <msub>
                    <mi>f</mi>
                    <mrow>
                      <mi>y</mi>
                      <mo>&it;</mo>
                      <mstyle>
                        <mtext>&emsp;</mtext>
                      </mstyle>
                      <mo>&it;</mo>
                      <mi>i</mi>
                    </mrow>
                  </msub>
                </mrow>
              </mrow>
              <mo>-</mo>
              <mrow>
                <munderover>
                  <mo>&Sum;</mo>
                  <mrow>
                    <mi>i</mi>
                    <mo>=</mo>
                    <mn>1</mn>
                  </mrow>
                  <mi>N</mi>
                </munderover>
                <mo>&it;</mo>
                <mrow>
                  <msub>
                    <mi>y</mi>
                    <mi>i</mi>
                  </msub>
                  <mo>&it;</mo>
                  <msub>
                    <mi>f</mi>
                    <mrow>
                      <mi>x</mi>
                      <mo>&it;</mo>
                      <mstyle>
                        <mtext>&emsp;</mtext>
                      </mstyle>
                      <mo>&it;</mo>
                      <mi>i</mi>
                    </mrow>
                  </msub>
                </mrow>
              </mrow>
            </mrow>
          </mrow>
        </mrow>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mi>Eq</mi>
        <mo>.</mo>
        <mstyle>
          <mtext>&emsp;</mtext>
        </mstyle>
        <mo>&it;</mo>
        <mrow>
          <mo>(</mo>
          <mn>4</mn>
          <mo>)</mo>
        </mrow>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
<mathematica-file id="MATHEMATICA-00003" file="US20030002447A1-20030102-M00003.NB"/>
<image id="EMI-M00003" wi="216.027" he="59.05305" file="US20030002447A1-20030102-M00003.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0102" lvl="7"><number>&lsqb;0102&rsqb;</number> where f<highlight><subscript>i</subscript></highlight>&equals;(f<highlight><subscript>xi</subscript></highlight>f<highlight><subscript>yi</subscript></highlight>) are the allocated x and y forces for module jet i, and w<highlight><subscript>i</subscript></highlight>&equals;(w<highlight><subscript>xi</subscript></highlight>w<highlight><subscript>yi</subscript></highlight>) are the weighting factors for each module&apos;s contribution to the x and y force. A large weighting factor causes the module to assume a greater role in meeting the constraints for forces and torque and a smaller role in minimizing the objective function. A small factor emphasizes the objective function. This objective function causes each module to minimize its actuation, while still providing the forces needed by the control. If activation levels are continuous, the solution to this optimization problem is given by:  
<math-cwu id="MATH-US-00004">
<number>4</number>
<math>
<mtable>
  <mtr>
    <mtd>
      <mrow>
        <mrow>
          <msub>
            <mi>f</mi>
            <mrow>
              <mi>x</mi>
              <mo>&it;</mo>
              <mstyle>
                <mtext>&emsp;</mtext>
              </mstyle>
              <mo>&it;</mo>
              <mi>i</mi>
            </mrow>
          </msub>
          <mo>=</mo>
          <mrow>
            <msub>
              <mi>w</mi>
              <mrow>
                <mi>x</mi>
                <mo>&it;</mo>
                <mstyle>
                  <mtext>&emsp;</mtext>
                </mstyle>
                <mo>&it;</mo>
                <mi>i</mi>
              </mrow>
            </msub>
            <mo>(</mo>
            <mrow>
              <mfrac>
                <msub>
                  <mi>F</mi>
                  <mi>x</mi>
                </msub>
                <mrow>
                  <munderover>
                    <mo>&Sum;</mo>
                    <mrow>
                      <mi>j</mi>
                      <mo>=</mo>
                      <mn>1</mn>
                    </mrow>
                    <mi>N</mi>
                  </munderover>
                  <mo>&it;</mo>
                  <msub>
                    <mi>w</mi>
                    <mi>xj</mi>
                  </msub>
                </mrow>
              </mfrac>
              <mo>+</mo>
              <mrow>
                <mfrac>
                  <mrow>
                    <msub>
                      <mi>T</mi>
                      <mi>z</mi>
                    </msub>
                    <mo>-</mo>
                    <mrow>
                      <msub>
                        <mi>F</mi>
                        <mi>y</mi>
                      </msub>
                      <mo>&it;</mo>
                      <mover>
                        <mi>x</mi>
                        <mi>_</mi>
                      </mover>
                    </mrow>
                    <mo>+</mo>
                    <mrow>
                      <msub>
                        <mi>F</mi>
                        <mi>x</mi>
                      </msub>
                      <mo>&it;</mo>
                      <mover>
                        <mi>y</mi>
                        <mi>_</mi>
                      </mover>
                    </mrow>
                  </mrow>
                  <mrow>
                    <mrow>
                      <msubsup>
                        <mi>&sigma;</mi>
                        <mi>x</mi>
                        <mn>2</mn>
                      </msubsup>
                      <mo>&it;</mo>
                      <mrow>
                        <munderover>
                          <mo>&Sum;</mo>
                          <mrow>
                            <mi>j</mi>
                            <mo>=</mo>
                            <mn>1</mn>
                          </mrow>
                          <mi>N</mi>
                        </munderover>
                        <mo>&it;</mo>
                        <msub>
                          <mi>w</mi>
                          <mi>yj</mi>
                        </msub>
                      </mrow>
                    </mrow>
                    <mo>+</mo>
                    <mrow>
                      <msubsup>
                        <mi>&sigma;</mi>
                        <mi>y</mi>
                        <mn>2</mn>
                      </msubsup>
                      <mo>&it;</mo>
                      <mrow>
                        <munderover>
                          <mo>&Sum;</mo>
                          <mrow>
                            <mi>j</mi>
                            <mo>=</mo>
                            <mn>1</mn>
                          </mrow>
                          <mi>N</mi>
                        </munderover>
                        <mo>&it;</mo>
                        <msub>
                          <mi>w</mi>
                          <mi>xj</mi>
                        </msub>
                      </mrow>
                    </mrow>
                  </mrow>
                </mfrac>
                <mo>&it;</mo>
                <mrow>
                  <mo>(</mo>
                  <mrow>
                    <mover>
                      <mi>y</mi>
                      <mi>_</mi>
                    </mover>
                    <mo>-</mo>
                    <msub>
                      <mi>y</mi>
                      <mi>i</mi>
                    </msub>
                  </mrow>
                  <mo>)</mo>
                </mrow>
              </mrow>
            </mrow>
            <mo>)</mo>
          </mrow>
        </mrow>
        <mo>&it;</mo>
        <mstyle>
          <mtext>&NewLine;</mtext>
        </mstyle>
        <mo>&it;</mo>
        <mrow>
          <msub>
            <mi>f</mi>
            <mrow>
              <mi>y</mi>
              <mo>&it;</mo>
              <mstyle>
                <mtext>&emsp;</mtext>
              </mstyle>
              <mo>&it;</mo>
              <mi>i</mi>
            </mrow>
          </msub>
          <mo>=</mo>
          <mrow>
            <msub>
              <mi>w</mi>
              <mrow>
                <mi>y</mi>
                <mo>&it;</mo>
                <mstyle>
                  <mtext>&emsp;</mtext>
                </mstyle>
                <mo>&it;</mo>
                <mi>i</mi>
              </mrow>
            </msub>
            <mo>(</mo>
            <mrow>
              <mfrac>
                <msub>
                  <mi>F</mi>
                  <mi>y</mi>
                </msub>
                <mrow>
                  <munderover>
                    <mo>&Sum;</mo>
                    <mrow>
                      <mi>j</mi>
                      <mo>=</mo>
                      <mn>1</mn>
                    </mrow>
                    <mi>N</mi>
                  </munderover>
                  <mo>&it;</mo>
                  <msub>
                    <mi>w</mi>
                    <mi>yj</mi>
                  </msub>
                </mrow>
              </mfrac>
              <mo>+</mo>
              <mrow>
                <mfrac>
                  <mrow>
                    <msub>
                      <mi>T</mi>
                      <mi>z</mi>
                    </msub>
                    <mo>-</mo>
                    <mrow>
                      <msub>
                        <mi>F</mi>
                        <mi>y</mi>
                      </msub>
                      <mo>&it;</mo>
                      <mover>
                        <mi>x</mi>
                        <mi>_</mi>
                      </mover>
                    </mrow>
                    <mo>+</mo>
                    <mrow>
                      <msub>
                        <mi>F</mi>
                        <mi>x</mi>
                      </msub>
                      <mo>&it;</mo>
                      <mover>
                        <mi>y</mi>
                        <mi>_</mi>
                      </mover>
                    </mrow>
                  </mrow>
                  <mrow>
                    <mrow>
                      <msubsup>
                        <mi>&sigma;</mi>
                        <mi>x</mi>
                        <mn>2</mn>
                      </msubsup>
                      <mo>&it;</mo>
                      <mrow>
                        <munderover>
                          <mo>&Sum;</mo>
                          <mrow>
                            <mi>j</mi>
                            <mo>=</mo>
                            <mn>1</mn>
                          </mrow>
                          <mi>N</mi>
                        </munderover>
                        <mo>&it;</mo>
                        <msub>
                          <mi>w</mi>
                          <mi>yj</mi>
                        </msub>
                      </mrow>
                    </mrow>
                    <mo>+</mo>
                    <mrow>
                      <msubsup>
                        <mi>&sigma;</mi>
                        <mi>y</mi>
                        <mn>2</mn>
                      </msubsup>
                      <mo>&it;</mo>
                      <mrow>
                        <munderover>
                          <mo>&Sum;</mo>
                          <mrow>
                            <mi>j</mi>
                            <mo>=</mo>
                            <mn>1</mn>
                          </mrow>
                          <mi>N</mi>
                        </munderover>
                        <mo>&it;</mo>
                        <msub>
                          <mi>w</mi>
                          <mi>xj</mi>
                        </msub>
                      </mrow>
                    </mrow>
                  </mrow>
                </mfrac>
                <mo>&it;</mo>
                <mrow>
                  <mo>(</mo>
                  <mrow>
                    <mover>
                      <mi>x</mi>
                      <mi>_</mi>
                    </mover>
                    <mo>-</mo>
                    <msub>
                      <mi>x</mi>
                      <mi>i</mi>
                    </msub>
                  </mrow>
                  <mo>)</mo>
                </mrow>
              </mrow>
            </mrow>
            <mo>)</mo>
          </mrow>
        </mrow>
        <mo>&it;</mo>
        <mstyle>
          <mtext>&NewLine;</mtext>
        </mstyle>
        <mo>&it;</mo>
        <mrow>
          <msub>
            <mi>t</mi>
            <mi>zi</mi>
          </msub>
          <mo>=</mo>
          <mrow>
            <mrow>
              <mrow>
                <msub>
                  <mi>f</mi>
                  <mi>yi</mi>
                </msub>
                <mo>&af;</mo>
                <mrow>
                  <mo>(</mo>
                  <mrow>
                    <msub>
                      <mi>x</mi>
                      <mi>i</mi>
                    </msub>
                    <mo>-</mo>
                    <msub>
                      <mi>x</mi>
                      <mi>i</mi>
                    </msub>
                  </mrow>
                  <mo>)</mo>
                </mrow>
              </mrow>
              <mo>-</mo>
              <mrow>
                <msub>
                  <mi>f</mi>
                  <mi>xi</mi>
                </msub>
                <mo>&af;</mo>
                <mrow>
                  <mo>(</mo>
                  <mrow>
                    <msub>
                      <mi>y</mi>
                      <mi>i</mi>
                    </msub>
                    <mo>-</mo>
                    <msub>
                      <mi>y</mi>
                      <mi>i</mi>
                    </msub>
                  </mrow>
                  <mo>)</mo>
                </mrow>
              </mrow>
            </mrow>
            <mo>=</mo>
            <mn>0</mn>
          </mrow>
        </mrow>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mi>Eq</mi>
        <mo>.</mo>
        <mstyle>
          <mtext>&emsp;</mtext>
        </mstyle>
        <mo>&it;</mo>
        <mrow>
          <mo>(</mo>
          <mn>5</mn>
          <mo>)</mo>
        </mrow>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
<mathematica-file id="MATHEMATICA-00004" file="US20030002447A1-20030102-M00004.NB"/>
<image id="EMI-M00004" wi="216.027" he="81.1377" file="US20030002447A1-20030102-M00004.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>t</italic></highlight><highlight><subscript>zi</subscript></highlight><highlight><italic>&equals;f</italic></highlight><highlight><subscript>yi</subscript></highlight>(<highlight><italic>x</italic></highlight><highlight><subscript>i</subscript></highlight><highlight><italic>&minus;x</italic></highlight><highlight><subscript>i</subscript></highlight>)&minus;<highlight><italic>f</italic></highlight><highlight><subscript>xi</subscript></highlight>(<highlight><italic>y</italic></highlight><highlight><subscript>i</subscript></highlight><highlight><italic>&minus;y</italic></highlight><highlight><subscript>i</subscript></highlight>)&equals;0 </in-line-formula></paragraph>
<paragraph id="P-0103" lvl="7"><number>&lsqb;0103&rsqb;</number> for i&equals;1 , . . . , N, where:  
<math-cwu id="MATH-US-00005">
<number>5</number>
<math>
<mtable>
  <mtr>
    <mtd>
      <mrow>
        <mrow>
          <mrow>
            <mover>
              <mi>x</mi>
              <mi>_</mi>
            </mover>
            <mo>=</mo>
            <mfrac>
              <mrow>
                <munderover>
                  <mo>&Sum;</mo>
                  <mrow>
                    <mi>i</mi>
                    <mo>=</mo>
                    <mn>1</mn>
                  </mrow>
                  <mi>N</mi>
                </munderover>
                <mo>&it;</mo>
                <mrow>
                  <msub>
                    <mi>w</mi>
                    <mrow>
                      <mi>y</mi>
                      <mo>&it;</mo>
                      <mstyle>
                        <mtext>&emsp;</mtext>
                      </mstyle>
                      <mo>&it;</mo>
                      <mi>i</mi>
                    </mrow>
                  </msub>
                  <mo>&it;</mo>
                  <msub>
                    <mi>x</mi>
                    <mi>i</mi>
                  </msub>
                </mrow>
              </mrow>
              <mrow>
                <munderover>
                  <mo>&Sum;</mo>
                  <mrow>
                    <mi>i</mi>
                    <mo>=</mo>
                    <mn>1</mn>
                  </mrow>
                  <mi>N</mi>
                </munderover>
                <mo>&it;</mo>
                <msub>
                  <mi>w</mi>
                  <mrow>
                    <mi>y</mi>
                    <mo>&it;</mo>
                    <mstyle>
                      <mtext>&emsp;</mtext>
                    </mstyle>
                    <mo>&it;</mo>
                    <mi>i</mi>
                  </mrow>
                </msub>
              </mrow>
            </mfrac>
          </mrow>
          <mo>,</mo>
          <mrow>
            <mover>
              <mi>y</mi>
              <mi>_</mi>
            </mover>
            <mo>=</mo>
            <mfrac>
              <mrow>
                <munderover>
                  <mo>&Sum;</mo>
                  <mrow>
                    <mi>i</mi>
                    <mo>=</mo>
                    <mn>1</mn>
                  </mrow>
                  <mi>N</mi>
                </munderover>
                <mo>&it;</mo>
                <mrow>
                  <msub>
                    <mi>w</mi>
                    <mrow>
                      <mi>x</mi>
                      <mo>&it;</mo>
                      <mstyle>
                        <mtext>&emsp;</mtext>
                      </mstyle>
                      <mo>&it;</mo>
                      <mi>i</mi>
                    </mrow>
                  </msub>
                  <mo>&it;</mo>
                  <msub>
                    <mi>y</mi>
                    <mi>i</mi>
                  </msub>
                </mrow>
              </mrow>
              <mrow>
                <munderover>
                  <mo>&Sum;</mo>
                  <mrow>
                    <mi>i</mi>
                    <mo>=</mo>
                    <mn>1</mn>
                  </mrow>
                  <mi>N</mi>
                </munderover>
                <mo>&it;</mo>
                <msub>
                  <mi>w</mi>
                  <mrow>
                    <mi>x</mi>
                    <mo>&it;</mo>
                    <mstyle>
                      <mtext>&emsp;</mtext>
                    </mstyle>
                    <mo>&it;</mo>
                    <mi>i</mi>
                  </mrow>
                </msub>
              </mrow>
            </mfrac>
          </mrow>
        </mrow>
        <mo>&it;</mo>
        <mstyle>
          <mtext>&NewLine;</mtext>
        </mstyle>
        <mo>&it;</mo>
        <mrow>
          <mrow>
            <mover>
              <msup>
                <mi>x</mi>
                <mn>2</mn>
              </msup>
              <mi>_</mi>
            </mover>
            <mo>=</mo>
            <mfrac>
              <mrow>
                <munderover>
                  <mo>&Sum;</mo>
                  <mrow>
                    <mi>i</mi>
                    <mo>=</mo>
                    <mn>1</mn>
                  </mrow>
                  <mi>N</mi>
                </munderover>
                <mo>&it;</mo>
                <mrow>
                  <msub>
                    <mi>w</mi>
                    <mrow>
                      <mi>y</mi>
                      <mo>&it;</mo>
                      <mstyle>
                        <mtext>&emsp;</mtext>
                      </mstyle>
                      <mo>&it;</mo>
                      <mi>i</mi>
                    </mrow>
                  </msub>
                  <mo>&it;</mo>
                  <msubsup>
                    <mi>x</mi>
                    <mi>i</mi>
                    <mn>2</mn>
                  </msubsup>
                </mrow>
              </mrow>
              <mrow>
                <munderover>
                  <mo>&Sum;</mo>
                  <mrow>
                    <mi>i</mi>
                    <mo>=</mo>
                    <mn>1</mn>
                  </mrow>
                  <mi>N</mi>
                </munderover>
                <mo>&it;</mo>
                <msub>
                  <mi>w</mi>
                  <mrow>
                    <mi>y</mi>
                    <mo>&it;</mo>
                    <mstyle>
                      <mtext>&emsp;</mtext>
                    </mstyle>
                    <mo>&it;</mo>
                    <mi>i</mi>
                  </mrow>
                </msub>
              </mrow>
            </mfrac>
          </mrow>
          <mo>,</mo>
          <mrow>
            <mover>
              <msup>
                <mi>y</mi>
                <mn>2</mn>
              </msup>
              <mi>_</mi>
            </mover>
            <mo>=</mo>
            <mfrac>
              <mrow>
                <munderover>
                  <mo>&Sum;</mo>
                  <mrow>
                    <mi>i</mi>
                    <mo>=</mo>
                    <mn>1</mn>
                  </mrow>
                  <mi>N</mi>
                </munderover>
                <mo>&it;</mo>
                <mrow>
                  <msub>
                    <mi>w</mi>
                    <mrow>
                      <mi>x</mi>
                      <mo>&it;</mo>
                      <mstyle>
                        <mtext>&emsp;</mtext>
                      </mstyle>
                      <mo>&it;</mo>
                      <mi>i</mi>
                    </mrow>
                  </msub>
                  <mo>&it;</mo>
                  <msubsup>
                    <mi>y</mi>
                    <mi>i</mi>
                    <mn>2</mn>
                  </msubsup>
                </mrow>
              </mrow>
              <mrow>
                <munderover>
                  <mo>&Sum;</mo>
                  <mrow>
                    <mi>i</mi>
                    <mo>=</mo>
                    <mn>1</mn>
                  </mrow>
                  <mi>N</mi>
                </munderover>
                <mo>&it;</mo>
                <msub>
                  <mi>w</mi>
                  <mrow>
                    <mi>x</mi>
                    <mo>&it;</mo>
                    <mstyle>
                      <mtext>&emsp;</mtext>
                    </mstyle>
                    <mo>&it;</mo>
                    <mi>i</mi>
                  </mrow>
                </msub>
              </mrow>
            </mfrac>
          </mrow>
        </mrow>
        <mo>&it;</mo>
        <mstyle>
          <mtext>&NewLine;</mtext>
        </mstyle>
        <mo>&it;</mo>
        <mrow>
          <mrow>
            <msubsup>
              <mi>&sigma;</mi>
              <mi>x</mi>
              <mn>2</mn>
            </msubsup>
            <mo>=</mo>
            <mrow>
              <mover>
                <msup>
                  <mi>x</mi>
                  <mn>2</mn>
                </msup>
                <mi>_</mi>
              </mover>
              <mo>-</mo>
              <msup>
                <mover>
                  <mi>x</mi>
                  <mi>_</mi>
                </mover>
                <mn>2</mn>
              </msup>
            </mrow>
          </mrow>
          <mo>,</mo>
          <mrow>
            <msubsup>
              <mi>&sigma;</mi>
              <mi>y</mi>
              <mn>2</mn>
            </msubsup>
            <mo>=</mo>
            <mrow>
              <mover>
                <msup>
                  <mi>y</mi>
                  <mn>2</mn>
                </msup>
                <mi>_</mi>
              </mover>
              <mo>-</mo>
              <msup>
                <mover>
                  <mi>y</mi>
                  <mi>_</mi>
                </mover>
                <mn>2</mn>
              </msup>
            </mrow>
          </mrow>
        </mrow>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mi>Eq</mi>
        <mo>.</mo>
        <mstyle>
          <mtext>&emsp;</mtext>
        </mstyle>
        <mo>&it;</mo>
        <mrow>
          <mo>(</mo>
          <mn>6</mn>
          <mo>)</mo>
        </mrow>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
<mathematica-file id="MATHEMATICA-00005" file="US20030002447A1-20030102-M00005.NB"/>
<image id="EMI-M00005" wi="216.027" he="115.92315" file="US20030002447A1-20030102-M00005.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph lvl="0"><in-line-formula>&sgr;<highlight><subscript>x</subscript></highlight><highlight><superscript>2</superscript></highlight><highlight><italic>&equals;x</italic></highlight><highlight><superscript>2</superscript></highlight><highlight><italic>&minus;{overscore (x)}</italic></highlight><highlight><superscript>2</superscript></highlight>,&sgr;<highlight><subscript>y</subscript></highlight><highlight><superscript>2</superscript></highlight><highlight><italic>&equals;y</italic></highlight><highlight><superscript>2</superscript></highlight><highlight><italic>&minus;{overscore (y)}</italic></highlight><highlight><superscript>2 </superscript></highlight></in-line-formula></paragraph>
<paragraph id="P-0104" lvl="0"><number>&lsqb;0104&rsqb;</number> The quantities {overscore (x)}, {overscore (y)} are the weighted average position of all the submodules, and &sgr;<highlight><subscript>x</subscript></highlight>,&sgr;<highlight><subscript>y </subscript></highlight>are the weighted standard deviations of all the x and y submodule jet positions about this average. The torque t<highlight><subscript>zi </subscript></highlight>is zero with respect to (X<highlight><subscript>i</subscript></highlight>,y<highlight><subscript>i</subscript></highlight>). </paragraph>
<paragraph id="P-0105" lvl="0"><number>&lsqb;0105&rsqb;</number> These equations provide a continuous solution to the optimization problem. In various exemplary embodiments wherein the domains of the jets are continuous, these equations provide an optimal solution. When implemented with discrete actuators, the optimal solution is approx<highlight><subscript>i</subscript></highlight>mated with a hierarchical decomposition as the number of jets in each module becomes large (and thus has an almost continuous domain). The implementation with discrete actuators will be discussed below. </paragraph>
<paragraph id="P-0106" lvl="0"><number>&lsqb;0106&rsqb;</number> The overall forces required by Eqs. (5) and (6) represent a partitioning of the overall task U&equals;(F<highlight><subscript>x</subscript></highlight>F<highlight><subscript>y</subscript></highlight>T<highlight><subscript>z</subscript></highlight>)<highlight><superscript>T </superscript></highlight>for a large region into tasks u<highlight><subscript>i</subscript></highlight>&equals;(f<highlight><subscript>xi</subscript></highlight>f<highlight><subscript>yi</subscript></highlight>0)<highlight><superscript>T </superscript></highlight>for its subregions or modules. </paragraph>
<paragraph id="P-0107" lvl="0"><number>&lsqb;0107&rsqb;</number> The solution in Eqs. (5) and (6) to the constrained optimization problem can be instantiated as needed for particular systems. For example, for non-hierarchical allocation to N<highlight><subscript>x </subscript></highlight>x jets and N<highlight><subscript>y </subscript></highlight>y jets, each jet &ldquo;module&rdquo; includes a single jet and is weighted equally by (w<highlight><subscript>xi</subscript></highlight>w<highlight><subscript>yi</subscript></highlight>)&equals;(<highlight><bold>1</bold></highlight> <highlight><bold>0</bold></highlight>) for an x jet and (<highlight><bold>0</bold></highlight> <highlight><bold>1</bold></highlight>) for a y jet. The instantiations of Eqs. 5 and 6 are easy to derive. </paragraph>
<paragraph id="P-0108" lvl="0"><number>&lsqb;0108&rsqb;</number> In a two-level hierarchical allocation, where the system is decomposed into modules consisting of individual jets, weights at the top level can be used to shift assignment of actuation depending on module sizes. For example, for the ith module with n<highlight><subscript>xi </subscript></highlight>x jets and n<highlight><subscript>yi </subscript></highlight>y jets, the weights may be selected to be (w<highlight><subscript>xi</subscript></highlight>w<highlight><subscript>yi</subscript></highlight>)&equals;(n<highlight><subscript>xi</subscript></highlight>n<highlight><subscript>yi</subscript></highlight>). Again, the instantiations of Eqs. 5 and 6 can be derived. Allocation within each module is akin to non-hierarchical allocation to the jets in the module, using the same equations. </paragraph>
<paragraph id="P-0109" lvl="0"><number>&lsqb;0109&rsqb;</number> For a module that is logically decomposed, allocation to the modules instantiating Eqs. (5) and (6) needs only to be computed for f<highlight><subscript>xi </subscript></highlight>or f<highlight><subscript>yi </subscript></highlight>for the x and y modules, respectively, and allocation within a module follows Eq. (7) for x modules and its equivalent for y modules. In various exemplary embodiments, if an array of air jets that has been decomposed by a logical heuristic consists only of N x jets with the same y position, the instantiation of the allocation function for the module, namely, Eq. (5), would be  
<math-cwu id="MATH-US-00006">
<number>6</number>
<math>
<mtable>
  <mtr>
    <mtd>
      <mtable>
        <mtr>
          <mtd>
            <mrow>
              <mrow>
                <msub>
                  <mi>f</mi>
                  <mrow>
                    <mi>x</mi>
                    <mo>&it;</mo>
                    <mstyle>
                      <mtext>&emsp;</mtext>
                    </mstyle>
                    <mo>&it;</mo>
                    <mi>i</mi>
                  </mrow>
                </msub>
                <mo>=</mo>
                <mfrac>
                  <msub>
                    <mi>F</mi>
                    <mi>x</mi>
                  </msub>
                  <mi>N</mi>
                </mfrac>
              </mrow>
              <mo>,</mo>
              <mrow>
                <msub>
                  <mi>f</mi>
                  <mrow>
                    <mi>y</mi>
                    <mo>&it;</mo>
                    <mstyle>
                      <mtext>&emsp;</mtext>
                    </mstyle>
                    <mo>&it;</mo>
                    <mi>i</mi>
                  </mrow>
                </msub>
                <mo>=</mo>
                <mn>0</mn>
              </mrow>
              <mo>,</mo>
              <mrow>
                <msub>
                  <mi>t</mi>
                  <mrow>
                    <mi>z</mi>
                    <mo>&it;</mo>
                    <mstyle>
                      <mtext>&emsp;</mtext>
                    </mstyle>
                    <mo>&it;</mo>
                    <mi>i</mi>
                  </mrow>
                </msub>
                <mo>=</mo>
                <mn>0</mn>
              </mrow>
            </mrow>
          </mtd>
          <mtd>
            <mrow>
              <mo>(</mo>
              <mrow>
                <mrow>
                  <mi>i</mi>
                  <mo>=</mo>
                  <mn>1</mn>
                </mrow>
                <mo>,</mo>
                <mi>&hellip;</mi>
                <mo>&it;</mo>
                <mstyle>
                  <mtext>&emsp;</mtext>
                </mstyle>
                <mo>,</mo>
                <mi>N</mi>
              </mrow>
              <mo>)</mo>
            </mrow>
          </mtd>
        </mtr>
      </mtable>
    </mtd>
    <mtd>
      <mrow>
        <mi>Eq</mi>
        <mo>.</mo>
        <mstyle>
          <mtext>&emsp;</mtext>
        </mstyle>
        <mo>&it;</mo>
        <mrow>
          <mo>(</mo>
          <mn>7</mn>
          <mo>)</mo>
        </mrow>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
<mathematica-file id="MATHEMATICA-00006" file="US20030002447A1-20030102-M00006.NB"/>
<image id="EMI-M00006" wi="216.027" he="18.00225" file="US20030002447A1-20030102-M00006.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0110" lvl="0"><number>&lsqb;0110&rsqb;</number> After steps S<highlight><bold>430</bold></highlight> and S<highlight><bold>435</bold></highlight>, the method proceeds to step S<highlight><bold>440</bold></highlight>, wherein it is determined whether all of the modules have been evaluated, i.e. whether the forces for the modules have to be either further allocated or assigned to individual actuators. In other words, it is determined whether i is equal to n, wherein n equals the number of modules in the level. If i is not equal to n (i.e. all the modules have not been evaluated), the method proceeds to step S<highlight><bold>445</bold></highlight>. </paragraph>
<paragraph id="P-0111" lvl="0"><number>&lsqb;0111&rsqb;</number> In step S<highlight><bold>445</bold></highlight>, the next module is selected. In other words, i is increased to i&plus;1. The method then proceeds back through steps S<highlight><bold>415</bold></highlight> through S<highlight><bold>440</bold></highlight>, until i is equal to n, the number of modules or actuators within the level. In other words, each module in the level is decomposed, the force for each module is determined and the force for each module is either allocated to a submodule or assigned to individual actuators. If there are no further modules to select, then a next module cannot be selected and in step S<highlight><bold>440</bold></highlight> it will be determined that all of the modules have been evaluated. </paragraph>
<paragraph id="P-0112" lvl="0"><number>&lsqb;0112&rsqb;</number> If in step S<highlight><bold>440</bold></highlight>, it is determined that all the modules have been evaluated, i.e., that i is equal to n, then the method proceeds to step S<highlight><bold>450</bold></highlight>, wherein the method ends. </paragraph>
<paragraph id="P-0113" lvl="0"><number>&lsqb;0113&rsqb;</number> The foregoing exemplary embodiment has the property that the allocation within one module does not depend on the allocation within any other module at the same level. In other words, allocations within modules at any given level are completely decoupled from each other and thus can be parallelized and distributed among multiple processors. </paragraph>
<paragraph id="P-0114" lvl="0"><number>&lsqb;0114&rsqb;</number> Furthermore, the distribution of computation is at the same scale as the actuation. This property is of obvious interest for many actuator systems with very large numbers of actuators. </paragraph>
<paragraph id="P-0115" lvl="0"><number>&lsqb;0115&rsqb;</number> In the foregoing exemplary embodiment, each call to allocate a force for a module partitions the actuation to the submodules of a given module. This exemplary embodiment is optimal for jets with continuous domains. </paragraph>
<paragraph id="P-0116" lvl="0"><number>&lsqb;0116&rsqb;</number> The foregoing exemplary embodiment recursively decomposes and allocates actuation to submodules within a module. In other various exemplary embodiments, the recursion terminates when at most n<highlight><subscript>max </subscript></highlight>jets remain in a module or the bottom level has been reached. </paragraph>
<paragraph id="P-0117" lvl="0"><number>&lsqb;0117&rsqb;</number> The foregoing exemplary embodiment is a recursive method. In other various exemplary embodiments, the method is implemented by an iterative method instead, as will be apparent to one skilled in the art. </paragraph>
<paragraph id="P-0118" lvl="0"><number>&lsqb;0118&rsqb;</number> In other various exemplary embodiments, the foregoing exemplary allocation method further includes allocating for error in step S<highlight><bold>430</bold></highlight> that is generated during the force allocation of step S<highlight><bold>430</bold></highlight> of a previous module. The error is the difference between the desired goal actuation for a given module and the actually produced actuation. </paragraph>
<paragraph id="P-0119" lvl="0"><number>&lsqb;0119&rsqb;</number> In one exemplary embodiment, the method of allocating the error is completed by a next module allocation method. The next module allocation method adds the force and torque errors made in allocating u<highlight><subscript>i&minus;1</subscript></highlight>&equals;(F<highlight><subscript>i&minus;1</subscript></highlight><highlight><superscript>n</superscript></highlight>,T<highlight><subscript>i&minus;1</subscript></highlight><highlight><superscript>n</superscript></highlight>) to the next module i to be allocated. In particular:  
<math-cwu id="MATH-US-00007">
<number>7</number>
<math>
<mrow>
  <msubsup>
    <mi>F</mi>
    <mi>i</mi>
    <mi>n</mi>
  </msubsup>
  <mo>=</mo>
  <mrow>
    <mrow>
      <msup>
        <mi>F</mi>
        <mrow>
          <mo>(</mo>
          <mrow>
            <mi>n</mi>
            <mo>-</mo>
            <mn>1</mn>
          </mrow>
          <mo>)</mo>
        </mrow>
      </msup>
      <mo>/</mo>
      <msub>
        <mi>N</mi>
        <mi>n</mi>
      </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
      <mfrac>
        <mrow>
          <mo>(</mo>
          <mrow>
            <msup>
              <mi>T</mi>
              <mrow>
                <mo>(</mo>
                <mrow>
                  <mi>n</mi>
                  <mo>-</mo>
                  <mn>1</mn>
                </mrow>
                <mo>)</mo>
              </mrow>
            </msup>
            <mo>-</mo>
            <mrow>
              <mover>
                <mi>x</mi>
                <mi>_</mi>
              </mover>
              <mo>&it;</mo>
              <mstyle>
                <mtext>&emsp;</mtext>
              </mstyle>
              <mo>&it;</mo>
              <msup>
                <mi>F</mi>
                <mrow>
                  <mstyle>
                    <mtext>&emsp;</mtext>
                  </mstyle>
                  <mo>&it;</mo>
                  <mrow>
                    <mo>(</mo>
                    <mrow>
                      <mi>n</mi>
                      <mo>-</mo>
                      <mn>1</mn>
                    </mrow>
                    <mo>)</mo>
                  </mrow>
                </mrow>
              </msup>
            </mrow>
          </mrow>
          <mo>)</mo>
        </mrow>
        <mrow>
          <msub>
            <mi>N</mi>
            <mi>n</mi>
          </msub>
          <mo>&it;</mo>
          <msubsup>
            <mi>&sigma;</mi>
            <mi>x</mi>
            <mn>2</mn>
          </msubsup>
        </mrow>
      </mfrac>
      <mo>&it;</mo>
      <mrow>
        <mo>(</mo>
        <mrow>
          <msub>
            <mi>x</mi>
            <mi>i</mi>
          </msub>
          <mo>-</mo>
          <mover>
            <mi>x</mi>
            <mi>_</mi>
          </mover>
        </mrow>
        <mo>)</mo>
      </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
      <mrow>
        <mo>(</mo>
        <mrow>
          <mn>1</mn>
          <mo>-</mo>
          <mi>W</mi>
        </mrow>
        <mo>)</mo>
      </mrow>
      <mo>&it;</mo>
      <mi>&Delta;</mi>
      <mo>&it;</mo>
      <mstyle>
        <mtext>&emsp;</mtext>
      </mstyle>
      <mo>&it;</mo>
      <mrow>
        <msubsup>
          <mi>T</mi>
          <mrow>
            <mi>i</mi>
            <mo>-</mo>
            <mn>1</mn>
          </mrow>
          <mrow>
            <mo>(</mo>
            <mrow>
              <mi>n</mi>
              <mo>-</mo>
              <mn>1</mn>
            </mrow>
            <mo>)</mo>
          </mrow>
        </msubsup>
        <mo>/</mo>
        <msub>
          <mi>x</mi>
          <mi>i</mi>
        </msub>
      </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
      <mi>W</mi>
      <mo>&it;</mo>
      <mstyle>
        <mtext>&emsp;</mtext>
      </mstyle>
      <mo>&it;</mo>
      <mi>&Delta;</mi>
      <mo>&it;</mo>
      <mstyle>
        <mtext>&emsp;</mtext>
      </mstyle>
      <mo>&it;</mo>
      <mrow>
        <msubsup>
          <mi>F</mi>
          <mrow>
            <mi>i</mi>
            <mo>-</mo>
            <mn>1</mn>
          </mrow>
          <mrow>
            <mo>(</mo>
            <mrow>
              <mi>n</mi>
              <mo>-</mo>
              <mn>1</mn>
            </mrow>
            <mo>)</mo>
          </mrow>
        </msubsup>
        <mo>.</mo>
      </mrow>
    </mrow>
  </mrow>
</mrow>
</math>
<mathematica-file id="MATHEMATICA-00007" file="US20030002447A1-20030102-M00007.NB"/>
<image id="EMI-M00007" wi="216.027" he="33.1128" file="US20030002447A1-20030102-M00007.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0120" lvl="7"><number>&lsqb;0120&rsqb;</number> where: </paragraph>
<paragraph lvl="0"><in-line-formula>&Dgr;T<highlight><subscript>i&minus;1</subscript></highlight><highlight><superscript>(n&minus;1) </superscript></highlight></in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula>&Dgr;F<highlight><subscript>i&minus;1</subscript></highlight><highlight><superscript>(n&minus;1) </superscript></highlight></in-line-formula></paragraph>
<paragraph id="P-0121" lvl="7"><number>&lsqb;0121&rsqb;</number> are the torque and force errors respectively made during allocation of the (i&minus;1)th subdomain and W is an error weighting factor reflecting the relative importance of torque versus force errors. If W&equals;1, then force errors are only to be considered, while W&equals;0 ignores the force errors and considers only torque errors. The ith module attempts to correct for the error made during the earlier allocations. Similarly, when all the child modules/submodules have been allocated, the resulting error of the parent module is allocated to the next parent module who passes the error on to its children modules (i.e. its submodules). The order of considering the modules can be important with this embodiment, as well as others. For example, error allocation could be sequential or to a nearest neighbor. In various exemplary embodiments, an allocation from the rim of the object (sheet) to its center (&ldquo;outside-in) is preferred. With an outside-in allocation, the outer most modules are allocated first. The error generated from this allocation is then allocated to the next outer most modules that are usually on the opposite side of the object. This process is continued until the center module is the last to be allocated. Outer modules apply the largest torques on the object. Any errors made by the outer modules tend to cancel each other out, leaving smaller errors to be dealt with by the inner modules that can deliver smaller torques. </paragraph>
<paragraph id="P-0122" lvl="0"><number>&lsqb;0122&rsqb;</number> In another exemplary embodiment, the error allocation method is a universal error allocation. In the universal error allocation method, the error generated is allocated to all of the remaining modules within the current level. This error allocation is accomplished by adjusting T<highlight><superscript>(n&minus;1) </superscript></highlight>and F<highlight><superscript>(n&minus;1) </superscript></highlight>by the error caused by allocation of the current module. The allocation of the next subdomain uses the new goals. <cross-reference target="DRAWINGS">FIG. 7</cross-reference> displays a chart that displays decomposition of a system into modules <highlight><bold>701</bold></highlight>, <highlight><bold>702</bold></highlight>, and <highlight><bold>703</bold></highlight> for modules <highlight><bold>1</bold></highlight>, <highlight><bold>2</bold></highlight>, and <highlight><bold>3</bold></highlight> respectively, to approximate a continuous force represented by dot-dashed curved line <highlight><bold>710</bold></highlight>. Each module attempts to represent the average continuous force density within its boundaries. For module <highlight><bold>1</bold></highlight>, this force is <highlight><bold>712</bold></highlight>. The actual force delivered in this module is 706 denoted by the dashed line. The error therefore is given by the cross hatched square <highlight><bold>708</bold></highlight>. The error <highlight><bold>708</bold></highlight> is subtracted from the average continuous force <highlight><bold>714</bold></highlight> to give the next desired force, <highlight><bold>718</bold></highlight>, the thick line in module <highlight><bold>2</bold></highlight>. The error <highlight><bold>708</bold></highlight> is subtracted from <highlight><bold>714</bold></highlight> because the delivered force was too large in module <highlight><bold>1</bold></highlight> compared to the desired force <highlight><bold>712</bold></highlight>. The force delivered in module <highlight><bold>2</bold></highlight> is given by <highlight><bold>716</bold></highlight> (dashed line), which is too small compared to the total desired force <highlight><bold>718</bold></highlight> denoted by the thick line, giving an error for module <highlight><bold>2</bold></highlight> given by <highlight><bold>728</bold></highlight>. This error <highlight><bold>728</bold></highlight> is added to the desired average continuous force <highlight><bold>722</bold></highlight> to given the desired module <highlight><bold>3</bold></highlight> force <highlight><bold>720</bold></highlight> (thick line). The actual delivered force in module <highlight><bold>3</bold></highlight> is <highlight><bold>724</bold></highlight> denoted by the dashed line. The error is therefore <highlight><bold>726</bold></highlight> for the combination of all three modules. The error scheme presented in <cross-reference target="DRAWINGS">FIG. 7</cross-reference> is just one of many. Another possibility includes assigning equal fractions of each module error to the others. </paragraph>
<paragraph id="P-0123" lvl="0"><number>&lsqb;0123&rsqb;</number> Because of the error allocation methods, according to the present invention, the local allocations of force do not have to be absolutely optimal; global allocation is important. </paragraph>
</section>
<section>
<heading lvl="1">Experimental Results </heading>
<paragraph id="P-0124" lvl="0"><number>&lsqb;0124&rsqb;</number> Experimental results will now be discussed to evaluate the various alternative force allocation algorithms in terms of their efficiency and effectiveness. Of particular importance for systems with large numbers of actuators is the scaling of their execution times and force allocation errors with the number of actuators. One might expect that there is a trade-off between execution time and errors for the different force allocation algorithms. </paragraph>
<paragraph id="P-0125" lvl="0"><number>&lsqb;0125&rsqb;</number> For the following evaluations, a simplified system of air jets were used as actuators. The system consisted of y jets that together only deliver a y-force and a z-torque U&equals;&lsqb;F<highlight><subscript>y</subscript></highlight>T<highlight><subscript>z</subscript></highlight>&rsqb;<highlight><superscript>T</superscript></highlight>. The number of positive and negative jets N under the sheet ranged from 1-100, the number of jets per module in hierarchical algorithms was 5, and the total combined maximum force was always F<highlight><subscript>max</subscript></highlight>&equals;1 (i.e., each jet delivered a force of <highlight><bold>{fraction (1/N)}). The jets were generalized discrete jets with domains &lcub;&minus;</bold></highlight>{fraction (1/N)}, <highlight><bold>0, {fraction (1/N)}&rcub; (i.e. possible actuation states). </bold></highlight></paragraph>
<paragraph id="P-0126" lvl="0"><number>&lsqb;0126&rsqb;</number> There are two ways of decomposing this exemplary experimental system hierarchically, either by grouping jets that are next to each other into modules, or by defining modules as columns of multiple jets with the same x position. In either case, this simplified system is equivalent to controlling the angle and y-position of a sheet using columns of jets. </paragraph>
<paragraph id="P-0127" lvl="0"><number>&lsqb;0127&rsqb;</number> Each algorithm was evaluated on a two-dimensional grid of goal force and torque values to determine the execution time and average allocation error. The grid evaluation points range from &minus;1 to 1 with step size 0.25 with a small pseudo-random value added to avoid symmetric cancellation. Time is the elapsed CPU time. All of the algorithms were implemented in Matlab 5.3 and computations for modules at the same level were simulated as running in parallel. The combined rms error &sgr; for the desired goals U<highlight><subscript>i</subscript></highlight>&equals;(F<highlight><subscript>yi</subscript></highlight>T<highlight><subscript>zi</subscript></highlight>) and the allocated actuation U<highlight><subscript>a,i</subscript></highlight>&equals;(F<highlight><subscript>ya,i</subscript></highlight>T<highlight><subscript>za,i</subscript></highlight>) was calculated as </paragraph>
<paragraph lvl="0"><in-line-formula>&sgr;&equals;{square root}<highlight><italic>{square root over (w<highlight><subscript>1</subscript></highlight>&sgr;<highlight><subscript>f</subscript></highlight><highlight><superscript>2</superscript></highlight><highlight><italic>&plus;w</italic></highlight><highlight><subscript>2</subscript></highlight>&sgr;<highlight><subscript>T</subscript></highlight><highlight><superscript>2</superscript></highlight>)}</italic></highlight></in-line-formula></paragraph>
<paragraph id="P-0128" lvl="7"><number>&lsqb;0128&rsqb;</number> where w<highlight><subscript>1</subscript></highlight>&equals;w<highlight><subscript>2</subscript></highlight>&equals;0.5, and &sgr;<highlight><subscript>F </subscript></highlight>and &sgr;<highlight><subscript>T </subscript></highlight>are the standard deviations of force error and torque errors computed over the grid or portions of the grid. <cross-reference target="DRAWINGS">FIGS. 8 and 9</cross-reference> show a task space of F<highlight><subscript>y </subscript></highlight>and T<highlight><subscript>z </subscript></highlight>grid with pseudo-random variations. <cross-reference target="DRAWINGS">FIG. 8</cross-reference> shows a pictorial representation of a sample rms combined error over the grid for an optimal algorithm. It shows that large force and torque values cannot be delivered together as represented by areas <highlight><bold>805</bold></highlight>. Because these large, unavoidable errors dominate the rms error, the rms error was computed over a confined area of the grid, namely a circle <highlight><bold>905</bold></highlight> with range 90% of F<highlight><subscript>max</subscript></highlight>, where an algorithm should be able to allocate with a small error as shown in <cross-reference target="DRAWINGS">FIG. 9</cross-reference> (which is a grid of evaluated force/torque points (within circle)). </paragraph>
<paragraph id="P-0129" lvl="0"><number>&lsqb;0129&rsqb;</number> In this evaluation, the four algorithms shown in Table 1 were compared. The four algorithms are: 1) optimal allocation using global search; 2) flat (non-hierarchical) allocation using Eqs. (5) and (6) in Solve and simple thresholding of the result in Assign; 3) two-level hierarchical allocation using Eqs. (5) and (6) in Solve at both levels; and 4) two-level hierarchical allocation using Eqs. (5) and (6) at the top level and optimal allocation at the lower level. Optimal allocation includes a brute-force search through all the possibilities for the allocation that minimizes the rms error.  
<table-cwu id="TABLE-US-00001">
<number>1</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="63PT" align="left"/>
<colspec colname="2" colwidth="35PT" align="left"/>
<colspec colname="3" colwidth="91PT" align="center"/>
<thead>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center">TABLE 1</entry>
</row>
<row>
<entry></entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry></entry>
<entry>Algorithms</entry>
<entry>Optimal</entry>
<entry>Heuristic</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
<entry>Flat</entry>
<entry>1 (global)</entry>
<entry>2</entry>
</row>
<row>
<entry></entry>
<entry>Hierarchical</entry>
<entry>4 (local)</entry>
<entry>3</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0130" lvl="0"><number>&lsqb;0130&rsqb;</number> Optimal allocation provides a baseline for the average allocation error. Because the execution time of the optimal algorithm scales so poorly with the number of jets, the optimal algorithm was evaluated only over the range of 1 to 10 jets. The results are shown in <cross-reference target="DRAWINGS">FIG. 10</cross-reference>. The rms error is given by <highlight><bold>{fraction (0.4/N)} and computation time scales as </bold></highlight>0.04 10<highlight><superscript>N</superscript></highlight>. These scaling results are readily understood because the truncation error for N jets with a force of <highlight><bold>{fraction (1/N)} each is a uniform distribution &plusmn;</bold></highlight><highlight><bold>{fraction (1/2N)}. When this error is averaged over the force and torque grid, the result is roughly </bold></highlight><highlight><bold>{fraction (1/2)}N</bold></highlight>{square root}{square root over (2)}, which agrees with the observed value. While the error is small for optimal allocation, the exponential scaling for the computation time is unacceptable for systems with large numbers of actuators. </paragraph>
<paragraph id="P-0131" lvl="0"><number>&lsqb;0131&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 11</cross-reference> shows a comparison of the errors of the four algorithms in Table 1 for N&equals;10 jets. As the figure shows, algorithm <highlight><bold>4</bold></highlight> (hierarchical allocation with optimal allocation within the module) yields the best results among the suboptimal algorithms. Flat allocation is next best, while hierarchical allocation without module optimization has the largest errors. Comparing the hierarchical algorithm with and without optimal allocation indicates that most of the error occurs by truncation when assigning within the module. Thus even for a small number of jets (e.g., less than 10), optimal allocation yields only about a factor of two improvement in error at a cost of 1 to 10 orders of magnitude in computation speed over the near-optimal allocation schemes. It is clear that near-optimal allocation is required for the more interesting ranges of 10-1000 jets. </paragraph>
<paragraph id="P-0132" lvl="0"><number>&lsqb;0132&rsqb;</number> The scaling of error and computation time as the number of jets ranges from 10 to 100 is now considered. While the optimal allocation cannot be computed, the scaling properties of the various near-optimal allocation algorithms can be compared and the scaling laws for the optimal allocation can be used. The computation times for the evaluated algorithms as a function of the number of jets is shown in <cross-reference target="DRAWINGS">FIG. 12</cross-reference>. The hierarchical allocation algorithms exhibit a very slow increase with the number of jets compared with the optimal and flat algorithms, confirming the expectation that hierarchical allocations exhibit good scaling properties. The time of (suboptimal) flat allocation (Alg. <highlight><bold>2</bold></highlight> increases as N, a clear disadvantage when compared with hierarchical allocation. The constant penalty factor for algorithm <highlight><bold>4</bold></highlight> compared with algorithm <highlight><bold>3</bold></highlight> reflects the time required to compute an optimal allocation for a small number of jets. In fact, at N&equals;10, the computation time is completely dominated by the optimal allocation. This computation penalty factor could be removed by using precomputed look-up tables for allocation at the module level, or by decomposing the system such that optimal allocation within a module becomes trivial. In the evaluated system, the latter can be achieved by aggregating modules from columns of y jets with the same x position, as indicated above. </paragraph>
<paragraph id="P-0133" lvl="0"><number>&lsqb;0133&rsqb;</number> The rms error for the evaluated algorithms as a function of the number of jets is shown in <cross-reference target="DRAWINGS">FIG. 13</cross-reference>. As is evident, the error does not decrease significantly as the number of jets increases, even with optimal module allocation (algorithm <highlight><bold>4</bold></highlight>). This behavior is a consequence of the fact that errors from individual module and jet allocations are not compensated by other allocations. More particularly, with a jet force of <highlight><bold>{fraction (1/N)} and optimal module allocation, each module makes an error of up to </bold></highlight><highlight><bold>{fraction (1/2)}N. With </bold></highlight>5 jets per module, the number of modules is M&equals;{fraction (N/5)}, and thus the total force error can be as large as M <highlight><bold>{fraction (1/2)}&equals;{fraction (N/</bold></highlight>5)} <highlight><bold>{fraction (1/2)}N&equals;</bold></highlight>0.1 independent of the number of jets. Because the maximum error tends to dominate the rms average, all the algorithms cluster near this value. Even with optimal module allocation, only the jets within a module are able to compensate for each other&apos;s error. However, from the maximum error formula M<highlight><bold>{fraction (1/2)}N, It is apparent that if the number of modules M is kept constant as the number of jets N is increased (i.e., the number of jets per module is increased), the error scales roughly as M&times;</bold></highlight><highlight><bold>{fraction (1/2)}N. </bold></highlight></paragraph>
<paragraph id="P-0134" lvl="0"><number>&lsqb;0134&rsqb;</number> The experimental results presented above can be summarized as follows. There is a trade-off between error and computation time for the allocation problem for large numbers of actuators. Globally optimal allocation (algorithm <highlight><bold>1</bold></highlight>), while producing the best errors, scales poorly with increasing numbers of jets. In fact, unless optimal allocation can be precomputed or computed easily (as in the row/column decomposition), the computational time scales as 2<highlight><superscript>N </superscript></highlight>for N jets. On the other hand, flat allocation (algorithm <highlight><bold>2</bold></highlight>), or simply breaking the problem into modules that are not allocated optimally (algorithm <highlight><bold>3</bold></highlight>), results in relatively large allocation errors. In fact, as shown above, the dominating rms error is on the order of one half the maximum total force. </paragraph>
<paragraph id="P-0135" lvl="0"><number>&lsqb;0135&rsqb;</number> The best compromise is a hierarchical decomposition into modules with optimal allocation within a module (algorithm <highlight><bold>4</bold></highlight>). Given a scaling of the error as {fraction (M/N)} as shown above, the larger the module for which the optimal allocation can be computed in real-time, or precomputed and stored, and thus the smaller the number of modules M, the better the result. At the same time, given {fraction (N/M)} jets per module, the optimal allocation time per module scales with 2{fraction (N/M)}, which suggests a trade-off between module size and number of modules for a particular N in order to decrease error while keeping computation time within acceptable bounds. The relation between error and computation time for all the algorithms, optimal, flat, and hierarchical, can be summarized with the relation </paragraph>
<paragraph lvl="0"><in-line-formula>log(T)&times;E&prop;1 &emsp;&emsp;(8) </in-line-formula></paragraph>
<paragraph id="P-0136" lvl="7"><number>&lsqb;0136&rsqb;</number> where T is the computation time and E is the fractional error, the error as a fraction of the full range. This relationship applies for problems where, given a local minimum, a lower minimum can be found almost anywhere and is only weak correlated with the previous minimum, and/or where the algorithm does little better than chance to go from one local minimum to finding the next. This appears to be the case for the combined optimization of force and torque from discrete jets. </paragraph>
<paragraph id="P-0137" lvl="0"><number>&lsqb;0137&rsqb;</number> However, if the algorithm can find better near-optimal solutions determined in constant time (i.e., precomputed or computed trivially as in the row/column decomposition), and if module allocation can be distributed, then even superlinear scaling can be achieved, as computation time is dominated by the allocation to M modules at the top level. </paragraph>
<paragraph id="P-0138" lvl="0"><number>&lsqb;0138&rsqb;</number> These results are summarized in Table 2. Note that, for hierarchical algorithms, the computation time is the sum of computation times at the top and module levels. Assuming P processors available for module allocation, the latter can further be divided by P (consider in particular the case where P&equals;M, i.e., there is one processor per module). For reference, the communication load is included, which scales with the number of calls between the levels and to the actuators.  
<table-cwu id="TABLE-US-00002">
<number>2</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="6">
<colspec colname="1" colwidth="70PT" align="left"/>
<colspec colname="2" colwidth="21PT" align="left"/>
<colspec colname="3" colwidth="21PT" align="left"/>
<colspec colname="4" colwidth="28PT" align="left"/>
<colspec colname="5" colwidth="49PT" align="left"/>
<colspec colname="6" colwidth="28PT" align="left"/>
<thead>
<row>
<entry namest="1" nameend="6" align="center">TABLE 2</entry>
</row>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="6" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Algorithms</entry>
<entry>1</entry>
<entry>2</entry>
<entry>3</entry>
<entry>4</entry>
<entry>4 (cto)</entry>
</row>
<row><entry namest="1" nameend="6" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
<entry></entry>
<entry></entry>
<entry></entry>
<entry></entry>
<entry></entry>
</row>
<row>
<entry>Rms error</entry>
<entry>
<math-cwu id="MATH-US-00008">
<number>8</number>
<math>
<mfrac>
  <mn>1</mn>
  <mrow>
    <mn>2</mn>
    <mo>&it;</mo>
    <mi>N</mi>
  </mrow>
</mfrac>
</math>
<mathematica-file id="MATHEMATICA-00008" file="US20030002447A1-20030102-M00008.NB"/>
<image id="EMI-M00008" wi="15.11055" he="17.03835" file="US20030002447A1-20030102-M00008.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</entry>
<entry>
<math-cwu id="MATH-US-00009">
<number>9</number>
<math>
<mfrac>
  <mn>1</mn>
  <mn>2</mn>
</mfrac>
</math>
<mathematica-file id="MATHEMATICA-00009" file="US20030002447A1-20030102-M00009.NB"/>
<image id="EMI-M00009" wi="10.0926" he="17.03835" file="US20030002447A1-20030102-M00009.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</entry>
<entry>
<math-cwu id="MATH-US-00010">
<number>10</number>
<math>
<mfrac>
  <mn>1</mn>
  <mn>2</mn>
</mfrac>
</math>
<mathematica-file id="MATHEMATICA-00010" file="US20030002447A1-20030102-M00010.NB"/>
<image id="EMI-M00010" wi="10.0926" he="17.03835" file="US20030002447A1-20030102-M00010.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</entry>
<entry>
<math-cwu id="MATH-US-00011">
<number>11</number>
<math>
<mfrac>
  <mi>M</mi>
  <mrow>
    <mn>2</mn>
    <mo>&it;</mo>
    <mi>N</mi>
  </mrow>
</mfrac>
</math>
<mathematica-file id="MATHEMATICA-00011" file="US20030002447A1-20030102-M00011.NB"/>
<image id="EMI-M00011" wi="15.11055" he="17.03835" file="US20030002447A1-20030102-M00011.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</entry>
<entry>
<math-cwu id="MATH-US-00012">
<number>12</number>
<math>
<mfrac>
  <mi>M</mi>
  <mrow>
    <mn>2</mn>
    <mo>&it;</mo>
    <mi>N</mi>
  </mrow>
</mfrac>
</math>
<mathematica-file id="MATHEMATICA-00012" file="US20030002447A1-20030102-M00012.NB"/>
<image id="EMI-M00012" wi="15.11055" he="17.03835" file="US20030002447A1-20030102-M00012.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</entry>
</row>
<row>
<entry> </entry>
</row>
<row>
<entry>Computation time</entry>
<entry>2<highlight><superscript>N</superscript></highlight></entry>
<entry>N</entry>
<entry>
<math-cwu id="MATH-US-00013">
<number>13</number>
<math>
<mrow>
  <mi>M</mi>
  <mo>+</mo>
  <mfrac>
    <mi>N</mi>
    <mi>P</mi>
  </mfrac>
</mrow>
</math>
<mathematica-file id="MATHEMATICA-00013" file="US20030002447A1-20030102-M00013.NB"/>
<image id="EMI-M00013" wi="24.97635" he="17.03835" file="US20030002447A1-20030102-M00013.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</entry>
<entry>
<math-cwu id="MATH-US-00014">
<number>14</number>
<math>
<mrow>
  <mi>M</mi>
  <mo>+</mo>
  <mfrac>
    <mrow>
      <mi>M</mi>
      <mo>&it;</mo>
      <mstyle>
        <mtext>&emsp;</mtext>
      </mstyle>
      <mo>&it;</mo>
      <msup>
        <mn>2</mn>
        <mfrac>
          <mi>N</mi>
          <mi>M</mi>
        </mfrac>
      </msup>
    </mrow>
    <mi>P</mi>
  </mfrac>
</mrow>
</math>
<mathematica-file id="MATHEMATICA-00014" file="US20030002447A1-20030102-M00014.NB"/>
<image id="EMI-M00014" wi="36.0045" he="22.08465" file="US20030002447A1-20030102-M00014.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</entry>
<entry>
<math-cwu id="MATH-US-00015">
<number>15</number>
<math>
<mrow>
  <mi>M</mi>
  <mo>+</mo>
  <mfrac>
    <mi>M</mi>
    <mi>P</mi>
  </mfrac>
</mrow>
</math>
<mathematica-file id="MATHEMATICA-00015" file="US20030002447A1-20030102-M00015.NB"/>
<image id="EMI-M00015" wi="26.16705" he="17.03835" file="US20030002447A1-20030102-M00015.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</entry>
</row>
<row>
<entry> </entry>
</row>
<row>
<entry>Communication load</entry>
<entry>N</entry>
<entry>N</entry>
<entry>M &plus; N</entry>
<entry>M &plus; N</entry>
<entry>M &plus; N</entry>
</row>
<row><entry namest="1" nameend="6" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0139" lvl="0"><number>&lsqb;0139&rsqb;</number> Table 2 shows scaling laws of error, computation time, and communication time for the algorithms that were evaluated, as well as for algorithm <highlight><bold>4</bold></highlight> with a constant-time module optimization (cto). The communication load is the number of messages passed between computational nodes and from computational nodes to the actuators. </paragraph>
<paragraph id="P-0140" lvl="0"><number>&lsqb;0140&rsqb;</number> The hybrid hierarchical-optimal algorithms presented work well for all ranges of numbers of actuators. For small numbers of actuators, the upper-level continuous allocation can be allocated trivially to a small number or even one module. The jets within a module are assigned optimally. For very large numbers of actuators (e.g.,&gt;1000), the number of jets within a module can be large, so the continuous allocation (which is optimal in the continuum limit) works very well. The lower level optimal allocation can be done either recursively to lower levels of modules or&mdash;because of the large numbers&mdash;through crude but rapid assignment. The algorithm works well in the medium range of 10&lt;N&lt;1000 as well. The asymptotic optimality of the continuum solution is used to guide the optimization to near-optimal smaller problems which are then solved using optimum methods. Thus, unlike other algorithms, this hybrid hiearchical optimal allocation works well in all regimes, and the system does not need to be redesigned as the number of actuators varies for different applications. </paragraph>
<paragraph id="P-0141" lvl="0"><number>&lsqb;0141&rsqb;</number> The hybrid hierarchical allocation of the present invention has been applied to an actual micro-electrical-mechanical system (MEMS) and found to work well. An exemplary embodiment of the present invention performs the allocation in&lt;0.4 ms for row/column allocation on a single Analog Devices SHARC 40 MHz DSP using algorithm <highlight><bold>4</bold></highlight> with constant time optimal allocation at the lower level. An 8&frac12; by 11 inch sheet in an exemplary embodiment of the present invention covers about N&equals;360 jets, and row/column decomposition results in about M&equals;40 to 50 modules with an average of 7 to 9 jets per module and a maximum of about 12 jets per module (depending on sheet position). The available jet force f<highlight><subscript>max </subscript></highlight>is about 0.1 mNt per jet. The average error is {fraction (M/2)} f<highlight><subscript>max</subscript></highlight>&equals;20 to 25 times f<highlight><subscript>max</subscript></highlight>, and the time is 40 to 50 times a computation for a module allocation, which is dominated by maintaining the data structures. The resulting position error has been 30 &mgr;m rms and 10<highlight><superscript>&minus;5 </superscript></highlight>radian rms angle error. </paragraph>
<paragraph id="P-0142" lvl="0"><number>&lsqb;0142&rsqb;</number> This is a tradeoff between the error and the computation time for methods of actuator allocation. Basically the log of the computation times the error is constant for hierarchical, optimal allocation, and hybrid-optimal hierarchical algorithms. Thus, a small decrease in error requires a large increase in computation time. However, because the allocation calculation is performed repetitively, this computational effort can be precomputed once. Thus, the hybrid hierarchical optimal allocation scheme had the best tradeoff between error and computation time. </paragraph>
<paragraph id="P-0143" lvl="0"><number>&lsqb;0143&rsqb;</number> The hybrid hierarchical-optimal algorithms of the present invention work well for all numbers of actuators from small traditional systems to many actuator systems conceived with thousands of actuators. These hybrid algorithms represent a general approach to high-dimensional problems. In other words, exemplary embodiments of the present invention use a continuous solution to break the problem up into a number of smaller self-similar problems that can either be further reduced in size or solved using optimal solutions. This present invention also has general application in other many degree of freedom systems such as robotic systems, such as, but not limited to, temperature-sensitive micro-robots (i.e. &ldquo;smart dust&rdquo;), and large-scale factories. </paragraph>
<paragraph id="P-0144" lvl="0"><number>&lsqb;0144&rsqb;</number> While this invention has been described in conjunction with the specific embodiments outlined above, it is evident that many alternatives, modifications and variations will be apparent to those skilled in the art. Accordingly, the preferred embodiments of the invention, as set forth above, are intended to be illustrative, not limiting. Various changes may be made without departing from the spirit and scope of this invention. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. An implementation unit system, comprising: 
<claim-text>a plurality of implementation units, </claim-text>
<claim-text>a controller that generates a system goal; and </claim-text>
<claim-text>an allocator that receives the system goal, partitions the system goal into a plurality of sub-goals based on an allocation parameter, and allocates the sub-goals to at least one of: 
<claim-text>the plurality of implementation units, and </claim-text>
<claim-text>a plurality of implementation modules comprising a group of the plurality of implementation units, </claim-text>
</claim-text>
<claim-text>wherein the allocator controls the implementation of the plurality of implementation units. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The system, as recited in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising: 
<claim-text>at least one sensor that detects an implementation state of at least one of the plurality of implementation units and provides the controller with the implementation state, </claim-text>
<claim-text>wherein the controller generates the system goal based on the implementation state. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The system, as recited in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein at least one of the plurality of implementation units is an air jet. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The system as recited in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising: 
<claim-text>an input source that provides system objective to the controller, </claim-text>
<claim-text>wherein the controller generates the system goal based on the system objective signal. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The system, as recited in <dependent-claim-reference depends_on="CLM-00004">claim 4</dependent-claim-reference>, wherein the input source is a computer. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The system, as recited in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the controller is remotely located from the plurality of actuators. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The system, as recited in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising: 
<claim-text>at least one sensor that detects an implementation state of at least one of the plurality of implementation units and provides the controller with the implementation state; and </claim-text>
<claim-text>an input source that provides an input signal to the controller, </claim-text>
<claim-text>wherein the controller generates the system goal based on the implementation state and the input signal. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The system, as recited in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the allocation parameter is predefined. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The system, as recited in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the allocation parameter is identity of the plurality of implementation modules under the control of the allocator. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The system, as recited in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the allocator partitions the system goal into the plurality of sub-goals based on the allocation parameter and a second allocation parameter, 
<claim-text>wherein the second allocation parameter is a location identifier for at least one of: 
<claim-text>the plurality of implementation units, and </claim-text>
<claim-text>the implementation modules. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The system, as recited in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the allocator partitions the system goal into the plurality of sub-goals based on the allocation parameter, a second allocation parameter and a third allocation parameter, 
<claim-text>wherein the second allocation parameter is a location identifier and the third allocation parameter is a weighting factor for at least one of: 
<claim-text>the plurality of implementation units, and </claim-text>
<claim-text>the implementation modules. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The system, as recited in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the allocator further includes a plurality of hierarchical allocation levels each of which include at least one module allocator that allocate the sub-goals. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. A method for allocating a system instruction to a plurality of actuators, comprising: 
<claim-text>grouping the plurality of actuators into a plurality of module actuators comprising at least one of a plurality of sub-module actuators and at least one of the plurality of actuators, wherein each of the plurality of sub-module actuators includes at least one of the plurality of actuators; </claim-text>
<claim-text>partitioning the system instruction into a plurality of sub-instructions for each of the plurality of module actuators based on at least one allocation parameter; </claim-text>
<claim-text>allocating each of the plurality of sub-instructions to at least one of the plurality of sub-module actuators if the module actuator includes the plurality of sub-module actuators; and </claim-text>
<claim-text>actuating the at least one of the plurality of actuators within the at least one sub-module actuator based on the sub-instructions, if the module actuator does not include the plurality of sub-module actuators. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00013-1">
<claim-text><highlight><bold>13</bold></highlight>. The method, as recited in <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, wherein the grouping step is based on a physical layout of the plurality of actuators. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The method, as recited in <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, further comprising: 
<claim-text>partitioning each of the plurality of sub-instructions into a plurality of second sub-instructions for each of the sub-module actuators; </claim-text>
<claim-text>determining if each of the plurality of sub-module actuators includes at least one second sub-module actuator; </claim-text>
<claim-text>allocating each of the plurality of second sub-instructions to the least one second sub-module actuators for each of the sub-module actuators determined to include the at least one second sub-module actuator; and </claim-text>
<claim-text>actuating at least one of the plurality of actuators disposed within the sub-module based on the second sub-instructions for each of the sub-module actuators determined not to include the at least one second sub-module actuator. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The method, as recited in <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference>, wherein the allocation parameter includes at least one of: 
<claim-text>the number of the plurality of sub-module actuators; and </claim-text>
<claim-text>the number of the plurality of module actuators. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. A method for allocating a desired goal to a plurality of actuators, comprising: 
<claim-text>establishing a plurality of allocation levels arranged in a hierarchical manner; and </claim-text>
<claim-text>for each allocation level: 
<claim-text>identifying the number of module allocators within the allocation level; and </claim-text>
<claim-text>for each module allocator: 
<claim-text>receiving an allocation goal that is at least one of the desired goal and a module actuation goal from one of the plurality of allocation levels that is higher in hierarchical order than the allocation level; and </claim-text>
<claim-text>identifying an allocation parameter for the module allocator; </claim-text>
<claim-text>generating the module actuation goal by partitioning the actuation goal based on the allocation parameter; </claim-text>
<claim-text>determining whether the allocation level is a bottom allocation level; </claim-text>
<claim-text>allocating the module actuation goal to one of the module allocators within one of the plurality of allocation levels that is lower in hierarchical order than the allocation level, if it determined that the allocation level is not the bottom allocation level; and </claim-text>
<claim-text>assigning the module actuation goal to at least one actuator of the array of actuators controlled by the module allocator if it is determined that the allocation level is the bottom allocation level. </claim-text>
</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The method, as recited in <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, wherein the number of module allocators identified in the identifying the number of module allocators step is predefined. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. A method for allocating a goal to a plurality of implementation units, comprising: 
<claim-text>grouping the implementation units into at least one group based on a first parameter; </claim-text>
<claim-text>dividing the at least one group into a plurality of sub-groups based on a second parameter; </claim-text>
<claim-text>allocating the goal to the at least one group based on dividing the goal into a plurality of sub-goals </claim-text>
</claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. A method for allocating a goal, comprising: 
<claim-text>receiving the goal; </claim-text>
<claim-text>obtaining an allocation parameter; </claim-text>
<claim-text>partitioning the goal into a plurality of sub-goals based on the allocation parameter; and </claim-text>
<claim-text>allocating the goal to at least one of a plurality of implementation units and a plurality of groups of the plurality of implementation units. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The method, as recited in <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference>, wherein the allocation parameter is predetermined. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The method, as recited in <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference>, wherein the allocation parameter is an indication of the number of groups of plurality of implementation units to which the goal is to be allocated. </claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The method, as recited in <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference>, wherein the obtaining step further comprises obtaining a second allocation parameter. </claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The method, as recited in <dependent-claim-reference depends_on="CLM-00022">claim 22</dependent-claim-reference>, wherein the second allocation parameter is a location identifier for at least one of the plurality of implementation units and the plurality of groups to which the goal is to be allocated. </claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The method, as recited in <dependent-claim-reference depends_on="CLM-00022">claim 22</dependent-claim-reference>, wherein the partitioning step further comprises partition the goal based on the allocation parameter and the second allocation parameter. </claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. The method, as recited in <dependent-claim-reference depends_on="CLM-00022">claim 22</dependent-claim-reference>, wherein: 
<claim-text>the obtaining step further comprises obtaining a third allocation parameter; and </claim-text>
<claim-text>the partitioning step further comprises partitioning the goal based on the allocation parameter, the second allocation parameter and the third allocation parameter. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. The method, as recited in <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>, wherein the third allocation parameter is a allocation weighting factor for at least one of the plurality of implementation units and the plurality of groups to which the goal is to be allocated.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>1</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030002447A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030002447A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030002447A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030002447A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030002447A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030002447A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030002447A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030002447A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030002447A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
