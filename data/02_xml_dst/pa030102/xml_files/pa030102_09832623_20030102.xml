<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005398A1-20030102-M00001.NB SYSTEM "US20030005398A1-20030102-M00001.NB" NDATA NB>
<!ENTITY US20030005398A1-20030102-M00001.TIF SYSTEM "US20030005398A1-20030102-M00001.TIF" NDATA TIF>
<!ENTITY US20030005398A1-20030102-M00002.NB SYSTEM "US20030005398A1-20030102-M00002.NB" NDATA NB>
<!ENTITY US20030005398A1-20030102-M00002.TIF SYSTEM "US20030005398A1-20030102-M00002.TIF" NDATA TIF>
<!ENTITY US20030005398A1-20030102-M00003.NB SYSTEM "US20030005398A1-20030102-M00003.NB" NDATA NB>
<!ENTITY US20030005398A1-20030102-M00003.TIF SYSTEM "US20030005398A1-20030102-M00003.TIF" NDATA TIF>
<!ENTITY US20030005398A1-20030102-M00004.NB SYSTEM "US20030005398A1-20030102-M00004.NB" NDATA NB>
<!ENTITY US20030005398A1-20030102-M00004.TIF SYSTEM "US20030005398A1-20030102-M00004.TIF" NDATA TIF>
<!ENTITY US20030005398A1-20030102-M00005.NB SYSTEM "US20030005398A1-20030102-M00005.NB" NDATA NB>
<!ENTITY US20030005398A1-20030102-M00005.TIF SYSTEM "US20030005398A1-20030102-M00005.TIF" NDATA TIF>
<!ENTITY US20030005398A1-20030102-M00006.NB SYSTEM "US20030005398A1-20030102-M00006.NB" NDATA NB>
<!ENTITY US20030005398A1-20030102-M00006.TIF SYSTEM "US20030005398A1-20030102-M00006.TIF" NDATA TIF>
<!ENTITY US20030005398A1-20030102-M00007.NB SYSTEM "US20030005398A1-20030102-M00007.NB" NDATA NB>
<!ENTITY US20030005398A1-20030102-M00007.TIF SYSTEM "US20030005398A1-20030102-M00007.TIF" NDATA TIF>
<!ENTITY US20030005398A1-20030102-M00008.NB SYSTEM "US20030005398A1-20030102-M00008.NB" NDATA NB>
<!ENTITY US20030005398A1-20030102-M00008.TIF SYSTEM "US20030005398A1-20030102-M00008.TIF" NDATA TIF>
<!ENTITY US20030005398A1-20030102-M00009.NB SYSTEM "US20030005398A1-20030102-M00009.NB" NDATA NB>
<!ENTITY US20030005398A1-20030102-M00009.TIF SYSTEM "US20030005398A1-20030102-M00009.TIF" NDATA TIF>
<!ENTITY US20030005398A1-20030102-M00010.NB SYSTEM "US20030005398A1-20030102-M00010.NB" NDATA NB>
<!ENTITY US20030005398A1-20030102-M00010.TIF SYSTEM "US20030005398A1-20030102-M00010.TIF" NDATA TIF>
<!ENTITY US20030005398A1-20030102-M00011.NB SYSTEM "US20030005398A1-20030102-M00011.NB" NDATA NB>
<!ENTITY US20030005398A1-20030102-M00011.TIF SYSTEM "US20030005398A1-20030102-M00011.TIF" NDATA TIF>
<!ENTITY US20030005398A1-20030102-M00012.NB SYSTEM "US20030005398A1-20030102-M00012.NB" NDATA NB>
<!ENTITY US20030005398A1-20030102-M00012.TIF SYSTEM "US20030005398A1-20030102-M00012.TIF" NDATA TIF>
<!ENTITY US20030005398A1-20030102-M00013.NB SYSTEM "US20030005398A1-20030102-M00013.NB" NDATA NB>
<!ENTITY US20030005398A1-20030102-M00013.TIF SYSTEM "US20030005398A1-20030102-M00013.TIF" NDATA TIF>
<!ENTITY US20030005398A1-20030102-D00000.TIF SYSTEM "US20030005398A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005398A1-20030102-D00001.TIF SYSTEM "US20030005398A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005398A1-20030102-D00002.TIF SYSTEM "US20030005398A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005398A1-20030102-D00003.TIF SYSTEM "US20030005398A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005398A1-20030102-D00004.TIF SYSTEM "US20030005398A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005398A1-20030102-D00005.TIF SYSTEM "US20030005398A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030005398A1-20030102-D00006.TIF SYSTEM "US20030005398A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030005398A1-20030102-D00007.TIF SYSTEM "US20030005398A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030005398A1-20030102-D00008.TIF SYSTEM "US20030005398A1-20030102-D00008.TIF" NDATA TIF>
<!ENTITY US20030005398A1-20030102-D00009.TIF SYSTEM "US20030005398A1-20030102-D00009.TIF" NDATA TIF>
<!ENTITY US20030005398A1-20030102-D00010.TIF SYSTEM "US20030005398A1-20030102-D00010.TIF" NDATA TIF>
<!ENTITY US20030005398A1-20030102-D00011.TIF SYSTEM "US20030005398A1-20030102-D00011.TIF" NDATA TIF>
<!ENTITY US20030005398A1-20030102-D00012.TIF SYSTEM "US20030005398A1-20030102-D00012.TIF" NDATA TIF>
<!ENTITY US20030005398A1-20030102-D00013.TIF SYSTEM "US20030005398A1-20030102-D00013.TIF" NDATA TIF>
<!ENTITY US20030005398A1-20030102-D00014.TIF SYSTEM "US20030005398A1-20030102-D00014.TIF" NDATA TIF>
<!ENTITY US20030005398A1-20030102-D00015.TIF SYSTEM "US20030005398A1-20030102-D00015.TIF" NDATA TIF>
<!ENTITY US20030005398A1-20030102-D00016.TIF SYSTEM "US20030005398A1-20030102-D00016.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005398</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09832623</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010411</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F009/45</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>716</class>
<subclass>008000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>TIMING-DRIVEN GLOBAL PLACEMENT BASED ON GEOMETRY-AWARE TIMING BUDGETS</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Jun-Dong</given-name>
<family-name>Cho</family-name>
</name>
<residence>
<residence-us>
<city>Millwood</city>
<state>NY</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>David</given-name>
<middle-name>S.</middle-name>
<family-name>Kung</family-name>
</name>
<residence>
<residence-us>
<city>Chappaqua</city>
<state>NY</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>Frank Chau</name-1>
<name-2>F. CHAU &amp; ASSOCIATES, LLP</name-2>
<address>
<address-1>Suite 501</address-1>
<address-2>1900 Hempstead Turnpike</address-2>
<city>East Meadow</city>
<state>NY</state>
<postalcode>11554</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A system and method for timing-closed placement which also takes wirelength and congestion into consideration. In one aspect, the system and method of timing driven placement according to the present invention incorporates a timing budget management technique which satisfies triangle parity and inequality, a timing-driven quadrisection placement strategy based on flexible timing window configurations to minimize the wirelength and congestion during each mincut quad-partition of top-down hierarchy, and a linear programming formulation incorporating bin capacity, channel capacity and congestion criticality. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> 1. Technical Field </paragraph>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> The present invention relates generally to a system and method for designing and placing circuitry on semiconductor chips, and more particularly, to a system and method for incorporating a timing-closed placement solution into a physical design process of integrated circuitry. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> 2. Description of the Related Art </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> The development of electronic manufacturing technology has created the ability to build thousands of circuits on a single chip. To take advantage of this technology, thousands of circuits must by physically placed and connected on the chip. This can be a very time-consuming process, especially when the actual process of designing, placing and connecting the circuits on the chip can affect the performance and timing requirements of the chip. Therefore, it has become necessary to automate the design process by using a computer to quickly place and wire predesigned circuits into a functional chip. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> The basic problem with this automation technique is that it sacrifices the performance of the resulting circuit for the ability to get a connected circuit in a reasonable amount of computing time. When the functional chip being designed is a central processing unit of a computer or other chip in which performance is critical and design complexity high, the performance sacrificed is not acceptable and the automation technique is not useful. This performance sacrifice usually manifests itself in the inability to obtain timing closure in complicated logic. Timing closure is the difference between the time allowed for processing information on the chip as logically designed, and the time required for processing information on the chip as physically designed. Timing closure is not met when the chip as physically wired and placed is not as fast as required by the logical design. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> With advances in VLSI technology, the size of modules in integrated circuits is becoming smaller and the density of modules on a chip is increasing. Consequently, intramodule delays are becoming smaller, and the total delay in the circuit is being dominated by delays in the interconnections between the modules. The communication-bounded nature of total circuit delay, along with more stringent timing requirements due to more aggressive design style, have made timing driven layout an important area of study. To meet the needs of a fast-expanding electronics industry, high performance chips must be designed in a short period. Accordingly, a design flow which incorporates timing analysis and verification into the physical design is desirable. This motivates the development of layout tools which optimize layout area and timing simultaneously. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> The problem of timing-driven placement has been studied extensively over recent years. Existing timing-driven approaches can be broadly classified into net-based methods and path-based methods. In a net-based algorithm, timing constraints are first translated into physical constraints, such as upper and lower bounds on the lengths of nets. More specifically, net-based algorithms try to satisfy timing constraints by (1) assigning higher weights to nets which are part of critical paths, or (2) by transforming timing requirements into a set of upper bounds on the net delays. In scenario (1), minimizing the delay in a critical net may increase the delay in other nets. This may result in additional critical paths and the delays of the nets in these paths also then have to be minimized. This again may result in an excessive delay in the previous critical net. It is desirable to prevent this oscillating effect. In scenario (2) above, delay constraints on the paths are translated into either length or timing lower and upper bounds (slacks) for each net. The bounds are then used to guide the placement and routing. Timing driven placement optimization will not shorten nets that are below the threshold, but nets near or above the threshold are very strongly weighted for improvement. A major problem of these approaches is the selection of the weights or bounds. Also, the use of individual net bounds may overconstrain the problem. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> Path-based methods consider timing requirements explicitly, and try to satisfy timing requirements and physical requirements simultaneously during the placement phase. A major difficulty encountered in path-based methods is the enormous complexity of computation. Path-based approaches overcome these difficulties via an optimization process which models the problem using paths instead of individual nets. The problem may be modeled as a linear programming or transforming the quadratic programming problem into a Lagrangian problem to reduce the number of constraints. However, this optimization process becomes very complex and time consuming in deep sub-micron designs. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> A legal (or feasible) solution to the timing-driven placement problem should satisfy the following placement constraints: (1) Macros should be placed at legitimate locations without overlapping, (2) there should be sufficient space to implement interconnections, (3) timing constraints should be satisfied for all logically possible paths in the circuit, (4) region constraints should be satisfied, i.e., some modules may be placed only in an certain regions, for example, (a) for movable I/O pins (input/output terminals): some I/O pins&apos; positions may be fixed, others may be assigned to any of the available I/O pads,(b) locations of some modules may already be fixed. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> An input to a timing-driven placement problem is a set of modules and a net list, where each module has a fixed shape and fixed terminal locations. The goal is to find the best position for each module on the chip according to appropriate cost functions. Timing driven placement incorporates timing objective functions into the placement problem. Nets that must satisfy timing requirements are called critical nets. In timing-driven placement, it is desirable to make critical nets timing-efficient and other nets length- and area-efficient. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> In a net-based timing-driven layout, timing requirements are usually first translated into physical requirements. Delay slacks correspond to budget wiring delays. Slack is the difference between the designed (logical) delay and the actual delay (after added wiring delay) from the wiring program. A positive slack implies that the current cycle-time is fulfilled by the physical layout (i.e., the net meets the design criteria), while a negative value indicates that the layout violates the timing conditions. In addition, a large positive value indicates that the cycle-time can be further improved. Hence, the goal in timing-driven layout is to maximize the min-slack. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> The delay budgeting problem seeks to allocate delay slacks before the placement and routing steps. Thus, as a result of delay budgeting, the performance-driven placement and routing steps are given net delay bounds. Since the delay slacks equate with wiring delay, it is natural to expect all nets to have positive slacks. Furthermore, the distribution of these slacks determines the difficulty of finding a feasible placement (and/or routing) solution. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> Excessive local congestion gives rise to future routing difficulty and also increases potential crosstalk noise in high-speed signal lines. Furthermore, it increases power dissipation due to coupling capacitance. In a timing analysis of a prerouting design, the routing of a net is usually assumed to be a minimal rectilinear Steiner tree. Due to the congestion, the capacitance (i.e., wirelength) of this routing tree is larger than the one with a minimal Steiner tree. Thus, we need to avoid the timing-critical nets from the congested areas. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> Existing timing-driven flows lead to unpredictable and suspicious timing results. Their main flaw is a lack of timing coverage which requires designers to spend days or even weeks iterating between synthesis and layout to achieve timing closure. Extremely complex deep submicron designs requires a new placement algorithm being completed with faster clocks. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> There have been many works in timing-driven placement in recent years. Recent results are mainly categorized as: A) Top-down hierarchical partitioning (slack-based), B) quadratic programming (path-based), and C) constructive approaches. </paragraph>
</section>
<section>
<heading lvl="1">A. Top-Down Hierarchical Partitioning </heading>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> In top-down hierarchical partitioning, the length of all interconnections are estimated provided that entire cells assigned to a partitioned region are located at the center of the region. Therefore, after each cut of a min-cut algorithm, a global routing is computed. See J. Garbers, B. Korte, H. J. Promel, E. Schwietzke, and A. Seger, VLSI-Placement Based on Routing and Timing Information, IEEE, 1990. This provides an expected net length for every net. These net lengths are subsequently used to perform a timing analysis. In particular, increasing the weight of some nets should lead to a shorter realization of these nets and thus should increase the minimum slack. In this algorithm, modules are not placed at upper levels of the mincut partitioning; the exact module placement is realized at the bottom of hierarchy. Thus, it is hardly guaranteed that the expected net length computed at each level of the hierarchy is consistent with the net length obtained by final placement. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> illustrates an exemplary conventional net-weight and mincut based placement approach. One example of this approach, hierarchical mincut-based partitioning, involves dividing a circuit into smaller parts, recursively. The object is to partition the circuit into parts such that the sizes of the partitions are within a prescribed range and the number of connections between components is minimized at each level of hierarchy. This results in minimizing the number of global wires and accordingly, maximizing the number of local wires, thus minimizing the total wirelength. During the partitioning, if module ml in partition <highlight><bold>100</bold></highlight> is moved to partition <highlight><bold>102</bold></highlight>, the result is an undesirable solution since the critical net C with its timing budget of 1 unit is on the cutline <highlight><bold>104</bold></highlight> and thus may span the entire chip region in a worst case scenario. On the other hand, if module m<highlight><bold>2</bold></highlight> is moved, then the timing budget of net D becomes over-weighted in a smaller wiring region. Therefore, there is a need for a more insightful timing budget management strategy. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> In M. Marek-Sadowska and S. P. Lin, &ldquo;Timing-Driven Placement&rdquo;, IEEE Conference, pp. 94-97, 1989, the timing-driven placement problem was formulated as a facility location problem, for example, for m old facilities located on a plane, locations of additional n-m new facilities are sought. The objective is to minimize the sum of weighted (net-weight based) rectilinear distances between them. Solutions to the problem produce placements of cells only at coordinates of the old facilities (for example, cells with fixed locations such as input/output (I/O) pads). In order to decompose cells into two partitions in the plane, fictitious terminals are added at the cutline that partitions the netlist into two equal-sized netlists. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> Usually, bi-partitioning and clustering-based partitioning approaches attempt to cluster critical nets in a local region so that most of the critical nets can reside in close proximity, but some critical paths can easily be divided into different partitions that span a timing-specifically unbounded routing region (i.e., a region where timing is not satisfied). In T. Koide, et al. &ldquo;A New Performance Driven Placement Method with the Elmore Delay Model for Row Based VLSIs&rdquo;, Hiroshima Univ. koide&commat;ecs.hiroshima-u.acjp, during 4-way partitioning, while moving the cell, slack gain is computed, and the cells connecting nets with large slack gains on the cutline may span the timing specifically unbounded routing region. To decrease the delay time of the paths, the cells are moved into clusters within a partition so that nets connecting the cells will span a smaller routing region. However, this method does not guarantee that the final layout of a net does not exceed the timing slack. </paragraph>
</section>
<section>
<heading lvl="1">B. Quadratic Programming </heading>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> Lagrangian relaxation offers an alternative to simulated annealing for controlling the tradeoff between the system cycle time and wirelength. A. Srinivasan, K. Chaudhary, and E. S. Kuh, &ldquo;RITUAL: A Performance-Driven Placement Algorithm&rdquo;, IEEE Trans. on Circuits and Systems II, Vol. 39, No. 11. pp. 825-840, Nov. 1992, presented such a mathematical programming approach such that the runtime is smaller than simulated annealing and the quality of the results are reasonable. However, issues like congestion analysis and routability factors are not considered. Routability constraints are among the most difficult because they are not analytical and are checked only by means of routing. This is a major reason why the routability constraints are not included into the mathematical programming formulations. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> Another technique involves an algorithm which uses an iterative approach. See A. Mathus and C. L. Liu, Compression-Realization: A New Approach to Timing-Driven Placement for Regular Architectures, IEEE TCAD, Vol. 16, No. 6, June 1997. In each iteration, there is a compression phase and a relaxation phase. The compression phase attempts to make the placement delay feasible by compressing the long paths that cause some of the primary output signals to arrive too late. However, the compression phase may produce an infeasible placement with some of the slots occupied by two modules. This allows the compression phase more flexibility, and often allows it to achieve the required decrease in delay. If an infeasible placement is produced in the compression phase (path-based), the relaxation phase (net-based), which carries out a timing-driven reconfiguration of the infeasible placement to produce a feasible solution, will be executed. Forming a slack neighborhood graph, the delays in the critical paths are guaranteed not to increase beyond a certain bound. It captures the freedom of movement of the modules, without &ldquo;violating the timing constraints.&rdquo; If the compression phase produces an infeasible placement, the original modules occupying the overcrowded slots need to be relocated. In the relaxation phase, relocation is carried out simultaneously for all of the modules in such a way that the delays do not increase by too much. The slack of an edge measures the amount by which the delay of the edge can be increased without violating any timing constraints. The slacks of the edges incident to a module determines the neighborhood within which the module can be moved without violating the timing requirements. In any iterative algorithm for placement, it is initially essential that the mobility of the modules be sufficiently high. This ensures that a bad initial placement does not cause the algorithm to get stuck in a high-cost local minimum. In order to prevent the mobility from being completely governed by the slacks, a relaxation parameter was introduced that allows the algorithm to increase the values of edge slacks which will be referred to as relaxed slacks. In order to incorporate a routability measure into the placement process, each edge of the slack neighborhood graph (SNG) is associated with a cost that measures the penalty, in terms of an increase in congestion, that results from the move associated with that edge. A reasonable measure of this penalty is a congestion gradient that measures the difference in congestion in different areas of the current placement. This approach tries to satisfy the timing constraints for most critical paths, but after spreading out the overlapped modules, it is not guaranteed that the final placement satisfies the timing constraints for entire critical nets. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> In most of these timing criticality-based approaches, some of the non-critical nets can turn into the critical nets due to the unbounded treatment for the wirelength of non-critical nets. In recent aggressive designs, most of the nets are critical and thus a priority-based approach may not be effective. </paragraph>
</section>
<section>
<heading lvl="1">C. Constructive Approaches </heading>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> A successive augmentation approach has also been proposed which adds one macro at a time to a partial placement until all macros are exhausted. There are two stages. The first technique involves adaptive changing of parameters according to evaluations of partial solutions. The second technique is carried out by an adaptive look-ahead procedure for improving global characteristics of the placement. The adaptive algorithm uses adaptation of parameters to handle a wider range of operating controls. A set of adjustable parameters such as a timing budget are used to control placement. This approach is effective when dynamic adjustment process can be realized in a reasonable amount of computation. However, this approach lacks global optimization. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> Another technique involves a constructive approach based on a path-delay timing window. See I. Lin and D. H. C. Du, &ldquo;Performance-Driven Constructive Placement&rdquo;, Design Automation Conference, pp. 103-106, 1990. This approach considered a path with a sequence of modules along the path. All modules in the path are bounded in a rectangle called a window to satisfy the timing requirement. Even if all modules are inside the region, a zig-zag routing may result. The basic idea is to define an area to guide the placement of the first module in the window such that the total interconnect delay can be minimized. The net constraints are used to reduce the placement constraints instead of directly using complete path constraints. Once a cell location is determined in a window, all associated paths are broken into two sub-paths. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> Previous works lacked the ability to deal with the timing constraints in terms of paths. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> For example, a timing driven placement method has been presented based on a path delay relaxation force (PDRF) method. The delay of a timing-critical path having a small timing margin is minimized by placing the cells on the path (called path core cells) at the center of gravity, and this process is performed for other path core cells. However, these approaches are only concerned with the timing-critical paths. The cells on the non-critical paths must be treated carefully since their placement may cause further timing problems in recent high performance designs. To deal with this problem, the net constraint driven placement can be utilized. However, the main problem with net constraints is that timing constraints are path based, hence net bounds are usually over-constraining, resulting in infeasible placements. As a result, methods of handling over-constrained net bounds have been proposed but usually rely on re-budgeting only after a physical design step (placement) is completed. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> Accordingly, there is a need for a system and method for a very large scale integration (VLSI) placement that efficiently increases production capacity of integrated circuits and accurately optimizes the integrated circuit design. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> The present invention is directed to a system and method for timing-closed placement which also takes wirelength and congestion into consideration. The system and method of timing driven placement according to the present invention incorporates a timing budget management technique which satisfies triangle parity and inequality, a timing-driven quadrisection placement strategy based on flexible timing window configurations to minimize the wirelength and congestion during each mincut quad-partition of top-down hierarchy, and a linear programming formulation incorporating bin capacity, channel capacity and congestion criticality. Advantageously, these features allow good timing-closed placement results to be achieved without excessive computation time, thus accelerating the sign-off-to-silicon cycle for customers and increasing production capacity. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> In an aspect of the present invention, a method for placing circuit elements on semiconductor chips is provided comprising the steps of: creating a circuit graph including cutlines, said circuit graph comprising said circuit elements connected by nets for placement on a placement grid; clustering critical nets in the circuit graph; assigning a timing budget for each net using at least one of a plurality of slack distribution algorithms satisfying at least one geometric constraint; partitioning the circuit graph using a mincut algorithm; generating a timing window region on the placement grid for each net which is less than or equal to each net&apos;s respective timing budget; and assigning the circuit elements attached to each net to each of their respective timing window regions. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> In another aspect of the present invention, a method for determining placement of circuit elements is provided comprising the steps of: describing a circuit image as a graph comprising circuit elements connected by edges; assigning a timing budget for each edge using a geometry-aware slack distribution algorithm which satisfies at least one geometric constraint; generating a timing window region on a placement grid for each edge, said timing window region being equal to or less than the timing budget for the respective edge; and assigning the circuit elements attached to each edge to each of their respective timing window regions. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> These and other aspects, features and advantages of the present invention will be described or become apparent from the following detailed description of the preferred embodiments, which is to be read in connection with the accompanying drawings. </paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> illustrates an exemplary conventional net-weight and mincut based placement approach. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> illustrates a preferred embodiment of a timing driven placement process with timing closure according to an aspect of the present invention. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> illustrates an exemplary circuit graph comprising nodes connected by edges having slack values. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4A</cross-reference> illustrates an exemplary placement of a slack-weighted circuit graph which has its slack modified to satisfy the triangle inequality rule and a parity rule according to an aspect of the present invention. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4B</cross-reference> illustrates an exemplary placement of a circuit graph which does not satisfy the triangle inequality rule. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> illustrates an exemplary slack-weighted circuit graph and a resulting feasible placement solution and an infeasible placement solution. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6A</cross-reference> depicts exemplary illustrations of rebudgeting where positive gains on the timing margins are realized. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6B</cross-reference> illustrates an exemplary circuit graph depicting variables to be used for rebudgetting while preserving triangle inequalities. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> FIGS. <highlight><bold>7</bold></highlight>A-<highlight><bold>7</bold></highlight>B are exemplary illustrations of rebudgeting results using geometry-aware slack distribution (rebudgetting) algorithms applied to the circuit graph of <cross-reference target="DRAWINGS">FIG. 3</cross-reference> according to an aspect of the present invention. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7C</cross-reference> illustrates an exemplary slack reassignment satisfying the triangle inequality rule according to an aspect of the present invention, where the slack is not rebudgetted. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> FIGS. <highlight><bold>8</bold></highlight>A-F illustrate an exemplary overall application of a method of module placement according to an aspect of the present invention. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9A</cross-reference> depicts another example of an initial circuit graph G&equals;(V, E) comprising node labels V (V&equals;1, 2, . . . , 8) attached by edges E. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9B</cross-reference> illustrates an exemplary placement grid having fixed labeling comprising bin and channel labels. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9C</cross-reference> illustrates an exemplary timing-driven partitioning of the circuit graph of <cross-reference target="DRAWINGS">FIG. 9A</cross-reference> into four quadrants based on a min-slack cut for maximizing resource balancing. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9D</cross-reference> illustrates an exemplary timing-closed placement of the modules and edges of <cross-reference target="DRAWINGS">FIG. 9A</cross-reference> onto the placement grid of FIG. B according to an aspect of the present invention </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> FIGS. <highlight><bold>10</bold></highlight>A-C illustrate exemplary steps of generating a timing window for level i considering timing windows generated in previous levels i&equals;1 and i&equals;2. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 11 A and 11B</cross-reference> illustrate exemplary formations of circuit graphs associated with a multiple-unit cell such that there are imaginery edges between two adjacent basic cells with a corresponding edge weight.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF PREFERRED EMBODIMENTS </heading>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> It is to be understood that the exemplary system modules and method steps described herein may be implemented in various forms of hardware, software, firmware, special purpose processors, or a combination thereof. Preferably, the present invention is implemented in software as an application program tangibly embodied on one or more program storage devices. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> The application program may be executed by any machine, device or platform comprising suitable architecture. It is to be further understood that, because some of the constituent system modules and method steps depicted in the accompanying Figures are preferably implemented in software, the actual connections between the system components (or the process steps) may differ depending upon the manner in which the present invention is programmed. Given the teachings herein, one of ordinary skill in the related art will be able to contemplate these and similar implementations or configurations of the present invention. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> A basic design model applicable to a timing-driven placement solution according to the present invention involves, for example, a microcell-library sea of gates technology which comprises the following features. A chip has a regular pattern of basic gates. Routing tracks in both directions are distributed between columns and rows and do not produce concentrated routing channels but require over-the-cell routing. This design style has a library of predesigned macrocells in drastically different sizes having varying heights and widths. The number of routing tracks available for inter-macrocell connections depends on the number of tracks utilized by intra-macrocell connections. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> illustrates a preferred embodiment of a timing driven placement process with timing closure according to an aspect of the present invention. Initially, in step <highlight><bold>201</bold></highlight> a circuit graph is created for later defining a timing budget window for each net on a placement grid. The circuit graph comprises, for example, modules (circuit elements) attached to each other by edges (nets), wherein some modules are partitioned by cutlines. The timing budget window is a timing-feasible rectangular area on the placement grid within which modules can be placed without violating a timing budget. Thus, the size of the placement grid affects timing accuracy. One timing slack unit corresponds to, for example, a width of a basic grid size. For example, a timing slack should be set to 1 or 2 if the placement grid forms a 2 by 2 array. In another example, the timing slack can be an integer value between 1 and 6 if the placement grid forms a 4 by 4 array (since a length of the diagonal of the 4 by 4 array is 6). </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> A multiple of the basic grid size can also be used as a grid size. In this case, a slack should be redistributed into its nearest (with lower slack) grid point. For example, if the size of a bin is 4 timing units, then the new slack value becomes:.  
<math-cwu id="MATH-US-00001">
<number>1</number>
<math>
<mrow>
  <mo>(</mo>
  <mfrac>
    <mrow>
      <mi>old</mi>
      <mo>-</mo>
      <mi>slack</mi>
      <mo>-</mo>
      <mi>value</mi>
    </mrow>
    <mn>4</mn>
  </mfrac>
  <mo>)</mo>
</mrow>
</math>
<mathematica-file id="MATHEMATICA-00001" file="US20030005398A1-20030102-M00001.NB"/>
<image id="EMI-M00001" wi="216.027" he="18.00225" file="US20030005398A1-20030102-M00001.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0054" lvl="7"><number>&lsqb;0054&rsqb;</number> Therefore, the finer (smaller) the grid, the greater the timing budget, and thus the greater the flexibility of placement for finding a feasible solution; however, the computation time is also increased. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> For instances where the grid size is more than one unit, a set of critical nets with small timing budgets are clustered into grid bins using a timing-driven clustering algorithm in a bottom-up clustering stage (step <highlight><bold>203</bold></highlight>). Timing-driven clustering involves clustering cells with nets so as to minimize the following function inside each cluster: </paragraph>
<paragraph lvl="0"><in-line-formula>f(cluster)&equals;timing budget/connectivity </in-line-formula></paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> This results in a timing-aware connectivity-based clustering, i.e., nets with a small timing budget will be clustered together into a subgraph having a higher connectivity (density). After finding a set of clusters of the same size, a cluster size corresponds to a grid size. Since the new grid size is larger than the basic (smallest) grid size, the number of components is decreased for future computation. Using this method with an appropriate bin size will be effective in order to reduce the computation time and to take advantage of clustered critical nets. </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> Next, an initial timing budget for each net is determined using a geometry-concerned slack distribution algorithm according to an aspect of the present invention, where the timing budget satisfies the triangle inequality rule and triangle parity (step <highlight><bold>205</bold></highlight>). </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> In step <highlight><bold>207</bold></highlight>, the circuit elements are divided into segments to minimize a number of global nets. Global nets are nets which span multiple segments. It is mandatory to use a partitioning approach as design complexity continues to increase. For example, the present invention preferably uses a multi-level graph partitioning mincut algorithm in step <highlight><bold>207</bold></highlight>. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> In step <highlight><bold>209</bold></highlight>, a timing window is generated within a placement grid based on one-bend global routing. The timing window is a rectangular area within which the modules can be placed without violating their timing budget. A one-bend global routing (a wire having one bend between modules) is preferable to, for example, a two-bend routing, since the more the number of bends, the more vias and thus, the more delays. </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> Next, the modules are assigned to their respective timing window regions on the placement grid (step <highlight><bold>211</bold></highlight>). Preferably, each module is assigned to a more general rather than specific bin on the placement grid. The exact placement of the modules are deferred to a lower level of hierarchy. This flexibility leads to a better mincut solution in the successive levels of hierarchy. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> To minimize congestion during the module assignment process, timing-feasible regions for each module are determined by selecting the region (or bin) which best distributes wires evenly over the cutlines. </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> The larger the size of the timing windows, the greater the probability of finding a feasible solution (i.e., a solution which reduces the possibility of cell overlaps), and thus, the more flexibility of reducing the total wirelength during top-down partitioning hierarchy. In addition, straight connections between the modules are desirable to reduce the possibility of congestions (cell/module overlap) and the number of bends. Thus, the objective is to maximize the timing window sizes and the number of straight-line connections. </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> Following module assignment, it is ascertained whether the recursive top-down partitioning is finished, i.e., whether all levels of the top down hierarchy have been processed and all modules in the circuit graph are assigned (step <highlight><bold>212</bold></highlight>). If not, the system goes to the next level of hierarchy and repeats the process starting from step <highlight><bold>207</bold></highlight> again. </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> If the top-down recursion is finished, it is then ascertained whether the module assignments are legal, i.e., whether the module capacity of each bin is not exceeded (step <highlight><bold>213</bold></highlight>). If yes, then the process ends (step <highlight><bold>217</bold></highlight>). Otherwise, a module relocation technique is executed (step <highlight><bold>215</bold></highlight>). The above steps of the overall method will now be described in more detail below. </paragraph>
</section>
<section>
<heading lvl="1">I. Net Delay Model and Slack Redistribution </heading>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> It is desirable to determine the initial timing budget for each module before synthesis since good initial timing-budgeting should shorten the number of resynthesis iterations and thus speed up the entire design process. For example, initially, the total timing slack (budget) in the path can be distributed equally over the nets in each path. If a path does not meet its constraint, all the nets in the path are targeted for improvement until the path as a whole falls below a threshold constraint. </paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> In a budget refinement problem, paths may have positive or negative slacks as a result of a given placement. Since the budgeting results are heuristic in nature and may be overtight (i.e., overly constraining), it is necessary to provide a method by which the budgeting algorithm can adjust the timing budget based on, for example, information on results from a failed placement. Given a directed acyclic graph with timing constraints, the object of budget management is to assign to each vertex an incremental delay such that the total sum of these delays is maximized without violating given constraints. A maximum effective budget can maximize the flexibility and freedom all signal nets can have during layout while keeping within the timing constraints, which is desirable for most placers and routers. </paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> illustrates an exemplary circuit graph comprising nodes <highlight><bold>301</bold></highlight> connected by edges or nets <highlight><bold>303</bold></highlight> having slack values <highlight><bold>305</bold></highlight>. The total slack here (does not include values for the dotted line) is for example, 18. A timing analysis as illustrated, for example, in Youssef, E. Shragowiz, and L. C. Bening, &ldquo;Critical path issue in VLSI designs,&rdquo; in Proc. Int. Conf. on Computer-Aided Design, pp. 520-523, 1989, can be performed to identify a set of critical nets. A critical net is a net which belongs to at least one critical path. A net weight is set proportional to the frequency of appearance of a critical net in a set of critical paths. The net weights are then used to weigh the driving strength of the nets. Weight implies a measure of priority, and a smaller timing budget implies critical nets. Therefore, a critical net will be characterized by a higher value on the timing weight and a lower value on a budget. </paragraph>
<paragraph id="P-0068" lvl="0"><number>&lsqb;0068&rsqb;</number> The critical path of a very large circuit contains a hundred-pin net, which causes more than 50% of the entire maximum path delay. As seen from an Elmore delay model, one long wire in a multi-terminal net will affect the delay of the entire net. Therefore, it is desirable to put special emphasis on reducing the lengths of nets with high numbers of pins (terminals). Thus, a lower timing budget is assigned in proportion to a greater number of terminals of the net. </paragraph>
<paragraph id="P-0069" lvl="0"><number>&lsqb;0069&rsqb;</number> The most critical net may contain a buffer chain and/or drives large fanouts. Therefore, the criticality (i.e., timing budget) of net i, &tgr;(i), in path j is measured as follows:  
<math-cwu id="MATH-US-00002">
<number>2</number>
<math>
<mrow>
  <mrow>
    <mrow>
      <mi>&tau;</mi>
      <mo>&af;</mo>
      <mrow>
        <mo>(</mo>
        <mi>i</mi>
        <mo>)</mo>
      </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
      <mrow>
        <mi>&tau;</mi>
        <mo>&af;</mo>
        <mrow>
          <mo>(</mo>
          <mi>j</mi>
          <mo>)</mo>
        </mrow>
      </mrow>
      <mo>&times;</mo>
      <mrow>
        <mo>(</mo>
        <mrow>
          <mn>1</mn>
          <mo>-</mo>
          <mfrac>
            <mrow>
              <mi>a</mi>
              <mo>&it;</mo>
              <mstyle>
                <mtext>&emsp;</mtext>
              </mstyle>
              <mo>&it;</mo>
              <mrow>
                <mi>&eta;</mi>
                <mo>&af;</mo>
                <mrow>
                  <mo>(</mo>
                  <mi>i</mi>
                  <mo>)</mo>
                </mrow>
              </mrow>
              <mo>&times;</mo>
              <mi>&beta;</mi>
              <mo>&it;</mo>
              <mstyle>
                <mtext>&emsp;</mtext>
              </mstyle>
              <mo>&it;</mo>
              <mrow>
                <mi>&varphi;</mi>
                <mo>&af;</mo>
                <mrow>
                  <mo>(</mo>
                  <mi>i</mi>
                  <mo>)</mo>
                </mrow>
              </mrow>
            </mrow>
            <mrow>
              <munderover>
                <mo>&Sum;</mo>
                <mrow>
                  <mi>k</mi>
                  <mo>=</mo>
                  <mn>1</mn>
                </mrow>
                <mrow>
                  <mi>n</mi>
                  <mo>&af;</mo>
                  <mrow>
                    <mo>(</mo>
                    <mi>j</mi>
                    <mo>)</mo>
                  </mrow>
                </mrow>
              </munderover>
              <mo>&it;</mo>
              <mrow>
                <mi>a</mi>
                <mo>&it;</mo>
                <mstyle>
                  <mtext>&emsp;</mtext>
                </mstyle>
                <mo>&it;</mo>
                <mrow>
                  <mi>&eta;</mi>
                  <mo>&af;</mo>
                  <mrow>
                    <mo>(</mo>
                    <mi>&kappa;</mi>
                    <mo>)</mo>
                  </mrow>
                </mrow>
                <mo>&times;</mo>
                <mi>&beta;</mi>
                <mo>&it;</mo>
                <mstyle>
                  <mtext>&emsp;</mtext>
                </mstyle>
                <mo>&it;</mo>
                <mrow>
                  <mi>&varphi;</mi>
                  <mo>&af;</mo>
                  <mrow>
                    <mo>(</mo>
                    <mi>&kappa;</mi>
                    <mo>)</mo>
                  </mrow>
                </mrow>
              </mrow>
            </mrow>
          </mfrac>
        </mrow>
        <mo>)</mo>
      </mrow>
    </mrow>
  </mrow>
  <mo>,</mo>
</mrow>
</math>
<mathematica-file id="MATHEMATICA-00002" file="US20030005398A1-20030102-M00002.NB"/>
<image id="EMI-M00002" wi="216.027" he="29.9943" file="US20030005398A1-20030102-M00002.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0070" lvl="7"><number>&lsqb;0070&rsqb;</number> where is &tgr;(j) is total-timing-budget of path j, n(i) the number of nets in a path i, &eegr;(i) is the multiplicity of net i and &phgr;(i) is the frequency factor associated with net i. Here, &agr; and &bgr; are the relative weights between &eegr;(i) and &phgr;(i) such that &agr;&plus;&bgr;&equals;1. The delay budget s (e) on an edge e can be transformed on the wirelength l (e) by using the Elmore delay model, R<highlight><subscript>d</subscript></highlight>(cl(e)&plus;C<highlight><subscript>L</subscript></highlight>)&plus;1/2crl(e)<highlight><superscript>2</superscript></highlight>&plus;rl(e)C<highlight><subscript>L</subscript></highlight>&equals;s(e), where R<highlight><subscript>d </subscript></highlight>is the driver resistance, C<highlight><subscript>L </subscript></highlight>is the load capacitance, and c and r is the unit capacitance and resistance respectively. </paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> After slacks are generated, slack redistribution is performed by initially determining a maximum effective slack for each path segment. This can be done by: 1) computing all slacks, and 2) distributing the slacks along the path segment based on the criticality measures; i.e., a net with a higher criticality measure will have a lower timing budget. For example, a net (edge) shared by two different paths is assigned a lower timing budget than a net which is part of a single path. The above two steps are repeated until there are no positive slacks on any nodes. </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> A set of critical nets can be identified either prior to module placement (static method) or during module placement (dynamic method). In a static method, the set of controlled critical nets does not change during the layout process. Preferably, instead of using the time-consuming dynamic method, the method of the present invention adopts a static timing budget management technique which uses a lookahead function to determine a feasible placement. </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> To ensure that a final module placement results in a feasible solution in terms of timing constraints while simultaneously minimizing wirelengths, the placement satisfying the timing budget is realized by careful treatment for instances where a circuit includes cycles in its corresponding circuit graph. Since wires are connected rectilinearly, the following triangle parity inequality rule must be satisfied prior to placement: </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>P</italic></highlight>(w<highlight><subscript>i</subscript></highlight><highlight><italic>&plus;w</italic></highlight><highlight><subscript>j</subscript></highlight>)&equals;<highlight><italic>P</italic></highlight>(w<highlight><subscript>k</subscript></highlight>), &forall;<highlight><italic>i, j, k&egr;C </italic></highlight>of <highlight><italic>G, </italic></highlight></in-line-formula></paragraph>
<paragraph id="P-0074" lvl="7"><number>&lsqb;0074&rsqb;</number> where P (w<highlight><subscript>i</subscript></highlight>) is the weight parity (i.e., edge weight is even or odd) of edge i with its weight w<highlight><subscript>i</subscript></highlight>, and C is a cycle in the graph G. Equivalently, if (w<highlight><subscript>i</subscript></highlight>&plus;w<highlight><subscript>j</subscript></highlight>)mod<highlight><bold>2</bold></highlight> &equals;w<highlight><subscript>k</subscript></highlight>mod<highlight><bold>2</bold></highlight>, then P (w<highlight><subscript>i</subscript></highlight>&plus;w<highlight><subscript>j</subscript></highlight>)&equals;P (W<highlight><subscript>k</subscript></highlight>). To have one-bend routing for every net in a cycle, every cycle of length three (referred to as a 3-cycle) should comply with the triangle inequality rule. Otherwise, a placement problem will result in which the timing budget will not be satisfied. The triangle property of an undirected cycle is a property that a complete weighted cycle satisfies s(u, v)&lE;s(u, w)&plus;s(w, v) for all vertices u, v, w, where s(i, j) is the timing slack (margin) for the net connecting two cells i and j. This holds for any graph representing points in both Euclidean and rectilinear (Manhattan) metric space, for example, a placement graph. Therefore, both the triangle inequality rule and a parity rule should be met for satisfying timing constraints. </paragraph>
<paragraph id="P-0075" lvl="0"><number>&lsqb;0075&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4A</cross-reference> illustrates an exemplary placement of a slack-weighted circuit graph which has its slack modified to satisfy the triangle inequality rule and a parity rule according to an aspect of the present invention. Circuit graph <highlight><bold>401</bold></highlight> is an exemplary cycle of length three which is not feasible for placement due to its edges having weights which do not satisfy the triangle inequality rule or the parity rule. The parity rule involves an integer quality (i.e., whether an edge weight is an odd or even number). For example, for the parity rule to be satisfied in a 3 cycle circuit graph, adding any two edges should result in a number which has a same parity/quality (i.e., odd or even) as the third edge. In addition, the triangle inequality rule is not satisfied in <highlight><bold>401</bold></highlight>. To satisfy the triangle inequality rule (which applies only to 3 cycle graphs), when the weights of any two edges are added, their sum should be greater than or equal to a weight of the third edge. </paragraph>
<paragraph id="P-0076" lvl="0"><number>&lsqb;0076&rsqb;</number> Circuit graph <highlight><bold>403</bold></highlight> is an exemplary cycle of length three which satisfies both the triangle inequality rule and the parity rule, and is thus feasible for placement. The triangle inequality rule is satisfied since the sum of any two edges in <highlight><bold>401</bold></highlight> is greater than or equal to the third edge. For example, the sum of the values of edges a-b and b-c (which is 4) is greater than the value of the edge a-c (which is 2). To illustrate the satisfaction of the parity rule in graph <highlight><bold>403</bold></highlight>, if the values of edges a-c and a-b are added (2&plus;1), they will equal an odd number (3) which is a same parity as the third edge b-c (also an odd number). </paragraph>
<paragraph id="P-0077" lvl="0"><number>&lsqb;0077&rsqb;</number> Placement graph <highlight><bold>405</bold></highlight> illustrates an exemplary rectilinear-wired placement of circuit graph <highlight><bold>403</bold></highlight> using one-bend routing. For example, there is one-bend <highlight><bold>406</bold></highlight> in the wire between nodes b and c. One-bend routing is preferable for placement since it results in a shortest path and thus a shorter wirelength. The circuit graph <highlight><bold>403</bold></highlight> can also be placed using two-bend routing (<highlight><bold>407</bold></highlight>). However, it is very time-consuming to formulate the two-bend routing in Linear Programming. Furthermore, the more bends, the greater the wirelength and detours and thus the more delays. Thus, two-bend interconnections between modules are preferably avoided, if possible. </paragraph>
<paragraph id="P-0078" lvl="0"><number>&lsqb;0078&rsqb;</number> However, there are cases where two-bend routing must be used. <cross-reference target="DRAWINGS">FIG. 4B</cross-reference> illustrates an exemplary placement of a circuit graph which does not satisfy the triangle inequality rule. Circuit graph <highlight><bold>410</bold></highlight> is infeasible since it does not satisfy either the triangle inequality of parity rules. Note that the weight of an edge (b,c) in graph <highlight><bold>410</bold></highlight> should be set to less than 3 to hold the triangle inequality property of placement. Circuit graph <highlight><bold>412</bold></highlight> satisfies a triangle parity rule, and thus is feasible for placement. However, in this case, we need to two-bend wire for the edge (b,c) as shown in placement graphs <highlight><bold>414</bold></highlight> and <highlight><bold>416</bold></highlight>. If a legal solution satisfying channel capacity constraints cannot be found with one-bend routing, than two-bend wires are permitted to be used. </paragraph>
<paragraph id="P-0079" lvl="0"><number>&lsqb;0079&rsqb;</number> It is important to note that in both <cross-reference target="DRAWINGS">FIGS. 4A and 4B</cross-reference>, during placement, the triangle inequality must be satisfied. <cross-reference target="DRAWINGS">FIG. 5</cross-reference> illustrates an exemplary slack-weighted circuit graph <highlight><bold>501</bold></highlight> and resulting feasible and infeasible placement solutions. Graph <highlight><bold>501</bold></highlight> comprises three cycles (a, b,c), (b,c,d) and (b,d,e) and a cutline <highlight><bold>503</bold></highlight> for partitioning the modules d and e from a, c and b during placement. Edges c,b and b,d include upper and lower bounds of a timing budget. It is desirable to maintain the triangle inequality for each cycle during placement, while the original slack values of each edge can be used to provide wiring flexibility. </paragraph>
<paragraph id="P-0080" lvl="0"><number>&lsqb;0080&rsqb;</number> Placement <highlight><bold>507</bold></highlight> represents an exemplary placement of modules b,c,d,e of graph <highlight><bold>501</bold></highlight> using a lookahead timing budgeting of edge b,c in which the triangle inequality property is satisfied during placement. Placement cutline <highlight><bold>507</bold></highlight> is analogous to the cutline <highlight><bold>503</bold></highlight> for partitioning the modules b,c and e,d in different partitions. Placement <highlight><bold>507</bold></highlight> results in a timing-legal placement for module a. Placement <highlight><bold>510</bold></highlight> illustrates an exemplary infeasible placement solution where the triangle inequality rule is not satisfied during placement. Here, there is no feasible placement for module a which would satisfy the timing constraints given in graph <highlight><bold>501</bold></highlight>. </paragraph>
<paragraph id="P-0081" lvl="0"><number>&lsqb;0081&rsqb;</number> Given a directed graph with timing and geometric (triangle inequality and parity) constraints, the object of budget management according to an aspect of the present invention is to assign to each node an incremental delay such that the total sum of these slack delays is maximized without violating given constraints. A maximum effective budget advantageously increases the flexibility and freedom of all signal nets during layout while keeping within the timing constraints. Initially, an optimal algorithm for budget management is used to identify the edges that have initial slack values which need to be reduced or transferred. Then, a rebudgetting strategy is employed to maximize the total slack values. </paragraph>
<paragraph id="P-0082" lvl="0"><number>&lsqb;0082&rsqb;</number> To compute the timing budget assignment complying with the triangle inequality rule and timing (path) constraints (referred to as Triangle-based Rebudgetting) according to an aspect of the present invention, either of the following algorithms can be applied: 1) Geometry-constrained Slack Reassignment, or 2) Geometry-constrained Rebudgetting. The first algorithm does not allow for a net to increase its originally assigned timing margins, but only to reduce their values, while satisfying triangle inequality for every cycle. The second algorithm aims to maximize the total timing margins while preserving the triangle inequalities. Thus, in the second algorithm, timing margins assigned to nets are allowed to be increased. </paragraph>
<paragraph id="P-0083" lvl="0"><number>&lsqb;0083&rsqb;</number> The basic idea of the first algorithm is to build a spanning tree from a graph where during the tree construction, edge weights are checked and updated (re-assigned) to satisfy both triangle inequality and triangle parity. Basically, in Timing Budget Reassignment, Deque(Q) is to extract the cheapest (lowest weighted) edge (u, v) in a graph G from a priority queue Q, and Enque (Q, s(u, w)) is to insert a new value s(u, w) to Q. </paragraph>
<paragraph id="P-0084" lvl="7"><number>&lsqb;0084&rsqb;</number> The overall Timing Budget Reassignment algorithm is as follows: </paragraph>
<paragraph id="P-0085" lvl="7"><number>&lsqb;0085&rsqb;</number> Geometry-Constrained Slack Reassignment (GSRA): </paragraph>
<paragraph id="P-0086" lvl="0"><number>&lsqb;0086&rsqb;</number> Until Q is empty, </paragraph>
<paragraph id="P-0087" lvl="2"><number>&lsqb;0087&rsqb;</number> 1. s(u, v)&equals;Deque(Q); </paragraph>
<paragraph id="P-0088" lvl="2"><number>&lsqb;0088&rsqb;</number> 2. If the edge (u, v) is incident to another edge (v, w) that is already traversed and they both form a cycle with another edge (u, w) (that has not yet been traversed) in G and s(u, w)&gE;s(v, w)&plus;s(u, v), then the following is set: s(u, w)&equals;s(v, w)&plus;s(u, v) and Enque (Q, s(u, w)); </paragraph>
<paragraph id="P-0089" lvl="2"><number>&lsqb;0089&rsqb;</number> 3. If the edge (u, v) is incident to another edge (v, w) that is already traversed and they both form a cycle with another edge (u, w) (that has not yet been traversed) in G and s (u, w)&lE;s (v, w)&plus;s (u, v) and s (u, w)mod<highlight><bold>2</bold></highlight>&ne;(s(v, w)&plus;s(u, v))mod<highlight><bold>2</bold></highlight>, then the following is set: s(u,w)&equals;s(u, w)&minus;1 and Enque(Q, s(u, w)); </paragraph>
<paragraph id="P-0090" lvl="2"><number>&lsqb;0090&rsqb;</number> 4. If the edge (u, v) is incident to another edge (v, w) traversed so far and there is no edge (u, w) in G, then a dummy edge (u, w) is added to the graph G and the following is set: s(u, w)&equals;s(v, w)&plus;s(u, v) and Enque(Q, s(u,w)); </paragraph>
<paragraph id="P-0091" lvl="2"><number>&lsqb;0091&rsqb;</number> 5. If the edge (u, v) creates a cycle with two edges, s(v, w) and s(u, w) already traversed in G, then the following is set: s(u, v)&equals;s(v, w)&plus;s(u, w) and Enque(Qs(u, v)); </paragraph>
<paragraph id="P-0092" lvl="0"><number>&lsqb;0092&rsqb;</number> At each step in the above algorithm, a cheapest edge is selected. A cycle-completing edge is more expensive than any previously added edge, thus the edge weight can be updated to satisfy the triangle inequality rule without changing other edges in the cycle that have already been traversed. The above algorithm for Budget Reassignment takes at most O(&verbar;E&verbar;log&verbar;E&verbar;&plus;&verbar;N&verbar;<highlight><superscript>2</superscript></highlight>) amount of time, where &verbar;E&verbar; is the number of edges and &verbar;N&verbar; is the number of nodes in the graph. </paragraph>
<paragraph id="P-0093" lvl="0"><number>&lsqb;0093&rsqb;</number> Given an initial budget assignment, when budget increases on some edges are not allowed, the Timing Budget Re-assignment algorithm finds an optimal solution for incremental budget assigning such that every cycle in the graph satisfies the triangle inequality rule. </paragraph>
<paragraph id="P-0094" lvl="0"><number>&lsqb;0094&rsqb;</number> It may be necessary to minimize the amount of timing budget updating through the timing budget assignment algorithm since it results in a tighter timing budget, and thus, there will be less possibility of finding a legal timing-driven placement solution. avoid reducing the total timing budgets, the following rebudgetting strategy can be used: </paragraph>
<paragraph id="P-0095" lvl="2"><number>&lsqb;0095&rsqb;</number> Rebudgetting is a labeling of the node r:V&rarr;Z, where Z is the set of integers. The rebudgetting label r(v) for a node v represents the amount of timing slacks moved from its output toward its inputs. The weight of an edge (u,v) after rebudgetting is denoted by: </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>s</italic></highlight>&prime;(<highlight><italic>u, v</italic></highlight>)&equals;<highlight><italic>s</italic></highlight>(<highlight><italic>u, v</italic></highlight>)&plus;<highlight><italic>r</italic></highlight>(<highlight><italic>v</italic></highlight>)&minus;<highlight><italic>r</italic></highlight>(<highlight><italic>u</italic></highlight>) </in-line-formula></paragraph>
<paragraph id="P-0096" lvl="7"><number>&lsqb;0096&rsqb;</number> Let the total timing slacks of a circuit after rebudgetting be denoted by  
<math-cwu id="MATH-US-00003">
<number>3</number>
<math>
<mrow>
  <mrow>
    <mi>S</mi>
    <mo>&af;</mo>
    <mrow>
      <mo>(</mo>
      <msup>
        <mi>G</mi>
        <mi>&prime;</mi>
      </msup>
      <mo>)</mo>
    </mrow>
  </mrow>
  <mo>=</mo>
  <mrow>
    <munder>
      <mo>&Sum;</mo>
      <mi>e</mi>
    </munder>
    <mo>&it;</mo>
    <mrow>
      <mrow>
        <msup>
          <mi>s</mi>
          <mi>&prime;</mi>
        </msup>
        <mo>&af;</mo>
        <mrow>
          <mo>(</mo>
          <mi>e</mi>
          <mo>)</mo>
        </mrow>
      </mrow>
      <mo>.</mo>
    </mrow>
  </mrow>
</mrow>
</math>
<mathematica-file id="MATHEMATICA-00003" file="US20030005398A1-20030102-M00003.NB"/>
<image id="EMI-M00003" wi="216.027" he="19.93005" file="US20030005398A1-20030102-M00003.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0097" lvl="7"><number>&lsqb;0097&rsqb;</number> The maximum rebudgetting problem can be stated as maximizing <highlight><superscript>S(G&prime;)</superscript></highlight>, subject to timing constraints. One can rewrite:  
<math-cwu id="MATH-US-00004">
<number>4</number>
<math>
<mrow>
  <mrow>
    <mi>S</mi>
    <mo>&af;</mo>
    <mrow>
      <mo>(</mo>
      <msup>
        <mi>G</mi>
        <mi>&prime;</mi>
      </msup>
      <mo>)</mo>
    </mrow>
  </mrow>
  <mo>=</mo>
  <mrow>
    <mrow>
      <munder>
        <mo>&Sum;</mo>
        <mi>e</mi>
      </munder>
      <mo>&it;</mo>
      <mrow>
        <mo>(</mo>
        <mrow>
          <mrow>
            <mi>s</mi>
            <mo>&af;</mo>
            <mrow>
              <mo>(</mo>
              <mi>e</mi>
              <mo>)</mo>
            </mrow>
          </mrow>
          <mo>+</mo>
          <mrow>
            <mi>r</mi>
            <mo>&af;</mo>
            <mrow>
              <mo>(</mo>
              <mi>v</mi>
              <mo>)</mo>
            </mrow>
          </mrow>
          <mo>-</mo>
          <mrow>
            <mi>r</mi>
            <mo>&af;</mo>
            <mrow>
              <mo>(</mo>
              <mi>u</mi>
              <mo>)</mo>
            </mrow>
          </mrow>
        </mrow>
        <mo>)</mo>
      </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
      <mrow>
        <mi>S</mi>
        <mo>&af;</mo>
        <mrow>
          <mo>(</mo>
          <mi>G</mi>
          <mo>)</mo>
        </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
        <munder>
          <mo>&Sum;</mo>
          <mi>v</mi>
        </munder>
        <mo>&it;</mo>
        <mrow>
          <mo>(</mo>
          <mrow>
            <mrow>
              <mrow>
                <mo>&LeftBracketingBar;</mo>
                <mrow>
                  <mi>FI</mi>
                  <mo>&af;</mo>
                  <mrow>
                    <mo>(</mo>
                    <mi>v</mi>
                    <mo>)</mo>
                  </mrow>
                </mrow>
                <mo>&RightBracketingBar;</mo>
              </mrow>
              <mo>-</mo>
              <mrow>
                <mrow>
                  <mo>&LeftBracketingBar;</mo>
                  <mrow>
                    <mi>FO</mi>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>(</mo>
                      <mi>v</mi>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                  <mo>&RightBracketingBar;</mo>
                </mrow>
                <mo>&it;</mo>
                <mrow>
                  <mi>r</mi>
                  <mo>&af;</mo>
                  <mrow>
                    <mo>(</mo>
                    <mi>v</mi>
                    <mo>)</mo>
                  </mrow>
                </mrow>
              </mrow>
            </mrow>
            <mo>,</mo>
          </mrow>
        </mrow>
      </mrow>
    </mrow>
  </mrow>
</mrow>
</math>
<mathematica-file id="MATHEMATICA-00004" file="US20030005398A1-20030102-M00004.NB"/>
<image id="EMI-M00004" wi="216.027" he="19.93005" file="US20030005398A1-20030102-M00004.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0098" lvl="7"><number>&lsqb;0098&rsqb;</number> where &verbar;<highlight><superscript>FI(v)</superscript></highlight>&verbar; and &verbar;<highlight><superscript>FO(v)&verbar;</superscript></highlight> are the number of fanins and fanouts of node v. The maximum rebudgetting problem can then be formulated as the following linear program. </paragraph>
<paragraph id="P-0099" lvl="7"><number>&lsqb;0099&rsqb;</number> Minimize:  
<math-cwu id="MATH-US-00005">
<number>5</number>
<math>
<mrow>
  <mrow>
    <munder>
      <mo>&Sum;</mo>
      <mi>v</mi>
    </munder>
    <mo>&it;</mo>
    <mrow>
      <mrow>
        <mo>(</mo>
        <mrow>
          <mrow>
            <mo>&LeftBracketingBar;</mo>
            <mrow>
              <mi>FO</mi>
              <mo>&af;</mo>
              <mrow>
                <mo>(</mo>
                <mi>v</mi>
                <mo>)</mo>
              </mrow>
            </mrow>
            <mo>&RightBracketingBar;</mo>
          </mrow>
          <mo>-</mo>
          <mrow>
            <mo>&LeftBracketingBar;</mo>
            <mrow>
              <mi>FI</mi>
              <mo>&af;</mo>
              <mrow>
                <mo>(</mo>
                <mi>v</mi>
                <mo>)</mo>
              </mrow>
            </mrow>
            <mo>&RightBracketingBar;</mo>
          </mrow>
        </mrow>
        <mo>)</mo>
      </mrow>
      <mo>&it;</mo>
      <mrow>
        <mi>r</mi>
        <mo>&af;</mo>
        <mrow>
          <mo>(</mo>
          <mi>v</mi>
          <mo>)</mo>
        </mrow>
      </mrow>
    </mrow>
  </mrow>
  <mo>,</mo>
</mrow>
</math>
<mathematica-file id="MATHEMATICA-00005" file="US20030005398A1-20030102-M00005.NB"/>
<image id="EMI-M00005" wi="216.027" he="19.93005" file="US20030005398A1-20030102-M00005.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0100" lvl="7"><number>&lsqb;0100&rsqb;</number> Subject to: </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>s</italic></highlight>(<highlight><italic>u, v</italic></highlight>)&plus;<highlight><italic>r</italic></highlight>(<highlight><italic>v</italic></highlight>)&minus;<highlight><italic>r</italic></highlight>(<highlight><italic>u</italic></highlight>)&gE;0 </in-line-formula></paragraph>
<paragraph id="P-0101" lvl="0"><number>&lsqb;0101&rsqb;</number> The objective function above represents the timing margin gains added to the rebudgetted circuit in relation to the original circuit. The constraint ensures that the s(e) for each edge e after rebudgetting is non-negative. This is referred to as a positive slack constraint. </paragraph>
<paragraph id="P-0102" lvl="0"><number>&lsqb;0102&rsqb;</number> The maximum rebudgetting problem can be reduced to the minimum cost network flow problem. Each edge (u,v) can be regarded as a network flow arc having infinite capacity and cost s(u,v) per unit of flow. The goal of the linear programming problem given asks that each edge is assigned a non-negative flow f(u,v) such that: </paragraph>
<paragraph id="P-0103" lvl="7"><number>&lsqb;0103&rsqb;</number> Maximize:  
<math-cwu id="MATH-US-00006">
<number>6</number>
<math>
<mrow>
  <munder>
    <mo>&Sum;</mo>
    <mrow>
      <mo>(</mo>
      <mrow>
        <mi>u</mi>
        <mo>,</mo>
        <mi>v</mi>
      </mrow>
      <mo>)</mo>
    </mrow>
  </munder>
  <mo>&it;</mo>
  <mrow>
    <mrow>
      <mi>s</mi>
      <mo>&af;</mo>
      <mrow>
        <mo>(</mo>
        <mrow>
          <mi>u</mi>
          <mo>,</mo>
          <mi>v</mi>
        </mrow>
        <mo>)</mo>
      </mrow>
    </mrow>
    <mo>&it;</mo>
    <mrow>
      <mi>f</mi>
      <mo>&af;</mo>
      <mrow>
        <mo>(</mo>
        <mrow>
          <mi>u</mi>
          <mo>,</mo>
          <mi>v</mi>
        </mrow>
        <mo>)</mo>
      </mrow>
    </mrow>
  </mrow>
</mrow>
</math>
<mathematica-file id="MATHEMATICA-00006" file="US20030005398A1-20030102-M00006.NB"/>
<image id="EMI-M00006" wi="216.027" he="19.93005" file="US20030005398A1-20030102-M00006.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0104" lvl="7"><number>&lsqb;0104&rsqb;</number> Subject to:  
<math-cwu id="MATH-US-00007">
<number>7</number>
<math>
<mrow>
  <mrow>
    <mrow>
      <munder>
        <mo>&Sum;</mo>
        <mrow>
          <mi>V</mi>
          <mo>&RightArrow;</mo>
        </mrow>
      </munder>
      <mo>&it;</mo>
      <mrow>
        <mi>f</mi>
        <mo>&af;</mo>
        <mrow>
          <mo>(</mo>
          <mi>e</mi>
          <mo>)</mo>
        </mrow>
      </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
      <munder>
        <mo>&Sum;</mo>
        <mrow>
          <mo>&RightArrow;</mo>
          <mi>V</mi>
        </mrow>
      </munder>
      <mo>&it;</mo>
      <mrow>
        <mi>f</mi>
        <mo>&af;</mo>
        <mrow>
          <mo>(</mo>
          <mi>e</mi>
          <mo>)</mo>
        </mrow>
      </mrow>
    </mrow>
  </mrow>
  <mo>=</mo>
  <mrow>
    <mrow>
      <mo>&LeftBracketingBar;</mo>
      <mrow>
        <mi>FO</mi>
        <mo>&af;</mo>
        <mrow>
          <mo>(</mo>
          <mi>v</mi>
          <mo>)</mo>
        </mrow>
      </mrow>
      <mo>&RightBracketingBar;</mo>
    </mrow>
    <mo>-</mo>
    <mrow>
      <mo>&LeftBracketingBar;</mo>
      <mrow>
        <mi>FI</mi>
        <mo>&it;</mo>
        <mrow>
          <mo>(</mo>
          <mi>v</mi>
          <mo>)</mo>
        </mrow>
      </mrow>
      <mo>&RightBracketingBar;</mo>
    </mrow>
  </mrow>
</mrow>
</math>
<mathematica-file id="MATHEMATICA-00007" file="US20030005398A1-20030102-M00007.NB"/>
<image id="EMI-M00007" wi="216.027" he="19.93005" file="US20030005398A1-20030102-M00007.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0105" lvl="0"><number>&lsqb;0105&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6A</cross-reference> depicts exemplary illustrations of rebudgeting where positive gains on the timing margins are realized. Rebudgeting with positive gains on the timing margins can be done using the following two operators: forward and backward rebudgetting. For example: </paragraph>
<paragraph id="P-0106" lvl="0"><number>&lsqb;0106&rsqb;</number> 1. If&verbar;<highlight><superscript>FO(v)</superscript></highlight>&verbar;&gE;&verbar;<highlight><superscript>FI(v)</superscript></highlight>&verbar; (forward rebudgetting) then, </paragraph>
<paragraph id="P-0107" lvl="2"><number>&lsqb;0107&rsqb;</number> r(v)&equals;r<highlight><subscript>min</subscript></highlight>(v)(&equals;min<highlight><subscript>e</subscript></highlight>(s(e)),e&egr;FI(v)) and g(v)&equals;(&verbar;FO(v)&minus;&verbar;FI(v)&verbar;)r(v); </paragraph>
<paragraph id="P-0108" lvl="0"><number>&lsqb;0108&rsqb;</number> 2. If&verbar;<highlight><superscript>Fi(v)</superscript></highlight>&verbar;&gt;&verbar;<highlight><superscript>FO(v)</superscript></highlight>&verbar; (backward rebudgetting) then </paragraph>
<paragraph id="P-0109" lvl="2"><number>&lsqb;0109&rsqb;</number> r(v)&equals;r<highlight><subscript>min</subscript></highlight>(v)(&equals;min<highlight><subscript>e</subscript></highlight>(s(e)), e&egr;FO(v)) and g(v)&equals;(&verbar;FI(v)&verbar;&minus;&verbar;FO(v)&verbar;)r(v). </paragraph>
<paragraph id="P-0110" lvl="0"><number>&lsqb;0110&rsqb;</number> Path <highlight><bold>601</bold></highlight> illustrates an example of backward rebudgetting where r(u) (that is, an edge value of u,v) is rebudgetted to each of its fanin edges i<highlight><subscript>1</subscript></highlight>,u and i<highlight><subscript>2</subscript></highlight>,u. This results in a positive gain on the total timing margin. Path <highlight><bold>605</bold></highlight> illustrates an example of forward rebudgetting where r(v) is rebudgetted to each of its fanout edges (v,o<highlight><subscript>1</subscript></highlight>) and (v,o<highlight><subscript>2</subscript></highlight>). If either of these backward or forward rebudgetting techniques are used, then the overall timing budgets will be increased to g(v)&equals;(&verbar;FI(v)&verbar;&minus;&verbar;FO(v)&verbar;)r(v) and g(v)&equals;(&verbar;FI(v)&verbar;&minus;&verbar;FO(v)&verbar;)(&minus;r(v)), respectively. </paragraph>
<paragraph id="P-0111" lvl="0"><number>&lsqb;0111&rsqb;</number> Based on the above rebudgetting strategy, a Geometry-Constrained Rebudgetting problem that satisfies the triangle inequality s(u,v)&gt;s(v,w)&plus;s(w,u) for every cycle in graph G can then be formulated as the integer linear program below. In this case, a new variable w must be introduced to create r(u,v), r(v,w), r(w,u) in addition to r(u), r(v), r(w). <cross-reference target="DRAWINGS">FIG. 6B</cross-reference> illustrates an exemplary circuit graph depicting variables to be used for rebudgetting while preserving triangle inequalities. These variables are required to find a solution satisfying triangle inequalities. </paragraph>
<paragraph id="P-0112" lvl="0"><number>&lsqb;0112&rsqb;</number> Therefore, Geometry-Constrained Rebudgetting is a labeling of the node r: V&rarr;Z and the edge r: E&rarr;Z in a directed circuit graph G&equals;(V, E), where Z is the set of integers. Here, it is assumed that a graph G<highlight><superscript>66 </superscript></highlight> is given that has been triangulated, for example, by performing Geometry-constrained Slack Reassignment. </paragraph>
<paragraph id="P-0113" lvl="7"><number>&lsqb;0113&rsqb;</number> Geometry-Constrained Slack Rebudgetting (G<highlight><superscript>2</superscript></highlight>R) </paragraph>
<paragraph id="P-0114" lvl="7"><number>&lsqb;0114&rsqb;</number> Maximize: </paragraph>
<paragraph id="P-0115" lvl="2"><number>&lsqb;0115&rsqb;</number> g(u)&plus;g(v)&plus;g(w)&minus;r(u,v)&minus;r(v,w)&minus;r(w,u),&forall;(u,v,w)&egr;G </paragraph>
<paragraph id="P-0116" lvl="2"><number>&lsqb;0116&rsqb;</number> where g(u)&equals;(&verbar;FI(u)&verbar;&minus;FO(u)&verbar;)r(u),g(v)&equals;(&verbar;FI(v)&minus;&verbar;FO(v)&verbar;)r(v), and </paragraph>
<paragraph id="P-0117" lvl="2"><number>&lsqb;0117&rsqb;</number> r(w)&equals;(&verbar;FI(w)&minus;&verbar;FO(w)&verbar;)r(w) </paragraph>
<paragraph id="P-0118" lvl="7"><number>&lsqb;0118&rsqb;</number> Subject to: (here, considering the case of triangle (u, v, w) in <cross-reference target="DRAWINGS">FIG. 6B</cross-reference>) </paragraph>
<paragraph id="P-0119" lvl="7"><number>&lsqb;0119&rsqb;</number> Constraint 1: </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>s</italic></highlight>&prime;(<highlight><italic>u,v</italic></highlight>)&plus;<highlight><italic>s</italic></highlight>&prime;(<highlight><italic>v,w</italic></highlight>)&gE;<highlight><italic>s</italic></highlight>&prime;(<highlight><italic>w,u</italic></highlight>) </in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>s</italic></highlight>&prime;(<highlight><italic>u,v</italic></highlight>)&plus;<highlight><italic>s</italic></highlight>&prime;(<highlight><italic>w,u</italic></highlight>)&gE;<highlight><italic>s</italic></highlight>&prime;(<highlight><italic>v,w</italic></highlight>) </in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>s</italic></highlight>&prime;(<highlight><italic>u,w</italic></highlight>)&plus;<highlight><italic>s</italic></highlight>&prime;(<highlight><italic>w,u</italic></highlight>)&gE;<highlight><italic>s</italic></highlight>&prime;(<highlight><italic>u,v</italic></highlight>) </in-line-formula></paragraph>
<paragraph id="P-0120" lvl="7"><number>&lsqb;0120&rsqb;</number> where </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>s</italic></highlight>&prime;(<highlight><italic>u,v</italic></highlight>)&equals;<highlight><italic>s</italic></highlight>(<highlight><italic>u,v</italic></highlight>)&plus;<highlight><italic>r</italic></highlight>(<highlight><italic>v</italic></highlight>)&minus;<highlight><italic>r</italic></highlight>(<highlight><italic>u</italic></highlight>)&minus;<highlight><italic>r</italic></highlight>(<highlight><italic>u,v</italic></highlight>) </in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>s</italic></highlight>&prime;(<highlight><italic>v,w</italic></highlight>)&equals;<highlight><italic>s</italic></highlight>(<highlight><italic>v,w</italic></highlight>)&plus;<highlight><italic>r</italic></highlight>(<highlight><italic>w</italic></highlight>)&minus;<highlight><italic>r</italic></highlight>(<highlight><italic>v</italic></highlight>)&minus;<highlight><italic>r</italic></highlight>(<highlight><italic>v,w</italic></highlight>) </in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>s</italic></highlight>&prime;(<highlight><italic>w,u</italic></highlight>)&equals;<highlight><italic>s</italic></highlight>(<highlight><italic>w,u</italic></highlight>)&plus;<highlight><italic>r</italic></highlight>(<highlight><italic>u</italic></highlight>)&minus;<highlight><italic>r</italic></highlight>(<highlight><italic>w</italic></highlight>)&minus;<highlight><italic>r</italic></highlight>(<highlight><italic>w,u</italic></highlight>) </in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>s</italic></highlight>(<highlight><italic>u,v</italic></highlight>)&gt;<highlight><italic>r</italic></highlight>(<highlight><italic>u,v</italic></highlight>)&gt;0 </in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>s</italic></highlight>(<highlight><italic>v,w</italic></highlight>)&gt;<highlight><italic>r</italic></highlight>(<highlight><italic>v,w</italic></highlight>)&gt;0 </in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>s</italic></highlight>(<highlight><italic>w,u</italic></highlight>)&gt;<highlight><italic>r</italic></highlight>(<highlight><italic>w,u</italic></highlight>)&gt;0 </in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>s</italic></highlight>(<highlight><italic>PI,u</italic></highlight>)&gt;<highlight><italic>r</italic></highlight>(<highlight><italic>u</italic></highlight>)&gt;&minus;<highlight><italic>s</italic></highlight>(<highlight><italic>PO, u</italic></highlight>) </in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>s</italic></highlight>(<highlight><italic>PI,v</italic></highlight>)&gt;<highlight><italic>r</italic></highlight>(<highlight><italic>v</italic></highlight>)&gt;&minus;<highlight><italic>s</italic></highlight>(<highlight><italic>PO, v</italic></highlight>) </in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>s</italic></highlight>(<highlight><italic>PI,w</italic></highlight>)&gt;<highlight><italic>r</italic></highlight>(<highlight><italic>w</italic></highlight>)&gt;&minus;<highlight><italic>s</italic></highlight>(<highlight><italic>PO,w</italic></highlight>) </in-line-formula></paragraph>
<paragraph id="P-0121" lvl="7"><number>&lsqb;0121&rsqb;</number> Constraint 2: </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>s</italic></highlight>(<highlight><italic>w,u</italic></highlight>)&minus;<highlight><italic>r</italic></highlight>(<highlight><italic>w,u</italic></highlight>)&gt;<highlight><italic>r</italic></highlight>(<highlight><italic>w</italic></highlight>)&minus;<highlight><italic>r</italic></highlight>(<highlight><italic>u</italic></highlight>) </in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>s</italic></highlight>(<highlight><italic>u,v</italic></highlight>)&minus;<highlight><italic>r</italic></highlight>(<highlight><italic>u,v</italic></highlight>)&gt;<highlight><italic>r</italic></highlight>(<highlight><italic>u</italic></highlight>)&minus;<highlight><italic>r</italic></highlight>(<highlight><italic>v</italic></highlight>) </in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>s</italic></highlight>(<highlight><italic>v,w</italic></highlight>)&minus;<highlight><italic>r</italic></highlight>(<highlight><italic>v,w</italic></highlight>)&gt;<highlight><italic>r</italic></highlight>(<highlight><italic>v</italic></highlight>)&minus;<highlight><italic>r</italic></highlight>(<highlight><italic>w</italic></highlight>) </in-line-formula></paragraph>
<paragraph id="P-0122" lvl="7"><number>&lsqb;0122&rsqb;</number> Constraint 3: </paragraph>
<paragraph lvl="0"><in-line-formula>&verbar;<highlight><italic>r</italic></highlight>(<highlight><italic>u</italic></highlight>)&verbar;&lE;<highlight><italic>r</italic></highlight><highlight><subscript>min</subscript></highlight>(&rarr;<highlight><italic>u</italic></highlight>),<highlight><italic>r</italic></highlight>(<highlight><italic>u</italic></highlight>)&lE;0 </in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula>&verbar;<highlight><italic>r</italic></highlight>(<highlight><italic>v</italic></highlight>)&verbar;&lE;<highlight><italic>r</italic></highlight><highlight><subscript>min</subscript></highlight>(&rarr;<highlight><italic>v</italic></highlight>),<highlight><italic>r</italic></highlight>(<highlight><italic>v</italic></highlight>)&lE;0 </in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula>&verbar;<highlight><italic>r</italic></highlight>(<highlight><italic>w</italic></highlight>)&verbar;&lE;<highlight><italic>r</italic></highlight><highlight><subscript>min</subscript></highlight>(&rarr;<highlight><italic>w</italic></highlight>),<highlight><italic>r</italic></highlight>(<highlight><italic>w</italic></highlight>)&lE;0 </in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>r</italic></highlight>(<highlight><italic>u</italic></highlight>)&lE;<highlight><italic>r</italic></highlight><highlight><subscript>min</subscript></highlight>(<highlight><italic>u</italic></highlight>&rarr;),<highlight><italic>r</italic></highlight>(<highlight><italic>u</italic></highlight>)&lE;0 </in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>r</italic></highlight>(<highlight><italic>v</italic></highlight>)&lE;<highlight><italic>r</italic></highlight><highlight><subscript>min</subscript></highlight>(<highlight><italic>v</italic></highlight>&rarr;),<highlight><italic>r</italic></highlight>(<highlight><italic>v</italic></highlight>)&lE;0 </in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>r</italic></highlight>(<highlight><italic>w</italic></highlight>)&lE;<highlight><italic>r</italic></highlight><highlight><subscript>min</subscript></highlight>(<highlight><italic>w</italic></highlight>&rarr;),<highlight><italic>r</italic></highlight>(<highlight><italic>w</italic></highlight>)&lE;0 </in-line-formula></paragraph>
<paragraph id="P-0123" lvl="7"><number>&lsqb;0123&rsqb;</number> where </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>r</italic></highlight><highlight><subscript>min</subscript></highlight>(&rarr;<highlight><italic>i</italic></highlight>)&equals;min<highlight><subscript>e</subscript></highlight>(<highlight><italic>s</italic></highlight>(<highlight><italic>e</italic></highlight>)),<highlight><italic>e&egr;FI</italic></highlight>(<highlight><italic>i</italic></highlight>) </in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>r</italic></highlight><highlight><subscript>min</subscript></highlight>(&rarr;<highlight><italic>i</italic></highlight>)&equals;min<highlight><subscript>e</subscript></highlight>(<highlight><italic>s</italic></highlight>(<highlight><italic>e</italic></highlight>)),<highlight><italic>e&egr;FO</italic></highlight>(<highlight><italic>i</italic></highlight>) </in-line-formula></paragraph>
<paragraph id="P-0124" lvl="0"><number>&lsqb;0124&rsqb;</number> The objective function above represents the timing margin gains added to the rebudgetted circuit in relation to the original circuit. That is, the total slack gain G after performing the G<highlight><superscript>2</superscript></highlight>R algorithm will be: </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>G&equals;g</italic></highlight>(<highlight><italic>u</italic></highlight>)&plus;<highlight><italic>g</italic></highlight>(<highlight><italic>v</italic></highlight>)&plus;<highlight><italic>g</italic></highlight>(<highlight><italic>w</italic></highlight>)&minus;<highlight><italic>r</italic></highlight>(<highlight><italic>u,v</italic></highlight>)&minus;<highlight><italic>r</italic></highlight>(<highlight><italic>v,w</italic></highlight>)&minus;<highlight><italic>r</italic></highlight>(<highlight><italic>w,u</italic></highlight>)) </in-line-formula></paragraph>
<paragraph id="P-0125" lvl="7"><number>&lsqb;0125&rsqb;</number> Here s(w,PI) is the sum of timing margins on the edges in the shortest path from w to primary inputs,and s(w, PO) is the sum of timing margins on the edges in the shortest path from w to primary outputs. This value is used as a lower and upper bound for each of the retimed variables r(e). </paragraph>
<paragraph id="P-0126" lvl="0"><number>&lsqb;0126&rsqb;</number> The second and third constraints ensure that the s(e) for each edge e after rebudgetting is non-negative. Constraint 2 and Constraint 3 are redundant since Constraint 1 implies Constraint 2 (by adding two inequalities in Constraint 1), and Constraint 2 implies Constraint 3, respectively. Therefore, only Constraint 1 is needed. </paragraph>
<paragraph id="P-0127" lvl="0"><number>&lsqb;0127&rsqb;</number> A host node h is introduced that sources all &ldquo;primary inputs&rdquo; and sinks all &ldquo;primary outputs&rdquo; with dummy edges (edges having zero weight) connecting the host node with all primary inputs and primary outputs. A vertex u is strongly connected to v if two paths exist: one from a to b and another from b to a. Then: </paragraph>
<paragraph id="P-0128" lvl="7"><number>&lsqb;0128&rsqb;</number> Lemma 1 </paragraph>
<paragraph id="P-0129" lvl="0"><number>&lsqb;0129&rsqb;</number> The graph G&prime;(V&prime;,E&prime;), where V&prime;&equals;V&cup;h, and E&prime;&equals;E&cup;(h,i),&forall;i &egr;PI, &cup;(h,o), &forall;o&egr;PO is a strongly connected graph. </paragraph>
<paragraph id="P-0130" lvl="7"><number>&lsqb;0130&rsqb;</number> Corollary 1 </paragraph>
<paragraph id="P-0131" lvl="0"><number>&lsqb;0131&rsqb;</number> If G&equals;(V,E) is a strongly connected graph, then r(u,v)&gE;0,&forall;(u,v)&egr;E of G. </paragraph>
<paragraph id="P-0132" lvl="7"><number>&lsqb;0132&rsqb;</number> Lemma 2 </paragraph>
<paragraph id="P-0133" lvl="0"><number>&lsqb;0133&rsqb;</number> In graph G&prime;(V&prime;,E&prime;), a feasible solution can be found without explicitly specifying lower and upper bounds for the retimed variables in the following LP formulation. </paragraph>
<paragraph id="P-0134" lvl="0"><number>&lsqb;0134&rsqb;</number> Note that the original circuit graph G&equals;(V,E) is usually neither a strongly connected graph nor a triangulated graph. Graph G is transformed into: G<highlight><superscript>&Dgr;C</superscript></highlight>&equals;(V<highlight><superscript>C</superscript></highlight>&equals;(V&cup;h),E<highlight><superscript>&Dgr;C</superscript></highlight>&equals;(E<highlight><superscript>C</superscript></highlight>&cup;E<highlight><superscript>&Dgr;</superscript></highlight>), where E<highlight><superscript>C </superscript></highlight>are the augmented imaginary edges connecting the host node with primary and primary outputs, and E<highlight><superscript>&Dgr;</superscript></highlight> is the augmented imaginary edge after graph triangulation. The graph triangulation (forming a complete graph) can be done by running the Geometry-constrained Slack Reassignment algorithm (however, at this time without updating the slack values). </paragraph>
<paragraph id="P-0135" lvl="0"><number>&lsqb;0135&rsqb;</number> If there are still timing problems, the following algorithm (satisfying both triangle inequality and parity) can be applied: </paragraph>
<paragraph id="P-0136" lvl="7"><number>&lsqb;0136&rsqb;</number> Geometry-Aware Slack Re-Budgetting on G,GSRB(G<highlight><superscript>2</superscript></highlight>R) </paragraph>
<paragraph id="P-0137" lvl="7"><number>&lsqb;0137&rsqb;</number> Maximize: </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>g</italic></highlight>(<highlight><italic>u</italic></highlight>)&plus;<highlight><italic>g</italic></highlight>(<highlight><italic>v</italic></highlight>)&plus;<highlight><italic>g</italic></highlight>(<highlight><italic>w</italic></highlight>)&minus;<highlight><italic>r</italic></highlight>(<highlight><italic>u,v</italic></highlight>)&minus;<highlight><italic>r</italic></highlight>(<highlight><italic>v,w</italic></highlight>) <highlight><italic>r</italic></highlight>(<highlight><italic>w,u</italic></highlight>),&forall;(<highlight><italic>u,v,w</italic></highlight>) &egr;<highlight><italic>E, </italic></highlight></in-line-formula></paragraph>
<paragraph id="P-0138" lvl="7"><number>&lsqb;0138&rsqb;</number> where g(u)&equals;(&verbar;FI(u)&verbar;&minus;&verbar;FO(u)&verbar;)r(u),g(v)&equals;(&verbar;FI(v)&verbar;&minus;FO(v)&verbar;)r(v), and r(w)&equals;(&verbar;FI(w)&verbar;&minus;&verbar;FO(w)&verbar;)r(w), and FI(i) (resp. FO(i)) is the number of fanins (resp. fanouts of i&egr;V of G. </paragraph>
<paragraph id="P-0139" lvl="7"><number>&lsqb;0139&rsqb;</number> Subject to: </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>r</italic></highlight>(<highlight><italic>i</italic></highlight>)&minus;<highlight><italic>r</italic></highlight>(<highlight><italic>h</italic></highlight>)&gE;0, &forall;<highlight><italic>i&egr;PI </italic></highlight></in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>r</italic></highlight>(<highlight><italic>h</italic></highlight>)&minus;<highlight><italic>r</italic></highlight>(<highlight><italic>o</italic></highlight>)&gE;0, &forall;<highlight><italic>o&egr;PO </italic></highlight></in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>s</italic></highlight>&prime;(<highlight><italic>u,v</italic></highlight>)&plus;<highlight><italic>s</italic></highlight>&prime;(<highlight><italic>v,w</italic></highlight>)&gE;<highlight><italic>s</italic></highlight>&prime;(<highlight><italic>w,u</italic></highlight>) </in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>s</italic></highlight>&prime;(<highlight><italic>u,v</italic></highlight>)&plus;<highlight><italic>s</italic></highlight>&prime;(<highlight><italic>w,u</italic></highlight>)&gE;<highlight><italic>s</italic></highlight>&prime;(<highlight><italic>v,w</italic></highlight>) </in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>s</italic></highlight>&prime;(<highlight><italic>v,w</italic></highlight>)&plus;<highlight><italic>s</italic></highlight>&prime;(<highlight><italic>w,u</italic></highlight>)&gE;<highlight><italic>s</italic></highlight>&prime;(<highlight><italic>u,v</italic></highlight>), </in-line-formula></paragraph>
<paragraph id="P-0140" lvl="7"><number>&lsqb;0140&rsqb;</number> where if (u,v), (v,w), (w,u)&egr;E then </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>s</italic></highlight>&prime;(<highlight><italic>u,v</italic></highlight>)&equals;<highlight><italic>s</italic></highlight>(<highlight><italic>u,v</italic></highlight>)&plus;<highlight><italic>r</italic></highlight>(<highlight><italic>v</italic></highlight>)&minus;<highlight><italic>r</italic></highlight>(<highlight><italic>u</italic></highlight>)&minus;<highlight><italic>r</italic></highlight>(<highlight><italic>u,v</italic></highlight>) </in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>s</italic></highlight>&prime;(<highlight><italic>v,w</italic></highlight>)&equals;<highlight><italic>s</italic></highlight>(<highlight><italic>v,w</italic></highlight>)&plus;<highlight><italic>r</italic></highlight>(<highlight><italic>w</italic></highlight>)&minus;<highlight><italic>r</italic></highlight>(<highlight><italic>v</italic></highlight>)&minus;<highlight><italic>r</italic></highlight>(<highlight><italic>v,w</italic></highlight>) </in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>s</italic></highlight>&prime;(<highlight><italic>w,u</italic></highlight>)&equals;<highlight><italic>s</italic></highlight>(<highlight><italic>w,u</italic></highlight>)&plus;<highlight><italic>r</italic></highlight>(<highlight><italic>u</italic></highlight>)&minus;<highlight><italic>r</italic></highlight>(<highlight><italic>w</italic></highlight>)&minus;<highlight><italic>r</italic></highlight>(<highlight><italic>w,u</italic></highlight>) </in-line-formula></paragraph>
<paragraph id="P-0141" lvl="7"><number>&lsqb;0141&rsqb;</number> else if (i,j)&egr;E<highlight><superscript>66</superscript></highlight>, then </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>s</italic></highlight>&prime;(<highlight><italic>i,j</italic></highlight>)&equals;<highlight><italic>d</italic></highlight>(<highlight><italic>i,j</italic></highlight>) </in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>s</italic></highlight>&prime;(<highlight><italic>i,j</italic></highlight>)&gt;1,&forall;(<highlight><italic>i,j</italic></highlight>)&egr;<highlight><italic>E&cup;E</italic></highlight><highlight><superscript>&Dgr;</superscript></highlight></in-line-formula></paragraph>
<paragraph id="P-0142" lvl="7"><number>&lsqb;0142&rsqb;</number> Here the variable r(i), &forall;i&egr;(V&cup;h) is unconstrained, but the value is always positive because of introducing the host node, the variable r(i,j)&gE;0, &forall;(i,j)&egr;E, and the variable d(i,j)&gE;0, &forall;(i,j)&egr;E<highlight><superscript>&Dgr;</superscript></highlight>. PI(G) (resp. PO(G)) is defined as the set of nodes that has no incoming (resp. outgoing arcs) arcs in G. The last constraint is required to avoid cell overlaps in the same location. </paragraph>
<paragraph id="P-0143" lvl="0"><number>&lsqb;0143&rsqb;</number> FIGS. <highlight><bold>7</bold></highlight>A-<highlight><bold>7</bold></highlight>B are exemplary illustrations of rebudgeting results using geometry-aware slack distribution (rebudgetting) algorithms applied to the circuit graph of <cross-reference target="DRAWINGS">FIG. 3</cross-reference> according to an aspect of the present invention. The goal in rebudgetting the slacks is to maximize the total slack while satisfying the triangle inequality rule. <cross-reference target="DRAWINGS">FIG. 7A</cross-reference> illustrates slack rebudgetting which satisfies the triangle inequality rule. Here, the total slack is increased to 21. Host node h (<highlight><bold>701</bold></highlight>) is introduced to propagate a retimed value of 5 from a fanin edge h,<highlight><bold>1</bold></highlight> to fanout edges <highlight><bold>1</bold></highlight>,<highlight><bold>5</bold></highlight> and <highlight><bold>1</bold></highlight>,<highlight><bold>3</bold></highlight>, and so forth (the rebudgetting is done through all the paths in a continuous loop). The values in boxes <highlight><bold>703</bold></highlight> represent the retimed slack results for each node using the GSRB algorithm. It is to be noted that the total slack amount of 21 does not include the values <highlight><bold>703</bold></highlight>. </paragraph>
<paragraph id="P-0144" lvl="0"><number>&lsqb;0144&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7B</cross-reference> illustrates slack rebudgetting which satisfies both the triangle inequality rule and parity. Here, for example, the total slack is increased to 20. <cross-reference target="DRAWINGS">FIG. 7C</cross-reference> illustrates an exemplary slack reassignment satisfying the triangle inequality rule without rebudgetting the slack. Although the slack reassigment algorithm is a much faster algorithm, it does not maximize the total slack; in fact, it reduces it (for example, here the total slack is 15). </paragraph>
<paragraph id="P-0145" lvl="0"><number>&lsqb;0145&rsqb;</number> Compared with the initial circuit graph of <cross-reference target="DRAWINGS">FIG. 3</cross-reference>, applying the GSRB algorithm results in a slack gain of 3 units (from 21 to 18), while applying GSRA reduces the total slacks by 3 units (from 18 to 15). Note that triangulization does not affect the total timing slacks since the total slacks are maximized on circuit edges (shown in solid lines in FIGS. <highlight><bold>7</bold></highlight>A-<highlight><bold>7</bold></highlight>C) only. </paragraph>
<paragraph id="P-0146" lvl="0"><number>&lsqb;0146&rsqb;</number> To incorporate the triangle parity constraints mentioned above, for each cycle (u,v,w) in graph G, the following additional constraints are needed: </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>s</italic></highlight>(<highlight><italic>u,v</italic></highlight>)&equals;<highlight><italic>a</italic></highlight><highlight><subscript>0</subscript></highlight>2<highlight><superscript>0</superscript></highlight><highlight><italic>&plus;a</italic></highlight><highlight><subscript>1</subscript></highlight>2<highlight><superscript>1</superscript></highlight><highlight><italic>&plus;a</italic></highlight><highlight><subscript>2</subscript></highlight>2<highlight><superscript>2</superscript></highlight><highlight><italic>&plus;a</italic></highlight><highlight><subscript>3</subscript></highlight>2<highlight><superscript>3</superscript></highlight><highlight><italic>&plus;. . . &plus;a</italic></highlight><highlight><subscript>k</subscript></highlight>2<highlight><superscript>k </superscript></highlight></in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>s</italic></highlight>(<highlight><italic>v,w</italic></highlight>)&plus;<highlight><italic>s</italic></highlight>(<highlight><italic>w,u</italic></highlight>)&equals;<highlight><italic>b</italic></highlight><highlight><subscript>0</subscript></highlight>2<highlight><italic>&plus;b</italic></highlight><highlight><subscript>1</subscript></highlight>2<highlight><superscript>1</superscript></highlight><highlight><italic>&plus;b</italic></highlight><highlight><subscript>2</subscript></highlight>2<highlight><superscript>2</superscript></highlight><highlight><italic>&plus;b</italic></highlight><highlight><subscript>3</subscript></highlight>2<highlight><superscript>3</superscript></highlight><highlight><italic>&plus;. . . &plus;b</italic></highlight><highlight><subscript>k</subscript></highlight>2<highlight><superscript>k </superscript></highlight></in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula>a<highlight><subscript>0</subscript></highlight>&equals;b<highlight><subscript>0</subscript></highlight>, </in-line-formula></paragraph>
<paragraph id="P-0147" lvl="7"><number>&lsqb;0147&rsqb;</number> where a<highlight><subscript>0</subscript></highlight>, a<highlight><subscript>1</subscript></highlight>, . . . a<highlight><subscript>k</subscript></highlight>, b<highlight><subscript>0</subscript></highlight>, b<highlight><subscript>1</subscript></highlight>, . . . b<highlight><subscript>k </subscript></highlight>are 0,1 variables, and k is the maximum value such that a<highlight><subscript>0</subscript></highlight>2<highlight><superscript>0</superscript></highlight>&plus;a<highlight><subscript>1</subscript></highlight>2<highlight><superscript>1</superscript></highlight>&plus;a<highlight><subscript>2</subscript></highlight>2<highlight><superscript>2</superscript></highlight>&plus;a<highlight><subscript>3</subscript></highlight>2<highlight><superscript>3</superscript></highlight>&plus;. . . &plus;a<highlight><subscript>k </subscript></highlight>is less than the maximum slack in G. </paragraph>
<paragraph id="P-0148" lvl="0"><number>&lsqb;0148&rsqb;</number> Since the overall timing budgets on each path has not been increased, we have a situation where both GSRA and GSRB generate a solution which satisfies timing constraints. </paragraph>
</section>
<section>
<heading lvl="1">II. Timing-Driven 4-Way Multi-Level Mincut Partitioning </heading>
<paragraph id="P-0149" lvl="0"><number>&lsqb;0149&rsqb;</number> Once a timing budget is assigned for each net, the circuits are divided into segments in a partitioning step using, for example, a multilevel partitioning mincut algorithm. The objective of the mincut partitioning step is to divide the circuits into a required number of segments to minimize the number of global nets (i.e., nets which span multiple segments). It is mandatory to use some partitioning approach as design complexity continues to increase. The partitioning problem can be formed as follows: </paragraph>
<paragraph id="P-0150" lvl="0"><number>&lsqb;0150&rsqb;</number> Given a graph G&equals;(V,E) with weights on the edges and vertices and a parameter &phgr;, find a partitioning of the vertices of G into &phgr; sets in such a way that the sums of the vertex weights in each set are as equal as possible, and the sum of the weights of edges crossing between sets is minimized. </paragraph>
<paragraph id="P-0151" lvl="0"><number>&lsqb;0151&rsqb;</number> A brief description of an overall partitioning algorithm is as follows: </paragraph>
<paragraph id="P-0152" lvl="0"><number>&lsqb;0152&rsqb;</number> Algorithm multilevel timing-concerned partitioning (MTP): </paragraph>
<paragraph id="P-0153" lvl="2"><number>&lsqb;0153&rsqb;</number> 1. Perform Connectivity-aware Slack Reassignment (CSRA) on G&equals;(V,E). </paragraph>
<paragraph id="P-0154" lvl="2"><number>&lsqb;0154&rsqb;</number> 2. Until G is small enough (e.g., &verbar;V&verbar;&equals;5000): </paragraph>
<paragraph id="P-0155" lvl="3"><number>&lsqb;0155&rsqb;</number> G&equals;coarsen(G); (i.e., minimize the timing budget by clustering) </paragraph>
<paragraph id="P-0156" lvl="2"><number>&lsqb;0156&rsqb;</number> 3. Perform GSRA or GSRB on the coarsened graph G and perform Congestion-Aware Timing-Driven Partitioning CAP(i) on G. </paragraph>
<paragraph id="P-0157" lvl="2"><number>&lsqb;0157&rsqb;</number> 4. Until the coarsened graph G&equals;original graph G: </paragraph>
<paragraph id="P-0158" lvl="3"><number>&lsqb;0158&rsqb;</number> uncoarsen the graph; </paragraph>
<paragraph id="P-0159" lvl="3"><number>&lsqb;0159&rsqb;</number> partition the uncoarsened graph as described in Step <highlight><bold>3</bold></highlight> using CAP(i). </paragraph>
<paragraph id="P-0160" lvl="0"><number>&lsqb;0160&rsqb;</number> Mincut is effective for minimizing the number of nets crossing the cutline (cut nets) in the upper level of hierarchy, thus the wirelength can be decreased for the highly connected networks in the smaller region of the lower level of hierarchy. (The graph formed by the cut nets will be referred to as G<highlight><superscript>C</superscript></highlight>). </paragraph>
<paragraph id="P-0161" lvl="0"><number>&lsqb;0161&rsqb;</number> There are three different stages in a multilevel graph partitioning algorithm. Initially, a sequence of smaller and smaller graphs is created from the original graph (coarsening). Then, the smallest graph in the sequence is partitioned carefully (partitioning). Next, the partition is propagated back through the sequence of grids (uncoarsening), with an occasional local refinement. A solution is approximated using a fast heuristic such that the computational costs of constructing coarse graphs and the local improvement algorithms are both proportional to the number of edges in the graph. </paragraph>
<paragraph id="P-0162" lvl="0"><number>&lsqb;0162&rsqb;</number> Cell congestion (i.e., cell overlaps) is closely related to the partitioning strategy. By maximizing the minimum timing budget of the nets crossing the cutlines during partitioning, advantageously, the probability of finding a legal (i.e., where cells have no overlap) solution is increased. Cycles having a smaller radius (slack margin of the net crossing cutline diagonally) and a smaller diameter(sum of slack margins assigned to nets in the cycle) formed by paths crossing cutlines result in cell overlaps. These cycles are known as critical cycles. To reduce the possibility of cell overlaps, during partitioning, such critical cycles are minimized. </paragraph>
<paragraph id="P-0163" lvl="0"><number>&lsqb;0163&rsqb;</number> Maximizing the timing budget during partitioning can be done during timing-driven clustering in the multilevel partitioning. That is, cell congestion (cell overlap) is correlated with slack distribution. In order to minimize the possibility of cell overlaps (and thus maximize the porosity), the following weighted cell overlap contribution metric can be used:  
<math-cwu id="MATH-US-00008">
<number>8</number>
<math>
<mrow>
  <msub>
    <mi>d</mi>
    <mi>cell</mi>
  </msub>
  <mo>=</mo>
  <mrow>
    <mo>&Sum;</mo>
    <mrow>
      <mfrac>
        <msub>
          <mi>s</mi>
          <mi>max</mi>
        </msub>
        <mrow>
          <mi>s</mi>
          <mo>=</mo>
          <mn>1</mn>
        </mrow>
      </mfrac>
      <mo>&it;</mo>
      <mfrac>
        <mn>1</mn>
        <mrow>
          <mi>&gamma;</mi>
          <mo>&af;</mo>
          <mrow>
            <mo>(</mo>
            <mi>s</mi>
            <mo>)</mo>
          </mrow>
        </mrow>
      </mfrac>
      <mo>&it;</mo>
      <msub>
        <mi>n</mi>
        <mi>s</mi>
      </msub>
    </mrow>
  </mrow>
</mrow>
</math>
<mathematica-file id="MATHEMATICA-00008" file="US20030005398A1-20030102-M00008.NB"/>
<image id="EMI-M00008" wi="216.027" he="18.96615" file="US20030005398A1-20030102-M00008.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0164" lvl="7"><number>&lsqb;0164&rsqb;</number> where &ggr;(s)&equals;s(2s&plus;2), the number of grids in the rectilinear circle with rectilinear radius minus 1. Here, the:  
<math-cwu id="MATH-US-00009">
<number>9</number>
<math>
<mfrac>
  <mn>1</mn>
  <mrow>
    <mi>&gamma;</mi>
    <mo>&af;</mo>
    <mrow>
      <mo>(</mo>
      <mi>s</mi>
      <mo>)</mo>
    </mrow>
  </mrow>
</mfrac>
</math>
<mathematica-file id="MATHEMATICA-00009" file="US20030005398A1-20030102-M00009.NB"/>
<image id="EMI-M00009" wi="216.027" he="18.96615" file="US20030005398A1-20030102-M00009.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0165" lvl="7"><number>&lsqb;0165&rsqb;</number> indicates the probability of cell overlaps. The same result can be obtained by using a clustering, thus d<highlight><subscript>cell </subscript></highlight>is not included in cost function of partitioning. Thus, a new congestion-driven mincut cost incorporating wire and cell congestion will be C&equals;&prop;d<highlight><subscript>wire</subscript></highlight>&plus;(1&prop;)d<highlight><subscript>cell</subscript></highlight>, where C is a cost function and &prop; measures the relative importance between d<highlight><subscript>wire </subscript></highlight>and d<highlight><subscript>cell</subscript></highlight>, and can be found by linear regression from the result of routing. </paragraph>
<paragraph id="P-0166" lvl="0"><number>&lsqb;0166&rsqb;</number> To meet the objective of congestion mitigation being consistent in terms of wirelength, we first apply a mincut algorithm with the cost function C and apply the GSRB algorithm to G with a new objective function such that we maximize the timing budgets on G<highlight><superscript>C </superscript></highlight>and minimize the timing budgets on G-G<highlight><superscript>C</superscript></highlight>. In this manner, strongly connected clusters are assigned lower timing budgets and weakly connected clusters are assigned greater timing budgets. This slack budget management is referred to as Connectivity-aware Slack Re-assignment (CSRA). </paragraph>
<paragraph id="P-0167" lvl="0"><number>&lsqb;0167&rsqb;</number> After applying the above multilevel partitioning algorithm (MTP), critical cycles are evenly distributed over the plane and appear in the low level of the top-down partitioning hierarchy. Alleviating the congestion in a local area is equivalent to evenly distributing the layout resource elements (cells and wires) over the entire chip area. Thus, at each level of top-down hierarchy, a quad-tree partitioning strategy is performed: </paragraph>
<paragraph id="P-0168" lvl="0"><number>&lsqb;0168&rsqb;</number> Quad-tree partitioning is an approach to region representation based on the successive subdivision of a plane into quadrants. This process can be represented by a quad-tree. A root node corresponds to the entire plane. Each son of a root node represents a quadrant. Each root node comprises four quadrants labeled in counter clock-wise order Q<highlight><subscript>1</subscript></highlight>, Q<highlight><subscript>2</subscript></highlight>, Q<highlight><subscript>3</subscript></highlight>, and Q<highlight><subscript>4</subscript></highlight>, from the right upper quadrant and four cutlines C<highlight><subscript>1 </subscript></highlight>(between Q<highlight><subscript>1 </subscript></highlight>and Q<highlight><subscript>2</subscript></highlight>), C<highlight><subscript>2 </subscript></highlight>(between Q<highlight><subscript>2 </subscript></highlight>and Q<highlight><subscript>3</subscript></highlight>), C<highlight><subscript>3 </subscript></highlight>(between Q<highlight><subscript>3 </subscript></highlight>and Q<highlight><subscript>4</subscript></highlight>) and C<highlight><subscript>4 </subscript></highlight>(between Q<highlight><subscript>4 </subscript></highlight>and Q<highlight><subscript>1</subscript></highlight>). The total timing slacks assigned on nets in q<highlight><subscript>i </subscript></highlight>during partitioning is denoted by s(q<highlight><subscript>i</subscript></highlight>). The total cell area assigned in q<highlight><subscript>i </subscript></highlight>during partitioning is denoted by a(i). The capacity of cutline ci is denoted by d(c<highlight><subscript>i</subscript></highlight>). The total timing slacks assigned on the nets crossing the cutline ci is denoted by s(ci), and the total number of nets crossing the cutline c<highlight><subscript>i </subscript></highlight>is denoted by n(c<highlight><subscript>i</subscript></highlight>). Leaf nodes of the quad tree correspond to a grid cell or a region with a functional block for which no further subdivision is necessary. A leaf node is occupied by basic cells, functional block, or clusters. </paragraph>
<paragraph id="P-0169" lvl="0"><number>&lsqb;0169&rsqb;</number> Q(i) denotes the quadrant region where cell i is assigned to and w(i,p) denotes the timing window region generated by s(i,p), which is the timing slack between cell i and I/O cell p. </paragraph>
<paragraph id="P-0170" lvl="0"><number>&lsqb;0170&rsqb;</number> The timing-driven partitioning problem can be effectively solved by an assignment technique in which each module and net is assigned to one of the four timing-closed quadrants. </paragraph>
<paragraph id="P-0171" lvl="0"><number>&lsqb;0171&rsqb;</number> The assignment technique can be formulated as a linear programming algorithm (described below). The smaller the total slacks on the cutlines, the higher the probability of finding a feasible solution, which reduces the possibility of cell overlaps in future placements at a lower level of the top-down partitioning hierarchy, and thus the more flexibility in reducing total wirelength during the top-down partitioning hierarchy. </paragraph>
<paragraph id="P-0172" lvl="7"><number>&lsqb;0172&rsqb;</number> Congestion-Aware Timing-Driven Partitioning (CAP(i)) on G&equals;(V,E): </paragraph>
<paragraph id="P-0173" lvl="0"><number>&lsqb;0173&rsqb;</number> Minimize  
<math-cwu id="MATH-US-00010">
<number>10</number>
<math>
<mrow>
  <munderover>
    <mo>&Sum;</mo>
    <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
    </mrow>
    <mn>4</mn>
  </munderover>
  <mo>&it;</mo>
  <mrow>
    <mi>n</mi>
    <mo>&af;</mo>
    <mrow>
      <mo>(</mo>
      <mi>i</mi>
      <mo>)</mo>
    </mrow>
  </mrow>
</mrow>
</math>
<mathematica-file id="MATHEMATICA-00010" file="US20030005398A1-20030102-M00010.NB"/>
<image id="EMI-M00010" wi="216.027" he="24.97635" file="US20030005398A1-20030102-M00010.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0174" lvl="7"><number>&lsqb;0174&rsqb;</number> Subject to: </paragraph>
<paragraph id="P-0175" lvl="7"><number>&lsqb;0175&rsqb;</number> Cutline Capacity Constraints: </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>n</italic></highlight>(<highlight><italic>i</italic></highlight>)&lE;<highlight><italic>d</italic></highlight>(<highlight><italic>c</italic></highlight><highlight><subscript>i</subscript></highlight>),<highlight><italic>i</italic></highlight>&equals;(1,2,3,4) </in-line-formula></paragraph>
<paragraph id="P-0176" lvl="7"><number>&lsqb;0176&rsqb;</number> Cut-nets Distribution Constraints:  
<math-cwu id="MATH-US-00011">
<number>11</number>
<math>
<mrow>
  <mrow>
    <mrow>
      <mi>n</mi>
      <mo>&it;</mo>
      <mrow>
        <mo>(</mo>
        <mi>i</mi>
        <mo>)</mo>
      </mrow>
    </mrow>
    <mo>&GreaterEqual;</mo>
    <mfrac>
      <mi>n</mi>
      <mrow>
        <msup>
          <mn>2</mn>
          <mrow>
            <mi>i</mi>
            <mo>+</mo>
            <mn>1</mn>
          </mrow>
        </msup>
        <mo>&it;</mo>
        <mrow>
          <mo>(</mo>
          <mrow>
            <mi>m</mi>
            <mo>+</mo>
            <mn>1</mn>
          </mrow>
          <mo>)</mo>
        </mrow>
      </mrow>
    </mfrac>
  </mrow>
  <mo>,</mo>
</mrow>
</math>
<mathematica-file id="MATHEMATICA-00011" file="US20030005398A1-20030102-M00011.NB"/>
<image id="EMI-M00011" wi="216.027" he="17.03835" file="US20030005398A1-20030102-M00011.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0177" lvl="7"><number>&lsqb;0177&rsqb;</number> where the right hand side is the low bound on channel capacity, n is the number of nets and m is the chip size. </paragraph>
<paragraph id="P-0178" lvl="7"><number>&lsqb;0178&rsqb;</number> Bin Capacity Constraints </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>ab</italic></highlight>(<highlight><italic>i</italic></highlight>)&lE;avg<highlight><italic>AU, i</italic></highlight>&equals;(1,2,3,4) </in-line-formula></paragraph>
<paragraph id="P-0179" lvl="7"><number>&lsqb;0179&rsqb;</number> where ab(i)&equals;area&minus;modules(q<highlight><subscript>i</subscript></highlight>)&plus; 
<math-cwu id="MATH-US-00012">
<number>12</number>
<math>
<mrow>
  <mrow>
    <mi>a</mi>
    <mo>&it;</mo>
    <mstyle>
      <mtext>&emsp;</mtext>
    </mstyle>
    <mo>&it;</mo>
    <mrow>
      <mi>b</mi>
      <mo>&af;</mo>
      <mrow>
        <mo>(</mo>
        <mi>i</mi>
        <mo>)</mo>
      </mrow>
    </mrow>
  </mrow>
  <mo>=</mo>
  <mrow>
    <mi>area</mi>
    <mo>-</mo>
    <mrow>
      <mi>modules</mi>
      <mo>&af;</mo>
      <mrow>
        <mo>(</mo>
        <msub>
          <mi>q</mi>
          <mi>i</mi>
        </msub>
        <mo>)</mo>
      </mrow>
    </mrow>
    <mo>+</mo>
    <mfrac>
      <mrow>
        <mi>area</mi>
        <mo>&af;</mo>
        <mrow>
          <mo>(</mo>
          <mrow>
            <msub>
              <mi>c</mi>
              <mi>i</mi>
            </msub>
            <mo>:</mo>
            <mrow>
              <mi>cutlines</mi>
              <mo>&it;</mo>
              <mstyle>
                <mtext>&emsp;</mtext>
              </mstyle>
              <mo>&it;</mo>
              <mi>adjacent</mi>
              <mo>&it;</mo>
              <mstyle>
                <mtext>&emsp;</mtext>
              </mstyle>
              <mo>&it;</mo>
              <mi>to</mi>
              <mo>&it;</mo>
              <mstyle>
                <mtext>&emsp;</mtext>
              </mstyle>
              <mo>&it;</mo>
              <msub>
                <mi>q</mi>
                <mi>i</mi>
              </msub>
            </mrow>
          </mrow>
          <mo>)</mo>
        </mrow>
      </mrow>
      <mn>2</mn>
    </mfrac>
    <mo>+</mo>
    <mi>area</mi>
    <mo>-</mo>
    <mrow>
      <mi>nets</mi>
      <mo>&af;</mo>
      <mrow>
        <mo>(</mo>
        <msub>
          <mi>q</mi>
          <mi>i</mi>
        </msub>
        <mo>)</mo>
      </mrow>
    </mrow>
  </mrow>
</mrow>
</math>
<mathematica-file id="MATHEMATICA-00012" file="US20030005398A1-20030102-M00012.NB"/>
<image id="EMI-M00012" wi="216.027" he="29.0304" file="US20030005398A1-20030102-M00012.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0180" lvl="7"><number>&lsqb;0180&rsqb;</number> &plus;area&minus;nets(q<highlight><subscript>i</subscript></highlight>) and avgAU&equals; 
<math-cwu id="MATH-US-00013">
<number>13</number>
<math>
<mrow>
  <mrow>
    <mrow>
      <mi>a</mi>
      <mo>&it;</mo>
      <mstyle>
        <mtext>&emsp;</mtext>
      </mstyle>
      <mo>&it;</mo>
      <mi>v</mi>
      <mo>&it;</mo>
      <mstyle>
        <mtext>&emsp;</mtext>
      </mstyle>
      <mo>&it;</mo>
      <mi>g</mi>
      <mo>&it;</mo>
      <mstyle>
        <mtext>&emsp;</mtext>
      </mstyle>
      <mo>&it;</mo>
      <mi>A</mi>
      <mo>&it;</mo>
      <mstyle>
        <mtext>&emsp;</mtext>
      </mstyle>
      <mo>&it;</mo>
      <mi>U</mi>
    </mrow>
    <mo>=</mo>
    <mfrac>
      <mrow>
        <mrow>
          <mi>w</mi>
          <mo>&it;</mo>
          <mstyle>
            <mtext>&emsp;</mtext>
          </mstyle>
          <mo>&it;</mo>
          <mi>s</mi>
          <mo>&times;</mo>
          <mi>S</mi>
        </mrow>
        <mo>+</mo>
        <mrow>
          <mi>w</mi>
          <mo>&it;</mo>
          <mstyle>
            <mtext>&emsp;</mtext>
          </mstyle>
          <mo>&it;</mo>
          <mi>b</mi>
          <mo>&times;</mo>
          <mi>B</mi>
        </mrow>
      </mrow>
      <mn>4</mn>
    </mfrac>
  </mrow>
  <mo>,</mo>
</mrow>
</math>
<mathematica-file id="MATHEMATICA-00013" file="US20030005398A1-20030102-M00013.NB"/>
<image id="EMI-M00013" wi="216.027" he="17.03835" file="US20030005398A1-20030102-M00013.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0181" lvl="7"><number>&lsqb;0181&rsqb;</number> where ws is wire unit are, S is the total slacks in G, and wb is cell unit area and B is the total number of modules in G. The upper-bound avgAU&equals;avgAU&plus;a. </paragraph>
<paragraph id="P-0182" lvl="7"><number>&lsqb;0182&rsqb;</number> Bin Resources Distribution Constraints: </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>ab</italic></highlight>(<highlight><italic>i</italic></highlight>)&gE;avg<highlight><italic>AL, i</italic></highlight>&equals;(1,2,3,4) </in-line-formula></paragraph>
<paragraph id="P-0183" lvl="7"><number>&lsqb;0183&rsqb;</number> The lower-bound: avgAL&equals;avgA&minus;a. </paragraph>
<paragraph id="P-0184" lvl="7"><number>&lsqb;0184&rsqb;</number> Timing Constraints: </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>q</italic></highlight>(<highlight><italic>i</italic></highlight>)&cap;<highlight><italic>w</italic></highlight>(<highlight><italic>i,P</italic></highlight>)&ne;0,<highlight><italic>i&egr;V </italic></highlight></in-line-formula></paragraph>
<paragraph id="P-0185" lvl="7"><number>&lsqb;0185&rsqb;</number> The overall placement algorithm is as follows: </paragraph>
<paragraph id="P-0186" lvl="7"><number>&lsqb;0186&rsqb;</number> Geometry-Aware Top-down Placement (GTP) </paragraph>
<paragraph id="P-0187" lvl="0"><number>&lsqb;0187&rsqb;</number> 1. Partition a circuit graph into 4 subgraphs by performing a multilevel timing-concerned partitioning (MTP) to find a mincut and to assign each of the subgraphs into a quadrant so as to satisfy the timing constraints between already placed cells (e.g., I/O pads) in a previous level of the top-down hierarchy and subgraphs. </paragraph>
<paragraph id="P-0188" lvl="0"><number>&lsqb;0188&rsqb;</number> 2. Perform Timing Window Generation and Module Assignment (described in the following section) for nets crossing 4 cutlines. Assign each net to channels on the four cutlines creating a pseudo-terminal. The fixed channel location of the pseudo terminal on the cutlines acts as an I/O pad for the quadrants, q<highlight><subscript>1</subscript></highlight>, q<highlight><subscript>2</subscript></highlight>, q<highlight><subscript>3</subscript></highlight>, and q<highlight><subscript>4 </subscript></highlight>(i.e., terminal propagation). </paragraph>
<paragraph id="P-0189" lvl="0"><number>&lsqb;0189&rsqb;</number> 3. Repeat the above procedures for each subgraph q<highlight><subscript>i </subscript></highlight>until a leaf node of the quad-tree is reached. </paragraph>
<paragraph id="P-0190" lvl="0"><number>&lsqb;0190&rsqb;</number> In step <highlight><bold>1</bold></highlight> above, path slacks between the already-placed cell in a previous level and the cell in the current level of the top-down hierarchy need to be checked. In the second iteration of GTP, one of the partitioning constraints &dgr;s(qi), as described above, is adjusted to further alleviate congestion. </paragraph>
</section>
<section>
<heading lvl="1">III. Timing Window Generation and Module Assignment </heading>
<paragraph id="P-0191" lvl="0"><number>&lsqb;0191&rsqb;</number> Next, a module assignment algorithm is performed at each level of the mincut hierarchy. FIGS. <highlight><bold>8</bold></highlight>A-F illustrate an exemplary overall application of a method of module placement according to an aspect of the present invention. Initially, in <cross-reference target="DRAWINGS">FIG. 8A, a</cross-reference> circuit graph is provided comprising modules <highlight><bold>800</bold></highlight> connected by edges <highlight><bold>801</bold></highlight>, the edges having slack values assigned according to the geometry aware slack distribution algorithm of the present invention. In addition, clusters <highlight><bold>802</bold></highlight> are formed from critical nets. In <cross-reference target="DRAWINGS">FIG. 8B, a</cross-reference> mincut is performed to reduce the number of edges crossing cutlines <highlight><bold>803</bold></highlight> at a first level of hierarchy (top level <highlight><bold>1</bold></highlight>). Next, <cross-reference target="DRAWINGS">FIG. 8C</cross-reference> illustrates timing windows <highlight><bold>805</bold></highlight> generated for each module <highlight><bold>800</bold></highlight> on a placement grid <highlight><bold>807</bold></highlight>, where each of the modules are assigned to their respective timing window at level <highlight><bold>1</bold></highlight> of the hierarchy. It is important to note that the cycle (f,b,d) was placed simultaneously at level <highlight><bold>1</bold></highlight>. Once the modules in the first hierarchy are placed, mincut is performed in <cross-reference target="DRAWINGS">FIG. 8D</cross-reference> on the set of edges on the cutlines (represented by dotted lines) at a next level of hierarchy (level <highlight><bold>2</bold></highlight>). Then, in <cross-reference target="DRAWINGS">FIG. 8E</cross-reference> the modules attached to the nets (represented by solid lines in <cross-reference target="DRAWINGS">FIG. 8D</cross-reference>) are placed on the placement grid <highlight><bold>807</bold></highlight>. <cross-reference target="DRAWINGS">FIG. 8F</cross-reference> illustrates a next level of hierarchy (level <highlight><bold>3</bold></highlight>) of the top-down placement process. Note that module c is not assigned to an exact location until this lower level (level <highlight><bold>3</bold></highlight>) of hierarchy is processed. </paragraph>
<paragraph id="P-0192" lvl="0"><number>&lsqb;0192&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9A</cross-reference> depicts another example of an initial circuit graph G&equals;(V,E) <highlight><bold>901</bold></highlight> comprising node labels V <highlight><bold>903</bold></highlight> (V&equals;1, 2, . . . , 8) attached by edges E <highlight><bold>905</bold></highlight>. Each edge <highlight><bold>905</bold></highlight> includes an edge label comprising an edge ID <highlight><bold>907</bold></highlight> (E&equals;1, 2, . . . 12) and a given feasible slack value <highlight><bold>909</bold></highlight>. Each slack value is assigned using, for example, a geometry-aware slack distribution algorithm according to an aspect of the present invention satisfying geometric constraints such as triangle parity and inequality. </paragraph>
<paragraph id="P-0193" lvl="0"><number>&lsqb;0193&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9B</cross-reference> illustrates an exemplary placement grid <highlight><bold>910</bold></highlight> having fixed labeling comprising bin and channel labels (addresses). Each quadrant comprises 9 bins; for example, quadrant <highlight><bold>912</bold></highlight> includes bins <highlight><bold>1</bold></highlight>, <highlight><bold>5</bold></highlight>, <highlight><bold>6</bold></highlight>, <highlight><bold>7</bold></highlight>, <highlight><bold>8</bold></highlight>, <highlight><bold>21</bold></highlight>, <highlight><bold>22</bold></highlight>, <highlight><bold>23</bold></highlight> and <highlight><bold>24</bold></highlight>. Bin <highlight><bold>1</bold></highlight> includes bins <highlight><bold>21</bold></highlight>-<highlight><bold>24</bold></highlight>, bin <highlight><bold>5</bold></highlight> includes <highlight><bold>21</bold></highlight> and <highlight><bold>22</bold></highlight>, bin <highlight><bold>7</bold></highlight> includes bins <highlight><bold>23</bold></highlight> and <highlight><bold>24</bold></highlight>, bin <highlight><bold>6</bold></highlight> includes bins <highlight><bold>22</bold></highlight> and <highlight><bold>23</bold></highlight>, and bin <highlight><bold>8</bold></highlight> includes bins <highlight><bold>21</bold></highlight> and <highlight><bold>24</bold></highlight>. Each bin is labeled in a counter-clockwise fashion within each quadrant; bins <highlight><bold>1</bold></highlight>-<highlight><bold>4</bold></highlight> are also labeled in a counter-clockwise fashion starting from quadrant <highlight><bold>912</bold></highlight>. Placement grid includes channel labels for labeling each of the four cutlines separating each quadrant (C&equals;c&ensp;, c<highlight><bold>12</bold></highlight>, . . . c<highlight><bold>42</bold></highlight>) </paragraph>
<paragraph id="P-0194" lvl="0"><number>&lsqb;0194&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9C</cross-reference> illustrates an exemplary timing-driven partitioning of the circuit graph <highlight><bold>901</bold></highlight> into four quadrants <highlight><bold>914</bold></highlight>, <highlight><bold>916</bold></highlight>, <highlight><bold>918</bold></highlight> and <highlight><bold>920</bold></highlight> based on a min-slack cut for maximizing resource balancing. The circuit graph is partitioned into segments such that global nets (nets which span multiple segments) are minimized. <cross-reference target="DRAWINGS">FIG. 9D</cross-reference> illustrates an exemplary timing-closed placement of the modules <highlight><bold>903</bold></highlight> onto the placement grid <highlight><bold>910</bold></highlight> and nets (edges) into channels according to an aspect of the present invention (the bin and channel labels here are not shown). Each module is placed into a target timing-closed window region, for example, module <highlight><bold>1</bold></highlight> is placed in bin <highlight><bold>5</bold></highlight>, module <highlight><bold>2</bold></highlight> in bin <highlight><bold>6</bold></highlight>, module <highlight><bold>4</bold></highlight> in bin <highlight><bold>28</bold></highlight>, etc. The placement is situated such that straight connections and window sizes are maximized. Note that in the <cross-reference target="DRAWINGS">FIG. 9</cross-reference>D, module <highlight><bold>1</bold></highlight> is allocated to bin <highlight><bold>5</bold></highlight> rather than assigning to an exact basic bin location. The exact module placements are deferred to a lower level of hierarchy. </paragraph>
<paragraph id="P-0195" lvl="0"><number>&lsqb;0195&rsqb;</number> The goal is to assign each module to a target timing-closed window region. A linear programming algorithm can be used to find an assignment of the modules. </paragraph>
<paragraph id="P-0196" lvl="0"><number>&lsqb;0196&rsqb;</number> The linear program described below has the following constraints with (0,1) variable of yibj, xibj, and xicj, where yibj&equals;1 if a cell i is assigned to timing window j, xibj&equals;1 if a net i is assigned to bin j, and xicj&equals;1 if a net i is assigned to cut-channel j. To assign cells to bins and nets to channels, the labels as shown in <cross-reference target="DRAWINGS">FIG. 9B</cross-reference> are used here for illustrative purposes. </paragraph>
<paragraph id="P-0197" lvl="7"><number>&lsqb;0197&rsqb;</number> Linear Programming Algorithm: Module Assignment </paragraph>
<paragraph id="P-0198" lvl="7"><number>&lsqb;0198&rsqb;</number> Maximize TW&plus;ST, where TW is the size of timing windows assigned to nodes and ST is the set of configurations for straight connections. That is: max: </paragraph>
<paragraph id="P-0199" lvl="1"><number>&lsqb;0199&rsqb;</number> w13c11&plus;w13c12&plus;w24c11&plus;w24c12&plus;w75c31&plus;w75c32&plus;w86c31&plus;w86c32&plus;w35c21&plus;w35c22&plus;w46c21&plus;w46c22&plus;w28c41&plus;w28c42&plus;w17c41&plus;w17&plus;c42&plus;y1b5&plus;y1b6&plus;y1b7&plus;y1b8&plus;y2b6&plus;y2b7&plus;y3b9&plus;y3b10&plus;y3b11&plus;y3b12&plus;y4b11&plus;y4b12&plus;y5b13&plus;y5b14&plus;y5b15&plus;y5b16&plus;y6b13&plus;y6b16&plus;y7b17&plus;y7b18&plus;y7b19&plus;y7b20&plus;y8b17&plus;y8b18; </paragraph>
<paragraph id="P-0200" lvl="7"><number>&lsqb;0200&rsqb;</number> Subject to: </paragraph>
<paragraph id="P-0201" lvl="7"><number>&lsqb;0201&rsqb;</number> Assignment Constraint: All Possible Configurations Inside Timing-Windows </paragraph>
<paragraph id="P-0202" lvl="1"><number>&lsqb;0202&rsqb;</number> y1b5&plus;y1b6&plus;y1b7&plus;y1b8&plus;y1b21l&plus;y1b22&plus;y1b23&plus;y1b24&equals;1; </paragraph>
<paragraph id="P-0203" lvl="1"><number>&lsqb;0203&rsqb;</number> y3b9&plus;y3b10&plus;y3b11&plus;y3b12&plus;y3b25&plus;y3b26&plus;y3b27&plus;y3b28&equals;1; </paragraph>
<paragraph id="P-0204" lvl="1"><number>&lsqb;0204&rsqb;</number> y5b 13&plus;y5b14&plus;y5b15&plus;y5b16&plus;y5b29&plus;y5b30&plus;y5b31&plus;y5b32&equals;1; </paragraph>
<paragraph id="P-0205" lvl="1"><number>&lsqb;0205&rsqb;</number> y7b17&plus;y7b18&plus;y7b19&plus;y7b20&plus;y7b33&plus;y7b34&plus;y7b35&plus;y7b36&equals;1; </paragraph>
<paragraph id="P-0206" lvl="1"><number>&lsqb;0206&rsqb;</number> y2b6&plus;y2b7&plus;y2b22&plus;y2b23&plus;y2b24&equals;1; </paragraph>
<paragraph id="P-0207" lvl="1"><number>&lsqb;0207&rsqb;</number> y4b11&plus;y4b12&plus;y4b25&plus;y4b27&plus;y4b28&equals;1; </paragraph>
<paragraph id="P-0208" lvl="1"><number>&lsqb;0208&rsqb;</number> y6b13&plus;y6b16&plus;y6b29&plus;y6b30&plus;y6b32&equals;1; </paragraph>
<paragraph id="P-0209" lvl="1"><number>&lsqb;0209&rsqb;</number> y8b17&plus;y8b18&plus;y8b33&plus;y8b34&plus;y8b35&equals;1; </paragraph>
<paragraph id="P-0210" lvl="7"><number>&lsqb;0210&rsqb;</number> Net Connectivity Constraint </paragraph>
<paragraph id="P-0211" lvl="1"><number>&lsqb;0211&rsqb;</number> /*center nets with slacks&equals;3 radius&equals;3 from center*/y1b5&plus;y1b6&plus;y1b7&plus;y1b8&plus;y1b21&plus;y1b22&plus;y1b23&plus;y1b24&equals;y3b9&plus;y3b10&plus;y3b11&plus;y3b12&plus;y3b25&plus;y3b26y3b27&plus;y3b28; </paragraph>
<paragraph id="P-0212" lvl="1"><number>&lsqb;0212&rsqb;</number> y3b9&plus;y3b10&plus;y3b11&plus;y3b12&plus;y3b25&plus;y3b26&plus;y3b27&plus;y3b28&equals;y5b13&plus;y5b14&plus;y5b15&plus;y5b16&plus;y5b29&plus;y5b30&plus;y5b31&plus;y5b32; </paragraph>
<paragraph id="P-0213" lvl="1"><number>&lsqb;0213&rsqb;</number> y5b13&plus;y5b14&plus;y5b15&plus;y5b16&plus;y5b29&plus;y5b30&plus;y5b31&plus;y5b32&equals;y7b17&plus;y7b18&plus;y7b19&plus;y7b20&plus;y7b33&plus;y7b34&plus;y7b35&plus;y7b36; </paragraph>
<paragraph id="P-0214" lvl="1"><number>&lsqb;0214&rsqb;</number> y7b17&plus;y7b18&plus;y7b19&plus;y7b20&plus;y7b33&plus;y7b34&plus;y7b35&plus;y7b36&equals;y1b5&plus;y1b6&plus;y1b7&plus;y1b8&plus;y1b21&plus;y1b22&plus;y1b23&plus;y1b24; </paragraph>
<paragraph id="P-0215" lvl="1"><number>&lsqb;0215&rsqb;</number> /*center nets with slacks&equals;2 radius&equals;2 from center*/y2b6&plus;y2b7&plus;y2b22&plus;y2b23&plus;y2b24&equals;y4b11&plus;y4b12&plus;y4b25&plus;y4b27&plus;y4b28; </paragraph>
<paragraph id="P-0216" lvl="1"><number>&lsqb;0216&rsqb;</number> y4b11&plus;y4b12&plus;y4b25&plus;y4b27&plus;y4b28&equals;y6b13&plus;y6b16&plus;y6b29&plus;y6b30&plus;y6b32; </paragraph>
<paragraph id="P-0217" lvl="1"><number>&lsqb;0217&rsqb;</number> y6b13&plus;y6b16&plus;y6b29&plus;y6b30&plus;y6b32&equals;y8b17&plus;y8b18&plus;y8b33&plus;y8b34&plus;y8b35; </paragraph>
<paragraph id="P-0218" lvl="1"><number>&lsqb;0218&rsqb;</number> y8b17&plus;y8b18&plus;y8b33&plus;y8b34&plus;y8b35&equals;y2b6&plus;y2b7&plus;y2b22&plus;y2b23&plus;y2b24; </paragraph>
<paragraph id="P-0219" lvl="1"><number>&lsqb;0219&rsqb;</number> 25/*side nets with slack2*/y1b5&plus;y1b6&plus;y1b7&plus;y1b8&plus;y1b21&plus;y1b22&plus;y23&plus;y1b24&equals;y2b6&plus;y2b7&plus;y2b22&plus;y2b23&plus;y2b24; </paragraph>
<paragraph id="P-0220" lvl="1"><number>&lsqb;0220&rsqb;</number> y3b9&plus;y3b10&plus;y3b11&plus;y3b12&plus;y3b25&plus;y3b26&plus;y3b27&plus;y3b28&equals;y3b28&equals;y4b11&plus;y4b12&plus;y4b25&plus;y4b27&plus;y4b28; </paragraph>
<paragraph id="P-0221" lvl="1"><number>&lsqb;0221&rsqb;</number> y5b13&plus;y5b14&plus;y5b15&plus;y5b16&plus;y5b29&plus;y5b30&plus;y5b31&plus;y5b32&equals;y6b13&plus;y6b16&plus;y6b29&plus;y6b30&plus;y6b32; </paragraph>
<paragraph id="P-0222" lvl="1"><number>&lsqb;0222&rsqb;</number> y7b17&plus;y7b18&plus;y7b19&plus;y7b20&plus;y7b33&plus;y7b34&plus;y7b35&plus;y7b36&equals;y8b17&plus;y8b18&plus;y8b33&plus;y8b34&plus;y8b35; </paragraph>
<paragraph id="P-0223" lvl="0"><number>&lsqb;0223&rsqb;</number> This constraints represents a netlist associated with module assignment. Here all assignments is needed to be timing-closed so that all delays between the nodes satisfies the timing constraints. Thus we need the following constraints: </paragraph>
<paragraph id="P-0224" lvl="7"><number>&lsqb;0224&rsqb;</number> Timing Resolution Constraint </paragraph>
<paragraph id="P-0225" lvl="1"><number>&lsqb;0225&rsqb;</number> *remove timing violations for nets with slack&equals;3*/y1b8&plus;y3b9&lE;1;y1b8&plus;y3b10 &lE;1; y1b8&plus;y3b11&lE;1; y1b8&plus;y3b12&lE;1; </paragraph>
<paragraph id="P-0226" lvl="1"><number>&lsqb;0226&rsqb;</number> y1b5&plus;y7b17&lE;1; y1b5&plus;y7b18&lE;1; y1b5&plus;y1b19&lE;1; y1b5&plus;y7b20&lE;1; </paragraph>
<paragraph id="P-0227" lvl="1"><number>&lsqb;0227&rsqb;</number> y7b20&plus;y5b13&lE;1; y7b20&plus;y5b14&lE;1; y7b20&plus;y5b15&lE;1;y7b20&plus;y5b16&lE;1; </paragraph>
<paragraph id="P-0228" lvl="1"><number>&lsqb;0228&rsqb;</number> y7b19&plus;y1b5&lE;1; y7b19&plus;y1b6&lE;1; y7b19&plus;y1b7&lE;1;y7b19&plus;y1b8&lE;1; </paragraph>
<paragraph id="P-0229" lvl="1"><number>&lsqb;0229&rsqb;</number> y3b9&plus;y5b13&lE;1; y3b9&plus;y5b14&lE;1; y3b9&plus;y5b15&lE;1;y3b9&plus;y5b16&lE;1; </paragraph>
<paragraph id="P-0230" lvl="1"><number>&lsqb;0230&rsqb;</number> y3b10&plus;y1b5&lE;1; y3b10&plus;y1b6&lE;1; y3b10&plus;y1b7&lE;1;y3b10&plus;y1b8&lE;1; </paragraph>
<paragraph id="P-0231" lvl="1"><number>&lsqb;0231&rsqb;</number> y5b15&plus;y3b9&lE;1; y5b15&plus;y3b10&lE;1; y5b15&plus;y3b11&lE;1;y5b15&plus;y3b12&lE;1; </paragraph>
<paragraph id="P-0232" lvl="1"><number>&lsqb;0232&rsqb;</number> y5b14&plus;y7b17&lE;1; y5b14&plus;y7b18&lE;1; y5b14&plus;y7b19&lE;1;y5b14&plus;y7b20&lE;1; </paragraph>
<paragraph id="P-0233" lvl="1"><number>&lsqb;0233&rsqb;</number> /*remove timing violations for nets with slack&equals;2*/y2b6&plus;y4b11&lE;1; y2b6&plus;y4b12&lE;1; y2b7&plus;y4b11&lE;1; y2b7&plus;y4b12&lE;1; </paragraph>
<paragraph id="P-0234" lvl="1"><number>&lsqb;0234&rsqb;</number> y4b11&plus;y6b13&lE;1; y4b11&plus;y6b16&lE;1; y4b12&plus;y6b13&lE;1; y4b12&plus;y6b16&lE;1; </paragraph>
<paragraph id="P-0235" lvl="1"><number>&lsqb;0235&rsqb;</number> y6b13&plus;y8b17&lE;1; y6b13&plus;y8b18&lE;1; y6b16&plus;y8b17&lE;1; y6b16&plus;y8b18&lE;1; </paragraph>
<paragraph id="P-0236" lvl="1"><number>&lsqb;0236&rsqb;</number> y8b17&plus;y2b6&lE;1; y8b17&plus;y2b7&lE;1; y8b18&plus;y2b6&lE;1; y8b18&plus;y2b18&lE;1; </paragraph>
<paragraph id="P-0237" lvl="1"><number>&lsqb;0237&rsqb;</number> y2b22&plus;y4b11&lE;1; y2b22&plus;y8b17&lE;1; y2b22&plus;y8b18&lE;1; </paragraph>
<paragraph id="P-0238" lvl="1"><number>&lsqb;0238&rsqb;</number> y2b24&plus;y4b11&lE;1; y2b24&plus;y4b12&lE;1; y2b24&plus;y8b18&lE;1; </paragraph>
<paragraph id="P-0239" lvl="1"><number>&lsqb;0239&rsqb;</number> y4b27&plus;y6b16&lE;1; y4b27&plus;y2b6&lE;1; y4b27&plus;y2b7&lE;1; </paragraph>
<paragraph id="P-0240" lvl="1"><number>&lsqb;0240&rsqb;</number> y4b25&plus;y6b16&lE;1; y4b25&plus;y6b13&lt;1; y4b25&plus;y2b7&lE;1; </paragraph>
<paragraph id="P-0241" lvl="1"><number>&lsqb;0241&rsqb;</number> y6b32&plus;y8b17&lE;1; y6b32&plus;y4b11&lE;1; y6b32&plus;y4b12&lE;1; </paragraph>
<paragraph id="P-0242" lvl="1"><number>&lsqb;0242&rsqb;</number> y6b30&plus;y8b17&lE;1; y6b30&plus;y8b18&lE;1; y6b30&plus;y4b12&lE;1; </paragraph>
<paragraph id="P-0243" lvl="1"><number>&lsqb;0243&rsqb;</number> y8b33&plus;y2b6&lE;1; y8b33&plus;y6b13&lE;1; y8b33&plus;y6b16&lE;1; </paragraph>
<paragraph id="P-0244" lvl="1"><number>&lsqb;0244&rsqb;</number> y8b35&plus;y2b6&lE;1; y8b35&plus;y2b7&lE;1; y8b35&plus;y6b13&lE;1; </paragraph>
<paragraph id="P-0245" lvl="1"><number>&lsqb;0245&rsqb;</number> y2b22&plus;y4b27&lE;1; y2b24&plus;y4b27&lE;1; y2b24&plus;y4b25&lE;1; </paragraph>
<paragraph id="P-0246" lvl="1"><number>&lsqb;0246&rsqb;</number> y4b27&plus;y6b32&lE;1; y4b25&plus;y6b30&lE;1; y4b25&plus;y6b32&lE;1; </paragraph>
<paragraph id="P-0247" lvl="1"><number>&lsqb;0247&rsqb;</number> y6b30&plus;y8b33&lE;1; y6b30&plus;y8b35&lE;1; y6b32&plus;y8b33&lE;1; </paragraph>
<paragraph id="P-0248" lvl="1"><number>&lsqb;0248&rsqb;</number> y8b33&plus;y2b22&lE;1; y8b35&plus;y2b22&lE;1; y8b35&plus;y2b24&lE;1; </paragraph>
<paragraph id="P-0249" lvl="7"><number>&lsqb;0249&rsqb;</number> Channel Capacity Constraint </paragraph>
<paragraph id="P-0250" lvl="1"><number>&lsqb;0250&rsqb;</number> 1&plus;x1c11&plus;x1c12&equals;y1b5&plus;y1b6&plus;y1b7&plus;y1b8&plus;y1b21&plus;y1b22&plus;y1b23&plus;y1b24&plus;y3b9&plus;y3b&emsp;b&plus;y3b11&plus;y3b12&plus;y3b25&plus;y3b26&plus;y3b27&plus;y3b28; </paragraph>
<paragraph id="P-0251" lvl="1"><number>&lsqb;0251&rsqb;</number> 1&plus;x2c11&plus;x2c12&equals;y2b6&plus;y2b7&plus;y2b22&plus;y21b23&plus;y2b241&plus;y4b11&plus;y4b12&plus;y4b25&plus;y4b27&plus;y4b28; </paragraph>
<paragraph id="P-0252" lvl="1"><number>&lsqb;0252&rsqb;</number> 1<highlight><bold>30</bold></highlight> x9c21&plus;x9c22&equals;y3b9&plus;y3b10 &plus;y3b11&plus;y3b12&plus;y3b27y3b28&plus;y5b13&plus;y5b14&plus;y5b15&plus;y5b16&plus;y5b29&plus;y5b30&plus;y5b31&plus;y5b32; </paragraph>
<paragraph id="P-0253" lvl="1"><number>&lsqb;0253&rsqb;</number> 1&plus;x10c21&plus;x10c22&equals;y4b11&plus;y4b12&plus;y4b25&plus;y4b27&plus;y4b28&plus;y6b13&plus;y6b16&plus;y6b29&plus;y6b30&plus;y6b32; </paragraph>
<paragraph id="P-0254" lvl="1"><number>&lsqb;0254&rsqb;</number> 1<highlight><bold>30</bold></highlight> x6c31&plus;x6c32&equals;y8b17&plus;y8b18&plus;y8b33&plus;y8b34&plus;y8b35&plus;y6b13&plus;y6b16&plus;y6b29&plus;y6b30&plus;y6b32; </paragraph>
<paragraph id="P-0255" lvl="1"><number>&lsqb;0255&rsqb;</number> 1&plus;x5c31&plus;x5c32&equals;y5b13&plus;y5b14&plus;y5b15&plus;y5b16&plus;y5b29&plus;y5y5b30y5b31y5b32&plus;y7b17&plus;y7b18&plus;y7b19&plus;y7b20&plus;y7b33&plus;y7b34&plus;y7b35&plus;y7b36; </paragraph>
<paragraph id="P-0256" lvl="1"><number>&lsqb;0256&rsqb;</number> 1&plus;x11c41&plus;x11c42&equals;y2b6&plus;y2b7&plus;y2b22&plus;y2b23&plus;y2b24&plus;y8b17&plus;y8b18&plus;y8b33&plus;y8b34&plus;y8b35; </paragraph>
<paragraph id="P-0257" lvl="1"><number>&lsqb;0257&rsqb;</number> 1<highlight><bold>30</bold></highlight> x12c41&plus;x12c42&equals;y1b5&plus;y1b6&plus;y1b7&plus;y1b8&plus;y1b21&plus;y1b22&plus;y1b23&plus;y1&plus;y1b24&plus;y7b17&plus;y7b18&plus;y7b19&plus;y7b20&plus;y7b33&plus;y7b34&plus;y7b35&plus;y7b36; </paragraph>
<paragraph id="P-0258" lvl="1"><number>&lsqb;0258&rsqb;</number> /*&lE;channel capacity obtained by partitioning*/x1c11&plus;x2c11&lE;1; x1c12&plus;x2c12&lE;1; x9c21&plus;x10c21&lE;1; x9c22&plus;x10c22&plus;x10c22&lE;1; </paragraph>
<paragraph id="P-0259" lvl="1"><number>&lsqb;0259&rsqb;</number> x5c31&plus;x6c31&lE;1; x5c32&plus;x6c32&lE;1; x11c41&plus;x12c41&lE;1; x11c42&plus;x12c42 &lE;1; </paragraph>
<paragraph id="P-0260" lvl="7"><number>&lsqb;0260&rsqb;</number> Straight Connections Constraint </paragraph>
<paragraph id="P-0261" lvl="1"><number>&lsqb;0261&rsqb;</number> y1b5&plus;y1b21&plus;y1b22&plus;y3b9&plus;y3b25&plus;y3b26&plus;x1c11&equals;w13c11; </paragraph>
<paragraph id="P-0262" lvl="1"><number>&lsqb;0262&rsqb;</number> y1b7&plus;y1b23&plus;y1b24&plus;y3b11&plus;y3b27&plus;y3b28&plus;x1c12&equals;w13c12; </paragraph>
<paragraph id="P-0263" lvl="1"><number>&lsqb;0263&rsqb;</number> y2b22&plus;y4b25&plus;x2c11&equals;w24c11; </paragraph>
<paragraph id="P-0264" lvl="1"><number>&lsqb;0264&rsqb;</number> y2b7&plus;y2b23&plus;y2b24&plus;y4b11&plus;y4b27&plus;y4b28&plus;x2c12&equals;w24c12 </paragraph>
<paragraph id="P-0265" lvl="1"><number>&lsqb;0265&rsqb;</number> y7b17&plus;y7b33&plus;y7b34&plus;y5b13&plus;y5b29&plus;y5b30&plus;x5c31&equals;w75c31; </paragraph>
<paragraph id="P-0266" lvl="1"><number>&lsqb;0266&rsqb;</number> y7b19&plus;y7b35&plus;y7b36&plus;y5b15&plus;y5b31&plus;y5b32&plus;x5c32w75c32; </paragraph>
<paragraph id="P-0267" lvl="1"><number>&lsqb;0267&rsqb;</number> y8b17&plus;y8b33&plus;y8b34&plus;y6b13&plus;y6b29&plus;y6b30&plus;x6c31&equals;w86c31; </paragraph>
<paragraph id="P-0268" lvl="1"><number>&lsqb;0268&rsqb;</number> y8b35&plus;y6b32&plus;x6c32&equals;w86c32; </paragraph>
<paragraph id="P-0269" lvl="1"><number>&lsqb;0269&rsqb;</number> y3b10&plus;y3b26&plus;y3b27&plus;y5b14&plus;y5b30&plus;y5b31&plus;x9c21&equals;w35c21; </paragraph>
<paragraph id="P-0270" lvl="1"><number>&lsqb;0270&rsqb;</number> y3b12&plus;y3b25&plus;y3b28&plus;y5b16&plus;y5b29&plus;y5b32&plus;x9c22&equals;w22c22; </paragraph>
<paragraph id="P-0271" lvl="1"><number>&lsqb;0271&rsqb;</number> y4b27&plus;y6b30&plus;x10c21&equals;w46c21; </paragraph>
<paragraph id="P-0272" lvl="1"><number>&lsqb;0272&rsqb;</number> y4b12&plus;y4b25&plus;y4b28&plus;y6b16&plus;y6b29&plus;y6b32&plus;x10c22&equals;w46c22; </paragraph>
<paragraph id="P-0273" lvl="1"><number>&lsqb;0273&rsqb;</number> y2b6&plus;y2b22&plus;y2b23&plus;y8b18&plus;y8b34&plus;y8b35&plus;x11c41&equals;w28c41; </paragraph>
<paragraph id="P-0274" lvl="1"><number>&lsqb;0274&rsqb;</number> y2b24&plus;y8b33&plus;x11c42&equals;w28c42; </paragraph>
<paragraph id="P-0275" lvl="1"><number>&lsqb;0275&rsqb;</number> y1b6&plus;y1b22&plus;y1b23&plus;y7b18&plus;y7b34&plus;y7b35&plus;x12c41&equals;w17c41; </paragraph>
<paragraph id="P-0276" lvl="1"><number>&lsqb;0276&rsqb;</number> y1b8&plus;y1b21&plus;y1b24&plus;y7b20&plus;y7b33&plus;y7b36&plus;x12c42&equals;w17c42; </paragraph>
<paragraph id="P-0277" lvl="1"><number>&lsqb;0277&rsqb;</number> /*not allowing two-turn detours; LHS is maximized by cost function*/yb5&plus;y1b21&plus;y1b22&plus;y3b9&plus;y3b25&plus;y3b26&gE;x1c11; </paragraph>
<paragraph id="P-0278" lvl="1"><number>&lsqb;0278&rsqb;</number> y1b7&plus;y1b23&plus;y1b24&plus;y3b11&plus;y3b27&plus;y3b28&gE;x1c12; </paragraph>
<paragraph id="P-0279" lvl="1"><number>&lsqb;0279&rsqb;</number> y2b22&plus;y4b25&gE;x2c11; </paragraph>
<paragraph id="P-0280" lvl="1"><number>&lsqb;0280&rsqb;</number> y2b7&plus;y2b23&plus;y2b24&plus;y4b11&plus;y4b27&plus;y4b28&gE;x2c12 </paragraph>
<paragraph id="P-0281" lvl="0"><number>&lsqb;0281&rsqb;</number> y7b17&plus;y7b33&plus;y7b34&plus;y5b13&plus;y5b29&plus;y5b30&gE;x5c31; </paragraph>
<paragraph id="P-0282" lvl="1"><number>&lsqb;0282&rsqb;</number> y7b19&plus;y7b35&plus;y7b36&plus;y5b15&plus;y5b31&plus;y5b32&gE;x5c32; </paragraph>
<paragraph id="P-0283" lvl="1"><number>&lsqb;0283&rsqb;</number> y8b17&plus;y8b33&plus;y8b34&plus;y6b13&plus;y6b29&plus;y6b30&gE;x6c31; </paragraph>
<paragraph id="P-0284" lvl="1"><number>&lsqb;0284&rsqb;</number> y8b35&plus;y6b32&gE;x6c32; </paragraph>
<paragraph id="P-0285" lvl="1"><number>&lsqb;0285&rsqb;</number> y3b10&plus;y3b26&plus;y3b27&plus;y5b14&plus;y5b30&plus;y5b31&gE;x9c21; </paragraph>
<paragraph id="P-0286" lvl="1"><number>&lsqb;0286&rsqb;</number> y3b12&plus;y3b25&plus;y3b28&plus;y5b16&plus;y5b29&plus;y5b32&gE;x9c22; </paragraph>
<paragraph id="P-0287" lvl="1"><number>&lsqb;0287&rsqb;</number> y4b27&plus;y6b30&gE;x10c21; </paragraph>
<paragraph id="P-0288" lvl="1"><number>&lsqb;0288&rsqb;</number> y4b12&plus;y4b25&plus;y4b28&plus;y6b16&plus;y6b29&plus;y6b32&gE;x10c22; </paragraph>
<paragraph id="P-0289" lvl="1"><number>&lsqb;0289&rsqb;</number> y2b6&plus;y2b22&plus;y2b23&plus;y8b18&plus;y8b34&plus;y8b35&plus;&gE;x11c41; </paragraph>
<paragraph id="P-0290" lvl="1"><number>&lsqb;0290&rsqb;</number> y2b24&plus;8b33&gE;x11c42; </paragraph>
<paragraph id="P-0291" lvl="1"><number>&lsqb;0291&rsqb;</number> y1b6&plus;y1b22&plus;y1b23&plus;y7b18&plus;y7b34&plus;y7b35&plus;&gE;x12c41; </paragraph>
<paragraph id="P-0292" lvl="1"><number>&lsqb;0292&rsqb;</number> y1b8&plus;y1b21&plus;y1b24&plus;y7b20&plus;y7b33&plus;y7b36&plus;&gE;x12c42; </paragraph>
<paragraph id="P-0293" lvl="0"><number>&lsqb;0293&rsqb;</number> These constraints removes the two-bend (two-turn) detours. </paragraph>
<paragraph id="P-0294" lvl="7"><number>&lsqb;0294&rsqb;</number> Bin Capacity Constraint </paragraph>
<paragraph id="P-0295" lvl="1"><number>&lsqb;0295&rsqb;</number> y1b6&plus;y2b6&lE;2; y1b7&plus;y2b7&lE;2; y3b11&plus;y4b11&lE;2; y3b12&plus;y4b12&lE;2; </paragraph>
<paragraph id="P-0296" lvl="1"><number>&lsqb;0296&rsqb;</number> y5b13&plus;y6b13&lE;2; y5b16&plus;y6b16&lE;2; y7b17&plus;y8b17&lE;2; y7b18&plus;y8b18&lE;2; </paragraph>
<paragraph id="P-0297" lvl="1"><number>&lsqb;0297&rsqb;</number> y1b22&plus;y2b22&lE;1; y1b23&plus;y2b23&lE;1; y1b24&plus;y2b24&lE;1; </paragraph>
<paragraph id="P-0298" lvl="1"><number>&lsqb;0298&rsqb;</number> y3b25&plus;y4b25&lE;1; y3b27&plus;y4b27&lE;1; y3b28&plus;y4b28&lE;1; </paragraph>
<paragraph id="P-0299" lvl="1"><number>&lsqb;0299&rsqb;</number> y5b29&plus;y6b29&lE;1; y5b30&plus;y6b30&lE;1; y5b32&plus;y6b32&lE;1; </paragraph>
<paragraph id="P-0300" lvl="7"><number>&lsqb;0300&rsqb;</number> (0,1) Integer Variables Constraint </paragraph>
<paragraph id="P-0301" lvl="1"><number>&lsqb;0301&rsqb;</number> y1b5&lE;1; y1b6&lE;1; y1b7&lE;1; y1b8&lE;1; y1b21&lE;1;y1b22&lE;1; y1b24&lE;1; </paragraph>
<paragraph id="P-0302" lvl="1"><number>&lsqb;0302&rsqb;</number> y2b6&lE;1; y2b7&lE;1; y2b22&lE;1; y2b23&lE;1; y2b24&lE;1; </paragraph>
<paragraph id="P-0303" lvl="1"><number>&lsqb;0303&rsqb;</number> y3b9&lE;1; y3b10&lE;1; y3b11&lE;1; y3b12&lE;1; y3b25&lE;1;y3b26&lE;1; y3b27&lE;1; y3b28&lE;1; </paragraph>
<paragraph id="P-0304" lvl="1"><number>&lsqb;0304&rsqb;</number> y4b11&lE;1; y4b12&lE;1; y4b25&lE;1; y4b27&lE;1; y4b28&lE;1; </paragraph>
<paragraph id="P-0305" lvl="1"><number>&lsqb;0305&rsqb;</number> y5b13&lE;1; y5b14&lE;1; y5b15&lE;1; y5b16&lE;1; y5b29&lE;1;y5b30&lE;1; y5b31&lE;1; y5b32&lE;1; </paragraph>
<paragraph id="P-0306" lvl="1"><number>&lsqb;0306&rsqb;</number> y6b13&lE;1; y6b16&lE;1; y6b29&lE;1; y6b30&lE;1; y6b32&lE;1; </paragraph>
<paragraph id="P-0307" lvl="1"><number>&lsqb;0307&rsqb;</number> y7b17&lE;1; y7b18&lE;1; y7b19&lE;1; y7b20&lE;1; y7b33&lE;1;y7b34&lE;1; y7b35&lE;1; y7b36&lE;1; </paragraph>
<paragraph id="P-0308" lvl="1"><number>&lsqb;0308&rsqb;</number> y8b17&lE;1; y8b18&lE;1; y8b33&lE;1; y8b34&lE;1; y8b35&lE;1; </paragraph>
<paragraph id="P-0309" lvl="1"><number>&lsqb;0309&rsqb;</number> x1c11&lE;1; x1c12&lE;1; x2c11&lE;1; x2c12&lE;1; x9c21&lE;1;x9c21&lE;1;x9c22&lE;1; y10c21&lE;1; </paragraph>
<paragraph id="P-0310" lvl="1"><number>&lsqb;0310&rsqb;</number> y10c22&lE;1; x6c31&lE;1; x6c32&lE;1; x5c31&lE;1; x5c32&lE;1;x11c41&lE;1; x11c42&lE;1; </paragraph>
<paragraph id="P-0311" lvl="1"><number>&lsqb;0311&rsqb;</number> x12c41&lE;1; x12c42&lE;1; </paragraph>
<paragraph id="P-0312" lvl="0"><number>&lsqb;0312&rsqb;</number> FIGS. <highlight><bold>10</bold></highlight>A-C illustrate exemplary steps of generating a timing window for level i considering timing windows generated in previous levels i&equals;1 and i&equals;2. <cross-reference target="DRAWINGS">FIG. 10A</cross-reference> illustrates a given subgraph of an edge (a,b) having a slack value of 4. <cross-reference target="DRAWINGS">FIG. 10B</cross-reference> illustrates a timing window <highlight><bold>1000</bold></highlight> generated at level i-<highlight><bold>2</bold></highlight> (here, a highest level of hierarchy) for module a, and a timing window <highlight><bold>1002</bold></highlight> generated for module b at level i-<highlight><bold>1</bold></highlight> (a next lower level of hierarchy). <cross-reference target="DRAWINGS">FIG. 10B</cross-reference> includes cut lines generated at level i-<highlight><bold>2</bold></highlight> (<highlight><bold>1004</bold></highlight>), cut lines generated at level i-<highlight><bold>1</bold></highlight> (<highlight><bold>1006</bold></highlight>) and cutlines at level i (<highlight><bold>1008</bold></highlight>). The timing window for edge (a,b) is generated at a current level i such that &square;(a<highlight><superscript>i-2</superscript></highlight>)&cap;&square; (a<highlight><superscript>i</superscript></highlight>)&ne;&Oslash; and &square; (b<highlight><superscript>i-2</superscript></highlight>)&cap;&square; (b<highlight><superscript>i</superscript></highlight>)&ne;&Oslash; (we refer to the constraints as timing window closure constraints), where &square; (a<highlight><superscript>i</superscript></highlight>) denotes the timing window for node a at level i of the top-down partition. A top-down partition is used here to get a more exact location for each module in the lower levels of the hierarchy. Here, module a for example, is assigned to an address in the highest level of hierarchy, but not to an exact location. In the current level i, module a is assigned to the upper right bin of timing window <highlight><bold>1000</bold></highlight>. <cross-reference target="DRAWINGS">FIG. 10C</cross-reference> illustrates an exemplary timing window <highlight><bold>1010</bold></highlight> generated for edge (a,b) at level i. </paragraph>
<paragraph id="P-0313" lvl="0"><number>&lsqb;0313&rsqb;</number> Note that the lower level of hierarchy where the possibility of overflow is increased has a smaller configuration space. Therefore, a feasible solution can be found by using a set of different slack distributions as well as increasing the number of timing window configurations. </paragraph>
<paragraph id="P-0314" lvl="0"><number>&lsqb;0314&rsqb;</number> Thus, an effective timing-driven placement that also takes the routing congestion and wirelength into consideration is reached where all nets meet timing constraints with absolute timing budgets. Based on these features, good global placement results can be achieved without excessive computation time. </paragraph>
<paragraph id="P-0315" lvl="0"><number>&lsqb;0315&rsqb;</number> It is to be noted that the basic algorithms described in this paper can be easily extended to cells with different sizes such that cell width and height are multiples of basic units. For example, as shown in <cross-reference target="DRAWINGS">FIG. 11A, a</cross-reference> graph <highlight><bold>1103</bold></highlight> associated with a multiple-unit cell <highlight><bold>1101</bold></highlight> can be formed such that there are imaginery edges between two adjacent basic cells with a corresponding edge weight. For example, here the edge weight corresponds to a fixed timing budget (one grid unit corresponds to a unit timing budget). </paragraph>
<paragraph id="P-0316" lvl="0"><number>&lsqb;0316&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 11</cross-reference>B, the graph <highlight><bold>1105</bold></highlight> can generate different shapes (e.g., a straight or bended shape). To generate a particular shape of a multiple-sizes cell <highlight><bold>1106</bold></highlight>, an edge can be assigned an attribute which regards to its corresponding shape. For example, graph <highlight><bold>1105</bold></highlight> corresponds to an alternate placement configuration such that cell a is above cell b and cell c is to the right of cell b. Here, the attributes can be, for example, (a,c):L, (a,b):&verbar;, (b,c):-, where &ldquo;L&rdquo;, &ldquo;&verbar;&rdquo; and &ldquo;-&rdquo; correspond to L-shaped, horizontal and vertical placement respectively, of two cells. </paragraph>
<paragraph id="P-0317" lvl="0"><number>&lsqb;0317&rsqb;</number> Although illustrative embodiments of the present invention have been described herein with reference to the accompanying drawings, it is to be understood that the present invention is not limited to those precise embodiments, and that various other changes and modifications maybe affected therein by one skilled in the art without departing from the scope or spirit of the invention. All such changes and modifications are intended to be included within the scope of the invention as defined by the appended claims. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method for placing circuit elements on semiconductor chips comprising the steps of: 
<claim-text>a) creating a circuit graph including cutlines, said circuit graph comprising said circuit elements connected by nets for placement on a placement grid; </claim-text>
<claim-text>b) clustering critical nets in the circuit graph; </claim-text>
<claim-text>c) assigning a timing budget for each net using at least one of a plurality of slack distribution algorithms satisfying at least one geometric constraint; </claim-text>
<claim-text>d) partitioning the circuit graph using a mincut algorithm; </claim-text>
<claim-text>e) generating a timing window region on the placement grid for each net which is less than or equal to each net&apos;s respective timing budget; and </claim-text>
<claim-text>f) assigning the circuit elements attached to each net to each of their respective timing window regions. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the geometric constraint is a triangle inequality rule or a triangle parity rule. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the step of partitioning further comprises: 
<claim-text>performing a connectivity aware slack reassignment on the circuit graph to assign densely connected clusters a lower timing budget and weakly connected clusters a higher timing budget; and </claim-text>
<claim-text>partitioning the circuit graph into four subgraphs to reduce a number of edges crossing cutlines at a first level of hierarchy. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the placement grid comprises a plurality of bins for placement of the circuit elements, and channels for placement of the nets. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, wherein the step of assigning a timing budget further comprises using a geometry constrained slack reassignment algorithm for assigning timing budgets which satisfy the triangle inequality rule for every cycle in the circuit graph. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, wherein the step of assigning a timing budget further comprises using a geometry constrained slack rebudgetting algorithm for assigning timing budgets which satisfy the triangle inequality rule for every cycle in the circuit graph. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, wherein the step of assigning a timing budget further comprises using a geometry constrained slack rebudgetting algorithm for assigning timing budgets which satisfy the triangle inequality rule and the triangle parity rule. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, wherein the triangle inequality rule provides that a sum of the timing budgets of any two edges of a cycle is equal to or greater than the timing budget of the third edge. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, wherein the triangle parity rule provides that a sum of the timing budgets of any two edges of a cycle is of a same parity as the timing budget of the third edge. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. A method for determining placement of circuit elements comprising the steps of: 
<claim-text>describing a circuit image as a graph comprising circuit elements connected by edges; </claim-text>
<claim-text>assigning a timing budget for each edge using a geometry-aware slack distribution algorithm which satisfies at least one geometric constraint; </claim-text>
<claim-text>generating a timing window region on a placement grid for each edge, said timing window region being equal to or less than the timing budget for the respective edge; and </claim-text>
<claim-text>assigning the circuit elements attached to each edge to each of their respective timing window regions. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein the geometric constraint is a triangle inequality rule or a triangle parity rule. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. A program storage device readable by a machine, tangibly embodying a program of instructions executable by the machine to perform the method steps for placing circuit elements on semiconductor chips, the method comprising the steps of: 
<claim-text>a) creating a circuit graph including cutlines, said circuit graph comprising said circuit elements connected by nets for placement on a placement grid; </claim-text>
<claim-text>b) clustering critical nets in the circuit graph; </claim-text>
<claim-text>c) assigning a timing budget for each net using at least one of a plurality of slack distribution algorithms satisfying at least one geometric constraint; </claim-text>
<claim-text>d) partitioning the circuit graph using a mincut algorithm; </claim-text>
<claim-text>e) generating a timing window region on the placement grid for each net which is less than or equal to each net&apos;s respective timing budget; and </claim-text>
<claim-text>f) assigning the circuit elements attached to each net to each of their respective timing window regions. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The program storage device of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, wherein the geometric constraint is a triangle inequality rule or a triangle parity rule. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The program storage device of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, wherein the step of partitioning further comprises: 
<claim-text>performing a connectivity aware slack reassignment on the circuit graph to assign densely connected clusters a lower timing budget and weakly connected clusters a higher timing budget; and </claim-text>
<claim-text>partitioning the circuit graph into four subgraphs to reduce a number of edges crossing cutlines at a first level of hierarchy. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The program storage device of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, wherein the placement grid comprises a plurality of bins for placement of the circuit elements, and channels for placement of the nets. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The program storage device of <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference>, wherein the step of assigning a timing budget further comprises using a geometry constrained slack reassignment algorithm for assigning timing budgets which satisfy the triangle inequality rule for every cycle in the circuit graph. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The program storage device of <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference>, wherein the step of assigning a timing budget further comprises using a geometry constrained slack rebudgetting algorithm for assigning timing budgets which satisfy the triangle inequality rule for every cycle in the circuit graph. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The program storage device of <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference>, wherein the step of assigning a timing budget further comprises using a geometry constrained slack rebudgetting algorithm for assigning timing budgets which satisfy the triangle inequality rule and the triangle parity rule. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The program storage device of <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference>, wherein the triangle inequality rule provides that a sum of the timing budgets of any two edges of a cycle is equal to or greater than the timing budget of the third edge. </claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The program storage device of <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference>, wherein the triangle parity rule provides that a sum of the timing budgets of any two edges of a cycle is of a same parity as the timing budget of the third edge.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>1</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005398A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005398A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005398A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005398A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005398A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005398A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030005398A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030005398A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030005398A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00009">
<image id="EMI-D00009" file="US20030005398A1-20030102-D00009.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00010">
<image id="EMI-D00010" file="US20030005398A1-20030102-D00010.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00011">
<image id="EMI-D00011" file="US20030005398A1-20030102-D00011.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00012">
<image id="EMI-D00012" file="US20030005398A1-20030102-D00012.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00013">
<image id="EMI-D00013" file="US20030005398A1-20030102-D00013.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00014">
<image id="EMI-D00014" file="US20030005398A1-20030102-D00014.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00015">
<image id="EMI-D00015" file="US20030005398A1-20030102-D00015.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00016">
<image id="EMI-D00016" file="US20030005398A1-20030102-D00016.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
