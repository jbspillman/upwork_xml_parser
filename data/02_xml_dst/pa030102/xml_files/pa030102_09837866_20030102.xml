<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005009A1-20030102-M00001.NB SYSTEM "US20030005009A1-20030102-M00001.NB" NDATA NB>
<!ENTITY US20030005009A1-20030102-M00001.TIF SYSTEM "US20030005009A1-20030102-M00001.TIF" NDATA TIF>
<!ENTITY US20030005009A1-20030102-M00002.NB SYSTEM "US20030005009A1-20030102-M00002.NB" NDATA NB>
<!ENTITY US20030005009A1-20030102-M00002.TIF SYSTEM "US20030005009A1-20030102-M00002.TIF" NDATA TIF>
<!ENTITY US20030005009A1-20030102-M00003.NB SYSTEM "US20030005009A1-20030102-M00003.NB" NDATA NB>
<!ENTITY US20030005009A1-20030102-M00003.TIF SYSTEM "US20030005009A1-20030102-M00003.TIF" NDATA TIF>
<!ENTITY US20030005009A1-20030102-M00004.NB SYSTEM "US20030005009A1-20030102-M00004.NB" NDATA NB>
<!ENTITY US20030005009A1-20030102-M00004.TIF SYSTEM "US20030005009A1-20030102-M00004.TIF" NDATA TIF>
<!ENTITY US20030005009A1-20030102-M00005.NB SYSTEM "US20030005009A1-20030102-M00005.NB" NDATA NB>
<!ENTITY US20030005009A1-20030102-M00005.TIF SYSTEM "US20030005009A1-20030102-M00005.TIF" NDATA TIF>
<!ENTITY US20030005009A1-20030102-M00006.NB SYSTEM "US20030005009A1-20030102-M00006.NB" NDATA NB>
<!ENTITY US20030005009A1-20030102-M00006.TIF SYSTEM "US20030005009A1-20030102-M00006.TIF" NDATA TIF>
<!ENTITY US20030005009A1-20030102-M00007.NB SYSTEM "US20030005009A1-20030102-M00007.NB" NDATA NB>
<!ENTITY US20030005009A1-20030102-M00007.TIF SYSTEM "US20030005009A1-20030102-M00007.TIF" NDATA TIF>
<!ENTITY US20030005009A1-20030102-M00008.NB SYSTEM "US20030005009A1-20030102-M00008.NB" NDATA NB>
<!ENTITY US20030005009A1-20030102-M00008.TIF SYSTEM "US20030005009A1-20030102-M00008.TIF" NDATA TIF>
<!ENTITY US20030005009A1-20030102-M00009.NB SYSTEM "US20030005009A1-20030102-M00009.NB" NDATA NB>
<!ENTITY US20030005009A1-20030102-M00009.TIF SYSTEM "US20030005009A1-20030102-M00009.TIF" NDATA TIF>
<!ENTITY US20030005009A1-20030102-M00010.NB SYSTEM "US20030005009A1-20030102-M00010.NB" NDATA NB>
<!ENTITY US20030005009A1-20030102-M00010.TIF SYSTEM "US20030005009A1-20030102-M00010.TIF" NDATA TIF>
<!ENTITY US20030005009A1-20030102-M00011.NB SYSTEM "US20030005009A1-20030102-M00011.NB" NDATA NB>
<!ENTITY US20030005009A1-20030102-M00011.TIF SYSTEM "US20030005009A1-20030102-M00011.TIF" NDATA TIF>
<!ENTITY US20030005009A1-20030102-M00012.NB SYSTEM "US20030005009A1-20030102-M00012.NB" NDATA NB>
<!ENTITY US20030005009A1-20030102-M00012.TIF SYSTEM "US20030005009A1-20030102-M00012.TIF" NDATA TIF>
<!ENTITY US20030005009A1-20030102-M00013.NB SYSTEM "US20030005009A1-20030102-M00013.NB" NDATA NB>
<!ENTITY US20030005009A1-20030102-M00013.TIF SYSTEM "US20030005009A1-20030102-M00013.TIF" NDATA TIF>
<!ENTITY US20030005009A1-20030102-M00014.NB SYSTEM "US20030005009A1-20030102-M00014.NB" NDATA NB>
<!ENTITY US20030005009A1-20030102-M00014.TIF SYSTEM "US20030005009A1-20030102-M00014.TIF" NDATA TIF>
<!ENTITY US20030005009A1-20030102-M00015.NB SYSTEM "US20030005009A1-20030102-M00015.NB" NDATA NB>
<!ENTITY US20030005009A1-20030102-M00015.TIF SYSTEM "US20030005009A1-20030102-M00015.TIF" NDATA TIF>
<!ENTITY US20030005009A1-20030102-M00016.NB SYSTEM "US20030005009A1-20030102-M00016.NB" NDATA NB>
<!ENTITY US20030005009A1-20030102-M00016.TIF SYSTEM "US20030005009A1-20030102-M00016.TIF" NDATA TIF>
<!ENTITY US20030005009A1-20030102-M00017.NB SYSTEM "US20030005009A1-20030102-M00017.NB" NDATA NB>
<!ENTITY US20030005009A1-20030102-M00017.TIF SYSTEM "US20030005009A1-20030102-M00017.TIF" NDATA TIF>
<!ENTITY US20030005009A1-20030102-D00000.TIF SYSTEM "US20030005009A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005009A1-20030102-D00001.TIF SYSTEM "US20030005009A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005009A1-20030102-D00002.TIF SYSTEM "US20030005009A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005009A1-20030102-D00003.TIF SYSTEM "US20030005009A1-20030102-D00003.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005009</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09837866</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010417</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F017/10</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>708</class>
<subclass>322000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Least-mean square system with adaptive step size</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Mohammad</given-name>
<family-name>Usman</family-name>
</name>
<residence>
<residence-us>
<city>Mission Viejo</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
</inventors>
<correspondence-address>
<name-1>PATENT METRIX, LLC</name-1>
<name-2></name-2>
<address>
<address-1>14252 CULVER DR. #914</address-1>
<city>IRVINE</city>
<state>CA</state>
<postalcode>92604</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">An adaptive filter based on a recursive algorithm with an adaptive step size is described. The recursive algorithm provides relatively fast convergence without undue computational overhead. In one embodiment, the recursive algorithm has an update similar to LMS where a first gradient is used to compute new filter weights using an adaptation factor. The adaptation factor is computed at each step using one or more estimated gradients. In one embodiment, the gradients are estimated in a region near the current set of filter weights. In one embodiment, the adaptive filter algorithm is used in an echo canceller to reduce the effect of line echo in a modem. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> 1. Field of the Invention </paragraph>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> The invention relates to adaptive filters using a Least-Mean-Square (LMS) optimization with an adaptive step size. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> 2. Description of the Related Art </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> The term &ldquo;filter&rdquo; is often used to describe a signal processing element (hardware or software) that accepts an input signal having desired and undesired components, and that produces an output signal where the undesired components have been wholly or partially removed. Thus, for example, a filter can remove unwanted frequency content, noise, etc. from the input signal. Filters can be classified as linear and nonlinear. A filter is said to be linear of the output signal can be described as is a linear function of the input signal. Otherwise, the filter is nonlinear. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> The design of filters is often approached as an optimization problem. A useful approach to this filter optimization problem is to minimize the mean-square value of an error signal that is defined as the difference between some desired response and the actual filter output. For stationary inputs, the resulting solution is commonly known as the Wiener filter, which is said to be optimum in the mean-square sense. The Weiner filter is inadequate for dealing with situations in which the nonstationary nature of the signal and/or noise is intrinsic to the filter problem. In such situations, the optimum filter has to assume a time-varying form. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> The design of a Weiner filter requires a priori information about the statistics of the data to be processed. This filter is optimum only when the statistical characteristics of the input data mach the a priori information on which the design of the filter is based. When this information is not known completely, however, it may not be possible to design the Wiener filter or else the design may no longer be optimum. When the data to be processed is nonstationary, the Wiener filter is typically replaced by an adaptive filter. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> An adaptive filter is self-designing in that the adaptive filter relies for its operation on a recursive algorithm, which makes it possible for the filter to perform satisfactorily in an environment where complete knowledge of the relevant signal characteristics is not available. The Least-Mean-Square (LMS) type of recursive algorithm often used in adaptive filters often suffer from problems related to slow convergence. The Conjugate Gradient (CG) type of recursive algorithm often used in adaptive filters offer better convergence than the LMS algorithm, but consumes far more computing resources. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> The present invention solves these and other problems by providing a recursive algorithm that provides relatively fast convergence with a relatively light computational burden. In one embodiment, a combined LMS/CG algorithm provides relatively fast convergence with a relatively light computational burden. In one embodiment, the combined LMS/CG algorithm has an update similar to LMS where a first gradient is used to compute new filter weights using an adaptation factor, and like CG, the adaptation factor is computed at each step using one or more gradients or estimated gradients. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> In one embodiment, the LMS/CG algorithm is used in an echo canceller to reduce the effect of line echo in a modem.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> Aspects, features, and advantages of the present invention will be more apparent from the following particular description thereof presented in conjunction with the following drawings, wherein: </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a block diagram of an adaptive filter </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a block diagram of a communication system that uses adaptive filters for echo cancellation. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a functional block diagram of an adaptive filter algorithm that uses an adaptive step size.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> In the drawings, the first digit of any three-digit reference number generally indicates the number of the figure in which the referenced element first appears </paragraph>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT </heading>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> An adaptive filter is a self-designing filter that uses a algorithm, typically a recursive algorithm, to adjust the filter characteristics. The ability to change filter characteristics makes it possible for the adaptive filter to perform satisfactorily in an environment where complete knowledge of the relevant signal characteristics is not available. <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a block diagram of an adaptive filter <highlight><bold>100</bold></highlight>. The adaptive filter <highlight><bold>100</bold></highlight> has a filter input <highlight><bold>101</bold></highlight>, a filter output <highlight><bold>102</bold></highlight>, and an error signal input <highlight><bold>106</bold></highlight>. The filter input <highlight><bold>101</bold></highlight> is provided to an input of a filter <highlight><bold>103</bold></highlight>, and an output of the filter <highlight><bold>103</bold></highlight> is provided to the filter output <highlight><bold>102</bold></highlight>. The error signal <highlight><bold>106</bold></highlight> is provided to an input of a control algorithm <highlight><bold>105</bold></highlight>. Filter configuration data <highlight><bold>104</bold></highlight> is computed by the control algorithm <highlight><bold>105</bold></highlight> and provided to a control input of the filter <highlight><bold>103</bold></highlight>. The filter <highlight><bold>103</bold></highlight> can be an analog filter, a digital filter, or a combination thereof. The configuration data <highlight><bold>104</bold></highlight> specifies, at least in part, the transfer function of the filter <highlight><bold>103</bold></highlight>. For example, if the filter <highlight><bold>103</bold></highlight> is a digital filter, such as a Finite Impulse Response (FIR) filter or an Infinite Impulse Response (IIR) filter, the configuration data <highlight><bold>104</bold></highlight> includes a set of weights that determine the transfer function of the filter <highlight><bold>103</bold></highlight>. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> The control algorithm <highlight><bold>105</bold></highlight> computes the configuration data <highlight><bold>104</bold></highlight> from the error signal by using a control algorithm. The control algorithm is typically a recursive algorithm. The algorithm starts from some predetermined set of initial conditions, representing whatever is known about the environment, and attempts to configure the filter <highlight><bold>103</bold></highlight> to minimize the error signal in some mean-squared sense. In a stationary environment, the control algorithm converges to the optimum Wiener solution. In a nonstationary environment, the algorithm offers a tracking capability, in that it can track time variations in the statistics of the input data, provided that the variations are sufficiently slow. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> As a direct consequence of the application of a recursive algorithm whereby the parameters of an adaptive filter are updated from one iteration to the next, the transfer function of the filter <highlight><bold>103</bold></highlight> becomes time-dependent. This, therefore, means that an adaptive filter is, in reality, a nonlinear device in the sense that it does not obey the principle of superposition. Notwithstanding this property, adaptive filters are commonly classified as linear or nonlinear. An adaptive filter is said to be linear if the estimate of a quantity of interest is computed adaptively at the filter output <highlight><bold>102</bold></highlight> as a linear combination of the available set of observations applied to the filter input <highlight><bold>101</bold></highlight> for a given set of configuration data <highlight><bold>104</bold></highlight>. In other words, the adaptive filter <highlight><bold>100</bold></highlight> is said to be linear if, for a given set of configuration data <highlight><bold>104</bold></highlight>, the output <highlight><bold>102</bold></highlight> is linearly related to the input <highlight><bold>101</bold></highlight>. Otherwise, the adaptive filter is said to be nonlinear. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> There always exist trade-offs between speed of convergence, stability, and performance of an adaptive filter. While stability of an algorithm is an important consideration, it is also typically important that the algorithm has fast convergence and high SNR. This is important in modems (such as the modems shown in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>) where only a certain amount of time, and therefore number of samples of training data, are available during which convergence should be achieved. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> The choice of the control algorithm <highlight><bold>105</bold></highlight> is based, at least in part, on issues relating to rate of convergence, tracking, robustness, computational requirements, and numerical properties. Rate of convergence is defined as the number of iterations required for the control algorithm <highlight><bold>105</bold></highlight>, in response to stationary inputs, to converge (at least approximately) to the optimum Wiener solution in the mean-square sense. A fast rate of convergence allows the control algorithm <highlight><bold>105</bold></highlight> to adapt rapidly to a stationary environment of unknown statistics. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> When the adaptive filter <highlight><bold>100</bold></highlight> operates in a nonstationary environment, the control algorithm <highlight><bold>105</bold></highlight> is required to track statistical variations in the environment. The tracking performance of the control algorithm <highlight><bold>105</bold></highlight>, however, is influenced by two contradictory features: (1) the rate of convergence, and (2) steady-state fluctuation due to algorithm noise. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> If the adaptive filter <highlight><bold>100</bold></highlight> is robust, then small disturbances (i.e. disturbances with small energy) can only result in small errors in the control algorithm <highlight><bold>105</bold></highlight>. The disturbances can arise from factors external to the filter <highlight><bold>100</bold></highlight> and from factors internal to the filter <highlight><bold>100</bold></highlight>. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> The computational requirements of the control algorithm <highlight><bold>105</bold></highlight> include: (a) the number of operations (i.e. multiplications, divisions, additions, and subtractions) required to make one complete iteration of the algorithm; (b) the amount of memory needed to store the control algorithm program and its data; and (c) the engineering investment required to program the algorithm. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> When the algorithm <highlight><bold>105</bold></highlight> is implemented digitally, inaccuracies are produced due to quantization errors. The quantization errors are due to analog-to-digital conversion of the input data and digital representation of internal calculations. In particular, there are two areas of concern: numerical stability and numerical accuracy. Numerical stability (or lack thereof) is an inherent characteristic of an adaptive filtering algorithm. Numerical accuracy, on the other hand, is determined by the word length used in the numerical calculations. An adaptive filtering algorithm is said to be numerically robust when it is relatively insensitive to variations in the word length used in its digital implementation. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> The Least Mean-Squared (LMS) algorithm is widely used in applications such as the control algorithm <highlight><bold>105</bold></highlight> because of its simplicity and relatively light computational burden. However, the LMS algorithm has two major disadvantages. First, it requires specification of an adaptation coefficient, &mgr;, which is typically given by the user and adjusted when close to convergence for a better Signal-to-Noise Ratio (SNR). Second, the LMS algorithm exhibits slow convergence. The parameter &mgr;, which controls the speed of convergence, is usually found by trial-and-error methods. Although, an upper bound for &mgr; can be computed, use of the upper bound does not guarantee the best possible convergence. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> An alternative to the LMS is conjugate gradient (CG) method. For an n-dimensional problem (i.e., an n-tap filter) CG guarantees convergence in n steps given infinite precision. Unfortunately, the CG method requires specification of a matrix to be inverted. For most applications, this matrix is not easily specified and can only be estimated. For instance in modems, the matrix to be inverted is the auto-correlation matrix of the input data. Estimation of this matrix is not only computationally expensive, but it also affects the convergence properties of the CG method and frequently causes the algorithm to diverge. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> In one embodiment, the control algorithm <highlight><bold>105</bold></highlight> is based on a modified algorithm that uses the best properties of the CG method and the LMS method. The modified algorithm avoids an explicit specification of &mgr; by using a CG-like step, but the modified algorithm uses an LMS-like update procedure to avoid the need for a CG matrix. Since the modified algorithm is based on properties of the LMS method and the CG method, it is useful to first develop expressions for both of these methods. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> In the LMS method, given an input vector {overscore (u)}, and a vector of filter coefficients or weights, {overscore (w)} then the minimum mean-squared error function can be written as: </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>J</italic></highlight>({overscore (<highlight><italic>w</italic></highlight>)})&equals;&sgr;<highlight><subscript>d</subscript></highlight><highlight><superscript>2</superscript></highlight><highlight><italic>&minus;{overscore (w)}</italic></highlight><highlight><superscript>H</superscript></highlight><highlight><italic>{overscore (p)}&minus;{overscore (p)}</italic></highlight><highlight><superscript>H</superscript></highlight><highlight><italic>{overscore (w)}&plus;R{overscore (w)}, </italic></highlight></in-line-formula></paragraph>
<paragraph id="P-0028" lvl="7"><number>&lsqb;0028&rsqb;</number> where &sgr;<highlight><subscript>d</subscript></highlight><highlight><superscript>2 </superscript></highlight>is the variance of the desired signal d(k), R is the auto-correlation matrix of the input signal {overscore (u)}, and {overscore (p)} is the cross-correlation between the desired signal d(k) and input {overscore (u)}. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> The minimum value of J({overscore (w)}) is:  
<math-cwu id="MATH-US-00001">
<number>1</number>
<math>
<mrow>
  <mrow>
    <munder>
      <mi>min</mi>
      <mover>
        <mi>&omega;</mi>
        <mi>_</mi>
      </mover>
    </munder>
    <mo>&it;</mo>
    <mrow>
      <mi>J</mi>
      <mo>&af;</mo>
      <mrow>
        <mo>(</mo>
        <mover>
          <mi>w</mi>
          <mi>_</mi>
        </mover>
        <mo>)</mo>
      </mrow>
    </mrow>
  </mrow>
  <mo>=</mo>
  <mrow>
    <msubsup>
      <mi>&sigma;</mi>
      <mi>d</mi>
      <mn>2</mn>
    </msubsup>
    <mo>-</mo>
    <mrow>
      <msup>
        <mover>
          <mi>p</mi>
          <mi>_</mi>
        </mover>
        <mi>H</mi>
      </msup>
      <mo>&it;</mo>
      <mi>R</mi>
      <mo>&it;</mo>
      <mover>
        <mi>p</mi>
        <mi>_</mi>
      </mover>
    </mrow>
  </mrow>
</mrow>
</math>
<mathematica-file id="MATHEMATICA-00001" file="US20030005009A1-20030102-M00001.NB"/>
<image id="EMI-M00001" wi="216.027" he="15.11055" file="US20030005009A1-20030102-M00001.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0030" lvl="7"><number>&lsqb;0030&rsqb;</number> for </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>{overscore (w)}</italic></highlight><highlight><subscript>optimal</subscript></highlight><highlight><italic>&equals;R</italic></highlight><highlight><superscript>&minus;1</superscript></highlight><highlight><italic>{overscore (p)}. </italic></highlight></in-line-formula></paragraph>
<paragraph id="P-0031" lvl="7"><number>&lsqb;0031&rsqb;</number> Here, {overscore (w)}<highlight><subscript>optimal </subscript></highlight>are the optimal weight of the filter in mean-squared sense. In LMS, the following update is used for the filter weights:  
<math-cwu id="MATH-US-00002">
<number>2</number>
<math>
<mtable>
  <mtr>
    <mtd>
      <mrow>
        <mrow>
          <msub>
            <mover>
              <mi>w</mi>
              <mi>_</mi>
            </mover>
            <mrow>
              <mi>n</mi>
              <mo>+</mo>
              <mn>1</mn>
            </mrow>
          </msub>
          <mo>=</mo>
          <mrow>
            <msub>
              <mover>
                <mi>w</mi>
                <mi>_</mi>
              </mover>
              <mi>n</mi>
            </msub>
            <mo>+</mo>
            <mrow>
              <mfrac>
                <mi>&mu;</mi>
                <mn>2</mn>
              </mfrac>
              <mo>&it;</mo>
              <mrow>
                <mo>&Del;</mo>
                <mi>J</mi>
              </mrow>
            </mrow>
          </mrow>
        </mrow>
        <mo>,</mo>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mo>(</mo>
        <mn>1</mn>
        <mo>)</mo>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
<mathematica-file id="MATHEMATICA-00002" file="US20030005009A1-20030102-M00002.NB"/>
<image id="EMI-M00002" wi="216.027" he="16.07445" file="US20030005009A1-20030102-M00002.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0032" lvl="7"><number>&lsqb;0032&rsqb;</number> where &nabla;J is the gradient of J:  
<math-cwu id="MATH-US-00003">
<number>3</number>
<math>
<mrow>
  <mrow>
    <mrow>
      <mo>&Del;</mo>
      <mi>J</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
      <mn>2</mn>
      <mo>&it;</mo>
      <mrow>
        <mi>E</mi>
        <mo>&af;</mo>
        <mrow>
          <mo>[</mo>
          <mrow>
            <msubsup>
              <mover>
                <mi>u</mi>
                <mi>_</mi>
              </mover>
              <mi>k</mi>
              <mi>H</mi>
            </msubsup>
            <mo>&it;</mo>
            <mrow>
              <mo>{</mo>
              <mrow>
                <mrow>
                  <mi>d</mi>
                  <mo>&af;</mo>
                  <mrow>
                    <mo>(</mo>
                    <mi>k</mi>
                    <mo>)</mo>
                  </mrow>
                </mrow>
                <mo>-</mo>
                <mrow>
                  <msubsup>
                    <mover>
                      <mi>w</mi>
                      <mi>_</mi>
                    </mover>
                    <mi>k</mi>
                    <mi>T</mi>
                  </msubsup>
                  <mo>&it;</mo>
                  <msub>
                    <mover>
                      <mi>u</mi>
                      <mi>_</mi>
                    </mover>
                    <mi>k</mi>
                  </msub>
                </mrow>
              </mrow>
              <mo>}</mo>
            </mrow>
          </mrow>
          <mo>]</mo>
        </mrow>
      </mrow>
    </mrow>
  </mrow>
  <mo>,</mo>
</mrow>
</math>
<mathematica-file id="MATHEMATICA-00003" file="US20030005009A1-20030102-M00003.NB"/>
<image id="EMI-M00003" wi="216.027" he="11.02815" file="US20030005009A1-20030102-M00003.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0033" lvl="7"><number>&lsqb;0033&rsqb;</number> where E denotes a statistical expectation. The term in braces in the above equation is the error between the desired and estimated signal, which can be defined as:  
<math-cwu id="MATH-US-00004">
<number>4</number>
<math>
<mrow>
  <mrow>
    <mi>e</mi>
    <mo>&af;</mo>
    <mrow>
      <mo>(</mo>
      <mi>k</mi>
      <mo>)</mo>
    </mrow>
  </mrow>
  <mo>=</mo>
  <mrow>
    <mo>(</mo>
    <mrow>
      <mrow>
        <mi>d</mi>
        <mo>&af;</mo>
        <mrow>
          <mo>(</mo>
          <mi>k</mi>
          <mo>)</mo>
        </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
        <msubsup>
          <mover>
            <mi>w</mi>
            <mi>_</mi>
          </mover>
          <mi>k</mi>
          <mi>T</mi>
        </msubsup>
        <mo>&it;</mo>
        <msub>
          <mover>
            <mi>u</mi>
            <mi>_</mi>
          </mover>
          <mi>k</mi>
        </msub>
      </mrow>
    </mrow>
    <mo>)</mo>
  </mrow>
</mrow>
</math>
<mathematica-file id="MATHEMATICA-00004" file="US20030005009A1-20030102-M00004.NB"/>
<image id="EMI-M00004" wi="216.027" he="11.02815" file="US20030005009A1-20030102-M00004.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0034" lvl="7"><number>&lsqb;0034&rsqb;</number> In LMS, the statistical expectation is estimated by the instantaneous value of the gradient. Therefore: </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>{overscore (w)}</italic></highlight><highlight><subscript>k&plus;1</subscript></highlight><highlight><italic>&equals;{overscore (w)}</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><italic>&plus;&mgr;e</italic></highlight>(<highlight><italic>n</italic></highlight>) <highlight><italic>{overscore (u)}</italic></highlight><highlight><subscript>k</subscript></highlight>,&emsp;&emsp;(2) </in-line-formula></paragraph>
<paragraph id="P-0035" lvl="7"><number>&lsqb;0035&rsqb;</number> It has been shown that the proper choice of &mgr; should be:  
<math-cwu id="MATH-US-00005">
<number>5</number>
<math>
<mrow>
  <mrow>
    <mn>0</mn>
    <mo>&lt;</mo>
    <mi>&mu;</mi>
    <mo>&lt;</mo>
    <mfrac>
      <mn>2</mn>
      <msub>
        <mi>&lambda;</mi>
        <mi>max</mi>
      </msub>
    </mfrac>
  </mrow>
  <mo>,</mo>
</mrow>
</math>
<mathematica-file id="MATHEMATICA-00005" file="US20030005009A1-20030102-M00005.NB"/>
<image id="EMI-M00005" wi="216.027" he="18.00225" file="US20030005009A1-20030102-M00005.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0036" lvl="7"><number>&lsqb;0036&rsqb;</number> where &mgr;<highlight><subscript>max </subscript></highlight>is the maximum eigenvalue of the auto-correlation matrix R. Since R is not known and, therefore, &mgr;<highlight><subscript>max </subscript></highlight>is not known, one cannot necessarily choose a good value of &mgr;. In practice, a value for &mgr; is usually chosen by trial-and-error. The value of &mgr; affects the filter performance. Smaller values of &mgr; give higher signal-to-noise ratio but take more time to converge. Usually, a designer starts with a relatively large value of &mgr; for fast initial convergence, and then chooses a smaller value for high SNR. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> Conjugate gradient methods are computationally more expensive than LMS methods, but converge much faster. Conjugate gradient methods have been formulated for a purely quadratic problem as follows:  
<math-cwu id="MATH-US-00006">
<number>6</number>
<math>
<mtable>
  <mtr>
    <mtd>
      <mrow>
        <mrow>
          <munder>
            <mi>min</mi>
            <mover>
              <mi>&omega;</mi>
              <mi>_</mi>
            </mover>
          </munder>
          <mo>&it;</mo>
          <mrow>
            <mo>(</mo>
            <mrow>
              <mrow>
                <mfrac>
                  <mn>1</mn>
                  <mn>2</mn>
                </mfrac>
                <mo>&it;</mo>
                <msup>
                  <mover>
                    <mi>w</mi>
                    <mi>_</mi>
                  </mover>
                  <mi>H</mi>
                </msup>
                <mo>&it;</mo>
                <mi>R</mi>
                <mo>&it;</mo>
                <mover>
                  <mi>w</mi>
                  <mi>_</mi>
                </mover>
              </mrow>
              <mo>-</mo>
              <mrow>
                <msup>
                  <mover>
                    <mi>p</mi>
                    <mi>_</mi>
                  </mover>
                  <mi>T</mi>
                </msup>
                <mo>&it;</mo>
                <mover>
                  <mi>w</mi>
                  <mi>_</mi>
                </mover>
              </mrow>
            </mrow>
            <mo>)</mo>
          </mrow>
        </mrow>
        <mo>,</mo>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mo>(</mo>
        <mn>3</mn>
        <mo>)</mo>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
<mathematica-file id="MATHEMATICA-00006" file="US20030005009A1-20030102-M00006.NB"/>
<image id="EMI-M00006" wi="216.027" he="18.96615" file="US20030005009A1-20030102-M00006.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0038" lvl="7"><number>&lsqb;0038&rsqb;</number> where R is a positive definite matrix. To find the above minimum, take the gradient with respect to {overscore (w)}: </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>&nabla;f</italic></highlight>(<highlight><italic>{overscore (w)}</italic></highlight>)&equals;<highlight><italic>R{overscore (w)}&minus;{overscore (p)}&equals;</italic></highlight>0 </in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>R{overscore (w)}&equals;{overscore (p)}. </italic></highlight></in-line-formula></paragraph>
<paragraph id="P-0039" lvl="7"><number>&lsqb;0039&rsqb;</number> Therefore, finding the minimum of equation (3) is equivalent to solving R{overscore (w)}&equals;{overscore (p)}. To solve this equation, find direction vectors {overscore (d)} and step size a such that {overscore (d)}<highlight><subscript>i</subscript></highlight>, is R-conjugate to {overscore (d)}<highlight><subscript>j</subscript></highlight>, i&ne;j. R-conjugate is defined as: </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>{overscore (d)}</italic></highlight><highlight><subscript>i</subscript></highlight><highlight><superscript>T</superscript></highlight><highlight><italic>R{overscore (d)}</italic></highlight><highlight><subscript>j</subscript></highlight>&equals;0, <highlight><italic>i&ne;j.</italic></highlight>&emsp;&emsp;(4) </in-line-formula></paragraph>
<paragraph id="P-0040" lvl="7"><number>&lsqb;0040&rsqb;</number> If the condition in equation (4) is fulfilled, then for an n-dimensional system the optimal solution that satisfies (3) is: </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>{overscore (w)}</italic></highlight><highlight><subscript>optimal</subscript></highlight>&equals;&agr;<highlight><subscript>0</subscript></highlight><highlight><italic>{overscore (d)}</italic></highlight><highlight><subscript>0</subscript></highlight>&plus;&agr;<highlight><subscript>1</subscript></highlight><highlight><italic>{overscore (d)}</italic></highlight><highlight><subscript>1</subscript></highlight>&plus; . . . &agr;&agr;<highlight><subscript>n&minus;1</subscript></highlight><highlight><italic>{overscore (d)}</italic></highlight><highlight><subscript>n&minus;1</subscript></highlight>. </in-line-formula></paragraph>
<paragraph id="P-0041" lvl="7"><number>&lsqb;0041&rsqb;</number> This implies that, given infinite precision, CG is guaranteed to converge within n iterations. There are, however, some problems. First, infinite precision is not available on computers. This becomes an issue when R is ill conditioned or has a high condition number. Second, the standard CG algorithm is applied to quadratic problems. A more general algorithm would also treat non-quadratic problems. Finally, in many circumstances, R is not given and needs to be estimated. If the estimate for R is poor, then the system is typically unstable and will fail to converge. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> The conjugate gradient algorithm for a general non-quadratic problem can be derived by using quadratic method or the method of Fletcher-Reeves, but these require knowledge of the Hessian of the functional f({overscore (w)}) at {overscore (w)}k. The functional f({overscore (w)}) is given by:  
<math-cwu id="MATH-US-00007">
<number>7</number>
<math>
<mrow>
  <mrow>
    <mi>f</mi>
    <mo>&af;</mo>
    <mrow>
      <mo>(</mo>
      <mover>
        <mi>w</mi>
        <mi>_</mi>
      </mover>
      <mo>)</mo>
    </mrow>
  </mrow>
  <mo>=</mo>
  <mrow>
    <mrow>
      <mo>(</mo>
      <mrow>
        <mrow>
          <mfrac>
            <mn>1</mn>
            <mn>2</mn>
          </mfrac>
          <mo>&it;</mo>
          <msup>
            <mover>
              <mi>w</mi>
              <mi>_</mi>
            </mover>
            <mi>H</mi>
          </msup>
          <mo>&it;</mo>
          <mi>R</mi>
          <mo>&it;</mo>
          <mover>
            <mi>w</mi>
            <mi>_</mi>
          </mover>
        </mrow>
        <mo>-</mo>
        <mrow>
          <msup>
            <mover>
              <mi>p</mi>
              <mi>_</mi>
            </mover>
            <mi>T</mi>
          </msup>
          <mo>&it;</mo>
          <mover>
            <mi>w</mi>
            <mi>_</mi>
          </mover>
        </mrow>
      </mrow>
      <mo>)</mo>
    </mrow>
    <mo>.</mo>
  </mrow>
</mrow>
</math>
<mathematica-file id="MATHEMATICA-00007" file="US20030005009A1-20030102-M00007.NB"/>
<image id="EMI-M00007" wi="216.027" he="18.00225" file="US20030005009A1-20030102-M00007.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> An alternate technique is to solve the general problem that does not require computation of the Hessian as follows. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> Given g<highlight><subscript>k</subscript></highlight>&equals;&nabla;f<highlight><superscript>T</superscript></highlight>({overscore (w)}<highlight><subscript>k</subscript></highlight>), it can be shown that {overscore (d)}<highlight><subscript>k</subscript></highlight><highlight><superscript>T </superscript></highlight>R{overscore (d)}<highlight><subscript>k</subscript></highlight>&equals;{overscore (d)}<highlight><subscript>k</subscript></highlight><highlight><superscript>T </superscript></highlight>R{overscore (g)}<highlight><subscript>k</subscript></highlight>. Therefore, in order to obtain {overscore (w)}<highlight><subscript>k&plus;1 </subscript></highlight>from {overscore (w)}<highlight><subscript>k </subscript></highlight>one only needs to use R to evaluate {overscore (g)} and R{overscore (g)}<highlight><subscript>k</subscript></highlight>. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> To evaluate R{overscore (g)}<highlight><subscript>k</subscript></highlight>, assume that the problem is quadratic, and take a unit from {overscore (w)} step in the direction of the negative gradient and evaluate the function at that point. Therefore, let: </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>{overscore (y)}</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><italic>&equals;{overscore (w)}</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><italic>&minus;{overscore (g)}</italic></highlight><highlight><subscript>k</subscript></highlight>, </in-line-formula></paragraph>
<paragraph id="P-0046" lvl="7"><number>&lsqb;0046&rsqb;</number> from which, </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>{overscore (g)}</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><italic>&equals;&nabla;f</italic></highlight><highlight><superscript>T</superscript></highlight>(<highlight><italic>{overscore (w)}</italic></highlight><highlight><subscript>k</subscript></highlight>)&equals;<highlight><italic>R{overscore (w)}</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><italic>&minus;{overscore (p)}</italic></highlight></in-line-formula></paragraph>
<paragraph id="P-0047" lvl="7"><number>&lsqb;0047&rsqb;</number> Define {overscore (h)} as: </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>{overscore (h)}</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><italic>&equals;&nabla;f</italic></highlight><highlight><superscript>T</superscript></highlight>(<highlight><italic>{overscore (y)}</italic></highlight><highlight><subscript>k</subscript></highlight>)&equals;<highlight><italic>R{overscore (y)}</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><italic>&minus;{overscore (p)}</italic></highlight></in-line-formula></paragraph>
<paragraph id="P-0048" lvl="7"><number>&lsqb;0048&rsqb;</number> It follows from the above equations that:  
<math-cwu id="MATH-US-00008">
<number>8</number>
<math>
<mtable>
  <mtr>
    <mtd>
      <mrow>
        <msub>
          <mover>
            <mi>h</mi>
            <mi>_</mi>
          </mover>
          <mi>k</mi>
        </msub>
        <mo>=</mo>
        <mrow>
          <mrow>
            <mi>R</mi>
            <mo>&it;</mo>
            <msub>
              <mover>
                <mi>y</mi>
                <mi>_</mi>
              </mover>
              <mi>k</mi>
            </msub>
          </mrow>
          <mo>-</mo>
          <mover>
            <mi>p</mi>
            <mi>_</mi>
          </mover>
        </mrow>
      </mrow>
    </mtd>
  </mtr>
  <mtr>
    <mtd>
      <mrow>
        <mo>=</mo>
        <mrow>
          <mrow>
            <mi>R</mi>
            <mo>&it;</mo>
            <msub>
              <mover>
                <mi>w</mi>
                <mi>_</mi>
              </mover>
              <mi>k</mi>
            </msub>
          </mrow>
          <mo>-</mo>
          <mrow>
            <mi>R</mi>
            <mo>&it;</mo>
            <msub>
              <mover>
                <mi>g</mi>
                <mi>_</mi>
              </mover>
              <mi>k</mi>
            </msub>
          </mrow>
          <mo>-</mo>
          <mover>
            <mi>p</mi>
            <mi>_</mi>
          </mover>
        </mrow>
      </mrow>
    </mtd>
  </mtr>
  <mtr>
    <mtd>
      <mrow>
        <mo>=</mo>
        <mrow>
          <msub>
            <mover>
              <mi>g</mi>
              <mi>_</mi>
            </mover>
            <mi>k</mi>
          </msub>
          <mo>-</mo>
          <mrow>
            <mi>R</mi>
            <mo>&it;</mo>
            <mrow>
              <msub>
                <mover>
                  <mi>g</mi>
                  <mi>_</mi>
                </mover>
                <mi>k</mi>
              </msub>
              <mo>.</mo>
            </mrow>
          </mrow>
        </mrow>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
<mathematica-file id="MATHEMATICA-00008" file="US20030005009A1-20030102-M00008.NB"/>
<image id="EMI-M00008" wi="216.027" he="34.0767" file="US20030005009A1-20030102-M00008.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0049" lvl="7"><number>&lsqb;0049&rsqb;</number> Hence, </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>R{overscore (g)}</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><italic>&equals;{overscore (w)}</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><italic>&minus;{overscore (h)}</italic></highlight><highlight><subscript>k </subscript></highlight></in-line-formula></paragraph>
<paragraph id="P-0050" lvl="7"><number>&lsqb;0050&rsqb;</number> Given the above equation, a modified CG algorithm that does not require knowledge of a Hessian or a line search is given below. Step 1: </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> Starting with any value of {overscore (w)}<highlight><subscript>0 </subscript></highlight>compute: </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>{overscore (g)}</italic></highlight><highlight><subscript>0</subscript></highlight><highlight><italic>&equals;&nabla;f </italic></highlight><highlight><superscript>T</superscript></highlight>(<highlight><italic>{overscore (w)}</italic></highlight><highlight><subscript>0</subscript></highlight>) </in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>{overscore (y)}</italic></highlight><highlight><subscript>0</subscript></highlight>&equals;{overscore (&ohgr;)}<highlight><subscript>0</subscript></highlight><highlight><italic>&minus;{overscore (g)}</italic></highlight><highlight><subscript>0 </subscript></highlight></in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>{overscore (h)}</italic></highlight><highlight><subscript>0</subscript></highlight><highlight><italic>&equals;&nabla;f</italic></highlight><highlight><superscript>T</superscript></highlight>(<highlight><italic>{overscore (y)}</italic></highlight><highlight><subscript>0</subscript></highlight>) </in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>{overscore (d)}</italic></highlight><highlight><subscript>0</subscript></highlight><highlight><italic>&equals;&minus;{overscore (g)}</italic></highlight><highlight><subscript>0 </subscript></highlight></in-line-formula></paragraph>
<paragraph id="P-0052" lvl="7"><number>&lsqb;0052&rsqb;</number> Step 2: </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> For k&equals;0, 1, . . . , n&minus;1 do  
<math-cwu id="MATH-US-00009">
<number>9</number>
<math>
<mtable>
  <mtr>
    <mtd>
      <mrow>
        <msub>
          <mi>&alpha;</mi>
          <mi>k</mi>
        </msub>
        <mo>=</mo>
        <mfrac>
          <mrow>
            <msubsup>
              <mover>
                <mi>g</mi>
                <mi>_</mi>
              </mover>
              <mi>k</mi>
              <mi>T</mi>
            </msubsup>
            <mo>&it;</mo>
            <msub>
              <mover>
                <mi>d</mi>
                <mi>_</mi>
              </mover>
              <mi>k</mi>
            </msub>
          </mrow>
          <mrow>
            <msubsup>
              <mover>
                <mi>d</mi>
                <mi>_</mi>
              </mover>
              <mi>k</mi>
              <mi>T</mi>
            </msubsup>
            <mo>&af;</mo>
            <mrow>
              <mo>(</mo>
              <mrow>
                <msub>
                  <mover>
                    <mi>g</mi>
                    <mi>_</mi>
                  </mover>
                  <mi>k</mi>
                </msub>
                <mo>-</mo>
                <msub>
                  <mover>
                    <mi>h</mi>
                    <mi>_</mi>
                  </mover>
                  <mi>k</mi>
                </msub>
              </mrow>
              <mo>)</mo>
            </mrow>
          </mrow>
        </mfrac>
      </mrow>
    </mtd>
  </mtr>
  <mtr>
    <mtd>
      <mrow>
        <msub>
          <mover>
            <mi>w</mi>
            <mi>_</mi>
          </mover>
          <mrow>
            <mi>k</mi>
            <mo>+</mo>
            <mn>1</mn>
          </mrow>
        </msub>
        <mo>=</mo>
        <mrow>
          <msub>
            <mover>
              <mi>w</mi>
              <mi>_</mi>
            </mover>
            <mi>k</mi>
          </msub>
          <mo>+</mo>
          <mrow>
            <msub>
              <mi>&alpha;</mi>
              <mi>k</mi>
            </msub>
            <mo>&it;</mo>
            <msub>
              <mover>
                <mi>d</mi>
                <mi>_</mi>
              </mover>
              <mi>k</mi>
            </msub>
          </mrow>
        </mrow>
      </mrow>
    </mtd>
  </mtr>
  <mtr>
    <mtd>
      <mrow>
        <msub>
          <mover>
            <mi>g</mi>
            <mi>_</mi>
          </mover>
          <mrow>
            <mi>k</mi>
            <mo>+</mo>
            <mn>1</mn>
          </mrow>
        </msub>
        <mo>=</mo>
        <mrow>
          <mrow>
            <mrow>
              <mo>&Del;</mo>
              <msup>
                <mi>f</mi>
                <mi>T</mi>
              </msup>
            </mrow>
            <mo>&it;</mo>
            <msub>
              <mover>
                <mi>g</mi>
                <mi>_</mi>
              </mover>
              <mrow>
                <mi>k</mi>
                <mo>+</mo>
                <mn>1</mn>
              </mrow>
            </msub>
          </mrow>
          <mo>=</mo>
          <mrow>
            <mfrac>
              <mn>2</mn>
              <msub>
                <mi>n</mi>
                <mi>w</mi>
              </msub>
            </mfrac>
            <mo>&it;</mo>
            <mrow>
              <munderover>
                <mo>&Sum;</mo>
                <mrow>
                  <mi>j</mi>
                  <mo>=</mo>
                  <mrow>
                    <mi>k</mi>
                    <mo>-</mo>
                    <msub>
                      <mi>n</mi>
                      <mi>w</mi>
                    </msub>
                    <mo>+</mo>
                    <mn>1</mn>
                  </mrow>
                </mrow>
                <mi>k</mi>
              </munderover>
              <mo>&it;</mo>
              <mstyle>
                <mtext>&emsp;</mtext>
              </mstyle>
              <mo>&it;</mo>
              <mrow>
                <mrow>
                  <mo>(</mo>
                  <mrow>
                    <mrow>
                      <msubsup>
                        <mover>
                          <mi>w</mi>
                          <mi>_</mi>
                        </mover>
                        <mi>k</mi>
                        <mi>T</mi>
                      </msubsup>
                      <mo>&it;</mo>
                      <msub>
                        <mover>
                          <mi>u</mi>
                          <mi>_</mi>
                        </mover>
                        <mi>k</mi>
                      </msub>
                    </mrow>
                    <mo>-</mo>
                    <mrow>
                      <mi>r</mi>
                      <mo>&af;</mo>
                      <mrow>
                        <mo>(</mo>
                        <mi>j</mi>
                        <mo>)</mo>
                      </mrow>
                    </mrow>
                  </mrow>
                  <mo>)</mo>
                </mrow>
                <mo>&it;</mo>
                <mrow>
                  <mover>
                    <mi>u</mi>
                    <mi>_</mi>
                  </mover>
                  <mo>&af;</mo>
                  <mrow>
                    <mo>(</mo>
                    <mi>j</mi>
                    <mo>)</mo>
                  </mrow>
                </mrow>
              </mrow>
            </mrow>
          </mrow>
        </mrow>
      </mrow>
    </mtd>
  </mtr>
  <mtr>
    <mtd>
      <mrow>
        <msub>
          <mover>
            <mi>y</mi>
            <mi>_</mi>
          </mover>
          <mrow>
            <mi>k</mi>
            <mo>+</mo>
            <mn>1</mn>
          </mrow>
        </msub>
        <mo>=</mo>
        <mrow>
          <msub>
            <mover>
              <mi>w</mi>
              <mi>_</mi>
            </mover>
            <mrow>
              <mi>k</mi>
              <mo>+</mo>
              <mn>1</mn>
            </mrow>
          </msub>
          <mo>-</mo>
          <msub>
            <mover>
              <mi>g</mi>
              <mi>_</mi>
            </mover>
            <mrow>
              <mi>k</mi>
              <mo>+</mo>
              <mn>1</mn>
            </mrow>
          </msub>
        </mrow>
      </mrow>
    </mtd>
  </mtr>
  <mtr>
    <mtd>
      <mrow>
        <msub>
          <mover>
            <mi>h</mi>
            <mi>_</mi>
          </mover>
          <mrow>
            <mi>k</mi>
            <mo>+</mo>
            <mn>1</mn>
          </mrow>
        </msub>
        <mo>=</mo>
        <mrow>
          <mrow>
            <mrow>
              <mo>&Del;</mo>
              <msup>
                <mi>f</mi>
                <mi>T</mi>
              </msup>
            </mrow>
            <mo>&it;</mo>
            <msub>
              <mover>
                <mi>y</mi>
                <mi>_</mi>
              </mover>
              <mrow>
                <mi>k</mi>
                <mo>+</mo>
                <mn>1</mn>
              </mrow>
            </msub>
          </mrow>
          <mo>=</mo>
          <mrow>
            <mfrac>
              <mn>2</mn>
              <msub>
                <mi>n</mi>
                <mi>w</mi>
              </msub>
            </mfrac>
            <mo>&it;</mo>
            <mrow>
              <munderover>
                <mo>&Sum;</mo>
                <mrow>
                  <mi>j</mi>
                  <mo>=</mo>
                  <mrow>
                    <mi>k</mi>
                    <mo>-</mo>
                    <msub>
                      <mi>n</mi>
                      <mi>w</mi>
                    </msub>
                    <mo>+</mo>
                    <mn>1</mn>
                  </mrow>
                </mrow>
                <mi>k</mi>
              </munderover>
              <mo>&it;</mo>
              <mstyle>
                <mtext>&emsp;</mtext>
              </mstyle>
              <mo>&it;</mo>
              <mrow>
                <mrow>
                  <mo>(</mo>
                  <mrow>
                    <mrow>
                      <msubsup>
                        <mover>
                          <mi>y</mi>
                          <mi>_</mi>
                        </mover>
                        <mi>k</mi>
                        <mi>T</mi>
                      </msubsup>
                      <mo>&it;</mo>
                      <msub>
                        <mover>
                          <mi>u</mi>
                          <mi>_</mi>
                        </mover>
                        <mi>k</mi>
                      </msub>
                    </mrow>
                    <mo>-</mo>
                    <mrow>
                      <mi>r</mi>
                      <mo>&af;</mo>
                      <mrow>
                        <mo>(</mo>
                        <mi>j</mi>
                        <mo>)</mo>
                      </mrow>
                    </mrow>
                  </mrow>
                  <mo>)</mo>
                </mrow>
                <mo>&it;</mo>
                <mrow>
                  <mover>
                    <mi>u</mi>
                    <mi>_</mi>
                  </mover>
                  <mo>&af;</mo>
                  <mrow>
                    <mo>(</mo>
                    <mi>j</mi>
                    <mo>)</mo>
                  </mrow>
                </mrow>
              </mrow>
            </mrow>
          </mrow>
        </mrow>
      </mrow>
    </mtd>
  </mtr>
  <mtr>
    <mtd>
      <mrow>
        <msub>
          <mi>&beta;</mi>
          <mi>k</mi>
        </msub>
        <mo>=</mo>
        <mfrac>
          <mrow>
            <msubsup>
              <mover>
                <mi>g</mi>
                <mi>_</mi>
              </mover>
              <mrow>
                <mi>k</mi>
                <mo>+</mo>
                <mn>1</mn>
              </mrow>
              <mi>T</mi>
            </msubsup>
            <mo>&it;</mo>
            <msub>
              <mover>
                <mi>g</mi>
                <mi>_</mi>
              </mover>
              <mrow>
                <mi>k</mi>
                <mo>+</mo>
                <mn>1</mn>
              </mrow>
            </msub>
          </mrow>
          <mrow>
            <msubsup>
              <mover>
                <mi>g</mi>
                <mi>_</mi>
              </mover>
              <mi>k</mi>
              <mi>T</mi>
            </msubsup>
            <mo>&it;</mo>
            <msub>
              <mover>
                <mi>g</mi>
                <mi>_</mi>
              </mover>
              <mi>k</mi>
            </msub>
          </mrow>
        </mfrac>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
<mathematica-file id="MATHEMATICA-00009" file="US20030005009A1-20030102-M00009.NB"/>
<image id="EMI-M00009" wi="216.027" he="126.97965" file="US20030005009A1-20030102-M00009.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0054" lvl="2"><number>&lsqb;0054&rsqb;</number> if k&ne;n </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>{overscore (d)}</italic></highlight><highlight><subscript>k&plus;1</subscript></highlight><highlight><italic>&equals;{overscore (g)}</italic></highlight><highlight><subscript>k&plus;1</subscript></highlight><highlight><italic>&plus;&bgr;</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><italic>{overscore (d)}</italic></highlight><highlight><subscript>k </subscript></highlight></in-line-formula></paragraph>
<paragraph id="P-0055" lvl="2"><number>&lsqb;0055&rsqb;</number> else </paragraph>
<paragraph id="P-0056" lvl="3"><number>&lsqb;0056&rsqb;</number> Replace {overscore (&ohgr;)}<highlight><subscript>0 </subscript></highlight>with {overscore (&ohgr;)}(n) and go to Step 1 end for </paragraph>
<paragraph id="P-0057" lvl="7"><number>&lsqb;0057&rsqb;</number> Where n<highlight><subscript>w </subscript></highlight>is the window size in number of sample points over which the gradient is estimated. Although, the above modified CG method takes care of some of the shortcomings of the original CG method, the modified CG method is often unstable in practice. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> In one embodiment, the control algorithm <highlight><bold>105</bold></highlight> uses an LMS/CG algorithm that uses features from the LMS method and the modified CG method. The LMS/CG algorithm has an update similar to LMS where only the first gradient is used for weights update, and like CG, the adaptation factor, &agr;, is computed at each step using both the gradients, {overscore (g)}, and {overscore (h)}. In the LMS/CG method, filter weights for the filter <highlight><bold>103</bold></highlight> are computed using the update: </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>{overscore (w)}</italic></highlight><highlight><subscript>k&plus;1</subscript></highlight><highlight><italic>&equals;{overscore (w)}</italic></highlight><highlight><subscript>k</subscript></highlight>&plus;&agr;<highlight><subscript>k</subscript></highlight><highlight><italic>{overscore (g)}</italic></highlight><highlight><subscript>k </subscript></highlight></in-line-formula></paragraph>
<paragraph id="P-0059" lvl="7"><number>&lsqb;0059&rsqb;</number> Note that the adaptation constant &mgr; has been replaced by an adaptation factor &agr;<highlight><subscript>k</subscript></highlight>. To compute &agr;<highlight><subscript>k</subscript></highlight>, note that:  
<math-cwu id="MATH-US-00010">
<number>10</number>
<math>
<mrow>
  <msub>
    <mover>
      <mi>g</mi>
      <mi>_</mi>
    </mover>
    <mi>k</mi>
  </msub>
  <mo>=</mo>
  <mrow>
    <mrow>
      <mo>&Del;</mo>
      <mi>J</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
      <mrow>
        <mo>-</mo>
        <mrow>
          <mn>2</mn>
          <mo>&af;</mo>
          <mrow>
            <mo>[</mo>
            <mrow>
              <mrow>
                <mi>r</mi>
                <mo>&af;</mo>
                <mrow>
                  <mo>(</mo>
                  <mi>k</mi>
                  <mo>)</mo>
                </mrow>
              </mrow>
              <mo>-</mo>
              <mrow>
                <msubsup>
                  <mover>
                    <mi>w</mi>
                    <mi>_</mi>
                  </mover>
                  <mi>k</mi>
                  <mi>T</mi>
                </msubsup>
                <mo>&it;</mo>
                <msub>
                  <mover>
                    <mi>u</mi>
                    <mi>_</mi>
                  </mover>
                  <mi>k</mi>
                </msub>
              </mrow>
            </mrow>
            <mo>]</mo>
          </mrow>
        </mrow>
      </mrow>
      <mo>&it;</mo>
      <mrow>
        <msup>
          <mover>
            <mi>u</mi>
            <mi>_</mi>
          </mover>
          <mi>H</mi>
        </msup>
        <mo>&af;</mo>
        <mrow>
          <mo>(</mo>
          <mi>k</mi>
          <mo>)</mo>
        </mrow>
      </mrow>
    </mrow>
  </mrow>
</mrow>
</math>
<mathematica-file id="MATHEMATICA-00010" file="US20030005009A1-20030102-M00010.NB"/>
<image id="EMI-M00010" wi="216.027" he="11.02815" file="US20030005009A1-20030102-M00010.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0060" lvl="7"><number>&lsqb;0060&rsqb;</number> Similarly, </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>{overscore (y)}</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><italic>&equals;{overscore (w)}</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><italic>&minus;{overscore (g)}</italic></highlight><highlight><subscript>k</subscript></highlight>, </in-line-formula></paragraph>
<paragraph id="P-0061" lvl="7"><number>&lsqb;0061&rsqb;</number> and,  
<math-cwu id="MATH-US-00011">
<number>11</number>
<math>
<mrow>
  <msub>
    <mover>
      <mi>h</mi>
      <mi>_</mi>
    </mover>
    <mi>k</mi>
  </msub>
  <mo>=</mo>
  <mrow>
    <mrow>
      <mo>&Del;</mo>
      <mrow>
        <msubsup>
          <mi>f</mi>
          <mi>k</mi>
          <mi>T</mi>
        </msubsup>
        <mo>&af;</mo>
        <mrow>
          <mo>(</mo>
          <msub>
            <mover>
              <mi>y</mi>
              <mi>_</mi>
            </mover>
            <mi>k</mi>
          </msub>
          <mo>)</mo>
        </mrow>
      </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
      <mrow>
        <mrow>
          <mo>-</mo>
          <mrow>
            <mn>2</mn>
            <mo>&af;</mo>
            <mrow>
              <mo>[</mo>
              <mrow>
                <mrow>
                  <mi>r</mi>
                  <mo>&af;</mo>
                  <mrow>
                    <mo>(</mo>
                    <mi>k</mi>
                    <mo>)</mo>
                  </mrow>
                </mrow>
                <mo>-</mo>
                <mrow>
                  <msubsup>
                    <mover>
                      <mi>y</mi>
                      <mi>_</mi>
                    </mover>
                    <mi>k</mi>
                    <mi>T</mi>
                  </msubsup>
                  <mo>&it;</mo>
                  <msub>
                    <mover>
                      <mi>u</mi>
                      <mi>_</mi>
                    </mover>
                    <mi>k</mi>
                  </msub>
                </mrow>
              </mrow>
              <mo>]</mo>
            </mrow>
          </mrow>
        </mrow>
        <mo>&it;</mo>
        <mrow>
          <msup>
            <mover>
              <mi>u</mi>
              <mi>_</mi>
            </mover>
            <mi>H</mi>
          </msup>
          <mo>&af;</mo>
          <mrow>
            <mo>(</mo>
            <mi>k</mi>
            <mo>)</mo>
          </mrow>
        </mrow>
      </mrow>
      <mo>&it;</mo>
      <mstyle>
        <mtext>&NewLine;</mtext>
      </mstyle>
      <mo>&it;</mo>
      <mstyle>
        <mtext>&emsp;</mtext>
      </mstyle>
      <mo>=</mo>
      <mrow>
        <mrow>
          <mrow>
            <mo>-</mo>
            <mrow>
              <mn>2</mn>
              <mo>&af;</mo>
              <mrow>
                <mo>[</mo>
                <mrow>
                  <mrow>
                    <mi>r</mi>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>(</mo>
                      <mi>k</mi>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                  <mo>-</mo>
                  <mrow>
                    <msup>
                      <mrow>
                        <mo>(</mo>
                        <mrow>
                          <msub>
                            <mover>
                              <mi>w</mi>
                              <mi>_</mi>
                            </mover>
                            <mi>k</mi>
                          </msub>
                          <mo>-</mo>
                          <msub>
                            <mover>
                              <mi>g</mi>
                              <mi>_</mi>
                            </mover>
                            <mi>k</mi>
                          </msub>
                        </mrow>
                        <mo>)</mo>
                      </mrow>
                      <mi>T</mi>
                    </msup>
                    <mo>&it;</mo>
                    <msub>
                      <mover>
                        <mi>u</mi>
                        <mi>_</mi>
                      </mover>
                      <mi>k</mi>
                    </msub>
                  </mrow>
                </mrow>
                <mo>]</mo>
              </mrow>
            </mrow>
          </mrow>
          <mo>&it;</mo>
          <mrow>
            <msup>
              <mover>
                <mi>u</mi>
                <mi>_</mi>
              </mover>
              <mi>H</mi>
            </msup>
            <mo>&af;</mo>
            <mrow>
              <mo>(</mo>
              <mi>k</mi>
              <mo>)</mo>
            </mrow>
          </mrow>
        </mrow>
        <mo>&it;</mo>
        <mstyle>
          <mtext>&NewLine;</mtext>
        </mstyle>
        <mo>&it;</mo>
        <mstyle>
          <mtext>&emsp;</mtext>
        </mstyle>
        <mo>=</mo>
        <mrow>
          <mrow>
            <mo>-</mo>
            <mrow>
              <mn>2</mn>
              <mo>&af;</mo>
              <mrow>
                <mo>[</mo>
                <mrow>
                  <mrow>
                    <mi>r</mi>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>(</mo>
                      <mi>k</mi>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                  <mo>-</mo>
                  <mrow>
                    <msubsup>
                      <mover>
                        <mi>g</mi>
                        <mi>_</mi>
                      </mover>
                      <mi>k</mi>
                      <mi>T</mi>
                    </msubsup>
                    <mo>&it;</mo>
                    <msub>
                      <mover>
                        <mi>u</mi>
                        <mi>_</mi>
                      </mover>
                      <mi>k</mi>
                    </msub>
                  </mrow>
                </mrow>
                <mo>]</mo>
              </mrow>
            </mrow>
          </mrow>
          <mo>&it;</mo>
          <mrow>
            <msup>
              <mover>
                <mi>u</mi>
                <mi>_</mi>
              </mover>
              <mi>H</mi>
            </msup>
            <mo>&af;</mo>
            <mrow>
              <mo>(</mo>
              <mi>k</mi>
              <mo>)</mo>
            </mrow>
          </mrow>
        </mrow>
      </mrow>
    </mrow>
  </mrow>
</mrow>
</math>
<mathematica-file id="MATHEMATICA-00011" file="US20030005009A1-20030102-M00011.NB"/>
<image id="EMI-M00011" wi="216.027" he="33.1128" file="US20030005009A1-20030102-M00011.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0062" lvl="7"><number>&lsqb;0062&rsqb;</number> Where r(k) is a response signal that includes desired components and the error (or noise) components e(k) introduced by a system (e.g., a plant) associated with the adaptive filter. As in the method of steepest descent, only one gradient is used. However, the CG formulation allows the choice of a step size that is not a constant. This step size is optimal if the gradient and the conjugate directions are co-incident. After simple algebraic manipulation, it follows that:  
<math-cwu id="MATH-US-00012">
<number>12</number>
<math>
<mrow>
  <msub>
    <mi>&alpha;</mi>
    <mi>k</mi>
  </msub>
  <mo>=</mo>
  <mrow>
    <mfrac>
      <mrow>
        <msubsup>
          <mover>
            <mi>g</mi>
            <mi>_</mi>
          </mover>
          <mi>k</mi>
          <mi>T</mi>
        </msubsup>
        <mo>&it;</mo>
        <msub>
          <mover>
            <mi>g</mi>
            <mi>_</mi>
          </mover>
          <mi>k</mi>
        </msub>
      </mrow>
      <mrow>
        <msubsup>
          <mover>
            <mi>g</mi>
            <mi>_</mi>
          </mover>
          <mi>k</mi>
          <mi>T</mi>
        </msubsup>
        <mo>&af;</mo>
        <mrow>
          <mo>[</mo>
          <mrow>
            <msub>
              <mover>
                <mi>g</mi>
                <mi>_</mi>
              </mover>
              <mi>k</mi>
            </msub>
            <mo>-</mo>
            <msub>
              <mover>
                <mi>h</mi>
                <mi>_</mi>
              </mover>
              <mi>k</mi>
            </msub>
          </mrow>
          <mo>]</mo>
        </mrow>
      </mrow>
    </mfrac>
    <mo>.</mo>
  </mrow>
</mrow>
</math>
<mathematica-file id="MATHEMATICA-00012" file="US20030005009A1-20030102-M00012.NB"/>
<image id="EMI-M00012" wi="216.027" he="22.08465" file="US20030005009A1-20030102-M00012.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0063" lvl="7"><number>&lsqb;0063&rsqb;</number> Here only the instantaneous estimates of the gradients, {overscore (g)}<highlight><subscript>k</subscript></highlight>&equals;&nabla;f<highlight><superscript>T</superscript></highlight>({overscore (w)}) and {overscore (h)}&equals;&nabla;f<highlight><superscript>T</superscript></highlight>({overscore (y)}) have been used. The step size in the modified CG algorithm is chosen under the assumption that the direction vector {overscore (d)}<highlight><subscript>i </subscript></highlight>is R orthogonal to {overscore (d)}<highlight><subscript>k</subscript></highlight>, for i&ne;k. In the LMS/CG algorithm, the conjugate directions are replaced with the gradients and, although {overscore (g)}<highlight><subscript>i</subscript></highlight><highlight><superscript>T</superscript></highlight>{overscore (g)}i&plus;<highlight><bold>1</bold></highlight>&equals;0, R-conjugation is not guaranteed. Therefore, the LMS/CG method does not guarantee convergence in n steps even if given infinite precision. On the other hand, since the step size is chosen under the assumption that all {overscore (g)}<highlight><subscript>i </subscript></highlight>are R-conjugate (and given enough iterations they will span the sub-space like {overscore (d)}i&apos;s) the behavior is typically similar to CG close to the point of convergence. In summary, this algorithm is typically behaves more like LMS initially and more like CG close to convergence. </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> The LMS/CG algorithm is as follows: </paragraph>
<paragraph id="P-0065" lvl="2"><number>&lsqb;0065&rsqb;</number> Step 1: </paragraph>
<paragraph id="P-0066" lvl="3"><number>&lsqb;0066&rsqb;</number> Start with any value of {overscore (w)}<highlight><subscript>0</subscript></highlight>. </paragraph>
<paragraph id="P-0067" lvl="2"><number>&lsqb;0067&rsqb;</number> Step 2: </paragraph>
<paragraph id="P-0068" lvl="3"><number>&lsqb;0068&rsqb;</number> while e(k) is above a desired threshold: </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>e</italic></highlight>(<highlight><italic>k</italic></highlight>)&equals;<highlight><italic>r</italic></highlight>(<highlight><italic>k</italic></highlight>)&minus;{overscore (w)}<highlight><subscript>k</subscript></highlight><highlight><superscript>T</superscript></highlight><highlight><italic>{overscore (u)}</italic></highlight><highlight><subscript>k </subscript></highlight></in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>{overscore (g)}</italic></highlight><highlight><subscript>k</subscript></highlight>&equals;&minus;2<highlight><italic>{overscore (u)}</italic></highlight><highlight><superscript>H</superscript></highlight>(<highlight><italic>k</italic></highlight>)<highlight><italic>e</italic></highlight>(<highlight><italic>k</italic></highlight>) </in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>{overscore (h)}</italic></highlight><highlight><subscript>k</subscript></highlight>&equals;&minus;2(<highlight><italic>e</italic></highlight>(<highlight><italic>k</italic></highlight>)&minus;{overscore (g)}<highlight><subscript>k</subscript></highlight><highlight><superscript>T</superscript></highlight><highlight><italic>{overscore (u)}</italic></highlight><highlight><subscript>k</subscript></highlight>)<highlight><italic>{overscore (u)}</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>H</superscript></highlight></in-line-formula> 
<math-cwu id="MATH-US-00013">
<number>13</number>
<math>
  <mrow>
    <msub>
      <mi>&alpha;</mi>
      <mi>k</mi>
    </msub>
    <mo>=</mo>
    <mfrac>
      <mrow>
        <msubsup>
          <mover>
            <mi>g</mi>
            <mi>_</mi>
          </mover>
          <mi>k</mi>
          <mi>T</mi>
        </msubsup>
        <mo>&it;</mo>
        <msub>
          <mover>
            <mi>g</mi>
            <mi>_</mi>
          </mover>
          <mi>k</mi>
        </msub>
      </mrow>
      <mrow>
        <msubsup>
          <mover>
            <mi>g</mi>
            <mi>_</mi>
          </mover>
          <mi>k</mi>
          <mi>T</mi>
        </msubsup>
        <mo>&af;</mo>
        <mrow>
          <mo>(</mo>
          <mrow>
            <msub>
              <mover>
                <mi>g</mi>
                <mi>_</mi>
              </mover>
              <mi>k</mi>
            </msub>
            <mo>-</mo>
            <msub>
              <mover>
                <mi>h</mi>
                <mi>_</mi>
              </mover>
              <mi>k</mi>
            </msub>
          </mrow>
          <mo>)</mo>
        </mrow>
      </mrow>
    </mfrac>
  </mrow>
</math>
<math>
  <mrow>
    <msub>
      <mover>
        <mi>w</mi>
        <mi>_</mi>
      </mover>
      <mrow>
        <mi>k</mi>
        <mo>+</mo>
        <mn>1</mn>
      </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
      <msub>
        <mover>
          <mi>w</mi>
          <mi>_</mi>
        </mover>
        <mi>k</mi>
      </msub>
      <mo>+</mo>
      <mrow>
        <msub>
          <mi>&alpha;</mi>
          <mi>k</mi>
        </msub>
        <mo>&it;</mo>
        <msub>
          <mover>
            <mi>g</mi>
            <mi>_</mi>
          </mover>
          <mi>k</mi>
        </msub>
      </mrow>
    </mrow>
  </mrow>
</math>
<mathematica-file id="MATHEMATICA-00013" file="US20030005009A1-20030102-M00013.NB"/>
<image id="EMI-M00013" wi="216.027" he="34.0767" file="US20030005009A1-20030102-M00013.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0069" lvl="2"><number>&lsqb;0069&rsqb;</number> end while </paragraph>
<paragraph id="P-0070" lvl="0"><number>&lsqb;0070&rsqb;</number> Adaptive filtering algorithms are commonly used in modems for echo cancellation and equalization. <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a block diagram showing a modem <highlight><bold>200</bold></highlight> and a modem <highlight><bold>210</bold></highlight>. The modems <highlight><bold>200</bold></highlight> and <highlight><bold>210</bold></highlight> use adaptive filters for echo cancellation. </paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> In the modem <highlight><bold>200</bold></highlight>, data to be transmitted is provided to an input of a digital to analog converter <highlight><bold>201</bold></highlight> and to a filter data input of an echo canceller <highlight><bold>208</bold></highlight>. An output of the digital to analog converter <highlight><bold>201</bold></highlight> is provided to an input of a transmit filter <highlight><bold>202</bold></highlight>. An output of the transmit filter <highlight><bold>202</bold></highlight> is provided to a data input of a hybrid <highlight><bold>203</bold></highlight>. An output of the hybrid <highlight><bold>203</bold></highlight> is provided to an input of a receive filter <highlight><bold>204</bold></highlight>. An output of the receive filter <highlight><bold>204</bold></highlight> is provided to an input of a sampler (i.e., an analog to digital converter) <highlight><bold>205</bold></highlight>. A digital output from the sampler <highlight><bold>205</bold></highlight> is provided to a non-inverting input of an adder <highlight><bold>207</bold></highlight>. A filter data output from the echo canceller <highlight><bold>208</bold></highlight> is provided to an inverting input of the adder <highlight><bold>207</bold></highlight>. An output of the adder <highlight><bold>208</bold></highlight> is provided to an error signal input of the echo canceller <highlight><bold>208</bold></highlight> and to a detector <highlight><bold>206</bold></highlight>. The output from the adder <highlight><bold>208</bold></highlight> is the difference between the output of the sampler <highlight><bold>205</bold></highlight> and the output of the echo canceller <highlight><bold>208</bold></highlight>. </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> In the modem <highlight><bold>210</bold></highlight>, data to be transmitted is provided to an input of a digital to analog converter <highlight><bold>211</bold></highlight> and to a filter data input of an echo canceller <highlight><bold>218</bold></highlight>. An output of the digital to analog converter <highlight><bold>211</bold></highlight> is provided to an input of a transmit filter <highlight><bold>212</bold></highlight>. An output of the transmit filter <highlight><bold>212</bold></highlight> is provided to a data input of a hybrid <highlight><bold>213</bold></highlight>. An output of the hybrid <highlight><bold>213</bold></highlight> is provided to an input of a receive filter <highlight><bold>214</bold></highlight>. An output of the receive filter <highlight><bold>214</bold></highlight> is provided to an input of a sampler (i.e., an analog to digital converter) <highlight><bold>215</bold></highlight>. A digital output from the sampler <highlight><bold>215</bold></highlight> is provided to a non-inverting input of an adder <highlight><bold>217</bold></highlight>. A filter data output from the echo canceller <highlight><bold>218</bold></highlight> is provided to an inverting input of the adder <highlight><bold>217</bold></highlight>. An output of the adder <highlight><bold>218</bold></highlight> is provided to an error signal input of the echo canceller <highlight><bold>218</bold></highlight> and to a detector <highlight><bold>216</bold></highlight>. The output from the adder <highlight><bold>218</bold></highlight> is the difference between the output of the sampler <highlight><bold>215</bold></highlight> and the output of the echo canceller <highlight><bold>208</bold></highlight>. A line input/output port of the hybrid <highlight><bold>203</bold></highlight> is provided to a line input/output port of the hybrid <highlight><bold>213</bold></highlight>. The echo cancellers <highlight><bold>208</bold></highlight> and <highlight><bold>218</bold></highlight> are adaptive filters that provide an echo cancelling signal to the adders <highlight><bold>207</bold></highlight> and <highlight><bold>217</bold></highlight> respectively. </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> Only minor modifications are needed for the LMS/CG algorithm to be applicable to be used in echo cancellation. Since the received signal in the modems <highlight><bold>200</bold></highlight> and <highlight><bold>210</bold></highlight> is real, the following algorithm is used in the echo cancellers <highlight><bold>208</bold></highlight> and <highlight><bold>218</bold></highlight>: </paragraph>
<paragraph id="P-0074" lvl="2"><number>&lsqb;0074&rsqb;</number> Step 1: </paragraph>
<paragraph id="P-0075" lvl="3"><number>&lsqb;0075&rsqb;</number> Start with any value of {overscore (w)}<highlight><subscript>0</subscript></highlight>. </paragraph>
<paragraph id="P-0076" lvl="2"><number>&lsqb;0076&rsqb;</number> Step 2: </paragraph>
<paragraph id="P-0077" lvl="3"><number>&lsqb;0077&rsqb;</number> while e(k) is above a given threshold:  
<math-cwu id="MATH-US-00014">
<number>14</number>
<math>
<mrow>
  <mstyle>
    <mtext>&NewLine;</mtext>
  </mstyle>
  <mo>&it;</mo>
  <mrow>
    <mrow>
      <mi>e</mi>
      <mo>&af;</mo>
      <mrow>
        <mo>(</mo>
        <mi>k</mi>
        <mo>)</mo>
      </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
      <mi>Re</mi>
      <mo>&af;</mo>
      <mrow>
        <mo>[</mo>
        <mrow>
          <mrow>
            <mi>r</mi>
            <mo>&af;</mo>
            <mrow>
              <mo>(</mo>
              <mi>k</mi>
              <mo>)</mo>
            </mrow>
          </mrow>
          <mo>-</mo>
          <mrow>
            <msubsup>
              <mover>
                <mi>w</mi>
                <mi>_</mi>
              </mover>
              <mi>k</mi>
              <mi>T</mi>
            </msubsup>
            <mo>&it;</mo>
            <msub>
              <mover>
                <mi>u</mi>
                <mi>_</mi>
              </mover>
              <mi>k</mi>
            </msub>
          </mrow>
        </mrow>
        <mo>]</mo>
      </mrow>
    </mrow>
  </mrow>
</mrow>
</math>
<mathematica-file id="MATHEMATICA-00014" file="US20030005009A1-20030102-M00014.NB"/>
<image id="EMI-M00014" wi="216.027" he="21.12075" file="US20030005009A1-20030102-M00014.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
&emsp;<highlight><italic>{overscore (g)}</italic></highlight><highlight><subscript>k</subscript></highlight>&equals;&minus;2<highlight><italic>{overscore (u)}</italic></highlight>*(<highlight><italic>k</italic></highlight>)<highlight><italic>e</italic></highlight>(<highlight><italic>k</italic></highlight>) </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>{overscore (h)}</italic></highlight><highlight><subscript>k</subscript></highlight>&equals;&minus;2(<highlight><italic>e</italic></highlight>(<highlight><italic>k</italic></highlight>)&minus;<highlight><italic>{overscore (g)}</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>T</superscript></highlight><highlight><italic>{overscore (u)}</italic></highlight><highlight><subscript>k</subscript></highlight>)<highlight><italic>{overscore (u)}</italic></highlight><highlight><subscript>k</subscript></highlight>* </in-line-formula> 
<math-cwu id="MATH-US-00015">
<number>15</number>
<math>
  <mrow>
    <msub>
      <mi>&alpha;</mi>
      <mi>k</mi>
    </msub>
    <mo>=</mo>
    <mfrac>
      <mrow>
        <msubsup>
          <mover>
            <mi>g</mi>
            <mi>_</mi>
          </mover>
          <mi>k</mi>
          <mi>T</mi>
        </msubsup>
        <mo>&it;</mo>
        <msub>
          <mover>
            <mi>g</mi>
            <mi>_</mi>
          </mover>
          <mi>k</mi>
        </msub>
      </mrow>
      <mrow>
        <msubsup>
          <mover>
            <mi>g</mi>
            <mi>_</mi>
          </mover>
          <mi>k</mi>
          <mi>T</mi>
        </msubsup>
        <mo>&af;</mo>
        <mrow>
          <mo>(</mo>
          <mrow>
            <msub>
              <mover>
                <mi>g</mi>
                <mi>_</mi>
              </mover>
              <mi>k</mi>
            </msub>
            <mo>-</mo>
            <msub>
              <mover>
                <mi>h</mi>
                <mi>_</mi>
              </mover>
              <mi>k</mi>
            </msub>
          </mrow>
          <mo>)</mo>
        </mrow>
      </mrow>
    </mfrac>
  </mrow>
</math>
<math>
  <mrow>
    <msub>
      <mover>
        <mi>w</mi>
        <mi>_</mi>
      </mover>
      <mrow>
        <mi>k</mi>
        <mo>+</mo>
        <mn>1</mn>
      </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
      <msub>
        <mover>
          <mi>w</mi>
          <mi>_</mi>
        </mover>
        <mi>k</mi>
      </msub>
      <mo>+</mo>
      <mrow>
        <msub>
          <mi>&alpha;</mi>
          <mi>k</mi>
        </msub>
        <mo>&it;</mo>
        <msub>
          <mover>
            <mi>g</mi>
            <mi>_</mi>
          </mover>
          <mi>k</mi>
        </msub>
      </mrow>
    </mrow>
  </mrow>
</math>
<mathematica-file id="MATHEMATICA-00015" file="US20030005009A1-20030102-M00015.NB"/>
<image id="EMI-M00015" wi="216.027" he="34.0767" file="US20030005009A1-20030102-M00015.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0078" lvl="2"><number>&lsqb;0078&rsqb;</number> end while </paragraph>
<paragraph id="P-0079" lvl="7"><number>&lsqb;0079&rsqb;</number> Where Re denotes the real part of a complex number. An implementation of the above algorithm is shown in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>. In <cross-reference target="DRAWINGS">FIG. 3, a</cross-reference> set (a vector) of starting weights {overscore (w)}<highlight><subscript>0 </subscript></highlight>is provided to a first input of a multiplier <highlight><bold>301</bold></highlight>. An output of the multiplier <highlight><bold>301</bold></highlight> is provided to an input of a time delay <highlight><bold>302</bold></highlight>. An output of the time delay <highlight><bold>302</bold></highlight> is an updated set of weights {overscore (w)}<highlight><subscript>k</subscript></highlight>. The output of the time delay <highlight><bold>302</bold></highlight> is provided to an input of a transpose block <highlight><bold>303</bold></highlight>. An output of the transpose block <highlight><bold>303</bold></highlight> is provided to a first input of a multiplier <highlight><bold>304</bold></highlight>. An input signal {overscore (u)}<highlight><subscript>k </subscript></highlight>is provided to a second input of the multiplier <highlight><bold>304</bold></highlight>, to an input of an amplifier <highlight><bold>311</bold></highlight>, and to a first input of a multiplier <highlight><bold>308</bold></highlight>. An output of the multiplier <highlight><bold>304</bold></highlight> is provided to an inverting input of an adder <highlight><bold>305</bold></highlight>. A received signal input {overscore (r)}<highlight><subscript>k </subscript></highlight>is provided to a non-inverting input of the adder <highlight><bold>305</bold></highlight>. An output of the adder <highlight><bold>305</bold></highlight> is an error signal {overscore (e)}<highlight><subscript>k</subscript></highlight>. The error signal {overscore (e)}<highlight><subscript>k </subscript></highlight>is provided to a first input of a multiplier <highlight><bold>306</bold></highlight> and to a non-inverting input of an adder <highlight><bold>309</bold></highlight>. An output of the amplifier <highlight><bold>311</bold></highlight> is provided to an input of a conjugate block <highlight><bold>312</bold></highlight>. The amplifier <highlight><bold>311</bold></highlight> has a gain of &minus;2. The conjugate block <highlight><bold>312</bold></highlight> performs a complex conjugate operation. An output of the conjugate block <highlight><bold>312</bold></highlight> is provided to a second input of the multiplier <highlight><bold>306</bold></highlight> and to a first input of a multiplier <highlight><bold>310</bold></highlight>. </paragraph>
<paragraph id="P-0080" lvl="0"><number>&lsqb;0080&rsqb;</number> An output of the multiplier <highlight><bold>306</bold></highlight> is provided to an input of a transpose block <highlight><bold>307</bold></highlight>, to a first input of a multiplier <highlight><bold>313</bold></highlight>, and to a non-inverting input of an adder <highlight><bold>314</bold></highlight>. An output of the transpose block <highlight><bold>307</bold></highlight> is provided to a second input of the multiplier <highlight><bold>308</bold></highlight>, to a second input of a multiplier <highlight><bold>313</bold></highlight>, and to a first input of a multiplier <highlight><bold>315</bold></highlight>. An output of the multiplier <highlight><bold>308</bold></highlight> is provided to an inverting input of the adder <highlight><bold>309</bold></highlight>. An output of the adder <highlight><bold>309</bold></highlight> is provided to a second input of the multiplier <highlight><bold>310</bold></highlight>. An output of the multiplier <highlight><bold>310</bold></highlight> is provided to an inverting input of the adder <highlight><bold>314</bold></highlight>. An output of the adder <highlight><bold>314</bold></highlight> is provided to a second input of the multiplier <highlight><bold>315</bold></highlight>. An output of the multiplier <highlight><bold>315</bold></highlight> is provided to a denominator input of a divider <highlight><bold>316</bold></highlight>. An output of the multiplier <highlight><bold>313</bold></highlight> is provided to a numerator input of the divider <highlight><bold>316</bold></highlight>. An output of the divider <highlight><bold>316</bold></highlight> is provided to a second input of the multiplier <highlight><bold>301</bold></highlight>. </paragraph>
<paragraph id="P-0081" lvl="0"><number>&lsqb;0081&rsqb;</number> Most of the arithmetic operations shown in <cross-reference target="DRAWINGS">FIG. 3</cross-reference> are vector operations. The output of the algorithm shown in <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a set of weights {overscore (w)}<highlight><subscript>k</subscript></highlight>. The weights {overscore (w)}<highlight><subscript>k </subscript></highlight>are provided to a filter, such as the filter <highlight><bold>103</bold></highlight> shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, to produce the desired filtering of inputs to outputs. </paragraph>
<paragraph id="P-0082" lvl="0"><number>&lsqb;0082&rsqb;</number> Through the foregoing description and accompanying drawings, the present invention has been shown to have important advantages over the prior art. While the above detailed description has shown, described, and pointed out the fundamental novel features of the invention, it will be understood that various omissions and substitutions and changes in the form and details of the device illustrated may be made by those skilled in the art, without departing from the spirit of the invention. Therefore, the invention should be limited in its scope only by the following claims. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. An adaptive filter comprising: 
<claim-text>a configurable filter, a configuration of said configurable filter specified by one or more weights {overscore (w)}<highlight><subscript>k</subscript></highlight>; and </claim-text>
<claim-text>a control algorithm, said control algorithm configured to compute a new set of weights {overscore (w)}<highlight><subscript>k&plus;1 </subscript></highlight>based on an adaptation factor &agr;<highlight><subscript>k </subscript></highlight>multiplied by an estimated gradient {overscore (g)}<highlight><subscript>k </subscript></highlight>at a point given by {overscore (w)}<highlight><subscript>k</subscript></highlight>, where said adaptation factor is computed from said estimated gradient {overscore (g)}<highlight><subscript>k </subscript></highlight>and an estimated gradient {overscore (h)}<highlight><subscript>k </subscript></highlight>computed at a point {overscore (y)}<highlight><subscript>k</subscript></highlight>, said point {overscore (y)}<highlight><subscript>k </subscript></highlight>different from said point {overscore (w)}<highlight><subscript>k</subscript></highlight>. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The adaptive filter of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein {overscore (w)}<highlight><subscript>k&plus;1</subscript></highlight>&equals;{overscore (w)}<highlight><subscript>k</subscript></highlight>&minus;&agr;<highlight><subscript>k</subscript></highlight>{overscore (g)}<highlight><subscript>k</subscript></highlight>. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The adaptive filter of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein {overscore (y)}<highlight><subscript>k</subscript></highlight>&equals;{overscore (w)}<highlight><subscript>k</subscript></highlight>&minus;{overscore (g)}<highlight><subscript>k</subscript></highlight>. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The adaptive filter of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein </claim-text>
<claim-text> 
<math-cwu id="MATH-US-00016">
<number>16</number>
<math>
<mrow>
  <msub>
    <mi>&alpha;</mi>
    <mi>k</mi>
  </msub>
  <mo>=</mo>
  <mrow>
    <mfrac>
      <mrow>
        <msubsup>
          <mover>
            <mi>g</mi>
            <mi>_</mi>
          </mover>
          <mi>k</mi>
          <mi>T</mi>
        </msubsup>
        <mo>&it;</mo>
        <msub>
          <mover>
            <mi>g</mi>
            <mi>_</mi>
          </mover>
          <mi>k</mi>
        </msub>
      </mrow>
      <mrow>
        <msubsup>
          <mover>
            <mi>g</mi>
            <mi>_</mi>
          </mover>
          <mi>k</mi>
          <mi>T</mi>
        </msubsup>
        <mo>&af;</mo>
        <mrow>
          <mo>(</mo>
          <mrow>
            <msub>
              <mover>
                <mi>g</mi>
                <mi>_</mi>
              </mover>
              <mi>k</mi>
            </msub>
            <mo>-</mo>
            <msub>
              <mover>
                <mi>h</mi>
                <mi>_</mi>
              </mover>
              <mi>k</mi>
            </msub>
          </mrow>
          <mo>)</mo>
        </mrow>
      </mrow>
    </mfrac>
    <mo>.</mo>
  </mrow>
</mrow>
</math>
<mathematica-file id="MATHEMATICA-00016" file="US20030005009A1-20030102-M00016.NB"/>
<image id="EMI-M00016" wi="216.027" he="22.08465" file="US20030005009A1-20030102-M00016.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. A method for computing a new set of weights {overscore (w)}<highlight><subscript>k&plus;1 </subscript></highlight>in an adaptive filter comprising: 
<claim-text>estimating a gradient {overscore (g)}<highlight><subscript>k </subscript></highlight>at a point given by a current set of weights {overscore (w)}<highlight><subscript>k</subscript></highlight>; </claim-text>
<claim-text>computing an adaptation factor &agr;<highlight><subscript>k </subscript></highlight>where said adaptation factor is computed from said estimated gradient {overscore (g)}<highlight><subscript>k </subscript></highlight>and an estimated gradient {overscore (h)}<highlight><subscript>k </subscript></highlight>computed at a point {overscore (y)}<highlight><subscript>k</subscript></highlight>, said point {overscore (y)}<highlight><subscript>k </subscript></highlight>different from said point {overscore (w)}<highlight><subscript>k</subscript></highlight>; and </claim-text>
<claim-text>computing {overscore (w)}<highlight><subscript>k&plus;1 </subscript></highlight>according to the equation {overscore (w)}<highlight><subscript>k&plus;1</subscript></highlight>&equals;{overscore (w)}<highlight><subscript>k</subscript></highlight>&minus;&agr;<highlight><subscript>k</subscript></highlight>{overscore (g)}<highlight><subscript>k</subscript></highlight>. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference>, wherein {overscore (y)}<highlight><subscript>k</subscript></highlight>&equals;{overscore (w)}<highlight><subscript>k</subscript></highlight>&minus;{overscore (g)}<highlight><subscript>k</subscript></highlight>. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference>, wherein </claim-text>
<claim-text> 
<math-cwu id="MATH-US-00017">
<number>17</number>
<math>
<mrow>
  <msub>
    <mi>&alpha;</mi>
    <mi>k</mi>
  </msub>
  <mo>=</mo>
  <mrow>
    <mfrac>
      <mrow>
        <msubsup>
          <mover>
            <mi>g</mi>
            <mi>_</mi>
          </mover>
          <mi>k</mi>
          <mi>T</mi>
        </msubsup>
        <mo>&it;</mo>
        <msub>
          <mover>
            <mi>g</mi>
            <mi>_</mi>
          </mover>
          <mi>k</mi>
        </msub>
      </mrow>
      <mrow>
        <msubsup>
          <mover>
            <mi>g</mi>
            <mi>_</mi>
          </mover>
          <mi>k</mi>
          <mi>T</mi>
        </msubsup>
        <mo>&af;</mo>
        <mrow>
          <mo>(</mo>
          <mrow>
            <msub>
              <mover>
                <mi>g</mi>
                <mi>_</mi>
              </mover>
              <mi>k</mi>
            </msub>
            <mo>-</mo>
            <msub>
              <mover>
                <mi>h</mi>
                <mi>_</mi>
              </mover>
              <mi>k</mi>
            </msub>
          </mrow>
          <mo>)</mo>
        </mrow>
      </mrow>
    </mfrac>
    <mo>.</mo>
  </mrow>
</mrow>
</math>
<mathematica-file id="MATHEMATICA-00017" file="US20030005009A1-20030102-M00017.NB"/>
<image id="EMI-M00017" wi="216.027" he="22.08465" file="US20030005009A1-20030102-M00017.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. An adaptive filter comprising: 
<claim-text>a configurable filter, a configuration of said configurable filter specified by one or more weights {overscore (w)}<highlight><subscript>k</subscript></highlight>; and </claim-text>
<claim-text>means for computing a new set of weights {overscore (w)}<highlight><subscript>k&plus;1 </subscript></highlight>based on an adaptation factor &agr;<highlight><subscript>k </subscript></highlight>multiplied by an estimated gradient {overscore (g)}<highlight><subscript>k </subscript></highlight>at a point given by {overscore (w)}<highlight><subscript>k</subscript></highlight>, where said adaptation factor is computed from said estimated gradient {overscore (g)}<highlight><subscript>k </subscript></highlight>and an estimated gradient {overscore (h)}<highlight><subscript>k </subscript></highlight>computed at a point {overscore (y)}<highlight><subscript>k</subscript></highlight>, said point {overscore (y)}<highlight><subscript>k </subscript></highlight>different from said point {overscore (w)}<highlight><subscript>k</subscript></highlight>.</claim-text>
</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>3</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005009A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005009A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005009A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005009A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
