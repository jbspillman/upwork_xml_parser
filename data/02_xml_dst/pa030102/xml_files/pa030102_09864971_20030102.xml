<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030002443A1-20030102-D00000.TIF SYSTEM "US20030002443A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030002443A1-20030102-D00001.TIF SYSTEM "US20030002443A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030002443A1-20030102-D00002.TIF SYSTEM "US20030002443A1-20030102-D00002.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030002443</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09864971</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010524</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>H04L012/56</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>370</class>
<subclass>237000</subclass>
</uspc>
</classification-us-primary>
<classification-us-secondary>
<uspc>
<class>370</class>
<subclass>238000</subclass>
</uspc>
</classification-us-secondary>
<classification-us-secondary>
<uspc>
<class>370</class>
<subclass>389000</subclass>
</uspc>
</classification-us-secondary>
</classification-us>
<title-of-invention>System and method for enhancing the availability of routing systems through equal cost multipath</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Claude</given-name>
<family-name>Basso</family-name>
</name>
<residence>
<residence-us>
<city>Raleigh</city>
<state>NC</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Francis</given-name>
<family-name>Arts</family-name>
</name>
<residence>
<residence-non-us>
<city>Turnhout</city>
<country-code>BE</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Pierre</given-name>
<middle-name>Leon</middle-name>
<family-name>Debuysscher</family-name>
</name>
<residence>
<residence-non-us>
<city>De Pinte</city>
<country-code>BE</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Olivier</given-name>
<middle-name>Didier</middle-name>
<family-name>Duroyon</family-name>
</name>
<residence>
<residence-us>
<city>McLean</city>
<state>VA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Max</given-name>
<middle-name>Robert</middle-name>
<family-name>Povse</family-name>
</name>
<residence>
<residence-us>
<city>Apex</city>
<state>NC</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Natarajan</given-name>
<family-name>Vaidhyanathan</family-name>
</name>
<residence>
<residence-us>
<city>Durham</city>
<state>NC</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Colin</given-name>
<middle-name>Beaton</middle-name>
<family-name>Verrilli</family-name>
</name>
<residence>
<residence-us>
<city>Apex</city>
<state>NC</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<assignee>
<organization-name>International Business Machines Corporation</organization-name>
<address>
<city>Armonk</city>
<state>NY</state>
<country>
<country-code>US</country-code>
</country>
</address>
<assignee-type>02</assignee-type>
</assignee>
<correspondence-address>
<name-1>IBM CORPORATION</name-1>
<name-2></name-2>
<address>
<address-1>PO BOX 12195</address-1>
<address-2>DEPT 9CCA, BLDG 002</address-2>
<city>RESEARCH TRIANGLE PARK</city>
<state>NC</state>
<postalcode>27709</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">In a networking environment including one or more network processing (NP) devices and implementing a routing protocol for routing data packets from a source NP devices to destination NP devices via a switch fabric, with each network processing device supporting a number of interface ports, a system and method for enabling a routing system to recover more quickly that the routing protocol so as to significantly reduce the occurrence of lost data packets to a failed target interface/blade. The routing system is enabled to track the operational status of each network processor device and operational status of destination ports supported by each network processor device in the system, and maintains the operational status as a data structure at each network processing device. Prior to routing packets, an expedient logical determination is made as to the operational status of a target network processing device and target interface port of a current packet to be routed as represented in the data structure maintained at the source NP device. If the target blade/interface is not operations, an alternative route may be provided by ECMP. In this manner, correct routing of packets is ensured with reduced occurrence of lost data packets due to failed target NP devices/ports. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> 1. Field of the Invention </paragraph>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> This invention relates generally to network processor-based devices, and more specifically to an improved equal cost multipath routing and recovery mechanism that enables the routing system to recover more quickly that the routing protocol. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> 2. Discussion of the Prior Art </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> In today&apos;s networked world, bandwidth is a critical resource. Increasing network traffic, driven by the Internet and other emerging applications, is straining the capacity of network infrastructures. To keep pace, organizations are looking for better technologies and methodologies to support and manage traffic growth and the convergence of voice with data. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> The convergence of voice and data will play a large role in defining tomorrow&apos;s network environment. Because voice communications will naturally follow the path of lowest cost, voice will inevitably converge with data. Technologies such as Voice over IP (VoIP), Voice over ATM (VoATM), and Voice over Frame Relay (VoFR) are cost-effective alternatives in this changing market. However, to make migration to these technologies possible, the industry has to ensure quality of service (QoS) for voice and determine how to charge for voice transfer over data lines. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> Integrating legacy systems is also a crucial concern for organizations as new products and capabilities become available. To preserve their investments in existing equipment and software, organizations demand solutions that allow them to migrate to new technologies without disrupting their current operations. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> Eliminating network bottlenecks continues to be a top priority for service providers. Routers are often the source of these bottlenecks. However, network congestion in general is often mis-diagnosed as a bandwidth problem and is addressed by seeking higher-bandwidth solutions. Today, manufacturers are recognizing this difficulty. They are turning to network processor technologies to manage bandwidth resources more efficiently and to provide the advanced data services, at wire speed, that are commonly found in routers and network application servers. These services include load balancing, QoS, gateways, fire walls, security, and web caching. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> For remote access applications, performance, bandwidth-on-demand, security, and authentication rank as top priorities. The demand for integration of QoS and CoS, integrated voice handling, and more sophisticated security solutions will also shape the designs of future remote access network switches. Further, remote access will have to accommodate an increasing number of physical mediums, such as ISDN, T1, E1, OC-3 through OC-48, cable, and xDSL modems. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> A network processor (herein also mentioned as an &ldquo;NP&rdquo;) has been defined as a programmable communications integrated circuit capable of performing one or more of the following functions: </paragraph>
<paragraph id="P-0010" lvl="2"><number>&lsqb;0010&rsqb;</number> Packet classification&mdash;identifying a packet based on known characteristics, such as address or protocol; </paragraph>
<paragraph id="P-0011" lvl="2"><number>&lsqb;0011&rsqb;</number> Packet modification&mdash;modifying the packet to comply with IP, ATM, or other protocols (for example, updating the time- to-live field in the header for IP); </paragraph>
<paragraph id="P-0012" lvl="2"><number>&lsqb;0012&rsqb;</number> Queue/policy management&mdash;reflects the design strategy for packet queuing, de-queuing, and scheduling of packets for specific applications; and, </paragraph>
<paragraph id="P-0013" lvl="2"><number>&lsqb;0013&rsqb;</number> Packet forwarding&mdash;transmission and receipt of data over the switch fabric and forwarding or routing the packet to the appropriate address. </paragraph>
<paragraph id="P-0014" lvl="7"><number>&lsqb;0014&rsqb;</number> For exemplary purposes, reference is made to <cross-reference target="DRAWINGS">FIG. 1</cross-reference> which illustrates a logical model of a generic Network Processor system <highlight><bold>10</bold></highlight>. As shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, multiple Network Processors (NP) <highlight><bold>12</bold></highlight> are shown connected using a switch fabric <highlight><bold>15</bold></highlight>, with each of the network processors supporting a large number of external LAN or WAN interface ports <highlight><bold>20</bold></highlight>. A separate General Purpose Processor (GPP) functions as a control point (CP) <highlight><bold>25</bold></highlight> for the system and has a physical or logical association with all of the Network Processors <highlight><bold>12</bold></highlight> in the system for enabling the customization and configuration of the Network Processor (NP) devices so that they may handle the forwarding of data packets and frames. It should be understood however, that the GPP may be embedded in a network processor device itself. The generic network processor system <highlight><bold>10</bold></highlight> comprises two major software components: 1) the control point code base running on the GPP, and, the programmable hardware-assist processors&apos; picocode in each of the network processors. These two software components are responsible for initializing the system, maintaining the forwarding paths, and managing the system. From a software view, the system is distributed. The GPP and each picoprocessor run in parallel, with the CP communicating with each picoprocessor using a predefined application program interface (API) <highlight><bold>30</bold></highlight> and control protocol. The CP code base provides support for the Layer <highlight><bold>2</bold></highlight> and Layer <highlight><bold>3</bold></highlight> topology protocols and Layer <highlight><bold>4</bold></highlight> and Layer <highlight><bold>5</bold></highlight> network applications and systems management. Examples are protocol support for VLAN, IP, and Multiprotocol Label Switching standard (MPLS), and the supporting address- and route-learning algorithms to maintain topology information. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> With particular reference to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, and accompanying description found in commonly-owned, co-pending U.S. patent application Ser. No. 09/384,691 filed Aug. 27, 1999 and entitled &ldquo;NETWORK PROCESSOR PROCESSING COMPLEX AND METHODS&rdquo;, the whole contents and disclosure of which is incorporated by reference as if fully set forth herein, the general flow of a packet or frame received at the NP device is as follows: frames received from an network connection, e.g., Ethernet MAC, are placed in internal data store buffers by an upside &ldquo;enqueue&rdquo; device (EDS-UP) where they are identified as either normal data frames or system control frames (Guided Frames). In the context of the invention, frames identified as normal data frames are enqueued to an Embedded Processor Complex (EPC) which comprises a plurality of picoprocessors, e.g., protocol processors. These picoprocessors execute logic (picocode) capable of looking at the received frame header and deciding what to do with the frame (forwardly, modify, filter, etc.). The EPC has access to several lookup tables, and classification hardware assists to allow the picoprocessors to keep up with the high-bandwidth requirements of the Network Processor. A classification hardware assist device in particular, is provided for classifying frames of well known frame formats. The Embedded Processing Complex (EPC) particularly provides and controls the programmability of the NP device and includes, among other components (such as memory, dispatcher, interfaces), N processing units, referred to as GxH, which concurrently execute picocode that is stored in a common instruction memory. It is understood, however, that the architecture and structure is completely scalable towards more GxHs with the only limitation being the amount of silicon area provided in the chip. In operation, classification results from the classification hardware assist device are passed to the GxH, during frame dispatch. Each GxH preferably includes a Processing Unit core (CLP) which comprises, e.g., a 3-stage pipeline, general purpose registers and an ALU. Several GxHs in particular, are defined as General Data Handlers (GDH) each of which comprise a full CLP with the five coprocessors and are primarily used for forwarding frames. One GxH coprocessor, in particular, a Tree Search Engine Coprocessor (TSE) functions to access all tables, counters, and other data in a control memory that are needed by the picocode in performing tree searches used in forwarding data packets, thus freeing a protocol processor to continue execution. The TSE is particularly implemented for storing and retrieving information in various processing contexts, e.g., determining frame routing rules, lookup of frame forwarding information and, in some cases, frame alteration information. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> Traditional frame routing capability provided in network processor devices typically utilize a network routing table having entries which provide a single next hop for each table entry. Commonly-owned, co-pending U.S. patent application Ser. No. 09/546,702 entitled METHOD FOR PROVIDING EQUAL COST MULTIPATH FORWARDING IN A NETWORK PROCESSOR, the whole content and disclosure of which is set forth herein, describes a system and method for providing the ability for a network processor to select from multiple next hop options for a single forwarding entry. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference>(<highlight><italic>a</italic></highlight>) depicts an example network processor frame routing scenario <highlight><bold>40</bold></highlight> and <cross-reference target="DRAWINGS">FIG. 2</cross-reference>(<highlight><italic>b</italic></highlight>) illustrates an example Equal Cost Multipath Forwarding (ECMP) table <highlight><bold>50</bold></highlight> that may be used to provide a lookup of a nextHop address for forwarding packets as described in commonly-owned, co-pending U.S. patent application Ser. No. 09/546,702. Preferably, such a table is employed in a Network Processor (NP) device having packet routing functions such as described in commonly-owned, co- pending U.S. patent application Ser. No. 09/384,691. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> Thus, the example ECMP forwarding table <highlight><bold>50</bold></highlight> illustrated in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>(<highlight><italic>b</italic></highlight>), is particularly implemented in a frame forwarding context for network processor operations. In the example ECMP forwarding table <highlight><bold>50</bold></highlight>, there is provided subnet destination address fields <highlight><bold>52</bold></highlight>, with each forwarding entry including multiple next hop routing information comprising multiple next hop address fields, e.g., fields <highlight><bold>60</bold></highlight><highlight><italic>a</italic></highlight>-<highlight><bold>60</bold></highlight><highlight><italic>c</italic></highlight>. Additionally provided in the ECMP routing table is cumulative probability data for each corresponding next hop such as depicted in action data field <highlight><bold>70</bold></highlight>. Particularly, in the exemplary illustration of the ECMP packet forwarding table <highlight><bold>50</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 2</cross-reference>(<highlight><italic>b</italic></highlight>), there is included three (3) next hop fields to addresses 9.1.1.1, 8.1.1.1, 6.1.1.1 associated with a destination subnet address 7.*.*.*. An action data field <highlight><bold>70</bold></highlight> includes threshold values used to weight the probability of each next hop and is used to determine which next hop will be chosen. In the action field <highlight><bold>72</bold></highlight>, shown in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>(<highlight><italic>b</italic></highlight>), these values as being stored as cumulative percentages with the first cumulative percentage (30%) corresponding to next hop <highlight><bold>0</bold></highlight>, the second cumulative percentage value (80%) corresponding to next hop <highlight><bold>1</bold></highlight>, etc. This means that, the likelihood of routing a packet through next hop <highlight><bold>0</bold></highlight> is 30% (i.e., approximately 30% of traffic for the specified table entry should be routed to next hop <highlight><bold>0</bold></highlight>), and, the likelihood of routing a packet through next hop <highlight><bold>1</bold></highlight> is 50% (i.e., approximately 50% of traffic for the specified table entry should be routed to next hop <highlight><bold>1</bold></highlight>). This technique may be extended to offer as many next hops as desired or feasible. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> Currently, in such network processing systems, if a destination NP device (hereinafter referred to as Targetblade or blade) or interface (such as a port or TargetPort) associated with the target blade and capable of handling the frame type fails, i.e., the packet or frame cannot be routed to the correct destination set forth in the ECMP forwarding table. However, it is often the case that the other Network Processors (NP&apos;s) in the system will continue to attempt to forward frames through the failed interface/blade until the routing protocol, e.g., the Open Shortest Path First (OSPF) protocol which enables routers to understand the internal network architecture, i.e., within an autonomous network, and calculate the shortest path from an IP Source Address (SA) to IP Destination Address (DA), detects the failed link and downloads a new forwarding entry that avoids the failed interface/blade. The time for this routing protocol to detect the failed link could be relatively long, and during this period all the data packets routed through the failed interface/blade may be lost. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> Consequently, it would be highly desirable to provide a methodology that would enable a routing system to recover more quickly that the routing protocol so as to significantly reduce the occurrence of lost data packets to a failed target interface/blade with minimal performance penalty. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> Accordingly, it is an object of the present invention to provide a network processor with a system that that would enable a routing system to recover more quickly that the routing protocol so as to significantly reduce the occurrence of lost data packets to a failed target interface/blade. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> It is another object of the present invention to provide in a network processor system, a method of maintaining the operational status of all the network processors (blades) in the routing system so that packet forwarding issues resulting from a failed interface/blade may be quickly resolved without the loss of data packets routed in the system with minimal performance penalty. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> In accordance with the preferred embodiment of the invention there is provided for a networking environment including one or more network processing (NP) devices and implementing a routing protocol for routing data packets from a source NP devices to destination NP devices via a switch fabric, with each network processing device supporting a number of interface ports, a system and method for enabling a routing system to recover more quickly that the routing protocol so as to significantly reduce the occurrence of lost data packets to a failed target interface/blade. The routing system is enabled to track the operational status of each network processor device and operational status of destination ports supported by each network processor device in the system, and maintains the operational status as a data structure at each network processing device. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> Prior to routing packets, an expedient logical determination is made as to the operational status of a target network processing device and target interface port of a current packet to be routed as represented in the data structure maintained at the source NP device. In this manner, correct routing of packets is ensured with reduced occurrence of lost data packets due to failed target NP devices/ports.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> Further features, aspects and advantages of the apparatus and methods of the present invention will become better understood with regard to the following description, appended claims, and accompanying drawings where: </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> illustrates a logical model of a generic Network Processor system <highlight><bold>10</bold></highlight>. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference>(<highlight><italic>a</italic></highlight>) depicts an example network processing scenario <highlight><bold>40</bold></highlight> including network processors (routers) employing a packet routing table such as an ECMP forwarding table. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference>(<highlight><italic>b</italic></highlight>) illustrates an example ECMP forwarding table for use in a network processor, router or packet switching device according to the example network processing scenario of <cross-reference target="DRAWINGS">FIG. 2</cross-reference>(<highlight><italic>a</italic></highlight>). </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> illustrates the determination of a failed link to Target Blade associated with ECMP next hop destination NP<highlight><bold>1</bold></highlight> for the example network processing scenario of <cross-reference target="DRAWINGS">FIG. 2</cross-reference>(<highlight><italic>a</italic></highlight>), and the resulting decision to re-route the frame to an operation destination NP<highlight><bold>2</bold></highlight> according to the example ECMP table.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">Detailed DESCRIPTION OF THE PREFERRED EMBODIMENT </heading>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> A first method of maintaining operational status at the blade/NP level involves implementation of a data structure (hereinafter referred to as opStatus) that is maintained by each NP device. This opStatus data structure includes information representing the operational status of all the network processors (blades/ports) in the routing system and, for example, may comprises a bit vector of sixty-four (64) bits long (in an example system employing 64 NP devices). If the ith bit is set, for instance, then the ith NP/blade is indicated as operational. In operation, after choosing the next hop according to ECMP rules, the layer-3 forwarding picocode will check the operational status of the NP/blade through which the chosen next hop is reachable. If that NP is not operational, then a different equal-cost next hop (the next hop with the smallest index) that is reachable through an operational NP/blade will be chosen. <cross-reference target="DRAWINGS">FIG. 3</cross-reference> illustrates the determination of a failed link to Target Blade associated with ECMP next hop destination NP<highlight><bold>1</bold></highlight>, and the resulting decision to re-route the frame to an operation destination NP<highlight><bold>2</bold></highlight> according to the ECMP table. That is, in each NP, the operational status of the TB for each packet routed is checked. If the destination TB is down, then a different Next Hop is chosen as suggested by the ECMP table. It should be understood that the particular user application will detect failures and update the opStatus data structure accordingly. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> This first solution essentially maintains the operational status at the TB (blade)/NP level. In order to extend this solution to an interface/port (TB/TP) level, there needs to be maintained a datastructure that is 64&times;16 bits long, assuming each blade in the example system maintains sixteen (16) ports, for instance. Since the opStatus datastructure is consulted in the main forwarding path, it must be stored in a fast, expensive memory. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> Another solution relies on the assumption that the interface/blade failures are rare and it is unlikely that more than one blade will fail at the same time. The advantage of tracking a single failure is the reduction of the size of the opStatus data structure. The current solution only requires 48 bits in expensive high-speed memory where as the previous solution required 64&times;16 bits in such a memory. Thus, the following data structure may be maintained in each NP device in the routing system.  
<table-cwu id="TABLE-US-00001">
<number>1</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>&lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Uint 16 failedBlade; /* Use the value of 0xffff if all blades are</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="84PT" align="left"/>
<colspec colname="1" colwidth="133PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>operational */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Uint 16 failedPortMask;</entry>
</row>
<row>
<entry></entry>
<entry>Uint 16 failedPortValue;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>&rcub;</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> According to this embodiment, the following algorithm is invoked to check whether a given TB, TP is operational:  
<table-cwu id="TABLE-US-00002">
<number>2</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="35PT" align="left"/>
<colspec colname="1" colwidth="182PT" align="left"/>
<thead>
<row>
<entry></entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
<entry>Boolean is Operational (TB, TP) &lcub;</entry>
</row>
<row>
<entry></entry>
<entry>If (failedBlade &equals;&equals; 0xffff)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="49PT" align="left"/>
<colspec colname="1" colwidth="168PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&emsp;&ensp;/* all blades are operational */</entry>
</row>
<row>
<entry></entry>
<entry>&emsp;&ensp;return TRUE;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="35PT" align="left"/>
<colspec colname="1" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>If ((TB &equals;&equals; failedBlade) &amp;&amp; (TP &amp; failedPortMask &equals;&equals;</entry>
</row>
<row>
<entry></entry>
<entry>failed PortValue))</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="49PT" align="left"/>
<colspec colname="1" colwidth="168PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&emsp;&ensp;/* where &amp;&amp; is the logical AND operator */</entry>
</row>
<row>
<entry></entry>
<entry>&emsp;&ensp;/* where &amp; is a bitwise AND operator*/</entry>
</row>
<row>
<entry></entry>
<entry>&emsp;&ensp;Return FALSE;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="35PT" align="left"/>
<colspec colname="1" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Else</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="49PT" align="left"/>
<colspec colname="1" colwidth="168PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&emsp;&ensp;Return TRUE;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="196PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> According to this algorithm, if all blades are operational, the routing of packets throughout the system will continue and no ECMP re-routing is necessary. However, only if both a Target Blade is a failed blade AND the result of the bitwise operation between the Target Port and failedPort Mask is equal to the failedPortValue, then a FALSE is returned and the ECMP table invoked for re-routing subsequent packets to another TB or TP. If a TRUE is returned, i.e., either the Target Blade is not a failed blade or the result of the bitwise operation between the Target Port and failedPort Mask is not equal to the failedPortValue, then the packet will still be routed to the destination TB/TP. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> It should be understood that this solution may handle individual failures at port, data move unit (DMU) and blade levels. However, multiple blade failures cannot be handled by this solution. As an example, if all the interfaces in all the blades are operational then failedBlade will contain the value of 0xffff and the values of failedPortMask and failedPortValue will be ignored. If the blade number, e.g., bladeNum, is not operational (i.e., all the ports in that blade have failed) then failedBlade will include bladeNum and faildPortMask will contain the value of 0 and failedPortValue will contain the value of 0. If the port numbered portNum in the blade numbered bladeNum is not operational, then failedBlade will contain bladeNum and failedPortMask will contain the value of 0xffff and the failedPortValue will contain the value of portNum. Assuming a blade having four data move units (DMUs) of four ports each, the ports in DMU A have last (least significant) 2 bits set to 00, the ports in DMU B have last 2 bits set to 01, the ports in DMU C have last 2 bits set to 10, and the ports in DMU D have last 2 bits set to 11. If DMU C were to fail in blade numbered bladeNum, failedBlade will contain the value of bladeNum, and failedPortMask will contain the value of 0x0003 and failedPortValue will contain the value of 0x0002. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> In the preferred embodiment, a range is used to represent the failed blades and a mask on the port number to represent the set of failed ports. This solution only requires 32 bits of high-speed memory. The following data structure will be maintained in all of the NPs in the preferred embodiment:  
<table-cwu id="TABLE-US-00003">
<number>3</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>&lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Uint 8 beginFailedBlade;/* unsigned integer representing begin</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="70PT" align="left"/>
<colspec colname="1" colwidth="147PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&emsp;&emsp;value range of failed blades */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Uint 8 endFailedBlade;/* end value of range of failed blades */</entry>
</row>
<row>
<entry></entry>
<entry>Uint 8 failedPortMask;</entry>
</row>
<row>
<entry></entry>
<entry>Uint failedPortValue;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>&rcub;</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> According to this data structure, if failedPortMask and failedPortValue are both 0xff, then all blades will be considered operational. This convention is founded on the assumption that no port is numbered 0xff. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> According to this embodiment, the following algorithm is invoked to check whether a given TB, TP is operational:  
<table-cwu id="TABLE-US-00004">
<number>4</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<thead>
<row>
<entry></entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
<entry>Boolean isOperational (TB, TP) &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>If ((failedPortMask &equals;&equals;0xff) &amp;&amp; (failedPortValue &equals;&equals; 0xff))</entry>
</row>
<row>
<entry></entry>
<entry>/* all blades are operational */</entry>
</row>
<row>
<entry></entry>
<entry>/* 1-cycle, 1 picocode instruction can perform this test */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>returnTRUE;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>If (TB &lt; beginFailedBlade) return TRUE;</entry>
</row>
<row>
<entry></entry>
<entry>If (TB &gt; endFailedBlade) return TRUE;</entry>
</row>
<row>
<entry></entry>
<entry>If (TP &amp; failedPortMask &excl;&equals; failedPortValue) return TRUE;</entry>
</row>
<row>
<entry></entry>
<entry>Return FALSE;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> According to this algorithm, if all blades are operational, then both failedPortMask and failedPortValue are set to 0xff and the values of the other fields are ignored. This is a simple test that may be performed in one machine cycle. If the blade numbered bladeNum is not operational (i.e., all the ports in that blade have failed) then, according to this algorithm, </paragraph>
<paragraph id="P-0040" lvl="2"><number>&lsqb;0040&rsqb;</number> beginFailedBlade and endFailedBlade are set as bladeNum, </paragraph>
<paragraph id="P-0041" lvl="2"><number>&lsqb;0041&rsqb;</number> failedPortMask is set as 0, and </paragraph>
<paragraph id="P-0042" lvl="2"><number>&lsqb;0042&rsqb;</number> failedPortValue is set as 0. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> However, if the blades numbered, for example <highlight><bold>8</bold></highlight>, <highlight><bold>9</bold></highlight>, and <highlight><bold>10</bold></highlight> are not operational then set </paragraph>
<paragraph id="P-0044" lvl="2"><number>&lsqb;0044&rsqb;</number> beginFailedBlade as 8 </paragraph>
<paragraph id="P-0045" lvl="2"><number>&lsqb;0045&rsqb;</number> endFailedBlade as 10 </paragraph>
<paragraph id="P-0046" lvl="2"><number>&lsqb;0046&rsqb;</number> failedPortMask as 0 and </paragraph>
<paragraph id="P-0047" lvl="2"><number>&lsqb;0047&rsqb;</number> failedPortValue as 0 </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> If the port numbered portNum in the blade numbered bladeNum is not operational, then, according to this algorithm, </paragraph>
<paragraph id="P-0049" lvl="2"><number>&lsqb;0049&rsqb;</number> beginFailedBlade is set as bladeNum </paragraph>
<paragraph id="P-0050" lvl="2"><number>&lsqb;0050&rsqb;</number> endFailedBlade is set as bladeNum </paragraph>
<paragraph id="P-0051" lvl="2"><number>&lsqb;0051&rsqb;</number> failedPortMask is set as 0xff </paragraph>
<paragraph id="P-0052" lvl="2"><number>&lsqb;0052&rsqb;</number> failedPortValue is set as portNum </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> The ports in DMU A have last (least significant) 2 bits set to 00. The ports in DMU B have last 2 bits set to 0 1. The ports in DMU C have last 2 bits set to 10 and the ports in DMU D have last 2 bits set to 11. In an example scenario when all the ports in DMU C fail in blade numbered bladeNum, then, according to this algorithm, </paragraph>
<paragraph id="P-0054" lvl="2"><number>&lsqb;0054&rsqb;</number> beginFailedBlade is set as bladeNum </paragraph>
<paragraph id="P-0055" lvl="2"><number>&lsqb;0055&rsqb;</number> endFailedBlade is set as bladeNum </paragraph>
<paragraph id="P-0056" lvl="2"><number>&lsqb;0056&rsqb;</number> failedPortValue is set as 0b 0000 0010 and </paragraph>
<paragraph id="P-0057" lvl="2"><number>&lsqb;0057&rsqb;</number> failedPortMask is set as 0b 0000 0011 </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> While the invention has been particularly shown and described with respect to illustrative and preformed embodiments thereof, it will be understood by those skilled in the art that the foregoing and other changes in form and details may be made therein without departing from the spirit and scope of the invention which should be limited only by the scope of the appended claims. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">Having thus described our invention, what we claim as new, and desire to secure by Letters Patent is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. In a networking environment comprising one or more network processing (NP) devices for routing data packets from a source to a destination via a switch fabric, with each network processing device supporting a number of interface ports, a system for ensuring packet routing from one network processing device to a target network processing device via a target interface port, said system comprising: 
<claim-text>mechanism for tracking operational status of each network processor device and operational status of destination ports supported by each said network processor device in said system, said operational status being maintained at each network processing device; </claim-text>
<claim-text>said network processor devices including mechanism for determining the operational status of a target network processing device and target interface port of a current packet to be routed prior to said routing, </claim-text>
<claim-text>routing mechanism for routing packets from source NP devices to destination NP devices and destination ports thereof in accordance with a packet routing protocol, said routing mechanism routing said current packet to a target network processor device and destination port when said target network processor device and destination ports thereof are determined as operational, and routing packets to another operational NP device and port thereof upon determination of non-operational target network processor device and destination port, whereby proper routing of packets is guaranteed with minimum packet lost. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The system for ensuring packet routing in accordance with <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein said routing mechanism implements an Equal Cost Multi-Path ECMP protocol including next hop routing table for mapping a destination address associated with a packet to be forwarded to one or more next hop options in said networking environment. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The system for ensuring packet routing in accordance with <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein each network processor device maintains a data structure receiving values from said tracking mechanism indicating status of said network processor devices, said determining mechanism implementing logic for comparing said received value against a first value indicating all NP devices are operational prior to routing of a current packet, and initiating routing of said packet to said target when said values match. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The system for ensuring packet routing in accordance with <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference>, wherein said received value is a second value representing a particular NP device that is not operational, said determining mechanism implementing logic for comparing a bit representation of a target NP device of a packet to be routed against this received second value and initiating routing of said packet to another NP device when said target NP device is not operational. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The system for ensuring packet routing in accordance with <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein each network processor device maintains a data structure receiving values from said tracking mechanism indicating status of said network processor devices, said determining mechanism implementing logic for comparing said received value against a first value indicating all interface ports for said NP devices are operational prior to routing of a current packet, and initiating routing of said packet to said NP device and target port when said values match. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The system for ensuring packet routing in accordance with <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference>, wherein said first value includes a set of mask bits and a set of bits representing said target destination port, said determining mechanism implementing bitwise logic for comparing said received value against said mask bit set and obtaining a first result, comparing said first result against said target destination port bits, and initiating re-routing of said packet to another destination port when said first result does not match said target destination port bits. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The system for ensuring packet routing in accordance with <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference>, wherein said data structure receives two values defining a range of NP devices that are not operational, said determining mechanism implementing logic for comparing a bit representation of a target NP device of a packet to be routed against said each of said two values defining said range, and initiating re-routing of said packet to another destination port outside said range when said bit representation of said target NP device falls within said two values. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. A method for ensuring packet routing in a networking environment comprising one or more network processing (NP) devices for routing data packets from a source to a destination via a switch fabric, with each network processing device supporting a number of interface ports, said method comprising the steps of: 
<claim-text>a) tracking operational status of each network processor device and operational status of destination ports supported by each said network processor device in said system, and maintaining said operational status at each network processing device; </claim-text>
<claim-text>b) determining the operational status of a target network processing device and target interface port of a current packet to be routed prior to said routing at a current NP device; and, </claim-text>
<claim-text>c) routing packets from source NP devices to destination NP devices and destination ports thereof in accordance with a packet routing protocol, a current packet being routed to a target network processor device and destination port when said target network processor device and destination ports thereof are determined as operational, or being routed to another operational NP device and port thereof upon determination of non-operational target network processor device and destination port, whereby proper routing of packets is guaranteed with minimum packet lost. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The method for ensuring packet routing in accordance with <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference>, wherein said routing of packets from source NP devices to destination NP devices and destination ports thereof is in accordance with Equal Cost Multi-Path (ECMP) protocol, said routing step c) including mapping a destination address associated with a packet to be forwarded to one or more next hop options in said networking environment. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The method for ensuring packet routing in accordance with <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference>, wherein said step of maintaining said operational status includes maintaining a data structure for receiving values determined from said tracking step indicating status of said network processor devices. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The method for ensuring packet routing in accordance with <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein said determining step b) includes the step of implementing logic for comparing a received value against a first value indicating all NP devices are operational prior to routing of a current packet, and initiating routing of said packet to said target when said values match. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The method for ensuring packet routing in accordance with <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, wherein said received value is a second value representing a particular NP device that is not operational, said determining step b) including the step of implementing logic for comparing a bit representation of a target NP device of a packet to be routed against this received second value and initiating routing of said packet to another NP device when said target NP device is not operational. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The method for ensuring packet routing in accordance with <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein said determining step b) includes the step of implementing logic for comparing said received value against a first value indicating all interface ports for said NP devices are operational prior to routing of a current packet, and initiating routing of said packet to said NP device and target port when said values match. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The method for ensuring packet routing in accordance with <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference>, wherein said first value includes a set of mask bits and a set of bits representing said target destination port, said determining step b) including the step of implementing bitwise logic for comparing said received value against said mask bit set and obtaining a first result, comparing said first result against said target destination port bits, and initiating re-routing of said packet to another destination port when said first result does not match said target destination port bits. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The method for ensuring packet routing in accordance with <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference>, wherein said data structure receives two values defining a range of NP devices that are not operational, said determining step b) implementing logic for comparing a bit representation of a target NP device of a packet to be routed against said each of said two values defining said range, and initiating re-routing of said packet to another destination port outside said range when said bit representation of said target NP device falls within said two values. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. A program storage device readable by a machine, tangibly embodying a program of instructions executable by the machine to perform method steps for ensuring packet routing in a networking environment comprising one or more network processing (NP) devices for routing data packets from a source to a destination via a switch fabric, with each network processing device supporting a number of interface ports, said method steps comprising: 
<claim-text>a) tracking operational status of each network processor device and operational status of destination ports supported by each said network processor device in said system, and maintaining said operational status at each network processing device; </claim-text>
<claim-text>b) determining the operational status of a target network processing device and target interface port of a current packet to be routed prior to said routing at a current NP device; and, </claim-text>
<claim-text>c) routing packets from source NP devices to destination NP devices and destination ports thereof in accordance with a packet routing protocol, a current packet being routed to a target network processor device and destination port when said target network processor device and destination ports thereof are determined as operational, or being routed to another operational NP device and port thereof upon determination of non-operational target network processor device and destination port, whereby proper routing of packets is guaranteed with minimum packet lost. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The program storage device readable by a machine in accordance with <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, wherein said routing of packets from source NP devices to destination NP devices and destination ports thereof is in accordance with Equal Cost Multi-Path (ECMP) protocol, said routing step c) including mapping a destination address associated with a packet to be forwarded to one or more next hop options in said networking environment. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The program storage device readable by a machine in accordance with <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, wherein said step of maintaining said operational status includes maintaining a data structure for receiving values determined from said tracking step indicating status of said network processor devices. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The program storage device readable by a machine in accordance with <dependent-claim-reference depends_on="CLM-00011">claim 18</dependent-claim-reference>, wherein said determining step b) includes the step of implementing logic for comparing a received value against a first value indicating all NP devices are operational prior to routing of a current packet, and initiating routing of said packet to said target when said values match. </claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The program storage device readable by a machine in accordance with <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference>, wherein said received value is a second value representing a particular NP device that is not operational, said determining step b) including the step of implementing logic for comparing a bit representation of a target NP device of a packet to be routed against this received second value and initiating routing of said packet to another NP device when said target NP device is not operational. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The program storage device readable by a machine in accordance with <dependent-claim-reference depends_on="CLM-00022">claim 20</dependent-claim-reference>, wherein said determining step b) includes the step of implementing logic for comparing said received value against a first value indicating all interface ports for said NP devices are operational prior to routing of a current packet, and initiating routing of said packet to said NP device and target port when said values match. </claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The program storage device readable by a machine in accordance with <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference>, wherein said first value includes a set of mask bits and a set of bits representing said target destination port, said determining step b) including the step of implementing bitwise logic for comparing said received value against said mask bit set and obtaining a first result, comparing said first result against said target destination port bits, and initiating re-routing of said packet to another destination port when said first result does not match said target destination port bits. </claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The program storage device readable by a machine in accordance with <dependent-claim-reference depends_on="CLM-00011">claim 18</dependent-claim-reference>, wherein said data structure receives two values defining a range of NP devices that are not operational, said determining step b) implementing logic for comparing a bit representation of a target NP device of a packet to be routed against said each of said two values defining said range, and initiating re-routing of said packet to another destination port outside said range when said bit representation of said target NP device falls within said two values.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>1</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030002443A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030002443A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030002443A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
