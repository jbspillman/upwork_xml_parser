<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030001834A1-20030102-D00000.TIF SYSTEM "US20030001834A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030001834A1-20030102-D00001.TIF SYSTEM "US20030001834A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030001834A1-20030102-D00002.TIF SYSTEM "US20030001834A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030001834A1-20030102-D00003.TIF SYSTEM "US20030001834A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030001834A1-20030102-D00004.TIF SYSTEM "US20030001834A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030001834A1-20030102-D00005.TIF SYSTEM "US20030001834A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030001834A1-20030102-D00006.TIF SYSTEM "US20030001834A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030001834A1-20030102-D00007.TIF SYSTEM "US20030001834A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030001834A1-20030102-D00008.TIF SYSTEM "US20030001834A1-20030102-D00008.TIF" NDATA TIF>
<!ENTITY US20030001834A1-20030102-D00009.TIF SYSTEM "US20030001834A1-20030102-D00009.TIF" NDATA TIF>
<!ENTITY US20030001834A1-20030102-D00010.TIF SYSTEM "US20030001834A1-20030102-D00010.TIF" NDATA TIF>
<!ENTITY US20030001834A1-20030102-D00011.TIF SYSTEM "US20030001834A1-20030102-D00011.TIF" NDATA TIF>
<!ENTITY US20030001834A1-20030102-D00012.TIF SYSTEM "US20030001834A1-20030102-D00012.TIF" NDATA TIF>
<!ENTITY US20030001834A1-20030102-D00013.TIF SYSTEM "US20030001834A1-20030102-D00013.TIF" NDATA TIF>
<!ENTITY US20030001834A1-20030102-D00014.TIF SYSTEM "US20030001834A1-20030102-D00014.TIF" NDATA TIF>
<!ENTITY US20030001834A1-20030102-D00015.TIF SYSTEM "US20030001834A1-20030102-D00015.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030001834</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09867878</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010529</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F017/00</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>345</class>
<subclass>418000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Methods and apparatuses for controlling transformation of two and three-dimensional images</title-of-invention>
</technical-information>
<continuity-data>
<continuations>
<continuation-of>
<parent-child>
<child>
<document-id>
<doc-number>09867878</doc-number>
<kind-code>A1</kind-code>
<document-date>20010529</document-date>
</document-id>
</child>
<parent>
<document-id>
<doc-number>09557943</doc-number>
<document-date>20000424</document-date>
<country-code>US</country-code>
</document-id>
</parent>
<parent-status>GRANTED</parent-status>
<parent-patent>
<document-id>
<doc-number>6320583</doc-number>
<country-code>US</country-code>
</document-id>
</parent-patent>
</parent-child>
</continuation-of>
</continuations>
<continuations>
<continuation-of>
<parent-child>
<child>
<document-id>
<doc-number>09557943</doc-number>
<document-date>20000424</document-date>
<country-code>US</country-code>
</document-id>
</child>
<parent>
<document-id>
<doc-number>08882721</doc-number>
<document-date>19970625</document-date>
<country-code>US</country-code>
</document-id>
</parent>
<parent-status>GRANTED</parent-status>
<parent-patent>
<document-id>
<doc-number>6147692</doc-number>
<country-code>US</country-code>
</document-id>
</parent-patent>
</parent-child>
</continuation-of>
</continuations>
</continuity-data>
<inventors>
<first-named-inventor>
<name>
<given-name>Christopher</given-name>
<middle-name>D.</middle-name>
<family-name>Chaw</family-name>
</name>
<residence>
<residence-us>
<city>Santa Cruz</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Orion</given-name>
<family-name>Wilson</family-name>
</name>
<residence>
<residence-us>
<city>West Lake Village</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>KENYON &amp; KENYON (SAN JOSE)</name-1>
<name-2></name-2>
<address>
<address-1>333 WEST SAN CARLOS ST.</address-1>
<address-2>SUITE 600</address-2>
<city>SAN JOSE</city>
<state>CA</state>
<postalcode>95110</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">Methods and apparatuses described herein automate and confer additive properties to morphs (modification of a starting graphical image to a destination graphical image). The enhanced automated additive morphs created by this invention extend the currently limited scope of animation techniques, creating: moving morphs, where characters can speak, move, and emote during the morphing process; parametric character creation, where features can be sequentially added to a character to create a wide variety of resulting characters; behavioral transference, where character behavior can be automatically transferred to newly created characters, and behavioral layering whereby sequential behavior patterns can be concurrently transferred or imparted to a character. The present invention allows an animator to create, animate, control and transform two and three dimensional images instantaneously and fluidly. The invention provides a superior solution at significantly less cost which extends the range and properties of existing state of the art animation. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">FIELD OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> The present invention pertains to automated methods and apparatuses for the controlling and transforming of two and three-dimensional images. More particularly, the present invention relates to methods and apparatuses for changing the elements of image through the use of one or more sets of modification data in real time. </paragraph>
</section>
<section>
<heading lvl="1">COPYRIGHT NOTICE </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or patent disclosure as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever. </paragraph>
</section>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 8, a</cross-reference> computer system that is known in the art is shown. The computer system <highlight><bold>810</bold></highlight> includes a system unit having a processor <highlight><bold>811</bold></highlight>, such as a Pentium&reg; D processor manufactured by Intel Corporation, Santa Clara, Calif. The processor is coupled to system memory <highlight><bold>812</bold></highlight> (e.g., Random Access Memory (RAM)) via a bridge circuit <highlight><bold>813</bold></highlight>. The bridge circuit <highlight><bold>813</bold></highlight> couples the processor <highlight><bold>811</bold></highlight> and system memory <highlight><bold>812</bold></highlight> to a bus <highlight><bold>814</bold></highlight>, such as one operated according to the Peripheral Component Interconnect standard (Version 2.1, 1995, PCI Special Interest Group, Portland, Oreg.). The system unit <highlight><bold>810</bold></highlight> also includes a graphics adapter <highlight><bold>815</bold></highlight> coupled to the bus <highlight><bold>814</bold></highlight> which converts data signals from the bus into information for output at a display <highlight><bold>820</bold></highlight>, such as a cathode ray tube (CRT) display, active matrix display, etc. Using the computer system of <cross-reference target="DRAWINGS">FIG. 1, a</cross-reference> graphical image can be displayed at display <highlight><bold>820</bold></highlight>. The graphical image can be created internally to the computer system <highlight><bold>810</bold></highlight> or can be input via an input device <highlight><bold>830</bold></highlight> (such as a scanner, video camera, digital camera, etc.). As is known in the art, a graphical image is stored as a number of two-dimensional picture elements or &ldquo;pixels,&rdquo; each of which can be displayed. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> In the current art, graphical images (e.g., of a person&apos;s face) can be changed by allowing the user to modify a graphical image by &ldquo;moving&rdquo; (e.g., with a cursor movement device such as a mouse) the two-dimensional location of one or more pixels ( For example: Adobe Photoshop Version 3.0.5 (Adobe Systems, Inc., San Jose, Calif.)). In doing so, the other pixels around the one that is being moved are filled in with new data or other pixel data from the graphical image. For example, the graphical image of the person&apos;s face can be modified using this product by making the person&apos;s nose larger or smaller. This two-dimensional phenomenon is analogous to stretching and warping a photograph printed on a &ldquo;rubber sheet.&rdquo; In the Kai&apos;s Power Goo product by MetaTools, Inc (Carpinteria, Calif.), photographic distortions can be performed in &ldquo;real time&rdquo; by the operator&apos;s &ldquo;clicking and dragging&rdquo; with a mouse across the surface of a photo displayed on the computer screen. The operator can see the photograph stretch as the mouse is moved. This procedure covers only two dimensional art and does not permit any sophisticated character animation such as speech or emotion. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> In the current art, the gradual change of the shape of one image into that of another as seen in film and video is called a &ldquo;morph&rdquo;. Current morphs are created by an operator who instructs a computer to distort the shape of a specific starting image into the shape of a specific target image. Morphing programs typically work by allowing the operator to select points on the outline of the specific starting image and then to reassign each of these points to a new location, thereby defining the new outline of the desired target image. The computer then performs the morph by: (1) smoothly moving each of these points along a path from start to finish and (2) interpolating the movement of all the other points within the image as the morph takes place. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> There are two distinct disadvantages to this method described above. First, it requires that a custom morph be created for each desired transformation. Second, because this method requires the selection of a single image or frame upon which the morph is performed, the frame-by-frame progression of character action must stop during the period in which the morph is performed. This is why in current films, characters do not speak or move during the morph procedure. The reason morphs are currently performed relatively quickly (i.e., within a few seconds) is so that this freezing of action is not fully noticed by the audience. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> In recent films, whenever a character morphs (e.g. when the villain robot in James Cameron&apos;s &ldquo;Terminator 2&rdquo; changes to its liquid metal form), the character ceases moving while the morph takes place. In the &ldquo;Fifth Element&rdquo; released in May of 1997, characters are seen changing from alien to human form while they shake their heads back and forth. Although this gives the character the appearance of moving while the morph is taking place, the underlying 3D image of a character&apos;s head is actually frozen while it shakes. This method is merely the 3D equivalent of a &ldquo;freeze frame.&rdquo; This method cannot enable a morphing character to speak, move or emote while a morph is taking place. The static morphing methods used in today&apos;s films are slow and considerably expensive. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> According to an embodiment of the present invention a first region of a first graphical image is identified and then it is modified based on a first set of predetermined modification data. Using this method to morph a graphical image, a variety of applications can be performed according to further embodiments of the present invention. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> First, the morph (e.g., the application of modification data) for a first starting image can be readily applied to other starting images. In other words, the morphs automatically impart desired characteristics in a custom manner to a multiplicity of starting images. This an improvement over the prior art which requires a customized selection and reassignment of points on a specific starting image to create a morph. A method of the present invention described herein automates this process. Rather than requiring an artist or technician to custom create a morph of a specific image, for example, an adult into that of a child, the morphs of the present invention enable a wide variety of human, animal, or other characters to be rendered chimplike using a single &ldquo;chimp&rdquo; morph. An example of this is shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, where a single morph relating to &ldquo;chimpification&rdquo; is applied to three different starting images. In each case, the resulting image maintains recognizable features of the starting image while uniquely embodying the desired characteristics of the &ldquo;chimp&rdquo; morph. The morph has been described thus far as modification data. Examples of modification data includes deltasets and deltazones described in more detail below. Briefly, deltasets or zones categorically identify regions, feature by feature within differing starting images so that these images are uniquely altered to preserve the automated morph&apos;s desired effect. Because a single morph can be applied to a number of different starting images, the morph exists as a qualitative entity independently from the images it acts upon. This independence creates an entirely new tool, a morph library, a collection of desired alterations or enhancements which can be generically used on any starting image to create specific desired effects as illustrated in the above &ldquo;chimpification&rdquo; example. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> Second, once an image has been morphed to add a particular characteristic or quality, the resulting image can be subjected to a different morph to add a second characteristic or quality. <cross-reference target="DRAWINGS">FIG. 2</cross-reference> illustrates a simple example of this additive property wherein a &ldquo;chimp&rdquo; morph is added to a &ldquo;child&rdquo; morph to create a childlike chimp (other examples will be described in further detail below). The additive property of the automated, additive morphing system can be used in a number of ways to bring new functionality and scope to the morphing process. Five distinct additive properties of automated, additive morphs will be described below along with their practical application. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> Third, morphs can be provided that allow a graphical image character to speak, move, emote, etc. According to an embodiment of the invention, a moving morph can be created during which a character can continue speaking, moving, and emoting by cross applying an automated additive morph to a (&ldquo;morph sequence&rdquo;). The morph sequence that is known in the art (such as what is shown in programs by Dr. Michael Cohen at the University of California at Santa Cruz and products of Protozoa Inc. (San Francisco, Calif.) allows for computer-generated characters to move their mouths in a manner which approximates speech by running their characters through a sequence of &ldquo;Viseme&rdquo; morphs. (A Viseme is the visual equivalent of a phoneme, i.e. the face one makes when making a phonetic sound.) Such programs use a specific initial image of a character at rest, and a collection of target images. Each target image corresponds to a particular facial position or &ldquo;Viseme&rdquo; used in common speech. <cross-reference target="DRAWINGS">FIG. 3</cross-reference> shows how these target images can be strung together in a morph sequence to make an animated character approximate the lip movements of speech. This figure shows the sequence of Viseme endpoints which enable the character to mouth the word &ldquo;pony&rdquo;. It is important to note that the creation and performance of this sequence does not require the special properties of the morphing system presented herein. The morphs within this sequence in the prior art are not generalized (all are distortions of one specific starting image), and they are not additive. Visemes used in the prior art follow one after the other and are not added to one another. According to an embodiment of the present invention, the use of morph sequences is extended to generate not only speech, but also emotive flow and the physical components of emotional reactions. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> For example, <cross-reference target="DRAWINGS">FIG. 4</cross-reference> shows the cross-addition of an automated, additive morph to the &ldquo;pony&rdquo; morph sequence described above in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>. In that figure, the four vertical columns of character pictures represent the progressive application of the &ldquo;chimp&rdquo; morph described earlier (from left to right multiplying the modification data by multiplication values of 0%, 33%, 66%, 100% prior to application to the starting image). Because the &ldquo;chimp&rdquo; morph is non-specific as to its starting point (as are all automated additive morphs according to the present invention) it is possible to increasingly apply the &ldquo;chimp&rdquo; morph while changing the starting point within the morph Sequence, producing the progression shown in the darkened diagonal of squares. This diagonal progression, shown in horizontal fashion at the bottom of <cross-reference target="DRAWINGS">FIG. 4</cross-reference> yields a character which can speak while this character is morphing. This is the underlying structure of the moving morph. Traditional morphs, (being specific rather than generic) cannot be cross-applied in this manner. Characters created using the methods of the present invention can be made to not only speak, but also emote, and react from morph sequences. Thus, characters can remain fully functional during an automated, additive morph rather than being required to &ldquo;freeze frame&rdquo; until the morph has been completed as do the morphs of the prior art. An additional benefit of this cross-additive procedure is that morphs can be stopped at any point to yield a fully functional, consistent new character which is a hybrid of the starting and final characters. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> Fourth, the methods of the present invention provide for parametric character creation in which newly created characters automatically speak, move, and emote using modification data stored in a database or library. In the automated, additive morphing system, (1) morphs can exist as qualitative attributes independent of any particular starting image, and (2) morphs can be applied, one after the other, to produce a cumulative effect. When qualitative attributes are defined as appearance parameters (length or width of nose, prominence of jaw parameters, roundness of face, etc.) these attributes can be selectively applied in such a way as to create any desired face from one single starting image. As an example, a multi-racial starting character is defined and a morph library of appearance parameters is created which can be used to adjust the characters features so as to create any desired character. <cross-reference target="DRAWINGS">FIG. 5</cross-reference> shows an example of this process. The parameter adjustments in this figure are coarse and cartoon-like so as to yield clearly visible variations. In realistic character generation, a much larger number of parameters can be more gradually applied. The first three morphs shown in this illustration are &ldquo;shape morphs.&rdquo; In the final step of <cross-reference target="DRAWINGS">FIG. 5</cross-reference>, the coloration or &ldquo;skin&rdquo; which is laid over the facial shape is changed rather than the shape itself. This step can be used to create the desired hair color, eye color, skin tone, facial hair, etc. in the resultant character. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> Fifth, the parametric character creation described above can be combined with the moving morph, also described above, to create characters which automatically speak, emote and move. This dual application is illustrated in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>, wherein not only the underlying structure, but also the full speaking and emoting functionality of the original character are automatically transferred to the new character. The character shown in <cross-reference target="DRAWINGS">FIG. 6</cross-reference> not only contains a mutable physical appearance, but also a full set of Visemes, emotions, and computer triggered autonomous and reactive behavior. All of these functions can be automatically transferred to a vast range of characters which can be created using parametric character creation. This represents an exponential savings in animation time and cost over existing procedures which require custom creation of not only the character itself, but every emotion, Viseme, blink, etc. that the new character makes. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> Sixth, morph sequences can be used simultaneously to combine different behavioral sequences. <cross-reference target="DRAWINGS">FIG. 7</cross-reference> illustrates the simultaneous utilization of an emoting sequence and a speaking sequence. In this figure, the Viseme sequence required to make the character say &ldquo;pony&rdquo; (left column of pictures) has been added to an emotive morph sequence (center column) in such a manner that the timing of each sequence is preserved. The resultant sequence (right column) creates a character which can simultaneously speak and react with emotions. This procedure can also be used to combine autonomous emotive factors (a computer-generated cycling of deltas representing different emotions or &ldquo;moods&rdquo;) with reactive factors (emotional deltas triggered by the proximity of elements within the character&apos;s environment which have assigned emotive influences on the character). Such procedures can be used to visualize the interplay between conscious and subconscious emotions. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> The foregoing examples and other examples of the present invention will be described in further detail below.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> shows an example of an automated morph according to an embodiment of the present invention. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> shows an example of an automated, additive morph according to an embodiment of the present invention. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> shows an example of a morph sequence that can be performed according to an embodiment of the present invention. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> shows an example of a moving morph according to an embodiment of the present invention. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> shows an example of parametric character creation according to an embodiment of the present invention. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> shows an example of automatic behavioral transference according to an embodiment of the present invention. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> shows an example of behavioral layering according to an embodiment of the present invention. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> is a computer system that is known in the art. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference> is a general block diagram of an image transformation system of the present invention. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 10</cross-reference><highlight><italic>a</italic></highlight>-<highlight><italic>d </italic></highlight>are polygonal models used for the presentation of a graphical image of a human head or the like. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 11</cross-reference><highlight><italic>a</italic></highlight>-<highlight><italic>f </italic></highlight>are polygonal images showing the application of deltaset in accordance with an embodiment of the present invention. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 12</cross-reference><highlight><italic>a</italic></highlight>-<highlight><italic>g </italic></highlight>are graphical images of a person&apos;s head that are generated in accordance with an embodiment of the present invention. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 13</cross-reference> shows an input device for controlling the amount of transformation occurs when applying a deltaset to an image. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 14</cross-reference><highlight><italic>a</italic></highlight>-<highlight><italic>d </italic></highlight>are graphical images of a person&apos;s head that are generated in accordance with an embodiment of the present invention. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 15</cross-reference> shows a communication system environment for an exemplary method of the present invention.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION </heading>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> According to an embodiment of the present invention modification data is generated that can be applied to a starting image so as to form a destination image. For example, the modification data can be difference values that are generated by determining the differences between first and second images. Once these differences are determined they can be stored and later applied to any starting image to create a new destination image without the extensive frame-by-frame steps described above with respect to morphing performed in the motion picture industry. These difference values can be created on a vertex-by- vertex basis to facilitate the morphing between shapes that have an identical number of vertices. Alternatively, difference values can be assigned spatially, so that the location of points within the starting image determines the motion within the automated morph. This eliminates the need for explicit identification of vertices and allows these methods and apparatuses to work regardless of a given image&apos;s polygonal structure. For simplicity sake we describe an example vertex-based automated additive morphing system below which uses deltasets as the modification data. A position or spatially-based morphing system which can morph images regardless of polygonal structure, such as deltazones (another example of modification data), is created by interpolating the motion between vertices. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> An example of the vertices-based embodiment of the present invention includes the generation of a first image (e.g., a neutral or starting image) comprising a first number of vertices, each vertex having a spatial location (e.g., in two or three dimensional space) and a second image is generated (e.g. a target or destination image) having an equal number of vertices. A difference between a first one of the vertices of the first image and a corresponding vertex of the second image is determined representing the difference in location between the two vertices. The difference is then stored in a memory device (e.g., RAM, hard-disc drive, etc.). Difference values for all corresponding vertices of the first and second images can be created using these steps and stored as a variable array (referred to herein as a deltaset). The deltaset can then be applied to the first image to create the second image by moving the vertices in the first image to their corresponding locations in the second image. Alternatively, a multiplication or ratio value can be multiplied by the entries in the deltaset and applied to the first image so that an intermediate graphical image is created. According to a feature of the present invention, the deltaset can be applied to any starting image having an equal number of vertices. This allows the user to create new destination images without performing, again, the mathematical calculations used to create the original deltaset. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 9, a</cross-reference> general block diagram of an image transformation system <highlight><bold>900</bold></highlight> of the present invention is shown. According to an embodiment of the present invention, the system <highlight><bold>900</bold></highlight> includes a library or database of deltasets <highlight><bold>931</bold></highlight>. The library of deltasets <highlight><bold>931</bold></highlight> can be stored in the system memory <highlight><bold>912</bold></highlight> or any other memory device, such as a hard disc drive <highlight><bold>917</bold></highlight> coupled to bus <highlight><bold>914</bold></highlight> via a Small Computer Standard Interface (SCSI) host bus adapter <highlight><bold>918</bold></highlight> (see <cross-reference target="DRAWINGS">FIG. 8</cross-reference>). As described in further detail below, deltasets are variable arrays of position change values that can be applied to the vertices of a starting image. Referring to <cross-reference target="DRAWINGS">FIG. 9</cross-reference>, the deltaset information is composed and cached in device <highlight><bold>932</bold></highlight> (e.g., processor <highlight><bold>811</bold></highlight> and system memory <highlight><bold>812</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 8</cross-reference>) where it then can be used to transform a first or starting image having a neutral geometry <highlight><bold>933</bold></highlight> into a target image having a final geometry <highlight><bold>935</bold></highlight>. Additional geometry manipulation can be performed such as the addition of features (e.g., hair) or actions (e.g., looking around) by device <highlight><bold>934</bold></highlight>. Both the starting and second images can then be displayed at display <highlight><bold>920</bold></highlight>, or any other output device (memory) or sent to file export (e.g., the Internet system). </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> Inputs to the system <highlight><bold>900</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 9</cross-reference> include a variety of user controls <highlight><bold>937</bold></highlight>; autonomous behavior control <highlight><bold>938</bold></highlight>; and face tracker data input <highlight><bold>939</bold></highlight> which will be further described below. Other inputs can come from other systems such as the so-called World-Wide Web (WWW). Also audio data can be supplied by audio data input device <highlight><bold>940</bold></highlight> which can be supplied to deltaset caching and composing device <highlight><bold>932</bold></highlight>. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> In this embodiment, the neutral geometry <highlight><bold>933</bold></highlight> is based on the image of a person&apos;s head that has been captured using any of a variety of known methods (e.g., video, scanner, etc.). Referring to <cross-reference target="DRAWINGS">FIG. 10</cross-reference>, the image data of the person&apos;s head is placed onto a polygonal model <highlight><bold>1051</bold></highlight>. The polygonal model comprises a plurality of vertices <highlight><bold>1052</bold></highlight> and connections <highlight><bold>1053</bold></highlight> that extend between the vertices. Each polygon <highlight><bold>1054</bold></highlight> of the polygonal model is defined by three or more vertices <highlight><bold>1052</bold></highlight>. To show the generation and application of deltasets to the polygonal model of <cross-reference target="DRAWINGS">FIG. 10</cross-reference><highlight><italic>a</italic></highlight>, an example is discussed below using simple polygons (e.g., a square, a triangle, a rectangle, and a circle). </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> Each polygon has an identifiable shape. For example, looking at <cross-reference target="DRAWINGS">FIG. 11</cross-reference><highlight><italic>a</italic></highlight>, a square polygon is shown having 8 vertices (points <highlight><bold>1100</bold></highlight> to <highlight><bold>1107</bold></highlight>) in two-dimensional space. By moving individual vertices, the square polygon can be converted into a number of other polygon shapes such as a rectangle (<cross-reference target="DRAWINGS">FIG. 11</cross-reference><highlight><italic>b</italic></highlight>), a circle (<cross-reference target="DRAWINGS">FIG. 11</cross-reference><highlight><italic>c</italic></highlight>) and a triangle (<cross-reference target="DRAWINGS">FIG. 11</cross-reference><highlight><italic>d</italic></highlight>; where vertices <highlight><bold>1100</bold></highlight>, <highlight><bold>1101</bold></highlight>, and <highlight><bold>1107</bold></highlight> all occupy the same point in two-dimensional space). A deltaset is a set of steps that are taken to move each vertex (<highlight><bold>1100</bold></highlight> to <highlight><bold>1107</bold></highlight>) from a starting polygon to a target or destination polygon. For example, the steps that are taken from the square polygon of <cross-reference target="DRAWINGS">FIG. 11</cross-reference><highlight><italic>a </italic></highlight>to the rectangular polygon of <cross-reference target="DRAWINGS">FIG. 11</cross-reference><highlight><italic>b </italic></highlight>include vertices <highlight><bold>1105</bold></highlight>, <highlight><bold>1106</bold></highlight>, and <highlight><bold>1107</bold></highlight> moving to the left a certain distance &ldquo;x&rdquo;; points <highlight><bold>1101</bold></highlight>, <highlight><bold>1102</bold></highlight>, and <highlight><bold>1103</bold></highlight> moving to the right the same distance &ldquo;x&rdquo;; and vertices <highlight><bold>1100</bold></highlight> and <highlight><bold>1104</bold></highlight> staying in the same location. Thus, the deltaset defines the path taken by each vertex in transforming the starting polygon to the destination polygon. In other words, the deltaset defines the difference in position of corresponding vertices in the starting and target polygons. Similarly, deltasets can be created for the transformation of the square polygon of <cross-reference target="DRAWINGS">FIG. 11</cross-reference><highlight><italic>a </italic></highlight>to the circle polygon of <cross-reference target="DRAWINGS">FIG. 11</cross-reference><highlight><italic>c </italic></highlight>and of the square polygon of <cross-reference target="DRAWINGS">FIG. 11</cross-reference><highlight><italic>a </italic></highlight>to the triangle polygon of <cross-reference target="DRAWINGS">FIG. 11</cross-reference><highlight><italic>d. </italic></highlight></paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> In this embodiment, the deltaset is created by transforming a starting polygon shape into another, however, one skilled in the art will appreciate that a deltaset can be created that are not based on specific starting and target shapes, but created in the abstract. Moreover, once a deltaset is created, it can be used on any starting shape to create a new shape. For example, the deltaset used to transform the square polygon of <cross-reference target="DRAWINGS">FIG. 11</cross-reference><highlight><italic>a </italic></highlight>to the rectangle polygon of <cross-reference target="DRAWINGS">FIG. 11</cross-reference><highlight><italic>b </italic></highlight>(for convenience, referred to as Deltaset<highlight><bold>1</bold></highlight>) can be used on the circle polygon of <cross-reference target="DRAWINGS">FIG. 11</cross-reference><highlight><italic>c</italic></highlight>. Thus, the circle polygon of <cross-reference target="DRAWINGS">FIG. 11</cross-reference><highlight><italic>c </italic></highlight>becomes the starting shape and after applying Deltaset<highlight><bold>1</bold></highlight>, would become the ellipse polygon of <cross-reference target="DRAWINGS">FIG. 11</cross-reference><highlight><italic>e </italic></highlight>(i.e., the target shape). </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> Deltasets can also be combined (e.g., added together) to create new deltasets. Thus, Deltaset<highlight><bold>1</bold></highlight>, Deltaset<highlight><bold>2</bold></highlight> (i.e., transform from the square of <cross-reference target="DRAWINGS">FIG. 11</cross-reference><highlight><italic>a </italic></highlight>to the circle of <cross-reference target="DRAWINGS">FIG. 11</cross-reference><highlight><italic>c</italic></highlight>), and Deltaset<highlight><bold>3</bold></highlight> (i.e., transform from the square of <cross-reference target="DRAWINGS">FIG. 11</cross-reference><highlight><italic>a </italic></highlight>to the triangle of <cross-reference target="DRAWINGS">FIG. 11</cross-reference><highlight><italic>c</italic></highlight>) can be combined to form a new deltaset (Deltaset<highlight><bold>4</bold></highlight>). Applying Deltaset<highlight><bold>4</bold></highlight> to the starting square polygon of <cross-reference target="DRAWINGS">FIG. 11</cross-reference><highlight><italic>a</italic></highlight>, the target shape of <cross-reference target="DRAWINGS">FIG. 11</cross-reference><highlight><italic>f </italic></highlight>is achieved. In its simplest form, the starting polygon, destination polygon, and deltaset must have the same number of vertices. Additional algorithms would be necessary to transform between shapes or objects having a differing number of vertices. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> An additional method for moving vertices can be derived from the deltaset method wherein the motion to the points of a deltaset are interpolated such that a continuous field of motion is created. These fields which we refer to as deltazones can be used to morph images irrespective of their particular triangle strip set because a one to one correspondence between movements and vertices upon which the deltasets rely are replaced by a dynamical system of motion which operates on any number of vertices by moving them in accordance with their original location. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> Herein, an example of the implementation of deltasets and their operation on graphical images will be described with reference to pseudocode based on &ldquo;C&rdquo; and &ldquo;C&plus;&plus;&rdquo; programming that is known in the art. The datatype structure for a deltaset (Deltaset_Type) is similar to that for a basic shape object, and the pseudocode is shown in Table I.  
<table-cwu id="TABLE-US-00001">
<number>1</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<thead>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center">TABLE I</entry>
</row>
<row>
<entry></entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
<entry>////////////////////////////////////////////////////////</entry>
</row>
<row>
<entry></entry>
<entry>// Basic datatype structure of a deltaset.</entry>
</row>
<row>
<entry></entry>
<entry>typedef struct &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="91PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>dataPoint_Type</entry>
<entry>*dataPoints;</entry>
<entry>// Array of delta values</entry>
</row>
<row>
<entry></entry>
<entry>int</entry>
<entry>numPoints;</entry>
<entry>// Number of points in above</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub; deltaSet_Type, shape_Type;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>//&emsp;&ensp;end of datatype structure</entry>
</row>
<row>
<entry></entry>
<entry>////////////////////////////////////////////////////////</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> As seen from the above, the Deltaset_Type and shape_type variables each include an array of &lsqb;numpoints&rsqb; values. Each value is a position of a vertex for the shape_type variable and delta value for the Deltaset_Type variable. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> An example of a core routine for the creation of a deltaset through the calculation of the steps or difference values from a starting object to a destination object is shown in Table II.  
<table-cwu id="TABLE-US-00002">
<number>2</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center">TABLE II</entry>
</row>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>//////////////////////////////////////////////////////////////////</entry>
</row>
<row>
<entry>// core Routine to calculate the steps from a source (neutral)</entry>
</row>
<row>
<entry>// object to a destination object and store those steps</entry>
</row>
<row>
<entry>// in a deltaset.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="112PT" align="left"/>
<colspec colname="2" colwidth="105PT" align="left"/>
<tbody valign="top">
<row>
<entry>DeltaSet_Calc(deltaSet_Type</entry>
<entry>*dset,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="70PT" align="left"/>
<colspec colname="2" colwidth="105PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>shape_Type</entry>
<entry>*src</entry>
</row>
<row>
<entry></entry>
<entry>shape_Type</entry>
<entry>*dest)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>&lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry>int</entry>
<entry>i;</entry>
</row>
<row>
<entry>int</entry>
<entry>numpts;</entry>
</row>
<row>
<entry>dataPoint_Type</entry>
<entry>delta;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>// Ensure that dset has a matching number of data points as the shapes.</entry>
</row>
<row>
<entry>Numpts &equals; src -&gt; numPoints;</entry>
</row>
<row>
<entry>deltaSet_SetNumPts (dset, numpts);</entry>
</row>
<row>
<entry>// For each data point in the objects, calculate the</entry>
</row>
<row>
<entry>// difference between the source and the destination</entry>
</row>
<row>
<entry>// and store the result in the deltaset.</entry>
</row>
<row>
<entry>for (i &equals; 0; i &lt; numpts; i&plus;&plus;)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub;</entry>
</row>
<row>
<entry></entry>
<entry>delta &equals; dest -&gt; dataPoints&lsqb;i&rsqb; &minus; src -&gt; dataPoints&lsqb;i&rsqb;;</entry>
</row>
<row>
<entry></entry>
<entry>dset -&gt; dataPoints&lsqb;i&rsqb; &equals; delta;</entry>
</row>
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>&rcub;</entry>
</row>
<row>
<entry>// end of routine</entry>
</row>
<row>
<entry>////////////////////////////////////////////////////////////</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> As can be seen from the above pseudocode, the variable &ldquo;delta&rdquo; is used to temporarily store the difference in position between the source (src) and destination (dest) for each of the vertices in the shape. Each delta value is then stored in a deltaset array (dset). Once a deltaset array is created, it can be easily applied to any starting shape having an equal number of vertices to form a new target shape. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> An example of pseudocode that can be used to modify a deltaset so that it can be applied to a starting shape is shown in Table III.  
<table-cwu id="TABLE-US-00003">
<number>3</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="196PT" align="left"/>
<thead>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center">TABLE III</entry>
</row>
<row>
<entry></entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
<entry>//////////////////////////////////////////////////////////////////</entry>
</row>
<row>
<entry></entry>
<entry>// core Routine to apply the steps stored in a</entry>
</row>
<row>
<entry></entry>
<entry>// deltaset to a shape, with a percentage amount.</entry>
</row>
<row>
<entry></entry>
<entry>// Note that negative amounts can be used.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="98PT" align="left"/>
<colspec colname="2" colwidth="98PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>deltaSet_Apply (deltaSet_Type</entry>
<entry>*dset,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="77PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="98PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>shape_Type</entry>
<entry>*dest,</entry>
</row>
<row>
<entry></entry>
<entry>float</entry>
<entry>amount)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="196PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub;</entry>
</row>
<row>
<entry></entry>
<entry>int&emsp;i;</entry>
</row>
<row>
<entry></entry>
<entry>if (amount &equals;&equals; 0.0)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="35PT" align="left"/>
<colspec colname="1" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>return;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="196PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>for (i &equals; 0 ; i &lt; dset -&gt; numPoints; i&plus;&plus;)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="35PT" align="left"/>
<colspec colname="1" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub;</entry>
</row>
<row>
<entry></entry>
<entry>dest -&gt; dataPoints&lsqb;i&rsqb; &plus;&equals; (dset -&gt; dataPoints &lsqb;i&rsqb; * amount);</entry>
</row>
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="196PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>// end of routine</entry>
</row>
<row>
<entry></entry>
<entry>//////////////////////////////////////////////////////////////////</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> As seen from above, during the routine Deltaset_Apply, calculations for a single transition are performed based on a percentage amount passed using the &ldquo;amount.&rdquo; Each data point in the destination shape is calculated based on the deltaset value for that point multiplied by the percentage value &ldquo;amount&rdquo; (which can have a negative value or a value greater than 1). </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> The pseudocode of Table IV shows two utility routines that are used for creating a new, blank deltaset and to set the number of datapoints.  
<table-cwu id="TABLE-US-00004">
<number>4</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<thead>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center">TABLE IV</entry>
</row>
<row>
<entry></entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
<entry>//////////////////////////////////////////////////////////////////</entry>
</row>
<row>
<entry></entry>
<entry>// utility Routine to create a new, Blank deltaset</entry>
</row>
<row>
<entry></entry>
<entry>deltaSet_Type *NewDeltaSet()</entry>
</row>
<row>
<entry></entry>
<entry>&lcub;</entry>
</row>
<row>
<entry></entry>
<entry>allocate a new deltraSet_Type and return a pointer to it.</entry>
</row>
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>// end of routine</entry>
</row>
<row>
<entry></entry>
<entry>//////////////////////////////////////////////////////////////////</entry>
</row>
<row>
<entry></entry>
<entry>//////////////////////////////////////////////////////////////////</entry>
</row>
<row>
<entry></entry>
<entry>// utility Routine to set the number of datapoints</entry>
</row>
<row>
<entry></entry>
<entry>// in a deltaset.</entry>
</row>
<row>
<entry></entry>
<entry>deltaSet_SetNumPts (deltaSet_Type *dset, int numPoints)</entry>
</row>
<row>
<entry></entry>
<entry>&lcub;</entry>
</row>
<row>
<entry></entry>
<entry>de-allocate dset -&gt; dataPoints, if not already empty;</entry>
</row>
<row>
<entry></entry>
<entry>allocate an array of type dataPoint_Type and size numPoints,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>and put it in dset -&gt; dataPoints;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>dset -&gt; numPoints &equals; numPoints;</entry>
</row>
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>// end of routine</entry>
</row>
<row>
<entry></entry>
<entry>//////////////////////////////////////////////////////////////////</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> With reference to Table V, an example of pseudocode is shown for the transformation from the square shape of <cross-reference target="DRAWINGS">FIG. 11</cross-reference><highlight><italic>a </italic></highlight>to the shape of <cross-reference target="DRAWINGS">FIG. 11</cross-reference><highlight><italic>e</italic></highlight>.  
<table-cwu id="TABLE-US-00005">
<number>5</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center">TABLE V</entry>
</row>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>////////////////////////////////////////////////////////////////////////</entry>
</row>
<row>
<entry>// The following pseudocode example shows how</entry>
</row>
<row>
<entry>// to use the above deltaset routines to morph from a</entry>
</row>
<row>
<entry>// square to a new shape which has features of both the</entry>
</row>
<row>
<entry>// rectangle and the circle.</entry>
</row>
<row>
<entry>// Define the basic dataPoint that makes shapes &amp; deltasets.</entry>
</row>
<row>
<entry>typedef 2DVector dataPoint_Type;</entry>
</row>
<row>
<entry>// Declaration of basic shapes.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry>shape_Type</entry>
<entry>Square,</entry>
</row>
<row>
<entry></entry>
<entry>Rectangle,</entry>
</row>
<row>
<entry></entry>
<entry>Circle;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>// Declaration of deltasets.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry>deltaSet_Type</entry>
<entry>rect_dset,</entry>
</row>
<row>
<entry></entry>
<entry>circ_dset;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>// Declaration of a new shape to get the data put into it.</entry>
</row>
<row>
<entry>shape_Type&emsp;&emsp;newshape;</entry>
</row>
<row>
<entry>// Initialize shapes.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="119PT" align="left"/>
<colspec colname="2" colwidth="98PT" align="left"/>
<tbody valign="top">
<row>
<entry>shape_SetNumPoints(&amp;square,</entry>
<entry>8);</entry>
</row>
<row>
<entry>shape_SetNumPoints(&amp;rectangle,</entry>
<entry>8);</entry>
</row>
<row>
<entry>shape_SetNumPoints(&amp;circle,</entry>
<entry>8);</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>// set data points of square, rectangle, and circle.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="105PT" align="left"/>
<colspec colname="2" colwidth="112PT" align="left"/>
<tbody valign="top">
<row>
<entry>shape_SetPoints (&amp;square,</entry>
<entry>(&thinsp;&thinsp;0.0,&emsp;&thinsp;&thinsp;1.0),</entry>
</row>
<row>
<entry></entry>
<entry>(&thinsp;&thinsp;1.0,&emsp;&thinsp;&thinsp;1.0),</entry>
</row>
<row>
<entry></entry>
<entry>(&thinsp;&thinsp;1.0,&emsp;&thinsp;&thinsp;0.0),</entry>
</row>
<row>
<entry></entry>
<entry>(&thinsp;&thinsp;1.0,&emsp;&minus;1.0),</entry>
</row>
<row>
<entry></entry>
<entry>(&thinsp;&thinsp;0.0,&emsp;&minus;1.0),</entry>
</row>
<row>
<entry></entry>
<entry>(&minus;1.0,&emsp;&minus;1.0),</entry>
</row>
<row>
<entry></entry>
<entry>(&minus;1.0,&emsp;&thinsp;&thinsp;0.0),</entry>
</row>
<row>
<entry></entry>
<entry>(&minus;1.0,&emsp;&thinsp;&thinsp;1.0));</entry>
</row>
<row>
<entry>shape_SetPoints (&amp;rectangle,</entry>
<entry>(&thinsp;&thinsp;0.0,&emsp;&thinsp;&thinsp;1.0),</entry>
</row>
<row>
<entry></entry>
<entry>(&thinsp;&thinsp;2.0,&emsp;&thinsp;&thinsp;1.0),</entry>
</row>
<row>
<entry></entry>
<entry>(&thinsp;&thinsp;2.0,&emsp;&thinsp;&thinsp;0.0),</entry>
</row>
<row>
<entry></entry>
<entry>(&thinsp;&thinsp;2.0,&emsp;&minus;1.0),</entry>
</row>
<row>
<entry></entry>
<entry>(&thinsp;&thinsp;0.0,&emsp;&minus;1.0),</entry>
</row>
<row>
<entry></entry>
<entry>(&minus;2.0,&emsp;&minus;1.0),</entry>
</row>
<row>
<entry></entry>
<entry>(&minus;2.0,&emsp;&thinsp;&thinsp;0.0),</entry>
</row>
<row>
<entry></entry>
<entry>(&minus;2.0,&emsp;&thinsp;&thinsp;1.0));</entry>
</row>
<row>
<entry>shape_SetPoints (&amp;circle,</entry>
<entry>(&thinsp;&thinsp;0.0,&emsp;&thinsp;&thinsp;1.0),</entry>
</row>
<row>
<entry></entry>
<entry>(&thinsp;&thinsp;0.0,&emsp;1.0),</entry>
</row>
<row>
<entry></entry>
<entry>(&thinsp;&thinsp;0.0,&emsp;1.0),</entry>
</row>
<row>
<entry></entry>
<entry>(&thinsp;&thinsp;0.0,&emsp;1.0),</entry>
</row>
<row>
<entry></entry>
<entry>(&thinsp;&thinsp;0.0,&emsp;1.0),</entry>
</row>
<row>
<entry></entry>
<entry>(&thinsp;&thinsp;0.0,&emsp;1.0),</entry>
</row>
<row>
<entry></entry>
<entry>(&thinsp;&thinsp;0.0,&emsp;1.0),</entry>
</row>
<row>
<entry></entry>
<entry>(&thinsp;&thinsp;0.0,&emsp;1.0),</entry>
</row>
<row>
<entry></entry>
<entry>(&thinsp;&thinsp;0.0,&emsp;&thinsp;&thinsp;1.0));</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>// calculate DeltaSets</entry>
</row>
<row>
<entry>deltaSet_Calc (&amp;rect_dset, &amp;square, &amp;rectangle);</entry>
</row>
<row>
<entry>deltaSet_Calc (&amp;circ_dset, &amp;square, &amp;circle);</entry>
</row>
<row>
<entry>////////////////////////////////////////////////////////////////////////</entry>
</row>
<row>
<entry>// The resulting DeltaSets now contain the values:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="105PT" align="left"/>
<colspec colname="2" colwidth="112PT" align="left"/>
<tbody valign="top">
<row>
<entry>// rect_dset:</entry>
<entry>(&thinsp;&thinsp;0.0,&emsp;&thinsp;&thinsp;0.0)</entry>
</row>
<row>
<entry>//</entry>
<entry>(&thinsp;&thinsp;1.0,&emsp;&thinsp;&thinsp;0.0)</entry>
</row>
<row>
<entry>//</entry>
<entry>(&thinsp;&thinsp;1.0,&emsp;&thinsp;&thinsp;0.0)</entry>
</row>
<row>
<entry>//</entry>
<entry>(&thinsp;&thinsp;1.0,&emsp;&thinsp;&thinsp;0.0)</entry>
</row>
<row>
<entry>//</entry>
<entry>(&thinsp;&thinsp;0.0,&emsp;&thinsp;&thinsp;0.0)</entry>
</row>
<row>
<entry>//</entry>
<entry>(&minus;1.0,&emsp;&thinsp;&thinsp;0.0)</entry>
</row>
<row>
<entry>//</entry>
<entry>(&minus;1.0,&emsp;&thinsp;&thinsp;0.0)</entry>
</row>
<row>
<entry>//</entry>
<entry>(&minus;1.0,&emsp;&thinsp;&thinsp;0.0)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>////////////////////////////////////////////////////////////////////////</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="105PT" align="left"/>
<colspec colname="2" colwidth="112PT" align="left"/>
<tbody valign="top">
<row>
<entry>//circ_dset:</entry>
<entry>(0.0,&emsp;&thinsp;&thinsp;0.0)</entry>
</row>
<row>
<entry>//</entry>
<entry>(&minus;0.4,&emsp;&minus;0.4)</entry>
</row>
<row>
<entry>//</entry>
<entry>(&thinsp;&thinsp;0.0,&emsp;&thinsp;&thinsp;0.0)</entry>
</row>
<row>
<entry>//</entry>
<entry>(&minus;0.4,&emsp;&thinsp;&thinsp;0.4)</entry>
</row>
<row>
<entry>//</entry>
<entry>(&thinsp;&thinsp;0.0,&emsp;&thinsp;&thinsp;0.0)</entry>
</row>
<row>
<entry>//</entry>
<entry>(&thinsp;&thinsp;0.4,&emsp;&thinsp;&thinsp;0.4)</entry>
</row>
<row>
<entry>//</entry>
<entry>(&thinsp;&thinsp;0.0,&emsp;&thinsp;&thinsp;0.0)</entry>
</row>
<row>
<entry>//</entry>
<entry>(&thinsp;&thinsp;0.0,&emsp;&minus;0.4)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>////////////////////////////////////////////////////////////////////////</entry>
</row>
<row>
<entry>// Apply the DeltaSets.</entry>
</row>
<row>
<entry>newshape &equals; copy of square;</entry>
</row>
<row>
<entry>deltaSet_Apply(&amp;rect_dset, &amp;newshape, 1.0) ;</entry>
</row>
<row>
<entry>deltaSet_Apply(&amp;circ_dset, &amp;newshape, 1.0);</entry>
</row>
<row>
<entry>////////////////////////////////////////////////////////////////////////</entry>
</row>
<row>
<entry>// newshape now contains values which</entry>
</row>
<row>
<entry>// look like the ellipse drawn above:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="105PT" align="left"/>
<colspec colname="2" colwidth="112PT" align="left"/>
<tbody valign="top">
<row>
<entry>//</entry>
<entry>(&thinsp;&thinsp;0.0,&emsp;&thinsp;&thinsp;1.0)</entry>
</row>
<row>
<entry>//</entry>
<entry>(&thinsp;&thinsp;1.6,&emsp;&thinsp;&thinsp;0.6)</entry>
</row>
<row>
<entry>//</entry>
<entry>(&thinsp;&thinsp;2.0,&emsp;&thinsp;&thinsp;0.0)</entry>
</row>
<row>
<entry>//</entry>
<entry>(&thinsp;&thinsp;1.6,&emsp;&thinsp;&thinsp;&minus;0.6)</entry>
</row>
<row>
<entry>//</entry>
<entry>(&thinsp;&thinsp;0.0,&emsp;&thinsp;&thinsp;&minus;1.0)</entry>
</row>
<row>
<entry>//</entry>
<entry>(&minus;1.6,&emsp;&thinsp;&thinsp;&minus;0.6)</entry>
</row>
<row>
<entry>//</entry>
<entry>(&minus;2.0,&emsp;&thinsp;&thinsp;0.0)</entry>
</row>
<row>
<entry>//</entry>
<entry>(&minus;1.6,&emsp;&thinsp;&thinsp;0.6)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>////////////////////////////////////////////////////////////////////////</entry>
</row>
<row>
<entry>// to create the egg-ish shape above,</entry>
</row>
<row>
<entry>// one would simply add a third DeltaSet</entry>
</row>
<row>
<entry>// based on a triangle shape.</entry>
</row>
<row>
<entry>// -----------------end of simple geometry example/////////////</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> As seen from the pseudocode of Table V, a datapoint is defined as a two-dimensional vector and the square, rectangle, and circle shapes are defined as eight points with abscissa and ordinate values. Deltasets are then calculated for the transition from square to rectangle and from square to circle. As seen above, the resulting deltasets (rect_dset and circ_dset) represent differences between abscissa and ordinate values of the respective starting and target images. The deltasets can then be applied to a starting shape (in this example, the starting image, newshape, is set to the square shape of <cross-reference target="DRAWINGS">FIG. 11</cross-reference><highlight><italic>a</italic></highlight>). First the rect_dset deltaset is applied to the square shape to form an intermediate shape, and then the circ_dset deltaset is applied to this intermediate shape to form the destination shape that is shown in <cross-reference target="DRAWINGS">FIG. 11</cross-reference><highlight><italic>e</italic></highlight>. To get to the shape of <cross-reference target="DRAWINGS">FIG. 11</cross-reference><highlight><italic>f</italic></highlight>, a deltaset representing a transformation between the square shape of <cross-reference target="DRAWINGS">FIG. 11</cross-reference><highlight><italic>a </italic></highlight>to the triangle shape of <cross-reference target="DRAWINGS">FIG. 11</cross-reference><highlight><italic>d </italic></highlight>is created and applied to the ellipse shape shown in <cross-reference target="DRAWINGS">FIG. 11</cross-reference><highlight><italic>e. </italic></highlight></paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> The deltasets example, above, can be easily extended to a three-dimensional representation. The example can also be expanded to more intricate and complex applications such as in three-dimensional space and facial animation. As the application of deltasets becomes more complex in facial animation, several additional features can be added. For example, certain motions of the face are limited to certain defined areas, such as blinking of the eyes. Accordingly, a deltaset for an entire face would be mostly 0&apos;s (indicating no change) except for the eyes and eyelids, thus isolating these areas for change. To improve efficiency, the deltaset datatype can be changed so that only non-zero values are stored. Thus during the execution of the Deltaset_apply routine, only the points that change are acted upon, rather than every point in the graphical representation. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> An embodiment of facial animation is described below with reference to the pseudocode example of Table VI.  
<table-cwu id="TABLE-US-00006">
<number>6</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center">TABLE VI</entry>
</row>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>Facial Moving-Morphing example -------------------------------</entry>
</row>
<row>
<entry>// The following pseudocode example shows how deltaset</entry>
</row>
<row>
<entry>// morphing is used to fully animate and morph a face.</entry>
</row>
<row>
<entry>// Note that this achieves a &ldquo;moving morph&rdquo;, wherein the</entry>
</row>
<row>
<entry>// overall structure of the face can smoothly change without</entry>
</row>
<row>
<entry>// interrupting the process of other facial animation such</entry>
</row>
<row>
<entry>// as blinking, emoting, and speaking.</entry>
</row>
<row>
<entry>////////////////////////////////////////////////////////////////////////</entry>
</row>
<row>
<entry>// Setup</entry>
</row>
<row>
<entry>// Define the basic dataPoint that makes shapes &amp; deltasets.</entry>
</row>
<row>
<entry>typedef 3DVector dataPoint_Type;</entry>
</row>
<row>
<entry>// Declaration of basic shapes &amp; deltasets.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="63PT" align="left"/>
<colspec colname="2" colwidth="154PT" align="left"/>
<tbody valign="top">
<row>
<entry>shape_Type</entry>
<entry>neutralFace,</entry>
</row>
<row>
<entry></entry>
<entry>overallMorphface,</entry>
</row>
<row>
<entry></entry>
<entry>blinkFace,</entry>
</row>
<row>
<entry></entry>
<entry>emoteFaces&emsp;&lsqb;&rsqb;,</entry>
</row>
<row>
<entry></entry>
<entry>speakFaces&emsp;&lsqb;&rsqb;,</entry>
</row>
<row>
<entry></entry>
<entry>newShapeFace;</entry>
</row>
<row>
<entry>deltaSet_Type</entry>
<entry>overall_dset,</entry>
</row>
<row>
<entry></entry>
<entry>blink_dset,</entry>
</row>
<row>
<entry></entry>
<entry>emote_dsets &lsqb;&rsqb;,</entry>
</row>
<row>
<entry></entry>
<entry>speak_dsets &lsqb;&rsqb;;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>// neutralFace is the geometry of the basic 3D face,</entry>
</row>
<row>
<entry>//&emsp;&emsp;no expression, looking straight ahead.</entry>
</row>
<row>
<entry>// overallMorphFace is a radically different face,</entry>
</row>
<row>
<entry>//&emsp;&emsp;say a cat.</entry>
</row>
<row>
<entry>// blinkFace is the same as neutralFace but with eyes closed.</entry>
</row>
<row>
<entry>// emoteFaces is an array of faces with different emotions or</entry>
</row>
<row>
<entry>//&emsp;&emsp;expressions. ie Happy, sad, angry, trustful etc.</entry>
</row>
<row>
<entry>// speakFaces is an array of faces in different phoneme (or</entry>
</row>
<row>
<entry>//&emsp;&emsp;&ldquo;viseme&rdquo;) positions. ie &ldquo;OO&rdquo;, &ldquo;AE&rdquo;, &ldquo;L&rdquo;, &ldquo;M&rdquo; etc.</entry>
</row>
<row>
<entry>// newShapeFace is a shape which is the destination of the</entry>
</row>
<row>
<entry>//&emsp;&emsp;morphing.</entry>
</row>
<row>
<entry>// Declarations of amount of morphs.</entry>
</row>
<row>
<entry>// These typically range from 0.0 to 1.0, but can be outside</entry>
</row>
<row>
<entry>// of this range.</entry>
</row>
<row>
<entry>float overallMorphAmount, blinkAmount,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>emoteAmounts &lsqb;&rsqb;, speakAmounts &lsqb;&rsqb;;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>// Other declarations</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="63PT" align="left"/>
<colspec colname="2" colwidth="154PT" align="left"/>
<tbody valign="top">
<row>
<entry>float time;</entry>
<entry>// a pseudo time variable.</entry>
</row>
<row>
<entry>int&emsp;&ensp;numEmotes;</entry>
<entry>// the number of emotion faces.</entry>
</row>
<row>
<entry>int&emsp;&ensp;numSpeaks;</entry>
<entry>// the number of viseme faces.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>////////////////////////////////////////////////////////////////////////</entry>
</row>
<row>
<entry>// initialize the deltasets</entry>
</row>
<row>
<entry>deltaSet_Calc (&amp;overall_dset, &amp;neutralFace, &amp;blinkFace);</entry>
</row>
<row>
<entry>deltaSet_Calc (&amp;blink_dset, &amp;neutralFace, &amp;blinkFace);</entry>
</row>
<row>
<entry>for (i &equals; 0; i &lt; numEmotes; i&plus;&plus;)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>deltaSet_Calc( &amp;emote_dsets &lsqb;i&rsqb;,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="63PT" align="left"/>
<colspec colname="1" colwidth="154PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&amp;neutralFace,</entry>
</row>
<row>
<entry></entry>
<entry>&amp;emoteFaces &lsqb;i&rsqb;);</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>for (i &equals; 0; i &lt; numSpeaks; i&plus;&plus;)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>deltaSet_Calc( &amp;speak_dsets &lsqb;i&rsqb;,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="63PT" align="left"/>
<colspec colname="1" colwidth="154PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&amp;neutralFace,</entry>
</row>
<row>
<entry></entry>
<entry>&amp;speakFaces &lsqb;i&rsqb;);</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>////////////////////////////////////////////////////////////////////////</entry>
</row>
<row>
<entry>// Main animation loop</entry>
</row>
<row>
<entry>while (KeepRunning)</entry>
</row>
<row>
<entry>&lcub;</entry>
</row>
<row>
<entry>time &plus;&equals; 0.1;</entry>
</row>
<row>
<entry>// Calculate the amount each morph is to be applied.</entry>
</row>
<row>
<entry>// For emoteAmounts and speakAmounts, this is an array</entry>
</row>
<row>
<entry>// of values most of which are zero.</entry>
</row>
<row>
<entry>// (Note that deltaSet_Apply() returns immediately if</entry>
</row>
<row>
<entry>// amount &equals;&equals; 0.0)</entry>
</row>
<row>
<entry>CalBlinkAmount (&amp;blinkAmount);</entry>
</row>
<row>
<entry>CalEmoteAmounts (emoteAmounts);</entry>
</row>
<row>
<entry>CalcSpeakAmounts (speakAmount);</entry>
</row>
<row>
<entry>overallMorphAmount &equals; sin(time) * 0.5 &plus; 0.5;</entry>
</row>
<row>
<entry>// Reset the working copy of the face.</entry>
</row>
<row>
<entry>newShapeFace &equals; Copy of neutralFace;</entry>
</row>
<row>
<entry>// Apply the data sets controlling facial animation.</entry>
</row>
<row>
<entry>deltaSet_Apply(blink_dset, &amp;newShapeFace, blinkAmount);</entry>
</row>
<row>
<entry>for (i &equals; 0; i &lt; numEmotes; i&plus;&plus;)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>deltaSet_Apply(&amp;emote_dsets&lsqb;i&rsqb;,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="63PT" align="left"/>
<colspec colname="1" colwidth="154PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&amp;newShapeFace,</entry>
</row>
<row>
<entry></entry>
<entry>emoteAmounts &lsqb;i&rsqb;);</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>for (i &equals; 0 i &lt; numSpeaks; i&plus;&plus;)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>deltaSet_Apply(&amp;speak_dsets &lsqb;i&rsqb;,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="63PT" align="left"/>
<colspec colname="1" colwidth="154PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&amp;newShapeFace,</entry>
</row>
<row>
<entry></entry>
<entry>speakAmounts &lsqb;i&rsqb;);</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>// Apply the overall shape morph</entry>
</row>
<row>
<entry>deltaSet_Apply(&amp;overall_dset,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="63PT" align="left"/>
<colspec colname="1" colwidth="154PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&amp;newShapeFace,</entry>
</row>
<row>
<entry></entry>
<entry>overallMorphAmount);</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>&rcub;</entry>
</row>
<row>
<entry>// End of animation loop</entry>
</row>
<row>
<entry>////////////////////////////////////////////////////////////////////////</entry>
</row>
<row>
<entry>// ---------------end of facial moving morph example-----------</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> As seen from the above, the animated face image comprises three-dimensional datapoints. &ldquo;NeutralFace&rdquo; is a starting image that will be changed based on one or more deltasets. The neutralface image is shown in <cross-reference target="DRAWINGS">FIG. 12</cross-reference><highlight><italic>a </italic></highlight>with eyes looking straight ahead and no expression. &ldquo;OverallMorphFace&rdquo; is a different face from NeutralFace. In this example, OverallMorphFace is in the image of a cat shown in <cross-reference target="DRAWINGS">FIG. 12</cross-reference><highlight><italic>b</italic></highlight>. A face showing a completed facial movement is &ldquo;blinkFace&rdquo; which shows the same face as NeutralFace but with the eyes closed (see <cross-reference target="DRAWINGS">FIG. 12</cross-reference><highlight><italic>c</italic></highlight>). &ldquo;EmoteFaces&rdquo; is an array of the neutralFace augmented to show one or more emotions. For example, <cross-reference target="DRAWINGS">FIG. 12</cross-reference><highlight><italic>d </italic></highlight>shows the neutralFace emoting happiness, <cross-reference target="DRAWINGS">FIG. 12</cross-reference><highlight><italic>e </italic></highlight>shows neutralFace emoting anger, etc. &ldquo;SpeakFaces&rdquo; is an array of faces showing expressions of different phonemes, a phoneme, or viseme, is a speech syllable used to form spoken words (e.g., the &ldquo;oo&rdquo;, &ldquo;ae&rdquo;, and &ldquo;m&rdquo; sounds). As an example, <cross-reference target="DRAWINGS">FIG. 12</cross-reference><highlight><italic>f </italic></highlight>shows neutralFace expressing the phoneme &ldquo;oo.&rdquo;</paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> The amount of transformation or morphing can be controlled by multiplication or multiplier values, overallMorphAmount, blinkAmount, emote Amounts&lsqb; &rsqb;, and speakAmounts&lsqb; &rsqb;. As an example, if blinkamount is set to 1.0 then when applying a deltaset for blinking to neutralFace of <cross-reference target="DRAWINGS">FIG. 12</cross-reference><highlight><italic>a </italic></highlight>will achieve the face of <cross-reference target="DRAWINGS">FIG. 12</cross-reference><highlight><italic>c </italic></highlight>(i.e., 100% of the blink is applied). Numbers less than or greater than 1.0 can be selected for these variables. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> Deltasets are then created for transforming the neutralFace image. As can be seen from the pseudocode of Table VI, deltaset overall_dset is created for the changes between neutralFace (<cross-reference target="DRAWINGS">FIG. 12</cross-reference><highlight><italic>a</italic></highlight>) and overallMorphFace (<cross-reference target="DRAWINGS">FIG. 12</cross-reference><highlight><italic>b</italic></highlight>); deltaset blink_dset is created for the changes between neutralFace (<cross-reference target="DRAWINGS">FIG. 12</cross-reference><highlight><italic>a</italic></highlight>) and blinkFace (<cross-reference target="DRAWINGS">FIG. 12</cross-reference><highlight><italic>c</italic></highlight>); deltasets emote_dsets&lsqb; &rsqb; are created between neutralFace (<cross-reference target="DRAWINGS">FIG. 12</cross-reference><highlight><italic>a</italic></highlight>) and each emotion expression image (e.g., the &ldquo;happy&rdquo; emoteFace&lsqb; &rsqb; of <cross-reference target="DRAWINGS">FIG. 12</cross-reference><highlight><italic>d </italic></highlight>and the &ldquo;angry&rdquo; emoteFace&lsqb; &rsqb; of <cross-reference target="DRAWINGS">FIG. 12</cross-reference><highlight><italic>e</italic></highlight>; and deltasets speak_dsets&lsqb; &rsqb; are created between neutralFace (<cross-reference target="DRAWINGS">FIG. 12</cross-reference><highlight><italic>a</italic></highlight>) and each phoneme expression image (e.g., the &ldquo;oo&rdquo; speakFace&lsqb; &rsqb; of <cross-reference target="DRAWINGS">FIG. 12</cross-reference><highlight><italic>f</italic></highlight>). </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> In the main animation loop, the amounts for each deltaset transformation are calculated (e.g., the values for overallMorphAmount, blinkamount, emoteAmount&lsqb; &rsqb;s, and speakAmounts&lsqb; &rsqb;). For the emoteAmounts&lsqb; &rsqb; and speakAmounts&lsqb; &rsqb; arrays, these values are mostly zero. The new facial image to be created is stored in newShapeFace and is originally set to the NeutralFace image. Then, the deltasets that were calculated above, are applied to the newShapeFace in amounts set in transformation variables calculated above. In this example, overallMorphAmount is set to 0.5 (i.e., halfway between neutralFace and overallMorphFace; blinkamount is set to 1.0 (i.e., full blink&mdash;eyes closed); emoteAmount&lsqb; &rsqb; for &ldquo;happy&rdquo; is set to 1.0 while all other emoteAmount&lsqb; &rsqb; values are set to 0; and speakamount&lsqb; &rsqb; for the phoneme &ldquo;oo&rdquo; is set to 1.0 while all other speakAmount&lsqb; &rsqb; values are set to 0. The resulting image based on these variables is shown in <cross-reference target="DRAWINGS">FIG. 12</cross-reference><highlight><italic>g. </italic></highlight></paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> As described above, the deltasets that have been created can now be applied to another starting image (i.e., an image other than neutralFace shown in <cross-reference target="DRAWINGS">FIG. 12</cross-reference><highlight><italic>a</italic></highlight>) without recalculation. This is shown in the examples of <cross-reference target="DRAWINGS">FIGS. 14</cross-reference><highlight><italic>a</italic></highlight>-<highlight><italic>d</italic></highlight>. Using the method set forth above, a deltaset can be created between neutralFace and overallMorphFace which signifies the changes between a male human face (shown in <cross-reference target="DRAWINGS">FIG. 12</cross-reference><highlight><italic>a</italic></highlight>) and the face of a cat (shown in <cross-reference target="DRAWINGS">FIG. 12</cross-reference><highlight><italic>b</italic></highlight>). As seen in <cross-reference target="DRAWINGS">FIG. 14</cross-reference><highlight><italic>a</italic></highlight>, a neutral, male human face is shown without application of this deltaset. <cross-reference target="DRAWINGS">FIG. 14</cross-reference><highlight><italic>b </italic></highlight>shows the effects of the application of this deltaset (or fractional value of this deltaset) in that the male human face now looks &ldquo;cat-like.&rdquo; The underlying polygonal model for <cross-reference target="DRAWINGS">FIGS. 14</cross-reference><highlight><italic>a </italic></highlight>and <highlight><bold>14</bold></highlight><highlight><italic>b </italic></highlight>are shown in <cross-reference target="DRAWINGS">FIGS. 10</cross-reference><highlight><italic>a </italic></highlight>and <highlight><bold>10</bold></highlight><highlight><italic>b</italic></highlight>, respectively. As seen in <cross-reference target="DRAWINGS">FIGS. 10</cross-reference><highlight><italic>a </italic></highlight>and <highlight><italic>b</italic></highlight>, vertices of the first image are shown to move to different positions in the destination image. Referring back to <cross-reference target="DRAWINGS">FIGS. 14</cross-reference><highlight><italic>a </italic></highlight>and <highlight><bold>14</bold></highlight><highlight><italic>b</italic></highlight>, one skilled in the art will appreciate that the color of each pixel can also change in accordance with a deltaset storing the difference in color for each pixel in the human and cat images of these figures. The deltaset described above can be applied to a neutral, female human face (see <cross-reference target="DRAWINGS">FIG. 14</cross-reference><highlight><italic>c</italic></highlight>) to form a new destination image (see <cross-reference target="DRAWINGS">FIG. 14</cross-reference><highlight><italic>d</italic></highlight>). </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> Also, the variables (e.g., overallMorphAmount) can be input using graphical sliders shown in <cross-reference target="DRAWINGS">FIGS. 13</cross-reference><highlight><italic>a</italic></highlight>-<highlight><italic>d</italic></highlight>. In this example, several deltasets have been previously determined. a first deltaset represents the difference between a starting image with lips in a first position and a target image with lips in a second, higher position. a second deltaset represents the difference between a starting image with jaw in a first position and a target image with the jaw in a second, jutted-out position. a third deltaset represents the difference between a starting image with relatively smooth skin and a target image with old (i.e., heavily textured skin). Referring to <cross-reference target="DRAWINGS">FIGS. 13</cross-reference><highlight><italic>a</italic></highlight>-<highlight><italic>d</italic></highlight>, the amount each of these first, second, and third deltasets is applied to the neutral image of <cross-reference target="DRAWINGS">FIG. 13</cross-reference><highlight><italic>a </italic></highlight>is determined by the placement of one or more sliders <highlight><bold>1301</bold></highlight>-<highlight><bold>1303</bold></highlight>. In this example, if the slider is in a central position, then the deltaset is not applied at all (i.e., the deltaset multiplied by 0.0 is applied to the image). If the slider is placed to the right, the deltaset multiplied by 1.0 is applied to the image and if it is placed to the left, the deltaset multiplied by &minus;1.0 is applied to the image. Accordingly in <cross-reference target="DRAWINGS">FIG. 10</cross-reference><highlight><italic>a</italic></highlight>, sliders <highlight><bold>101</bold></highlight>-<highlight><bold>03</bold></highlight> are in a central position. In <cross-reference target="DRAWINGS">FIG. 13</cross-reference><highlight><italic>b</italic></highlight>, slider <highlight><bold>1301</bold></highlight> is moved (e.g., with a mouse, not shown) to the right causing the first deltaset (multiplied by 1.0) to be applied to the neutral image of <cross-reference target="DRAWINGS">FIG. 13</cross-reference><highlight><italic>a </italic></highlight>(thus, the lips are moved up some distance). Likewise, in <cross-reference target="DRAWINGS">FIG. 13</cross-reference><highlight><italic>c</italic></highlight>, slider <highlight><bold>1302</bold></highlight> is moved to the left, and the second deltaset described above (multiplied by &minus;1.0) is applied to the image of <cross-reference target="DRAWINGS">FIG. 13</cross-reference><highlight><italic>b </italic></highlight>(thus, the jaw is recessed). Also, in <cross-reference target="DRAWINGS">FIG. 13</cross-reference><highlight><italic>d</italic></highlight>, slider <highlight><bold>1303</bold></highlight> is moved to the right causing the third deltaset (multiplied by 1.0) to be applied to the image of <cross-reference target="DRAWINGS">FIG. 13</cross-reference><highlight><italic>c</italic></highlight>. One skilled in the art will appreciate that the sliders <highlight><bold>1301</bold></highlight>-<highlight><bold>03</bold></highlight> can have intermediate values between &minus;1.0 and 1.0 or can have values beyond this range. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> As seen from the above, once one or more deltasets have been created, the multiplier values that are controlled by sliders <highlight><bold>1301</bold></highlight>-<highlight><bold>03</bold></highlight> (for example) of the embodiment of <cross-reference target="DRAWINGS">FIG. 13</cross-reference> would be the only input necessary to modify a starting image. This feature is advantageous in the area of communications. Referring to <cross-reference target="DRAWINGS">FIG. 15, a</cross-reference> communication system is shown. In this system, a first component (such as server <highlight><bold>1510</bold></highlight>) is coupled via a transmission medium <highlight><bold>1509</bold></highlight> to a second component (such as client <highlight><bold>1511</bold></highlight> coupled to a display <highlight><bold>1512</bold></highlight>). In this example, the transmission medium <highlight><bold>1509</bold></highlight> is the so-called Internet system that has a varying, but limited bandwidth. The server <highlight><bold>1510</bold></highlight> and client <highlight><bold>1511</bold></highlight> are computer systems similar to system <highlight><bold>801</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 8</cross-reference>. a first image (e.g., a person&apos;s face) is transmitted over the transmission medium <highlight><bold>1509</bold></highlight> from the server <highlight><bold>1510</bold></highlight> to the client as well as any desired deltasets (as described above). Some code may also be sent, operating as described herein. The image and deltasets can be stored at the client <highlight><bold>1511</bold></highlight> and the image can be displayed at display <highlight><bold>1512</bold></highlight>. For the server <highlight><bold>1510</bold></highlight> to change the image at the client <highlight><bold>1511</bold></highlight>, an entire, new image need not be sent. Rather, the multiplication values for the deltasets (e.g., the values controlled by sliders <highlight><bold>1301</bold></highlight>-<highlight><bold>03</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 13</cross-reference>) can be sent over the transmission medium <highlight><bold>1509</bold></highlight> to cause the desired change to the image at display <highlight><bold>1512</bold></highlight>. Thus, a great savings in bandwidth is achieved allowing greater animation and control of the image. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> In another example, the system of <cross-reference target="DRAWINGS">FIG. 15</cross-reference> can be used as a video phone system where the original image that is sent is that of the speaking party at the server <highlight><bold>1510</bold></highlight> over the transmission medium <highlight><bold>1509</bold></highlight> (e.g., plain old telephone system (POTS)). Speech by the user at the server <highlight><bold>1510</bold></highlight> can be converted into phonemes that are then converted into multiplication values that are transmitted over the transmission medium <highlight><bold>1509</bold></highlight> with the voice signal to facilitate the &ldquo;mouthing&rdquo; of words at the client <highlight><bold>1511</bold></highlight>. </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> As described above, a graphical image of a human, for example, can be made to express emotions by applying a deltaset to a neutral, starting image of the human. If the expression of emotions is autonomous, the computer graphical image of the human will seem more life-like. It could be concluded that humans fit into two categories or extremes: one that represents a person who is emotionally unpredictable (i.e., expresses emotions randomly), such as an infant, perhaps; and one that has preset reactions to every stimulation. According to an embodiment of the present invention, an &ldquo;emotional state space&rdquo; is created that includes a number of axes, each corresponding to one emotion. For example, assuming that there are only two emotions, &ldquo;happy&rdquo; and &ldquo;alert,&rdquo; then at point (1.0, 0.0), the person is happy and not sleepy or excited; at point (0.0, 1.0), the person neither happy nor sad, but is excited, at point (&minus;1.0, &minus;1.0), the person is sad and sleepy. Though there are many more emotions that can be expressed, a person typically will be expressing no more than one or two emotions at a time. Referring back to <cross-reference target="DRAWINGS">FIG. 9</cross-reference>, element <highlight><bold>937</bold></highlight> provides input for changing the neutral image based on the expression of emotions. An example of pseudocode for the expression of emotions is shown in Table VIII. In this pseudocode, two emotions are selected: one that is to be expressed and one that is currently fading from expression.  
<table-cwu id="TABLE-US-00007">
<number>7</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center">TABLE VIII</entry>
</row>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>PSEUDOCODE example -----------------------------</entry>
</row>
<row>
<entry>// This is pseudocode based in part on &ldquo;C&rdquo;.</entry>
</row>
<row>
<entry>// First is pseudocode for the random walk</entry>
</row>
<row>
<entry>// style of autonomous emoting, second</entry>
</row>
<row>
<entry>// is the reaction style.</entry>
</row>
<row>
<entry>// These routines determine the amount that each emotion</entry>
</row>
<row>
<entry>// in the emotion library is currently expressed</entry>
</row>
<row>
<entry>// in the artificial human. They do not</entry>
</row>
<row>
<entry>// actually express the emotions. One method</entry>
</row>
<row>
<entry>// of expressing the emotions is detailed above.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>///////////////////////////////</entry>
</row>
<row>
<entry></entry>
<entry>// These variables are the basic</entry>
</row>
<row>
<entry></entry>
<entry>// output.</entry>
</row>
<row>
<entry></entry>
<entry>// emoteAmounts is an array of floats that represents</entry>
</row>
<row>
<entry></entry>
<entry>//&emsp;&emsp;the degree to which each emotion in the emotion</entry>
</row>
<row>
<entry></entry>
<entry>//&emsp;&emsp;library is currently playing on the face.</entry>
</row>
<row>
<entry></entry>
<entry>// emoteNum is the number of emotions in the library.</entry>
</row>
<row>
<entry></entry>
<entry>float emoteAmounts &lsqb;&rsqb;;</entry>
</row>
<row>
<entry></entry>
<entry>int emoteNum;</entry>
</row>
<row>
<entry></entry>
<entry>//////////////////////////////////</entry>
</row>
<row>
<entry></entry>
<entry>// These variables are the two</entry>
</row>
<row>
<entry></entry>
<entry>// emotions present at one moment.</entry>
</row>
<row>
<entry></entry>
<entry>// nextEmote &amp; nextAmount are the</entry>
</row>
<row>
<entry></entry>
<entry>// current destination emotion &amp;</entry>
</row>
<row>
<entry></entry>
<entry>// how much of it.</entry>
</row>
<row>
<entry></entry>
<entry>// lastEmote is the emotion currently</entry>
</row>
<row>
<entry></entry>
<entry>// fading away.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="133PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>int</entry>
<entry>nextEmote</entry>
<entry>&equals; 0;</entry>
</row>
<row>
<entry></entry>
<entry>float</entry>
<entry>nextAmount</entry>
<entry>&equals; 0.0;</entry>
</row>
<row>
<entry></entry>
<entry>int</entry>
<entry>lastEmote</entry>
<entry>&equals; 0;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>///////////////////////////////////////</entry>
</row>
<row>
<entry></entry>
<entry>// This variable is the number</entry>
</row>
<row>
<entry></entry>
<entry>// of seconds it will take the</entry>
</row>
<row>
<entry></entry>
<entry>// lastEmote to fade completely.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="133PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>float</entry>
<entry>decaySecs</entry>
<entry>&equals; 3.0;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>///////////////////////////////////////</entry>
</row>
<row>
<entry></entry>
<entry>// This variable is the number</entry>
</row>
<row>
<entry></entry>
<entry>// of seconds it will take to</entry>
</row>
<row>
<entry></entry>
<entry>// go from the current emotion amount</entry>
</row>
<row>
<entry></entry>
<entry>// to the next amount.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="133PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>float</entry>
<entry>changeSecs</entry>
<entry>&equals; 0.5;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>///////////////////////////////////////</entry>
</row>
<row>
<entry></entry>
<entry>// Routine to use a random walk to</entry>
</row>
<row>
<entry></entry>
<entry>// navigate an emotional state-space.</entry>
</row>
<row>
<entry></entry>
<entry>// This implementation uses only two</entry>
</row>
<row>
<entry></entry>
<entry>// emotions at one time, and calls them</entry>
</row>
<row>
<entry></entry>
<entry>// nextEmotion and lastEmotion. The</entry>
</row>
<row>
<entry></entry>
<entry>// dynamic model is basically that of a</entry>
</row>
<row>
<entry></entry>
<entry>// human baby, emoting at random.</entry>
</row>
<row>
<entry></entry>
<entry>// The routine basically chooses an emotion</entry>
</row>
<row>
<entry></entry>
<entry>// To go to, then increases its value while</entry>
</row>
<row>
<entry></entry>
<entry>// decreasing the value of the previous one.</entry>
</row>
<row>
<entry></entry>
<entry>// The input variable dt is the amount of</entry>
</row>
<row>
<entry></entry>
<entry>// time elapsed since the last call.</entry>
</row>
<row>
<entry></entry>
<entry>calcEmoteAmountsRandom (float dt)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub;</entry>
</row>
<row>
<entry></entry>
<entry>//////////////////////////////////</entry>
</row>
<row>
<entry></entry>
<entry>// These variables are probabilities</entry>
</row>
<row>
<entry></entry>
<entry>// of an event per second.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="105PT" align="left"/>
<colspec colname="2" colwidth="84PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>float probabilityOfNewEmote</entry>
<entry>&equals; 0.01;</entry>
</row>
<row>
<entry></entry>
<entry>float probabilityOfNewAmount</entry>
<entry>&equals; 0.2;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>// Decay old emotions, go towards new.</entry>
</row>
<row>
<entry></entry>
<entry>DoDecayAndRamp();</entry>
</row>
<row>
<entry></entry>
<entry>//////////////////////////////////</entry>
</row>
<row>
<entry></entry>
<entry>// now decide if we go to a new emotion.</entry>
</row>
<row>
<entry></entry>
<entry>// decide if we want to go to a new value</entry>
</row>
<row>
<entry></entry>
<entry>// of the current emotion without changing</entry>
</row>
<row>
<entry></entry>
<entry>// which emotion it is.</entry>
</row>
<row>
<entry></entry>
<entry>if (unitRand() *dt &lt;&equals; probabilityOfNewAmount)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub;</entry>
</row>
<row>
<entry></entry>
<entry>nextAmount &equals; select a new random amount of</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>emotion;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>// decide if we want to go to a new emotion</entry>
</row>
<row>
<entry></entry>
<entry>if (unitRand() *dt &lt;&equals; probabilityOfNewEmote)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub;</entry>
</row>
<row>
<entry></entry>
<entry>nextEmote &equals; a random integer &gt;&equals; zero and &lt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>emoteNum;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>nextAmount &equals; select a new random amount of</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>emotion;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>// End of routine.</entry>
</row>
<row>
<entry></entry>
<entry>//////////////////////////////</entry>
</row>
<row>
<entry></entry>
<entry>/////////////////////////////////////////</entry>
</row>
<row>
<entry></entry>
<entry>// Routine to calculate the amount</entry>
</row>
<row>
<entry></entry>
<entry>// of each emotion based on reactions</entry>
</row>
<row>
<entry></entry>
<entry>// to objects in the scene.</entry>
</row>
<row>
<entry></entry>
<entry>// This routine relies on objects with data-</entry>
</row>
<row>
<entry></entry>
<entry>// structures that contain an emotion,</entry>
</row>
<row>
<entry></entry>
<entry>// a degree of reactivity, and position.</entry>
</row>
<row>
<entry></entry>
<entry>CalcEmoteAmountsReact (float dt)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub;</entry>
</row>
<row>
<entry></entry>
<entry>// Decay old emotions, go towards new.</entry>
</row>
<row>
<entry></entry>
<entry>DoDecayAndRamp();</entry>
</row>
<row>
<entry></entry>
<entry>// Determine object of most interest.</entry>
</row>
<row>
<entry></entry>
<entry>for (i &equals; 0; i&lt; numberOfObjects; i&plus;&plus;)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub;</entry>
</row>
<row>
<entry></entry>
<entry>objectReactionLevel &lsqb;i&rsqb; &equals; metric which</entry>
</row>
<row>
<entry></entry>
<entry>incorporates object&apos;s visibility, speed, speed</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="77PT" align="left"/>
<colspec colname="2" colwidth="98PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>towards</entry>
<entry>viewer, inherent</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>emotional</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="70PT" align="left"/>
<colspec colname="1" colwidth="147PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>reactivity (how exciting it is), and</entry>
</row>
<row>
<entry></entry>
<entry>distance to center of vision;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>mainObject &equals; index of largest value in</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>objectReactionLevel;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>// Set next Emotion &amp; Amount.</entry>
</row>
<row>
<entry></entry>
<entry>nextEmotion &equals; Object &num;mainObject -&gt; reaction;</entry>
</row>
<row>
<entry></entry>
<entry>nextAmount &equals; objectReactionLevel &lsqb;mainObject&rsqb;;</entry>
</row>
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>// End of routine</entry>
</row>
<row>
<entry></entry>
<entry>// Note that mainObject is also used to move the artificial</entry>
</row>
<row>
<entry></entry>
<entry>//&emsp;&emsp;human&apos;s eyes and head towards the object, or to start</entry>
</row>
<row>
<entry></entry>
<entry>//&emsp;&emsp;walking towards the object, and other manifestations</entry>
</row>
<row>
<entry></entry>
<entry>//&emsp;&emsp;of being interested in something.</entry>
</row>
<row>
<entry></entry>
<entry>////////////////////////////////////////////</entry>
</row>
<row>
<entry></entry>
<entry>////////////////////////////////////////////</entry>
</row>
<row>
<entry></entry>
<entry>// Routine to decay the last emotion and</entry>
</row>
<row>
<entry></entry>
<entry>// ramp towards the next value of the</entry>
</row>
<row>
<entry></entry>
<entry>// new emotion.</entry>
</row>
<row>
<entry></entry>
<entry>DoDecayAndRamp()</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub;</entry>
</row>
<row>
<entry></entry>
<entry>// Decrease value of all emotions besides current one.</entry>
</row>
<row>
<entry></entry>
<entry>for (i &equals; 0; i &lt; emoteNum; i&plus;&plus;)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub;</entry>
</row>
<row>
<entry></entry>
<entry>if (i &excl;&equals; nextEmote)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub;</entry>
</row>
<row>
<entry></entry>
<entry>emoteAmounts &lsqb;i&rsqb; &minus;&equals; dt/decaySecs;</entry>
</row>
<row>
<entry></entry>
<entry>if (emoteAmounts &lsqb;i&rsqb; &lt; 0.0)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="70PT" align="left"/>
<colspec colname="1" colwidth="147PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>emoteAmounts &lsqb;i&rsqb; 0.0;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>// Change value of current emotion towards</entry>
</row>
<row>
<entry></entry>
<entry>// next level.</entry>
</row>
<row>
<entry></entry>
<entry>// First, calculate the direction of change.</entry>
</row>
<row>
<entry></entry>
<entry>currAmount &equals; emoteAmounts &lsqb;lastEmote&rsqb;;</entry>
</row>
<row>
<entry></entry>
<entry>diff &equals; nextAmount &minus; currAmount;</entry>
</row>
<row>
<entry></entry>
<entry>if (diff &gt; 0.0)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>direction &equals; 1.0;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>else if (diff &lt; 0.0)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>direction &equals; 1.0;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>else</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>direction &equals; 0.0;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>// Now go in that direction at appropriate speed.</entry>
</row>
<row>
<entry></entry>
<entry>currAmount &plus;&equals; dt * direction * changeSecs;</entry>
</row>
<row>
<entry></entry>
<entry>// stop at ends.</entry>
</row>
<row>
<entry></entry>
<entry>if ((direction &equals;&equals; 1.0 AND currAmount &gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>nextAmount) OR</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>(direction &equals;&equals;&minus; 1.0 AND currAmount &lt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>nextAmount))</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>currAmount &equals; nextAmount;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>emoteAmounts &lsqb;nextAmount&rsqb; &equals; currAmount;</entry>
</row>
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>// end of decaying and ramping routine</entry>
</row>
<row>
<entry></entry>
<entry>//////////////////////////////////////</entry>
</row>
<row>
<entry></entry>
<entry>/////////////////////////////////</entry>
</row>
<row>
<entry></entry>
<entry>// Utility function unitRand.</entry>
</row>
<row>
<entry></entry>
<entry>float unitRand()</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub;</entry>
</row>
<row>
<entry></entry>
<entry>return a random number &gt;&equals; 0.0 and &lt;&equals; 1.0;</entry>
</row>
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> As seen from above, emoteAmounts &lsqb; &rsqb; is an array of values for the current expression of one of &ldquo;emoteNum&rdquo; emotions. For example, for the emotion &ldquo;happy&rdquo;, a value is set (e.g, between &minus;1.0 and 1.0) to indicate the current state of the graphical image (e.g., <cross-reference target="DRAWINGS">FIG. 12D</cross-reference> shows neutralFace emoting &ldquo;happy&rdquo; with a value of 1.0). The nextEmote variable stores the level of the next emotion to be expressed. The lastEmote variable stores the level of the emotion that is currently being expressed, and is also fading away. The number of seconds for this emotion to fade to 0.0 is stored in the variable decaySecs. The number of seconds for the next emotion to be expressed after the current emotion amount goes to 0.0. </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> During the CalcEmoteAmountRandom routine, probability values for going to the next emotion (probabilityOfNewEmote) and of changing to a new amount for the current emotion (probabilityOfNewAmount) are set. Then a random number is generated, and if that number is less than the probability value, a new random amount of emotion is assigned to the variable nextAmount. a second random number is selected, and if that number is less than the probability value, a next emotion is selected from the available ones, and a random amount is assigned to the nextAmount variable. </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> During the routine CalcEmoteAmountsReact, the objects that are around the graphic image of the person are analyzed to determine which object is of most interest (e.g., by assigning weighted values based on the object&apos;s visibility, speed, speed towards the graphical image of the person, the inherent emotional reactivity of the object, and its distance to center of vision for the graphic image of the person). Each object has a data structure that includes a predefined emotion, a degree of reactivity and position. For example, a gun object, would elicit a &ldquo;fear&rdquo; emotion with a high degree of reactivity depending on how close it is (i.e., distance) to the person. Accordingly, based on the object of most interest (and the relationship between the person and the object), a nextEmotion is selected and a nextAmount is selected based on the object and the random numbers referenced above determine whether that next Emotion is to be expressed by the human image. Using the routines of Table VIII, the human image expresses emotions that are more lifelike in that they are somewhat random, yet can occur in response to specific stimuli. </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> Referring back to <cross-reference target="DRAWINGS">FIG. 8</cross-reference>, an input device <highlight><bold>830</bold></highlight> is provided for the input of data for the creation of graphic images to be output to display <highlight><bold>820</bold></highlight>. The input device <highlight><bold>830</bold></highlight> can be a variety of components including a video camera, a magnetic tracker monitor, etc. In one such system, selected points are tracked on a person&apos;s face. These devices output a stream of information that are commensurate with the coordinates of a number of select locations on a person&apos;s face as they move (see element <highlight><bold>939</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 9</cross-reference>). For example, 6 locations around the mouth, one on each eyelid, one on each eyebrow, one on each cheek, can all be tracked and output to the computer system of <cross-reference target="DRAWINGS">FIG. 8</cross-reference>. </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> The method of face tracking according to an embodiment of the present invention, a neutral three-dimensional model of a person is created as described above. a test subject (e.g., a person) is used having a set of markers on his/her face (as described above). For each marker, three three-dimensional model faces are created, one for each 3D axis (e.g., the x, y and z axes). Each of these models is the same as the neutral model except that the specific marker is moved a known distance (e.g. one inch or other unit) along one of the axes. Thus, for each marker, there is a contorted version of the neutral image where the marker is moved one unit only along the x-axis; a second image where the marker is moved along one unit only along the y-axis; and a third image where the marker is moved along one unit only along the z-axis. Deltasets are then created between the neutral image and each of the three contorted versions for each marker. </paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> With the deltasets created, the input stream of marker positions are received from the input device <highlight><bold>830</bold></highlight>. The neutral image is then modified with the appropriate deltaset(s) rather than directly with the input positions. If marker data is only in two dimensions, then only two corresponding distorted models are needed (and only two deltasets are created for that marker). Movement of one marker can influence the movement of other points in the neutral model (to mimic real-life or as desired by the user). Also, the movement of a marker in one axis may distort the model in more than one axis (e.g., movement of the marker at the left eyebrow in a vertical direction may have vertical and horizontal effects on the model). An example of pseudocode for implementing the input of marker positions is shown in Table IX.  
<table-cwu id="TABLE-US-00008">
<number>8</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center">TABLE IX</entry>
</row>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>// This pseudocode is based in part on &ldquo;C&rdquo;.</entry>
</row>
<row>
<entry>// It takes as input:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="14PT" align="left"/>
<colspec colname="2" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry>//</entry>
<entry>* An array of vector data representing the spacial</entry>
</row>
<row>
<entry>//</entry>
<entry>displacement of a set of facial markers.</entry>
</row>
<row>
<entry>//</entry>
<entry>* An array of DeltaSets setup as described above,</entry>
</row>
<row>
<entry>//</entry>
<entry>with numDimensions DeltaSets for each marker.</entry>
</row>
<row>
<entry>//</entry>
<entry>* a 3D model of a &ldquo;neutral face&rdquo;, as described above.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>// It outputs:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="14PT" align="left"/>
<colspec colname="2" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry>//</entry>
<entry>* a 3D model of a face which mimics the motion of the</entry>
</row>
<row>
<entry>//</entry>
<entry>actual face with which the markers are associated.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="168PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>int</entry>
<entry>numMarkers;</entry>
</row>
<row>
<entry></entry>
<entry>int</entry>
<entry>numDimensions;</entry>
</row>
<row>
<entry></entry>
<entry>float</entry>
<entry>markerDisplacements &lsqb;numMarkers&rsqb; &lsqb;numDimensions&rsqb;;</entry>
</row>
<row>
<entry></entry>
<entry>DeltaSet</entry>
<entry>markerDeltaSets &lsqb;numMarkers&rsqb; &lsqb;numDimensions&rsqb;;</entry>
</row>
<row>
<entry></entry>
<entry>Shape</entry>
<entry>neutralFace;</entry>
</row>
<row>
<entry></entry>
<entry>Shape</entry>
<entry>outputFace;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>// numMarkers is the number of discrete locations being</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="14PT" align="left"/>
<colspec colname="2" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>//</entry>
<entry>tracked on the source face. Typically 6-14, but</entry>
</row>
<row>
<entry></entry>
<entry>//</entry>
<entry>under no limitations.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>// numDimensions is the number of dimensions reported by</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="14PT" align="left"/>
<colspec colname="2" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>//</entry>
<entry>the markerDisplacements array.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>// markerDisplacements is an array of vectors with one</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>vector</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>// for each marker on the source face. These values</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>should</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="14PT" align="left"/>
<colspec colname="2" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>//</entry>
<entry>be updated once per frame.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>// marker DeltaSets is a 2D array of DeltaSets of size</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="14PT" align="left"/>
<colspec colname="2" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>//</entry>
<entry>numMarkers x numDimensions.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>// neutralFace is the original, undistorted 3D face model.</entry>
</row>
<row>
<entry></entry>
<entry>// outputFace is a 3D model that will mimic the source face.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>////////////////////////////////////////////////////////////////////////</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="14PT" align="left"/>
<colspec colname="2" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry>//</entry>
<entry>// The main animation loop. Runs once per frame.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>MainAnimationLoop ()</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub;</entry>
</row>
<row>
<entry></entry>
<entry>outputFace &equals; copy of neutralFace;</entry>
</row>
<row>
<entry></entry>
<entry>// Loop over each marker and each reported dimension.</entry>
</row>
<row>
<entry></entry>
<entry>for (m &equals; O; m &lt; numMarkers; m&plus;&plus;)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub;</entry>
</row>
<row>
<entry></entry>
<entry>for (d &equals; O; d &lt; numDimensions; d&plus;&plus;)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub;</entry>
</row>
<row>
<entry></entry>
<entry>deltaSet_Apply (markerDeltaSets &lsqb;m&rsqb; &lsqb;d&rsqb;,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="112PT" align="left"/>
<colspec colname="1" colwidth="105PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&amp; outputFace,</entry>
</row>
<row>
<entry></entry>
<entry>MarkerDisplacements &lsqb;m&rsqb; &lsqb;d&rsqb;);</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>//</entry>
</row>
<row>
<entry></entry>
<entry>// End of main animation loop.</entry>
</row>
<row>
<entry></entry>
<entry>////////////////////////////////////////////////////////////////////////</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> As seen from the above, the neutral face image that is input is modified with the created deltasets to mimic the resultant movements in the face caused by physically moving the attached markers. Without distortion, neutralFace is the original 3D face model and outputFace is a 3D model that mimics the movement of the subject&apos;s face. During the main animation loop, which can run once per frame, each marker is analyzed for its position. The resulting displacement of the marker is then applied to the outputFace (which starts as a copy of neutralFace) through the use of the Deltaset_apply routine discussed above and the deltasets that have been previously created. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method of transforming a graphical image, comprising: 
<claim-text>(a) identifying a first region of a first graphical image; and </claim-text>
<claim-text>(b) modifying said first region of said first graphical image based on a first set of predetermined modification data. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> further comprising after step (a): 
<claim-text>(a1) retrieving said first set of modification data from a database, said database storing a plurality of sets of modification data. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> further comprising: 
<claim-text>(c) identifying a first region of a second graphical image; and </claim-text>
<claim-text>(d) modifying said at least first region of said second graphical image based on said first set of predetermined modification data. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> further comprising: 
<claim-text>(c) further modifying said first region of said first graphical image based on a second set of modification data. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> further comprising: 
<claim-text>(c) identifying a second region of said first graphical image; and </claim-text>
<claim-text>(d) modifying said second region of said first graphical image as modified in step (b) based on a second set of modification data. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. A method of transforming a starting graphical image to a destination graphical image, comprising: 
<claim-text>(a) generating a first image; </claim-text>
<claim-text>(b) generating a second image; </claim-text>
<claim-text>(c) determining a set of difference values between said first image and said second image; and </claim-text>
<claim-text>(d) storing said difference values in a memory device. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. A method of transforming a starting graphical image to a destination graphical image, comprising: 
<claim-text>(a) generating a first image comprising a first number of vertices, each vertex having a spatial location; </claim-text>
<claim-text>(b) generating a second image comprising a number of vertices equal to said first number of vertices; </claim-text>
<claim-text>(c) determining a difference between a first one of said vertices of said first image with a corresponding vertex of said second image; and </claim-text>
<claim-text>(d) storing said difference in a memory device. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. A method of modifying a starting graphical image comprising: 
<claim-text>(a) identifying at least a first region of said starting graphical image; </claim-text>
<claim-text>(b) modifying said first region of said starting graphical image based on first and second sets of modification data. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference>, further comprising before step (b): 
<claim-text>(a1) adding together said first and second sets of modification data. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. A communication system, comprising: 
<claim-text>a client including a computer system and a display; </claim-text>
<claim-text>a server including at least a computer system, said server capable of transmitting a first image and at least a first set of modification data to said client; and </claim-text>
<claim-text>said server is capable of modifying said first image by transmitting a multiplier value to said client, such that said first image is modified based on said first set of modification data multiplied by said multiplier value. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. A method of modifying a starting graphical image comprising: 
<claim-text>(a) generating a starting image having a plurality of characteristics; </claim-text>
<claim-text>(b) storing in a library a plurality of sets of modification data; </claim-text>
<claim-text>(c) retrieving a first set of modification data from said library; and </claim-text>
<claim-text>(d) modifying said starting image based on said first set of modification data, such that a first characteristic of said starting image is changed. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference> further comprising after step (c): 
<claim-text>(c1) multiplying said first set of modification data by a multiplier value; </claim-text>
<claim-text>and further wherein in step (d), said starting image is modified based on said first set of modification data multiplied by said multiplier value. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference> wherein said multiplier value is input by a relative position of a graphical slider. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, further comprising repeating steps (c) and (d) for each change to one of said characteristics of said starting image. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, further comprising repeating steps (c), (c1), and (d) for each change to one of said characteristics of said starting image. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference> wherein said multiplier value is input by a relative position of a graphical slider. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. A method of modifying a starting graphical image comprising: 
<claim-text>(a) generating a first starting image having a plurality of characteristics; </claim-text>
<claim-text>(b) storing in a library a plurality of sets of modification data; </claim-text>
<claim-text>(c) retrieving first and second sets of modification data from said library; and </claim-text>
<claim-text>(d) modifying said starting image based on said first and second sets of modification data, such that first and second characteristics of said starting image are changed, respectively. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference> further comprising after step (c): 
<claim-text>(c1) multiplying said first set of modification data by a first multiplier value; and </claim-text>
<claim-text>(c2) multiplying said second set of modification data by a second multiplier value; and further wherein in step (d), said starting image is modified based on said first and second sets of modification data multiplied by said first and second multiplier values, respectively. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 18</dependent-claim-reference> wherein said first and second multiplier values are input by relative positions of first and second graphical sliders, respectively. </claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 18</dependent-claim-reference> further comprising repeating steps (c), (c1), (c2), and (d) for each change to said first and second characteristics of said starting image. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference>, further comprising: 
<claim-text>(e) generating a second starting image having a plurality of characteristics; </claim-text>
<claim-text>(f) retrieving said first and second sets of modification data from said library; and </claim-text>
<claim-text>(g) modifying said second starting image based on said first and second sets of modification data, such that first and second characteristics of said second starting image are changed, respectively. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference>, further comprising after step (f): 
<claim-text>(f1) multiplying said first set of modification data by a first multiplier value; and </claim-text>
<claim-text>(f2) multiplying said second set of modification data by a second multiplier value. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. A method of modifying a graphical image comprising: 
<claim-text>(a) generating a starting graphical image of a character, said character capable of expressing a plurality of emotions; </claim-text>
<claim-text>(b) retrieving a first set of modification data from a library, each set of modification data stored in said library being related to an expression of an emotion; </claim-text>
<claim-text>(c) multiplying said first set of modification data by a first multiplication value; and </claim-text>
<claim-text>(d) modifying said starting graphical image based on said first set of modification data multiplied by said multiplier value. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 23</dependent-claim-reference>, further comprising: 
<claim-text>(e) generating a first random number; </claim-text>
<claim-text>(f) comparing said first random number with a first probability value; </claim-text>
<claim-text>(g) selecting a new amount for said first multiplication value based on said comparison in step (f); and </claim-text>
<claim-text>(h) repeating steps (c) and (d). </claim-text>
</claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. The method <dependent-claim-reference depends_on="CLM-00022">claim 24</dependent-claim-reference>, further comprising: 
<claim-text>(e) generating a second random number; </claim-text>
<claim-text>(f) comparing said second random number with a second probability value; </claim-text>
<claim-text>(g) selecting a second set of modification data based on said comparison in step (f); and </claim-text>
<claim-text>(h) multiplying said second set of modification data by a second multiplication value; and </claim-text>
<claim-text>(i) modifying said starting graphical image based on a said second set of modification data multiplied by said second multiplication value. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. The method <dependent-claim-reference depends_on="CLM-00022">claim 24</dependent-claim-reference>, further comprising: 
<claim-text>(i) generating a second random number; </claim-text>
<claim-text>(j) comparing said second random number with a second probability value; </claim-text>
<claim-text>(k) selecting a second set of modification data based on said comparison in step (j); </claim-text>
<claim-text>(l) multiplying said second set of modification data by a second multiplication value; and </claim-text>
<claim-text>(m) modifying said starting graphical image based on a said second set of modification data multiplied by said second multiplication value. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. A method of modifying a graphical image comprising: 
<claim-text>(a) generating a starting graphical image of a character, said character capable of expressing a plurality of emotions; </claim-text>
<claim-text>(b) generating at least a first graphical object located proximately to said starting graphical image, said graphical object including a data structure defining a first emotion to be expressed by said starting graphical image; </claim-text>
<claim-text>(c) determining a relationship between said starting graphical image and said graphical object; </claim-text>
<claim-text>(d) retrieving a first set of modification data from a library, said modification data being related to an expression of a said first emotion; </claim-text>
<claim-text>(e) generating a multiplication value based on said relationship between said graphical object and said starting graphical image; </claim-text>
<claim-text>(f) multiplying said first set of modification data by said multiplication value; and </claim-text>
<claim-text>(g) modifying said starting graphical image based on said first set of modification data. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 27</dependent-claim-reference> wherein said relationship is a distance between said graphical object and said starting graphical image.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>1</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030001834A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030001834A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030001834A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030001834A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030001834A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030001834A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030001834A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030001834A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030001834A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00009">
<image id="EMI-D00009" file="US20030001834A1-20030102-D00009.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00010">
<image id="EMI-D00010" file="US20030001834A1-20030102-D00010.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00011">
<image id="EMI-D00011" file="US20030001834A1-20030102-D00011.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00012">
<image id="EMI-D00012" file="US20030001834A1-20030102-D00012.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00013">
<image id="EMI-D00013" file="US20030001834A1-20030102-D00013.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00014">
<image id="EMI-D00014" file="US20030001834A1-20030102-D00014.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00015">
<image id="EMI-D00015" file="US20030001834A1-20030102-D00015.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
