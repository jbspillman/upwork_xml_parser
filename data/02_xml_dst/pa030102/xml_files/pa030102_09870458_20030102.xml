<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005269A1-20030102-D00000.TIF SYSTEM "US20030005269A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005269A1-20030102-D00001.TIF SYSTEM "US20030005269A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005269A1-20030102-D00002.TIF SYSTEM "US20030005269A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005269A1-20030102-D00003.TIF SYSTEM "US20030005269A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005269A1-20030102-D00004.TIF SYSTEM "US20030005269A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005269A1-20030102-D00005.TIF SYSTEM "US20030005269A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030005269A1-20030102-D00006.TIF SYSTEM "US20030005269A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030005269A1-20030102-D00007.TIF SYSTEM "US20030005269A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030005269A1-20030102-D00008.TIF SYSTEM "US20030005269A1-20030102-D00008.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005269</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09870458</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010601</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F009/00</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>712</class>
<subclass>223000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Multi-precision barrel shifting</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Joshua</given-name>
<middle-name>M.</middle-name>
<family-name>Conner</family-name>
</name>
<residence>
<residence-us>
<city>Apache Junction</city>
<state>AZ</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>John</given-name>
<family-name>Elliot</family-name>
</name>
<residence>
<residence-us>
<city>Chandler</city>
<state>AZ</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Michael</given-name>
<middle-name>I.</middle-name>
<family-name>Catherwood</family-name>
</name>
<residence>
<residence-us>
<city>Pepperell</city>
<state>MA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Brian</given-name>
<middle-name>Neil</middle-name>
<family-name>Fall</family-name>
</name>
<residence>
<residence-us>
<city>Chandler</city>
<state>AZ</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Brian</given-name>
<family-name>Boles</family-name>
</name>
<residence>
<residence-us>
<city>Mesa</city>
<state>AZ</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>SWIDLER BERLIN SHEREFF FRIEDMAN, LLP</name-1>
<name-2></name-2>
<address>
<address-1>3000 K STREET, NW</address-1>
<address-2>BOX IP</address-2>
<city>WASHINGTON</city>
<state>DC</state>
<postalcode>20007</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A processor configuration for processing multi-precision shift instructions is provided. The multi-precision shift instructions are executed following a previous shift instruction of the same increment, such as a logical or arithmetic left or right shift operation. The first shift instruction shifts a first memory word by the shift increment and stores this shifted value into memory. The second, and any subsequent, multi-precision shift instruction shifts the next memory word by the shift increment and concatenates the bits shifted out of the previously shifted memory word into bit positions of the memory word presently being shifted. This concatenated value is then stored back to memory and forms another part of the multi-precision shifted value. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">FIELD OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> The present invention relates to systems and methods for instruction processing and, more particularly, to systems and methods for providing multi-precision barrel shifting instructions and processing, pursuant to which a value that may comprise multiple words stored in memory may be shifted in a barrel shifter and stored back into multiple memory words. </paragraph>
</section>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> Processors, including microprocessors, digital signal processors and microcontrollers, operate by running software programs that are embodied in one or more series of instructions stored in a memory. The processors run the software by fetching the instructions from the series of instructions, decoding the instructions and executing them. In addition to program instructions, data is also stored in memory that is accessible by the processor. Generally, the program instructions process data by accessing data in memory, modifying the data and storing the modified data into memory. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> One type of instruction that is employed in processors is the shift instruction. Shift instructions conventionally include arithmetic and logical left and right shift instructions and bit rotate instructions. These instructions fetch data from memory, perform the shift on the fetched data and then generally write the result back to memory. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> Conventional shift instructions and shift instruction processing work well when data to be shifted is word length data. In this scenario, word length data is fetched from memory, fed into a shifter or barrel shifter on the processor, shifted the requisite amount and then stored back into a memory location. Any bits that are &ldquo;shifted out&rdquo; are either lost or may be retrieved using subsequent instructions. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> Data stored in memory is not always word length, however, and exceeds the word length of the processor when stored in memory with precision that is an integer multiple of the word length. Such data may be, for example, double precision (32 bit data on a 16 bit processor), triple precision (48 bit data on a 16 bit processor) or higher depending on the application. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> When data to be shifted exceeds the word length of the processor, neither conventional shift instructions nor conventional processor hardware are able to handle the shift operation using a single shift instruction per word. This is because multi-precision shifting requires shift and concatenation operations that span successive instruction cycles and memory locations. Conventional processors do not have hardware or instructions to perform these operations directly and in successive processor cycles. Accordingly, if multi-precision shifting operations are to be performed on conventional processors, two, three or more instructions, including shift and non-shift operations such as logical OR&apos;s may be required per multi-precision word. These instructions are required to save bits that are shifted out of one memory location and to concatenate the shifted out bits during subsequent shift operations. These conventional software routines and techniques are slow, make inefficient use of processor cycles and can severely handicap performance when processors are engaged in running shift intensive applications. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> Accordingly, there is a need for a new method and processor configuration that permits multi-precision shifting and operates with multi-precision shift instructions to provide efficient shifting of multi-precision data. There is a further need for a new shifter that permits shift operations on multi-precision data on successive processor cycles. There is still a further need for shift instructions that permit multi-precision shifts using one shift instruction per multi-precision word. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> According to the present invention, a method and a processor configuration for processing shift instructions are provided that allow multi-precision shifts using one shift instruction per multi-precision word. The instructions themselves include the following multi-precision shift instructions: </paragraph>
<paragraph id="P-0009" lvl="2"><number>&lsqb;0009&rsqb;</number> MSL Wb, increment, Wnd (multi-precision shift left by increment) </paragraph>
<paragraph id="P-0010" lvl="2"><number>&lsqb;0010&rsqb;</number> MSR Wb, increment, Wnd (multi-precision shift right by increment) </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> Wb and Wnd specify source and destination memory locations from which to retrieve and store data respectively. These instructions are executed following a previous shift instruction of the same increment, such as a logical or arithmetic left or right shift operation. For example, to execute a logical left shift by 4 operation on a data value that spans two memory words, the following simple instruction sequence may be implemented: </paragraph>
<paragraph id="P-0012" lvl="2"><number>&lsqb;0012&rsqb;</number> SL Wb, 4, Wnd </paragraph>
<paragraph id="P-0013" lvl="2"><number>&lsqb;0013&rsqb;</number> MSL Wb, 4, Wnd </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> The first instruction shifts the low order memory word left by four bits and stores this shifted value into memory. The second, multi-precision shift instruction shifts the high order memory word left by four bits and concatenates the four bits shifted out of the low order memory word into the lower bits of the shifted upper word. This concatenated value is then stored back to memory and forms the upper half of the shifted value. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> According to one embodiment of the invention, a method of processing a multi-precision shift instruction includes fetching and decoding a multi-precision shift instruction. The method further includes executing the multi-precision shift instruction on an operand within a multi-word value to shift the operand and concatenate the shifted value with bits shifted out of a previous shift operation on the same multi-word value. The result of the shifting is then outputted. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> The method may include storing the bits shifted out of the operand during the executing into a carry register. The multi-precision shift instruction itself may be a shift left or a shift right instruction and may specify a shift increment. In addition, the concatenation step is performed by a logical OR operation. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> According to another embodiment of the present invention, a processor for processing multi-precision shift instructions includes a program memory, a program counter, and a barrel shifter. The program memory stores program instructions including a multi-precision shift instruction. The program counter identifies current instructions for processing. The barrel shifter executes shift instructions and includes a carry register for storing values shifted out of sections of the barrel shifter and OR logic for concatenating values stored in the carry 0 and carry 1 registers with values in the barrel shifter. The barrel shifter executes a shift instruction fetched from the program memory to a) load an operand into a section within the barrel shifter, b) shift the operand, c) output the shifted value and d) store into the carry register bits shifted out of the section of the barrel shifter. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> The barrel shifter may execute a multi-precision shift instruction to further e) concatenate the value in the carry register with the shifted operand prior to outputting the shifted value. The barrel shifter may execute at least two shift instructions to shift a multi-word value. The first instruction of the at least two shift instructions may not be a multi-precision shift instruction, but rather may be an arithmetic or logical left or right shift or other shift operation. However, the second and subsequent instructions of the at least two shift instructions are generally multi-precision shift instructions.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE FIGURES </heading>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> The above described features and advantages of the present invention will be more filly appreciated with reference to the detailed description and appended figures in which: </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> depicts a functional block diagram of an embodiment of a processor chip within which embodiments of the present invention may find application. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> depicts a functional block diagram of a data busing scheme for use in a processor, which has a microcontroller and a digital signal processing engine, within which embodiments of the present invention may find application. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> depicts a functional block diagram of a digital signal processor (DSP) engine according to an embodiment of the present invention. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> depicts a functional block diagram of a barrel shifter according to an embodiment of the present invention. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 5A and 5B</cross-reference> depict a multi-precision barrel shift left by 4 instruction sequence to illustrate multi-precision barrel shift instruction processing according to an embodiment of the present invention. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 6A and 6B</cross-reference> depict a multi-precision barrel shift right by 4 instruction sequence to illustrate multi-precision barrel shift instruction processing according to an embodiment of the present invention. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 7A and 7B</cross-reference> depict a multi-precision barrel shift right by 20 instruction sequence to illustrate multi-precision barrel shift instruction processing according to an embodiment of the present invention. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 8A and 8B</cross-reference> depict a multi-precision barrel shift left by 20 instruction sequence to illustrate multi-precision barrel shift instruction processing according to an embodiment of the present invention.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION </heading>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> According to the present invention, a method and a processor configuration for processing multi-precision shift instructions are provided. The multi-precision shift instructions are executed following a previous shift instruction of the same increment, such as a logical or arithmetic left or right shift operation. The first shift instruction shifts the first memory (or register) word by the shift increment and stores this shifted value into memory. The second, and any subsequent, multi-precision shift instruction shifts the next memory word by the shift increment and concatenates the bits shifted out of the previously shifted memory word into bit positions of the memory word presently being shifted. This concatenated value is then stored back to memory and forms another part of the multi-precision shifted value. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> In order to describe embodiments of processing multi-precision shift instructions, an overview of pertinent processor elements is first presented with reference to <cross-reference target="DRAWINGS">FIGS. 1 and 2</cross-reference>. The systems and methods for implementing multi-precision barrel shifting are then described more particularly with reference to FIGS. <highlight><bold>3</bold></highlight>-<highlight><bold>8</bold></highlight>B. </paragraph>
<paragraph id="P-0030" lvl="7"><number>&lsqb;0030&rsqb;</number> Overview of Processor Elements </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> depicts a functional block diagram of an embodiment of a processor chip within which the present invention may find application. Referring to <cross-reference target="DRAWINGS">FIG. 1, a</cross-reference> processor <highlight><bold>100</bold></highlight> is coupled to external devices/systems <highlight><bold>140</bold></highlight>. The processor <highlight><bold>100</bold></highlight> may be any type of processor including, for example, a digital signal processor (DSP), a microprocessor, a microcontroller or combinations thereof. The external devices <highlight><bold>140</bold></highlight> may be any type of systems or devices including input/output devices such as keyboards, displays, speakers, microphones, memory, or other systems which may or may not include processors. Moreover, the processor <highlight><bold>100</bold></highlight> and the external devices <highlight><bold>140</bold></highlight> may together comprise a stand alone system. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> The processor <highlight><bold>100</bold></highlight> includes a program memory <highlight><bold>105</bold></highlight>, an instruction fetch/decode unit <highlight><bold>110</bold></highlight>, instruction execution units <highlight><bold>115</bold></highlight>, data memory and registers <highlight><bold>120</bold></highlight>, peripherals <highlight><bold>125</bold></highlight>, data I/O <highlight><bold>130</bold></highlight>, and a program counter and loop control unit <highlight><bold>135</bold></highlight>. The bus <highlight><bold>150</bold></highlight>, which may include one or more common buses, communicates data between the units as shown. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> The program memory <highlight><bold>105</bold></highlight> stores software embodied in program instructions for execution by the processor <highlight><bold>100</bold></highlight>. The program memory <highlight><bold>105</bold></highlight> may comprise any type of nonvolatile memory such as a read only memory (ROM), a programmable read only memory (PROM), an electrically programmable or an electrically programmable and erasable read only memory (EPROM or EEPROM) or flash memory. In addition, the program memory <highlight><bold>105</bold></highlight> may be supplemented with external nonvolatile memory <highlight><bold>145</bold></highlight> as shown to increase the complexity of software available to the processor <highlight><bold>100</bold></highlight>. Alternatively, the program memory may be volatile memory which receives program instructions from, for example, an external non-volatile memory <highlight><bold>145</bold></highlight>. When the program memory <highlight><bold>105</bold></highlight> is nonvolatile memory, the program memory may be programmed at the time of manufacturing the processor <highlight><bold>100</bold></highlight> or prior to or during implementation of the processor <highlight><bold>100</bold></highlight> within a system. In the latter scenario, the processor <highlight><bold>100</bold></highlight> may be programmed through a process called in-line serial programming. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> The instruction fetch/decode unit <highlight><bold>110</bold></highlight> is coupled to the program memory <highlight><bold>105</bold></highlight>, the instruction execution units <highlight><bold>115</bold></highlight> and the data memory <highlight><bold>120</bold></highlight>. Coupled to the program memory <highlight><bold>105</bold></highlight> and the bus <highlight><bold>150</bold></highlight> is the program counter and loop control unit <highlight><bold>135</bold></highlight>. The instruction fetch/decode unit <highlight><bold>110</bold></highlight> fetches the instructions from the program memory <highlight><bold>105</bold></highlight> specified by the address value contained in the program counter <highlight><bold>135</bold></highlight>. The instruction fetch/decode unit <highlight><bold>110</bold></highlight> then decodes the fetched instructions and sends the decoded instructions to the appropriate execution unit <highlight><bold>115</bold></highlight>. The instruction fetch/decode unit <highlight><bold>110</bold></highlight> may also send operand information including addresses of data to the data memory <highlight><bold>120</bold></highlight> and to functional elements that access the registers. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> The program counter and loop control unit <highlight><bold>135</bold></highlight> includes a program counter register (not shown) which stores an address of the next instruction to be fetched. During normal instruction processing, the program counter register may be incremented to cause sequential instructions to be fetched. Alternatively, the program counter value may be altered by loading a new value into it via the bus <highlight><bold>150</bold></highlight>. The new value may be derived based on decoding and executing a flow control instruction such as, for example, a branch instruction. In addition, the loop control portion of the program counter and loop control unit <highlight><bold>135</bold></highlight> may be used to provide repeat instruction processing and repeat loop control as further described below. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> The instruction execution units <highlight><bold>115</bold></highlight> receive the decoded instructions from the instruction fetch/decode unit <highlight><bold>110</bold></highlight> and thereafter execute the decoded instructions. As part of this process, the execution units may retrieve one or two operands via the bus <highlight><bold>150</bold></highlight> and store the result into a register or memory location within the data memory <highlight><bold>120</bold></highlight>. The execution units may include an arithmetic logic unit (ALU) such as those typically found in a microcontroller. The execution units may also include a digital signal processing engine, a floating point processor, an integer processor or any other convenient execution unit. A preferred embodiment of the execution units and their interaction with the bus <highlight><bold>150</bold></highlight>, which may include one or more buses, is presented in more detail below with reference to <cross-reference target="DRAWINGS">FIG. 2</cross-reference>. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> The data memory and registers <highlight><bold>120</bold></highlight> are volatile memory and are used to store data used and generated by the execution units. The data memory <highlight><bold>120</bold></highlight> and program memory <highlight><bold>105</bold></highlight> are preferably separate memories for storing data and program instructions respectively. This format is a known generally as a Harvard architecture. It is noted, however, that according to the present invention, the architecture may be a Von-Neuman architecture or a modified Harvard architecture which permits the use of some program space for data space. A dotted line is shown, for example, connecting the program memory <highlight><bold>105</bold></highlight> to the bus <highlight><bold>150</bold></highlight>. This path may include logic for aligning data reads from program space such as, for example, during table reads from program space to data memory <highlight><bold>120</bold></highlight>. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> Referring again to <cross-reference target="DRAWINGS">FIG. 1, a</cross-reference> plurality of peripherals <highlight><bold>125</bold></highlight> on the processor may be coupled to the bus <highlight><bold>125</bold></highlight>. The peripherals may include, for example, analog to digital converters, timers, bus interfaces and protocols such as, for example, the controller area network (CAN) protocol or the Universal Serial Bus (USB) protocol and other peripherals. The peripherals exchange data over the bus <highlight><bold>150</bold></highlight> with the other units. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> The data I/O unit <highlight><bold>130</bold></highlight> may include transceivers and other logic for interfacing with the external devices/systems <highlight><bold>140</bold></highlight>. The data I/O unit <highlight><bold>130</bold></highlight> may further include functionality to permit in circuit serial programming of the Program memory through the data I/O unit <highlight><bold>130</bold></highlight>. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> depicts a functional block diagram of a data busing scheme for use in a processor <highlight><bold>100</bold></highlight>, such as that shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, which has an integrated microcontroller arithmetic logic unit (ALU) <highlight><bold>270</bold></highlight> and a digital signal processing (DSP) engine <highlight><bold>230</bold></highlight>. This configuration may be used to integrate DSP functionality to an existing microcontroller core. Referring to <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, the data memory <highlight><bold>120</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is implemented as two separate memories: an X-memory <highlight><bold>210</bold></highlight> and a Y-memory <highlight><bold>220</bold></highlight>, each being respectively addressable by an X-address generator <highlight><bold>250</bold></highlight> and a Y-address generator <highlight><bold>260</bold></highlight>. The X-address generator may also permit addressing the Y-memory space thus making the data space appear like a single contiguous memory space when addressed from the X address generator. The bus <highlight><bold>150</bold></highlight> may be implemented as two buses, one for each of the X and Y memory, to permit simultaneous fetching of data from the X and Y memories. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> The W registers <highlight><bold>240</bold></highlight> are general purpose address and/or data registers. The DSP engine <highlight><bold>230</bold></highlight> is coupled to both the X and Y memory buses and to the W registers <highlight><bold>240</bold></highlight>. The DSP engine <highlight><bold>230</bold></highlight> may simultaneously fetch data from each the X and Y memory, execute instructions which operate on the simultaneously fetched data and write the result to an accumulator (not shown) and write a prior result to X or Y memory or to the W registers <highlight><bold>240</bold></highlight> within a single processor cycle. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> In one embodiment, the ALU <highlight><bold>270</bold></highlight> may be coupled only to the X memory bus and may only fetch data from the X bus. However, the X and Y memories <highlight><bold>210</bold></highlight> and <highlight><bold>220</bold></highlight> may be addressed as a single memory space by the X address generator in order to make the data memory segregation transparent to the ALU <highlight><bold>270</bold></highlight>. The memory locations within the X and Y memories may be addressed by values stored in the W registers <highlight><bold>240</bold></highlight>. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> Any processor clocking scheme may be implemented for fetching and executing instructions. A specific example follows, however, to illustrate an embodiment of the present invention. Each instruction cycle is comprised of four Q clock cycles Q1-Q4. The four phase Q cycles provide timing signals to coordinate the decode, read, process data and write data portions of each instruction cycle. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> According to one embodiment of the processor <highlight><bold>100</bold></highlight>, the processor <highlight><bold>100</bold></highlight> concurrently performs two operations&mdash;it fetches the next instruction and executes the present instruction. Accordingly, the two processes occur simultaneously. The following sequence of events may comprise, for example, the fetch instruction cycle:  
<table-cwu id="TABLE-US-00001">
<number>1</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="42PT" align="right"/>
<colspec colname="2" colwidth="175PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>Q1:</entry>
<entry>Fetch Instruction</entry>
</row>
<row>
<entry>Q2:</entry>
<entry>Fetch Instruction</entry>
</row>
<row>
<entry>Q3:</entry>
<entry>Fetch Instruction</entry>
</row>
<row>
<entry>Q4:</entry>
<entry>Latch Instruction into prefetch register, Increment PC</entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> The following sequence of events may comprise, for example, the execute instruction cycle for a single operand instruction:  
<table-cwu id="TABLE-US-00002">
<number>2</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="right"/>
<colspec colname="2" colwidth="196PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>Q1:</entry>
<entry>latch instruction into IR, decode and determine addresses of</entry>
</row>
<row>
<entry></entry>
<entry>operand data</entry>
</row>
<row>
<entry>Q2:</entry>
<entry>fetch operand</entry>
</row>
<row>
<entry>Q3:</entry>
<entry>execute function specified by instruction and calculate destination</entry>
</row>
<row>
<entry></entry>
<entry>address for data</entry>
</row>
<row>
<entry>Q4:</entry>
<entry>write result to destination</entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> The following sequence of events may comprise, for example, the execute instruction cycle for a dual operand instruction using a data pre-fetch mechanism. These instructions pre-fetch the dual operands simultaneously from the X and Y data memories and store them into registers specified in the instruction. They simultaneously allow instruction execution on the operands fetched during the previous cycle.  
<table-cwu id="TABLE-US-00003">
<number>3</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="right"/>
<colspec colname="2" colwidth="196PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>Q1:</entry>
<entry>latch instruction into IR, decode and determine addresses of</entry>
</row>
<row>
<entry></entry>
<entry>operand data</entry>
</row>
<row>
<entry>Q2:</entry>
<entry>pre-fetch operands into specified registers, execute operation in</entry>
</row>
<row>
<entry></entry>
<entry>instruction</entry>
</row>
<row>
<entry>Q3:</entry>
<entry>execute operation in instruction, calculate destination address for</entry>
</row>
<row>
<entry></entry>
<entry>data</entry>
</row>
<row>
<entry>Q4:</entry>
<entry>complete execution, write result to destination</entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0047" lvl="7"><number>&lsqb;0047&rsqb;</number> DSP Engine and Multi-Precision Barrel Shift Instruction Processing </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> depicts a functional block diagram of the DSP engine <highlight><bold>230</bold></highlight>. The DSP engine <highlight><bold>230</bold></highlight> is coupled to the X and the Y bus and the W registers <highlight><bold>240</bold></highlight>. The DSP engine includes a multiplier <highlight><bold>300</bold></highlight>, a barrel shifter <highlight><bold>330</bold></highlight>, an adder/subtractor <highlight><bold>340</bold></highlight>, two accumulators <highlight><bold>345</bold></highlight> and <highlight><bold>350</bold></highlight> and round and saturation logic <highlight><bold>365</bold></highlight>. These elements and others that are discussed below with reference to <cross-reference target="DRAWINGS">FIG. 3</cross-reference> cooperate to process DSP instructions including, for example, multiply and accumulate instructions and shift instructions. According to one embodiment of the invention, the DSP engine operates as an asynchronous block with only the accumulators and the barrel shifter result registers being clocked. Other configurations, including pipelined configurations, may be implemented according to the present invention. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> The multiplier <highlight><bold>300</bold></highlight> has inputs coupled to the W registers <highlight><bold>240</bold></highlight> and an output coupled to the input of a multiplexer <highlight><bold>305</bold></highlight>. The multiplier <highlight><bold>300</bold></highlight> may also have inputs coupled to the X and Y bus. The multiplier may be any size however, for convenience, a 16&times;16 bit multiplier is described herein which produces a 32 bit output result. The multiplier may be capable of signed and unsigned operation and can multiplex its output using a scaler to support either fractional or integer results. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> The output of the multiplier <highlight><bold>300</bold></highlight> is coupled to one input of a multiplexer <highlight><bold>305</bold></highlight>. The multiplexer <highlight><bold>305</bold></highlight> has another input coupled to zero backfill logic <highlight><bold>310</bold></highlight>, which is coupled to the X Bus. The zero backfill logic <highlight><bold>310</bold></highlight> is included to illustrate that 16 zeros may be concatenated onto the 16 bit data read from the X bus to produce a 32 bit result fed into the multiplexer <highlight><bold>305</bold></highlight>. The 16 zeros are generally concatenated into the least significant bit positions. </paragraph>
<paragraph id="P-0051" lvl="7"><number>&lsqb;0051&rsqb;</number> The multiplexer <highlight><bold>305</bold></highlight> includes a control signal controlled by the instruction decoder of the processor which determines which input, either the multiplier output or a value from the X bus is passed forward. For instructions such as multiply and accumulate (MAC), the output of the multiplier is selected. For other instructions such as shift instructions, the value from the X bus (via the zero backfill logic) may be selected. The output of the multiplexer <highlight><bold>305</bold></highlight> is fed into the sign extend unit <highlight><bold>315</bold></highlight>. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> The sign extend unit <highlight><bold>315</bold></highlight> sign extends the output of the multiplexer from a 32 bit value to a 40 bit value. The sign extend unit <highlight><bold>315</bold></highlight> is illustrative only and this function may be implemented in a variety of ways. The sign extend unit <highlight><bold>315</bold></highlight> outputs a 40 bit value to a multiplexer <highlight><bold>320</bold></highlight>. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> The multiplexer <highlight><bold>320</bold></highlight> receives inputs from the sign extend unit <highlight><bold>315</bold></highlight> and the accumulators <highlight><bold>345</bold></highlight> and <highlight><bold>350</bold></highlight>. The multiplexer <highlight><bold>320</bold></highlight> selectively outputs values to the input of a barrel shifter <highlight><bold>330</bold></highlight> based on control signals derived from the decoded instruction. The accumulators <highlight><bold>345</bold></highlight> and <highlight><bold>350</bold></highlight> may be any length. According to the embodiment of the present invention selected for illustration, the accumulators are 40 bits in length. A multiplexer <highlight><bold>360</bold></highlight> determines which accumulator <highlight><bold>345</bold></highlight> or <highlight><bold>350</bold></highlight> is output to the multiplexer <highlight><bold>320</bold></highlight> and to the input of an adder <highlight><bold>340</bold></highlight>. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> The instruction decoder sends control signals to the multiplexers <highlight><bold>320</bold></highlight> and <highlight><bold>360</bold></highlight>, based on the decoded instruction. The control signals determine which accumulator is selected for either an add operation or a shift operation and whether a value from the multiplier or the X bus is selected for an add operation or a shift operation. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> The barrel shifter <highlight><bold>330</bold></highlight> performs shift operations on values received via the multiplexer <highlight><bold>320</bold></highlight>. The barrel shifter may perform arithmetic and logical left and right shifts and may perform circular shifts in some embodiments where bits rotated out one side of the shifter reenter through the opposite side of the buffer. In the illustrated embodiment, the barrel shifter is 40 bits in length and may perform a 15 bit arithmetic right shift and a 16 bit left shift in a single cycle. The shifter uses a signed binary value to determine both the magnitude and the direction of the shift operation. The signed binary value may come from a decoded instruction, such as shift instruction or a multi-precision shift instruction. According to one embodiment of the invention, a positive signed binary value produces a right shift and a negative signed binary value produces a left shift. A block diagram of the barrel shifter showing additional details is shown in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> The output of the barrel shifter <highlight><bold>330</bold></highlight> is sent to the multiplexer <highlight><bold>355</bold></highlight> and the multiplexer <highlight><bold>370</bold></highlight>. The multiplexer <highlight><bold>355</bold></highlight> also receives inputs from the accumulators <highlight><bold>345</bold></highlight> and <highlight><bold>350</bold></highlight>. The multiplexer <highlight><bold>355</bold></highlight> operates under control of the instruction decoder to selectively apply the value from one of the accumulators or the barrel shifter to the adder/subtractor <highlight><bold>340</bold></highlight> and the round and saturate logic <highlight><bold>365</bold></highlight>. </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> The adder/subtractor <highlight><bold>340</bold></highlight> may select either accumulator <highlight><bold>345</bold></highlight> or <highlight><bold>350</bold></highlight> as a source and/or a destination. In the illustrated embodiment, the adder/subtractor <highlight><bold>340</bold></highlight> has 40 bits. The adder receives an accumulator input and an input from another source such as the barrel shifter <highlight><bold>331</bold></highlight>, the X bus or the multiplier. The value from the barrel shifter <highlight><bold>331</bold></highlight> may come from the multiplier or the X bus and may be scaled in the barrel shifter prior to its arrival at the other input of the adder/subtractor <highlight><bold>340</bold></highlight>. The adder/subtractor <highlight><bold>340</bold></highlight> adds to or subtracts a value from the accumulator and stores the result back into one of the accumulators. In this manner values in the accumulators represent the accumulation of results from a series of arithmetic operations. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> The round and saturate logic <highlight><bold>365</bold></highlight> is used to round 40 bit values from the accumulator or the barrel shifter down to 16 bit values that may be transmitted over the X bus for storage into a W register or data memory. The round and saturate logic has an output coupled to a multiplexer <highlight><bold>370</bold></highlight>. The multiplier <highlight><bold>370</bold></highlight> may be used to select either the output of the round and saturate logic <highlight><bold>365</bold></highlight> or the output from a selected 16 bits of the barrel shifter <highlight><bold>330</bold></highlight> for output to the X bus. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> depicts a block diagram of the barrel shifter. Referring to <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, barrel shifter <highlight><bold>330</bold></highlight> includes a barrel shifter <highlight><bold>331</bold></highlight> itself. The shifter is shown to receive data via the multiplexer <highlight><bold>320</bold></highlight> from either accumulator <highlight><bold>345</bold></highlight> or <highlight><bold>350</bold></highlight> or from the X bus as described above. The barrel shifter <highlight><bold>331</bold></highlight> also receives inputs from zero or sign extend logic, zero backfill logic and a shifter control unit <highlight><bold>336</bold></highlight>. </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> On logical right shift instructions, the zero or sign extend logic <highlight><bold>332</bold></highlight> causes zeroes to be stored into locations on the left side of the barrel shifter that are vacated as a result of right shifting. On arithmetic right shift instructions, the zero or sign extend logic causes the value of the sign bit (which may be zero or one) to be stored into locations on the left side of the barrel shifter that are vacated as a result of right shifting. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> On logical left shift instructions, the zero backfill logic <highlight><bold>334</bold></highlight> causes zeros to be stored into locations on the right side of the barrel shifter that are vacated as a result of left shifting. </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> The shifter control unit <highlight><bold>336</bold></highlight> receives signed binary values taken from the decoded instruction and, in response, causes the value loaded into the barrel shifter to be shifted the specified amount in the specified direction. </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> The barrel shifter <highlight><bold>331</bold></highlight> itself is shown divided into three sections. For a 40 bit barrel shifter and a processor with a 16 bit word width, the rightmost section and the central section may each be 16 bits and the leftmost section may be eight bits wide. In the illustrated embodiment, the leftmost bit stores the sign of the value in the barrel shifter. The barrel shifter may output all 40 bits from among the three sections to, for example, the accumulators as described above. Alternatively, the barrel shifter <highlight><bold>330</bold></highlight> may output 16 bits from the center and rightmost sections to registers that facilitate multi-precision barrel shift operations as well as to the 16 bit X bus. </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> The rightmost 32 bits of the barrel shifter may be coupled to a multiplexer <highlight><bold>380</bold></highlight> which has outputs coupled to both a carry 0 register <highlight><bold>382</bold></highlight> and a carry 1 register <highlight><bold>384</bold></highlight> which are each 16 bits wide. The carry 1 and carry 0 registers have outputs coupled to a logical OR block <highlight><bold>388</bold></highlight>. </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> The logical OR block <highlight><bold>388</bold></highlight> receives inputs from the carry 0 and carry 1 registers and from a multiplexer <highlight><bold>386</bold></highlight>. The multiplexer <highlight><bold>386</bold></highlight> selectively applies either the rightmost or central section of the barrel shifter or zero to the input of the logical OR based on the decoded instruction. The logical OR block <highlight><bold>388</bold></highlight> takes the logical OR of the two 16 bit values at its inputs and applies the result to an input of a multiplexer <highlight><bold>390</bold></highlight>. The multiplexer <highlight><bold>390</bold></highlight> is controlled by the instruction decoded to output 16 bits at a time from the rightmost or central section of the barrel shifter <highlight><bold>330</bold></highlight> or the 16 bits from the logical OR. When shift instructions with more than 15 bits are encountered, the multiplexer may select 16 bits of zeros or sign extend to output as shown in <cross-reference target="DRAWINGS">FIGS. 7A and 8A</cross-reference>. </paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> The operation of the carry 0 and carry 1 registers comes into play when multi-precision barrel shift instructions are decoded and executed. The operation of these registers and the OR logic to process a multi-precision barrel shift instruction is explained more fully with reference to the specific multi-precision instruction flow diagrams that follow. </paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> A status register <highlight><bold>392</bold></highlight> on the processor reflects may certain results of shifting as part of multi-precision shift operations. For example, if a one is written into either of the carry 0 or carry 1 registers as a result of a multi-precision shift operation, a carry flag within the status register <highlight><bold>392</bold></highlight> may be set to indicate a carry. Other techniques for setting a carry flag may also be implemented. A zero flag within the status register <highlight><bold>392</bold></highlight> may be set to indicate the presence of a zero value as the operation result when a zero is written out to the memory (or register) location specified by Wnd as a result of a multi-precision shift operation. </paragraph>
<paragraph id="P-0068" lvl="0"><number>&lsqb;0068&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 5A and 5B</cross-reference> depict a multi-precision barrel shift instruction sequence to illustrate multi-precision barrel shift instruction processing according to an embodiment of the present invention. Referring to <cross-reference target="DRAWINGS">FIG. 5A, a</cross-reference> shift left instruction is considered: </paragraph>
<paragraph id="P-0069" lvl="2"><number>&lsqb;0069&rsqb;</number> SL Wb, 4, Wnd&mdash;shift left by 4 the contents of WB and store into Wnd </paragraph>
<paragraph id="P-0070" lvl="0"><number>&lsqb;0070&rsqb;</number> The Wb and Wnd are either registers or pointers to memory. Wb stores a value that is to be shifted and Wnd stores the shifted result after the operation. </paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> During execution of the instruction, the value from Wb is loaded into the barrel shifter <highlight><bold>330</bold></highlight> and a negative 4 is applied to the shifter control unit <highlight><bold>336</bold></highlight>. The shifter control unit <highlight><bold>336</bold></highlight> causes the barrel shifter <highlight><bold>331</bold></highlight> to shift the value to the left by four as shown in <cross-reference target="DRAWINGS">FIG. 5A</cross-reference>. The lower 16 bits of the shifted value are then taken from the rightmost section of the barrel shifter and stored back into the register or memory location specified by Wnd through proper configuration of the multiplexer <highlight><bold>390</bold></highlight>. </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> The multiplexer <highlight><bold>380</bold></highlight> is configured to store the value from the center section of the barrel shifter <highlight><bold>330</bold></highlight> into the carry 0 register as shown in <cross-reference target="DRAWINGS">FIG. 5A</cross-reference>. As a result, the carry 0 register stores a 16 bit value, the lower four bits of which are the left most four bits from the Wb register that were left shifted out. </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> After a SL instruction, one or more MSL instructions may be executed. The MSL is a multi-precision shift instruction. The multi-precision shift instruction allows one to shift values in memory or registers that span more than the word size of the processor. Accordingly, if thirty two bit or forty eight bit values were stored among two or three memory words respectively, the multi-precision instruction may be used to shift the value among three or four memory words respectively within the memory or registers. </paragraph>
<paragraph id="P-0074" lvl="0"><number>&lsqb;0074&rsqb;</number> Consider the following multi-precision instruction shown in <cross-reference target="DRAWINGS">FIG. 5B</cross-reference> which is executed after the SL instruction to shift a two word value in memory: </paragraph>
<paragraph id="P-0075" lvl="2"><number>&lsqb;0075&rsqb;</number> MSL Wb, 4, Wnd&mdash;multi-prec. Shift left by 4 the Wb value and store in Wnd. </paragraph>
<paragraph id="P-0076" lvl="0"><number>&lsqb;0076&rsqb;</number> During execution of the MSL instruction, the value from Wb is loaded into the barrel shifter in the same manner as the SL instruction. Then the barrel shifter contents are shifted left by 4 in the same manner described above. The MSL instruction causes the multiplexer <highlight><bold>390</bold></highlight> to select the output of the logical OR for outputting to the Wnd register. </paragraph>
<paragraph id="P-0077" lvl="0"><number>&lsqb;0077&rsqb;</number> The logical OR <highlight><bold>388</bold></highlight> takes the logical OR of the carry 0 register and the right-most 16 bits. This value is then output to Wnd and includes as its lowest four bits the upper four bits left shifted into the carry 0 register in the SL instruction. The value output also includes as its upper twelve bits the twelve bits that remain in the lower 16 bits of the barrel shifter after the MSL shift by four. In this manner, shifting may be performed on multiple word or multi-precision data with the values shifted out of one word being captured in the proper location in the adjoining word. </paragraph>
<paragraph id="P-0078" lvl="0"><number>&lsqb;0078&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 6A and 6B</cross-reference> depict a multi-precision arithmetic shift right instruction sequence. Referring to <cross-reference target="DRAWINGS">FIG. 6</cross-reference>A, the instruction ASR Wb, 4, Wnd causes the value in Wb to be loaded into the center section of the barrel shifter <highlight><bold>331</bold></highlight> and shifted right by four. The sign extend logic causes the value in the left most bit of the Wb register to be to be copied into the four bit locations vacated by the shift. The sign extended, shifted value from the central section is then selected by the multiplexer <highlight><bold>390</bold></highlight> and output to the Wnd location. At the same time, the value in the rightmost section of the barrel shifter is stored into the carry 1 register because this is a shift right instruction. </paragraph>
<paragraph id="P-0079" lvl="0"><number>&lsqb;0079&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6B</cross-reference> depicts the following MSR instruction (a multi-precision shift right instruction) executed after the ASR instruction: MSR, Wb, 4, Wnd. Referring to <cross-reference target="DRAWINGS">FIG. 6</cross-reference>B, the value from Wb is loaded into the center section of the barrel shifter <highlight><bold>330</bold></highlight> and shifted right by four with a zero extend. The zero extend is done because the sign bit is not part of the value in the Wb register for the MSR instruction. </paragraph>
<paragraph id="P-0080" lvl="0"><number>&lsqb;0080&rsqb;</number> This causes the shifted value from the center section of the circular buffer to be logically ORed with the carry 1 register. This value, which represents the shifted Wb value and the upper four bits that were right shifted out during ASR instruction processing, is then output to the Wnd register. The lower 16 bits of the barrel shifter are also stored into the carry 1 register, which may be used to correctly execute additional MSR instructions for values that span more than two words. </paragraph>
<paragraph id="P-0081" lvl="0"><number>&lsqb;0081&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 7A and 7B</cross-reference> depict a multi-precision arithmetic shift right instruction sequence where the shift is by 20, which exceeds the word width (16 bit) of the machine. Referring to <cross-reference target="DRAWINGS">FIG. 7</cross-reference>A, the instruction ASR Wb, 20, Wnd causes the value in Wb to be loaded into the center section of the barrel shifter and shifted right by four (this is twenty minus the word width of the machine 16) as shown in <cross-reference target="DRAWINGS">FIG. 7A</cross-reference>. The shift by four calculation is made by the shifter control unit <highlight><bold>336</bold></highlight>. The sign extend logic causes the value in the left most bit of the Wb register to be copied into the four bit locations vacated by the shift. Because the right shift is by more than one word, the shifter control unit <highlight><bold>336</bold></highlight> or the instruction decoder causes the multiplexer <highlight><bold>390</bold></highlight> to select 16 bits of sign extended data for output to the Wnd register. The sign extended, shifted value from the central section of the barrel shifter is then stored into the carry 1 register and the shifted value from the rightmost section of the barrel shifter is stored into the carry 0 register. </paragraph>
<paragraph id="P-0082" lvl="0"><number>&lsqb;0082&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7B</cross-reference> depicts the following MSR instruction (a multi-precision shift right instruction) executed after the ASR instruction: MSR, Wb, 20, Wnd. Referring to <cross-reference target="DRAWINGS">FIG. 7</cross-reference>B, the value from WB is loaded into the center section of the barrel shifter <highlight><bold>330</bold></highlight> and shifted right by four (this is value twenty minus the word width of the machine 16) as with a zero extend. The zero extend is done because the sign bit is not part of the value in the Wb register for the MSR instruction. </paragraph>
<paragraph id="P-0083" lvl="0"><number>&lsqb;0083&rsqb;</number> The value in the carry 1 register is selected by the multiplexer <highlight><bold>390</bold></highlight> and output to the Wnd register. The value in the carry 0 register is logically ORed with the value in the central section of the barrel shifter <highlight><bold>330</bold></highlight> and stored in the carry 1 register. The value in the rightmost section of the barrel shifter is then stored in the carry 0 section. A subsequent MSR Wb, 20, Wnd instructions may be executed to store the remaining bits into a destination register or when the multi-precision value exceeds three word widths. </paragraph>
<paragraph id="P-0084" lvl="0"><number>&lsqb;0084&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 8A and 8B</cross-reference> depict a multi-precision arithmetic shift left instruction sequence where the shift is by 20, which exceeds the word width (16 bit) of the machine. Referring to <cross-reference target="DRAWINGS">FIG. 8</cross-reference>A, the instruction SL Wb, 20, Wnd causes the value in Wb to be loaded into the rightmost section of the barrel shifter and shifted left by four (this is value twenty minus the word width of the machine 16) as shown in <cross-reference target="DRAWINGS">FIG. 8A</cross-reference>. The shift by four calculation is made by the shifter control unit <highlight><bold>336</bold></highlight>. The zero backfill logic causes zeros to populate the four bit locations vacated by the shift left. </paragraph>
<paragraph id="P-0085" lvl="0"><number>&lsqb;0085&rsqb;</number> Because the left shift is by more than one word, the shifter control unit <highlight><bold>336</bold></highlight> or the decoded instruction causes the multiplexer <highlight><bold>390</bold></highlight> to select 16 bits of zeros from the zero backfill for output to the Wnd register. The shifted value from the rightmost section of the barrel shifter is then stored into the carry 0 register and the shifted value from the central section of the barrel shifter is stored into the carry 1 register. </paragraph>
<paragraph id="P-0086" lvl="0"><number>&lsqb;0086&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7B</cross-reference> depicts the following MSL instruction (a multi-precision shift left instruction) executed after the SL instruction: MSL, Wb, 20, Wnd. Referring to <cross-reference target="DRAWINGS">FIG. 7</cross-reference>B, the value from Wb is loaded into the rightmost section of the barrel shifter <highlight><bold>330</bold></highlight> and shifted left by four (this is value twenty minus the word width of the machine 16) with a zero backfill. </paragraph>
<paragraph id="P-0087" lvl="0"><number>&lsqb;0087&rsqb;</number> The value in the carry 0 register is selected by the multiplexer <highlight><bold>390</bold></highlight> and output to the Wnd register. The value in the carry 1 register is logically ORed with the value in the rightmost section of the barrel shifter <highlight><bold>330</bold></highlight> and stored in the carry 0 register. The value in the central section of the barrel shifter is then stored in the carry 1 section. A subsequent MSL Wb, 20, Wnd instruction may be executed to store the remaining bits into a destination register or when the multi-precision value exceeds three word widths. </paragraph>
<paragraph id="P-0088" lvl="0"><number>&lsqb;0088&rsqb;</number> In general with the above multi-precision instructions, for a multi-precision shift right instruction in its various forms, the first value for Wb should be the leftmost word of data to be shifted. For a multi-precision shift left instruction in its various forms, the first value for Wb should be the rightmost word of data to be shifted. </paragraph>
<paragraph id="P-0089" lvl="0"><number>&lsqb;0089&rsqb;</number> While particular embodiments of the present invention have been illustrated and described, it will be understood by those having ordinary skill in the art that changes may be made to those embodiments without departing from the spirit and scope of the invention. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method of processing a multi-precision shift instruction, comprising: 
<claim-text>fetching and decoding a multi-precision shift instruction; </claim-text>
<claim-text>executing the multi-precision shift instruction on an operand within a multi-word value to shift the operand and concatenate the shifted value with bits shifted out of a previous shift operation on the same multi-word value; and </claim-text>
<claim-text>outputting the result. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising storing the bits shifted out of the operand during the executing into a carry register. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the multi-precision shift instruction is a shift left instruction. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the multi-precision shift instruction is a shift right instruction. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the concatenation step is performed by a logical OR operation. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the multi-precision shift instruction specifies a shift increment. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference>, wherein the shift increment is greater than or equal to the number of bits in a word. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference>, wherein the shift increment is less than the number of bits in a word. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. A processor for processing multi-precision shift instructions, comprising: 
<claim-text>a program memory for storing instructions including a multi-precision shift instruction; </claim-text>
<claim-text>a program counter for identifying current instructions for processing; and </claim-text>
<claim-text>a barrel shifter for executing shift instructions, the barrel shifter including: 
<claim-text>a carry register for storing values shifted out of sections of the barrel shifter; and </claim-text>
<claim-text>OR logic for concatenating values stored in the carry 0 and carry 1 registers with values in the barrel shifter, </claim-text>
<claim-text>the barrel shifter executing a shift instruction fetched from the program memory to a) load an operand into a section within the barrel shifter, b) shift the operand, c) output the shifted value and d) store into the carry register bits shifted out of the section of the barrel shifter. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The processor according to <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, wherein the barrel shifter executes a multi-precision shift instruction to further e) concatenate the value in the carry register with the shifted operand prior to outputting the shifted value. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The processor according to <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, wherein the shift instruction is a shift left instruction. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The processor according to <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, wherein the shift instruction is a shift right instruction. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The processor according to <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, wherein the shift instruction is an arithmetic shift instruction. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The processor according to <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, wherein the shift instruction is a logical shift instruction. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The processor according to <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, wherein the shift instruction specifies a shift increment. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The processor according to <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, wherein the barrel shifter executes at least two shift instructions to shift a multi-word value. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The processor according <highlight><bold>16</bold></highlight>, wherein the first instruction of the at least two shift instructions is not a multi-precision shift instruction. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The processor according <highlight><bold>16</bold></highlight>, wherein the second and subsequent instructions of the at least two shift instructions is a multi-precision shift instruction.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>5A</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005269A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005269A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005269A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005269A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005269A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005269A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030005269A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030005269A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030005269A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
