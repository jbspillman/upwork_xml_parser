<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005011A1-20030102-D00000.TIF SYSTEM "US20030005011A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005011A1-20030102-D00001.TIF SYSTEM "US20030005011A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005011A1-20030102-D00002.TIF SYSTEM "US20030005011A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005011A1-20030102-D00003.TIF SYSTEM "US20030005011A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005011A1-20030102-D00004.TIF SYSTEM "US20030005011A1-20030102-D00004.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005011</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09870461</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010601</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F007/38</ipc>
</classification-ipc-primary>
<classification-ipc-secondary>
<ipc>G06F007/00</ipc>
</classification-ipc-secondary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>708</class>
<subclass>490000</subclass>
</uspc>
</classification-us-primary>
<classification-us-secondary>
<uspc>
<class>708</class>
<subclass>525000</subclass>
</uspc>
</classification-us-secondary>
</classification-us>
<title-of-invention>Sticky z bit</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>John</given-name>
<family-name>Elliott</family-name>
</name>
<residence>
<residence-us>
<city>Chandler</city>
<state>AZ</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
</inventors>
<correspondence-address>
<name-1>SWIDLER BERLIN SHEREFF FRIEDMAN, LLP</name-1>
<name-2></name-2>
<address>
<address-1>3000 K STREET, NW</address-1>
<address-2>BOX IP</address-2>
<city>WASHINGTON</city>
<state>DC</state>
<postalcode>20007</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">The indication of a status affected by the performance of an ALU mathematical operation is provided. The indication includes the setting and clearing of a status bit in a status register based on the production of an arithmetic result of zero by an ALU performing the ALU mathematical operation. The result may comprise a series of results, each result produced by an ALU mathematical operation instruction executed to perform the ALU mathematical operation. Indicating a status affected by the performance of the ALU mathematical operation instruction further includes determining whether the ALU mathematical operation instruction corresponds to an ALU mathematical operation instruction with carry as well as determining whether the result is a non-zero value. The status bit maintains a value of zero upon the production of a non-zero value until an ALU mathematical operation instruction without carry is determined. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> 1. Field of the Invention </paragraph>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> The present invention relates to systems and methods for indicating the status of an ALU operation and, more particularly, to systems and methods for indicating the status of an ALU mathematical operation, pursuant to which the result is based on one or more prior results. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> 2. Description of Prior Art </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> Processors, including microprocessors, digital signal processors and microcontrollers, operate by running software programs that are embodied in one or more series of instructions stored in a memory. The processors run the software by fetching the instructions from the series of instructions, decoding the instructions and executing them. A 16-bit arithmetic logic unit (ALU) of a processor, including digital signal processors, are conventionally adept at processing ALU mathematical operation instructions, such as addition operation instructions, that operate on a data word or data byte, and indicates the various statuses affected by the execution of each ALU mathematical operation instruction with status flags. For example, a 16-bit ALU of a processor is adept at performing an addition operation according to an addition mathematical operation instruction on operands represented as a data word and indicating if the result of the addition operation produced an arithmetic result of zero by setting a zero status bit. In general, the statuses affected by a 16-bit ALU mathematical operation is set based on each single 16-bit result produced by the ALU mathematical operation. Accordingly, the statuses affected by a 16-bit ALU mathematical operation may be misleading in conditions where the result is based on one or more prior results and produced by executing a series of ALU mathematical operation instructions. These type of ALU mathematical operations execute in two processing cycles and produce a 16-bit results in each of the processing cycles to form the final result. As a result, the status flags may only indicate the statuses affected by the ALU mathematical operation based on a result produced during the most recent processing cycle instead of the results produced during both processing cycles. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> There is a need for a new method of indicating the statuses affected by the performance of an ALU mathematical operation. There is a further need for a new method of indicating the statuses affected by the performance of an ALU mathematical operation producing a final result formed by two distinct semi-results. There is a further need for a new method of indicating the statuses affected by the performance of an ALU mathematical operation for each result produced during the performance of the ALU mathematical operation based on preceding results. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> According to embodiments of the present invention, a method and a processor for indicating a status affected by the performance of an ALU mathematical operation are provided. The status affected by the performance of an ALU mathematical operation include the sticky zero flag for indicating whether a result of the ALU mathematical operation produced an arithmetic result of zero. The pre-requisite for employing the sticky zero flag is that a prior math operation must be a conventional math operation (i.e., no carry involved) that set the sticky zero flag with a one (1) or a zero (0) and the subsequent math operation is a math operation including a carry. The sticky zero flag maintains a setting indicating non-zero status upon the production of a non-zero result until the performance of a ALU mathematical operation not including a carry produces an arithmetic result of zero. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> A method of indicating a status affected by the performance of an ALU mathematical operation according to an embodiment of the present invention includes executing an ALU mathematical operation instruction on a set of source operands. The method further includes determining that the ALU mathematical operation instruction corresponds to an ALU mathematical operation instruction with carry. The method further includes producing a result based on the set of source operands in accordance with the ALU mathematical operation instruction and setting a status flag based on the result. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> In an embodiment of the present invention, the setting of the status flag includes determining that the result is a non-zero value. Upon determining that the result is a non-zero value the status flag is cleared by writing to it a value of zero. The value of zero is maintained in the status flag until an ALU mathematical operation instruction without carry is determined. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> In an embodiment of the present invention, the setting of the status flag includes determining that the result is a zero value. Upon determining that the result is a zero, the value of the status flag is maintained. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> A processor for indicating a status affected by the performance of an ALU mathematical operation includes an ALU operable to execute an ALU mathematical operation instruction on a set of source operands. The ALU can determines that the ALU mathematical operation instruction corresponds to an ALU mathematical operation instruction with carry. The ALU is further operable to produce a result based on the set of source operands in accordance with the ALU mathematical operation instruction and set a status flag based on the result.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> The above described features and advantages of the present invention will be more fully appreciated with reference to the detailed description and appended figures in which: </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> depicts a functional block diagram of an embodiment of a processor chip within which embodiments of the present invention may find application; </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> depicts a functional block diagram of a data busing scheme for use in a processor, which has a microcontroller and a digital signal processing engine, within which embodiments of the present invention may find application; </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> depicts a functional block diagram of a processor configuration for indicating a status affected by the performance of an ALU mathematical operation according to embodiments of the present invention; and </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> depicts a method of indicating a status affected by the performance of an ALU mathematical operation according to embodiments of the present invention</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF THE INVENTION </heading>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> According to embodiments of the present invention, a method and a processor for indicating a status affected by the performance of an ALU mathematical operation are provided. The status affected by the performance of an ALU mathematical operation include the sticky zero flag for indicating whether a result of the ALU mathematical operation produced an arithmetic result of zero. Moreover, the sticky zero flag indicates whether a result produced during the performance of the ALU mathematical operation produced an arithmetic result of zero. The sticky zero flag maintains a setting indicating non-zero status until a subsequent ALU mathematical math operation without carry produces a result of zero. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> In order to describe embodiments of ALU mathematical operation status indicating, an overview of pertinent processor elements is first presented with reference to <cross-reference target="DRAWINGS">FIGS. 1 and 2</cross-reference>. The ALU mathematical operation status indicating is then described more particularly with reference to FIGS. <highlight><bold>3</bold></highlight>-<highlight><bold>5</bold></highlight>. </paragraph>
<paragraph id="P-0018" lvl="7"><number>&lsqb;0018&rsqb;</number> Overview of Processor Elements </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> depicts a functional block diagram of an embodiment of a processor chip within which the present invention may find application. Referring to <cross-reference target="DRAWINGS">FIG. 1, a</cross-reference> processor <highlight><bold>100</bold></highlight> is coupled to external devices/systems <highlight><bold>140</bold></highlight>. The processor <highlight><bold>100</bold></highlight> may be any type of processor including, for example, a digital signal processor (DSP), a microprocessor, a microcontroller or combinations thereof. The external devices <highlight><bold>140</bold></highlight> may be any type of systems or devices including input/output devices such as keyboards, displays, speakers, microphones, memory, or other systems which may or may not include processors. Moreover, the processor <highlight><bold>100</bold></highlight> and the external devices <highlight><bold>140</bold></highlight> may together comprise a stand alone system. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> The processor <highlight><bold>100</bold></highlight> includes a program memory <highlight><bold>105</bold></highlight>, an instruction fetch/decode unit <highlight><bold>110</bold></highlight>, instruction execution units <highlight><bold>115</bold></highlight>, data memory and registers <highlight><bold>120</bold></highlight>, peripherals <highlight><bold>125</bold></highlight>, data I/<highlight><bold>0</bold></highlight> <highlight><bold>130</bold></highlight>, and a program counter and loop control unit <highlight><bold>135</bold></highlight>. The bus <highlight><bold>150</bold></highlight>, which may include one or more common buses, communicates data between the units as shown. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> The program memory <highlight><bold>105</bold></highlight> stores software embodied in program instructions for execution by the processor <highlight><bold>100</bold></highlight>. The program memory <highlight><bold>105</bold></highlight> may comprise any type of nonvolatile memory such as a read only memory (ROM), a programmable read only memory (PROM), an electrically programmable or an electrically programmable and erasable read only memory (EPROM or EEPROM) or flash memory. In addition, the program memory <highlight><bold>105</bold></highlight> may be supplemented with external nonvolatile memory <highlight><bold>145</bold></highlight> as shown to increase the complexity of software available to the processor <highlight><bold>100</bold></highlight>. Alternatively, the program memory may be volatile memory which receives program instructions from, for example, an external non-volatile memory <highlight><bold>145</bold></highlight>. When the program memory <highlight><bold>105</bold></highlight> is nonvolatile memory, the program memory may be programmed at the time of manufacturing the processor <highlight><bold>100</bold></highlight> or prior to or during implementation of the processor <highlight><bold>100</bold></highlight> within a system. In the latter scenario, the processor <highlight><bold>100</bold></highlight> may be programmed through a process called in-line serial programming. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> The instruction fetch/decode unit <highlight><bold>110</bold></highlight> is coupled to the program memory <highlight><bold>105</bold></highlight>, the instruction execution units <highlight><bold>115</bold></highlight> and the data memory <highlight><bold>120</bold></highlight>. Coupled to the program memory <highlight><bold>105</bold></highlight> and the bus <highlight><bold>150</bold></highlight> is the program counter and loop control unit <highlight><bold>135</bold></highlight>. The instruction fetch/decode unit <highlight><bold>110</bold></highlight> fetches the instructions from the program memory <highlight><bold>105</bold></highlight> specified by the address value contained in the program counter <highlight><bold>135</bold></highlight>. The instruction fetch/decode unit <highlight><bold>110</bold></highlight> then decodes the fetched instructions and sends the decoded instructions to the appropriate execution unit <highlight><bold>115</bold></highlight>. The instruction fetch/decode unit <highlight><bold>110</bold></highlight> may also send operand information including addresses of data to the data memory <highlight><bold>120</bold></highlight> and to functional elements that access the registers. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> The program counter and loop control unit <highlight><bold>135</bold></highlight> includes a program counter register (not shown) which stores an address of the next instruction to be fetched. During normal instruction processing, the program counter register may be incremented to cause sequential instructions to be fetched. Alternatively, the program counter value may be altered by loading a new value into it via the bus <highlight><bold>150</bold></highlight>. The new value may be derived based on decoding and executing a flow control instruction such as, for example, a branch instruction. In addition, the loop control portion of the program counter and loop control unit <highlight><bold>135</bold></highlight> may be used to provide repeat instruction processing and repeat loop control as further described below. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> The instruction execution units <highlight><bold>115</bold></highlight> receive the decoded instructions from the instruction fetch/decode unit <highlight><bold>110</bold></highlight> and thereafter execute the decoded instructions. As part of this process, the execution units may retrieve one or two operands via the bus <highlight><bold>150</bold></highlight> and store the result into a register or memory location within the data memory <highlight><bold>120</bold></highlight>. The execution units may include an arithmetic logic unit (ALU) such as those typically found in a microcontroller. The execution units may also include a digital signal processing engine, a floating point processor, an integer processor or any other convenient execution unit. A preferred embodiment of the execution units and their interaction with the bus <highlight><bold>150</bold></highlight>, which may include one or more buses, is presented in more detail below with reference to <cross-reference target="DRAWINGS">FIG. 2</cross-reference>. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> The data memory and registers <highlight><bold>120</bold></highlight> are volatile memory and are used to store data used and generated by the execution units. The data memory <highlight><bold>120</bold></highlight> and program memory <highlight><bold>105</bold></highlight> are preferably separate memories for storing data and program instructions respectively. This format is a known generally as a Harvard architecture. It is noted, however, that according to the present invention, the architecture may be a Von-Neuman architecture or a modified Harvard architecture which permits the use of some program space for data space. A dotted line is shown, for example, connecting the program memory <highlight><bold>105</bold></highlight> to the bus <highlight><bold>150</bold></highlight>. This path may include logic for aligning data reads from program space such as, for example, during table reads from program space to data memory <highlight><bold>120</bold></highlight>. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> Referring again to <cross-reference target="DRAWINGS">FIG. 1, a</cross-reference> plurality of peripherals <highlight><bold>125</bold></highlight> on the processor may be coupled to the bus <highlight><bold>150</bold></highlight>. The peripherals may include, for example, analog to digital converters, timers, bus interfaces and protocols such as, for example, the controller area network (CAN) protocol or the Universal Serial Bus (USB) protocol and other peripherals. The peripherals exchange data over the bus <highlight><bold>150</bold></highlight> with the other units. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> The data I/<highlight><bold>0</bold></highlight> unit <highlight><bold>130</bold></highlight> may include transceivers and other logic for interfacing with the external devices/systems <highlight><bold>140</bold></highlight>. The data I/<highlight><bold>0</bold></highlight> unit <highlight><bold>130</bold></highlight> may further include functionality to permit in circuit serial programming of the Program memory through the data I/<highlight><bold>0</bold></highlight> unit <highlight><bold>130</bold></highlight>. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> depicts a functional block diagram of a data busing scheme for use in a processor <highlight><bold>100</bold></highlight>, such as that shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, which has an integrated microcontroller arithmetic logic unit (ALU) <highlight><bold>270</bold></highlight> and a digital signal processing (DSP) engine <highlight><bold>230</bold></highlight>. This configuration may be used to integrate DSP functionality to an existing microcontroller core. Referring to <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, the data memory <highlight><bold>120</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is implemented as two separate memories: an X-memory <highlight><bold>210</bold></highlight> and a Y-memory <highlight><bold>220</bold></highlight>, each being respectively addressable by an X-address generator <highlight><bold>250</bold></highlight> and a Y-address generator <highlight><bold>260</bold></highlight>. The X-address generator may also permit addressing the Y-memory space thus making the data space appear like a single contiguous memory space when addressed from the X address generator. The bus <highlight><bold>150</bold></highlight> may be implemented as two buses, one for each of the X and Y memory, to permit simultaneous fetching of data from the X and Y memories. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> The W registers <highlight><bold>240</bold></highlight> are general purpose address and/or data registers. The DSP engine <highlight><bold>230</bold></highlight> is coupled to both the X and Y memory buses and to the W registers <highlight><bold>240</bold></highlight>. The DSP engine <highlight><bold>230</bold></highlight> may simultaneously fetch data from each the X and Y memory, execute instructions which operate on the simultaneously fetched data and write the result to an accumulator (not shown) and write a prior result to X or Y memory or to the W registers <highlight><bold>240</bold></highlight> within a single processor cycle. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> In one embodiment, the ALU <highlight><bold>270</bold></highlight> may be coupled only to the X memory bus and may only fetch data from the X bus. However, the X and Y memories <highlight><bold>210</bold></highlight> and <highlight><bold>220</bold></highlight> may be addressed as a single memory space by the X address generator in order to make the data memory segregation transparent to the ALU <highlight><bold>270</bold></highlight>. The memory locations within the X and Y memories may be addressed by values stored in the W registers <highlight><bold>240</bold></highlight>. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> Any processor clocking scheme may be implemented for fetching and executing instructions. A specific example follows, however, to illustrate an embodiment of the present invention. Each instruction cycle is comprised of four Q clock cycles Q1 Q4. The four phase Q cycles provide timing signals to coordinate the decode, read, process data and write data portions of each instruction cycle. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> According to one embodiment of the processor <highlight><bold>100</bold></highlight>, the processor <highlight><bold>100</bold></highlight> concurrently performs two operations&mdash;it fetches the next instruction and executes the present instruction. Accordingly, the two processes occur simultaneously. The following sequence of events may comprise, for example, the fetch instruction cycle:  
<table-cwu id="TABLE-US-00001">
<number>1</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="42PT" align="right"/>
<colspec colname="2" colwidth="175PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>Q1:</entry>
<entry>Fetch Instruction</entry>
</row>
<row>
<entry>Q2:</entry>
<entry>Fetch Instruction</entry>
</row>
<row>
<entry>Q3:</entry>
<entry>Fetch Instruction</entry>
</row>
<row>
<entry>Q4:</entry>
<entry>Latch Instruction into prefetch register, Increment PC</entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> The following sequence of events may comprise, for example, the execute instruction cycle for a single operand instruction:  
<table-cwu id="TABLE-US-00002">
<number>2</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="right"/>
<colspec colname="2" colwidth="196PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>Q1:</entry>
<entry>latch instruction into IR, decode and determine addresses of</entry>
</row>
<row>
<entry></entry>
<entry>operand data</entry>
</row>
<row>
<entry>Q2:</entry>
<entry>fetch operand</entry>
</row>
<row>
<entry>Q3:</entry>
<entry>execute function specified by instruction and calculate destination</entry>
</row>
<row>
<entry></entry>
<entry>address for data</entry>
</row>
<row>
<entry>Q4:</entry>
<entry>write result to destination</entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> The following sequence of events may comprise, for example, the execute instruction cycle for a dual operand instruction using a data pre-fetch mechanism. These instructions pre-fetch the dual operands simultaneously from the X and Y data memories and store them into registers specified in the instruction. They simultaneously allow instruction execution on the operands fetched during the previous cycle.  
<table-cwu id="TABLE-US-00003">
<number>3</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="right"/>
<colspec colname="2" colwidth="196PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>Q1:</entry>
<entry>latch instruction into IR, decode and determine addresses of</entry>
</row>
<row>
<entry></entry>
<entry>operand data</entry>
</row>
<row>
<entry>Q2:</entry>
<entry>pre-fetch operands into specified registers, execute operation in</entry>
</row>
<row>
<entry></entry>
<entry>instruction</entry>
</row>
<row>
<entry>Q3:</entry>
<entry>execute operation in instruction, calculate destination address for</entry>
</row>
<row>
<entry></entry>
<entry>data</entry>
</row>
<row>
<entry>Q4:</entry>
<entry>complete execution, write result to destination</entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0035" lvl="7"><number>&lsqb;0035&rsqb;</number> ALU Mathematical Operation Status Indicating </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> depicts a functional block diagram of a processor for indicating a status of an ALU mathematical operation according to the present invention. Referring to <cross-reference target="DRAWINGS">FIG. 3</cross-reference>, the processor includes a program memory <highlight><bold>300</bold></highlight> for storing instructions such as ALU mathematical operation instructions. The processor also includes a program counter <highlight><bold>305</bold></highlight> which stores a pointer to the next program instruction that is to be fetched. The processor further includes an instruction register <highlight><bold>315</bold></highlight> for storing an instruction for execution that has been fetched from the program memory <highlight><bold>300</bold></highlight>. The processor may further include pre-fetch registers (not shown) that may be used for fetching and storing a series of upcoming instructions for decoding and execution. The processor also includes an instruction decoder <highlight><bold>320</bold></highlight>, an arithmetic logic unit (ALU) <highlight><bold>325</bold></highlight>, registers <highlight><bold>345</bold></highlight> and a status register <highlight><bold>350</bold></highlight>. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> The instruction decoder <highlight><bold>320</bold></highlight> decodes instructions, such as ALU mathematical operation instructions, that are stored in the instruction register <highlight><bold>315</bold></highlight>. Based on the combination of bits in the instruction, the instruction decoder <highlight><bold>320</bold></highlight> decodes particular bits in ALU mathematical operation instructions that results in the selective activation of logic within the ALU <highlight><bold>325</bold></highlight> for fetching operands, performing the operation specified by the fetched instruction on the operands, producing an output/result in accordance with the instruction to the appropriate data memory location and setting a status bit in accordance with the operation performed on the operands by the instruction. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> The ALU <highlight><bold>325</bold></highlight> includes registers <highlight><bold>330</bold></highlight> that may receive one or more operands from the registers <highlight><bold>345</bold></highlight> and/or a data memory location <highlight><bold>355</bold></highlight>. The origin of the one or more operands depends on the addressing mode defined by the combination of bits used in the instruction. For example, one combination of address mode bits results in the activation of logic that obtains one operand from data memory across the X data bus depicted in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, another operand from a register. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> The ALU <highlight><bold>325</bold></highlight> includes ALU logic <highlight><bold>335</bold></highlight> which may receive the one or more operands from the registers <highlight><bold>330</bold></highlight>. The ALU logic <highlight><bold>335</bold></highlight> executes arithmetic and logic operations according to instructions, such as ALU mathematical operation instructions, decoded by the instruction decoder on the one or more operands fetched from the registers <highlight><bold>345</bold></highlight> and/or from address location in the data memory <highlight><bold>345</bold></highlight>. The ALU logic <highlight><bold>335</bold></highlight> produces outputs/results in accordance with the arithmetic and logic operations based on the one or more operands to one of registers <highlight><bold>345</bold></highlight> and/or the status register <highlight><bold>350</bold></highlight>. The outputs/results may be stored/written to the register in accordance with bits specified in the instruction. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> Status register <highlight><bold>350</bold></highlight> contains status bits that indicate the status of processor elements and operations. Status register <highlight><bold>350</bold></highlight> may be a 16-bit status register. The status register <highlight><bold>350</bold></highlight> may be separated into a lower segment and an upper segment. The processor operations for which status may be indicated include MCU ALU, DSP Adder/Subtractor, repeat, and Do loop. A bit in the status register <highlight><bold>350</bold></highlight>, such as a sticky z bit, can indicate whether an operation, such as an ALU mathematical operation, produce an arithmetic result of zero. An ALU mathematical operation may comprise of a series of ALU mathematical operation instructions, some specifying a carry and some not specifying a carry, but each producing an arithmetic result. The bit is set, such as with a value of one (1) or zero (0), to indicate that an ALU mathematical operation instruction has been executed some time in the past which produced a zero arithmetic result or a non-zero arithmetic result. The bit is initially set with a value of one (1) by the execution of an ALU math operation instruction without carry produces a zero result. The bit remains set until a subsequent ALU mathematical operation instruction with carry is executed and produces a non-zero arithmetic result. When a non-zero result is produced, the bit is cleared, such as with a value of zero, and remains cleared until a subsequent ALU mathematical operation instruction without carry is executed and produces a zero arithmetic result. The application of the bit, such as the sticky z bit, is determined by the execution of an ALU mathematical operation instruction with carry subsequent to the execution of an ALU mathematical operation instruction without a carry. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> depicts a method of indicating a status of an ALU mathematical operation according to the present invention. <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is best understood when viewed in conjunction with <cross-reference target="DRAWINGS">FIG. 3</cross-reference>. Referring to <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, in step <highlight><bold>400</bold></highlight>, the decoder <highlight><bold>320</bold></highlight> determines whether an ALU mathematical operation instruction specifies a carry operation. The instruction may be fetched from the program memory <highlight><bold>300</bold></highlight>. The decoder determines whether the ALU mathematical operation instruction specifies a carry operation by decoding bits in the instruction. If an ALU mathematical operation instruction with carry is determined, then the method proceeds to step <highlight><bold>405</bold></highlight>. In step <highlight><bold>405</bold></highlight>, the ALU mathematical operation instruction is executed by ALU <highlight><bold>325</bold></highlight>. The ALU performs an operation on one or more operands specified by the ALU mathematical operation instruction. Then in step <highlight><bold>410</bold></highlight>, the ALU <highlight><bold>325</bold></highlight> produces an output/result in accordance with the performed operation. The output result may be stored in data memory or data registers as specified by the ALU mathematical operation instruction. In step <highlight><bold>415</bold></highlight>, the ALU <highlight><bold>325</bold></highlight> determines whether the output/result produced an arithmetic result of zero. If the ALU did not produce an arithmetic result of zero, then the method proceeds to step <highlight><bold>420</bold></highlight> where the status bit is cleared, that is changing the bit value from one (1) to zero (0). The status bit maintains the value of zero until an ALU mathematical operation instruction is executed that is not an ALU mathematical operation instruction specifying a carry operation. If the ALU produced an arithmetic result of zero, then the method proceeds to step <highlight><bold>425</bold></highlight>. In step <highlight><bold>425</bold></highlight>, the ALU <highlight><bold>325</bold></highlight> does nothing until the next ALU mathematical operation instruction not specifying a carry is executed and produces a zero arithmetic result. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> If an ALU mathematical operation instruction with carry is not determined, then the method proceeds to step <highlight><bold>435</bold></highlight>. In step <highlight><bold>435</bold></highlight>, the ALU mathematical operation instruction is executed by ALU <highlight><bold>325</bold></highlight>. The ALU performs an operation on one or more operands specified by the ALU mathematical operation instruction. Then in step <highlight><bold>440</bold></highlight>, the ALU <highlight><bold>325</bold></highlight> produces an output/result in accordance with the performed operation. The output result may be stored in data memory or data registers as specified by the ALU mathematical operation instruction. In step <highlight><bold>445</bold></highlight>, the ALU <highlight><bold>325</bold></highlight> determines whether the output/result produced an arithmetic result of zero. If the ALU did not produce an arithmetic result of zero, then the method proceeds to step <highlight><bold>455</bold></highlight> where the status bit is set with a value of zero. If the ALU produced an arithmetic result of zero, then the method proceeds to step <highlight><bold>450</bold></highlight>. In step <highlight><bold>450</bold></highlight>, the status bit is set with a value of 1. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> While specific embodiments of the present invention have been illustrated and described, it will be understood by those having ordinary skill in the art that changes may be made to those embodiments without departing from the spirit and scope of the invention. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method of indicating a status affected by the performance of an ALU mathematical operation, comprising: 
<claim-text>executing an ALU mathematical operation instruction on a set of source operands; </claim-text>
<claim-text>determining that the ALU mathematical operation instruction corresponds to an ALU mathematical operation instruction with carry; </claim-text>
<claim-text>producing a result based on the set of source operands in accordance with the ALU mathematical operation instruction; and </claim-text>
<claim-text>setting a status flag based on the result. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the step of setting the status flag includes the step of determining that the result is a non-zero value. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, wherein the step of setting the status flag includes the step of clearing the status flag by writing a value of zero to the status flag. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference>, wherein the step of setting the status flag includes the step maintaining the value of zero in the status flag until an ALU mathematical operation instruction without carry is determined. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the step of setting the status flag includes the step of determining that the result is a zero value. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference>, wherein the step of setting the status flag includes the step of maintaining the value in the status flag. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. A processor for indicating a status affected by the performance of an ALU mathematical operation, comprising: 
<claim-text>an ALU operable to: 
<claim-text>execute an ALU mathematical operation instruction on a set of source operands; </claim-text>
<claim-text>determine that the ALU mathematical operation instruction corresponds to an ALU mathematical operation instruction with carry; </claim-text>
<claim-text>produce a result based on the set of source operands in accordance with the ALU mathematical operation instruction; and </claim-text>
<claim-text>set a status flag based on the result. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The processor according to <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference>, further comprising the ALU operable to determine that the result is a non-zero value. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The processor according to <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference>, further comprising the ALU operable to clear the status flag by writing a value of zero to the status flag. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The processor according to <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, further comprising the ALU operable to maintain the value of zero in the status flag until an ALU mathematical operation instruction without carry is determined. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The processor according to <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference>, further comprising the ALU operable to determine that the result is a zero value. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The processor according to <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, further comprising the ALU operable to maintain the value of the status flag.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>4</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005011A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005011A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005011A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005011A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005011A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
