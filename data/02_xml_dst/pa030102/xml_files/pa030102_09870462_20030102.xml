<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005254A1-20030102-D00000.TIF SYSTEM "US20030005254A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005254A1-20030102-D00001.TIF SYSTEM "US20030005254A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005254A1-20030102-D00002.TIF SYSTEM "US20030005254A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005254A1-20030102-D00003.TIF SYSTEM "US20030005254A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005254A1-20030102-D00004.TIF SYSTEM "US20030005254A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005254A1-20030102-D00005.TIF SYSTEM "US20030005254A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030005254A1-20030102-D00006.TIF SYSTEM "US20030005254A1-20030102-D00006.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005254</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09870462</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010601</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F012/00</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>711</class>
<subclass>200000</subclass>
</uspc>
</classification-us-primary>
<classification-us-secondary>
<uspc>
<class>711</class>
<subclass>168000</subclass>
</uspc>
</classification-us-secondary>
</classification-us>
<title-of-invention>Compatible effective addressing with a dynamically reconfigurable data space word width</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Joseph</given-name>
<middle-name>W.</middle-name>
<family-name>Triece</family-name>
</name>
<residence>
<residence-us>
<city>Phoenix</city>
<state>AZ</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Michael</given-name>
<family-name>Pyska</family-name>
</name>
<residence>
<residence-us>
<city>Phoenix</city>
<state>AZ</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Stephen</given-name>
<middle-name>A.</middle-name>
<family-name>Bowling</family-name>
</name>
<residence>
<residence-us>
<city>Chandler</city>
<state>AZ</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Michael</given-name>
<middle-name>I.</middle-name>
<family-name>Catherwood</family-name>
</name>
<residence>
<residence-us>
<city>Pepperell</city>
<state>MA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>SWIDLER BERLIN SHEREFF FRIEDMAN, LLP</name-1>
<name-2></name-2>
<address>
<address-1>3000 K STREET, NW</address-1>
<address-2>BOX IP</address-2>
<city>WASHINGTON</city>
<state>DC</state>
<postalcode>20007</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A processor has a native word width of multiples of a byte width. The processor may, nonetheless, process, store and retrieve data in word or byte widths depending on the mode of an instruction directing the processing. Instructions may assume either a word or a byte mode. In the word mode, the instruction causes the processor to read, store and operate on word width data. In the byte mode, the instruction causes the processor to read, store and operate on byte data where the byte is specified based on upper/lower byte bits in the instruction. This architecture permits a new generation of processor having word widths of more than one byte to be backward compatible with software written for byte width processors. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">FIELD OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> The present invention relates to systems and methods for addressing memory locations and, more particularly, to systems and methods for dynamically addressing a memory using variable word widths. </paragraph>
</section>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> Processors, including microprocessors, digital signal processors and microcontrollers, generally operate on data in blocks called words. Each word has conventionally been defined as one byte (eight bits) or a multiple of a power of two bytes. Accordingly, processor word widths have been, for example, 8, 16, 32 and 64 bits. Processors with wider word widths may perform more accurate calculations by using and retaining more significant digits during processing. Other things being equal, processors with wider word widths tend to be more complex but also perform operations more quickly and in parallel by comparison to processors with various word widths. Successive generations of processors tend to be designed using wider word widths in order to capitalize on the above advantages. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> One problem with creating a new generation of processors within a line of processors is ensuring backward compatibility. When a new processor is created with a wider word width than a previous generation, the new processor may no longer be compatible with software written for the earlier generation of processor. This may occur because software written for the earlier generation processor may presume a certain word width and include mathematical operations and instruction sequences based on that word width. The same mathematical operations and instructions may not, however, be valid on any machine having a different word width. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> For this reason, there is a need to provide a new generation of processors that has a wider word width but that may process instructions in the same manner as a shorter word-width processor to ensure compatibility. This ensures backward compatibility with earlier generation processors and still capitalizes on improvements accompanying wider word width processors. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> Conventionally, processors have provided logic to align word data between a processor and external data sources that may utilize, for example, conflicting big endian or little endian data conventions. Generally these processors include logic for receiving an aligning external data and swapping the order of bits within a received word of the same width. Processors have also provided a select few registers that may be larger than the native word width of a processor to permit, for example, double precision operations to be performed on that data. These conventional techniques do not, however, address backward compatibility or how to handle instruction processing in and/or storage of data in a memory dynamically changeable word width formats. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> Accordingly, there is a need for a new processor architecture that allows a processor to process the same instruction in more than one word width depending on the mode of an instruction to ensure backward compatibility. There is a further need for the processor utilize memory of the processor in multiple word width modes and in particular in a native word width mode and a smaller word width mode such as a byte width mode. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> According to the present invention, a processor is provided that has a native word width of multiples of a byte width. The processor may, nonetheless process, store and retrieve data in word or byte widths depending on the mode of an instruction directing the processing. Instructions may assume either a word or a byte mode. In the word mode, the instruction causes the processor to read, store and operate on word width data. In the byte mode, the instruction causes the processor to read, store and operate on byte data where the byte is specified based on upper/lower byte bits in the instruction. This architecture permits a new generation of processor having word widths of more than one byte to be backward compatible with software written for byte width processors. The architecture also is implemented in such a way that the same instruction may be processed on byte or word data depending on the mode (or generation) of the instruction. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> A method of processing byte and word instructions dynamically in the same processor, comprising includes fetching and decoding an instruction having a byte/word bit and an upper/lower byte bit. The method further includes generating an address for a memory based on the instruction. When the byte/word bit is set to a word value, method establishes a write path between upper and lower bytes of a bus and upper and lower bytes of a memory location at the generated address. When the byte/word bit is set to a byte value, the method establishes a write path between the lower bytes of a bus and the upper or lower bytes of a memory location at the generated address based on the upper/lower byte bit. The method may further include flagging an addressing error when the byte/word bit is set to a word value and the upper/lower byte bit is set to upper. </paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE FIGURES </heading>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> The above described features and advantages of the present invention will be more fully appreciated with reference to the detailed description and appended figures in which: </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> depicts a functional block diagram of an embodiment of a processor chip within which embodiments of the present invention may find application. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> depicts a functional block diagram of a data busing scheme for use in a processor, which has a microcontroller and a digital signal processing engine, within which embodiments of the present invention may find application. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> depicts a functional block diagram of the interaction between an instruction decoder, an ALU, an address generation unit and memory for addressing the memory using dynamically variable word widths. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4A</cross-reference> depicts a functional block diagram of the interaction between the address generation unit and the data memory for addressing and writing to the memory in dynamically variable word widths. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4B</cross-reference> depicts a functional block diagram of the interaction between the address generation unit and the data memory for addressing and reading from the memory in dynamically variable word widths. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> depicts a method of addressing a memory based on dynamically variable word widths.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION </heading>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> According to the present invention, a processor is provided that has a native word width of multiples of a byte width. The processor may, nonetheless process, store and retrieve data in word or byte widths depending on the mode of an instruction directing the processing. Instructions may specify either a word or a byte mode. In the word mode, the instruction causes the processor to read, store and operate on word width data. In the byte mode, the instruction causes the processor to read, store and operate on byte data where the byte is specified based on upper/lower byte bits in the instruction. This architecture permits a new generation of processor having word widths of more than one byte to be backward compatible with software written for byte width processors. The architecture also is implemented in such a way that the same instruction may be processed on byte or word data depending on the mode (or generation) of the instruction. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> In order to describe embodiments of processing instructions in word and/or byte modes, an overview of pertinent processor elements is first presented with reference to <cross-reference target="DRAWINGS">FIGS. 1 and 2</cross-reference>. The systems and methods for implementing word and/or byte mode processing are then described more particularly with reference to FIGS. <highlight><bold>3</bold></highlight>-<highlight><bold>5</bold></highlight>. </paragraph>
<paragraph id="P-0018" lvl="7"><number>&lsqb;0018&rsqb;</number> Overview of Processor Elements </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> depicts a functional block diagram of an embodiment of a processor chip within which the present invention may find application. Referring to <cross-reference target="DRAWINGS">FIG. 1, a</cross-reference> processor <highlight><bold>100</bold></highlight> is coupled to external devices/systems <highlight><bold>140</bold></highlight>. The processor <highlight><bold>100</bold></highlight> may be any type of processor including, for example, a digital signal processor (DSP), a microprocessor, a microcontroller or combinations thereof. The external devices <highlight><bold>140</bold></highlight> may be any type of systems or devices including input/output devices such as keyboards, displays, speakers, microphones, memory, or other systems which may or may not include processors. Moreover, the processor <highlight><bold>100</bold></highlight> and the external devices <highlight><bold>140</bold></highlight> may together comprise a stand alone system. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> The processor <highlight><bold>100</bold></highlight> includes a program memory <highlight><bold>105</bold></highlight>, an instruction fetch/decode unit <highlight><bold>110</bold></highlight>, instruction execution units <highlight><bold>115</bold></highlight>, data memory and registers <highlight><bold>120</bold></highlight>, peripherals <highlight><bold>125</bold></highlight>, data I/O <highlight><bold>130</bold></highlight>, and a program counter and loop control unit <highlight><bold>135</bold></highlight>. The bus <highlight><bold>150</bold></highlight>, which may include one or more common buses, communicates data between the units as shown. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> The program memory <highlight><bold>105</bold></highlight> stores software embodied in program instructions for execution by the processor <highlight><bold>100</bold></highlight>. The program memory <highlight><bold>105</bold></highlight> may comprise any type of nonvolatile memory such as a read only memory (ROM), a programmable read only memory (PROM), an electrically programmable or an electrically programmable and erasable read only memory (EPROM or EEPROM) or flash memory. In addition, the program memory <highlight><bold>105</bold></highlight> may be supplemented with external nonvolatile memory <highlight><bold>145</bold></highlight> as shown to increase the complexity of software available to the processor <highlight><bold>100</bold></highlight>. Alternatively, the program memory may be volatile memory which receives program instructions from, for example, an external non-volatile memory <highlight><bold>145</bold></highlight>. When the program memory <highlight><bold>105</bold></highlight> is nonvolatile memory, the program memory may be programmed at the time of manufacturing the processor <highlight><bold>100</bold></highlight> or prior to or during implementation of the processor <highlight><bold>100</bold></highlight> within a system. In the latter scenario, the processor <highlight><bold>100</bold></highlight> may be programmed through a process called in-line serial programming. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> The instruction fetch/decode unit <highlight><bold>110</bold></highlight> is coupled to the program memory <highlight><bold>105</bold></highlight>, the instruction execution units <highlight><bold>115</bold></highlight> and the data memory <highlight><bold>120</bold></highlight>. Coupled to the program memory <highlight><bold>105</bold></highlight> and the bus <highlight><bold>150</bold></highlight> is the program counter and loop control unit <highlight><bold>135</bold></highlight>. The instruction fetch/decode unit <highlight><bold>110</bold></highlight> fetches the instructions from the program memory <highlight><bold>105</bold></highlight> specified by the address value contained in the program counter <highlight><bold>135</bold></highlight>. The instruction fetch/decode unit <highlight><bold>110</bold></highlight> then decodes the fetched instructions and sends the decoded instructions to the appropriate execution unit <highlight><bold>115</bold></highlight>. The instruction fetch/decode unit <highlight><bold>110</bold></highlight> may also send operand information including addresses of data to the data memory <highlight><bold>120</bold></highlight> and to functional elements that access the registers. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> The program counter and loop control unit <highlight><bold>135</bold></highlight> includes a program counter register (not shown) which stores an address of the next instruction to be fetched. During normal instruction processing, the program counter register may be incremented to cause sequential instructions to be fetched. Alternatively, the program counter value may be altered by loading a new value into it via the bus <highlight><bold>150</bold></highlight>. The new value may be derived based on decoding and executing a flow control instruction such as, for example, a branch instruction. In addition, the loop control portion of the program counter and loop control unit <highlight><bold>135</bold></highlight> may be used to provide repeat instruction processing and repeat loop control as further described below. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> The instruction execution units <highlight><bold>115</bold></highlight> receive the decoded instructions from the instruction fetch/decode unit <highlight><bold>110</bold></highlight> and thereafter execute the decoded instructions. As part of this process, the execution units may retrieve one or two operands via the bus <highlight><bold>150</bold></highlight> and store the result into a register or memory location within the data memory <highlight><bold>120</bold></highlight>. The execution units may include an arithmetic logic unit (ALU) such as those typically found in a microcontroller. The execution units may also include a digital signal processing engine, a floating point processor, an integer processor or any other convenient execution unit. A preferred embodiment of the execution units and their interaction with the bus <highlight><bold>150</bold></highlight>, which may include one or more buses, is presented in more detail below with reference to <cross-reference target="DRAWINGS">FIG. 2</cross-reference>. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> The data memory and registers <highlight><bold>120</bold></highlight> are volatile memory and are used to store data used and generated by the execution units. The data memory <highlight><bold>120</bold></highlight> and program memory <highlight><bold>105</bold></highlight> are preferably separate memories for storing data and program instructions respectively. This format is a known generally as a Harvard architecture. It is noted, however, that according to the present invention, the architecture may be a Von-Neuman architecture or a modified Harvard architecture which permits the use of some program space for data space. A dotted line is shown, for example, connecting the program memory <highlight><bold>105</bold></highlight> to the bus <highlight><bold>150</bold></highlight>. This path may include logic for aligning data reads from program space such as, for example, during table reads from program space to data memory <highlight><bold>120</bold></highlight>. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> Referring again to <cross-reference target="DRAWINGS">FIG. 1, a</cross-reference> plurality of peripherals <highlight><bold>125</bold></highlight> on the processor may be coupled to the bus <highlight><bold>150</bold></highlight>. The peripherals may include, for example, analog to digital converters, timers, bus interfaces and protocols such as, for example, the controller area network (CAN) protocol or the Universal Serial Bus (USB) protocol and other peripherals. The peripherals exchange data over the bus <highlight><bold>150</bold></highlight> with the other units. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> The data I/O unit <highlight><bold>130</bold></highlight> may include transceivers and other logic for interfacing with the external devices/systems <highlight><bold>140</bold></highlight>. The data I/O unit <highlight><bold>130</bold></highlight> may further include functionality to permit in circuit serial programming of the Program memory through the data I/O unit <highlight><bold>130</bold></highlight>. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> depicts a functional block diagram of a data busing scheme for use in a processor <highlight><bold>100</bold></highlight>, such as that shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, which has an integrated microcontroller arithmetic logic unit (ALU) <highlight><bold>270</bold></highlight> and a digital signal processing (DSP) engine <highlight><bold>230</bold></highlight>. This configuration may be used to integrate DSP functionality to an existing microcontroller core. Referring to <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, the data memory <highlight><bold>120</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is implemented as two separate memories: an X-memory <highlight><bold>210</bold></highlight> and a Y-memory <highlight><bold>220</bold></highlight>, each being respectively addressable by an X-address generator <highlight><bold>250</bold></highlight> and a Y-address generator <highlight><bold>260</bold></highlight>. The X-address generator may also permit addressing the Y-memory space thus making the data space appear like a single contiguous memory space when addressed from the X address generator. The bus <highlight><bold>150</bold></highlight> may be implemented as two buses, one for each of the X and Y memory, to permit simultaneous fetching of data from the X and Y memories. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> The W registers <highlight><bold>240</bold></highlight> are general purpose address and/or data registers. The DSP engine <highlight><bold>230</bold></highlight> is coupled to both the X and Y memory buses and to the W registers <highlight><bold>240</bold></highlight>. The DSP engine <highlight><bold>230</bold></highlight> may simultaneously fetch data from each the X and Y memory, execute instructions which operate on the simultaneously fetched data and write the result to an accumulator (not shown) and write a prior result to X or Y memory or to the W registers <highlight><bold>240</bold></highlight> within a single processor cycle. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> In one embodiment, the ALU <highlight><bold>270</bold></highlight> may be coupled only to the X memory bus and may only fetch data from the X bus. However, the X and Y memories <highlight><bold>210</bold></highlight> and <highlight><bold>220</bold></highlight> maybe addressed as a single memory space by the X address generator in order to make the data memory segregation transparent to the ALU <highlight><bold>270</bold></highlight>. The memory locations within the X and Y memories may be addressed by values stored in the W registers <highlight><bold>240</bold></highlight>. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> Any processor clocking scheme may be implemented for fetching and executing instructions. A specific example follows, however, to illustrate an embodiment of the present invention. Each instruction cycle is comprised of four Q clock cycles Q1-Q4. The four phase Q cycles provide timing signals to coordinate the decode, read, process data and write data portions of each instruction cycle. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> According to one embodiment of the processor <highlight><bold>100</bold></highlight>, the processor <highlight><bold>100</bold></highlight> concurrently performs two operations&mdash;it fetches the next instruction and executes the present instruction. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> Accordingly, the two processes occur simultaneously. The following sequence of events may comprise, for example, the fetch instruction cycle:  
<table-cwu id="TABLE-US-00001">
<number>1</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="42PT" align="right"/>
<colspec colname="2" colwidth="175PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>Q1:</entry>
<entry>Fetch Instruction</entry>
</row>
<row>
<entry>Q2:</entry>
<entry>Fetch Instruction</entry>
</row>
<row>
<entry>Q3:</entry>
<entry>Fetch Instruction</entry>
</row>
<row>
<entry>Q4:</entry>
<entry>Latch Instruction into prefetch register, Increment PC</entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> The following sequence of events may comprise, for example, the execute instruction cycle for a single operand instruction:  
<table-cwu id="TABLE-US-00002">
<number>2</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="right"/>
<colspec colname="2" colwidth="196PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>Q1:</entry>
<entry>latch instruction into IR, decode and determine addresses of</entry>
</row>
<row>
<entry></entry>
<entry>operand data</entry>
</row>
<row>
<entry>Q2:</entry>
<entry>fetch operand</entry>
</row>
<row>
<entry>Q3:</entry>
<entry>execute function specified by instruction and calculate destination</entry>
</row>
<row>
<entry></entry>
<entry>address for data</entry>
</row>
<row>
<entry>Q4:</entry>
<entry>write result to destination</entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> The following sequence of events may comprise, for example, the execute instruction cycle for a dual operand instruction using a data pre-fetch mechanism. These instructions pre-fetch the dual operands simultaneously from the X and Y data memories and store them into registers specified in the instruction. They simultaneously allow instruction execution on the operands fetched during the previous cycle.  
<table-cwu id="TABLE-US-00003">
<number>3</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="right"/>
<colspec colname="2" colwidth="196PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>Q1:</entry>
<entry>latch instruction into IR, decode and determine addresses of</entry>
</row>
<row>
<entry></entry>
<entry>operand data</entry>
</row>
<row>
<entry>Q2:</entry>
<entry>pre-fetch operands into specified registers, execute operation in</entry>
</row>
<row>
<entry></entry>
<entry>instruction</entry>
</row>
<row>
<entry>Q3:</entry>
<entry>execute operation in instruction, calculate destination address for</entry>
</row>
<row>
<entry></entry>
<entry>data</entry>
</row>
<row>
<entry>Q4:</entry>
<entry>complete execution, write result to destination</entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0036" lvl="7"><number>&lsqb;0036&rsqb;</number> Byte/Word Addressing and Processing </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> depicts a functional block diagram of a processor for processing bit operations according to the present invention. Referring to <cross-reference target="DRAWINGS">FIG. 3</cross-reference>, the processor includes a program memory <highlight><bold>300</bold></highlight> for storing instructions including instructions that operate in both word and byte modes. The processor also includes a program counter <highlight><bold>305</bold></highlight> which stores a pointer to the next program instruction that is to be fetched. The processor further includes an instruction register <highlight><bold>310</bold></highlight> for storing an instruction for execution that has been fetched from the program memory <highlight><bold>300</bold></highlight>. The processor may further include pre-fetch registers or an instruction pipeline (not shown) that may be used for fetching and storing a series of upcoming instructions for decoding and execution. The processor also includes an instruction decoder <highlight><bold>315</bold></highlight>, an arithmetic logic unit (ALU) <highlight><bold>320</bold></highlight>, registers <highlight><bold>340</bold></highlight>, a status register <highlight><bold>350</bold></highlight> and a data memory <highlight><bold>330</bold></highlight>. The data memory <highlight><bold>330</bold></highlight> is addressed by an address generation unit <highlight><bold>325</bold></highlight>. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> The instruction decoder <highlight><bold>315</bold></highlight> decodes instructions that are stored in the instruction register <highlight><bold>310</bold></highlight>. Based on the bits in the instruction, the instruction decoder <highlight><bold>315</bold></highlight> selectively activates logic within the ALU <highlight><bold>320</bold></highlight> for fetching operands, performing the operation specified by the instruction on the operands and returning the result to the appropriate memory location. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> The ALU <highlight><bold>320</bold></highlight> includes operand latches <highlight><bold>345</bold></highlight> that receive operands from the registers <highlight><bold>340</bold></highlight> and/or a data memory <highlight><bold>330</bold></highlight> depending on the addressing mode used in the instruction. For example in one addressing mode, the source and/or destination operand data may be stored in the registers <highlight><bold>340</bold></highlight>. In another addressing mode, the source and/or destination operand data may be stored in the data memory <highlight><bold>355</bold></highlight>. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> The ALU <highlight><bold>320</bold></highlight> includes ALU logic <highlight><bold>335</bold></highlight>, each of which receives inputs from the operand latches <highlight><bold>345</bold></highlight> and produces outputs to the bus <highlight><bold>390</bold></highlight> and the status register <highlight><bold>350</bold></highlight>. The ALU logic <highlight><bold>350</bold></highlight> executes arithmetic and logic operations according to instructions decoded by the instruction decoder on operands fetched from the registers <highlight><bold>340</bold></highlight> and/or from the data memory <highlight><bold>330</bold></highlight>. In general, the ALU <highlight><bold>320</bold></highlight> processes data in byte or word widths. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> The instruction decoder <highlight><bold>315</bold></highlight> decodes particular instructions and sends control signals to the ALU <highlight><bold>320</bold></highlight>, the address generation unit <highlight><bold>325</bold></highlight> and directs the fetching of the correct operands specified in the instruction. The instruction decoder <highlight><bold>315</bold></highlight> also, based on the instruction, sends control signals directing the activation of the correct portion of the ALU logic <highlight><bold>335</bold></highlight> to carry out the operation specified by the instruction on the correct operands, directing the result to be written to the correct destination and directing the status register to store pertinent data when present, such as a status flag indicating a zero result. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> The data memory <highlight><bold>330</bold></highlight> is coupled to the address generation unit and the bus <highlight><bold>390</bold></highlight>. The address unit provides addresses to the data memory for retrieving operands and other data that are stored in the memory during processor read cycles and for storing operands and other data into the data memory during processor write cycles. Data read from the memory and stored into the memory is communicated to other units of the processor via the bus <highlight><bold>390</bold></highlight>, which is coupled to, among other units, the data memory <highlight><bold>330</bold></highlight>, the registers <highlight><bold>340</bold></highlight> and the ALU <highlight><bold>320</bold></highlight>. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> The data memory may be any convenient size based on the processing power of the processor and the target applications. As an illustrative example, the data memory <highlight><bold>330</bold></highlight> may be configured as a 64 K-bit memory array <highlight><bold>360</bold></highlight> having a 4 K bit&times;16 bit arrangement. The 16 bit wide memory accordingly has a native word width of two bytes, lower byte <highlight><bold>370</bold></highlight> and upper byte <highlight><bold>375</bold></highlight>. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> The data memory also includes a data memory multiplexer <highlight><bold>365</bold></highlight> which directs data from the bus <highlight><bold>390</bold></highlight> into the appropriate upper byte <highlight><bold>375</bold></highlight> and/or lower byte <highlight><bold>370</bold></highlight> during a write cycle depending on whether the instruction specifies a byte or word mode of operation. The data memory multiplexer <highlight><bold>365</bold></highlight> directs data to the bus <highlight><bold>390</bold></highlight> from the appropriate upper byte <highlight><bold>375</bold></highlight> and/or lower byte <highlight><bold>370</bold></highlight> during a read cycle depending on whether the instruction specifies a byte or word mode of operation. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> In order to implement byte or word mode of operation, one or more instructions within the instruction set of the processor may specify the byte or word mode of operation. This may be encoded within the instruction in the following manner with two bits: </paragraph>
<paragraph id="P-0046" lvl="2"><number>&lsqb;0046&rsqb;</number> word/byte bit: 0 for word, 1 for byte mode (or vice-versa) </paragraph>
<paragraph id="P-0047" lvl="2"><number>&lsqb;0047&rsqb;</number> upper/lower byte bit: 0 for lower byte and word operations, 1 for upper byte. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4A</cross-reference> depicts an interaction between the address generation unit <highlight><bold>325</bold></highlight>, the data memory array <highlight><bold>360</bold></highlight> and the data memory multiplexer <highlight><bold>365</bold></highlight> during a write cycle. The interaction depicts an illustrative embodiment that may be used to direct the storage of individual bytes or words into the upper and lower bytes of the data memory array <highlight><bold>360</bold></highlight>. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 4</cross-reference>A, the address generation unit may receive a pointer from the registers <highlight><bold>340</bold></highlight> specifying an individual memory word location within the memory array <highlight><bold>360</bold></highlight>. The address generation unit decodes the pointer to determine the individual memory word location. The address generation unit may also receive a write clock signal which gates the address decoding such that the individual memory word location is only activated (by raising a word line voltage for example) during memory write cycles. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> The data memory multiplexer <highlight><bold>365</bold></highlight> receives the write clock signal and the byte/word bit value as well as the upper/lower byte bit value. The latter two values may be received directly from the instruction decoder <highlight><bold>315</bold></highlight> or from the instruction decoder <highlight><bold>315</bold></highlight> by way of the address generation unit <highlight><bold>325</bold></highlight>. The data memory multiplexer may be implemented in many different ways to steer data to and from the bus <highlight><bold>390</bold></highlight> and the appropriate upper and/or lower bytes of the memory array <highlight><bold>360</bold></highlight>. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> The status register stores flag values indicating various conditions within the processor and the ALU result. During a byte operation, the flags are derived based on the lower eight bits of the result generated by the ALU for an instruction, rather than the entire word result. This is because the upper 8 bits of the result for a byte operation may not contain meaningful data. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> Referring to the embodiment depicted in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>A, the multiplexer <highlight><bold>365</bold></highlight> includes two logic trees <highlight><bold>400</bold></highlight> and <highlight><bold>405</bold></highlight> for generating control signals to direct the writing of bytes from the bus into the appropriate byte locations in the memory array <highlight><bold>360</bold></highlight>. The logic trees <highlight><bold>400</bold></highlight> and <highlight><bold>405</bold></highlight> generate the same signal during a write cycle when the byte/word bit is set high indicating a word operation. The signal generated is low and is fed to the tri state buffers <highlight><bold>415</bold></highlight> and <highlight><bold>430</bold></highlight> thus activating the tri state buffers. With the tri state buffers <highlight><bold>415</bold></highlight> and <highlight><bold>430</bold></highlight> active, the value from the LSB of the bus <highlight><bold>390</bold></highlight> is written into the LSB <highlight><bold>370</bold></highlight> of the memory array <highlight><bold>360</bold></highlight> through gate <highlight><bold>425</bold></highlight> and the tri-state buffer. The value from the MSB of the bus <highlight><bold>390</bold></highlight> is selected by the multiplexer <highlight><bold>435</bold></highlight> based on the zero value from the logic tree <highlight><bold>405</bold></highlight> fed to its control input. The MSB value is in turn written into the MSB <highlight><bold>375</bold></highlight> of the memory array <highlight><bold>360</bold></highlight> through the gate <highlight><bold>420</bold></highlight> and the tri-state buffer <highlight><bold>415</bold></highlight>. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> The logic trees <highlight><bold>400</bold></highlight> and <highlight><bold>405</bold></highlight> generate opposing signals when the byte/word bit is set low indicating a byte operation. When the upper/lower bit is set to a zero, the logic tree <highlight><bold>400</bold></highlight> generates a high output signal which disables the tri-state buffer <highlight><bold>415</bold></highlight>. Thus, data from the bus is not written into the MSB <highlight><bold>375</bold></highlight> of the memory. By contrast, the logic tree <highlight><bold>405</bold></highlight> generates a low output signal thus activating the tri-state buffer <highlight><bold>430</bold></highlight> causing data to be written from the LSB of the bus <highlight><bold>390</bold></highlight> into the LSB of the memory array <highlight><bold>360</bold></highlight>. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> When the word/byte bit is set to a zero and the upper/lower bit is set to a one, the logic tree <highlight><bold>405</bold></highlight> generates a high output signal which disables the tri-state buffer <highlight><bold>430</bold></highlight> and sets the control input of the multiplexer to select the LSB of the bus <highlight><bold>390</bold></highlight>. Thus, data from the bus is not written into the LSB <highlight><bold>375</bold></highlight> of the memory. By contrast, the logic tree <highlight><bold>405</bold></highlight> generates a low output signal thus activating the tri-state buffer <highlight><bold>415</bold></highlight>. The values from the trees <highlight><bold>400</bold></highlight> and <highlight><bold>405</bold></highlight> cause the multiplexer <highlight><bold>435</bold></highlight> to select the LSB from the bus <highlight><bold>390</bold></highlight> and write the data into the LSB <highlight><bold>375</bold></highlight> of the memory array <highlight><bold>360</bold></highlight>. This arrangement provides for proper operation and alignment of byte and word writes to the memory array <highlight><bold>360</bold></highlight>. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4B</cross-reference> depicts an interaction between the address generation unit <highlight><bold>325</bold></highlight>, the data memory array <highlight><bold>360</bold></highlight> and the data memory multiplexer <highlight><bold>365</bold></highlight> during a read cycle. The illustrative embodiment may be used to direct the retrieval of individual bytes or words into the upper and lower bytes of the data memory array <highlight><bold>360</bold></highlight>. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 4</cross-reference>B, the address generation unit may receive a pointer from the registers <highlight><bold>340</bold></highlight> specifying an individual memory word location within the memory array <highlight><bold>360</bold></highlight>. The address generation unit decodes the pointer to determine the individual memory word location. The address generation unit may also receive a read clock signal which gates the address decoding such that the individual memory word location is only activated (by raising a word line voltage for example) during memory read cycles. </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> The data memory multiplexer <highlight><bold>365</bold></highlight> receives the read clock signal and the byte/word bit value as well as the upper/lower byte bit value. The latter two values may be received directly from the instruction decoder <highlight><bold>315</bold></highlight> or from the instruction decoder <highlight><bold>315</bold></highlight> by way of the address generation unit <highlight><bold>325</bold></highlight>. The multiplexer <highlight><bold>365</bold></highlight> includes a logic trees <highlight><bold>500</bold></highlight> for generating a control signal to direct the reading of bytes from the memory array <highlight><bold>360</bold></highlight> into the appropriate byte positions on the bus <highlight><bold>390</bold></highlight>. The logic tree <highlight><bold>500</bold></highlight> generates a signal that is set low during a write cycle when the byte/word bit is set high indicating a word operation. An inverted version of the read signal is generated during a read cycle and its low value is fed to the tri state buffers <highlight><bold>530</bold></highlight> and <highlight><bold>540</bold></highlight> thus activating them. With the tri state buffers <highlight><bold>530</bold></highlight> and <highlight><bold>540</bold></highlight> active, the value from the MSB of the memory address activated by the address generation unit <highlight><bold>325</bold></highlight> is read onto the MSB of the bus <highlight><bold>390</bold></highlight> through gate <highlight><bold>535</bold></highlight> and the tri-state buffer <highlight><bold>540</bold></highlight>. The value from the LSB <highlight><bold>370</bold></highlight> of the memory array <highlight><bold>360</bold></highlight> is selected by the multiplexer <highlight><bold>520</bold></highlight> based on the zero value from the logic tree <highlight><bold>500</bold></highlight> fed to its control input. The selected LSB value is in turn written onto the LSB of the bus <highlight><bold>390</bold></highlight> through the gate <highlight><bold>525</bold></highlight> and the tri-state buffer <highlight><bold>530</bold></highlight>. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> When the byte/word bit is set low indicating a byte operation, the signal generated by the logic tree <highlight><bold>500</bold></highlight> is set equal to the value of the upper/lower byte bit. Accordingly, when the upper/lower bit is set to a zero, the logic tree <highlight><bold>500</bold></highlight> generates a low output signal which sets the control input of the multiplexer to select the LSB <highlight><bold>370</bold></highlight> of the memory array <highlight><bold>360</bold></highlight>. Thus, data from the LSB <highlight><bold>370</bold></highlight> is selected and read onto the LSB of the bus <highlight><bold>390</bold></highlight>. By contrast, the logic tree <highlight><bold>500</bold></highlight> generates a high output signal when the upper/lower byte bit is high causing the multiplexer <highlight><bold>520</bold></highlight> to select the MSB <highlight><bold>375</bold></highlight> from the memory array <highlight><bold>360</bold></highlight> and write the data into the LSB of the bus <highlight><bold>390</bold></highlight>. This arrangement provides for proper operation and alignment of byte and word reads from the memory array <highlight><bold>360</bold></highlight>. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> depicts a method of addressing a memory based on dynamically variable word widths. Referring to <cross-reference target="DRAWINGS">FIG. 5</cross-reference>, in step <highlight><bold>600</bold></highlight>, the processor fetches an instruction. Then in step <highlight><bold>605</bold></highlight>, the instruction decoder decodes the instruction. In step <highlight><bold>610</bold></highlight>, the instruction decoder sends control signals to the address generation unit based on the byte/word bit and the upper/lower byte bits within the instruction. These control signals determine whether the memory will be accessed and the instruction will be processed as a word or a particular byte. In step <highlight><bold>615</bold></highlight>, the address generation unit retrieves pointers to data memory. In general, the pointers are retrieved from a registers specified in the instruction under control of the instruction decoder. </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> In step <highlight><bold>620</bold></highlight>, logic determines whether the byte/word bit value specifies a word or a byte. When the byte/word bit value specifies a word, then step <highlight><bold>625</bold></highlight> begins. When the byte/word bit value specifies a byte, then step <highlight><bold>630</bold></highlight> begins. In step <highlight><bold>625</bold></highlight>, logic checks to determine whether the upper/lower byte bit is set to upper. If the upper/lower byte bit is set to upper, then step <highlight><bold>635</bold></highlight> begins and an address error trap flag is set. Subsequently, the processor may cause a corresponding address trap interrupt service routine to be executed. Alternatively, if the upper/lower byte bit is set to lower, then step <highlight><bold>640</bold></highlight> begins. Step <highlight><bold>625</bold></highlight> may be implemented by checking for a condition where the byte/word bit is set to word and the upper/lower byte bit is set to upper. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> In step <highlight><bold>640</bold></highlight>, the processor performs a read or write on a full word from/to the memory and/or bus. In step <highlight><bold>645</bold></highlight>, any values read out of the memory in step <highlight><bold>640</bold></highlight> are written to a full register width. Accordingly, words are written into and out of the memory. </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> Step <highlight><bold>630</bold></highlight> begins if the byte/word bit value is set to byte. In step <highlight><bold>630</bold></highlight>, the processor checks to see if the upper/lower byte bit is set to upper or lower. When it is set to upper, step <highlight><bold>650</bold></highlight> begins and the processor either writes the lower byte from the bus to the upper byte in memory or reads the upper byte from memory onto the lower byte on the bus. </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> If in step <highlight><bold>630</bold></highlight> the processor determines that the upper/lower byte bit is set to lower, then step <highlight><bold>655</bold></highlight> begins. In step <highlight><bold>655</bold></highlight>, the processor either writes the lower byte from the bus to the lower byte in memory or reads the lower byte from memory onto the lower byte on the bus. </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> After steps <highlight><bold>650</bold></highlight> and <highlight><bold>655</bold></highlight>, step <highlight><bold>660</bold></highlight> begins and the processor reads/writes to the lower byte of the registers. In this manner, for byte operations, reads and writes are conducted in a manner which preserves the alignment of data within the memory, on the bus and within the registers. </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> While specific embodiments of the present invention have been illustrated and described, it will be understood by those having ordinary skill in the art that changes may be made to those embodiments without departing from the spirit and scope of the invention. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method of processing byte and word instruction operands dynamically in the same processor, comprising: 
<claim-text>fetching and decoding an instruction having a byte/word bit and an upper/lower byte bit; </claim-text>
<claim-text>generating an address for a memory based on the instruction; </claim-text>
<claim-text>establishing a write path between upper and lower bytes of a bus and upper and lower bytes of a memory location at the generated address when the byte/word bit is set to a word value and establishing a write path between the lower bytes of a bus and the upper or lower bytes of a memory location at the generated address based on the upper/lower byte bit when the byte/word bit is set to a byte value. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the address is generated based on a pointer value stored in a register. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising flagging an addressing error when the byte/word bit is set to a word value and the upper/lower byte bit is set to upper. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. A method of processing byte and word instruction operands dynamically in the same processor, comprising: 
<claim-text>fetching and decoding an instruction having a byte/word bit and an upper/lower byte bit; </claim-text>
<claim-text>generating an address for a memory based on the instruction; </claim-text>
<claim-text>establishing a read path between upper and lower bytes of a bus and upper and lower bytes of a memory location at the generated address when the byte/word bit is set to a word value and establishing a read path between the lower bytes of a bus and the upper or lower bytes of a memory location at the generated address based on the upper/lower byte bit when the byte/word bit is set to a byte value. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00004">claim 4</dependent-claim-reference>, wherein the address is generated based on a pointer value stored in a register. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00004">claim 4</dependent-claim-reference>, further comprising flagging an addressing error when the byte/word bit is set to a word value and the upper/lower byte bit is set to upper.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>2</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005254A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005254A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005254A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005254A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005254A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005254A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030005254A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
