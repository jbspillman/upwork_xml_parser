<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030003432A1-20030102-D00000.TIF SYSTEM "US20030003432A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030003432A1-20030102-D00001.TIF SYSTEM "US20030003432A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030003432A1-20030102-D00002.TIF SYSTEM "US20030003432A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030003432A1-20030102-D00003.TIF SYSTEM "US20030003432A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030003432A1-20030102-D00004.TIF SYSTEM "US20030003432A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030003432A1-20030102-D00005.TIF SYSTEM "US20030003432A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030003432A1-20030102-D00006.TIF SYSTEM "US20030003432A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030003432A1-20030102-D00007.TIF SYSTEM "US20030003432A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030003432A1-20030102-D00008.TIF SYSTEM "US20030003432A1-20030102-D00008.TIF" NDATA TIF>
<!ENTITY US20030003432A1-20030102-D00009.TIF SYSTEM "US20030003432A1-20030102-D00009.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030003432</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09881791</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010614</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G09B007/00</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>434</class>
<subclass>322000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>System and method for automated assertion acquisition in a Java compatibility testing environment</title-of-invention>
</technical-information>
<continuity-data>
<non-provisional-of-provisional>
<document-id>
<doc-number>60291670</doc-number>
<document-date>20010516</document-date>
<country-code>US</country-code>
</document-id>
</non-provisional-of-provisional>
<non-provisional-of-provisional>
<document-id>
<doc-number>60292185</doc-number>
<document-date>20010518</document-date>
<country-code>US</country-code>
</document-id>
</non-provisional-of-provisional>
</continuity-data>
<inventors>
<first-named-inventor>
<name>
<given-name>Arzhan</given-name>
<middle-name>I</middle-name>
<family-name>Kinzhalin</family-name>
</name>
<residence>
<residence-non-us>
<city>St. Petersburg</city>
<country-code>RU</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Andrey</given-name>
<middle-name>Y.</middle-name>
<family-name>Chernyshev</family-name>
</name>
<residence>
<residence-non-us>
<city>St. Petersburg</city>
<country-code>RU</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Mikhail</given-name>
<family-name>Gorshenev</family-name>
</name>
<residence>
<residence-us>
<city>Mountain View</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Debra</given-name>
<family-name>Dooley</family-name>
</name>
<residence>
<residence-us>
<city>San Jose</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>MARTINE &amp; PENILLA, LLP</name-1>
<name-2></name-2>
<address>
<address-1>710 LAKEWAY DRIVE</address-1>
<address-2>SUITE 170</address-2>
<city>SUNNYVALE</city>
<state>CA</state>
<postalcode>94085</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">An invention is disclosed for automated acquisition of assertions in a specification of a computer program is disclosed. An input specification is received, wherein the input specification comprises a plurality of sentences. Then, a sentence is obtained from the plurality of sentences, and a determination is made as to whether the obtained sentence is a testable assertion. Next, the obtained sentence is marked as testable when the obtained sentence is a testable assertion. Some aspects of the present invention can identify a context within the specification, and obtain the sentence from the plurality of sentences by parsing the context. Moreover, the marked obtained sentence can be added to an assertion result set. Generally, the context is a set of circumstances related to the obtained sentence. Further, each assertion can comprise one, two, or more sentences of the specification. </paragraph>
</subdoc-abstract>
<subdoc-description>
<cross-reference-to-related-applications>
<heading lvl="1">CROSS REFERENCE TO RELATED APPLICATIONS </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> This application claims the benefit of (1) U.S. Provisional Patent Application having Ser. No. 60/291,670, filed on May 16, 2001, entitled &ldquo;System and Method for Compatibility Testing in a Java Environment,&rdquo; and (2) U.S. Provisional Patent Application having Ser. No. 60/292,185, filed on May 18, 2001, entitled &ldquo;System and Method for Combinatorial Test Generation in a Compatibility Testing Environment.&rdquo;Each of these provisional patent applications is incorporated herein by reference. </paragraph>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> This application is also related to U.S. Patent Application No. ______ (Attorney Docket No. SUNMP013), filed Jun. 14, 2001, and entitled &ldquo;System and Method for Specification Tracking in a Java Compatibility Testing Environment&rdquo;, which is incorporated herein by reference. </paragraph>
</cross-reference-to-related-applications>
<summary-of-invention>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> 1. Field of the Invention </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> The present invention relates generally to Java testing, and more particularly to automated Java specification tracking in a Java compatibility-testing environment. 2. Description of the Related Art </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> Currently, Java environments can be categorized into various Java technologies. A Java technology is defined as a Java specification and its reference implementation. Examples of Java technologies are Java 2 Standard Edition (J2SE), Java 2 Enterprise Edition (J2EE), and Mobile Information Device Profile (MIDP). As with most other types of Java software, a new Java technology should be tested to assure consistency across multiple platforms. This testing is generally performed using compatibility testing. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> Compatibility testing refers to the methods used to test an implementation of a Java technology specification in order to assure consistency across multiple hardware platforms, operating systems, and other implementations of the same Java technology specification. When this assurance is accomplished by means of a formal process, application developers can then be confident that an application will run in a consistent manner across all tested implementations of the same Java technology specification. This consistent specification-based behavior is a primary function of compatibility testing. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> Compatibility testing differs from traditional product testing in a number of ways. Unlike product testing, compatibility testing is not primarily concerned with robustness, performance, or ease of use. The primary purpose of Java compatibility testing is to determine whether an implementation of a technology is compliant with the specification of that technology. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> Compatibility test development for a given feature relies on a complete specification and reference implementation for that feature. Compatibility testing is a means of ensuring correctness, completeness, and consistency across all implementations of a technology specification that are developed. The primary goal of compatibility testing is to provide the assurance that an application will run in a consistent manner across all tested implementations of a technology. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> To determine if the implementation of a particular Java technology is compliant with the specification for the particular Java technology, technology compatibility kits (TCK) may be used. A TCK is a suite of tests, tools, and documentation that allows an implementor of a Java technology specification to determine if the implementation is compliant with the specification. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> A TCK typically includes a Test Harness, defined as the applications and tools that are used for test execution and test suite management, and a TCK Test Suite, which is the composite of the actual test cases in a TCK that are executed to test an implementation. A TCK can also include documentation that includes the specific TCK usage procedures, and the compatibility testing requirements that apply to the related technology release (usually in the form of a TCK user&apos;s guide). Also, a description of the TCK appeals process can be included, as well as an audit process, which is used to better ensure the integrity of a consistent self-testing compatibility program. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> As mentioned above, a TCK usually includes a TCK test suite, which is a set of tests designed to verify that an implementation of a Java technology complies with the appropriate specification. Each test in a TCK test suite is composed of one or more test cases that are designated by a test description. A test case is the source code and accompanying information designed to exercise one aspect of a specified assertion. Accompanying information may include test documentation, auxiliary data files and other resources used by the source code. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> In order to be complete, a test suite includes a test case to verify each and every testable assertion that is made by the API specification. Test developers must review the actual specification document and generate at least one test case for each testable assertion that appears in the API specification. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> Unfortunately, the conventional method for determining assertions for a particular specification is a laborious process involving a manual inspection of the specification. Prior to the test design stage during conventional testing, the test developer must scan through the specification and split the entire text into logical statements. Each logical statement then needs to be examined by type to indicate if it is a testable assertion. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> Of course, the process of manually inspecting the specification is a time consuming process prone to errors. Moreover, since one of the most important issues of the TCK development process is to keep TCK tests synchronized with their technology&apos;s current API specification, the manual inspection process is exacerbated whenever the specification changes. Upon any specification change, the corresponding TCK tests must be revised and corrected if their functionality has been affected by the change. To accomplish this, the specification must be re-inspected to confirm the current assertions and determine if particular assertions should be removed or additional assertions should be added. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> In view of the foregoing, there is a need for methods for tracking the specification to determine assertions. Preferably, the methods should be automated, and should provide tracking between different versions of a specification to identify TCK test that are affected by each change assertion. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> Broadly speaking, the present invention fills these needs by providing a system for tracking a specification that automatically obtains assertions within the specification. The embodiments of the present invention further provide testing of obtained assertions to determine if the assertions are valid assertions. In one embodiment, a method for automated acquisition of assertions in a specification of a computer program is disclosed. An input specification is received, wherein the input specification comprises a plurality of sentences. Then, a sentence is obtained from the plurality of sentences, and a determination is made as to whether the obtained sentence is a testable assertion. Next, the obtained sentence is marked as testable when the obtained sentence is a testable assertion. Some aspects of the present invention can identify a context within the specification, and obtain the sentence from the plurality of sentences by parsing the context. Moreover, the marked obtained sentence can be added to an assertion result set. Generally, the context is a set of circumstances related to the obtained sentence. Further, each assertion can comprise one, two, or more sentences of the specification. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> In another embodiment, a computer program for automatically obtaining assertions from a specification for a computer program is disclosed. The computer program includes a code segment that receives an input specification for a computer program, and a code segment that identifies a context within the input specification. Further included is a code segment that parses the identified context to obtain assertions, and a code segment that determines whether the obtained assertions are testable statements. In addition, a code segment that adds the obtained assertions to an assertion result set is included. In this manner, the assertion result set can be used to facilitate testing of the specification. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> A computer program for automated acquisition of assertions in a specification of a computer program is disclosed in a yet a further embodiment of the present invention. The computer program includes a code segment that receives an input specification, wherein the input specification comprises a plurality of sentences, and a code segment that obtains a sentence from the plurality of sentences. Further included is a code segment that determines whether the obtained sentence is a testable assertion, and a code segment that marks the obtained sentence as testable when the obtained sentence is a testable assertion. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> Advantageously, the embodiments of the present invention allow a test developer to perform testing routines in a semi-automated way that improves performance, reduces human error, and allows the test developer to spend more time on test development itself. Moreover, the embodiments of the present invention produce various reports on how TCK covers the corresponding specification. These reports are very useful for project management since they allow the test developer to analyze TCK completeness and plan future TCK works. Other aspects and advantages of the invention will become apparent from the following detailed description, taken in conjunction with the accompanying drawings, illustrating by way of example the principles of the invention. </paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> The invention, together with further advantages thereof, may best be understood by reference to the following description taken in conjunction with the accompanying drawings in which: </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is diagram showing a specification tracking methodology, in accordance with an embodiment of the present invention; </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a use case diagram showing a specification tracking system, in accordance with an embodiment of the present invention; </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> shows dispatcher process for processing user commands, in accordance with an embodiment of the present invention; </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a block diagram showing task entry points, in accordance with an embodiment of the present invention; </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5A</cross-reference> is flowchart showing a process for obtaining specification assertions, in accordance with an embodiment of the present invention; </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5B</cross-reference> is flowchart showing a process for obtaining specification assertions and validating the assertions, in accordance with an embodiment of the present invention; </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is a class diagram showing a Getassert framework class, in accordance with an embodiment of the present invention; </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> is a flowchart showing a process <highlight><bold>204</bold></highlight> for reporting TCK coverage of a specification, in accordance with an embodiment of the present invention; and </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> is a diagram showing reporting TCK information class, in accordance with an embodiment of the present invention. </paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS </heading>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> An invention is disclosed for automated acquisition of assertions in a specification of a computer program. In the following description, numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent, however, to one skilled in the art that the present invention may be practiced without some or all of these specific details. In other instances, well known process steps have not been described in detail in order not to unnecessarily obscure the present invention. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> The embodiments of the present invention allow quick collection of information on a specification, the corresponding test suite, and the relationship between the specification and the test suite. Thus, the embodiments of the present invention simplify the TCK Test Development process. In particular, the embodiments of the present invention automatically identify assertions, track changes between specification versions, and identify TCK tests that are affected by each changed assertion. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> As mentioned previously, test developers had to perform these routines manually. Advantageously, the embodiments of the present invention allow a test developer to perform these routines in a semi-automated way that improves performance, reduces human error, and allows the test developer to spend more time on test development itself. Moreover, as described in greater detail subsequently, the embodiments of the present invention produce various reports on how TCK covers the corresponding specification. These reports are very useful for project management since they allow the test developer to analyze TCK completeness and plan future TCK works. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> The specification tracking of the embodiments of the present invention bind a specification assertion to the test that tests that specification assertion. After that binding is done a plurality of benefits is gained. First, upon each change in the specification assertion, the corresponding set of TCK tests can be tracked. This helps the test developer to identify a set of the tests that should be revised as soon as new specification version is available. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> Second, the embodiments of the present invention provide different types of reports regarding how the TCK covers the corresponding specification. These reports include coverage information, which defines how many specification assertions are tested by the testsuite, and a list of tested and untested assertions. Third, the embodiments of the present invention keep binding information, which is the correspondence between a test case and an assertion. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is diagram showing a specification tracking methodology <highlight><bold>100</bold></highlight>, in accordance with an embodiment of the present invention. The specification tracking methodology <highlight><bold>100</bold></highlight> shows a specification <highlight><bold>102</bold></highlight>, a specification tracking system <highlight><bold>104</bold></highlight>, an assertion list <highlight><bold>106</bold></highlight>, and a test generator <highlight><bold>108</bold></highlight>. The specification <highlight><bold>102</bold></highlight> can be any specification, such as a Javadoc specification for a Java technology API. Preferably, the specification <highlight><bold>102</bold></highlight> includes a plurality of assertions that can be tested. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> In operation, the specification <highlight><bold>102</bold></highlight> is provided to the specification tracking system <highlight><bold>104</bold></highlight> of the embodiments of the present invention. Once received, the specification tracking system <highlight><bold>104</bold></highlight> processes the specification to generate an assertion list <highlight><bold>106</bold></highlight>. The assertion list <highlight><bold>106</bold></highlight> can then be used to create test cases manually, or automatically using a test generator <highlight><bold>108</bold></highlight>. In addition, the specification tracking system <highlight><bold>104</bold></highlight> generates reports providing information on how the TCK tests cover the specification, as described in greater detail subsequently. These reports can include information on the percentage of the specification assertions covered by the TCK tests, a list of assertions tested by the TCK tests, and a list of assertions not tested by the TCK tests. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> In one embodiment, the specification tracking system <highlight><bold>104</bold></highlight> is generated using the Java language and executed on a Java virtual machine. A Java virtual machine is used as an interpreter to provide portability to Java applications. In general, developers design Java applications as hardware independent software modules, which are executed Java virtual machines. The Java virtual machine layer is developed to operate in conjunction with the native operating system of the particular hardware on which the mobile multimedia framework system is to run. In this manner, Java applications can be ported from one hardware device to another without requiring updating of the application code. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> Unlike most programming languages, in which a program is compiled into machine-dependent, executable program code, Java classes are compiled into machine independent byte-code class files which are executed by a machine-dependent virtual machine. The virtual machine provides a level of abstraction between the machine independence of the byte-code classes and the machine-dependent instruction set of the underlying computer hardware. A class loader is responsible for loading the byte-code class files as needed, and an interpreter or just-in-time compiler provides for the transformation of byte-codes into machine code. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> More specifically, Java is a programming language designed to generate applications that can run on all hardware platforms, small, medium and large, without modification. Developed by Sun, Java has been promoted and geared heavily for the Web, both for public Web sites and intranets. Generally, Java programs can be called from within HTML documents or launched standalone. When a Java program runs from a Web page, it is called a &ldquo;Java applet&rdquo;, and when run on a Web server, the application is called a &ldquo;servlet&rdquo;. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> Java is an interpreted language. The source code of a Java program is compiled into an intermediate language called &ldquo;bytecode&rdquo;. The bytecode is then converted (interpreted) into machine code at runtime. Upon finding a Java applet, the Web browser invokes a Java interpreter (Java Virtual Machine), which translates the bytecode into machine code and runs it. Thus, Java programs are not dependent on any specific hardware and will run in any computer with the Java Virtual Machine software. On the server side, Java programs can also be compiled into machine language for faster performance. However a compiled Java program loses hardware independence as a result. Although the present invention is described based on the Java programming language, other programming languages may be used to implement the embodiments of the present invention, such as other object oriented programming languages. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a use case diagram showing a specification tracking system <highlight><bold>104</bold></highlight>, in accordance with an embodiment of the present invention. The use case diagram of <cross-reference target="DRAWINGS">FIG. 2</cross-reference> illustrates how a user <highlight><bold>200</bold></highlight> interacts with a specification tracking system <highlight><bold>104</bold></highlight> of the embodiments of the present invention. The specification tracking system <highlight><bold>104</bold></highlight> includes a dispatcher module <highlight><bold>202</bold></highlight> in communication with report TCK coverage module <highlight><bold>204</bold></highlight>, a track TCK tests module <highlight><bold>206</bold></highlight>, a report specification differences module <highlight><bold>208</bold></highlight>, and a get specification assertions module <highlight><bold>210</bold></highlight>. As will be seen, the specification tracking system <highlight><bold>104</bold></highlight> of the embodiments of the present invention is capable of performing a plurality of tasks, including obtaining specification assertions, reporting TCK information, tracking specification differences, and determining TCK tests testing a particular assertion. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> In operation, the user <highlight><bold>200</bold></highlight> interacts with the dispatcher module <highlight><bold>202</bold></highlight>, which hides the internal organization of the specification tracking system <highlight><bold>104</bold></highlight> details from the user <highlight><bold>200</bold></highlight>. The dispatcher module <highlight><bold>202</bold></highlight> provides the user <highlight><bold>200</bold></highlight> with simple and intuitive interface to execute the underlying tasks. The user <highlight><bold>200</bold></highlight> submits a command to the dispatcher module <highlight><bold>202</bold></highlight>, and the dispatcher module <highlight><bold>202</bold></highlight> makes a decision based on the received command as to which concrete actions it should perform depending on the system configuration and default settings. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> The dispatcher module <highlight><bold>202</bold></highlight> preferably is not aware of any task-specific details. Based on the commands submitted by the user <highlight><bold>200</bold></highlight>, the dispatcher module <highlight><bold>202</bold></highlight> determines the class responsible for executing specified task and runs it. This class will be referred to hereinafter as the &ldquo;responsible class&rdquo;. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> Each of responsible classes implements a special interface that provides the dispatcher module <highlight><bold>202</bold></highlight> with a uniform interface to run the task. In one embodiment, a specification tracking framework application programming interface (API) is used to implement the uniform interface. The framework API specifies which interfaces classes should expose, and how to use these interfaces. In addition, the framework API determines the protocols used, which is the method calling sequence. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> shows dispatcher process <highlight><bold>202</bold></highlight> for processing user commands, in accordance with an embodiment of the present invention. The dispatcher module <highlight><bold>202</bold></highlight> forms the entry point of specification tracking system of the embodiments of the present invention. The user submits a command to the dispatcher module <highlight><bold>202</bold></highlight> through the entry point, and the dispatcher module <highlight><bold>202</bold></highlight> reads the system configuration in operation <highlight><bold>300</bold></highlight>. In addition, the dispatcher module parses the command submitted by the user in operation <highlight><bold>302</bold></highlight>. In one embodiment, the syntax for the command can be: </paragraph>
<paragraph id="P-0046" lvl="2"><number>&lsqb;0046&rsqb;</number> java com.sun.tdk.spectrac.Main command &lsqb;doctype&rsqb; &lsqb;options&rsqb;</paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> Where command is one of the following: 1) getassert, 2) report, 3) specdiff, or 4) track. In addition, doctype is type of specification to be processed, and options are command-specific options. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> A decision is then made as to whether the command is appropriate for the current implementation of the specification tracking system, in operation <highlight><bold>304</bold></highlight>. For example, if the specification tracking system were implemented as described above with reference to the syntax for a command, a command other than 1) getassert, 2) report, 3) specdiff, or 4) track, would not be appropriate. If the command is not appropriate the dispatch process <highlight><bold>202</bold></highlight> aborts, otherwise, the dispatch process continues with operation <highlight><bold>306</bold></highlight>. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> In operation <highlight><bold>306</bold></highlight>, the dispatcher module <highlight><bold>202</bold></highlight> locates the responsible class for executing the received command. Each task has a responsible class, which is responsible for performing the functions of the task. After parsing the command received from the user, the dispatcher module can determine which class is responsible for executing the functions of the related task. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> The responsible class is then instantiated in operation <highlight><bold>308</bold></highlight>. Instantiation is a term used in object oriented programming to describe the creation of objects from classes. An object is a generic term that is used in the object-oriented programming environment to refer to a module that contains related code and variables. A software application can be written using an object-oriented programming language whereby the program&apos;s functionality is implemented using objects. Examples of object-oriented programming languages include C&plus;&plus; as well as Java. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> Object-oriented programming is a method of creating computer programs by combining certain fundamental building blocks, and creating relationships among and between the building blocks. The building blocks in object-oriented programming systems are called &ldquo;objects&rdquo;. An object is a programming unit that groups together a data structure (instance variables) and the operations (methods) that can use or affect that data. Thus, an object consists of data and one or more operations or procedures that can be performed on that data. The joining of data and operations into a unitary building block is called &ldquo;encapsulation&rdquo;. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> An object can be instructed to perform one of its methods when it receives a &ldquo;message&rdquo;. A message is a command or instruction to the object to execute a certain method. It consists of a method selection (name) and a plurality of arguments that are sent to an object. A message tells the receiving object what operations to perform. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> One advantage of object-oriented programming is the way in which methods are invoked. When a message is sent to an object, it is not necessary for the message to instruct the object how to perform a certain method. It is only necessary to request that the object execute the method. This greatly simplifies program development. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> Object-oriented programming languages are predominantly based on a &ldquo;class&rdquo; scheme. A class defines a type of object that typically includes both instance variables and methods for the class. An object class is used to create a particular instance of an object. An instance of an object class includes the variables and methods defined for the class. Multiple instances of the same class can be created from an object class. Each instance that is created from the object class is said to be of the same type or class. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> A hierarchy of classes can be defined such that an object class definition has one or more subclasses. A subclass inherits its parent&apos;s (and grandparent&apos;s etc.) definition. Each subclass in the hierarchy may add to or modify the behavior specified by its parent class. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> To illustrate, an employee object class can include &ldquo;name&rdquo; and &ldquo;salary&rdquo; instance variables and a &ldquo;set_salary&rdquo; method. Instances of the employee object class can be created, or instantiated for each employee in an organization. Each object instance is said to be of type &ldquo;employee&rdquo;. Each employee object instance includes the &ldquo;name&rdquo; and &ldquo;salary&rdquo; instance variables and the &ldquo;set_salary&rdquo; method. The values associated with the &ldquo;name&rdquo; and &ldquo;salary&rdquo; variables in each employee object instance contain the name and salary of an employee in the organization. A message can be sent to an employee&apos;s employee object instance to invoke the &ldquo;set_salary&rdquo; method to modify the employee&apos;s salary (i.e., the value associated with the &ldquo;salary&rdquo; variable in the employee&apos;s employee object). </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> In operation <highlight><bold>310</bold></highlight>, the responsible class is run and the command is executed. Each task has its responsible class, which is the entry point for that task. <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a block diagram showing task entry points <highlight><bold>400</bold></highlight>, in accordance with an embodiment of the present invention. The task entry points <highlight><bold>400</bold></highlight> include getassert <highlight><bold>210</bold></highlight>, reporter <highlight><bold>204</bold></highlight>, specdiff <highlight><bold>208</bold></highlight>, and track <highlight><bold>206</bold></highlight>, based on the command types described previously. As shown in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, the dispatcher module uses a runner <highlight><bold>410</bold></highlight> to parse the commands, and instantiate and run the responsible classes. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> Each responsible class exposes a uniform interface that allows the Dispatcher to execute a task without knowledge of any task-specific details. In this manner, the implementation that is being called by the dispatcher module may be modified without any affect on dispatcher module&apos;s code. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5A</cross-reference> is flowchart showing a process <highlight><bold>210</bold></highlight><highlight><italic>a </italic></highlight>for obtaining specification assertions, in accordance with an embodiment of the present invention. As will be seen, a user can retrieve specification assertions using the getassert command of the specification tracking system. The getassert command has the corresponding abstract class GetassertBase, which is the base class for every class implementing getassert command. </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> In operation <highlight><bold>502</bold></highlight>, the process <highlight><bold>210</bold></highlight><highlight><italic>a </italic></highlight>receives an input specification. As discussed above, the input specification can be identified based on the input arguments of the received command. After receiving a request to process a particular specification, the process <highlight><bold>210</bold></highlight><highlight><italic>a </italic></highlight>determines whether or not the requested specification is available. If the requested specification is not available, a problem is reported in operation <highlight><bold>504</bold></highlight>, and the process <highlight><bold>210</bold></highlight><highlight><italic>a </italic></highlight>is aborted, in operation <highlight><bold>505</bold></highlight>. However, if the requested specification is available, the process <highlight><bold>210</bold></highlight><highlight><italic>a </italic></highlight>continues with operation <highlight><bold>506</bold></highlight>. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> In operation <highlight><bold>506</bold></highlight>, the next context is identified. The context is a set of circumstances related to each assertion. As such, each assertion of the specification has its context. In one embodiment of the present invention, the specification has a tree-like structure. For example, the API specification tree has a top-level specification as a root, and package-level specifications as immediate children of the root, with class-level specifications as their children, and finally constructor/method/field specifications as leaves. As mentioned previously, an assertion is uniquely identified by both the assertion text and the context associated with it. The assertion context can be defined as the associated node of the specification tree. For example, an assertion from a package-level specification would mean that the package-level is the assertion context. It should be noted, however, that embodiments of the present invention can process specifications that do not strictly adhere to this particular multi-level structure, because the specification tree can be considered to contain only one node. </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> A decision is then made, in operation <highlight><bold>508</bold></highlight>, as to whether a context is available. If no context is available, the process <highlight><bold>210</bold></highlight><highlight><italic>a </italic></highlight>is completed in operation <highlight><bold>514</bold></highlight>. Generally, when no further context is available the input application has been processed and an assertion result completed, as described below. If the context is available, the process <highlight><bold>210</bold></highlight><highlight><italic>a </italic></highlight>continues with operation <highlight><bold>509</bold></highlight>. </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> The context specification is then filtered, in operation <highlight><bold>509</bold></highlight>. A context specification is a portion of the specification that is associated with a particular context. Once the context specification is filtered, the context specification is parsed, in operation <highlight><bold>510</bold></highlight>. Specifically, the context specification is parsed to find the assertions present in the particular context specification. </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> The embodiments of the present invention scan through the specification and split the entire text into logical statements. In some embodiments, discussed subsequently, each logical statement is then examined by type to indicate if it is a testable assertion. </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> Statements are considered testable assertions if they are intended to describe behavior of an API that can be tested by the TCK. Also, examples or sample code pieces that are provided in the specification are typically testable and can be verified by the TCK. In this sense, examples or sample code are generally considered testable assertions. Further, it should be noted that some assertions can be implied or indirectly stated in the specification, and these should be identified as well for testing. Note that an implied assertion might also introduce a specification flaw that may not be obvious. </paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> On the other hand, statements intended to describe the behavior of an API, but which cannot be tested by the TCK due to the special nature of the behavior or functionality, are generally considered non-testable assertions. Similarly, some statements will form general descriptions of the API such as a description of a package, class, method, or field, and so forth. If such a general description does not describe behavior, but is aimed rather at providing a context for the rest of the text, then such a statement is not intended to be an assertion and should not be tested. Hence, these statements are generally not considered to be assertions, as they are easy to misinterpret. </paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> An exemplary context specification is shown in Table 1.  
<table-cwu id="TABLE-US-00001">
<number>1</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center">TABLE 1</entry>
</row>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>public static String toString (int i, int radix)</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>Creates a string representation of the first argument in the radix specified</entry>
</row>
<row>
<entry>by the second argument.</entry>
</row>
<row>
<entry>If the radix is smaller than Character.MIN_RADIX or larger than</entry>
</row>
<row>
<entry>Character.MAX_RADIX, then the radix 10 is used instead.</entry>
</row>
<row>
<entry>If the first argument is negative, the first element of the result is the ASCII</entry>
</row>
<row>
<entry>minus character &lsquo;&minus;&rsquo; (&lsquo;&bsol;u002d&rsquo;).</entry>
</row>
<row>
<entry>If the first argument is not negative, no sign character appears in the result.</entry>
</row>
<row>
<entry>Parameters:</entry>
</row>
<row>
<entry>i - an integer.</entry>
</row>
<row>
<entry>radix - the radix.</entry>
</row>
<row>
<entry>Returns:</entry>
</row>
<row>
<entry>a string representation of the argument in the specified radix.</entry>
</row>
<row>
<entry>See Also:</entry>
</row>
<row>
<entry>Character.MAX_RADIX, Character.MIN_RADIX</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0068" lvl="0"><number>&lsqb;0068&rsqb;</number> Table 2 shows a list of assertions based on the context specification shown in Table 1.  
<table-cwu id="TABLE-US-00002">
<number>2</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="center"/>
<colspec colname="2" colwidth="196PT" align="left"/>
<thead>
<row>
<entry namest="1" nameend="2" align="center">TABLE 2</entry>
</row>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>A1.</entry>
<entry>Creates a string representation of the first argument in the radix</entry>
</row>
<row>
<entry></entry>
<entry>specified by the second argument.</entry>
</row>
<row>
<entry>A2.</entry>
<entry>If the radix is smaller than Character.MIN_RADIX or larger</entry>
</row>
<row>
<entry></entry>
<entry>than Character.MAX_RADIX, then the radix 10 is used instead.</entry>
</row>
<row>
<entry>A3.</entry>
<entry>If the first argument is negative, the first element of the result is</entry>
</row>
<row>
<entry></entry>
<entry>the ASCII minus character &lsquo;&minus;&rsquo; (&lsquo;&bsol;u002d&rsquo;).</entry>
</row>
<row>
<entry>A4.</entry>
<entry>If the first argument is not negative, no sign character appears in</entry>
</row>
<row>
<entry></entry>
<entry>the result.</entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0069" lvl="0"><number>&lsqb;0069&rsqb;</number> Thus, tables 1 and 2 illustrate one example of how an embodiment of the present invention can parse a context specification and create a list of assertions based on that context specification. </paragraph>
<paragraph id="P-0070" lvl="0"><number>&lsqb;0070&rsqb;</number> Having parsed the context specification, the discovered assertions are added to an assertion result set, in operation <highlight><bold>512</bold></highlight>. The process <highlight><bold>210</bold></highlight><highlight><italic>a </italic></highlight>then continues with another identify context operation <highlight><bold>506</bold></highlight>. In this manner, the process <highlight><bold>210</bold></highlight><highlight><italic>a </italic></highlight>can parse through an input specification and generate a list of assertions based on the input specification. As mentioned above, in some embodiments of the present invention, each logical statement is can be examined by type to indicate if it is a testable assertion. </paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5B</cross-reference> is flowchart showing a process <highlight><bold>210</bold></highlight><highlight><italic>b </italic></highlight>for obtaining specification assertions and validating the assertions, in accordance with an embodiment of the present invention. Similar to the process <highlight><bold>210</bold></highlight><highlight><italic>a </italic></highlight>of Figure SA, in operation <highlight><bold>502</bold></highlight> of process <highlight><bold>210</bold></highlight><highlight><italic>b </italic></highlight>an input specification is received. As discussed above, the input specification can be identified based on the input arguments of the received command. </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> In operation <highlight><bold>506</bold></highlight>, the next context is identified. A decision is then made, in operation <highlight><bold>508</bold></highlight>, as to whether a context is available. If no context is available, the process <highlight><bold>210</bold></highlight><highlight><italic>b </italic></highlight>is completed in operation <highlight><bold>514</bold></highlight>. Generally, when no further context is available the input application has been processed and an assertion result completed. If the context is available, the process <highlight><bold>210</bold></highlight><highlight><italic>b </italic></highlight>continues with operation <highlight><bold>509</bold></highlight>. </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> The context specification is then filtered, in operation <highlight><bold>509</bold></highlight>. As discussed above, a context specification is a portion of the specification that is associated with a particular context. Once the context specification is filtered, the context specification is parsed, in operation <highlight><bold>510</bold></highlight>. Specifically, the context specification is parsed to find the assertions present in the particular context specification. </paragraph>
<paragraph id="P-0074" lvl="0"><number>&lsqb;0074&rsqb;</number> A decision is then made as to whether a sentence is available, in operation <highlight><bold>550</bold></highlight>. Embodiments of the present invention can parse the input specification to obtain sentences having relevance to the input specification. If no sentence is available in the current context, the process <highlight><bold>210</bold></highlight><highlight><italic>b </italic></highlight>identifies the next context in <highlight><bold>506</bold></highlight>. Otherwise, the process obtains the next sentence, in operation <highlight><bold>552</bold></highlight>. </paragraph>
<paragraph id="P-0075" lvl="0"><number>&lsqb;0075&rsqb;</number> Another decision is then made as to whether the obtained sentence is a testable assertion, in operation <highlight><bold>554</bold></highlight>. In one embodiment, a natural language processing system can be used to process the obtained sentence. In this case, the natural language processing system includes an input means for inputting the sentence obtained from the specification, and a knowledge base for storing linguistic knowledge and general knowledge. In addition, a partitioner is included that partitions the sentence into words, and a derivation module is included that refers to knowledge stored in the knowledge base and derives concepts respectively represented by the words obtained by the partitioner. Further, an integration module can be included that relates the concepts of the words, which are derived by the derivation module, with one another by referring to knowledge stored in the knowledge base. For example, a valid assertion can be identified as a sentence which uses particular keywords or phrases such as &ldquo;required to&rdquo; &ldquo;should&rdquo;, &ldquo;should not&rdquo;. </paragraph>
<paragraph id="P-0076" lvl="0"><number>&lsqb;0076&rsqb;</number> If the obtained sentence is not a testable assertion, another decision is made as to whether another sentence is available in the current context, in operation <highlight><bold>550</bold></highlight>. However, if the obtained sentence is a testable assertion, sentence is marked as a valid, testable assertion, in operation <highlight><bold>556</bold></highlight>. The assertion is then added to the assertion result set, in operation <highlight><bold>558</bold></highlight>. Thereafter, another decision is made as to whether another sentence is available in the current context, in operation <highlight><bold>550</bold></highlight>. In this manner, the process <highlight><bold>210</bold></highlight> b can parse through an input specification and generate a list of valid assertions based on the input specification. </paragraph>
<paragraph id="P-0077" lvl="0"><number>&lsqb;0077&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is a class diagram showing a Getassert framework class <highlight><bold>600</bold></highlight>, in accordance with an embodiment of the present invention. The Getassert framework class <highlight><bold>600</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 6</cross-reference> shows the Getassert class <highlight><bold>210</bold></highlight>, a specification class <highlight><bold>602</bold></highlight>, and an assertion class <highlight><bold>604</bold></highlight>. As shown in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>, the Getassert class <highlight><bold>210</bold></highlight> calls the methods of the specification class <highlight><bold>602</bold></highlight> to obtain context specifications and the related assertions. The specification class <highlight><bold>602</bold></highlight>, in turn, uses the assertion class <highlight><bold>604</bold></highlight> to obtain the sentences within each context specification. </paragraph>
<paragraph id="P-0078" lvl="0"><number>&lsqb;0078&rsqb;</number> As shown in <cross-reference target="DRAWINGS">FIG. 6, a</cross-reference> Spec Reader Iterator <highlight><bold>608</bold></highlight> is used to retrieve the specification. The Spec Reader Iterator <highlight><bold>608</bold></highlight> is responsible for obtaining the specification text from the specified source, determining the contexts, preprocessing the specification text, and providing an interface to iterate through the various contexts and their specifications. The responsible class, Getassert <highlight><bold>210</bold></highlight>, iterates through the documentation and creates an internal representation of the input specification. The Getassert class <highlight><bold>210</bold></highlight> provides the public method Specification getSpec() which is used by other components of the specification tracking system or an external application to get an instance of Specification class. </paragraph>
<paragraph id="P-0079" lvl="0"><number>&lsqb;0079&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> is a flowchart showing a process <highlight><bold>204</bold></highlight> for reporting TCK coverage of a specification, in accordance with an embodiment of the present invention. In operation <highlight><bold>702</bold></highlight>, the location of the TCK is identified. In addition, the specification for the specified contexts can be obtained in operation <highlight><bold>704</bold></highlight>. </paragraph>
<paragraph id="P-0080" lvl="0"><number>&lsqb;0080&rsqb;</number> Once the TCK location is identified, the location of the tests for the specified contexts is identified, in operation <highlight><bold>706</bold></highlight>. Next, the TCK information files are located, in operation <highlight><bold>708</bold></highlight>, and the TCK information is collected in operation <highlight><bold>710</bold></highlight>. Typically, the information is returned in the form of an instance of the TCK class. At point <highlight><bold>712</bold></highlight>, both the TCK information and the specification for the specified contexts that was obtained in operation <highlight><bold>704</bold></highlight> are available to the system. Thereafter the assertions are processed, in operation <highlight><bold>714</bold></highlight>. Processing the assertions includes marking the assertion status, such as indicating whether an assertion is tested, non-tested, or invalid. To perform the process <highlight><bold>204</bold></highlight> for reporting TCK coverage of a specification, the TCK information class <highlight><bold>204</bold></highlight> is used. </paragraph>
<paragraph id="P-0081" lvl="0"><number>&lsqb;0081&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> is a diagram showing reporting TCK information class <highlight><bold>204</bold></highlight>, in accordance with an embodiment of the present invention. The TCK information class <highlight><bold>204</bold></highlight> includes a FileFinder module <highlight><bold>800</bold></highlight>, a TCKReader module <highlight><bold>802</bold></highlight>, a TCK <highlight><bold>804</bold></highlight>, a TestCase <highlight><bold>806</bold></highlight>, an Assertion <highlight><bold>808</bold></highlight>, a ReporterBase <highlight><bold>810</bold></highlight>, and a GetassertBase <highlight><bold>812</bold></highlight>. Generally, before reports are created the TCK information files describing test-to-assertion relationship are created. The TCKReader module <highlight><bold>802</bold></highlight> uses the FileFinder module <highlight><bold>800</bold></highlight> to find these files for a set of contexts specified. The TCKReader module <highlight><bold>802</bold></highlight> typically collects TCK information by reading information files and provides this information to the Report class in form of an instance of TCK object <highlight><bold>804</bold></highlight>. The Report class then gets the actual specification using the Getassert interface <highlight><bold>210</bold></highlight> and compares this with the information contained in the TCK <highlight><bold>804</bold></highlight>. The output from this operation is still a TCK object with each assertion <highlight><bold>808</bold></highlight> marked with its status. A method Report.run() is then executed that reads that information and creates human-readable reports. </paragraph>
<paragraph id="P-0082" lvl="0"><number>&lsqb;0082&rsqb;</number> Although the foregoing invention has been described in some detail for purposes of clarity of understanding, it will be apparent that certain changes and modifications may be practiced within the scope of the appended claims. Accordingly, the present embodiments are to be considered as illustrative and not restrictive, and the invention is not to be limited to the details given herein, but may be modified within the scope and equivalents of the appended claims.</paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method for automated acquisition of assertions in a specification of a computer program, comprising the operations of: 
<claim-text>receiving an input specification, wherein the input specification comprises a plurality of sentences; </claim-text>
<claim-text>obtaining a sentence from the plurality of sentences; </claim-text>
<claim-text>determining whether the obtained sentence is a testable assertion; and </claim-text>
<claim-text>marking the obtained sentence as testable when the obtained sentence is a testable assertion. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. A method as recited in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising the operation of identifying a context within the specification. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. A method as recited in <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, wherein the operation of obtaining the sentence from the plurality of sentences includes parsing the context to obtain the sentence. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. A method as recited in <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference>, further comprising the operation of adding the marked obtained sentence to an assertion result set. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. A method as recited in <dependent-claim-reference depends_on="CLM-00004">claim 4</dependent-claim-reference>, wherein the context is a set of circumstances related to the obtained sentence. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. A method as recited in <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference>, wherein each assertion comprises at least one sentence of the specification. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. A method as recited in <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, wherein each assertion can comprises at least two sentences of the specification. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. A computer program for automatically obtaining assertions from a specification for a computer program, comprising: 
<claim-text>a code segment that receives an input specification for a computer program; </claim-text>
<claim-text>a code segment that identifies a context within the input specification; </claim-text>
<claim-text>a code segment that parses the identified context to obtain assertions; </claim-text>
<claim-text>a code segment that determines whether the obtained assertions are testable statements; and </claim-text>
<claim-text>a code segment that adds the obtained assertions to an assertion result set, wherein the assertion result set can be used to facilitate testing of the specification. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. A computer program as recited in <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference>, further comprising a code segment that filters the identified context prior to parsing the context. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. A computer program as recited in <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, wherein an assertion is an implied statement that can be tested. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. A computer program as recited in <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, wherein the context is a set of circumstances related to the obtained assertions. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. A computer program as recited in <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, wherein each assertion comprises at least one sentence of the specification. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. A computer program as recited in <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, wherein each assertion can comprises at least two sentences of the specification. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. A computer program for automated acquisition of assertions in a specification of a computer program, comprising: 
<claim-text>a code segment that receives an input specification, wherein the input specification comprises a plurality of sentences; </claim-text>
<claim-text>a code segment that obtains a sentence from the plurality of sentences; </claim-text>
<claim-text>a code segment that determines whether the obtained sentence is a testable assertion; and </claim-text>
<claim-text>a code segment that marks the obtained sentence as testable when the obtained sentence is a testable assertion. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. A computer program as recited in <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference>, further comprising a code segment that identifies a context within the specification. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. A computer program as recited in <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference>, wherein the code segment that obtains the sentence from the plurality of sentences includes a code segment that parses the context to obtain the sentence. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. A computer program as recited in <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, further comprising a code segment that adds the marked obtained sentence to an assertion result set. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. A computer program as recited in <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference>, wherein the context is a set of circumstances related to the obtained sentence. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. A computer program as recited in <dependent-claim-reference depends_on="CLM-00011">claim 18</dependent-claim-reference>, wherein each assertion comprises at least one sentence of the specification. </claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. A computer program as recited in <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference>, wherein each assertion can comprises at least two sentences of the specification.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>1</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030003432A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030003432A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030003432A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030003432A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030003432A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030003432A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030003432A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030003432A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030003432A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00009">
<image id="EMI-D00009" file="US20030003432A1-20030102-D00009.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
