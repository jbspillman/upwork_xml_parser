<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005166A1-20030102-D00000.TIF SYSTEM "US20030005166A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005166A1-20030102-D00001.TIF SYSTEM "US20030005166A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005166A1-20030102-D00002.TIF SYSTEM "US20030005166A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005166A1-20030102-D00003.TIF SYSTEM "US20030005166A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005166A1-20030102-D00004.TIF SYSTEM "US20030005166A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005166A1-20030102-D00005.TIF SYSTEM "US20030005166A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030005166A1-20030102-D00006.TIF SYSTEM "US20030005166A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030005166A1-20030102-D00007.TIF SYSTEM "US20030005166A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030005166A1-20030102-D00008.TIF SYSTEM "US20030005166A1-20030102-D00008.TIF" NDATA TIF>
<!ENTITY US20030005166A1-20030102-D00009.TIF SYSTEM "US20030005166A1-20030102-D00009.TIF" NDATA TIF>
<!ENTITY US20030005166A1-20030102-D00010.TIF SYSTEM "US20030005166A1-20030102-D00010.TIF" NDATA TIF>
<!ENTITY US20030005166A1-20030102-D00011.TIF SYSTEM "US20030005166A1-20030102-D00011.TIF" NDATA TIF>
<!ENTITY US20030005166A1-20030102-D00012.TIF SYSTEM "US20030005166A1-20030102-D00012.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005166</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09884505</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010614</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F009/00</ipc>
</classification-ipc-primary>
<classification-ipc-secondary>
<ipc>G06F009/54</ipc>
</classification-ipc-secondary>
<classification-ipc-secondary>
<ipc>G06F015/163</ipc>
</classification-ipc-secondary>
<classification-ipc-secondary>
<ipc>G06F009/46</ipc>
</classification-ipc-secondary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>709</class>
<subclass>310000</subclass>
</uspc>
</classification-us-primary>
<classification-us-secondary>
<uspc>
<class>709</class>
<subclass>328000</subclass>
</uspc>
</classification-us-secondary>
</classification-us>
<title-of-invention>Tracking component manager</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Glenn</given-name>
<middle-name>R.</middle-name>
<family-name>Seidman</family-name>
</name>
<residence>
<residence-us>
<city>Woodside</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
</inventors>
<assignee>
<organization-name>Verano</organization-name>
<assignee-type>02</assignee-type>
</assignee>
<correspondence-address>
<name-1>MICHAEL B. EINSCHLAG, ESQ.</name-1>
<name-2></name-2>
<address>
<address-1>25680 FERNHILL DRIVE</address-1>
<city>LOS ALTOS HILLS</city>
<state>CA</state>
<postalcode>94024</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">One embodiment of the present invention is a component manager that manages one or more tracking components, the component manager including: a deployer that generates a client interface for each tracking component output port, and deploys the client interface in a directory service, wherein each entry is a tracking point object. In another embodiment, the deployer further generates a client interface for each tracking component input port, and deploys the client interface in a directory service, wherein each entry is a tracking point object. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">TECHNICAL FIELD OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> The present invention pertains to component managers, components associated with the component managers, and methods and apparatus for fabricating the component managers and their associated components. In particular, the present invention pertains to a tracker component manager (for example, a deferred response component manager embodied as an Enterprise TrackerBean container) and tracker components (for example, tracker components embodied as Enterprise TrackerBeans) associated therewith. </paragraph>
</section>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> A critical issue in an enterprise computing environment relates to a need to: (a) develop tracking sources that track and monitor status of software subsystems and devices; and (b) aggregate vast quantities of information available from multiple such tracking sources into a meaningful presentation. An additionally issue relates to a need for normal batch processes running in the enterprise computing environment to react to monitored conditions and specific tracking information criteria in real-time. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> Typical enterprise computing system deployments comprise many distinct computing subsystems, each of which computing subsystems have distinct purposes and are built by distinct development teams from separate corporations or from separate divisions within a corporation. This typically results in monitoring and tracking clients that: (a) have a distinct look and feel; and (b) address different deployed computing subsystems. As a result, an underlying tracking infrastructure that delivers tracking information from the computing subsystems to the monitoring and tracking clients (using client interfaces) tends to be developed in such a way that a tracking capability is coded for each distinct computing system without an enterprise-wide view. Then, in light of this state of affairs, whenever a new computing subsystem is added to an enterprise computing system, tracking infrastructure code must be developed for the new computing system. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> Sun Microsystems has introduced Java Management Extensions (&ldquo;JMX&rdquo;) that specifies a unified approach for developing management components&mdash;these management components can be used for tracking or configuring. Using JMX, management components can be built across computing subsystems by distinct development teams, and they can be brought together in a coherent manner to use or build client interfaces having a same look and feel. Although JMX assists in constructing management components, it does not help two or more management components work together to track or monitor together to accomplish a larger tracking task (i.e., JMX mostly expects management components to provide tracking and configuration in isolation). Thus, to get management components to work together, more code must be developed. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> In light of the above, there is a need for method and apparatus that enables tracking components to be developed, and that provides a mechanism for these tracking components to work together in tracking networks without additional code development. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> Embodiments of the present invention advantageously satisfy the above-identified need in the art and provide methods and apparatus that enable tracking components to be developed, and that provides a mechanism for these tracking components to work together in tracking networks without additional code development. In addition, advantageously, at least some embodiments of the present invention are compatible with JMX. In particular, one embodiment of the present invention represents a tracking component manager (embodied, for example, as a container) that provides freely gained characteristics for very large scale tracking and monitoring tracking by associating components with the tracking component manager (for example, by dropping the component into the container)&mdash;along with simple text declarations, representing tracking instructions for each component (for example, set forth in a deployment descriptor). In particular, in accordance with one embodiment of the present invention, a tracking component manager that is fabricated in accordance with one embodiment of the present invention provides a client user interface that makes it easy to: (a) configure individual tracking components; (b) track individual tracking components; and (c) connect tracking components into a tracking network to provide aggregate tracking information. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> Specifically, one embodiment of the present invention is a component manager that manages one or more tracking components, the component manager comprising: a deployer that generates a client interface for each tracking component output port, and deploys the client interface in a directory service, wherein each entry is a tracking point object. In another embodiment, the deployer further generates a client interface for each tracking component input port, and deploys the client interface in a directory service, wherein each entry is a tracking point object. </paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE FIGURE </heading>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> shows symbols used in the Detailed Description to describe various software entities and their interrelationships; </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> shows various of the interrelationships shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>; </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> shows a component deployment file; </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> shows a block diagram of tracking component instances disposed in an Enterprise TrackerBean Container along with their associated TrackingPoint objects for their input and output ports; </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> shows a block diagram of a TrackerBean Object Model that illustrates an input and output port paradigm; </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> shows a block diagram of TrackerBeans deployed in distributed ETB Containers wherein information flows are identified for different connection types; </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> shows a TrackerBean configurator user interface that displays a source of tracking information for TrackerBean named &ldquo;Ross&rdquo;; </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> shows a block diagram of an internal subsystem architecture for an Enterprise TrackerBean Container that is fabricated in accordance with the present invention; </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference> shows a block diagram of an XML grammar structure of a TrackerBean deployment descriptor that is fabricated in accordance with the present invention; </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10</cross-reference> shows a block diagram of an XML grammar structure of a tracking point network descriptor that is fabricated in accordance with the present invention; </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 11</cross-reference> shows a block diagram of an architecture of a TrackerBean TreeNode that is stored within a TrackerBeans dictionary shown in <cross-reference target="DRAWINGS">FIG. 8</cross-reference>; and </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 12</cross-reference> shows a block diagram of an interaction between an architecture of a TrackerBean TreeNode that is stored in a TrackerBeans dictionary and an architecture of a TrackerPointNetwork that is stored in a TrackerPointNetworks dictionary. </paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION </heading>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> In accordance with one embodiment of the present invention, a tracking component manager enables software components developed according to a new design pattern to be deployed, and to enjoy advantages for very large scale tracking and monitoring without having to explicitly code to gain such advantages. In accordance with one or more embodiments of the present invention, the advantageously obtained advantages include transparent and automated scheduling and synchronization of tracking information flows and automated creation of tracking points. In addition, in accordance with one or more embodiments of the present invention, a tracking component manager also provides a client user interface that makes it easy to configure individual components, track individual components, and connect tracking components into a tracking network to provide aggregate tracking information. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> In accordance with one embodiment of the present invention, an Enterprise TrackerBean Container (&ldquo;ETB&rdquo; Container) operates on a network server with client systems requiring tracking on the same server. Further embodiments of the present invention cover situations where client systems reside in a distinct server. When the client systems reside in the same network server as the ETB Container, the client systems may access the ETB Container in their same process or a distinct process. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> An ETB Container fabricated in accordance with one embodiment of the present invention provides a component manager in the form of a container architecture wherein components, for example, tracking components may be deployed into the container to gain beneficial dynamics and services. In accordance with one embodiment of the present invention, contracts (for example: a container/component contract; a client/component contract; and a deployment contract) are specified by way of interfaces (the interfaces include an administrative user interface) and a deployment model. The following lists benefits provided by one or more embodiments of the present invention: (a) a unified component object model for tracking and analyzing data from information sources; (b) a framework for configuring tracking components; (c) automated scheduled and synchronized processing of tracking information; (d) automated creation of tracking points; (e) a connection framework to establish a network of tracking points across local and distributed containers; (f) aggregation of components to form larger, composite components; (g) data flow management between tracking point inputs and outputs; (h) a listening framework for external client components; and (i) automatic registration of the components into a naming directory. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> The following detailed description of embodiments of the present invention employs UML structure diagrams that are well known to those of ordinary skill in the art to describe various software entities and their relationships and to aid in understanding the present invention. Note, however, that the container subsystem symbol shown, for example, in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, is not an UML standard, but it is used to better illustrate that some embodiments of the present invention comprise a container that &ldquo;contains&rdquo; components that get deployed thereinto. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> shows the symbols used herein to describe various software entities and their interrelationships. As shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, symbol <highlight><bold>100</bold></highlight> refers to a container subsystem, symbol <highlight><bold>110</bold></highlight> refers to a class, symbol <highlight><bold>120</bold></highlight> refers to a component instance, symbol <highlight><bold>130</bold></highlight> refers to an object, symbol <highlight><bold>140</bold></highlight> refers to an interface, symbol <highlight><bold>150</bold></highlight> refers to an interrelationship of &ldquo;implements,&rdquo;, symbol <highlight><bold>160</bold></highlight> refers to an interrelationship of &ldquo;uses,&rdquo; and symbol <highlight><bold>170</bold></highlight> refers to an interrelationship of &ldquo;inherits.&rdquo; <cross-reference target="DRAWINGS">FIG. 2</cross-reference> shows various of the interrelationships shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. As shown in <cross-reference target="DRAWINGS">FIG. 2</cross-reference><highlight><italic>a</italic></highlight>, the class &ldquo;child&rdquo; inherits class &ldquo;Parent.&rdquo; As further shown in <cross-reference target="DRAWINGS">FIG. 2</cross-reference><highlight><italic>b</italic></highlight>, class &ldquo;Automobile&rdquo; implements interface &ldquo;Vehicle.&rdquo; As still further shown in <cross-reference target="DRAWINGS">FIG. 2</cross-reference><highlight><italic>c</italic></highlight>, class &ldquo;Automobile&rdquo; uses classes &ldquo;Wheel&rdquo; and &ldquo;Seat.&rdquo; Lastly, as further shown in <cross-reference target="DRAWINGS">FIG. 2</cross-reference><highlight><italic>d</italic></highlight>, car <highlight><bold>27</bold></highlight> is an instance of class &ldquo;Automobile.&rdquo;</paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> shows a block diagram of software subsystems (along with their interrelationships) that comprise one embodiment of the present invention. In accordance with this embodiment of the present invention, Enterprise TrackerBean Container <highlight><bold>300</bold></highlight> manages Enterprise TrackerBeans (not shown in <cross-reference target="DRAWINGS">FIG. 8</cross-reference>), and a single interface (Enterprise TrackerBeanContainer interface <highlight><bold>310</bold></highlight>) through which requests are made. As shown in FIG. <highlight><bold>8</bold></highlight>, TrackerBeanPattemMachine <highlight><bold>320</bold></highlight> is the sole implementer of the single Enterprise TrackerBeanContainer interface <highlight><bold>310</bold></highlight> (i.e., the TrackerBeanPatternMachine class provides EnterpriseTrackerBeanContainer interface <highlight><bold>310</bold></highlight> that clients can use to access TrackerBeans and tracking points deployed inside Enterprise TrackerBean Container <highlight><bold>300</bold></highlight>). Further, TrackerBeanPatternMachine <highlight><bold>320</bold></highlight> maintains responsibility to manage the life cycle of Enterprise TrackerBeans. In accordance with one embodiment of the present invention, embodiments of the inventive systems operate by implementing the following: (a) a component manager/component contract; (b) a client/container contract; and (c) a deployment contract. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> As shown in <cross-reference target="DRAWINGS">FIG. 8</cross-reference>, DeploymentCoordinator <highlight><bold>330</bold></highlight> drives a deployment system while TrackerBeanPatternMachine <highlight><bold>320</bold></highlight> drives client runtime. Together, DeploymentCoordinator <highlight><bold>330</bold></highlight> and TrackerBeanPatternMachine <highlight><bold>320</bold></highlight> initiate processing that may be declared using a deployment descriptor. TrackerBeanPatternMachine <highlight><bold>320</bold></highlight> also manages several administrative functions through its EnterpriseTrackerBeanContainer interface <highlight><bold>310</bold></highlight>. For example, using EnterpriseTrackerBeanContainer interface <highlight><bold>310</bold></highlight>, TrackerBeanPatternMachine <highlight><bold>320</bold></highlight> causes the entire Enterprise TrackerBean Container <highlight><bold>300</bold></highlight> to be: (a) started; (b) shutdown; (c) queried for currently deployed DeferredResponse components; (d) requested to deploy additional component deployment files into the container; and (e) queried for historic occurrences (i.e., to provide an audit trail of various types) in accordance with methods that are well known to those of ordinary skill in the art. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> In accordance with this embodiment of the present invention, DeploymentCoordinator <highlight><bold>330</bold></highlight> handles deployment of new TrackerBeans and tracking point networks. DeploymentCoordinator <highlight><bold>330</bold></highlight> uses TrackerBeanCoordinator <highlight><bold>340</bold></highlight> to store the deployed information. TrackerBeanCoordinator <highlight><bold>340</bold></highlight> also coordinates runtime actions of the TrackerBeans and the tracking points in a manner to be described in detail below. TrackerBeanCoordinator <highlight><bold>340</bold></highlight> uses two dictionaries, TrackerBeans dictionary <highlight><bold>150</bold></highlight> and TrackingPointNetworks dictionary <highlight><bold>360</bold></highlight> to store deployed TrackerBeans and tracking point networks, respectively. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> In accordance with this embodiment of the present invention, at run time, DeploymentCoordinator <highlight><bold>330</bold></highlight> receives deployment files utilizing any one of a number of methods that are well known to those of ordinary skill in the art. As will be described in detail below, a deployment file comprises one or more tracking components along with a deployment descriptor text file (see <cross-reference target="DRAWINGS">FIG. 3</cross-reference>) that gives declarative instructions to ETB Container <highlight><bold>300</bold></highlight> for each component. For example, and without limitation, DeploymentCoordinator <highlight><bold>330</bold></highlight> can poll a predetermined subdirectory of Enterprise TrackerBean Container <highlight><bold>300</bold></highlight> for the presence of new deployment files; or DeploymentCoordinator <highlight><bold>330</bold></highlight> can be invoked directly by way of an Enterprise JavaBean SessionBean that represents DeploymentCoordinator <highlight><bold>330</bold></highlight> in accordance with methods that are well known to those of ordinary skill in the art; or a new deployment file may be handed to TrackerBeanPatternMachine <highlight><bold>320</bold></highlight> using its EnterpriseTrackerBeanContainer interface <highlight><bold>310</bold></highlight>. Whenever DeploymentCoordinator <highlight><bold>330</bold></highlight> detects a new TrackerBean deployment file, it reads each of the components in the deployment file, along with the component&apos;s associated deployment descriptors. In accordance with this embodiment of the present invention, the components read by DeploymentCoordinator <highlight><bold>330</bold></highlight> may either be a class or a serialized component instance. However, whenever the component read is a class, the class is instantiated in accordance with methods that are well known to those of ordinary skill in the art. In accordance with one embodiment of the present invention, a deployment descriptor for a TrackerBean is an XML file that comprises elements that describe the name and type of the TrackerBean. The file also lists details of input and output ports of the TrackerBean. <cross-reference target="DRAWINGS">FIG. 9</cross-reference> shows a block diagram of an XML grammar structure of a TrackerBean deployment descriptor that is fabricated in accordance with the present invention. Based on the information provided in the TrackerBean deployment descriptor, DeploymentCoordinator <highlight><bold>330</bold></highlight> creates the component in accordance with any one of a number of methods that are well known to those of ordinary skill in the art, and uses TrackerBeanCoordinator <highlight><bold>340</bold></highlight> to add it to TrackerBeans dictionary <highlight><bold>350</bold></highlight> contained inside TrackerBeanCoordinator <highlight><bold>340</bold></highlight> in accordance with any one of a number of methods that are well known to those of ordinary skill in the art. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 11</cross-reference> shows a block diagram of an architecture of TrackerBeanTreeNode <highlight><bold>380</bold></highlight> that is stored within TrackerBeans dictionary <highlight><bold>350</bold></highlight> shown in <cross-reference target="DRAWINGS">FIG. 8</cross-reference>. The nodes shown in <cross-reference target="DRAWINGS">FIG. 11</cross-reference>, contain information about deployed a TrackerBean and its input and output ports. For example, in accordance with the embodiment shown in <cross-reference target="DRAWINGS">FIG. 11</cross-reference>, each TrackerBeanTreeNode object (for example, TrackerBeanTreeNode object <highlight><bold>400</bold></highlight>) comprises: (a) a TrackerBean object (for example, TrackerBean object ) to which it refers through an interface (for example, TrackerBean interface <highlight><bold>410</bold></highlight>); (b) an inputs vector (for example, inputs vector <highlight><bold>440</bold></highlight>) which comprises information regarding all of the referred TrackerBean&apos;s input ports; and (c) an outputs vector (for example, outputs vector <highlight><bold>430</bold></highlight>) which comprises information regarding all of the referred TrackerBean&apos;s output ports. In accordance with one embodiment of the present invention, each input and output port of a TrackerBean that is described in the tracker bean deployment descriptor is instantiated as a TrackingPointNode object (for example, TrackingPointNode object <highlight><bold>450</bold></highlight> and TrackingPointNode object <highlight><bold>460</bold></highlight>, respectively), and added to the input and output vectors (for example, inputs vector <highlight><bold>440</bold></highlight> and outputs vector <highlight><bold>430</bold></highlight>) in accordance with any one of a number of methods that are well known to those of ordinary skill in the art. In accordance with this embodiment of the present invention, a TrackingPointNode object (for example, TrackingPointNode object <highlight><bold>450</bold></highlight> or TrackingPointNode object <highlight><bold>460</bold></highlight>) comprises an instance of an object that conforms to a TrackingPoint interface (for example, TrackingPoint interface <highlight><bold>475</bold></highlight> or TrackingPoint interface <highlight><bold>485</bold></highlight>); an embodiment of a TrackingPoint interface will be described in detail below. In addition, the TackingPointNode object also comprises an empty vector called &ldquo;connections&rdquo; at creation time. In accordance with this embodiment, this vector is used to store all connections for a given tracking point by DeploymentCoordinator <highlight><bold>330</bold></highlight> after it reads the tracking point network deployment descriptor. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> Whenever DeploymentCoordinator <highlight><bold>330</bold></highlight> detects a new TrackingPointNetwork deployment file, it reads the network deployment file, and it creates a TrackingPointNetwork object (for example, TrackingPointNetwork object <highlight><bold>370</bold></highlight>) in accordance with any one of a number of methods that are well known to those of ordinary skill in the art. DeploymentCoordinator <highlight><bold>330</bold></highlight> uses TrackerBeanCoordinator <highlight><bold>340</bold></highlight> to add the TrackingPointNetwork object (for example, TrackingPointNetwork object <highlight><bold>370</bold></highlight>) to TrackingPointNetworks dictionary <highlight><bold>360</bold></highlight> contained inside TrackerBeanCoordinator <highlight><bold>340</bold></highlight> in accordance with any one of a number of methods that are well known to those of ordinary skill in the art. A deployment descriptor for a tracking point network comprises information about: (a) tracking points in a network; and (b) connections between the tracking points. In addition, the deployment descriptor may also contain a synchronous update frequency for forced connections. <cross-reference target="DRAWINGS">FIG. 10</cross-reference> shows a block diagram of an XML grammar structure of a tracking point network deployment descriptor that is fabricated in accordance with the present invention. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> In accordance with one embodiment of the present invention, TrackingPointNetworks dictionary <highlight><bold>360</bold></highlight> comprises all TrackingPointNetwork objects that comprise TrackerBeans from ETB Container <highlight><bold>300</bold></highlight>. In accordance with one embodiment of the present invention, while loading a TrackingPointNetwork deployment descriptor and creating the tracking point network, DeploymentCoordinator <highlight><bold>330</bold></highlight> checks for correctness of: (a) the network topology; (b) the directional compatibility of connections (for example, in accordance with one embodiment of the present invention, connections start at an output port and end at an input port); and (c) connection types (pull, push or force), which connection types will be described in detail below. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 12</cross-reference> shows a block diagram of an interaction between an architecture of a TrackerBeanTreeNode (for example, TrackerBeanTreeNode <highlight><bold>400</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 11</cross-reference>) that is stored in a TrackerBeans dictionary (for example, TrackerBeans dictionary <highlight><bold>350</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 8</cross-reference>) and an architecture of a TrackerPointNetwork (for example, TrackingPointNetwork <highlight><bold>370</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 8</cross-reference>) that is stored in a TrackerPointNetworks dictionary (for example, TrackerPointNetworks dictionary <highlight><bold>360</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 8</cross-reference>). As shown in <cross-reference target="DRAWINGS">FIG. 12</cross-reference>, while creating a tracking point network, DeploymentCoordinator <highlight><bold>330</bold></highlight> stores it using a DefaultTreeModel object (for example, DefaultTreeModel object <highlight><bold>510</bold></highlight>) that uses nodes that conform to JDK&apos;s TreeNode interface (for example, TreeNode interface <highlight><bold>520</bold></highlight>). In accordance with this embodiment of the present invention, during the construction of the DefaultTreeModel object, (for example, DefauItTreeModel object <highlight><bold>510</bold></highlight>), DeploymentCoordinator <highlight><bold>330</bold></highlight> stores connection information for each tracking point in corresponding TrackingPointNode objects (for example, TrackingPointNode objects <highlight><bold>520</bold></highlight> and <highlight><bold>530</bold></highlight>) contained inside these TrackerBeanTreeNode objects (for example, TrackerBeanTreeNode object <highlight><bold>540</bold></highlight>. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> ETB Container <highlight><bold>300</bold></highlight> does not allow any client to access a deployed tracking component directly. However, ETB Container <highlight><bold>300</bold></highlight> generates TrackingPoint client interfaces for each input port and output port on the tracking component for a client to use to access the tracking component. In one embodiment of the present invention, ETB Container <highlight><bold>300</bold></highlight> stores the TrackingPoint client interfaces in a directory service at a location that is accessed using a name assigned to the tracking component in the deployment descriptor concatenated with a name assigned to the input port or the output port in the deployment descriptor. <cross-reference target="DRAWINGS">FIG. 4</cross-reference> shows a block diagram of tracking component instances disposed in an Enterprise TrackerBean Container along with their associated TrackingPoint objects for their input and output ports. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> Given the above-described architecture and deployment procedure, an embodiment of the present invention, for example, ETB Container <highlight><bold>300</bold></highlight> obtains all the static information it needs to organize itself, and to process the information in real-time. In accordance with this embodiment of the present invention, during real-time operation, TrackerBeans that track information on other systems synchronously or asynchronously gather information and output it to other TrackerBeans that either display the information in a useful way or do some useful analysis on them. The information flow may happen asynchronously (i.e., initiated by a TrackerBean) or synchronously (i.e., initiated by the ETB Container). </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> In accordance with this embodiment of the present invention, ETB Container <highlight><bold>300</bold></highlight> obtains a connection type (connection types will be described in detail below) by calling the issynchronouso method on the start and end tracking points of a connection. Based on boolean answers returned by the tracking points, the connection type can be determined using the following table.  
<table-cwu id="TABLE-US-00001">
<number>1</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Connection types based on a return value of the</entry>
</row>
<row>
<entry>isSynchronous( ) method</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="77PT" align="center"/>
<colspec colname="2" colwidth="84PT" align="center"/>
<colspec colname="3" colwidth="56PT" align="center"/>
<tbody valign="top">
<row>
<entry>Return value: start point</entry>
<entry>Return value: end point</entry>
<entry>Connection type</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>True</entry>
<entry>True</entry>
<entry>Force</entry>
</row>
<row>
<entry>True</entry>
<entry>False</entry>
<entry>Pull</entry>
</row>
<row>
<entry>False</entry>
<entry>True</entry>
<entry>Push</entry>
</row>
<row>
<entry>False</entry>
<entry>False</entry>
<entry>ERROR</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> As one can readily appreciate from the above, if both tracking points return a False reply, the connection type is undefined (an error condition). In accordance with one embodiment of the present invention, DeploymentCoordinator <highlight><bold>330</bold></highlight> reports such cases as errors. An update frequency for force connections is declared in a TrackingPoint Network deployment descriptor. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> In accordance with this embodiment, whenever an asynchronous output occurs, ETB Container <highlight><bold>300</bold></highlight> synchronously calls the connected input Trackingpoint objects to insert the new data. Similarly, whenever an asynchronous input occurs, ETB Container <highlight><bold>300</bold></highlight> first synchronously calls the connected output TrackingPoint object for its current Track object. ETB Container <highlight><bold>300</bold></highlight> can easily process data flow when both the input and output tracking points of a connection are inside it. However, if either one of the tracking points are inside a different container, data flow between them is achieved using EnterpriseTrackerBeanContainer interface <highlight><bold>310</bold></highlight> which comprises, but is not limited to, a pushTrack( ) and a pullTrack( ) method with signatures set forth below. </paragraph>
<paragraph id="P-0038" lvl="2"><number>&lsqb;0038&rsqb;</number> void pushTrack(String aTrackingPointName, Track aTrack) throws </paragraph>
<paragraph id="P-0039" lvl="2"><number>&lsqb;0039&rsqb;</number> RemoteException; </paragraph>
<paragraph id="P-0040" lvl="2"><number>&lsqb;0040&rsqb;</number> Track pullTrack(String aTrackingPointName) throws RemoteException; </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> Using the pushTrack( ) and pullTrack( ) methods, an ETB container can push and pull Tracks to another ETB Container to enable necessary data flow in a distributed deployment embodiment of the present invention. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> The following describes tracking components that are fabricated in accordance with embodiments of the present invention. <cross-reference target="DRAWINGS">FIG. 5</cross-reference> shows a block diagram of a TrackerBean Object Model that illustrates an input and output port paradigm. Each tracking component (for example, embodied as an TrackerBean) must be coded to comply with a TrackerBean interface (to be described in detail below), and must designate input ports and output ports having distinct names. In accordance with one embodiment of the present invention, a tracking component deployed inside an embodiment of a tracking component manager, as shown in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>, has zero or more input ports and zero or more output ports. In accordance with one embodiment of the present invention, a TrackerBean may monitor an application and provide the monitored information as its output to other TrackerBeans. Such a TrackerBean would have only output ports and no input ports, see <cross-reference target="DRAWINGS">FIG. 5</cross-reference><highlight><italic>a</italic></highlight>. In accordance with one embodiment of the present invention, a TrackerBean may take outputs from other TrackerBeans and present them as graphs or charts to a user. Such TrackerBeans have only input ports and no output ports, see <cross-reference target="DRAWINGS">FIG. 5B</cross-reference>. In accordance with one embodiment of the present invention, a TrackerBean may gather outputs of other TrackerBeans and apply mathematical calculations on the acquired information and output the results to other TrackerBeans. Such TrackerBeans have both input and output ports, see <cross-reference target="DRAWINGS">FIG. 5</cross-reference><highlight><italic>c. </italic></highlight></paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> Information flows between input ports and output ports of different TrackerBeans. In accordance with some embodiments of the present invention, as described above, the tracking component manager, for example, the ETB Container provides facilities for two modes of information flow between ports, i.e., a synchronous mode of information flow and an asynchronous mode of information flow. In a synchronous mode, the ETB Container may force output by invoking a syncOutputNext( ) call on a TrackerBean. In an asynchronous mode, a TrackerBean may asynchronously make its output available to other components by invoking an asyncOutputNext( ) call on the ETB container. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> In accordance with one embodiment of the present invention, the ETB Container uses a syncprocess( ) method to initiate a container-managed schedule for initiating processing on every deployed TrackerBean at a set frequency. The syncProcess( ) method is used for processing outside the immediate scope of data flow. However, such processing may cause an asynchronous data flow. For example, it could be the cause of asynchronous output or input. The method returns a boolean value to let the ETB Container know whether it failed or not (tracking components may ultimately require a connection to external systems, and this connection or other preparatory processing may fail). It is expected that some tracking component output will denote the specifics of the problem. In any case, the ETB Container must know that the syncProcess( ) method processing did not occur correctly. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> Tracking component developers must write class code that conforms to a TrackerBean interface. </paragraph>
<paragraph id="P-0046" lvl="2"><number>&lsqb;0046&rsqb;</number> interface TrackerBean </paragraph>
<paragraph id="P-0047" lvl="2"><number>&lsqb;0047&rsqb;</number> &lcub;</paragraph>
<paragraph id="P-0048" lvl="2"><number>&lsqb;0048&rsqb;</number> void setTrackerContext(TrackerContext aTrackerContext); </paragraph>
<paragraph id="P-0049" lvl="2"><number>&lsqb;0049&rsqb;</number> Dictionary getInputDescriptions( ); </paragraph>
<paragraph id="P-0050" lvl="2"><number>&lsqb;0050&rsqb;</number> Dictionary getOutputDescriptions( ); </paragraph>
<paragraph id="P-0051" lvl="2"><number>&lsqb;0051&rsqb;</number> void syncInputNext(String anInputName, Track aTrack); </paragraph>
<paragraph id="P-0052" lvl="2"><number>&lsqb;0052&rsqb;</number> Track syncOutputNext(String anOutputName); </paragraph>
<paragraph id="P-0053" lvl="2"><number>&lsqb;0053&rsqb;</number> boolean syncProcess( ); </paragraph>
<paragraph id="P-0054" lvl="2"><number>&lsqb;0054&rsqb;</number> &rcub;</paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> In accordance with one embodiment of the present invention, the following interfaces are provided by the ETB Container: </paragraph>
<paragraph id="P-0056" lvl="2"><number>&lsqb;0056&rsqb;</number> interface Track </paragraph>
<paragraph id="P-0057" lvl="2"><number>&lsqb;0057&rsqb;</number> &lcub;</paragraph>
<paragraph id="P-0058" lvl="2"><number>&lsqb;0058&rsqb;</number> String getSymbol( ); </paragraph>
<paragraph id="P-0059" lvl="2"><number>&lsqb;0059&rsqb;</number> Integer getQuality( ); </paragraph>
<paragraph id="P-0060" lvl="2"><number>&lsqb;0060&rsqb;</number> Object getData( ); </paragraph>
<paragraph id="P-0061" lvl="2"><number>&lsqb;0061&rsqb;</number> &rcub;</paragraph>
<paragraph id="P-0062" lvl="2"><number>&lsqb;0062&rsqb;</number> interface TrackerContext </paragraph>
<paragraph id="P-0063" lvl="2"><number>&lsqb;0063&rsqb;</number> &lcub;</paragraph>
<paragraph id="P-0064" lvl="2"><number>&lsqb;0064&rsqb;</number> void asyncOutputNext(String aName, Track aTrack); </paragraph>
<paragraph id="P-0065" lvl="2"><number>&lsqb;0065&rsqb;</number> Track asyncInputNext(String aName); </paragraph>
<paragraph id="P-0066" lvl="2"><number>&lsqb;0066&rsqb;</number> &rcub;</paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> As set forth above, the TrackerBean interface comprises: (a) methods to access its input and output ports (for example, getInputDescriptions( ), getOutputDescriptions( )); and (b) methods for data flow (for example, syncInputNext( ), syncOutputNext( ), syncprocess( )). In accordance with one embodiment of the present invention, ETB Container <highlight><bold>300</bold></highlight> uses a method (for example, setTrackerConext( )) to provide a mechanism for a TrackerBean to invoke methods on ETB Container <highlight><bold>300</bold></highlight>. In accordance with this embodiment of the present invention, this information, i.e., which method to invoke, is provided to the TrackerBean, for example, by DeploymentCoordinator <highlight><bold>330</bold></highlight>, when the component, for example, the TrackerBean, is deployed into ETB Container <highlight><bold>300</bold></highlight>. As set forth above, the TrackerContext interface comprises methods that can be used by a TrackerBean to invoke methods on ETB Container <highlight><bold>300</bold></highlight> to output data asynchronously. Further, the interface Track, set forth above, is an encapsulation of information that is being tracked. Thus, as one can readily appreciate from this, Track objects are primarily data objects associated with a symbol that provide a meaningful name to the data, if necessary. In accordance with other embodiments of the present invention, Tracks may also include quality attributes that provide indications of whether data is stale (for example, quality &equals;0) or not (for example, quality &equals;1). </paragraph>
<paragraph id="P-0068" lvl="0"><number>&lsqb;0068&rsqb;</number> Component developers may write classes to configure the tracking components that they develop. For example, TrackerBean developers may code TrackerBeans to adhere to any one of the following three configurator interfaces, the last of which one is JMX compliant. It should be understood however, that, although three configurator interfaces are disclosed, embodiments of the present invention are not limited thereto. </paragraph>
<paragraph id="P-0069" lvl="2"><number>&lsqb;0069&rsqb;</number> interface SimpleConfigurator </paragraph>
<paragraph id="P-0070" lvl="2"><number>&lsqb;0070&rsqb;</number> &lcub;</paragraph>
<paragraph id="P-0071" lvl="2"><number>&lsqb;0071&rsqb;</number> Dictionary get( ); </paragraph>
<paragraph id="P-0072" lvl="2"><number>&lsqb;0072&rsqb;</number> &rcub;</paragraph>
<paragraph id="P-0073" lvl="2"><number>&lsqb;0073&rsqb;</number> interface ServeletConfigurator </paragraph>
<paragraph id="P-0074" lvl="2"><number>&lsqb;0074&rsqb;</number> &lcub;</paragraph>
<paragraph id="P-0075" lvl="2"><number>&lsqb;0075&rsqb;</number> java.servlet.Servlet get( ); </paragraph>
<paragraph id="P-0076" lvl="2"><number>&lsqb;0076&rsqb;</number> &rcub;</paragraph>
<paragraph id="P-0077" lvl="2"><number>&lsqb;0077&rsqb;</number> interface &lt;Name of tracking component class&gt;MBean </paragraph>
<paragraph id="P-0078" lvl="2"><number>&lsqb;0078&rsqb;</number> &lcub;</paragraph>
<paragraph id="P-0079" lvl="2"><number>&lsqb;0079&rsqb;</number> . . . . . . &lt;custom configuration methods &gt;</paragraph>
<paragraph id="P-0080" lvl="2"><number>&lsqb;0080&rsqb;</number> &rcub;</paragraph>
<paragraph id="P-0081" lvl="0"><number>&lsqb;0081&rsqb;</number> Thus, a deployed tracking component can be configure, among other ways, using any one of the following three types of configurators: </paragraph>
<paragraph id="P-0082" lvl="2"><number>&lsqb;0082&rsqb;</number> <highlight><bold>1</bold></highlight>) SimpleConfigurator: Uses parameter &lt;-&gt; value pairs. When this configurator is used, a web page to enter configuration parameters is automatically generated by ETB Container <highlight><bold>300</bold></highlight> in accordance with any one of a number of methods that are well known to those of ordinary skill in the art. </paragraph>
<paragraph id="P-0083" lvl="2"><number>&lsqb;0083&rsqb;</number> <highlight><bold>2</bold></highlight>) ServletConfigurator: For example, this uses a Java servlet based configurator. </paragraph>
<paragraph id="P-0084" lvl="2"><number>&lsqb;0084&rsqb;</number> <highlight><bold>3</bold></highlight>) JMX (Java Management Extension Standard) configurators </paragraph>
<paragraph id="P-0085" lvl="0"><number>&lsqb;0085&rsqb;</number> In accordance with one embodiment of the present invention, at deployment time, ETB Container <highlight><bold>300</bold></highlight> determines which type of configurator to use for a tracking component that is being deployed. In accordance with one embodiment of the present invention, ETB Container <highlight><bold>300</bold></highlight> will use the SimpleConfigurator interface first, if it exists, then, it will then a ServletConfigurator interface, and lastly, it will use an MBean interface. As such, an interface with higher priority than the other interfaces will be employed for configuration, while ignoring lower priority configuration interfaces. </paragraph>
<paragraph id="P-0086" lvl="0"><number>&lsqb;0086&rsqb;</number> In accordance with one embodiment of the present invention, ETB Container <highlight><bold>300</bold></highlight> automatically generates a configuration GUI, in accordance with any one of a number of methods that are well known to those of ordinary skill in the art, that can be used to configure individual TrackerBeans based on the configurator interface it finds for a TrackerBean. <cross-reference target="DRAWINGS">FIG. 7</cross-reference> shows a TrackerBean configurator user interface that displays a source of tracking information for TrackerBean named &ldquo;Ross&rdquo;. In accordance with this embodiment of the present invention, each of the configurator interfaces presents a name-value pair paradigm. As such, ETB Container <highlight><bold>300</bold></highlight> can generate a web page based on a list of name value pairs in accordance with any one of a number of methods that are well known to those of ordinary skill in the art. In addition, in accordance with one embodiment of the present invention, the ServeletConfigurator interface produces a Servlet that provides a tracking component developer full control over the development of a configuration GUI, if desired. </paragraph>
<paragraph id="P-0087" lvl="0"><number>&lsqb;0087&rsqb;</number> As was described above, ETB Container <highlight><bold>300</bold></highlight> generates a tracking point for each input port and each output port of a TrackerBean. Further, in accordance with some embodiments of the present invention, these tracking points are connected to each other to form a network of tracking points. Still further, in accordance with some embodiments of the present invention, each tracking point may have multiple connections. Yet still further, in accordance with some embodiments of the present invention, connections are always directional, i.e., they start at a TrackerBean output port (denoted, for example, as a source) and they end at a TrackerBean input port (denoted, for example, as a destination). In accordance with some embodiments of the present invention, ETB Container <highlight><bold>300</bold></highlight> advantageously supports tracking point networks of any connection topology (for example, and without limitation, tree, circular, and so forth). </paragraph>
<paragraph id="P-0088" lvl="0"><number>&lsqb;0088&rsqb;</number> In accordance with one embodiment of the present invention, there are three types of connections: (a) pull; (b) push; and (c) force. Each type of connection operationally involves various combinations of synchronous and asynchronous input and output data flow. The following table shows the operational mechanics of data flow for the above connection types (also refer to <cross-reference target="DRAWINGS">FIG. 6</cross-reference> which shows a block diagram of TrackerBeans deployed in distributed ETB Containers wherein information flows are identified for different connection types).  
<table-cwu id="TABLE-US-00002">
<number>2</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="56PT" align="center"/>
<colspec colname="2" colwidth="112PT" align="left"/>
<colspec colname="3" colwidth="98PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Connection Type</entry>
<entry>1<highlight><superscript>st</superscript></highlight></entry>
<entry>2<highlight><superscript>nd</superscript></highlight></entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>Pull</entry>
<entry>Destination TrackerBean calls</entry>
<entry>Container calls Source&apos;s</entry>
</row>
<row>
<entry></entry>
<entry>TrackerContext.asyncInputNext( )</entry>
<entry>TrackerBean.syncOutputNext( )</entry>
</row>
<row>
<entry>Push</entry>
<entry>Source TrackerBean calls</entry>
<entry>Container calls Destination&apos;s</entry>
</row>
<row>
<entry></entry>
<entry>TrackerContext.asyncOutputNext( )</entry>
<entry>TrackerBean.syncInputNext( )</entry>
</row>
<row>
<entry>Force</entry>
<entry>Container calls Source&apos;s</entry>
<entry>Container calls Destination&apos;s</entry>
</row>
<row>
<entry></entry>
<entry>TrackerBean.syncOutputNext( )</entry>
<entry>TrackerBean.syncInputNext( )</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0089" lvl="0"><number>&lsqb;0089&rsqb;</number> In accordance with one embodiment of the present invention, a synchronous update frequency of the Force connection type is specified during deployment of a tracking point network. </paragraph>
<paragraph id="P-0090" lvl="0"><number>&lsqb;0090&rsqb;</number> Clients interested in tracking information can do so by using tracking point objects. In accordance with one embodiment of the present invention, tracking point objects are accessible through an interface known as TrackingPoint. Each TrackingPoint represents one input port or one output port of a TrackerBean. In accordance with one embodiment of the present invention, ETB Container <highlight><bold>300</bold></highlight> automatically creates and stores these tracking point interface instances, for example, inside a directory service in accordance with any one of a number of methods that are well known to those of ordinary skill in the art. Clients can then access a TrackingPoint, using a name of the TrackingPoint, from the directory service, without actually knowing which container contains the TrackingPoint. In accordance with one embodiment of the present invention, ETB Container <highlight><bold>300</bold></highlight> stores a state of tracking points inside a persistent store, if requested by a TrackerBean component at deployment time. Further, in accordance with one embodiment of the present invention, a client can register with a TrackingPoint to be notified asynchronously if its data changes. This is done using TrackingPoint and TrackingPointListener interfaces. These interfaces are set forth below. </paragraph>
<paragraph id="P-0091" lvl="2"><number>&lsqb;0091&rsqb;</number> interface TrackingPointObject </paragraph>
<paragraph id="P-0092" lvl="2"><number>&lsqb;0092&rsqb;</number> &lcub;</paragraph>
<paragraph id="P-0093" lvl="2"><number>&lsqb;0093&rsqb;</number> void addTrackingPointListener(TrackingPointListener aListener); </paragraph>
<paragraph id="P-0094" lvl="2"><number>&lsqb;0094&rsqb;</number> Track syncTrackNext( ); </paragraph>
<paragraph id="P-0095" lvl="2"><number>&lsqb;0095&rsqb;</number> boolean isSynchronous( ); </paragraph>
<paragraph id="P-0096" lvl="2"><number>&lsqb;0096&rsqb;</number> &rcub;</paragraph>
<paragraph id="P-0097" lvl="2"><number>&lsqb;0097&rsqb;</number> interface TrackingPointListener extends EventListener </paragraph>
<paragraph id="P-0098" lvl="2"><number>&lsqb;0098&rsqb;</number> &lcub;</paragraph>
<paragraph id="P-0099" lvl="2"><number>&lsqb;0099&rsqb;</number> void asyncTrackNext(Track aTrack); </paragraph>
<paragraph id="P-0100" lvl="2"><number>&lsqb;0100&rsqb;</number> &rcub;</paragraph>
<paragraph id="P-0101" lvl="0"><number>&lsqb;0101&rsqb;</number> The method isSynchronous( ) indicates whether the tracking point supports a synchronous mode of data flow. If the tracking point supports a synchronous mode of data flow, a client can read a value inside a tracking point by invoking the syncTrackNext( ) method. If the tracking point supports an asynchronous mode of data flow, a client can </paragraph>
<paragraph id="P-0102" lvl="0"><number>&lsqb;0102&rsqb;</number> register itself to receive the asynchronous notification using the addTrackingPointListener( ) method. Whenever the tracking point data gets updated, ETB Container <highlight><bold>300</bold></highlight> will notify the client of the change using the client&apos;s asyncTrackNext( ) method. </paragraph>
<paragraph id="P-0103" lvl="0"><number>&lsqb;0103&rsqb;</number> The following describes the deployment of Enterprise TrackerBeans. In accordance with one embodiment of the present invention, one or more tracking components are packed into a single file, along with a deployment descriptor text file that provides declarative instructions for each component to the container. This file is deployed into the container in the manner described above. However, as was described above, in accordance with one embodiment of the present invention, some tracking components may be specified to represent a tracking point network. In this case, for example, the deployment descriptor would comprise tracking point names and a description of paired connections, each with a source tracking point name and destination tracking point name. </paragraph>
<paragraph id="P-0104" lvl="0"><number>&lsqb;0104&rsqb;</number> When tracking components have been coded, they are ready for deployment. In accordance with one embodiment of the present invention, in order to deploy one or more tracking components at the same time, their executable file forms are put into a single file such as a ZIP file or other file format that is able to maintain an internal directory structure and store one or more embedded files. Each tracking component may reside anywhere in the internal directory structure, and components may be grouped into the same or multiple deployment files for organizational purposes. An example of a component deployment file is shown in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>. Also shown in <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a text file known as a deployment descriptor that is located, for example, and without limitation, in an internal directory &ldquo;META-INF&rdquo;. The deployment descriptor provides deployment configuration instructions to the container for each tracking component. In accordance with a preferred embodiment of the present invention, XML is used to declare such deployment instructions. Specifically, deployment instructions for each tracking component comprises: a string designating a directory name for the component (for example, its JNDI name); a string designating an internal deployment file path name to a file containing executable code for the component; a string designating an internal deployment file path name to a serialized state of an instance; a string designating a name of the component model (for example, Java, Microsoft COM, CORBA, or any other component models); an integer designating a maximum number of threads that the ETB Container will construct for the component, strings designating names of methods to be made available for tracking; additional strings per method declaring names of parameters; additional strings per method declaring names of two or more outputs for cases where there is more than one output; and additional strings specifying a parameter, a parameter class. </paragraph>
<paragraph id="P-0105" lvl="0"><number>&lsqb;0105&rsqb;</number> In accordance with one embodiment of the present invention, Enterprise TrackerBeans may be stored in Enterprise TrackerBean JAR files also referred to herein as &ldquo;ETB JAR&rdquo; files (the configuration of the Enterprise TrackerBeans described by an ETB Deployment Descriptor is also included within the ETB JAR file). Advantageously, this embodiment enables Enterprise TrackerBeans to be saved, and then deployed at any time. </paragraph>
<paragraph id="P-0106" lvl="0"><number>&lsqb;0106&rsqb;</number> The following describes ETB JAR Resource files. In accordance with one embodiment of the present invention, there are three categories of resource files: (a) category <highlight><bold>1</bold></highlight> relates to support files (for example, external native programs or configuration files); (b) category <highlight><bold>2</bold></highlight> relates to JNI native libraries (for example, dll or so files); and (c) category <highlight><bold>3</bold></highlight> relates to class and java files. </paragraph>
<paragraph id="P-0107" lvl="0"><number>&lsqb;0107&rsqb;</number> Category <highlight><bold>1</bold></highlight> files are stored in a JAR in a directory that corresponds to the bean name. For example, resources for the bean: t.verano.etb_bean.satellite.SatelliteReceiverBean should be stored in the JAR at resources/t/verano/etb_bean/satellite/SatelliteReceiverBean/. All files and any files in any subdirectories under this location will be extracted to %ETB_HOME%/respository/resources/t/verano/etb_bean/satellite/SatelliteReceiverBean/ where %ETB_HOME% is the directory that the ETB Container was installed. </paragraph>
<paragraph id="P-0108" lvl="0"><number>&lsqb;0108&rsqb;</number> Category <highlight><bold>2</bold></highlight> files are stored in a similar location. For the bean t.verano.etb_bean.satellite.SatelliteReceiverBean native libraries should be stored in the JAR at resources/t/verano/etb_bean/satellite/SatelliteReceiverBean/native. All files in this location are extracted to %ETB_HOME%/repository/resources/native/SatelliteReceiverBean/&lt;JAR_DATE&gt;/ where &lt;JAR_DATE&gt; is the date and time the jar was created. </paragraph>
<paragraph id="P-0109" lvl="0"><number>&lsqb;0109&rsqb;</number> Category <highlight><bold>3</bold></highlight> files are stored in the JAR normally, and according to the JavaBean specification. </paragraph>
<paragraph id="P-0110" lvl="0"><number>&lsqb;0110&rsqb;</number> The following describes how files are extracted at deployment time. In accordance with one embodiment of the present invention, resource files will be extracted from a JAR at deployment time or at ETB Container start time. If a resource file already exists, the file will be overwritten if the JAR was created after the last modified date of the file. Thus, if one modifies the file and then starts the ETB Container, the file will not be overwritten, However, if one deploys a newer version of the JAR, the file will be overwritten. At undeployment time (i.e., whenever the JAR is deleted) the resource files will be deleted. In addition, if the deployment descriptor does not include a bean&apos;s information, the bean&apos;s support files will not be extracted from the JAR file. </paragraph>
<paragraph id="P-0111" lvl="0"><number>&lsqb;0111&rsqb;</number> In accordance with one embodiment of the present invention, an Enterprise TrackingBean locates its support files at runtime by appending the bean name to a path to the location of a resources directory. For example, in one embodiment of the present invention, a system Java property variable &ldquo;etb.workarea&rdquo; is set to the location of the resources directory. For example, %ETB_HOME%/repository/resources. </paragraph>
<paragraph id="P-0112" lvl="0"><number>&lsqb;0112&rsqb;</number> The following describes the deployment of Enterprise TrackingPoint Networks. In accordance with one embodiment of the present invention, one or more TrackingPoint Networks are described within a single deployment file that provides connection information as well as declarative instructions for each network to ETB Container. This file is deployed into the ETB Container in the manner described above. </paragraph>
<paragraph id="P-0113" lvl="0"><number>&lsqb;0113&rsqb;</number> When TrackingPoint Networks have been described, they are ready for deployment. In accordance with one embodiment of the present invention, in order to deploy one or more TrackingPoint Networks at the same time, each is put into a single file such as, for example, a ZIP file or any other file format that is able to maintain an internal directory structure and store one or more embedded files. Each Trackingpoint Network may reside only in the META-INF subdirectory, but TrackingPoint Networks may be grouped into the same deployment file, or multiple deployment files, for organizational purposes. An example of a TrackingPoint Network deployment file would be the diagram shown in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>, except with components removed and potentially multiple deployment descriptors, where there would be one deployment descriptor text file for each TrackingPoint Network. Thus, each TrackingPoint Network deployment file comprises no components, and only one or more deployment descriptor text files in an internal directory &ldquo;META-INF&rdquo;. </paragraph>
<paragraph id="P-0114" lvl="0"><number>&lsqb;0114&rsqb;</number> The deployment descriptor provides connection instructions, as well as deployment configuration instructions, to the ETB Container for each Trackingpoint Network. In accordance with a preferred embodiment of the present invention, XML is used to declare such instructions. The structure of this deployment descriptor is depicted in <cross-reference target="DRAWINGS">FIG. 10</cross-reference>. Specifically, instructions for each trackingpoint and each trackingpoint connection must be listed. The instructions for each trackingpoint comprise: a string designating a directory name for the trackingpoint (for example, its JNDI name); and a Boolean declaring whether or not the trackingpoint should be persisted. The instructions for each trackingpoint-connection comprise: a string designating a directory name for the source trackingpoint; and a string designating a directory name for the destination trackingpoint. </paragraph>
<paragraph id="P-0115" lvl="0"><number>&lsqb;0115&rsqb;</number> In accordance with one embodiment of the present invention, Enterprise TrackingPoint Networks may be stored in Enterprise TrackingPoint JAR files also referred to herein as &ldquo;ETP JAR&rdquo;. Advantageously, this embodiment enables Enterprise TrackingPoint Networks to be saved, and then deployed at any time. </paragraph>
<paragraph id="P-0116" lvl="0"><number>&lsqb;0116&rsqb;</number> Those skilled in the art will recognize that the foregoing description has been presented for the sake of illustration and description only. As such, it is not intended to be exhaustive or to limit the invention to the precise form disclosed. For example, although embodiments of the present invention have been described using component managers which comprise Enterprise TrackerBean Containers and using components which comprise Enterprise TrackerBeans, those of ordinary skill in the art should readily appreciate that the present invention is not limited to such embodiments. In fact, it is within the spirit of the present invention to include any embodiment of component managers and components. For example, in some embodiments, deferred response may be any objects that support the execution of one or more associated methods as, for example, in object oriented programming. Further, the terms client, client system, and client subsystem also include terms such as, without limitation, client software system or client software subsystem. </paragraph>
<paragraph id="P-0117" lvl="0"><number>&lsqb;0117&rsqb;</number> Those skilled in the art will recognize that the foregoing description has been presented for the sake of illustration and description only. As such, it is not intended to be exhaustive or to limit the invention to the precise form disclosed. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A component manager that manages one or more tracking components, the component manager comprising: 
<claim-text>a deployer that generates a client interface for each tracking component output port, and deploys the client interface in a directory service, wherein each entry is a tracking point object. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The component manager of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein the deployer further: 
<claim-text>generates a client interface for each tracking component input port, and deploys the client interface in a directory service, wherein each entry is a tracking point object. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The component manager of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference> wherein: 
<claim-text>at least one output port is a synchronous output port. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The component manager of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference> wherein: 
<claim-text>at least one output port is an asynchronous output port. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The component manager of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference> wherein: 
<claim-text>at least one input port is a synchronous input port. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The component manager of <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference> wherein: 
<claim-text>at least one input port is an asynchronous input port. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The component manager of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference> wherein a client interface may be interacted with using a distributed communication protocol. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The component manager of <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference> wherein a client interface may be interacted with using a distributed communication protocol. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. A tracking component that comprises one or more output ports whose data values may be synchronously requested, wherein the data values may be any object type, and wherein a synchronous request for an output data value results in an invocation of a predetermined component method representing the output port that: (a) performs processing to obtain the output data value, or (b) returns an already gathered data value generated by an internal component process. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. A tracking component that comprises one or more input ports whose data values may be synchronously submitted, wherein the data values may be any object type, and wherein a synchronous request for submitting an input data value results in an invocation of a predetermined component method representing the input port that performs processing to: (a) store, (b) operate upon, or (c) transform a new input value. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. A tracking component that comprises one or more output ports whose data values may be asynchronously generated by the tracking component and received by a component manager, wherein the data values may be any object type. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. A tracking component that comprises one or more input ports whose data values may be asynchronously requested from the tracking component by a component manager, wherein the data values may be any object type. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The component manager of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference> which further comprises: 
<claim-text>a manager deployer that deploys one or more of a client interface representing an instance of the component manager, wherein each component manager may drive data to and from tracking components located in remote component manager instances interacting through interfaces of the remote component manager instances using a distributed communication protocol. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The component manager of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference> further comprises: 
<claim-text>a listener connector that registers a client to a tracking point using a predetermined Listener interface; and </claim-text>
<claim-text>a listener responder that invokes a predetermined method on the predetermined Listener interface whenever a new data value is input to the tracking point. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The component manager of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference> further comprises: 
<claim-text>a persister that persistently stores all data values input to a tracking point. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The component manager of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference> further comprises: 
<claim-text>a persister that receives information specifying predetermined data received by the component manager to be stored in persistent non-volatile memory. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The component manager of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference> further comprises: 
<claim-text>an invoker that invokes a predetermined method on a tracking component periodically based on a predetermined time interval. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The component manager of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference> wherein the deployer further: 
<claim-text>reads and deploys a file including component classes in the component manager. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The component manager of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference> wherein the deployer further: 
<claim-text>reads and deploys a file including component instances in the component manager. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The component manager of <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference> wherein the deployer further comprises: 
<claim-text>a deployment descriptor interpreter that reads a deployment descriptor included in a file wherein a synchronizing interval may be declared for each tracking component, which synchronizing interval determines the predetermined time interval. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The component manager of <dependent-claim-reference depends_on="CLM-00022">claim 20</dependent-claim-reference> wherein the deployer interpreter further: 
<claim-text>reads the deployment descriptor wherein synchronous inputs and outputs and asynchronous inputs and outputs are declared. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The component manager of <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference> wherein the deployer interpreter further: 
<claim-text>reads the deployment descriptor wherein a time interval for invoking a predetermined method periodically is specified. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The component manager of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference> further comprises a software component to operate on components implemented in one of the following component models: JavaBeans, Microsoft COM, and CORBA. </claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The component manager of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference> wherein the deployer further: 
<claim-text>reads and deploys a file including one or more tracking point deployment descriptors, each of which tracking point deployment descriptors includes a list of tracking point names and a description of paired tracking point connections, each of which paired connections having a source tracking point name and a destination tracking point name; and </claim-text>
<claim-text>matches tracking points generated by output and input ports attached to previously deployed tracking components. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. The component manager of <dependent-claim-reference depends_on="CLM-00022">claim 24</dependent-claim-reference> wherein: 
<claim-text>at least one output port is a synchronous output port; </claim-text>
<claim-text>at least one input port is a synchronous input port; and </claim-text>
<claim-text>the component manager further comprises a forced data transmitter that periodically synchronously requests data from a source synchronous output port and submits the data obtained to a destination synchronous input port based on a predetermined tracking point connection. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. The component manager of <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference> wherein the deployer interpreter further: 
<claim-text>reads the deployment descriptor wherein a time interval to transmit forced data periodically is specified. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. The component manager of <dependent-claim-reference depends_on="CLM-00022">claim 24</dependent-claim-reference> wherein: 
<claim-text>at least one output port is an asynchronous output port; </claim-text>
<claim-text>at least one input port is a synchronous input port; and </claim-text>
<claim-text>the component manager further comprises a push data transmitter that synchronously submits a data value to an input port of a tracking component represented by a predetermined tracking point destination whenever a corresponding predetermined tracking point source is an asynchronous output port that has generated a new data value. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. The component manager of <dependent-claim-reference depends_on="CLM-00022">claim 24</dependent-claim-reference> which further comprises: 
<claim-text>at least one output port is a asynchronous output port; </claim-text>
<claim-text>at least one input port is an asynchronous input port; and </claim-text>
<claim-text>the component manager further comprises a pull data transmitter that synchronously requests a data value from an output port of a tracking component represented by a predetermined tracking point source whenever a corresponding predetermined tracking point destination is an asynchronous input that has requested a new data value. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00029">
<claim-text><highlight><bold>29</bold></highlight>. The component manager of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference> further comprises: 
<claim-text>a configurator designator that discovers a configurator interface on each tracking component which provides names of configurable attributes that can modify behavior of a tracking component; and </claim-text>
<claim-text>a configurator manager that automatically constructs an executable file that represents an user interface that displays attribute values and receives user input to modify the attribute values. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00030">
<claim-text><highlight><bold>30</bold></highlight>. The component manager of <dependent-claim-reference depends_on="CLM-00022">claim 29</dependent-claim-reference> wherein the configurator manager further displays the generated configuration user interface showing the attribute values.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>8</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005166A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005166A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005166A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005166A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005166A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005166A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030005166A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030005166A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030005166A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00009">
<image id="EMI-D00009" file="US20030005166A1-20030102-D00009.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00010">
<image id="EMI-D00010" file="US20030005166A1-20030102-D00010.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00011">
<image id="EMI-D00011" file="US20030005166A1-20030102-D00011.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00012">
<image id="EMI-D00012" file="US20030005166A1-20030102-D00012.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
