<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030003908A1-20030102-D00000.TIF SYSTEM "US20030003908A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030003908A1-20030102-D00001.TIF SYSTEM "US20030003908A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030003908A1-20030102-D00002.TIF SYSTEM "US20030003908A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030003908A1-20030102-D00003.TIF SYSTEM "US20030003908A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030003908A1-20030102-D00004.TIF SYSTEM "US20030003908A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030003908A1-20030102-D00005.TIF SYSTEM "US20030003908A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030003908A1-20030102-D00006.TIF SYSTEM "US20030003908A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030003908A1-20030102-D00007.TIF SYSTEM "US20030003908A1-20030102-D00007.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030003908</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09892816</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010627</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>H04Q007/20</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>455</class>
<subclass>426000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Method and apparatus for storing data in flash memory</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Richard</given-name>
<middle-name>A.</middle-name>
<family-name>McGrew</family-name>
</name>
<residence>
<residence-us>
<city>Folsom</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Richard</given-name>
<middle-name>P.</middle-name>
<family-name>Garner</family-name>
</name>
<residence>
<residence-us>
<city>Cameron Park</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>BLAKELY SOKOLOFF TAYLOR &amp; ZAFMAN</name-1>
<name-2></name-2>
<address>
<address-1>12400 WILSHIRE BOULEVARD, SEVENTH FLOOR</address-1>
<city>LOS ANGELES</city>
<state>CA</state>
<postalcode>90025</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">In an embodiment, a method includes receiving a request to download data into flash memory. The method also includes halting the downloading of the data into the flash memory until the flash memory is initialized. The initialization includes storing pointers in a memory to different locations within the flash memory where the data is to be stored. Additionally, the method includes storing the data into the flash memory based on the pointers stored in the memory. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">FIELD OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> The invention relates to memory storage. More specifically, the invention relates to initializing flash memory and storing data therein. </paragraph>
</section>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> Flash memory is commonly used for applications that require a non-volatile memory to store code and data that must be retained when power to the memory is removed, but which can be re-written when necessary during operation. Flash memory is favored because it can be written and erased while in-circuit, and because it has read access times comparable to static random access memory (SRAM). </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> Current flash storage algorithms perform write operations as individual objects without regard for the size of the entire data being stored. Further, current storage algorithms typically scan the flash media before each write operation in order to find the location therein to put the data. This results in a significant time loss each time a write operation is called.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> Embodiments of the invention may be best understood by referring to the following description and accompanying drawings that illustrate such embodiments. The numbering scheme for the Figures included herein are such that the leading number for a given element in a Figure is associated with the number of the Figure. For example, device <highlight><bold>128</bold></highlight> can be located in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. However, element numbers are the same for those elements that are the same across different Figures. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> In the drawings: </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> illustrates portions of an apparatus for storing data into flash memory, according to embodiments of the present invention. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> illustrates a flow diagram of one embodiment for controlling writes to flash memory <highlight><bold>104</bold></highlight>, according to embodiments of the present invention. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> illustrates a flow diagram for initializing flash memory <highlight><bold>104</bold></highlight>, according to embodiments of the present invention. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> illustrates a flow diagram of one embodiment for receiving and storing of this data flow into device <highlight><bold>128</bold></highlight>, according to embodiments of the present invention. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> illustrates a flow diagram for writing data into flash memory <highlight><bold>104</bold></highlight>, according to embodiments of the present invention. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> illustrates a system that can incorporate embodiments of the present invention. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> illustrates an exemplary computer system comprising a processor having an instruction pipeline with hardware predication for initializing a flash memory device and storing data therein, according to embodiments of the present invention.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION </heading>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> In the following description, for purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be evident, however, to one skilled in the art that the present invention may be practiced without these specific details. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> illustrates portions of an apparatus for storing data into flash memory, according to embodiments of the present invention. In particular, <cross-reference target="DRAWINGS">FIG. 1</cross-reference> illustrates device <highlight><bold>128</bold></highlight>, which includes processor <highlight><bold>102</bold></highlight>, flash memory <highlight><bold>104</bold></highlight>, memory <highlight><bold>106</bold></highlight>, queue <highlight><bold>110</bold></highlight>, buffer unit <highlight><bold>108</bold></highlight>, initialize unit <highlight><bold>134</bold></highlight>, receive unit <highlight><bold>132</bold></highlight>, write flash unit <highlight><bold>136</bold></highlight> and write unit <highlight><bold>130</bold></highlight>, which are all coupled together. In an embodiment, initialize unit <highlight><bold>134</bold></highlight>, receive unit <highlight><bold>132</bold></highlight>, write flash unit <highlight><bold>136</bold></highlight> and write unit <highlight><bold>130</bold></highlight> can be processes or tasks that can reside within memory <highlight><bold>106</bold></highlight> and/or processor <highlight><bold>102</bold></highlight> and can be executed within processor <highlight><bold>102</bold></highlight>. However, embodiments of the present invention are not so limited, as initialize unit <highlight><bold>134</bold></highlight>, receive unit <highlight><bold>132</bold></highlight>, write flash unit <highlight><bold>136</bold></highlight> and write unit <highlight><bold>130</bold></highlight> can be different types of hardware (such as digital logic) executing the processing described therein. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> In one embodiment, device <highlight><bold>128</bold></highlight> is a cellular telephone. However, embodiments of the present invention are not so limited, as device <highlight><bold>128</bold></highlight> may be any device that includes flash memory. For example, device <highlight><bold>128</bold></highlight> may be a one-way pager, a two-way pager, a global positioning system (GPS) device, a vehicle entertainment system, a portable entertainment device, a personal data assistant (PDA), or any other type of computing device. In one embodiment, flash memory <highlight><bold>104</bold></highlight> is a flash memory device. In an embodiment, queue <highlight><bold>110</bold></highlight> is a first-in-first-out register array (FIFO); however, embodiments of the present invention are not so limited, as queue <highlight><bold>110</bold></highlight> may be any kind of storage unit. For example, queue <highlight><bold>110</bold></highlight> may be a stack-based register array. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> In one embodiment, buffer unit <highlight><bold>108</bold></highlight> contains a number of buffers, specifically, buffer <highlight><bold>112</bold></highlight>, buffer <highlight><bold>114</bold></highlight>, buffer <highlight><bold>116</bold></highlight>, buffer <highlight><bold>118</bold></highlight>, buffer <highlight><bold>120</bold></highlight>, and buffer <highlight><bold>122</bold></highlight>, which are buffers for the temporary storage of data to be input into flash memory <highlight><bold>104</bold></highlight>. The number of buffers within buffer unit <highlight><bold>108</bold></highlight> is by way of example and not by way of limitation, as buffer unit <highlight><bold>108</bold></highlight> may contain a greater or lesser number of buffers. In one embodiment, memory <highlight><bold>106</bold></highlight> is random access memory (RAM). </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> In an embodiment, queue <highlight><bold>110</bold></highlight> is also random access memory (RAM). In an embodiment, queue <highlight><bold>110</bold></highlight> is configurable to be of different sizes. In one such embodiment, the size of queue <highlight><bold>110</bold></highlight> can range from 1024 to 4096 bytes. Queue <highlight><bold>110</bold></highlight> is shown to be external from memory <highlight><bold>106</bold></highlight>. However, embodiments of the present invention are not so limited. For example, in another embodiment, queue <highlight><bold>110</bold></highlight> can be created and partitioned within memory <highlight><bold>106</bold></highlight>. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> Certain operations of device <highlight><bold>128</bold></highlight> will now be described in conjunction with the flowcharts of FIGS. <highlight><bold>2</bold></highlight>-<highlight><bold>5</bold></highlight>. <cross-reference target="DRAWINGS">FIG. 2</cross-reference> illustrates a flow diagram of one embodiment for controlling writes to flash memory <highlight><bold>104</bold></highlight>, according to embodiments of the present invention. Method <highlight><bold>201</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 2</cross-reference> commences with write unit <highlight><bold>130</bold></highlight> monitoring for the receipt of data to be stored in flash memory <highlight><bold>104</bold></highlight> from a device that is external to device <highlight><bold>128</bold></highlight> (hereinafter &ldquo;the external device&rdquo;), at process decision block <highlight><bold>202</bold></highlight>. Upon determining that no data is to be received, write unit <highlight><bold>130</bold></highlight> continues monitoring for the receipt of data, at process decision block <highlight><bold>202</bold></highlight>. In contrast, upon determining that there is data to be received, write unit <highlight><bold>130</bold></highlight> stops any current data flow into device <highlight><bold>128</bold></highlight>, at process block <highlight><bold>204</bold></highlight>. In an embodiment, this stoppage of data flow into device <highlight><bold>128</bold></highlight> includes the halting of operations by method <highlight><bold>401</bold></highlight>, which provides for the downloading of data into device <highlight><bold>128</bold></highlight> and is describe in more detail below in conjunction with <cross-reference target="DRAWINGS">FIG. 4</cross-reference>. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> Additionally, write unit <highlight><bold>130</bold></highlight> initializes flash memory <highlight><bold>104</bold></highlight> prior to receiving the data into device <highlight><bold>128</bold></highlight>, at process block <highlight><bold>206</bold></highlight>. <cross-reference target="DRAWINGS">FIG. 3</cross-reference> illustrates a flow diagram for initializing flash memory <highlight><bold>104</bold></highlight>, according to embodiments of the present invention. Method <highlight><bold>301</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 3</cross-reference> commences with initialize unit <highlight><bold>134</bold></highlight> locking queue <highlight><bold>110</bold></highlight>, at process block <highlight><bold>304</bold></highlight>. Accordingly, this locking of queue <highlight><bold>110</bold></highlight> precludes other units from inserting data or other tasks into queue <highlight><bold>110</bold></highlight> during the initialization of flash memory <highlight><bold>104</bold></highlight>. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> Initialize unit <highlight><bold>134</bold></highlight> determines whether queue <highlight><bold>110</bold></highlight> is empty, at process decision block <highlight><bold>308</bold></highlight>. Upon determining that queue <highlight><bold>110</bold></highlight> is not empty, initialize unit <highlight><bold>134</bold></highlight> waits a predetermined amount of time, at process block <highlight><bold>310</bold></highlight>, and again determines whether queue <highlight><bold>110</bold></highlight> is empty at process decision block <highlight><bold>308</bold></highlight>. However, embodiments of the present invention are not so limited, as initialize unit <highlight><bold>134</bold></highlight> can continue to check if queue <highlight><bold>110</bold></highlight> is empty, independent of a timer or predetermined amount of time. Conversely, upon determining that queue <highlight><bold>110</bold></highlight> is empty, initialize unit <highlight><bold>134</bold></highlight> determines the amount of free space in flash memory <highlight><bold>104</bold></highlight>, at process block <highlight><bold>312</bold></highlight>. In one embodiment, flash memory <highlight><bold>104</bold></highlight> includes a number of blocks for storage of data. In an embodiment, the size of the blocks within flash memory <highlight><bold>104</bold></highlight> is 64 kilobytes. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> In an embodiment, an array in memory <highlight><bold>106</bold></highlight> stores two values for each block within flash memory <highlight><bold>104</bold></highlight>. The first value indicates the number of bytes that are free, meaning that no data is stored therein, and can be written to. The second value indicates the number of bytes that are &ldquo;dirty&rdquo;, which are those bytes that include data but can be overwritten, and thus written to. Examples of &ldquo;dirty&rdquo; bytes could include data that expires after a predefined time period or is no longer used by units in device <highlight><bold>128</bold></highlight>, but remains therein because the data has not been overwritten. Accordingly, initialize unit <highlight><bold>134</bold></highlight> can traverse this array in memory <highlight><bold>106</bold></highlight> to determine the amount of free space within flash memory <highlight><bold>104</bold></highlight>. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> Initialize unit <highlight><bold>134</bold></highlight> determines whether the amount of free space in flash memory <highlight><bold>104</bold></highlight> is greater than or equal to the size of the data to be received into device <highlight><bold>128</bold></highlight> from the external device, at process decision block <highlight><bold>314</bold></highlight>. In particular, the value for this size of the data is transmitted into device <highlight><bold>128</bold></highlight> from the external device when the external device transmits the request to download data into device <highlight><bold>128</bold></highlight>. Upon determining that the amount of free space in flash memory <highlight><bold>104</bold></highlight> is not greater than or equal to the size of the data and associated overhead to be received into device <highlight><bold>128</bold></highlight>, initialize unit <highlight><bold>134</bold></highlight> reclaims space within flash memory <highlight><bold>104</bold></highlight> that is reclaimable (i.e., dirty), at process block <highlight><bold>316</bold></highlight>. In embodiments wherein the array within memory <highlight><bold>106</bold></highlight> indicates the amount of space within blocks of flash memory <highlight><bold>104</bold></highlight> are &ldquo;dirty&rdquo;, initialize unit <highlight><bold>134</bold></highlight> erases these &ldquo;dirty&rdquo; bytes within flash memory <highlight><bold>104</bold></highlight>. Additionally, initialize unit <highlight><bold>134</bold></highlight> again determines the amount of free space within flash memory <highlight><bold>104</bold></highlight>, at process block <highlight><bold>312</bold></highlight>. Initialize unit <highlight><bold>134</bold></highlight> continues checking for free space and reclaiming that space that can be reclaimed in flash memory <highlight><bold>104</bold></highlight>. In one embodiment, a timer can be set such that upon expiration of this timer if there is not enough free space available, initialize unit <highlight><bold>134</bold></highlight> returns an error and does not allow for the write of this data into flash memory <highlight><bold>104</bold></highlight>. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> Upon determining that the amount of free space in flash memory <highlight><bold>104</bold></highlight> is greater than or equal to the size of the data to be received into device <highlight><bold>128</bold></highlight>, initialize unit <highlight><bold>134</bold></highlight> creates headers for the different locations of free space in flash memory <highlight><bold>104</bold></highlight> and stores these headers into flash memory <highlight><bold>104</bold></highlight>, at process block <highlight><bold>318</bold></highlight>. In particular, the data stored in flash memory <highlight><bold>104</bold></highlight> also includes a header with information related to the data. For example, these headers could include the length of the data for this header in a given block or partition within flash memory <highlight><bold>104</bold></highlight>. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> The data to be stored in flash memory <highlight><bold>104</bold></highlight> may be larger than a given amount of contiguous free space in memory. Accordingly, the data to be stored in flash memory <highlight><bold>104</bold></highlight> can be stored across a number of different locations in flash memory <highlight><bold>104</bold></highlight>. In an embodiment, these headers are stored in-line with the data to be stored in the free space. For example, in an embodiment, the header for data in a block of flash memory <highlight><bold>104</bold></highlight> can be stored prior to the location of the actual data. In one embodiment, these headers include different information about the data being stored in flash memory <highlight><bold>104</bold></highlight>, such as the length of the data for this header. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> Additionally, initialize unit <highlight><bold>134</bold></highlight> reserves the free space in flash memory <highlight><bold>104</bold></highlight> that is to be used for writing the data to be received into device <highlight><bold>128</bold></highlight> to ensure that no other units within device <highlight><bold>128</bold></highlight> write to or delete the bytes within this free space. Initialize unit <highlight><bold>134</bold></highlight> also stores pointers, within memory <highlight><bold>106</bold></highlight>, to the different locations in flash memory <highlight><bold>104</bold></highlight> for this reserved free space. As described above, because the data to be stored in flash memory <highlight><bold>104</bold></highlight> can be greater than any one contiguous free space within flash memory <highlight><bold>104</bold></highlight>, a number of different pointers stored in memory <highlight><bold>106</bold></highlight> may be needed to point to the multiple locations of free space within flash memory <highlight><bold>104</bold></highlight> for storage of this data. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> This creation and reservation of free space within flash memory <highlight><bold>104</bold></highlight> as well as the creation of the headers and pointer associated therewith are considered a data reservation function. Accordingly, in an embodiment, initialize unit <highlight><bold>134</bold></highlight> also places this data reservation function into queue <highlight><bold>110</bold></highlight>, at process block <highlight><bold>334</bold></highlight>. This data reservation function will be removed from queue <highlight><bold>110</bold></highlight> upon completion of this creation and reservation of free space within flash memory <highlight><bold>104</bold></highlight> as well as the creation of the headers and pointer associated therewith. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> Therefore, initialize unit <highlight><bold>134</bold></highlight> determines whether queue <highlight><bold>110</bold></highlight> is empty, at process decision block <highlight><bold>332</bold></highlight>. In particular, because queue <highlight><bold>110</bold></highlight> was emptied prior to proceeding to process block <highlight><bold>312</bold></highlight>, queue <highlight><bold>110</bold></highlight> only includes this data reservation function. Therefore, when queue <highlight><bold>110</bold></highlight> is empty, this data reservation function is considered complete. Accordingly, upon determining that queue <highlight><bold>110</bold></highlight> is not empty, initialize unit <highlight><bold>134</bold></highlight> waits for queue <highlight><bold>110</bold></highlight> to empty, at process block <highlight><bold>326</bold></highlight>. In one such embodiment, this wait time can be based on a preset timer such that initialize unit <highlight><bold>134</bold></highlight> can again check to see if queue <highlight><bold>110</bold></highlight> is empty, at process decision block <highlight><bold>332</bold></highlight>, upon expiration of a timer. However, embodiments of the present invention are not so limited, as initialize unit <highlight><bold>134</bold></highlight> can continue to check if queue <highlight><bold>110</bold></highlight> is empty, independent of a timer. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> Upon determining that queue <highlight><bold>110</bold></highlight> is empty, initialize unit <highlight><bold>134</bold></highlight> unlocks queue <highlight><bold>110</bold></highlight>, at process block <highlight><bold>328</bold></highlight>. Additionally, initialize unit <highlight><bold>134</bold></highlight> signals completion of initializing flash memory <highlight><bold>104</bold></highlight>, at process block <highlight><bold>330</bold></highlight>. In an embodiment, this completion signal is through a semaphore that can be read by other units within device <highlight><bold>128</bold></highlight> interested in this semaphore. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> Returning to <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, after flash memory <highlight><bold>104</bold></highlight> has been initialized and the completion signal has been transmitted by initialize unit <highlight><bold>134</bold></highlight>, write unit <highlight><bold>130</bold></highlight> receives this completion signal. In an embodiment wherein the completion signal is a setting of a semaphore, write unit <highlight><bold>130</bold></highlight> receives this completion signal by checking the semaphore. Write unit <highlight><bold>130</bold></highlight> resumes data flow into device <highlight><bold>128</bold></highlight>, at process block <highlight><bold>208</bold></highlight>. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> illustrates a flow diagram of one embodiment for receiving and storing of this data flow into device <highlight><bold>128</bold></highlight>, according to embodiments of the present invention. In particular, <cross-reference target="DRAWINGS">FIG. 4</cross-reference> illustrates a flow diagram for the temporary storage of data intended for flash memory <highlight><bold>104</bold></highlight> into one of buffers <highlight><bold>112</bold></highlight>-<highlight><bold>122</bold></highlight> of buffer unit <highlight><bold>108</bold></highlight>, according to embodiments of the present invention. Further, in an embodiment, the operations illustrated by method <highlight><bold>401</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 4</cross-reference> are performed by receive unit <highlight><bold>132</bold></highlight>. In one such embodiment, receive unit <highlight><bold>132</bold></highlight> is an interrupt service routine executing within processor <highlight><bold>102</bold></highlight>. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> Method <highlight><bold>401</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 4</cross-reference> commences with the determination of whether there exists data to be transmitted to device <highlight><bold>128</bold></highlight> by receive unit <highlight><bold>132</bold></highlight>, at decision block <highlight><bold>402</bold></highlight>. In an embodiment wherein device <highlight><bold>128</bold></highlight> is a wireless device, the data could be received from a network. In one such embodiment, the BLUETOOTH&trade; standard is employed for this data transmission. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> Upon determining that there is no data to be received, receive unit <highlight><bold>132</bold></highlight> continues to check for such data. In contrast, upon determining that there is data to be received, receive unit <highlight><bold>132</bold></highlight> receives the data and stores the data into one of buffers <highlight><bold>112</bold></highlight>-<highlight><bold>122</bold></highlight> within buffer unit <highlight><bold>108</bold></highlight>, at process block <highlight><bold>404</bold></highlight>. In an embodiment, the size of the buffers are configurable by receive unit <highlight><bold>132</bold></highlight>. In one such embodiment, the size of the buffers is 512 bytes. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> Receive unit <highlight><bold>132</bold></highlight> also determines whether the buffer in which the data is being stored is full, at process decision block <highlight><bold>406</bold></highlight>. Upon determining that the buffer is not full, receive unit <highlight><bold>132</bold></highlight> continues checking for more data to be received, at process decision block <highlight><bold>402</bold></highlight>. Conversely, upon determining that the buffer is full, receive unit <highlight><bold>132</bold></highlight> releases the buffer and signals completion of writing to the buffer, at process block <highlight><bold>408</bold></highlight>. In an embodiment, this completion signal is through a semaphore that can be read by other units within device <highlight><bold>128</bold></highlight> interested in this semaphore. Additionally, receive unit <highlight><bold>132</bold></highlight> allocates another buffer within buffer unit <highlight><bold>108</bold></highlight>, at process block <highlight><bold>410</bold></highlight>, and continues to receive more data to place into this allocated buffer, at process block <highlight><bold>402</bold></highlight>. This process illustrated by method <highlight><bold>401</bold></highlight> continues until external devices do not have data to download into flash memory <highlight><bold>104</bold></highlight> of device <highlight><bold>128</bold></highlight> or until other units within device <highlight><bold>128</bold></highlight> stop the data flow, such as write unit <highlight><bold>130</bold></highlight>. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> Returning to <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, after resuming data flow into device <highlight><bold>128</bold></highlight>, write unit <highlight><bold>130</bold></highlight> transmits a signal to the external device, which is requesting to download data into device <highlight><bold>128</bold></highlight>, indicating to this external device that it can commence transmission of data to device <highlight><bold>128</bold></highlight>, at process block <highlight><bold>210</bold></highlight>. Additionally, write unit <highlight><bold>130</bold></highlight> determines whether a buffer within buffer unit <highlight><bold>108</bold></highlight> is available with data that has been transmitted from the external device, at process decision block <highlight><bold>212</bold></highlight>. In an embodiment, this determination is based on a semaphore that is set by receive unit <highlight><bold>132</bold></highlight>. In particular as described above in conjunction with <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, receive unit <highlight><bold>132</bold></highlight> receives the data being transmitted into device <highlight><bold>128</bold></highlight> from the external device, places this data into buffers with buffer unit <highlight><bold>108</bold></highlight> and transmits a completion signal, such as the setting of a semaphore, when a buffer has been filled with data. Upon determining that a buffer within buffer unit <highlight><bold>108</bold></highlight> is not available with data, write unit <highlight><bold>130</bold></highlight> continues checking for a buffer within buffer unit <highlight><bold>108</bold></highlight> that is available with data, at process block <highlight><bold>212</bold></highlight>. Conversely, upon determining that a buffer within buffer unit <highlight><bold>108</bold></highlight> is available with data, write unit <highlight><bold>130</bold></highlight> begins writing the data within the buffer in buffer unit <highlight><bold>108</bold></highlight>, at process block <highlight><bold>214</bold></highlight>. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> In particular, <cross-reference target="DRAWINGS">FIG. 5</cross-reference> illustrates a flow diagram for writing data into flash memory <highlight><bold>104</bold></highlight>, according to embodiments of the present invention. <cross-reference target="DRAWINGS">FIG. 5</cross-reference> commences with the disabling of interrupts within device <highlight><bold>128</bold></highlight> by write flash unit <highlight><bold>136</bold></highlight>, at process block <highlight><bold>504</bold></highlight>. Examples of the types of interrupts when device <highlight><bold>128</bold></highlight> is a cellular telephone includes button presses on the keypad for dialing a telephone number and data being received from external devices. This disablement of interrupts allows for the writing of data into flash memory <highlight><bold>104</bold></highlight> more quickly, as processor <highlight><bold>102</bold></highlight> does not interrupt write flash unit <highlight><bold>136</bold></highlight> to process interrupts by other units and/or tasks within device <highlight><bold>128</bold></highlight>. Additionally, this disablement of interrupts is needed when writing data into flash as two commands for writing to flash are required to be contiguous. In particular, a first command that places the flash in a mode to receive data (i.e., status mode) is to be followed by a second command for the data to be written, as the flash must be in a given mode to write data therein. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> Write flash unit <highlight><bold>136</bold></highlight> also place flash memory <highlight><bold>104</bold></highlight> into &lsquo;status&rsquo; mode. In an embodiment, when in &lsquo;status&rsquo; mode, the bytes within flash memory <highlight><bold>104</bold></highlight>, when read, indicate status regarding the current operation occurring thereto. In an embodiment, the &lsquo;status&rsquo; mode can return information regarding the status of a given block or other partition of flash memory <highlight><bold>104</bold></highlight>. Accordingly, when reading bytes in a given block, these bytes return the status for the entire block. Examples of the type of status information returned includes, but is not limited to, whether the current operation occurring within the partition or block is complete, whether any errors have occurred during this current operation, as well as the type of errors (if any errors did occur). An example of the type of error that could occur during a write or erase operation includes attempting to write to a block of data that is locked. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> Additionally, write flash unit <highlight><bold>136</bold></highlight> determines the location to write data into flash memory <highlight><bold>104</bold></highlight> based on the pointers, stored in memory <highlight><bold>106</bold></highlight>, that point to the reserved free space in flash memory <highlight><bold>104</bold></highlight> where the data is to be written. Write flash unit <highlight><bold>136</bold></highlight> transmits a request to write a portion of the data from the buffer within buffer unit <highlight><bold>108</bold></highlight> to at least one of these locations within flash memory <highlight><bold>104</bold></highlight>, at process block <highlight><bold>506</bold></highlight>. In an embodiment, this portion of data to be written is a 16-bit word. In another embodiment, this portion of data to be written is a 32-bit word. Write flash unit <highlight><bold>136</bold></highlight> determines whether there are any interrupts pending in device <highlight><bold>128</bold></highlight>, at process decision block <highlight><bold>508</bold></highlight>. Upon determining there are no interrupts pending in device <highlight><bold>128</bold></highlight>, write flash unit <highlight><bold>136</bold></highlight> determines whether flash memory <highlight><bold>104</bold></highlight> is ready to write data, at process decision block <highlight><bold>518</bold></highlight>. In particular, when a request is made to write data to flash memory, there can be a delay in order to ramp up power supplies, condition the location to where the data is being written and ramp down these power supplies all internal to the flash memory. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> Upon determining there are interrupts pending in device <highlight><bold>128</bold></highlight>, write flash unit <highlight><bold>136</bold></highlight> suspends these write operations to flash memory <highlight><bold>104</bold></highlight>. Additionally, write flash unit <highlight><bold>136</bold></highlight> places flash memory <highlight><bold>104</bold></highlight> into a &ldquo;read array&rdquo; mode, which allows for the reading of data from flash memory <highlight><bold>104</bold></highlight>. Write flash unit <highlight><bold>136</bold></highlight> also enables interrupts in device <highlight><bold>128</bold></highlight> that were disabled in process block <highlight><bold>504</bold></highlight>, at process block <highlight><bold>513</bold></highlight>. Accordingly, the operating system (not shown) being executed by processor <highlight><bold>102</bold></highlight> will handle the interrupts and while using a prioritization scheme for the different units executing within device <highlight><bold>128</bold></highlight>, the operating system will return control to write flash unit <highlight><bold>136</bold></highlight> when the unit becomes the highest priority to be processed by processor <highlight><bold>102</bold></highlight>. Write flash unit <highlight><bold>136</bold></highlight>, therefore, waits for the return of control, at process block <highlight><bold>514</bold></highlight>. Once control is returned, write flash unit <highlight><bold>136</bold></highlight> disables interrupts within device <highlight><bold>128</bold></highlight>, at process block <highlight><bold>515</bold></highlight>, and places flash memory <highlight><bold>104</bold></highlight> back into &lsquo;status&rsquo; mode, at process block <highlight><bold>550</bold></highlight>, similar to process blocks <highlight><bold>504</bold></highlight>-<highlight><bold>505</bold></highlight> described above. Write flash unit <highlight><bold>136</bold></highlight> resumes write operations to flash memory <highlight><bold>104</bold></highlight>, at process block <highlight><bold>516</bold></highlight>. Write flash unit <highlight><bold>136</bold></highlight> determines whether flash memory <highlight><bold>104</bold></highlight> is ready to write data, at process decision block <highlight><bold>518</bold></highlight>, as described above. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> Upon determining that flash memory <highlight><bold>104</bold></highlight> is not ready to write data, write flash unit <highlight><bold>136</bold></highlight> continues checking to determine whether there are any interrupts pending, at process decision block <highlight><bold>508</bold></highlight>. In contrast, upon determining that flash memory <highlight><bold>104</bold></highlight> is ready to write data, write flash unit <highlight><bold>136</bold></highlight> writes this portion of data into flash memory <highlight><bold>104</bold></highlight>, at process block <highlight><bold>519</bold></highlight>. Additionally, write flash unit <highlight><bold>136</bold></highlight> determines whether the data from the buffer within buffer unit <highlight><bold>108</bold></highlight> has been written to flash memory <highlight><bold>104</bold></highlight>, at process decision block <highlight><bold>520</bold></highlight>. Upon determining that all of the data from the buffer within buffer unit <highlight><bold>108</bold></highlight> has not been written into flash memory <highlight><bold>104</bold></highlight>, write flash unit <highlight><bold>136</bold></highlight> transmits another request to flash memory <highlight><bold>104</bold></highlight> to write data therein, at process block <highlight><bold>506</bold></highlight>, as described above. Conversely, upon determining that all of the data from the buffer within buffer unit <highlight><bold>108</bold></highlight> has been written into flash memory <highlight><bold>104</bold></highlight>, write flash unit <highlight><bold>136</bold></highlight> re-enables interrupts that were disabled in process block <highlight><bold>504</bold></highlight>, at process block <highlight><bold>522</bold></highlight>. Write flash unit <highlight><bold>136</bold></highlight> signals completion of writing data into flash memory <highlight><bold>104</bold></highlight>, at process block <highlight><bold>524</bold></highlight>. In an embodiment, this completion signal is through a semaphore that can be read by other units within device <highlight><bold>128</bold></highlight> interested in this semaphore. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> As illustrated, write flash unit <highlight><bold>136</bold></highlight> writes data stored in buffers <highlight><bold>112</bold></highlight>-<highlight><bold>122</bold></highlight> of buffer unit <highlight><bold>108</bold></highlight> into flash memory <highlight><bold>104</bold></highlight>, while still allowing for interrupts at certain times during the write operation. Returning to the examples of the types of interrupts when device <highlight><bold>128</bold></highlight> is a cellular telephone, certain interrupts within device <highlight><bold>128</bold></highlight> can be of such a high priority that they are required to be processed or the device <highlight><bold>128</bold></highlight> will no longer be functional. For example, if a user of the cellular telephone is attempting to entering a telephone number and place the call and if the data being written to flash memory <highlight><bold>104</bold></highlight> is large, the delay time for processing these button presses by the user could be large. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> illustrates a system that can incorporate embodiments of the present invention. In particular, <cross-reference target="DRAWINGS">FIG. 6</cross-reference> illustrates system <highlight><bold>600</bold></highlight> that includes cellular telephone <highlight><bold>602</bold></highlight> which is wireless coupled to network <highlight><bold>606</bold></highlight> through wireless communication link <highlight><bold>604</bold></highlight>. Additionally, network <highlight><bold>606</bold></highlight> is coupled to server <highlight><bold>608</bold></highlight>. Cellular telephone <highlight><bold>602</bold></highlight> is an embodiment of device <highlight><bold>128</bold></highlight>, illustrated in <cross-reference target="DRAWINGS">FIG. 1</cross-reference> above, while server <highlight><bold>608</bold></highlight> is an embodiment of the external device that is downloading data into the flash memory of cellular telephone <highlight><bold>602</bold></highlight>. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> In one embodiment, network <highlight><bold>606</bold></highlight> is a local area network (LAN). In another embodiment, network <highlight><bold>606</bold></highlight> is a wide area network (WAN). In an embodiment, network <highlight><bold>606</bold></highlight> is the Internet. Further, network <highlight><bold>606</bold></highlight> can be a combination of different networks that provide communication between server <highlight><bold>608</bold></highlight> and cellular telephone <highlight><bold>602</bold></highlight>. Examples of the different types of data to be downloaded by server <highlight><bold>608</bold></highlight> into cellular telephone <highlight><bold>602</bold></highlight> could be web pages and applets from different web sites residing in server <highlight><bold>608</bold></highlight>. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> illustrates an exemplary system <highlight><bold>700</bold></highlight> comprising processors <highlight><bold>702</bold></highlight> and <highlight><bold>704</bold></highlight> (similar to processor <highlight><bold>102</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 1</cross-reference> above) for initializing a flash memory device and storing data therein, according to embodiments of the present invention. Although described in the context of system <highlight><bold>700</bold></highlight>, the present invention may be implemented in any suitable computer system comprising any suitable one or more integrated circuits. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> As illustrated in <cross-reference target="DRAWINGS">FIG. 7</cross-reference>, computer system <highlight><bold>700</bold></highlight> comprises processor <highlight><bold>702</bold></highlight> that may include instructions for message accumulation and retrieval, as described herein. Computer system also can include another processor <highlight><bold>704</bold></highlight> that may also have instructions for message accumulation and retrieval, as described herein. Computer system <highlight><bold>700</bold></highlight> also includes processor bus <highlight><bold>710</bold></highlight>, and chipset <highlight><bold>720</bold></highlight>. Processors <highlight><bold>702</bold></highlight> and <highlight><bold>704</bold></highlight> and chipset <highlight><bold>720</bold></highlight> are coupled to processor bus <highlight><bold>710</bold></highlight>. Processors <highlight><bold>702</bold></highlight> and <highlight><bold>704</bold></highlight> may each comprise any suitable processor architecture and for one embodiment comprise an Intel&reg; Architecture used, for example, in the Pentium&reg; family of processors available from Intel&reg; Corporation of Santa Clara, Calif. Computer system <highlight><bold>700</bold></highlight> for other embodiments may comprise one, three, or more processors any of which may execute a set of instructions that are in accordance with embodiments of the present invention. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> Chipset <highlight><bold>720</bold></highlight> for one embodiment comprises memory controller hub (MCH) <highlight><bold>730</bold></highlight>, input/output (<highlight><bold>1</bold></highlight>/<highlight><bold>0</bold></highlight>) controller hub (ICH) <highlight><bold>740</bold></highlight>, and firmware hub (FWH) <highlight><bold>770</bold></highlight>. MCH <highlight><bold>730</bold></highlight>, ICH <highlight><bold>740</bold></highlight>, and FWH <highlight><bold>770</bold></highlight> may each comprise any suitable circuitry and for one embodiment is each formed as a separate integrated circuit chip. Chipset <highlight><bold>720</bold></highlight> for other embodiments may comprise any suitable one or more integrated circuit devices. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> MCH <highlight><bold>730</bold></highlight> may comprise any suitable interface controllers to provide for any suitable communication link to processor bus <highlight><bold>710</bold></highlight> and/or to any suitable device or component in communication with MCH <highlight><bold>730</bold></highlight>. MCH <highlight><bold>730</bold></highlight> for one embodiment provides suitable arbitration, buffering, and coherency management for each interface. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> MCH <highlight><bold>730</bold></highlight> is coupled to processor bus <highlight><bold>710</bold></highlight> and provides an interface to processors <highlight><bold>702</bold></highlight> and <highlight><bold>704</bold></highlight> over processor bus <highlight><bold>710</bold></highlight>. Processor <highlight><bold>702</bold></highlight> and/or processor <highlight><bold>704</bold></highlight> may alternatively be combined with MCH <highlight><bold>730</bold></highlight> to form a single chip. MCH <highlight><bold>730</bold></highlight> for one embodiment also provides an interface to a main memory <highlight><bold>732</bold></highlight> and a graphics controller <highlight><bold>734</bold></highlight> each coupled to MCH <highlight><bold>730</bold></highlight>. Main memory <highlight><bold>732</bold></highlight> stores data and/or instructions, for example, for computer system <highlight><bold>700</bold></highlight> and may comprise any suitable memory, such as a dynamic random access memory (DRAM) for example. Graphics controller <highlight><bold>734</bold></highlight> controls the display of information on a suitable display <highlight><bold>736</bold></highlight>, such as a cathode ray tube (CRT) or liquid crystal display (LCD) for example, coupled to graphics controller <highlight><bold>734</bold></highlight>. MCH <highlight><bold>730</bold></highlight> for one embodiment interfaces with graphics controller <highlight><bold>734</bold></highlight> through an accelerated graphics port (AGP). Graphics controller <highlight><bold>734</bold></highlight> for one embodiment may alternatively be combined with MCH <highlight><bold>730</bold></highlight> to form a single chip. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> MCH <highlight><bold>730</bold></highlight> is also coupled to ICH <highlight><bold>740</bold></highlight> to provide access to ICH <highlight><bold>740</bold></highlight> through a hub interface. ICH <highlight><bold>740</bold></highlight> provides an interface to I/O devices or peripheral components for computer system <highlight><bold>700</bold></highlight>. ICH <highlight><bold>740</bold></highlight> may comprise any suitable interface controllers to provide for any suitable communication link to MCH <highlight><bold>730</bold></highlight> and/or to any suitable device or component in communication with ICH <highlight><bold>740</bold></highlight>. ICH <highlight><bold>740</bold></highlight> for one embodiment provides suitable arbitration and buffering for each interface. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> For one embodiment, ICH <highlight><bold>740</bold></highlight> provides an interface to one or more suitable integrated drive electronics (IDE) drives <highlight><bold>742</bold></highlight>, such as a hard disk drive (HDD) or compact disc read only memory (CD ROM) drive for example, to store data and/or instructions for example, one or more suitable universal serial bus (USB) devices through one or more USB ports <highlight><bold>744</bold></highlight>, an audio coder/decoder (codec) <highlight><bold>746</bold></highlight>, and a modem codec <highlight><bold>748</bold></highlight>. ICH <highlight><bold>740</bold></highlight> for one embodiment also provides an interface through a super I/O controller <highlight><bold>750</bold></highlight> to a keyboard <highlight><bold>751</bold></highlight>, a mouse <highlight><bold>752</bold></highlight>, one or more suitable devices, such as a printer for example, through one or more parallel ports <highlight><bold>753</bold></highlight>, one or more suitable devices through one or more serial ports <highlight><bold>754</bold></highlight>, and a floppy disk drive <highlight><bold>755</bold></highlight>. ICH <highlight><bold>740</bold></highlight> for one embodiment further provides an interface to one or more suitable peripheral component interconnect (PCI) devices coupled to ICH <highlight><bold>740</bold></highlight> through one or more PCI slots <highlight><bold>762</bold></highlight> on a PCI bus and an interface to one or more suitable industry standard architecture (ISA) devices coupled to ICH <highlight><bold>740</bold></highlight> by the PCI bus through an ISA bridge <highlight><bold>764</bold></highlight>. ISA bridge <highlight><bold>764</bold></highlight> interfaces with one or more ISA devices through one or more ISA slots <highlight><bold>766</bold></highlight> on an ISA bus. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> ICH <highlight><bold>740</bold></highlight> is also coupled to FWH <highlight><bold>770</bold></highlight> to provide an interface to FWH <highlight><bold>770</bold></highlight>. FWH <highlight><bold>770</bold></highlight> may comprise any suitable interface controller to provide for any suitable communication link to ICH <highlight><bold>740</bold></highlight>. FWH <highlight><bold>770</bold></highlight> for one embodiment may share at least a portion of the interface between ICH <highlight><bold>740</bold></highlight> and super I/O controller <highlight><bold>750</bold></highlight>. FWH <highlight><bold>770</bold></highlight> comprises a basic input/output system (BIOS) memory <highlight><bold>772</bold></highlight> to store suitable system and/or video BIOS software. BIOS memory <highlight><bold>772</bold></highlight> may comprise any suitable non-volatile memory, such as a flash memory for example. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> Accordingly, computer system <highlight><bold>700</bold></highlight> includes a machine-readable medium on which is stored a set of instructions (i.e., software) embodying any one, or all, of the methodologies described above. For example, software can reside, completely or at least partially, within main memory <highlight><bold>732</bold></highlight> and/or within processors <highlight><bold>702</bold></highlight>/<highlight><bold>704</bold></highlight>. For the purposes of this specification, the term &ldquo;machine-readable medium&rdquo; shall be taken to include any mechanism that provides (i.e., stores and/or transmits) information in a form readable by a machine (e.g., a computer). For example, a machine-readable medium includes read only memory (ROM); random access memory (RAM); magnetic disk storage media; optical storage media; flash memory devices; electrical, optical, acoustical or other form of propagated signals (e.g., carrier waves, infrared signals, digital signals, etc.); etc. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> Thus, a method and apparatus for initializing a flash memory for the storage of data therein have been described. Although the present invention has been described with reference to specific exemplary embodiments, it will be evident that various modifications and changes may be made to these embodiments without departing from the broader spirit and scope of the invention. For example, data may be stored into Flash memory <highlight><bold>104</bold></highlight> in sizes other than 16-bits at a time. Accordingly, the specification and drawings are to be regarded in an illustrative rather than a restrictive sense. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method comprising: 
<claim-text>receiving a request to download data into flash memory; </claim-text>
<claim-text>halting the downloading of the data into the flash memory until the flash memory is initialized, wherein the initialization includes storing pointers in a memory to different locations within the flash memory where the data is to be stored; and </claim-text>
<claim-text>storing the data into the flash memory based on the pointers stored in the memory. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the initialization of the flash memory comprises: 
<claim-text>generating headers for the different locations within the flash memory where the data is to be stored; and </claim-text>
<claim-text>storing the headers at the different locations within the flash memory. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising storing the data received from the download into a number of buffers prior to storing the data into the flash memory. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the initialization of the flash memory comprises reclaiming space within the flash memory that is reclaimable for storage of data into the flash memory. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. A method comprising: 
<claim-text>receiving a request from an external device to store data into a flash memory of a device, wherein the request includes the size of the data; </claim-text>
<claim-text>initializing the flash memory of the device prior to receiving the data, wherein the initializing comprises, 
<claim-text>determining whether the size of free space within the flash memory is greater than the size of the data; </claim-text>
<claim-text>upon determining that the size of the free space within the flash memory is not greater than the size of the data, reclaiming space within the flash memory; </claim-text>
<claim-text>generating headers for each of a number of different locations within the flash memory where the free space is located; </claim-text>
<claim-text>storing the headers into the number of different locations within the flash memory; and </claim-text>
<claim-text>storing pointers, in a separate memory, to the number of different locations within the flash memory where the free space is located; </claim-text>
</claim-text>
<claim-text>transmitting a signal to the external device to transmit the data after the initialization of the flash memory is completed; </claim-text>
<claim-text>receiving the data into a number of buffers within the device; and </claim-text>
<claim-text>storing the data within the number of buffers into the number of different locations within the flash memory where the free space is located. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference>, wherein the separate memory is a random access memory. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference>, wherein the device is a cellular telephone and the external device is a server coupled to a network and wherein the data is transmitted to the cellular telephone through a wireless transmission link. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference>, further comprising disabling interrupts within the device when portions of the data are being written into the number of different locations in the flash memory. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference>, further comprising: 
<claim-text>determining whether interrupts are pending in the device periodically during the time the data is being written into the number of different locations in the flash memory; and </claim-text>
<claim-text>periodically halting the writing of the data into the number of different locations in the flash memory and servicing the interrupts that are pending in the device upon determining that interrupts are pending. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. An apparatus comprising: 
<claim-text>a flash memory partitioned into blocks; </claim-text>
<claim-text>a random access memory coupled to the flash memory; </claim-text>
<claim-text>a write unit coupled to the flash memory and the random access memory, wherein the write unit is to receive a request to download data into the flash memory and wherein the write unit is to download the data into the flash memory; and </claim-text>
<claim-text>an initialize unit coupled to the flash memory, the random access memory and the write unit, wherein the initialize unit is to store pointers, prior to downloading the data into the flash memory, in the random access memory to a number of the blocks within the flash memory that are free to store the data. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein the initialize unit is to store headers at the number of different blocks within the flash memory, prior to downloading the data into the flash memory. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein the initialize unit is to reclaim space, prior to downloading the data into the flash memory, within flash memory that is reclaimable for storage of the data into the flash memory upon determining that the size of free space within the flash memory is less than the size of the data to be downloaded into the flash memory. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein the write unit is to store the data received from the download into a number of buffers prior to storing the data into the flash memory. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. A system comprising: 
<claim-text>a server coupled to a network; and </claim-text>
<claim-text>a cellular telephone wirelessly coupled to the network, wherein the cellular telephone comprises, 
<claim-text>a flash memory partitioned into blocks; </claim-text>
<claim-text>a random access memory coupled to the flash memory; </claim-text>
<claim-text>a processor that is coupled to the flash memory and the random access memory, the processor to execute a number of instructions, which when executed by the processor causes the processor to, 
<claim-text>receive a request, from the server, to download data into the flash memory; </claim-text>
<claim-text>halt the downloading of the data into the flash memory until the flash memory is initialized, wherein the initialization includes storing pointers in the random access memory to a number of the blocks within the flash memory where the data is to be stored; and </claim-text>
<claim-text>store the data into the flash memory based on the pointers stored in the memory. </claim-text>
</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference>, wherein the initialization of the flash memory comprises: 
<claim-text>generating headers for the different locations within the flash memory where the data is to be stored; and </claim-text>
<claim-text>storing the headers at the different locations within the flash memory. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising storing the data received from the download into a number of buffers prior to storing the data into the flash memory. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the initialization of the flash memory comprises reclaiming space within the flash memory that is reclaimable for storage of data into the flash memory. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. A machine-readable medium that provides instructions, which when executed by a machine, causes the machine to perform operations comprising: 
<claim-text>receiving a request to download data into flash memory; </claim-text>
<claim-text>halting the downloading of the data into the flash memory until the flash memory is initialized, wherein the initialization includes storing pointers in a memory to different locations within the flash memory where the data is to be stored; and </claim-text>
<claim-text>storing the data into the flash memory based on the pointers stored in the memory. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The machine-readable medium of <dependent-claim-reference depends_on="CLM-00011">claim 18</dependent-claim-reference>, wherein the initialization of the flash memory comprises: 
<claim-text>generating headers for the different locations within the flash memory where the data is to be stored; and </claim-text>
<claim-text>storing the headers at the different locations within the flash memory. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The machine-readable medium of <dependent-claim-reference depends_on="CLM-00011">claim 18</dependent-claim-reference>, further comprising storing the data received from the download into a number of buffers prior to storing the data into the flash memory. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The machine-readable medium of <dependent-claim-reference depends_on="CLM-00011">claim 18</dependent-claim-reference>, wherein the initialization of the flash memory comprises reclaiming space within the flash memory that is reclaimable for storage of data into the flash memory. </claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. A machine-readable medium that provides instructions, which when executed by a machine, causes the machine to perform operations comprising: 
<claim-text>receiving a request from an external device to store data into a flash memory of a device, wherein the request includes the size of the data; </claim-text>
<claim-text>initializing the flash memory of the device prior to receiving the data, wherein the initializing comprises, 
<claim-text>determining whether the size of free space within the flash memory is greater than the size of the data; </claim-text>
<claim-text>upon determining that the size of the free space within the flash memory is not greater than the size of the data, reclaiming space within the flash memory; </claim-text>
<claim-text>generating headers for each of a number of different locations within the flash memory where the free space is located; </claim-text>
<claim-text>storing the headers into the number of different locations within the flash memory; and </claim-text>
<claim-text>storing pointers, in a separate memory, to the number of different locations within the flash memory where the free space is located; </claim-text>
</claim-text>
<claim-text>transmitting a signal to the external device to transmit the data after the initialization of the flash memory is completed; </claim-text>
<claim-text>receiving the data into a number of buffers within the device; and </claim-text>
<claim-text>storing the data within the number of buffers into the number of different locations within the flash memory where the free space is located. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The machine-readable medium of <dependent-claim-reference depends_on="CLM-00022">claim 22</dependent-claim-reference>, wherein the separate memory is a random access memory. </claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The machine-readable medium of <dependent-claim-reference depends_on="CLM-00022">claim 22</dependent-claim-reference>, wherein the device is a cellular telephone and the external device is a server coupled to a network and wherein the data is transmitted to the cellular telephone through a wireless transmission link. </claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. The machine-readable medium of <dependent-claim-reference depends_on="CLM-00022">claim 22</dependent-claim-reference>, further comprising disabling interrupts within the device when portions of the data are being written into the number of different locations in the flash memory. </claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. The machine-readable medium of <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>, further comprising: 
<claim-text>determining whether interrupts are pending in the device periodically during the time the data is being written into the number of different locations in the flash memory; and </claim-text>
<claim-text>periodically halting the writing of the data into the number of different locations in the flash memory and servicing the interrupts that are pending in the device upon determining that interrupts are pending.</claim-text>
</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>6</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030003908A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030003908A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030003908A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030003908A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030003908A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030003908A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030003908A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030003908A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
