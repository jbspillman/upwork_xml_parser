<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030001859A1-20030102-M00001.NB SYSTEM "US20030001859A1-20030102-M00001.NB" NDATA NB>
<!ENTITY US20030001859A1-20030102-M00001.TIF SYSTEM "US20030001859A1-20030102-M00001.TIF" NDATA TIF>
<!ENTITY US20030001859A1-20030102-D00000.TIF SYSTEM "US20030001859A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030001859A1-20030102-D00001.TIF SYSTEM "US20030001859A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030001859A1-20030102-D00002.TIF SYSTEM "US20030001859A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030001859A1-20030102-D00003.TIF SYSTEM "US20030001859A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030001859A1-20030102-D00004.TIF SYSTEM "US20030001859A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030001859A1-20030102-D00005.TIF SYSTEM "US20030001859A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030001859A1-20030102-D00006.TIF SYSTEM "US20030001859A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030001859A1-20030102-D00007.TIF SYSTEM "US20030001859A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030001859A1-20030102-D00008.TIF SYSTEM "US20030001859A1-20030102-D00008.TIF" NDATA TIF>
<!ENTITY US20030001859A1-20030102-D00009.TIF SYSTEM "US20030001859A1-20030102-D00009.TIF" NDATA TIF>
<!ENTITY US20030001859A1-20030102-D00010.TIF SYSTEM "US20030001859A1-20030102-D00010.TIF" NDATA TIF>
<!ENTITY US20030001859A1-20030102-D00011.TIF SYSTEM "US20030001859A1-20030102-D00011.TIF" NDATA TIF>
<!ENTITY US20030001859A1-20030102-D00012.TIF SYSTEM "US20030001859A1-20030102-D00012.TIF" NDATA TIF>
<!ENTITY US20030001859A1-20030102-D00013.TIF SYSTEM "US20030001859A1-20030102-D00013.TIF" NDATA TIF>
<!ENTITY US20030001859A1-20030102-D00014.TIF SYSTEM "US20030001859A1-20030102-D00014.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030001859</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09892924</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010626</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G09G005/00</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>345</class>
<subclass>584000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Interactive horizon mapping</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Peter-Pike</given-name>
<family-name>Sloan</family-name>
</name>
<residence>
<residence-us>
<city>Bellevue</city>
<state>WA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Michael</given-name>
<middle-name>F.</middle-name>
<family-name>Cohen</family-name>
</name>
<residence>
<residence-us>
<city>Seattle</city>
<state>WA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>LEE &amp; HAYES PLLC</name-1>
<name-2></name-2>
<address>
<address-1>421 W RIVERSIDE AVENUE SUITE 500</address-1>
<city>SPOKANE</city>
<state>WA</state>
<postalcode>99201</postalcode>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">Shadows, which play an important role in perceiving the shape and texture of an object, are simulated interactively in a real time, self-shadowing of a bump mapped surface for a computer rendered object. A computer graphics textured object function defines a horizon map over an orientation in a tangent space of the object using different textures or basis functions. The implementation can be performed using commodity graphics hardware by precomputing the horizon map for limited visibility for each point on the bump mapped surface given light in each of a plurality of radial directions. The horizon map is used to produce self-shadowing of the bump mapped surface of the object. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">TECHNICAL FIELD </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> The present invention relates to computer graphics renderings, and more particularly to systems, methods, and program products for real time shadowing of bump mapped surfaces using horizon mapping in computer graphics renderings. </paragraph>
</section>
<section>
<heading lvl="1">BACKGROUND </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> Computer graphics involves the rendering of images for display on a visual terminal of a computer. Rendering involves the translation of the three-dimensional (3D) geometry of graphical objects into picture elements (pixels) that are stored in a frame buffer. The contents of the frame buffer can then be displayed on the visual terminal or display device. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> In a computer gaming, 3D animation is used to display a sequence of images interactively to the user of the computer game, which gives the illusion of motion in three-dimensional space. This interactivity allows a user to change a scene or the point of view in the scene. These on-demand changes initiated by the user require a rendering system that can create new images in real-time. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> Computer games are one example of a 3D computer graphics system. Others include computer-aided design (CAD) and virtual reality (&ldquo;VR&rdquo;). A 3D graphics accelerator is typically used in these types of systems. The graphics hardware is used to receive off-loaded processing functions from a host processor to speed up system performance. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> An application program executing on a host processor generates three-dimensional geometry data including information corresponding to points on the surface of a three-dimensional graphical object. These points are usable as vertices of polygons which, when connected, may be rendered to form a representation of the graphical object. The application program causes the host processor to transfer this 3-D geometry data to a graphics accelerator, along with corresponding control and connectivity information. The graphics accelerator receives this stream of compressed 3-D geometry data and, for reasons of speed and diversity, renders a series a collection of flat encoded polygons, for example triangles, in a frame buffer for subsequent display on an attached display device. A polygonal system such as this has the advantage of being able to translate and project such objects quickly and efficiently. The process of connecting three-dimensional vertices into component polygons, the sum of which represents a graphical object, is referred to as &ldquo;tiling&rdquo;. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> Each graphical object to be rendered has a coordinate system that is local to the graphical object within the 3D computer graphics system. This coordinate system needs to be transformed from the coordinate system of the graphical object to the pixel display coordinates in the frame buffer. Once the geometry of the object has been transformed into screen coordinates, it is rasterized or broken into a set of pixel color values that are stored into the frame buffer. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> Each corner or vertex of each polygon has associated therewith certain values for pixel parameters based on the graphical object itself and the environmental properties of the graphical object. Interpolation is used for each pixel in the polygon area to generate the pixel parameters. One such pixel parameter is texture. Texture on the polygon is suggested by means of a texture map to accomplish finer detail in the polygon. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> In conventional commodity graphics hardware, the surface of an object is typically digitally represented by a texture in terms of four (4) color channels, namely red, green, blue, and alpha. At each vertex of each polygon, two-dimensional (2D) coordinates are specified for the orientation in the tangent plane of the light. The 2D qualities include color and brightness and are encoded by the first three channels. A texture is also encoded with three-dimensional properties, such as how transparent and reflective the object is by use of the fourth channel&mdash;the alpha channel. Once at texture is parameterized by a point on a surface, another texture can be parameterized by where the light is relative to the local surface point. Then, once a texture has been defined, it can be wrapped around any 3-dimensional object in a texture mapping process. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> A texture map is a picture stored in a computer memory as a bit map that is applied to the polygons that make up the graphical object to make the graphical object look more realistic. The texture map is comprised of individual two dimensional space rectangular &lsquo;texels&rsquo; coordinates that depict a certain texture. When the texels are mapped onto a polygon, it will appear to be textured. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> Texture mapping processes can be used to render an appearance of a smooth surface. A more realistic and topographical rendering, however, can be accomplished using a texture map that is known as a bump map. Bump mapping uses a bump map that is associated with a surface. The bump map, which is normally pre-calculated into a look up table stored in memory, is a collection of different surface normal vectors on different surface locations of the surface to create an impression of a rough surface. Stated otherwise, bump mapping simulates the effect of light reflecting from small perturbations across a surface. Bump mapping, often considered as the application of a shading function to an object, is done on a pixel-by-pixel basis. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> Bump mapping techniques, which convey surface texture by perturbing the normal vectors of a surface, are available on conventional commodity graphics hardware. The advantage of bump mapping is that it provides a simple way to modulate the shading on a surface. Bump maps represent a special kind of texture map. Instead of a color, each texel of a bump map contains a height field gradient. Bump maps are applied to a surface of an object using standard texture-mapping tools. Very complex surfaces (wrinkles, folds, bumps) can be simulated without increasing the complexity of the surface itself. A space in which the bump map is defined is called a map space. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> In bump mapping, texel coordinates, designated as &ldquo;u&rdquo; and &ldquo;v&rdquo;, are used in a single component texture map, f(u, v). The texture map is interpreted as a height field that perturbs at each point on the surface along its normal vector </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>N</italic></highlight>&equals;(<highlight><italic>P</italic></highlight><highlight><subscript>u</subscript></highlight><highlight><italic>&times;P</italic></highlight><highlight><subscript>v</subscript></highlight>)/&verbar;(<highlight><italic>P</italic></highlight><highlight><subscript>u</subscript></highlight><highlight><italic>&times;P</italic></highlight><highlight><subscript>v</subscript></highlight>)&verbar;,&emsp;&emsp;(1) </in-line-formula></paragraph>
<paragraph id="P-0013" lvl="7"><number>&lsqb;0013&rsqb;</number> where P<highlight><subscript>u </subscript></highlight>and P<highlight><subscript>v </subscript></highlight>are partials of the parameterization of texture space axes u and v. Rather than actually changing the surface geometry, however, only the normal vector is modified. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> Shadows play an important providing perceptual cues for perceiving surface shape and surface texture of an object. Bump mapping, however, does not define any explicit geometry such that there are no actual bumps to cast shadows. Stated otherwise, a bump defined by a conventional bump mapping function can cast neither a bumpy shadow nor a shadow on another object. Thus, interactive shadowing techniques that rely on an explicit representation of the geometry cannot be used to simulate shadows cast by the virtual bumps implied in bump mapping. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> It would be an advance in the art to provide a technique to render with commodity graphics hardware, in real time at interactive rates, a graphical image of an object having a bump mapped surface, where the bumps on the bump mapped surface cast shadows, thus more accurately accounting for the geometry of the underlying bump mapped surface. It would also be an advance in the art to represent limited self-shadowing for pure geometry while maintaining interactivity with a user of a computer. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY </heading>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> Interactive, real time self-shadowing, also known as horizon mapping, of a bump mapped surface is implemented for computer rendered objects. To do so, a system, method and program product are provided to represent a computer graphics textured object function that is defined over an orientation in a tangent space of the object using different textures or basis functions. The implementations described herein can be performed using commodity graphics hardware in real time, interactively. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> A technique is presented for casting of shadows by a precomputation of limited visibility for each point on a bump mapped surface. In particular, the lowest angle to the horizon is encoded in a discrete number of radial directions to each point to represent at what height each point becomes visible from each radial direction. This parameterization produces the self-shadowing of the surface geometry. </paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> Generally, the same numbers are used throughout the drawings to reference like elements and features. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> depicts a bumped curved surface having points thereon and an angle therefrom to the lowest eastern horizon. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> depicts one of the points seen in <cross-reference target="DRAWINGS">FIG. 1</cross-reference> at the origin, a projection of a vector to the light source upon the tangent plane contain the point in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, and an angle that represents the orientation of the projected vector in the tangent plane. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> depicts a normal N taken from a plane that is perpendicular to the surface seen in <cross-reference target="DRAWINGS">FIG. 1</cross-reference> at the point seen in <cross-reference target="DRAWINGS">FIGS. 1 and 2</cross-reference>. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a flow diagram showing an illustrative methodological implementation of the invention herein, and particularly showing preprocess precomputation operations performed noninteractively in texture space. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a flow diagram showing run time operations to follow the precomputation operations of <cross-reference target="DRAWINGS">FIG. 4</cross-reference>. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is a flow diagram showing run time operations to follow the run time operations of <cross-reference target="DRAWINGS">FIG. 5</cross-reference>. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> is a flow diagram showing run time operations to follow the run time operations of <cross-reference target="DRAWINGS">FIG. 6</cross-reference>. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> is an example of a computing operating environment capable of implementing, either wholly or partially, an illustrative implementation of the invention. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> FIGS. <highlight><bold>9</bold></highlight>A-<highlight><bold>9</bold></highlight>B through FIGS. <highlight><bold>17</bold></highlight>A-<highlight><bold>17</bold></highlight>C are renderings, in various stages thereof, that were produced using the interactive horizon mapping implementations disclosed herein.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION </heading>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> Bump and Horizon Mapping </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> In dot product bump mapping, also known normal mapping or bump mapping, vectors that are normal (&ldquo;the normals&rdquo;) to a surface are modified instead of modifying the height of the surface. The modifications to the normals render diffuse and specular reflections from small surface bumps on the surface. The technique directly stores the normals of the surface in texture maps. Bump mapping is particularly effective in rendering visual cues because the prime component in the calculation of the intensity of a picture element (pixel) is the direction of the surface normal at that pixel. For each point on a surface, there corresponds a height value by which this point would be raised on the surface. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> Horizon mapping approximates the shadows cast by the bumps on the same surface. As such, a computation can be made to self-shadow bump maps by describing the horizon for a small number of directions at each point in the height field. During rendering a shadow test is perform to determine, for each point on the height field, whether the light direction is above or below the interpolated horizon. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> The bump function produces a two dimensional table of height values for each point on the height field. A computation is made and stored, for each of the height values, of the lowest angle between a vector towards the visible horizon and the surface plane. A series of directions around the horizon, such as at the eight (8) main compass points&mdash;e.g. N, S, E, W, NE, SE, SW, and NW), are computed for each point on the height field of the surface plane. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> During the rendering stage, the lowest horizon angle at the intersection point is interpolated from the light direction and the horizon map for each point on the height field. If the lowest horizon angle from the surface normal is greater than the angle from the light direction to a point on the height field point, then that point is in shadow. Shadowing of bump mapped surfaces is implemented in an algorithm that maximizes the power of a frame buffer in a commodity graphics hardware environment so as to realize real time, interactivity in computer graphics applications. This algorithm, implemented in a computer graphics application, will now be discussed in reference to the Figures. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> depicts a bumped curved surface along a texture space axis &lsquo;U&rsquo; of a plane, the surface having three (3) points thereon, each point having a normal to the &lsquo;U&rsquo; axis that makes an angle &PHgr; with respect to the lowest eastern horizon vector for that point, where the numerical value of &PHgr; is shown. <cross-reference target="DRAWINGS">FIG. 1</cross-reference> also shows numerical values for the horizon angle in the westerly direction for each of the three points, although the topography to the west is no shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> depicts texture space axes &lsquo;U&rsquo; and &lsquo;V&rsquo; intersecting at one of the three (3) points seen in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, where a vector extends from that point towards a light source, the vector making an angle &thgr;<highlight><subscript>L </subscript></highlight>with respect to the &lsquo;U&rsquo; axis, where the light source is projected down to a location on the flat plane represented by texture space axes &lsquo;U&rsquo; and &lsquo;V&rsquo;, and where the location on the flat plane has the two-dimensional coordinates &lsquo;T&rsquo; and &lsquo;S&rsquo;. The angle &thgr;<highlight><subscript>L </subscript></highlight>represents the direction of light from the light source with respect to the tangent plane of the point. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> depicts the partials of the parameterization, namely vectors P<highlight><subscript>u</subscript></highlight>, P<highlight><subscript>v</subscript></highlight>, for a light vector L that makes an angle &PHgr;<highlight><subscript>L </subscript></highlight>with respect to a normal N taken from a plane that is tangential to the bumped surface seen in <cross-reference target="DRAWINGS">FIG. 1</cross-reference> at the point seen in <cross-reference target="DRAWINGS">FIGS. 1 and 2</cross-reference>. Normal N and the vectors P<highlight><subscript>u</subscript></highlight>, P<highlight><subscript>v </subscript></highlight>intersect at the point. Light from the depicted light source first strikes the point at the lowest angle &PHgr;<highlight><subscript>L </subscript></highlight>over the eastern horizon along a vector L. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> As seen by the examples in FIGS. <highlight><bold>1</bold></highlight>-<highlight><bold>3</bold></highlight>, P<highlight><subscript>u </subscript></highlight>and P<highlight><subscript>v </subscript></highlight>are the partials of the parameterization of the texture space axes &lsquo;u&rsquo; and &lsquo;v&rsquo;. A surface P(u,v) is parameterized on the unit square, and a surface normal N can be computed as the cross product of the partials of the surface P<highlight><subscript>u </subscript></highlight>and P<highlight><subscript>v</subscript></highlight>. Given a bump map F(u,v) as a non-negative scalar function parameterized over the same domain, the surface normal N can be modified, after dropping terms of first order, as follows: </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>P&prime;</italic></highlight><highlight><subscript>u</subscript></highlight><highlight><italic>&equals;P</italic></highlight><highlight><subscript>u</subscript></highlight><highlight><italic>&equals;F</italic></highlight><highlight><subscript>u</subscript></highlight><highlight><italic>N/N&verbar;N&verbar;, P&prime;</italic></highlight><highlight><subscript>v</subscript></highlight><highlight><italic>&equals;P</italic></highlight><highlight><subscript>v</subscript></highlight><highlight><italic>&plus;F</italic></highlight><highlight><subscript>u</subscript></highlight><highlight><italic>N/&verbar;N&verbar;, N&prime;&equals;P&prime;</italic></highlight><highlight><subscript>u</subscript></highlight><highlight><italic>&times;P&prime;</italic></highlight><highlight><subscript>v</subscript></highlight><highlight><italic>&equals;N&plus;D,</italic></highlight>&emsp;&emsp;(2) </in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula>where </in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>D</italic></highlight>&equals;(<highlight><italic>F</italic></highlight><highlight><subscript>u</subscript></highlight><highlight><italic>N&times;P</italic></highlight><highlight><subscript>v</subscript></highlight><highlight><italic>&minus;F</italic></highlight><highlight><subscript>v</subscript></highlight><highlight><italic>N&times;P</italic></highlight><highlight><subscript>u</subscript></highlight>)/&verbar;<highlight><italic>N&verbar;</italic></highlight>&emsp;&emsp;(3) </in-line-formula></paragraph>
<paragraph id="P-0037" lvl="7"><number>&lsqb;0037&rsqb;</number> is the perturbation of the normal. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> Horizon mapping is performed into the local coordinate system of the surface. This mapping is performed through the dual of the basis P<highlight><subscript>u</subscript></highlight>, P<highlight><subscript>v</subscript></highlight>, N, where N is the unbumpmapped surface normal which can be determined by an affine transform. The mapping is computed by building a matrix with the basis as columns and inverting it, where the rows of this inverse are a scaled version of N&times;P<highlight><subscript>v </subscript></highlight>and P<highlight><subscript>u</subscript></highlight>&times;N, along with N itself. A vector in this local frame has an associated orientation in the tangent plane &thgr; and an angle with the normal &PHgr;. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> There is then a determination made, at each pixel, whether a light vector, when transformed into the local coordinate frame, is visible above the horizon. To discover this, a horizon map, &PHgr;<highlight><subscript>u,v,&thgr;</subscript></highlight>, is built. The horizon map is tabulated at discrete u, v parameter values, and in a set of directions &thgr;, to represent the azimuth angle &PHgr; when a light would become visible at each direction &thgr;. By way of example, u and v are sampled fairly densely (e.g. 512&times;512), and &thgr; is sampled more coarsely (the eight (8) main compass points&mdash;e.g. N, S, E, W, NE, SE, SW, and NW). </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> An advantage is gained in horizon mapping of bumped, curved surfaces. Particularly, the precomputed horizon map is created in terms of the local geometry at each discrete (u, v) coordinate. This is possible and practical in the present implementation because the underlying geometry of the bumped, curved surface is known at the time when the horizon map is computed. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> Given the variable M to represent a number of sampled directions (the eight (8) main compass points&mdash;e.g. N, S, E, W, NE, SE, SW, and NW) for &thgr; and the discrete domain coordinates u<highlight><subscript>i</subscript></highlight>, v<highlight><subscript>j</subscript></highlight>, then the horizon angle &PHgr; (u<highlight><subscript>i</subscript></highlight>,v<highlight><subscript>j</subscript></highlight>, &thgr;) for any direction at coordinates u<highlight><subscript>i</subscript></highlight>, v<highlight><subscript>j </subscript></highlight>is found by interpolating between the discrete directions as follows:  
<math-cwu id="MATH-US-00001">
<number>1</number>
<math>
<mtable>
  <mtr>
    <mtd>
      <mrow>
        <mrow>
          <mrow>
            <mi>&phi;</mi>
            <mo>&af;</mo>
            <mrow>
              <mo>(</mo>
              <mrow>
                <msub>
                  <mi>u</mi>
                  <mi>i</mi>
                </msub>
                <mo>,</mo>
                <msub>
                  <mi>v</mi>
                  <mi>j</mi>
                </msub>
                <mo>,</mo>
                <mi>&theta;</mi>
              </mrow>
              <mo>)</mo>
            </mrow>
          </mrow>
          <mo>=</mo>
          <mrow>
            <munderover>
              <mo>&Sum;</mo>
              <mrow>
                <mi>k</mi>
                <mo>=</mo>
                <mn>1</mn>
              </mrow>
              <mi>M</mi>
            </munderover>
            <mo>&it;</mo>
            <mrow>
              <mrow>
                <msub>
                  <mi>B</mi>
                  <mi>k</mi>
                </msub>
                <mo>&af;</mo>
                <mrow>
                  <mo>(</mo>
                  <mi>&theta;</mi>
                  <mo>)</mo>
                </mrow>
              </mrow>
              <mo>&it;</mo>
              <mrow>
                <mi>&phi;</mi>
                <mo>&af;</mo>
                <mrow>
                  <mo>(</mo>
                  <mrow>
                    <mi>i</mi>
                    <mo>,</mo>
                    <mi>j</mi>
                    <mo>,</mo>
                    <mi>k</mi>
                  </mrow>
                  <mo>)</mo>
                </mrow>
              </mrow>
            </mrow>
          </mrow>
        </mrow>
        <mo>,</mo>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mo>(</mo>
        <mn>4</mn>
        <mo>)</mo>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
<mathematica-file id="MATHEMATICA-00001" file="US20030001859A1-20030102-M00001.NB"/>
<image id="EMI-M00001" wi="216.027" he="25.9119" file="US20030001859A1-20030102-M00001.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0042" lvl="7"><number>&lsqb;0042&rsqb;</number> where B<highlight><subscript>k </subscript></highlight>(&thgr;) is a basis function for the k<highlight><superscript>th </superscript></highlight>direction. The basis function B<highlight><subscript>k </subscript></highlight>(&thgr;) in the linear case is evaluated to one for the corresponding direction and linearly falls off to zero for the neighboring directions. For example, if the kth direction is east then the value of the linear basis function B<highlight><subscript>k </subscript></highlight>(&thgr;) is one when &thgr; equals east, and the value falls off to zero at the two closest compass points (northeast (NE) and southeast (SE)). In other words, the horizon angle &PHgr; is interpolated between discrete directions, noting that since this is a radial function it wraps around to interpolate between &PHgr; (i, j, 1) and &PHgr; (i, j, M). Similarly, the function &PHgr;(u, v, &thgr;) is bilinearly interpolated across the parameters u and v. In general the basis functions can be any functions that are all positive and sum to 1 for any orientation &thgr;. The coefficients for linear basis functions can be determined just by point sampling a discrete number of directions, but in general the coefficients for any shape of basis functions can be computed by solving a simple linear least squares problem that relates the coefficients of the basis functions to a potentially super sampled set of horizon angles at various orientations. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> To test the visibility of a light source from a point on a surface, the direction (x, y, z) from the point to the light source is transformed into the local tangent frame by a simple affine transform to provide the local coordinates (u, v, &thgr;). While the angle &thgr; could be determined by projecting the transformed vector onto the tangent plane, it is desirable that the first two transformed coordinates are used as a lookup into a table of &thgr; directions. The look up table will, by example, be encoded as a texture in the computer hardware. The table may be considered to be a set of texture maps. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> The texture mapping feature is conventional in commodity graphics hardware. By using the texture mapping feature that is provided with conventional commodity graphics hardware to store horizon maps, the need for sophisticated hardware and expensive host processor time is avoided. As such, horizon mapping of curved, bumped surfaces is enabled using the texture mapping capabilities of conventional commodity graphics hardware. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> General Self-Shadowing with Horizon Maps </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> The tangent plane parameterization and discretization used to compute shadows for bump maps can also be used to store global visibility information about a surface in general. The horizon angles are determined by shooting rays into a graphical object, starting from the horizon and moving towards the surface normal until there is no intersection. The largest angle that can be represented, by this determination of the horizon angles in the horizon map, is ninety (90) degrees out of the tangent plane. This determination of the shadows from bump maps is sufficient for most surfaces that lack undercut features. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> Implementation on Commodity Graphics Hardware </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> As was generally discussed above, horizon mapping can be performed for curved, bumped surfaces using the texture mapping capabilities of conventional commodity graphics hardware. A discussion is now presented, in reference to FIGS. <highlight><bold>4</bold></highlight>-<highlight><bold>7</bold></highlight>, for both the precomputation and the runtime shadowing algorithm and implementation thereof for commodity graphics hardware. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> Precomputation </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> The surface to be bumped and horizon mapped is tiled into a collection of polygons to which a texture is to be mapped in a parameterization thereof. The bump map will be represented in one such texture parameterization of the surface. The parameterization, seen at Block <highlight><bold>402</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, dictates how the bump map will wrap or fit upon the surface. The algorithm requires several inputs, including the coordinate values u, v associated with every vertex of each polygon, the geometry of the surface as a parameterization in the u, v coordinates, and a non-negative scalar valued bump map, F (u, v), depicted at Block <highlight><bold>404</bold></highlight>, that is parameterized over the surface. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> Before a graphical object is displayed upon a peripheral device, such as a computer screen, so as to be visible to a computer user, precomputation operations first are performed upon the inputs discussed above. For each vertex of each polygon representing a surface on each graphical object, a vector valued perturbed normal map, N&prime;(u, v) is precomputed at Block <highlight><bold>406</bold></highlight> from the non-negative scalar valued bump map, F (u, v). The normal map carries the bump map into the normal at every pixel. Stated otherwise, the surface height is perturbed at every pixel in this precomputation phase. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> To compute the normal map in texture space, there are given &lsquo;M&rsquo; directions in the tangent plane for an angle &thgr;<highlight><subscript>k&equals;1 . . . M</subscript></highlight>. M will, by example, be represented by the eight (8) main compass points (e.g. N, S, E, W, NE, SE, SW, and NW). As such, one horizon map, &PHgr;(u,v,&thgr;<highlight><subscript>k</subscript></highlight>), is computed for each &thgr;<highlight><subscript>k </subscript></highlight>at Block <highlight><bold>408</bold></highlight>, for a total of M horizon maps. When M&equals;8, the eight horizon maps be collected into only two (2) horizon maps by encoding four (4) of the eight directions into the four (4) color channels of texture storage. It is intended that the first direction be stored in the red channel, the second direction be stored in the green channel, the third direction be stored in the blue channel, and the forth direction is stored in the alpha (&agr;) channel. As such, the first horizon map might encode the directions N, NE, E and SE, while a second map encodes the directions S, SW, W and NW. Stated otherwise, a plurality of M radial directions could be approximately equally distributed from about zero radians to about 2&Pi; radians about each coordinate point (u, v). By way of example, one radial direction could be taken from about zero radians to about &Pi;/2 radians, another radial direction could be from about &Pi;/2 radians to about &Pi; radians, another radial direction could be from about H radians to about 3/2&Pi; radians, and still another radial direction could be from about 3/2&Pi; radians to about 2&Pi; radians. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> M basis maps are also precomputed. As such, there is one (1) basis function for each of the eight (8) discrete directions. Each of the M basis maps are derived at Block <highlight><bold>410</bold></highlight> and are represented by B<highlight><subscript>k</subscript></highlight>(s, t), where (s, t) represents the influence of the direction of the light source, &thgr;<highlight><subscript>k</subscript></highlight>, as set forth in Eq. 4, above. The encoding of the M basis maps will, by example, be similar to the encoding of the M horizon maps, again using the texture capabilities of conventional commodity graphics hardware. Accordingly, two (2) basis maps are encoded to each contain four (4) of the eight (8) directions. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> The encoding scheme for the normal and horizon maps realize a computational efficiency in that the dot products can be computed four (4) at a time by multiplying the weight of the basis function (the orientation value) times the horizon values. This implementation represents functions over orientations on a surface such that, for every point, for any orientation, there will be some function. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> An optional precomputation, seen at Block <highlight><bold>412</bold></highlight>, can derive a one dimensional arccosine mapping for each mapped point from the cosine of the horizon angle (cos(&PHgr;) to the horizon angle &PHgr;. This precomputation compares the cosines of the horizon angles instead of comparing the horizon angles themselves. Such an approximation is more readily realized because the dot products yield cosines. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> Another precomputation operation that is performed for each vertex is the scaling of the duals or a dual for the tangent frame basis, where computations are made for transformations into texture space. This per vertex computation, which is seen at Block <highlight><bold>414</bold></highlight>, is represented as </paragraph>
<paragraph lvl="0"><in-line-formula>&lsqb;P<highlight><subscript>u</subscript></highlight>, P<highlight><subscript>v</subscript></highlight>, N&rsqb;<highlight><superscript>&minus;1</superscript></highlight>&equals;&lsqb;S<highlight><superscript>T</superscript></highlight>, T<highlight><superscript>T</superscript></highlight>, N<highlight><superscript>T</superscript></highlight>&rsqb;,&emsp;&emsp;(5) </in-line-formula></paragraph>
<paragraph id="P-0057" lvl="7"><number>&lsqb;0057&rsqb;</number> and inverts the non-bump mapped local tangent frame. For a planar surface, the local tangent plane is the same for all vertices, but varies at each vertex over a curved surface. The inversion of the non-bump mapped local tangent frame allows a ready transform of the light direction onto the local tangent plane of the surface at each frame time. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> These precomputed data could be stored in volatile or nonvolatile memory since the date will not be needed until run time. By way of example and not by way of limitation, computer gaming applications may store horizon maps in precomputed texture space on computer readable media such as a CD-ROM. When the computer game is played, the CD-ROM is read by a computer having conventional commodity graphics hardware, or its functional equivalent, to access and use the precomputed horizon maps. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> At Each Frame Time, At Run Time </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> Use is made of the precomputed data during the interactive execution of the associated graphics program. For each scene to be rendered, given a current lighting condition, a computation is made at each vertex of each polygon for each graphical object for (s,t,&phgr;<highlight><subscript>L</subscript></highlight>), where s, t are the orientation coordinates of a point in the tangent plane at the vertex, and &phgr;<highlight><subscript>L </subscript></highlight>is the angle between the light and the normal at that point. The view to be rendered at this point is not taken into account because the shadows to be depicted are not view-dependent. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> Set Up Camera to Draw Into Texture Space </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> A computation is made at Block <highlight><bold>502</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 5</cross-reference> for each point as to the horizon angle that the light source would have be greater than for that point not to be in the shadow generated by the topography from that light source. Given the precomputation above, at each frame time, light is first projected in a light direction onto the local tangent plane at each vertex of each polygon. The light vector when dotted with the first two components of the inverted frame S and T yields the projection of the light vector into the coordinate space in the tangent plane resulting in the pair, (s, t). The light vector dotted with the normal at each vertex gives cos(&PHgr;<highlight><subscript>L</subscript></highlight>). </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> The remainder of the computation is carried out per pixel and is done in hardware using multi-texturing and blending into the frame buffer. The multi-texturing that is used in this implementation is different than conventional multi-texturing which multiplies the normal map times the diffuse color. This implementation, however, sums up the weighted basis functions instead. </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> The multi-texturing begins at Block <highlight><bold>504</bold></highlight> by setting transformations so as to render into UV space, by using the u, v coordinates as vertex coordinates. To do so, the textures are multiplied by the components thereof, the results of the multiplications are summed, and the results are stored in the alpha (&agr;) channel. The contribution for each of the first four (4) of eight (8) directions are accumulated into the frame buffer at Block <highlight><bold>506</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>. The first texture in the multi-texturing process is the basis map B<highlight><subscript>1 </subscript></highlight>(s, t) for the directions east, northeast, north, and northwest, where the s, t coordinates are for each vertex and are derived from the light direction. The second texture is the horizon map, &PHgr;<highlight><subscript>1 </subscript></highlight>(u, v), for the same directions as the first texture, but indexed by the u, v from the surface. </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> The contribution for each of the last four (4) of eight (8) directions are accumulated into the frame buffer at Block <highlight><bold>508</bold></highlight>. The first texture is the basis map B<highlight><subscript>2 </subscript></highlight>(s, t) for the directions east, northeast, north, and northwest, and the second texture is the horizon map, &PHgr;<highlight><subscript>2 </subscript></highlight>(U, V), for the same directions as the first texture. The resulting alpha (&agr;) channel now represents the horizon angle, &PHgr;, in the direction of the light. The results are saved into a texture map represented by &PHgr; (&thgr;<highlight><subscript>LIGHT</subscript></highlight>). </paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> The foregoing basis function and horizon map computations can be multiplied together and then added into the frame buffer for each of the eight (8) directions. The frame buffer then stores, for every pixel on each surface and for each of the eight directions, the angle to the horizon for each corresponding point on the surface. </paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> Set Up Camera to Draw Into Scene </paragraph>
<paragraph id="P-0068" lvl="0"><number>&lsqb;0068&rsqb;</number> Following the storage of the horizon angles in the frame buffer at Block <highlight><bold>510</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>, three (3) rendering passes are performed, each computing the transformations to draw into the current view of camera of the scene. The first pass, seen in <cross-reference target="DRAWINGS">FIG. 5</cross-reference> at reference numeral <highlight><bold>512</bold></highlight>, draws the model with only ambient lighting in the frame buffer. Also, the depth buffer is initialized to compute the distance of every pixel from the front of the scene such that only the front most pixel is visible. </paragraph>
<paragraph id="P-0069" lvl="0"><number>&lsqb;0069&rsqb;</number> A second of the three passes, seen in <cross-reference target="DRAWINGS">FIG. 6</cross-reference> at reference numeral <highlight><bold>602</bold></highlight>, creates a stencil that will only allow non-shadowed pixels to be rendered. This pass sets an alpha test, at Block <highlight><bold>604</bold></highlight>, which will accept pixels for display only if the corresponding alpha channel value is non-zero. All pixels having a non-zero value in the corresponding alpha channel are permitted to pass through at Block <highlight><bold>606</bold></highlight>. As such, the graphical object to be rendered is drawn to avoid drawing any point that is in shadow. Procedurally, no point is drawn where the stencil has a bit corresponding to the point that is set so as to be representative of the point being in shadow. Then, iterations are performed for each of the eight (8) directions. </paragraph>
<paragraph id="P-0070" lvl="0"><number>&lsqb;0070&rsqb;</number> After the directional iterations are computed in the second pass, a color mask is then set at Block <highlight><bold>608</bold></highlight> so that color channels are not written. The color mask thus preserves the ambient term that was set in the first pass. </paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> Following the color mask operation, a multi-texturing function is performed. The multi-texturing function is set to subtract values at Block <highlight><bold>610</bold></highlight>, where any negative value is set to zero, in that negative numbers are not meaningful to shadow renderings. </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> The scene is drawn at Block <highlight><bold>612</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 6</cross-reference> using the precomputed two (2) sets of texture coordinates. These texture coordinates represent, for each point given the direction of the current light source, the angles from the tangent plane of the point to the light source and the angles from the surface normal to the lowest horizontal point on the topography. Subtracting the two texture values will yield a light-value in the alpha (&agr;) channel. Positive light-values will result in the surface being drawn in the light and zero values will result in the surface being drawn in shadow, in that negative values are set to zero in the alpha channel. </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> The two textures used in the second pass and are represented as a ID texture and a 2D texture. The 1D texture is cos(&PHgr;)&gt;&PHgr;, where cos(&PHgr;) of the light was previously computed and store for at each vertex. This result contains the angle off the normal to the light at each pixel. The 2D texture is &PHgr;(&thgr;<highlight><subscript>LIGHT</subscript></highlight>) that was previously computed and stored for each vertex. The 2D texture encodes the angle off the normal of the horizon in the direction of the light at each pixel. </paragraph>
<paragraph id="P-0074" lvl="0"><number>&lsqb;0074&rsqb;</number> In essence, the foregoing 1D and 2D texture operations make use of the red, blue, green, and alpha channels that are conventionally used for lighting in the texture feature of commodity graphics hardware. The present implementation, however, uses these color channels to combine and weight the horizon textures with the basis textures in a reconstruction of the texturing function. As such, the implementation uses the general notion of a dot product different than is conventional. Accordingly, less computations are performed for each of the eight (8) directions, in that only two (2) passes are required, namely four (4) channels and directions on the first pass and four (4) channels and directions on the second pass, resulting in a computation that is four times as fast. </paragraph>
<paragraph id="P-0075" lvl="0"><number>&lsqb;0075&rsqb;</number> The last of the three passes, the initiation of which is seen in <cross-reference target="DRAWINGS">FIG. 7</cross-reference> at reference numeral <highlight><bold>702</bold></highlight>, performs a normal bump mapped rendering of the model wherever the pixels in the frame buffer are not in shadow. Since a test of the alpha channel would not be meaningful where points are in shadow, the alpha test is turned off at Block <highlight><bold>704</bold></highlight>. A stencil is set at Block <highlight><bold>706</bold></highlight> to prevent any pixel not having its stencil bit set from being drawn so that only those pixels intended to be seen are drawn. Then, at Block <highlight><bold>708</bold></highlight>, a color mask is set in place to allow for the writing of the color channels into the frame buffer. A blending function is enabled at Block <highlight><bold>710</bold></highlight>. The bending function adds other lighting to the ambient low level lighting that was previously accounted for in the frame buffer. The other lighting to be added to the image in this blending function includes diffuse and specular lighting. </paragraph>
<paragraph id="P-0076" lvl="0"><number>&lsqb;0076&rsqb;</number> Following the blending of other lighting, previously computed normal maps are added into the frame buffer at Block <highlight><bold>712</bold></highlight> to the graphical object to be rendered from the contents of the frame buffer in a standard bump mapping operation. Block <highlight><bold>712</bold></highlight> has the effect of shading the non-shadowed regions of the graphical object given the lighting present on the surfaces being rendered. Optionally, methods other than conventional normal mapping over the surfaces could also be used, such as bit mapped textures, etc. </paragraph>
<paragraph id="P-0077" lvl="0"><number>&lsqb;0077&rsqb;</number> Following the last of the three (3) passes, an image is rendered on a display device at Block <highlight><bold>714</bold></highlight> so as to display an ambient only term in shadowed regions and a normal bump mapping in non-shadowed regions. In order to create lighter shadows, the shadowed regions can be rendered with a lighter diffuse term rather than ambient only. This can be done in a fourth pass, not shown, by first setting the stencil function to only draw pixels that do not have the stencil bit set and by then drawing the geometry again using normal bump mapping, but with the scaled-down diffuse term. This fourth pass can also be combined with the first ambient pass. Iterating on creating the light dependent horizon map and the resulting alpha test can also be done for multiple light sources. </paragraph>
<paragraph id="P-0078" lvl="0"><number>&lsqb;0078&rsqb;</number> The results of the foregoing implementation, in various stages of renderings, are depicted in FIGS. <highlight><bold>9</bold></highlight>A-<highlight><bold>9</bold></highlight>B through FIGS. <highlight><bold>17</bold></highlight>A-<highlight><bold>17</bold></highlight>C. </paragraph>
<paragraph id="P-0079" lvl="0"><number>&lsqb;0079&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9A</cross-reference> depicts a basis function for the bump mapped surface rendering that is self-shadowed by horizon mapping and seen in <cross-reference target="DRAWINGS">FIG. 9B</cross-reference>. </paragraph>
<paragraph id="P-0080" lvl="0"><number>&lsqb;0080&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10A</cross-reference> shows the rendering of a normal map of a surface which is seen in <cross-reference target="DRAWINGS">FIG. 10B</cross-reference> with a horizon mapping that includes a light source coming from the north, and where <cross-reference target="DRAWINGS">FIG. 10C</cross-reference> illustrates the northerly light source basis texture for <cross-reference target="DRAWINGS">FIG. 10B</cross-reference>. </paragraph>
<paragraph id="P-0081" lvl="0"><number>&lsqb;0081&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 11A</cross-reference> is a rendering of a surface that is bump mapped, where the surface is rendered in <cross-reference target="DRAWINGS">FIG. 11B</cross-reference> with shadowing via horizon mapping by a northeasterly light source. </paragraph>
<paragraph id="P-0082" lvl="0"><number>&lsqb;0082&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 12A and 12B</cross-reference>, both of which are seen as being lit by a northeasterly light source, are renderings that feature horizon mapping techniques that are, respectively, point sampling and curve fitting. </paragraph>
<paragraph id="P-0083" lvl="0"><number>&lsqb;0083&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 13A and 13B</cross-reference> are renderings of the same bump mapped surface lit by a southwesterly light source, where <cross-reference target="DRAWINGS">FIG. 13A</cross-reference> illustrates shadows rendered by point sampled horizon mapping, where <cross-reference target="DRAWINGS">FIG. 13B</cross-reference> features the shadow that are smoother than that of <cross-reference target="DRAWINGS">FIG. 13</cross-reference>A through the use of a super sampling of curve fitting in a horizon mapping technique. </paragraph>
<paragraph id="P-0084" lvl="0"><number>&lsqb;0084&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 14A and 14B</cross-reference> are renderings of the same bump mapped surface lit by a southwesterly light source, where <cross-reference target="DRAWINGS">FIG. 14A</cross-reference> has rougher shadows of point sampled horizon mapping and <cross-reference target="DRAWINGS">FIG. 14B</cross-reference> features smoother shadows that are accomplished by sampling more points than the rendering seen in <cross-reference target="DRAWINGS">FIG. 14A</cross-reference>. </paragraph>
<paragraph id="P-0085" lvl="0"><number>&lsqb;0085&rsqb;</number> FIGS. <highlight><bold>15</bold></highlight>A-C are renderings of bump mapped surface of a simple plane, and respectively showing a normal map without shadowing, dense shadows accomplished by horizon mapping, and light shadows accomplished by horizon mapping. </paragraph>
<paragraph id="P-0086" lvl="0"><number>&lsqb;0086&rsqb;</number> FIGS. <highlight><bold>16</bold></highlight>A-C are renderings of the same bump mapped cylindrical surface having 160 vertices and 158 triangles, and respectively showing the cylindrical surface without horizon mapping, with dense shadows accomplished by horizon mapping, and with light shadows accomplished by horizon mapping. </paragraph>
<paragraph id="P-0087" lvl="0"><number>&lsqb;0087&rsqb;</number> FIGS. <highlight><bold>17</bold></highlight>A-C are renderings of the same bump mapped tessellated BSpline surface having 1600 vertices and 3042 triangles, and respectively showing dense shadows accomplished by horizon mapping, light shadows accomplished by horizon mapping, and light from a different direction seen from a different view, where <cross-reference target="DRAWINGS">FIGS. 17A and 17B</cross-reference> simulate a shadow from a raised surface that is cast upon a shadow from the recessed surface. </paragraph>
<paragraph id="P-0088" lvl="0"><number>&lsqb;0088&rsqb;</number> In may be advantageous to alter the conventional graphics pipeline processing for the benefit of the foregoing implementation so as to reduce the number of passes required. One such option would be to put the alpha and stencil tests after the blending of fragments with the color already in the frame buffer. This alteration would eliminate the frame-buffer-to-texture-memory copy operation. To do so, the lighting direction could be written into tangent space into the alpha channel when the ambient term is written. Then, subtractions are made from the contributions from each of the direction passes. This would also eliminate one rendering pass for the geometry. </paragraph>
<paragraph id="P-0089" lvl="0"><number>&lsqb;0089&rsqb;</number> Having a versatile vertex shader, other than the functions of same that have been described herein, would allow the precomputation of the s, t texture coordinates, rather than requiring computation of the same at run time. It would be desirable that such versatility be fully interoperable with the transform and lighting components of conventional commodity graphics hardware. </paragraph>
<paragraph id="P-0090" lvl="0"><number>&lsqb;0090&rsqb;</number> As an option to the above described implementation a different implementation in commodity graphics hardware can also be made without leveraging dot product fragment operations. It has been found, however, that a significant performance penalty will be had without use of dot product fragments. </paragraph>
<paragraph id="P-0091" lvl="0"><number>&lsqb;0091&rsqb;</number> The inventors intend these exemplary implementations to be examples and not to limit the scope of the present invention. Rather, the inventors have contemplated that the present invention might also be embodied and implemented in other ways, in conjunction with other present or future technologies </paragraph>
<paragraph id="P-0092" lvl="0"><number>&lsqb;0092&rsqb;</number> Exemplary Computing System and Environment </paragraph>
<paragraph id="P-0093" lvl="0"><number>&lsqb;0093&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> illustrates an example of a suitable computing environment <highlight><bold>800</bold></highlight> within which interactive horizon mapping, as described herein, may be implemented (either fully or partially). The computing environment <highlight><bold>800</bold></highlight> may be utilized in the computer and network architectures described herein. </paragraph>
<paragraph id="P-0094" lvl="0"><number>&lsqb;0094&rsqb;</number> The exemplary computing environment <highlight><bold>800</bold></highlight> is only one example of a computing environment and is not intended to suggest any limitation as to the scope of use or functionality of the computer and network architectures. Neither should the computing environment <highlight><bold>800</bold></highlight> be interpreted as having any dependency or requirement relating to any one or combination of components illustrated in the exemplary computing environment <highlight><bold>800</bold></highlight>. </paragraph>
<paragraph id="P-0095" lvl="0"><number>&lsqb;0095&rsqb;</number> Interactive horizon mapping may be implemented with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems, environments, and/or configurations that may be suitable for use include, but are not limited to, personal computers, server computers, thin clients, thick clients, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and the like. </paragraph>
<paragraph id="P-0096" lvl="0"><number>&lsqb;0096&rsqb;</number> Interactive horizon mapping may be described in the general context of computer-executable instructions, such as program modules, being executed by a computer. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. Interactive horizon mapping may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices. </paragraph>
<paragraph id="P-0097" lvl="0"><number>&lsqb;0097&rsqb;</number> The computing environment <highlight><bold>800</bold></highlight> includes a general-purpose computing device in the form of a computer <highlight><bold>802</bold></highlight>. The components of computer <highlight><bold>802</bold></highlight> can include, by are not limited to, one or more processors or processing units <highlight><bold>804</bold></highlight>, a system memory <highlight><bold>906</bold></highlight>, and a system bus <highlight><bold>908</bold></highlight> that couples various system components including the processor <highlight><bold>904</bold></highlight> to the system memory <highlight><bold>906</bold></highlight>. </paragraph>
<paragraph id="P-0098" lvl="0"><number>&lsqb;0098&rsqb;</number> The system bus <highlight><bold>908</bold></highlight> represents one or more of any of several types of bus structures, including a memory bus or memory controller, a peripheral bus, an accelerated graphics port, and a processor or local bus using any of a variety of bus architectures. By way of example, such architectures can include an Industry Standard Architecture (ISA) bus, a Micro Channel Architecture (MCA) bus, an Enhanced ISA (EISA) bus, a Video Electronics Standards Association (VESA) local bus, and a Peripheral Component Interconnects (PCI) bus also known as a Mezzanine bus. </paragraph>
<paragraph id="P-0099" lvl="0"><number>&lsqb;0099&rsqb;</number> Computer <highlight><bold>802</bold></highlight> typically includes a variety of computer readable media. Such media can be any available media that is accessible by computer <highlight><bold>802</bold></highlight> and includes both volatile and non-volatile media, removable and non-removable media. </paragraph>
<paragraph id="P-0100" lvl="0"><number>&lsqb;0100&rsqb;</number> The system memory <highlight><bold>806</bold></highlight> includes computer readable media in the form of volatile memory, such as random access memory (RAM) <highlight><bold>810</bold></highlight>, and/or non-volatile memory, such as read only memory (ROM) <highlight><bold>812</bold></highlight>. A basic input/output system (BIOS) <highlight><bold>814</bold></highlight>, containing the basic routines that help to transfer information between elements within computer <highlight><bold>802</bold></highlight>, such as during start-up, is stored in ROM <highlight><bold>812</bold></highlight>. RAM <highlight><bold>810</bold></highlight> typically contains data and/or program modules that are immediately accessible to and/or presently operated on by the processing unit <highlight><bold>804</bold></highlight>. System memory <highlight><bold>806</bold></highlight> is an example of a means for storing data having inputs and outputs and a frame buffer for storing pixel representations from which to render a three-dimensional graphical object. </paragraph>
<paragraph id="P-0101" lvl="0"><number>&lsqb;0101&rsqb;</number> Computer <highlight><bold>802</bold></highlight> may also include other removable/non-removable, volatile/non-volatile computer storage media. By way of example, <cross-reference target="DRAWINGS">FIG. 13</cross-reference> illustrates a hard disk drive <highlight><bold>816</bold></highlight> for reading from and writing to a non-removable, non-volatile magnetic media (not shown), a magnetic disk drive <highlight><bold>818</bold></highlight> for reading from and writing to a removable, non-volatile magnetic disk <highlight><bold>820</bold></highlight> (e.g., a &ldquo;floppy disk&rdquo;), and an optical disk drive <highlight><bold>822</bold></highlight> for reading from and/or writing to a removable, non-volatile optical disk <highlight><bold>824</bold></highlight> such as a CD-ROM, DVD-ROM, or other optical media. The hard disk drive <highlight><bold>816</bold></highlight>, magnetic disk drive <highlight><bold>818</bold></highlight>, and optical disk drive <highlight><bold>822</bold></highlight> are each connected to the system bus <highlight><bold>808</bold></highlight> by one or more data media interfaces <highlight><bold>826</bold></highlight>. Alternatively, the hard disk drive <highlight><bold>816</bold></highlight>, magnetic disk drive <highlight><bold>818</bold></highlight>, and optical disk drive <highlight><bold>822</bold></highlight> can be connected to the system bus <highlight><bold>808</bold></highlight> by one or more interfaces (not shown). </paragraph>
<paragraph id="P-0102" lvl="0"><number>&lsqb;0102&rsqb;</number> The disk drives and their associated computer-readable media provide non-volatile storage of computer readable instructions, data structures, program modules, and other data for computer <highlight><bold>802</bold></highlight>. Although the example illustrates a hard disk <highlight><bold>816</bold></highlight>, a removable magnetic disk <highlight><bold>820</bold></highlight>, and a removable optical disk <highlight><bold>824</bold></highlight>, it is to be appreciated that other types of computer readable media which can store data that is accessible by a computer, such as magnetic cassettes or other magnetic storage devices, flash memory cards, CD-ROM, digital versatile disks (DVD) or other optical storage, random access memories (RAM), read only memories (ROM), electrically erasable programmable read-only memory (EEPROM), and the like, can also be utilized to implement the exemplary computing system and environment. </paragraph>
<paragraph id="P-0103" lvl="0"><number>&lsqb;0103&rsqb;</number> Any number of program modules can be stored on the hard disk <highlight><bold>816</bold></highlight>, magnetic disk <highlight><bold>820</bold></highlight>, optical disk <highlight><bold>824</bold></highlight>, ROM <highlight><bold>812</bold></highlight>, and/or RAM <highlight><bold>810</bold></highlight>, including by way of example, an operating system <highlight><bold>826</bold></highlight>, one or more graphics application programs <highlight><bold>828</bold></highlight>, other program modules <highlight><bold>830</bold></highlight>, and program data <highlight><bold>832</bold></highlight>. Each of such operating system <highlight><bold>826</bold></highlight>, one or more graphics application programs <highlight><bold>828</bold></highlight>, other program modules <highlight><bold>830</bold></highlight>, and program data <highlight><bold>832</bold></highlight> (or some combination thereof) may include an embodiment of program code to perform interactive horizon mapping. </paragraph>
<paragraph id="P-0104" lvl="0"><number>&lsqb;0104&rsqb;</number> A user can enter commands and information into computer <highlight><bold>802</bold></highlight> via input devices such as a keyboard <highlight><bold>834</bold></highlight> and a pointing device <highlight><bold>836</bold></highlight> (e.g., a &ldquo;mouse&rdquo;). Other input devices <highlight><bold>838</bold></highlight> (not shown specifically) may include a microphone, joystick, game pad, satellite dish, serial port, scanner, and/or the like. These and other input devices are connected to the processing unit <highlight><bold>804</bold></highlight> via input/output interfaces <highlight><bold>840</bold></highlight> that are coupled to the system bus <highlight><bold>808</bold></highlight>, but may be connected by other interface and bus structures, such as a parallel port, game port, or a universal serial bus (USB). </paragraph>
<paragraph id="P-0105" lvl="0"><number>&lsqb;0105&rsqb;</number> A monitor <highlight><bold>842</bold></highlight> or other type of display device can also be connected to the system bus <highlight><bold>808</bold></highlight> via an interface, such as a video adapter/accelerator <highlight><bold>844</bold></highlight>. Video adapter/accelerator <highlight><bold>844</bold></highlight> is intended to have a component thereof that represents 3-D commodity graphics hardware. As such, the 3-D commodity graphics hardware is coupled to the high-speed system bus <highlight><bold>806</bold></highlight>. The 3-D commodity graphics hardware may be coupled to the system bus <highlight><bold>808</bold></highlight> by, for example, a cross bar switch or other bus connectivity logic. It is assumed that various other peripheral devices, or other buses, may be connected to the high-speed system bus <highlight><bold>808</bold></highlight>, as is well known in the art. Further, the 3-D commodity graphics hardware may be coupled through one or more other buses to system bus <highlight><bold>808</bold></highlight>. </paragraph>
<paragraph id="P-0106" lvl="0"><number>&lsqb;0106&rsqb;</number> Host processor <highlight><bold>804</bold></highlight> may transfer information to and from the 3-D commodity graphics hardware according to a programmed input/output (I/O) protocol over the system bus <highlight><bold>808</bold></highlight>. In one implementation, the 3-D commodity graphics hardware accesses the system memory <highlight><bold>806</bold></highlight> according to a direct memory access (DMA) protocol, or through intelligent bus mastering. </paragraph>
<paragraph id="P-0107" lvl="0"><number>&lsqb;0107&rsqb;</number> In one implementation, one or more graphics application programs <highlight><bold>828</bold></highlight> executing on processing unit <highlight><bold>804</bold></highlight> generates three-dimensional geometry data. The resulting 3-D geometry data can be stored in system memory <highlight><bold>806</bold></highlight> and then transferred to the 3-D commodity graphics hardware over system bus <highlight><bold>808</bold></highlight>. The 3-D commodity graphics hardware renders the resulting primitives accordingly on monitor <highlight><bold>842</bold></highlight>. The 3-D geometry data may also be transferred over a network for subsequent rendering, or stored to a removable medium such as a CD-ROM. The 3-D commodity graphics hardware performs bump mapping in a texture pipeline that includes dot products instructions. </paragraph>
<paragraph id="P-0108" lvl="0"><number>&lsqb;0108&rsqb;</number> In one implementation the 3-D commodity graphics hardware component of video adapter/accelerator <highlight><bold>844</bold></highlight> is intended to function as a 3-D graphics accelerator having a specialized rendering subsystem which is designed to off-load graphics processing functions from host processing unit <highlight><bold>804</bold></highlight>, thereby improving system performance. As such, an application program from any of program modules <highlight><bold>828</bold></highlight>-<highlight><bold>830</bold></highlight> executing on host processing unit <highlight><bold>804</bold></highlight> generates three-dimensional geometry data including information corresponding to points on the surface of a three-dimensional graphical object. These points are usable as vertices of polygons which, when connected, may be rendered to form a representation of the graphical object. The application program causes host processing unit <highlight><bold>840</bold></highlight> to transfer this 3-D geometry data to the graphics accelerator, along with corresponding control and connectivity information. The graphics accelerator receives this stream of 3-D geometry data and renders the encoded polygons on an attached display device. </paragraph>
<paragraph id="P-0109" lvl="0"><number>&lsqb;0109&rsqb;</number> Hosting processing unit <highlight><bold>804</bold></highlight> and video adapter/accelerator <highlight><bold>844</bold></highlight> function together as an example of a means for generating a bump mapped surface of a three-dimensional graphical object and a means for generating a horizon map of the bump mapped surface. System memory <highlight><bold>806</bold></highlight> is an example of a means for storing the generated horizon map in a texture map for reuse in rendering the three-dimensional graphical object. Host processor <highlight><bold>804</bold></highlight> and video adapter/accelerator <highlight><bold>844</bold></highlight> are illustrated as being coupled to monitor <highlight><bold>842</bold></highlight>, several input devices, and system memory <highlight><bold>806</bold></highlight>. This coupling enable control of bump and horizon map generation as well as the pixel representations in the frame buffer of system memory <highlight><bold>806</bold></highlight> to produce on the monitor <highlight><bold>842</bold></highlight> a rendering of shadows cast by light upon the bump mapped surface of the three-dimensional graphical object as a function of the horizon map. </paragraph>
<paragraph id="P-0110" lvl="0"><number>&lsqb;0110&rsqb;</number> In addition to the monitor <highlight><bold>842</bold></highlight>, other output peripheral devices can include components such as speakers (not shown) and a printer <highlight><bold>846</bold></highlight> which can be connected to computer <highlight><bold>802</bold></highlight> via the input/output interfaces <highlight><bold>840</bold></highlight>. </paragraph>
<paragraph id="P-0111" lvl="0"><number>&lsqb;0111&rsqb;</number> Computer <highlight><bold>802</bold></highlight> can operate in a networked environment using logical connections to one or more remote computers, such as a remote computing device <highlight><bold>848</bold></highlight>. By way of example, the remote computing device <highlight><bold>848</bold></highlight> can be a personal computer, portable computer, a server, a router, a network computer, a peer device or other common network node, and the like. </paragraph>
<paragraph id="P-0112" lvl="0"><number>&lsqb;0112&rsqb;</number> The remote computing device <highlight><bold>848</bold></highlight> is illustrated as a portable computer that can include many or all of the elements and features described herein relative to computer <highlight><bold>802</bold></highlight>. Logical connections between computer <highlight><bold>802</bold></highlight> and the remote computer <highlight><bold>848</bold></highlight> are depicted as a local area network (LAN) <highlight><bold>850</bold></highlight> and a general wide area network (WAN) <highlight><bold>852</bold></highlight>. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets, and the Internet. </paragraph>
<paragraph id="P-0113" lvl="0"><number>&lsqb;0113&rsqb;</number> When implemented in a LAN networking environment, the computer 802 is connected to a local network <highlight><bold>850</bold></highlight> via a network interface or adapter <highlight><bold>854</bold></highlight>. When implemented in a WAN networking environment, the computer <highlight><bold>802</bold></highlight> typically includes a modem <highlight><bold>856</bold></highlight> or other means for establishing communications over the wide network <highlight><bold>852</bold></highlight>. The modem <highlight><bold>856</bold></highlight>, which can be internal or external to computer <highlight><bold>802</bold></highlight>, can be connected to the system bus <highlight><bold>808</bold></highlight> via the input/output interfaces <highlight><bold>840</bold></highlight> or other appropriate mechanisms. It is to be appreciated that the illustrated network connections are exemplary and that other means of establishing communication link(s) between the computers <highlight><bold>802</bold></highlight> and <highlight><bold>848</bold></highlight> can be employed. </paragraph>
<paragraph id="P-0114" lvl="0"><number>&lsqb;0114&rsqb;</number> In a networked environment, such as that illustrated with computing environment <highlight><bold>800</bold></highlight>, program modules depicted relative to the computer <highlight><bold>802</bold></highlight>, or portions thereof, may be stored in a remote memory storage device. By way of example, remote application programs <highlight><bold>858</bold></highlight> reside on a memory device of remote computer <highlight><bold>848</bold></highlight>. For purposes of illustration, application programs and other executable program components such as the operating system are illustrated herein as discrete blocks, although it is recognized that such programs and components reside at various times in different storage components of the computing device <highlight><bold>802</bold></highlight>, and are executed by the data processor(s) of the computer. </paragraph>
<paragraph id="P-0115" lvl="0"><number>&lsqb;0115&rsqb;</number> Computer-Executable Instructions </paragraph>
<paragraph id="P-0116" lvl="0"><number>&lsqb;0116&rsqb;</number> An implementation of interactive horizon mapping may be described in the general context of computer-executable instructions, such as program modules, executed by one or more computers or other devices. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. Typically, the functionality of the program modules may be combined or distributed as desired in various embodiments. </paragraph>
<paragraph id="P-0117" lvl="0"><number>&lsqb;0117&rsqb;</number> Exemplary Operating Environment </paragraph>
<paragraph id="P-0118" lvl="0"><number>&lsqb;0118&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> illustrates an example of a suitable operating environment <highlight><bold>800</bold></highlight> in which an exemplary interactive horizon mapping may be implemented. Specifically, the exemplary interactive horizon mapping described herein may be implemented (wholly or in part) by any program modules <highlight><bold>828</bold></highlight>-<highlight><bold>830</bold></highlight> and/or operating system <highlight><bold>826</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 8</cross-reference> or a portion thereof. </paragraph>
<paragraph id="P-0119" lvl="0"><number>&lsqb;0119&rsqb;</number> The operating environment is only an example of a suitable operating environment and is not intended to suggest any limitation as to the scope or use of functionality of the exemplary interactive horizon mapping described herein. Other well known computing systems, environments, and/or configurations that are suitable for use include, but are not limited to, personal computers (PCs), server computers, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, programmable consumer electronics, wireless phones and equipments, general- and special-purpose appliances, application-specific integrated circuits (ASICs), network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and the like. </paragraph>
<paragraph id="P-0120" lvl="0"><number>&lsqb;0120&rsqb;</number> Computer Readable Media </paragraph>
<paragraph id="P-0121" lvl="0"><number>&lsqb;0121&rsqb;</number> An implementation of an exemplary interactive horizon mapping may be stored on or transmitted across some form of computer readable media. Computer readable media can be any available media that can be accessed by a computer. By way of example, and not limitation, computer readable media may comprise &ldquo;computer storage media&rdquo; and &ldquo;communications media.&rdquo;</paragraph>
<paragraph id="P-0122" lvl="0"><number>&lsqb;0122&rsqb;</number> &ldquo;Computer storage media&rdquo; include volatile and non-volatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules, or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by a computer. </paragraph>
<paragraph id="P-0123" lvl="0"><number>&lsqb;0123&rsqb;</number> &ldquo;Communication media&rdquo; typically embodies computer readable instructions, data structures, program modules, or other data in a modulated data signal, such as carrier wave or other transport mechanism. Communication media also includes any information delivery media. </paragraph>
<paragraph id="P-0124" lvl="0"><number>&lsqb;0124&rsqb;</number> The term &ldquo;modulated data signal&rdquo; means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared, and other wireless media. Combinations of any of the above are also included within the scope of computer readable media. </paragraph>
<paragraph id="P-0125" lvl="0"><number>&lsqb;0125&rsqb;</number> For purposes of the explanation, specific numbers, materials and configurations are set forth above in order to provide a thorough understanding of the present invention. However, it will be apparent to one skilled in the art that the present invention may be practiced without the specific exemplary details. In other instances, well-known features are omitted or simplified to clarify the description of the exemplary implementations of present invention, and thereby better explain the present invention. Furthermore, for ease of understanding, certain method operations are delineated as separate operations; however, these separately delineated operations should not be construed as necessarily order dependent in their performance. </paragraph>
<paragraph id="P-0126" lvl="0"><number>&lsqb;0126&rsqb;</number> The present invention may be embodied in other specific forms without departing from its spirit or essential characteristics. The described embodiments are to be considered in all respects only as illustrative and not restrictive. The scope of the invention is, therefore, indicated by the appended claims rather than by the foregoing description. All changes which come within the meaning and range of equivalency of the claims are to be embraced within their scope. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method for rendering a graphical object, the method comprising: 
<claim-text>defining a bump map to describe a bump mapped surface on a three-dimensional graphical object; and </claim-text>
<claim-text>defining a horizon map for the bump mapped surface in a plurality of color channels of a set of texture maps. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method as defined in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising: 
<claim-text>defining light having a direction relative to the bump mapped surface; </claim-text>
<claim-text>interpolating from the horizon map relative to the direction of light to determine those portions of the bump mapped surface that are: 
<claim-text>lit by the defined light; and </claim-text>
<claim-text>in a shadow cast by a bump of the bump mapped surface; </claim-text>
</claim-text>
<claim-text>rendering, from a given point of view, the lit portions of the bump mapped surface. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method as defined in <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, further comprising: 
<claim-text>interactively receiving instructions that change the direction of light relative to the bump mapped surface; </claim-text>
<claim-text>repeating the interpolating using the changed direction of light; and </claim-text>
<claim-text>repeating the rendering using the changed direction of light to render lit portions of the bump mapped surface. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method as defined in <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, wherein: 
<claim-text>rendering, from a given point of view, the lit portions of the bump mapped surface further comprises: 
<claim-text>applying bump map data from the bump map to a perspective view of the three-dimensional graphical object; </claim-text>
<claim-text>merging the set of texture maps with the bump map data; and </claim-text>
<claim-text>displaying, from the given point of view, the perspective view of the three-dimensional graphical object on a computer display. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method as defined in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein each texture map includes, for one encoded radial direction in a tangent plane around each vertex of a plurality of primitives defining the surface of the three-dimensional graphical object, the smallest angle between a normal vector to the vertex and a vector from the vertex to one of the bumps on the bump mapped surface in the one radial direction. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method as defined in <dependent-claim-reference depends_on="CLM-00004">claim 4</dependent-claim-reference>, wherein: 
<claim-text>the set of texture maps comprises two texture maps each corresponding to not more than four radial directions in a tangent plane around each vertex of a plurality of primitives defining the surface of the three-dimensional graphical object; and </claim-text>
<claim-text>each said radial direction is relative to a tangent plane of a surface on the three-dimensional graphical object; and </claim-text>
<claim-text>each said radial direction is encoded in one colors channel of one said color channel. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. A computer-readable media comprising computer-executable instructions for performing the rendering method as recited in <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. For a surface on a three-dimensional graphical object that is represented by a plurality of vertices in a tangent plane of the surface, where a bump map of the surface defines a bump mapped surface that includes a plurality of bumps on the bump mapped surface relative to the plurality of vertices, a method for rendering the bump mapped surface on the three-dimensional graphical object, the method comprising: 
<claim-text>deriving a horizon map relative to the bum mapped surface for a plurality of radial directions in the tangent plane around one said vertex, wherein the derived horizon map for each of the radial directions is in a color channel of a texture map; and </claim-text>
<claim-text>repeating the horizon map derivation for each vertex of said plurality of vertices, whereby a plurality of horizon maps are derived for the bump mapped surface. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The method as defined in <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference>, further comprising: 
<claim-text>defining light having a direction relative to the tangent plane; </claim-text>
<claim-text>interpolating, relative to the direction of light, from said plurality of horizon maps for the bump mapped surface to determine those portions of the bump mapped surface that are: 
<claim-text>lit by the defined light; and </claim-text>
<claim-text>in a shadow cast by a bump of the bump mapped surface; </claim-text>
</claim-text>
<claim-text>rendering the bump mapped surface on the three-dimensional graphical object, from a given point of view, to depict both the lit portions of the bump mapped surface and the shadows that are cast by bumps of the bump mapped surface. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The method as defined in <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, further comprising: 
<claim-text>interactively receiving instructions that change the direction of light relative to the bump mapped surface; and </claim-text>
<claim-text>repeating, using the changed direction of light, the interpolating and the rendering. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The method as defined in <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference>, wherein each said derivation of each of the horizon maps includes at least one of the radial directions that is: 
<claim-text>from about zero radians to about &Pi;/2 radians; </claim-text>
<claim-text>from about &Pi;/2 radians to about &Pi; radians; </claim-text>
<claim-text>from about n radians to about 3/2&Pi; radians; and </claim-text>
<claim-text>from about 3/2&Pi; radians to about 2&Pi; radians. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The rendering method as defined in <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, wherein the interpolating further comprises determining at least two of the radial directions to the direction of light relative to the tangent plane. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. A computer-readable media comprising computer-executable instructions for performing the method as recited in <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. For a surface on a three-dimensional graphical object that is represented by a plurality of vertices in a tangent plane of the surface, where a bump map of the surface defines a bump mapped surface that includes a plurality of bumps on the bump mapped surface relative to the plurality of vertices, each vertex having corresponding a horizon map for a plurality of radial directions about the vertex in the tangent plane, a method for rendering the bump mapped surface on the three-dimensional graphical object, the method comprising: 
<claim-text>defining light having a direction relative to the tangent plane; </claim-text>
<claim-text>interpolating, relative to the direction of light, from each horizon map of each of the vertices for the bump mapped surface to determine those portions of the bump mapped surface that are: 
<claim-text>lit by the defined light; and </claim-text>
<claim-text>in a shadow cast by a bump of the bump mapped surface; </claim-text>
</claim-text>
<claim-text>rendering the bump mapped surface on the three-dimensional graphical object, from a given point of view, to depict both the lit portions of the bump mapped surface and the shadows that are cast by bumps of the bump mapped surface, wherein: 
<claim-text>the horizon map for each of the vertices is stored in a texture map having a plurality of color channels; and </claim-text>
<claim-text>the corresponding horizon angle of the horizon map for each of the radial direction around each of the vertices is in a color channel of the corresponding texture map. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The method as defined in <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference>, wherein each of the horizon maps includes at least one of the radial directions about each said vertex that is: 
<claim-text>from about zero radians to about &Pi;/2 radians; </claim-text>
<claim-text>from about &Pi;/2 radians to about &Pi; radians; </claim-text>
<claim-text>from about &Pi; radians to about 3/2&Pi; radians; and </claim-text>
<claim-text>from about 3/2&Pi; radians to about 2&Pi; radians. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The rendering method as defined in <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference>, wherein the interpolating further comprises determining at least two of the radial directions in the corresponding horizon map to the direction of light relative to the tangent plane. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The method as defined in <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference>, further comprising: 
<claim-text>interactively receiving instructions that change the direction of light relative to the bump mapped surface; and </claim-text>
<claim-text>repeating, using the changed direction of light, the interpolating and the rendering. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. A computer-readable media comprising computer-executable instructions for performing the method as recited in <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference>. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. A method comprising: 
<claim-text>representing a surface on a three-dimensional graphical object by a plurality of polygons, each polygon having a plurality of vertices, each vertex defining a point in a tangent plane of the surface; </claim-text>
<claim-text>perturbing a vertex normal vector of the surface at each said vertex to define a plurality of bumps on the surface; and </claim-text>
<claim-text>defining in a color channel of a texture map, for each of a plurality of radial directions in the tangent plane around each said vertex, the smallest angle between the vertex normal vector and a vector from the vertex to one of the bumps in the respective radial direction. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The method as defined in <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference>, further comprising: 
<claim-text>defining light by a direction relative to: 
<claim-text>the tangent plane of the surface; and </claim-text>
<claim-text>each said vertex normal vector; </claim-text>
</claim-text>
<claim-text>determining, by interpolation from the color channels of the texture maps with respect to the direction of light, the portion of each said polygon that is lit by the defined light; and </claim-text>
<claim-text>rendering, from a given point of view, the portion of each said polygon that is lit by light and any other portion of each said polygon is in the shadow that is cast by the bumps on the surface in the direction of light, whereby the surface is displayed with shadows cast by bumps on the surface. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The method as defined in <dependent-claim-reference depends_on="CLM-00022">claim 20</dependent-claim-reference>, further comprising: 
<claim-text>interactively receiving instructions to change the direction of light relative to the surface on the three-dimensional graphical object; and </claim-text>
<claim-text>repeating, using the changed direction of light relative to the surface on the three-dimensional graphical object, the determining and the rendering. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The method as defined in <dependent-claim-reference depends_on="CLM-00022">claim 20</dependent-claim-reference>, wherein the determining further comprises: 
<claim-text>determining at least two of the radial directions in the tangent plane around the corresponding vertex of each said polygon to the direction of the light source; and </claim-text>
<claim-text>interpolating from the angle in the color channel in the text map corresponding to the at least two radial directions. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. A computer-readable media comprising computer-executable instructions for performing the method as recited in <dependent-claim-reference depends_on="CLM-00022">claim 20</dependent-claim-reference>. </claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. A method for determining shadowing cast onto a bump mapped surface by one or more bumps thereon, where the bump mapped surface is represented by a plurality of polygons each having a plurality of vertices, each vertex defining a point in a tangent plane of the bump mapped surface, where a normal vector at each said vertex is perturbed to define a bump map of the bump mapped surface that includes a plurality of bumps on the surface, the method comprising: 
<claim-text>defining a horizon map of the surface including, for each of a plurality of radial directions in the tangent plane around each said vertex, the largest angle between the normal vector and any direct ray of light to the vertex; and </claim-text>
<claim-text>storing the horizon map as a set of texture maps corresponding to the surface on the three-dimensional graphical object. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. The method as defined in <dependent-claim-reference depends_on="CLM-00022">claim 24</dependent-claim-reference>, further comprising: 
<claim-text>executing an interactive program that defines a light source by a direction relative to: 
<claim-text>the tangent plane of the surface; and </claim-text>
<claim-text>the normal of each said vertex; </claim-text>
</claim-text>
<claim-text>determining at least two of the radial directions stored in the horizon map with respect to the direction of the light source; </claim-text>
<claim-text>interpolating from the largest angles at the at least two radial directions of the horizon map to obtain the portion of each said polygon that is in the light from the light source; </claim-text>
<claim-text>rendering the surface on the three-dimensional graphical object, from a given point of view, to include only the portion of each said polygon that is in the light from the light source; </claim-text>
<claim-text>interactively receiving instructions to change the direction of the light source relative to the surface on the three-dimensional graphical object; </claim-text>
<claim-text>repeating the determining by interpolation step using the changed direction of the light source relative to the surface on the three-dimensional graphical object; and </claim-text>
<claim-text>repeating the rendering. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. The method as defined in <dependent-claim-reference depends_on="CLM-00022">claim 24</dependent-claim-reference>, wherein for each said vertex, each said texture map has a plurality of colors channels, each said color channel having encoded therein the largest angle between the normal vector and any direct ray of light to the vertex that does not contact any of the bumps on the surface. </claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. The method as defined in <dependent-claim-reference depends_on="CLM-00022">claim 26</dependent-claim-reference>, wherein: 
<claim-text>the set of texture maps comprises two texture maps; and </claim-text>
<claim-text>each said texture map: 
<claim-text>corresponding to not more that four of the radial directions; and </claim-text>
<claim-text>has four colors channels each having not more than one radial direction encoding for the corresponding largest angle for each vertex between the normal vector and any direct ray of light to the vertex that does not contact any of the bumps on the surface. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. A computer-readable media comprising computer-executable instructions for performing the method as recited in <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>. </claim-text>
</claim>
<claim id="CLM-00029">
<claim-text><highlight><bold>29</bold></highlight>. A method for rendering a frame in a frame buffer represented by a plurality of pixels, the frame depicting a three dimensional graphical object that is defined by surfaces each having a surface geometry defined by a parameterization of a plurality of polygons, each polygon being defined by vertices, each vertex (u, v) having a bump map scalar value F(u,v) defining a bump, each vertex (u,v) having a perturbed normal map vector value N&prime;(u,v) from the bump map scalar value F(u,v), each vertex (u,v) having M basis maps (B<highlight><subscript>k&equals;1 M</subscript></highlight>(s, t)), each vertex (u, v) having M horizon maps for each of M radial directions (&thgr;<highlight><subscript>k&equals;1 M</subscript></highlight>) in the tangent plane of the vertex (u, v), wherein each of the M horizon maps includes the largest angle &PHgr;(u,v,&thgr;<highlight><subscript>k&equals;1 M</subscript></highlight>) between the perturbed normal map vector value N&prime;(u, v) and any direct ray to the vertex (u, v), the method comprising: 
<claim-text>(i) defining a light vector (L) having a direction defined by: 
<claim-text>the angle &thgr;<highlight><subscript>L </subscript></highlight>between the light vector (L) and the plane formed by coordinates (u,v); and </claim-text>
<claim-text>the angle &PHgr;<highlight><subscript>L </subscript></highlight>between the light vector (L) and the perturbed normal map vector value N&prime;(u,v); </claim-text>
</claim-text>
<claim-text>(ii) inverting a local tangent frame by &lsqb;P<highlight><subscript>u</subscript></highlight>, P<highlight><subscript>v</subscript></highlight>, N&rsqb;<highlight><superscript>&minus;1</superscript></highlight>&equals;&lsqb;S<highlight><superscript>T</superscript></highlight>, T<highlight><superscript>T</superscript></highlight>, N<highlight><superscript>T</superscript></highlight>&rsqb; to obtain an inverted tangent frame (S,T); </claim-text>
<claim-text>(iii) taking the dot product of the light vector(L): 
<claim-text>with the first two components of the inverted frame (S, T) to obtain the projection of the light vector (L) into the coordinate space in the tangent plane at a coordinate pair (s, t); and </claim-text>
<claim-text>with the perturbed normal map vector value N&prime;(u, v) at the vertex to obtain cosine (&PHgr;<highlight><subscript>L</subscript></highlight>); </claim-text>
</claim-text>
<claim-text>(iv) setting the camera angle of the rendering to a point of view to be rendered for the frame to write into the space of a texture map; </claim-text>
<claim-text>(v) computing first and second texture effects on each pixel in the frame buffer, respectively, from first and second sets of the M directions stored as texture maps, wherein each said largest angle &PHgr;(u,v,&thgr;<highlight><subscript>k</subscript></highlight>) is in one of a plurality of color channels of a texture map, wherein one of the M directions corresponds to each said color channel of the texture map, and wherein the first and second texture effects are defined, respectively by: 
<claim-text>a basis map B<highlight><subscript>1 </subscript></highlight>(s, t) of said M basis maps (B<highlight><subscript>k&equals;1 . . . M</subscript></highlight>(s, t)), and a horizon map, &PHgr;<highlight><subscript>1 </subscript></highlight>(u, v) of said M horizon maps; and </claim-text>
<claim-text>a basis map B<highlight><subscript>2 </subscript></highlight>(s, t) of said M basis maps (B<highlight><subscript>k&equals;1 M</subscript></highlight>(s, t)), and a horizon map, &PHgr;<highlight><subscript>2 </subscript></highlight>(u, v) of said M horizon maps; </claim-text>
</claim-text>
<claim-text>(vi) storing the first and second texture effects for each pixel in the frame buffer in a texture map &PHgr;(&thgr;<highlight><subscript>LIGHT</subscript></highlight>); </claim-text>
<claim-text>(vii) for a given camera perspective view: 
<claim-text>on a first operation, rendering a model of the three dimensional graphical object with an ambient low level lighting term only; </claim-text>
<claim-text>on a second operation: 
<claim-text>setting an alpha test and a stencil function to accept only those pixels in the frame buffer that have a non-zero alpha test result; </claim-text>
<claim-text>setting a color mask upon the frame buffer, wherein the color mask will not write to the color channels of the texture maps, whereby the ambient low level lighting term previously rendered is preserved; </claim-text>
<claim-text>drawing, using multi-texturing, for the angle (&PHgr;<highlight><subscript>L</subscript></highlight>) and the angle to the horizon (&thgr;<highlight><subscript>L</subscript></highlight>), the first and second texture effects on each pixel in the frame buffer, which are, respectively, cosine(&thgr;<highlight><subscript>L</subscript></highlight>) that is greater than &PHgr;<highlight><subscript>L</subscript></highlight>, and &PHgr;(&thgr;<highlight><subscript>LIGHT</subscript></highlight>); </claim-text>
</claim-text>
<claim-text>on a third operation: 
<claim-text>setting the alpha test off; </claim-text>
<claim-text>setting the color mask upon the frame buffer to allow writing to the color channels of the texture maps; </claim-text>
<claim-text>setting the stencil function to only draw pixels in the frame buffer that have a non-zero alpha test result; </claim-text>
<claim-text>setting a blending function to accumulate into the frame buffer with the ambient low level lighting term; </claim-text>
<claim-text>drawing the vector valued perturbed normal map N&prime;(u, v); and </claim-text>
<claim-text>displaying the three dimensional graphical object defined by pixels in the frame buffer, wherein the displayed object has an ambient only term in shadowed regions and normal bump mapping in non-shadowed regions. </claim-text>
</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00030">
<claim-text><highlight><bold>30</bold></highlight>. The method as defined in <dependent-claim-reference depends_on="CLM-00022">claim 29</dependent-claim-reference>, further comprising: 
<claim-text>interactively receiving instructions that change the definition of the light vector (L) with respect to each vertex (u, v); and </claim-text>
<claim-text>repeating (i) through (vii) using the changed definition of the light vector (L). </claim-text>
</claim-text>
</claim>
<claim id="CLM-00031">
<claim-text><highlight><bold>31</bold></highlight>. A system comprising: 
<claim-text>a memory to store: </claim-text>
<claim-text>a frame buffer including a plurality of pixels in a representation of a three-dimensional graphical object; </claim-text>
<claim-text>a bump map of a bump mapped surface on the three-dimensional graphical object; and </claim-text>
<claim-text>a plurality of texture maps, corresponding to a plurality of horizon maps of the bump mapped surface, for reuse in rendering the three-dimensional graphical object; </claim-text>
<claim-text>a display device; </claim-text>
<claim-text>a processor, coupled to the display device and the memory, to process each said pixel to produce on the display device a rendering of the bump mapped surface with shadows cast, as a function of the plurality of horizon maps, by light impinging upon bumps on the bump mapped surface. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00032">
<claim-text><highlight><bold>32</bold></highlight>. The system as defined in <dependent-claim-reference depends_on="CLM-00033">claim 31</dependent-claim-reference>, wherein: 
<claim-text>each said texture map has red, green, blue, and alpha color channels; and </claim-text>
<claim-text>each said color channel has encoded therein a representation of at least one radial direction of the corresponding horizon map for one point on the bump mapped surface. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00033">
<claim-text><highlight><bold>33</bold></highlight>. The system as defined in <dependent-claim-reference depends_on="CLM-00033">claim 31</dependent-claim-reference>, further comprising an input device, coupled to the processing unit, to communication an interactive instruction to the processor that changes the direction of light relative to the bump mapped surface. </claim-text>
</claim>
<claim id="CLM-00034">
<claim-text><highlight><bold>34</bold></highlight>. A processing system comprising: 
<claim-text>a database having a first set of data representing a bump map for the bumpmapped surface and second set of data corresponding to horizon map of the bump mapped surface, wherein the second set of data is stored in color channels of a texture map for reuse in rendering a three-dimensional graphical object; </claim-text>
<claim-text>a processor operatively connected to receive the first and second sets of data and including a logic element implemented as hardware that: 
<claim-text>interpolates light in a direction with respect to the horizon map; and </claim-text>
<claim-text>determines from the interpolated light direction pixels that are representative of a rendering of the bump mapped surface on the three-dimensional graphical object that are shadowed by light cast upon bumps on the bump mapped surface; </claim-text>
</claim-text>
<claim-text>an input device, coupled to the processor, for interactively inputting instructions to the processor that change the direction of light relative to the bump mapped surface. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00035">
<claim-text><highlight><bold>35</bold></highlight>. The processing system as defined in <dependent-claim-reference depends_on="CLM-00033">claim 34</dependent-claim-reference>, wherein the processor generates a display signal: 
<claim-text>incorporating for display those pixels that are lit by light in the direction with respect to the horizon map; and </claim-text>
<claim-text>does not incorporating for display those pixels that are in shadowed by light cast upon the bumps on the bump mapped surface. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00036">
<claim-text><highlight><bold>36</bold></highlight>. Computer executable media comprising: 
<claim-text>a bump map of a bump mapped surface on a three-dimensional graphical object; and </claim-text>
<claim-text>a plurality of texture maps including a plurality of horizon maps of the bump mapped surface. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00037">
<claim-text><highlight><bold>37</bold></highlight>. The computer executable media as defined in <dependent-claim-reference depends_on="CLM-00033">claim 36</dependent-claim-reference>, further comprising a first code segment that, when executed by a computer: 
<claim-text>defines light having a direction relative to the bump mapped surface; </claim-text>
<claim-text>interpolates, from the plurality of horizon maps relative to the direction of light, to determine those portions of the bump mapped surface that are lit by the defined light; and </claim-text>
<claim-text>renders, from a given point of view, the bump mapped surface upon a display device: 
<claim-text>those portions of the bump mapped surface that are lit by the defined light; and </claim-text>
<claim-text>shadows cast upon the bump mapped surface by the defined light interfering with bump s on the bump mapped surface. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00038">
<claim-text><highlight><bold>38</bold></highlight>. The computer executable media as defined in <dependent-claim-reference depends_on="CLM-00033">claim 37</dependent-claim-reference>, further comprising a second code segment that, when executed by a computer: 
<claim-text>interactively receives instructions from an input device that change the direction of light relative to the bump mapped surface; and </claim-text>
<claim-text>repeats, using the changed direction of light, the interpolates and the renders. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00039">
<claim-text><highlight><bold>39</bold></highlight>. A data structure stored on a computer-readable medium, the data structure comprising: 
<claim-text>a first collection of texture maps each defining, in a plurality of color channels, a bump map describing a bump mapped surface on a three-dimensional graphical object; and </claim-text>
<claim-text>a second collection of texture maps each defining, in a plurality of color channels, a horizon map for the bump mapped surface, wherein each said color channel corresponds to a radial direction about a point on the bump mapped surface. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00040">
<claim-text><highlight><bold>40</bold></highlight>. The data structure as defined in <dependent-claim-reference depends_on="CLM-00033">claim 39</dependent-claim-reference>, further comprising other texture maps defining in color channels thereof other textures of the bump mapped surface. </claim-text>
</claim>
<claim id="CLM-00041">
<claim-text><highlight><bold>41</bold></highlight>. A data structure stored on a computer-readable medium, the data structure comprising: 
<claim-text>a first set of data representing a plurality of polygons representative of a surface on a three dimensional graphical object; </claim-text>
<claim-text>a second set of data representing a bump map of the surface defining a bump mapped surface as a function of the vertices corresponding to the plurality of polygons; and </claim-text>
<claim-text>a third set of data representing, for each vertex of each polygon, a horizon map stored as a plurality of texture maps each corresponding to a plurality of radial directions of the horizon map, wherein: 
<claim-text>each of the texture maps has a plurality of colors channels; and </claim-text>
<claim-text>each of the color channels corresponds to the horizon angle of one of the radial directions of the horizon map relative to the tangent plane of the one of the vertices.</claim-text>
</claim-text>
</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>4</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030001859A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030001859A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030001859A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030001859A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030001859A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030001859A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030001859A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030001859A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030001859A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00009">
<image id="EMI-D00009" file="US20030001859A1-20030102-D00009.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00010">
<image id="EMI-D00010" file="US20030001859A1-20030102-D00010.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00011">
<image id="EMI-D00011" file="US20030001859A1-20030102-D00011.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00012">
<image id="EMI-D00012" file="US20030001859A1-20030102-D00012.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00013">
<image id="EMI-D00013" file="US20030001859A1-20030102-D00013.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00014">
<image id="EMI-D00014" file="US20030001859A1-20030102-D00014.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
