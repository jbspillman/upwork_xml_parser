<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030002492A1-20030102-D00000.TIF SYSTEM "US20030002492A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030002492A1-20030102-D00001.TIF SYSTEM "US20030002492A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030002492A1-20030102-D00002.TIF SYSTEM "US20030002492A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030002492A1-20030102-D00003.TIF SYSTEM "US20030002492A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030002492A1-20030102-D00004.TIF SYSTEM "US20030002492A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030002492A1-20030102-D00005.TIF SYSTEM "US20030002492A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030002492A1-20030102-D00006.TIF SYSTEM "US20030002492A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030002492A1-20030102-D00007.TIF SYSTEM "US20030002492A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030002492A1-20030102-D00008.TIF SYSTEM "US20030002492A1-20030102-D00008.TIF" NDATA TIF>
<!ENTITY US20030002492A1-20030102-D00009.TIF SYSTEM "US20030002492A1-20030102-D00009.TIF" NDATA TIF>
<!ENTITY US20030002492A1-20030102-D00010.TIF SYSTEM "US20030002492A1-20030102-D00010.TIF" NDATA TIF>
<!ENTITY US20030002492A1-20030102-D00011.TIF SYSTEM "US20030002492A1-20030102-D00011.TIF" NDATA TIF>
<!ENTITY US20030002492A1-20030102-D00012.TIF SYSTEM "US20030002492A1-20030102-D00012.TIF" NDATA TIF>
<!ENTITY US20030002492A1-20030102-D00013.TIF SYSTEM "US20030002492A1-20030102-D00013.TIF" NDATA TIF>
<!ENTITY US20030002492A1-20030102-D00014.TIF SYSTEM "US20030002492A1-20030102-D00014.TIF" NDATA TIF>
<!ENTITY US20030002492A1-20030102-D00015.TIF SYSTEM "US20030002492A1-20030102-D00015.TIF" NDATA TIF>
<!ENTITY US20030002492A1-20030102-D00016.TIF SYSTEM "US20030002492A1-20030102-D00016.TIF" NDATA TIF>
<!ENTITY US20030002492A1-20030102-D00017.TIF SYSTEM "US20030002492A1-20030102-D00017.TIF" NDATA TIF>
<!ENTITY US20030002492A1-20030102-D00018.TIF SYSTEM "US20030002492A1-20030102-D00018.TIF" NDATA TIF>
<!ENTITY US20030002492A1-20030102-D00019.TIF SYSTEM "US20030002492A1-20030102-D00019.TIF" NDATA TIF>
<!ENTITY US20030002492A1-20030102-D00020.TIF SYSTEM "US20030002492A1-20030102-D00020.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030002492</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09892972</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010627</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>H04L012/56</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>370</class>
<subclass>360000</subclass>
</uspc>
</classification-us-primary>
<classification-us-secondary>
<uspc>
<class>370</class>
<subclass>426000</subclass>
</uspc>
</classification-us-secondary>
</classification-us>
<title-of-invention>Method, apparatus and computer program for informing a requesting device of port configuration changes in a computer network switching device</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Robert</given-name>
<middle-name>J.</middle-name>
<family-name>Gallagher</family-name>
</name>
<residence>
<residence-us>
<city>Hurley</city>
<state>NY</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>William</given-name>
<middle-name>J.</middle-name>
<family-name>Rooney</family-name>
</name>
<residence>
<residence-us>
<city>Hopewell Junction</city>
<state>NY</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<assignee>
<organization-name>International Business Machines Corporation</organization-name>
<address>
<city>Armonk</city>
<state>NY</state>
</address>
<assignee-type>02</assignee-type>
</assignee>
<correspondence-address>
<name-1>Andrew J. Wojnicki, Jr. - Attorney</name-1>
<name-2>IBM Corporation - MS P386</name-2>
<address>
<address-1>2455 South Road</address-1>
<city>Poughkeepsie</city>
<state>NY</state>
<postalcode>12601</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A method, apparatus, and computer program device enabling a computer network switching device to inform an attached requesting device of switch ports affected by configuration changes during the period of time since the last query by the particular requesting device. The switch device is initialized with a change index and data vector, the latter indicative of an initial port configuration. The switch increments the index in response to subsequent port configuration change events, and stores in association with the incremented index a data vector indicating the ports changed during the corresponding event. The switch stores an array of associated index and vector values. The switch responds to a query from an attached requesting device by informing the requesting device of specific ports affected by one or more configuration changes since the index value held by the requesting device was the current index value in the switch. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">FIELD OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> The present invention relates in general to computer and communication network switch devices, and more particularly, to a method, computer program device, and apparatus for informing a requesting device of specific switch ports affected by one or more changes to the switch port configuration. </paragraph>
</section>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> A recent trend in computing system architecture is the Storage Area Network (SAN). SANs are described in an IBM&reg; publication titled &ldquo;Introduction to Storage Area Network, SAN,&rdquo; IBM Publication No. SG24-5470-00, August 1999, which is hereby incorporated herein by reference in its entirety. As noted in this publication, a SAN &ldquo;is a high-speed network, comparable to a LAN, that allows the establishment of direct connections between storage devices and processors . . . &rdquo; Two aspects of this definition deserve further discussion. First, a SAN is a network used in addition to a standard communication network, such as a local area network (LAN). Storage input/output (I/O) operations are conducted over the SAN, reducing data transfer traffic on the LAN. Second, the SAN allows direct connections between processors and storage devices, thereby eliminating the need for storage devices dedicated to specific processors. In addition, since these direct connections may alternatively be accomplished by an I/O subsystem (such as a channel subsystem, as known in S/390&reg; architecture), the central processors are further relieved of the burdens associated with data transfer. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> A SAN requires a network infrastructure to implement the direct processor to storage connections discussed above. One type of device capable of providing such a SAN infrastructure is a known as a switch. A switch is a device capable of providing on demand, anything-to-anything connections between attached devices. A switch typically provides a number of ports to which external devices may attach. The switch provides the ability to dynamically connect any port to any other port, thereby enabling any attached device to communicate with any other attached device. Switches may be used to accomplish direct connections between devices, or switches may be combined in cascaded or chained topologies in order to increase the total number of ports within the network, or to increase the allowable physical distance between connected devices. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> In SAN switches known in the art, a configuration is associated with each port at any point in time. The configuration of a particular port is comprised of information describing the specific device attached to the port, as well as one or more connectivity attributes assigned to the port. Connectivity attributes determine the extent to which a particular port is available to form dynamic connections with other ports. For example, a port may be available to dynamically connect with any other port. Or, a particular port may be unavailable to make a dynamic connection with another port, for a variety of reasons: the port may have a dedicated (static) connection to another port, or the port may be unavailable to connect with a particular port or ports, or the port may be unavailable to connect with any other port. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> The configuration of a switch port can be changed in a number of ways. The switch may include a processor or other controller, which may be attached to an operator console. An operator may be able to change the port configuration via this attached operator console. Also, it may be possible for one or more processors attached to one or more switch ports to change the port configuration. Since multiple processors, concurrently running multiple applications, can be attached to a particular switch, multiple host applications capable of modifying the port configuration of a single switch can be operating concurrently. Further, the port configuration could be modified via changes to the physical device connected to a port, or changes in the connection between the port and the physical device (such as a link failure or cable disconnect). Finally, in an environment using cascaded or chained switches, port configuration changes in one switch could be initiated by another connected switch. As should be apparent to one of ordinary skill in the art, in an environment where so many factors can result in port configuration changes on any particular switch, there exists a need for the switch to inform connected devices of the current port configuration. As used herein, the term &ldquo;requesting device&rdquo; refers to any device which is capable of inquiring as to the port configuration of a switch connected to the requesting device. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> In switch systems known in the art, a switch provides a connected requesting device with the current switch port configuration by exchanging two sets of information: port configuration details, and a time stamp or index value. The requesting device stores the index value in association with the port configuration details for future reference. The switch tracks subsequent port configuration changes, such as by incrementing an index value or otherwise storing information indicative of the most recent configuration change. When a requesting device attempts to initiate a port configuration change or take other actions dependent upon port configuration, the requesting device first queries the switch to determine whether or not the requesting device has stored the switch&apos;s current configuration. To accomplish this, the requesting device provides to the switch the time stamp or index value associated with the most recent port configuration details known to or stored in the requesting device. If this value (time stamp or index) matches the current value stored in the switch, the requesting device has the most recent port configuration information, and is therefore able to institute a port configuration change or take other actions dependent upon port configuration. If, however, the values do not match, then at least one port configuration change has taken place since the requesting device last updated its port configuration data. The requesting device should now establish the current port configuration before attempting to modify the current port configuration, or prior to taking any other action dependent upon port configuration. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> In switch systems known in the art, the switch merely informs the requesting device as to whether or not the requesting device has the current port configuration information. Such a scheme, implemented by exchanging a value referred to as a &ldquo;key,&rdquo; is described in U.S. Pat. No. 5,297,262, titled &ldquo;Methods and Apparatus for Dynamically Managing Input/Output (I/O) Connectivity,&rdquo; issued March 22, which is assigned to the same assignee as the present application, and which is hereby incorporated herein by reference in its entirety. If the requesting device does not have the current port configuration, the requesting device completely refreshes its port configuration information for all ports within the switch, since the requesting device has no information indicating which port attributes have changed. The requesting device processor is therefore involved in completely refreshing its port configuration data, even if the configuration attributes of only one port are modified. Causing the requesting processor (or processors) to refresh port configuration information that is both current and valid tends to be wasteful of valuable processor resources. In particular, in circumstances where frequent changes are made to the attributes of individual ports in a switch containing many ports, causing several connected processors to refresh configuration information for unmodified ports becomes time consuming and very inefficient. In addition to the inefficient use of host processor resources, switch processor resources are also used inefficiently in such a system, since the switch processor is involved in the data refresh process for each attached requesting device. Where many attached devices request frequent port configuration updates, switch processor resources may become a system bottleneck. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> For the foregoing reasons, therefore, there is a need in the art for a method, device, and computer program product enabling a switch to provide to a requesting device sufficient information for the requesting device to determine the specific ports for which the requesting device should update its local port configuration data. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY </heading>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> The present invention is directed to a method, apparatus, and computer program device enabling a switch to provide to a requesting device sufficient information for the requesting device to determine the specific ports for which the requesting device should update its local port configuration data. In particular, the present invention improves processing efficiency by informing a requesting device of specific ports which have been affected by configuration changes since the last update available to the requesting device. In this manner, the requesting device is able to refresh its detailed port configuration information for the specific ports changed, eliminating the need to refresh configuration information that is already known to the requesting device. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> In preferred embodiments of the present invention, the switch increments a time stamp indicator, such as an index or key value, each time one or more modifications are made to the switch port configuration attributes. A configuration change event (or simply a change event) is defined as a specific instance whereby the configuration attributes of one or more switch ports are modified. The index value provides a representation of the change events: each change event is represented by a single index value. Each index value, therefore, represents a particular change event, during which the configuration of one or more ports is modified. When each change event occurs, the switch builds a data structure, such as a change data vector, indicating the specific switch ports affected by the configuration change event. The change data vector (also referred to herein as &ldquo;data vector&rdquo;) is stored in association with the key or index value corresponding to the specific configuration change event, such as in a table or array. Each associated pair of index value and data vector forms a table record, representing a specific change event and the one or more ports affected by the specific change event. The key or index value provides an index to the table: the switch is capable of searching the table to locate a particular index value. Index values may be recycled over time, however at any point in time all index values stored within the table are unique, and each such stored index value corresponds to a single specific change event. Corresponding to a specific key or index value stored in the table, and therefore corresponding to the specific configuration change event represented by the specific key or index value, the associated data vector provides an indication of the ports altered by the specific change event represented by the index value. When a requesting device queries the switch, the current index value stored in the switch is compared to the most recent index value known to the requesting device. If the values do not match, the switch may be able to inform the requesting device of the specific ports that have been modified, by utilizing the stored table of associated index values and change data vectors. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> In preferred embodiments of the present invention, the change data vector comprises a series of bits, where each bit represents a switch port. Each data vector is stored in a table, along with an index value. Each pair of values (index and data vector) forms a table record, where each table record corresponds to a particular port configuration change event. Within a particular data vector, the value of each bit indicates whether the port represented by that bit was affected by the configuration change event represented by the particular data vector. By creating and storing a series of such table records (index and data vector), one record for each change event, the switch builds a table summarizing the history of configuration change events and the specific ports affected thereby. This history summary table provides the basic information which the switch uses to inform a requesting device of the ports affected by one or more configuration change events. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> In preferred embodiments of the present invention, when the switch determines that the most recent index known to the requesting device is different than the current index value stored in the switch (thereby indicating that one or more ports have changed), the switch builds and returns to the requesting device a history summary vector. The history summary vector is similar in structure to the change data vector: each comprises a series of bits, where each bit represents a switch port. The summary vector differs from the change data vectors in one important aspect: the summary vector represents ports affected by a series of change events, where each data vector represents ports affected by one specific change event. In this regard, the history summary vector represents a summary of the ports whose configurations changed during the time since the requesting device last updated its port configuration information. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> In preferred embodiments of the present invention, when the requesting device queries the switch, the requesting device passes to the switch the most recent index value known to the requesting device. Also in preferred embodiments, the switch stores this index value for use in subsequent processing. In particular, if the index value that the requesting device passes to the switch is not equal to the current index value stored in the switch, the switch begins building the summary vector using the stored index value from the requesting device, incremented by one. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> In practical implementations of the present invention, the history summary table is capable of storing a finite number of records, representing a finite number of configuration change events. In preferred embodiments of the present invention, the history summary table retains the records corresponding to the most recent change events, discarding the records corresponding to the least recent change events as needed to store more recent records. Under these circumstances, there is a possibility that the most recent index value known to a requesting device is no longer stored within the history summary table. In preferred embodiments of the present invention, the switch handles this situation by informing the requesting device that the configuration of all implemented ports may have changed. As used herein, the set of implemented ports for any specific model or type of switch is the complete set of ports supportable by the particular model of switch, regardless of whether or not all of the supportable (implemented) ports are in use or even physically installed. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> In preferred embodiments of the present invention, the switch is an ESCON&reg; director, and the requesting device is a host processor. In alternative embodiments, the switch may be a FICON&trade; director, or any other switch in a switched I/O network, such as a SAN environment. Also, in alternative embodiments a cascaded or chained switch topology is employed, wherein the requesting device may be a switch. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> It is therefore an object of the present invention to enable an improvement in the efficiency with which a device updates its port configuration tables corresponding to an attached switch. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> It is a further object of the present invention to provide, within a switch, a data structure indicating the specific port or ports affected by a single port configuration change event. It is a further object of the present invention to provide, within the same switch, a series of such data structures representing a series of the most recent port configuration change events. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> It is a further object of the present invention to provide a series of communication protocols through which a requesting device can query a switch as to the current port configuration, and further through which the switch can inform the requesting device of all ports for which the requesting device should update its stored port configuration data. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> The recitation herein of a list of desirable objects which are met by various embodiments of the present invention is not meant to imply or suggest that any or all of these objects are present as essential features, either individually or collectively, in the most general embodiment of the present invention or in any of its more specific embodiments. </paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> The subject matter which is regarded as the invention is particularly pointed out and distinctly claimed in the concluding portion of the specification. The invention, however, both as to organization and method of practice, together with further objects and advantages thereof, may best be understood by reference to the following description taken in connection with the accompanying drawings in which: </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1A</cross-reference> illustrates a computing environment in which preferred embodiments are implemented; </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1B</cross-reference> illustrates a switch according to preferred embodiments of the present invention; </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1C</cross-reference> illustrates various aspects of alternative embodiments of the present invention; </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2A</cross-reference> illustrates fields of data included in a Test Key channel command word (CCW) of preferred embodiments of the present invention; </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2B</cross-reference> illustrates fields of data included in a Read History Summary CCW of preferred embodiments of the present invention; </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2C</cross-reference> illustrates fields of data included in a No Operation CCW of preferred embodiments of the present invention; </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2D</cross-reference> illustrates command chaining of preferred embodiments of the present invention; </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3A</cross-reference> illustrates fields of data stored in a switch of preferred embodiments of the present invention; </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3B</cross-reference> provides an overview of the processing performed within a switch, according to preferred embodiments of the present invention; </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3C</cross-reference> provides an overview of the processing performed within a requesting device, in accordance with preferred embodiments of the present invention; </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> illustrates logic used to initialize a requesting device in accordance with preferred embodiments of the present invention; </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5A</cross-reference> illustrates logic used by a requesting device to update internal switch tables in accordance with preferred embodiments of the present invention; </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5B</cross-reference> illustrates logic used by a requesting device to update switch records in accordance with preferred embodiments of the present invention; </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> illustrates logic used to initialize a switch in accordance with preferred embodiments of the present invention; </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> illustrates logic used by a switch in response to port configuration changes, in accordance with preferred embodiments of the present invention; </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> illustrates logic used by the switch to increment the key counter, in accordance with preferred embodiments of the present invention; </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference> illustrates logic used to process the Test Key CCW in accordance with preferred embodiments of the present invention; </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10</cross-reference> illustrates logic used to process the Read History Summary CCW in accordance with preferred embodiments of the present invention; </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 11</cross-reference> illustrates the port configuration data structures and fields stored within a requesting device, according to preferred embodiments of the present invention; </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 12</cross-reference> illustrates the Node Descriptor data structure of preferred embodiments of the present invention; </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 13</cross-reference> illustrates the Test Key and Increment CCW processing, according to preferred embodiments of the present invention; </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 14</cross-reference> illustrates the Port State Change processing, according to preferred embodiments of the present invention.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF THE INVENTION </heading>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> In accordance with preferred embodiments of the present invention, a network switch informs an attached requesting device of the specific switch ports affected by one or more configuration changes occurring since the most recent port configuration known to the requesting device. </paragraph>
<paragraph id="P-0044" lvl="7"><number>&lsqb;0044&rsqb;</number> Environment </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> One embodiment of a computing environment incorporating and using aspects of the present invention is described with reference to <cross-reference target="DRAWINGS">FIG. 1A</cross-reference>. The computing environment contains a processor <highlight><bold>100</bold></highlight>, which may include multiple central processing units <highlight><bold>106</bold></highlight> (CPUs). Processor <highlight><bold>100</bold></highlight> preferably includes a channel subsystem <highlight><bold>102</bold></highlight> to handle input/output (I/O) operations between processor memory <highlight><bold>104</bold></highlight> and external I/O devices <highlight><bold>152</bold></highlight>. While a preferred computing environment employs a channel subsystem <highlight><bold>102</bold></highlight>, the present invention is independent of whether or not processor <highlight><bold>100</bold></highlight> does or does not use a channel subsystem <highlight><bold>102</bold></highlight>. Channel subsystem <highlight><bold>102</bold></highlight> includes a plurality of channels <highlight><bold>105</bold></highlight>, each channel capable of forming a connection with an external device <highlight><bold>152</bold></highlight>. In the preferred embodiment of <cross-reference target="DRAWINGS">FIG. 1</cross-reference>A, each channel <highlight><bold>105</bold></highlight> is connected via a cable <highlight><bold>155</bold></highlight> to one of a plurality of ports <highlight><bold>110</bold></highlight> within switch <highlight><bold>135</bold></highlight>. In preferred embodiments of the present invention, switch <highlight><bold>135</bold></highlight> is an IBM ESCON director or a FICON director, however in alternative embodiments switch <highlight><bold>135</bold></highlight> can be any storage network switching device. Also connected to switch ports <highlight><bold>110</bold></highlight> via cables <highlight><bold>160</bold></highlight>, are a plurality of I/O device control units <highlight><bold>150</bold></highlight>. Each control unit (CU) <highlight><bold>150</bold></highlight> includes one or more host adapters <highlight><bold>165</bold></highlight>, to which a cable <highlight><bold>160</bold></highlight> is connected. Switch <highlight><bold>135</bold></highlight> further includes a switch matrix <highlight><bold>142</bold></highlight> (illustrated in <cross-reference target="DRAWINGS">FIG. 1B</cross-reference>), capable of forming connections <highlight><bold>144</bold></highlight> between switch ports. Connections <highlight><bold>144</bold></highlight> are shown for illustrative purposes only, switch matrix <highlight><bold>142</bold></highlight> is not limited in any way to forming only the connections <highlight><bold>144</bold></highlight> shown in <cross-reference target="DRAWINGS">FIG. 1A</cross-reference>. In fact, in preferred embodiments of the present invention switch matrix <highlight><bold>144</bold></highlight> is capable of dynamically connecting any device port <highlight><bold>110</bold></highlight> to any other device port <highlight><bold>110</bold></highlight>, thereby providing dynamic anything-to-anything connections between processor <highlight><bold>100</bold></highlight> and CU&apos;s <highlight><bold>150</bold></highlight>. Each CU <highlight><bold>150</bold></highlight> controls one or more I/O devices, such as direct access storage devices (DASD) <highlight><bold>152</bold></highlight>. In preferred embodiments, switch <highlight><bold>135</bold></highlight> also contains a Switch Control Unit <highlight><bold>130</bold></highlight> which communicates with switch matrix <highlight><bold>142</bold></highlight> via a special port <highlight><bold>125</bold></highlight>. In preferred embodiments switch <highlight><bold>135</bold></highlight> is an IBM ESCON director or a FICON director, and port <highlight><bold>125</bold></highlight> is known as the Switch Control Unit Port (CUP). The FICON interface is described in IBM publications titled &ldquo;Fiber Channel Connection (FICON) I/O Interface, Physical Layer,&rdquo; IBM Publication No. SA24-7172-02, October 2000, and &ldquo;Introduction to IBM S/390 FICON,&rdquo; IBM Publication No. SG24-5176-00, October 1999, both of which are hereby incorporated herein by reference in their entirety. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> In a preferred embodiment of the present invention, switch <highlight><bold>135</bold></highlight> is an IBM ESCON director (ESCD), a first-generation SAN. The ESCD device is described in IBM publications titled &ldquo;IBM ESCON Director 9032-5 Presentation,&rdquo; IBM Publication No. SG24-2005-00, September 1999, and &ldquo;Planning for the 9032 Model 5 Director with FICON Converter Feature,&rdquo; IBM Publication No. SA22-7415-01, August 1999, both of which are hereby incorporated herein by reference in their entirety. As noted therein, the IBM ESCON director (ESCD) switch provides up to 248 external ports, with the ability to connect any port to any other port, up to a maximum of 124 simultaneous active connections. The ESCD switch keeps track of the devices connected to each port, as well as a set of connection attributes defining which ports can or cannot be connected to other ports. The specific connection attributes of any particular switch <highlight><bold>135</bold></highlight> may vary both in number and definition, in keeping with the spirit and scope of the present invention. For example, the ESCD switch allows one of several connection attributes to be assigned to each port, such as: a port may be blocked (unable to connect with any other port), a port may have a dedicated connection to another port (and therefore unable to form a dynamic connection with a different port), a port may be prohibited from connecting to another specific port, or a port may be allowed to connect with any available port. The ESCD switch manages dynamic connections between ports, within the constraints defined by the current set of port connection attributes. The set of information encompassing a) the devices connected to each port, and b) the connection attributes of each port, is referred to as the port configuration. In general, connection attributes may encompass similar or different properties, and are in no way limited to the specific connection attributes described herein in reference to a preferred embodiment. The teachings of the present invention apply without regard to either the specific connection attributes employed, or the number of such connection attributes. As used herein, the terms &ldquo;port configuration&rdquo; and &ldquo;port status&rdquo; are synonymous, and may be used interchangeably. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> The port configuration of a switch such as the ESCD can be changed in a number of ways. The ESCD includes a control unit (CU) <highlight><bold>130</bold></highlight>, frequently attached to an operator console. The port configuration can be modified by an operator via the console attached to the ESCD CU. Also, applications running on device processors attached to one or more switch ports can initiate changes to the port configuration. Since multiple processors, concurrently running multiple applications, can be attached to a particular switch, multiple host applications capable of modifying the port configuration of a single switch can be operating concurrently. Further, the port configuration could be modified via changes to the physical device connected to a port, or changes in the connection between the port and the physical device (such as a link failure or cable disconnect). Finally, in an environment using cascaded or chained switches, port configuration changes in one switch could be initiated by another connected switch. As should be apparent to one of ordinary skill in the art, in an environment where many factors can result in port configuration changes on any particular switch, there exists a need for the switch to inform connecting devices of the current port configuration. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1B</cross-reference> provides additional details of switch <highlight><bold>135</bold></highlight>. In particular, <cross-reference target="DRAWINGS">FIG. 1B</cross-reference> illustrates switch memory <highlight><bold>140</bold></highlight> and switch nonvolatile memory, such as hard disk drive (HDD) <highlight><bold>145</bold></highlight>, used to store information relating to the present configuration of ports <highlight><bold>110</bold></highlight>. In general, such storage devices may be part of switch CU <highlight><bold>130</bold></highlight>, or part of an operator console (not illustrated) attached to CU <highlight><bold>130</bold></highlight>, or both. In general, only one form of storage is required, however preferred embodiments include two forms of storage as shown: a fast local memory <highlight><bold>140</bold></highlight>, most likely volatile, and a lower performance but nonvolatile storage device <highlight><bold>145</bold></highlight>, typically a HDD. In a preferred embodiment where switch <highlight><bold>135</bold></highlight> is an IBM ESCON director, nonvolatile storage <highlight><bold>145</bold></highlight> is the HDD of an attached operator console (not illustrated). </paragraph>
<paragraph id="P-0049" lvl="7"><number>&lsqb;0049&rsqb;</number> Switch Data Fields </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3A</cross-reference> illustrates the data fields of a preferred embodiment of the present invention which are stored in one or more storage devices such as memory <highlight><bold>140</bold></highlight> or HDD <highlight><bold>145</bold></highlight>, within or accessible to switch <highlight><bold>135</bold></highlight>. These data fields include the change index value <highlight><bold>300</bold></highlight>, the Maximum number of History Buffer entries <highlight><bold>305</bold></highlight>, the Current History Buffer Entry Index <highlight><bold>310</bold></highlight>, the History Buffer <highlight><bold>315</bold></highlight>, which contains a plurality of History Buffer Entries <highlight><bold>317</bold></highlight>, each History Buffer Entry containing an Index entry <highlight><bold>320</bold></highlight> and a change vector <highlight><bold>325</bold></highlight>, and finally a History Base Register <highlight><bold>330</bold></highlight>. As used herein, the term &ldquo;change index value&rdquo; is a generic term for the time stamp indicator that the switch uses to identify specific configuration change events. In preferred embodiments of the present invention utilizing an IBM ESCON director or a FICON director as switch <highlight><bold>135</bold></highlight>, change index value <highlight><bold>300</bold></highlight> is referred to as the Key Counter. As used herein with reference to preferred embodiments, therefore, the generic term &ldquo;change index value&rdquo; and the more specific term &ldquo;key counter&rdquo; are synonymous, and may be used interchangeably. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> The Key Counter <highlight><bold>300</bold></highlight> is a 4 byte (32 bit) field maintained in switch <highlight><bold>135</bold></highlight>. Key Counter <highlight><bold>300</bold></highlight> provides a mechanism through which an attached device, such as an application running on processor <highlight><bold>100</bold></highlight>, can determine whether ESCON director port configuration parameters (information contained in a port information block (PIB), a port address name, the Host Data-Buffer or the Mode Register) have been modified. These parameters are documented in the &ldquo;Programming the Interface for Enterprise Systems Connection Directors with FICON Converter Feature&rdquo;, SA23-0356-06, September 1999, which is hereby incorporated herein by reference in its entirety. Switch <highlight><bold>135</bold></highlight> increments Key Counter <highlight><bold>300</bold></highlight> each time one or more port configuration parameters are changed: by comparing the last Key Counter value known to processor <highlight><bold>100</bold></highlight> with the current value stored in switch <highlight><bold>135</bold></highlight>, switch <highlight><bold>135</bold></highlight> is able to determine whether or not the port configuration parameters of switch <highlight><bold>135</bold></highlight> have changed since the time when the Key Counter value known to processor <highlight><bold>100</bold></highlight> was the current value within switch <highlight><bold>135</bold></highlight>. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> The Maximum Number of History Buffer Entries <highlight><bold>305</bold></highlight> is a <highlight><bold>4</bold></highlight> byte field maintained in the switch. The Maximum Number of History Buffer Entries indicates the maximum number of History Buffer Entries <highlight><bold>317</bold></highlight> that can be stored within the Director History Buffer <highlight><bold>315</bold></highlight>. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> The Current History Buffer Entry Index <highlight><bold>310</bold></highlight> contains the index of the current History Buffer Entry <highlight><bold>317</bold></highlight>. Index <highlight><bold>310</bold></highlight> is used by switch <highlight><bold>135</bold></highlight> to point to the most recent History Buffer Entry <highlight><bold>317</bold></highlight> within Director History Buffer <highlight><bold>315</bold></highlight>. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> The Director History Buffer <highlight><bold>315</bold></highlight> contains an array of History Buffer Entries <highlight><bold>317</bold></highlight>. The number of entries is equal to the value of the Maximum Number of History Buffer Entries <highlight><bold>305</bold></highlight> field. Each History Buffer Entry <highlight><bold>317</bold></highlight> contains two fields, and Index Entry <highlight><bold>320</bold></highlight> and a Change Vector <highlight><bold>325</bold></highlight>. The Index Entry <highlight><bold>320</bold></highlight> is a four byte field which contains the value of the Key Counter <highlight><bold>300</bold></highlight> that was current when the port configuration changes indicated by the corresponding Change Vector <highlight><bold>325</bold></highlight> were made. The Change Vector <highlight><bold>325</bold></highlight> is a 256 bit field which indicates which ports were modified when the Key Counter <highlight><bold>300</bold></highlight> was set to the value in the corresponding Index Entry <highlight><bold>320</bold></highlight>. In this manner, each History Buffer Entry <highlight><bold>317</bold></highlight> contains a pair of associated data values, indicative of when a port configuration change event occurred (Index Entry <highlight><bold>320</bold></highlight>) and the ports affected by that change event (Change Vector <highlight><bold>325</bold></highlight>). Each bit of the Change Vector <highlight><bold>325</bold></highlight> corresponds to one port within switch <highlight><bold>135</bold></highlight>, and each port corresponds to one and only one bit within Change Vector <highlight><bold>325</bold></highlight>. In particular, in preferred embodiments of the present invention, the leftmost bit (bit <highlight><bold>0</bold></highlight>) represents port <highlight><bold>0</bold></highlight>, and the rightmost bit (bit <highlight><bold>255</bold></highlight>) represents port <highlight><bold>255</bold></highlight>. If a bit in the Change Vector is set to 1, then a change was made to the corresponding port when the Key Counter <highlight><bold>300</bold></highlight> was set to the value in the Index Entry <highlight><bold>320</bold></highlight> corresponding to the particular Change Vector. If a bit in the Change Vector is set to 0, then no change was made to the corresponding port when the Key Counter <highlight><bold>300</bold></highlight> was set to the value in the Index Entry <highlight><bold>320</bold></highlight> corresponding to the particular Change Vector <highlight><bold>325</bold></highlight>. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> The History Base Register <highlight><bold>330</bold></highlight> is a 4 byte field in the switch. This field is used to pass the key counter value specified by the Test Key command to the Read History Summary command. As described below, in preferred embodiments of the present invention the History Base Register stores the value of the Key Counter passed to the switch from the requesting device as part of the Test Key command, for subsequent use by the switch in responding to a Read History Summary command. The Test Key and Read History Summary commands of preferred embodiments are described in detail below. </paragraph>
<paragraph id="P-0056" lvl="7"><number>&lsqb;0056&rsqb;</number> Processing Overview </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIGS. 3B and 3C</cross-reference>, the overall method according to preferred embodiments of the present invention will now be described. In particular, <cross-reference target="DRAWINGS">FIG. 3B</cross-reference> illustrates the overall method performed within switch <highlight><bold>135</bold></highlight>. <cross-reference target="DRAWINGS">FIG. 3C</cross-reference> illustrates the overall method performed within an attached requesting device, such as processor <highlight><bold>100</bold></highlight>. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 3</cross-reference>B, an overview of switch processing is illustrated, starting at step <highlight><bold>350</bold></highlight>. As seen in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>B, switch <highlight><bold>135</bold></highlight> is first initialized, step <highlight><bold>352</bold></highlight>. Switch initialization is described in detail below, with reference to <cross-reference target="DRAWINGS">FIG. 6</cross-reference>. Once initialized, switch <highlight><bold>135</bold></highlight> waits for events which modify port configuration attributes, or to process commands issued by an attached requesting device such as processor <highlight><bold>100</bold></highlight> or the CU <highlight><bold>130</bold></highlight>, at step <highlight><bold>354</bold></highlight>. In preferred embodiments, switch <highlight><bold>135</bold></highlight> implements step <highlight><bold>354</bold></highlight> as an interrupt driven process, responding to commands from attached devices or the switch CU <highlight><bold>130</bold></highlight>. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> When, at step <highlight><bold>354</bold></highlight>, switch <highlight><bold>135</bold></highlight> detects an event which modifies one or more port configuration attributes, switch <highlight><bold>135</bold></highlight> increments Key Counter <highlight><bold>300</bold></highlight>, step <highlight><bold>355</bold></highlight>, then modifies the port configuration attributes and stores a data structure indicative of the changes made, step <highlight><bold>356</bold></highlight>. The details of step <highlight><bold>355</bold></highlight> will be described below, with reference to <cross-reference target="DRAWINGS">FIG. 8</cross-reference>. The details of step <highlight><bold>356</bold></highlight> will be described below, with reference to <cross-reference target="DRAWINGS">FIG. 7</cross-reference>. At the completion of step <highlight><bold>356</bold></highlight>, processing returns to step <highlight><bold>354</bold></highlight>. </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> When, at step <highlight><bold>354</bold></highlight>, switch <highlight><bold>135</bold></highlight> receives a command from an attached device such as processor <highlight><bold>100</bold></highlight> or the CU <highlight><bold>130</bold></highlight>, processing continues at step <highlight><bold>358</bold></highlight>. In preferred embodiments of the present invention, switch <highlight><bold>135</bold></highlight> is capable of responding to a variety of commands from attached devices. A few of the possible command options are illustrated in <cross-reference target="DRAWINGS">FIG. 3B</cross-reference>. For example, switch <highlight><bold>135</bold></highlight> might receive a command requesting switch <highlight><bold>135</bold></highlight> to compare Key Counter <highlight><bold>300</bold></highlight> to a value provided by the attached requesting device, such as processor <highlight><bold>100</bold></highlight>, and to increment Key Counter <highlight><bold>300</bold></highlight> if the values are equal, step <highlight><bold>362</bold></highlight>. Such a command is used by an attached requesting device to initiate port configuration changes in switch <highlight><bold>135</bold></highlight>, provided the attached requesting device holds the current Key Counter <highlight><bold>300</bold></highlight>. Details of switch processing for such a command, step <highlight><bold>362</bold></highlight>, are illustrated below, with reference to <cross-reference target="DRAWINGS">FIG. 13</cross-reference>. Also for example, switch <highlight><bold>135</bold></highlight> might receive a command requesting switch <highlight><bold>135</bold></highlight> to merely perform a comparison of Key Counter <highlight><bold>300</bold></highlight> and a value provided by the attached requesting device, step <highlight><bold>366</bold></highlight>. The details of switch processing for such a command, step <highlight><bold>366</bold></highlight>, are illustrated below, with reference to <cross-reference target="DRAWINGS">FIG. 9</cross-reference>. Further for example, switch <highlight><bold>135</bold></highlight> might receive one of several commands initiating changes to the configuration of one or more switch ports, step <highlight><bold>374</bold></highlight>. The details of switch processing for such a command, step <highlight><bold>374</bold></highlight>, are illustrated below with reference to <cross-reference target="DRAWINGS">FIG. 14</cross-reference>. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> Of particular interest in preferred embodiments of the present invention, step <highlight><bold>370</bold></highlight> illustrates the processing performed by switch <highlight><bold>135</bold></highlight> in response to a &ldquo;Read History Summary&rdquo; command which an attached requesting device, such as processor <highlight><bold>100</bold></highlight>, may issue. Such a command is issued by the attached requesting device when the requesting device determines that it does not hold the current value of Key Counter <highlight><bold>300</bold></highlight>. The requesting device may make such a determination by issuing a command such as Test Key, processed at step <highlight><bold>366</bold></highlight>. When the requesting device determines that it does not hold the current value of Key Counter <highlight><bold>300</bold></highlight>, the requesting device should update its port configuration data prior to initiating any further changes to the port configuration attributes or alternatively making decisions which may be based upon inaccurate (or obsolete) information. In preferred embodiments of the present invention, a command such as Read History Summary is provided to inform the requesting device of the specific ports affected by one or more configuration changes since the key value held by the requesting device was current. The details of switch processing for such a command, step <highlight><bold>370</bold></highlight>, are described in detail below with reference to <cross-reference target="DRAWINGS">FIG. 10</cross-reference>. </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> As illustrated in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>B, switch <highlight><bold>135</bold></highlight> may process one of several additional commands as known in the art which do not modify port state (for example &ldquo;Read PIB&rdquo;, &ldquo;Read Port Descriptors&rdquo; and &ldquo;Read Port Address Name&rdquo;), step <highlight><bold>376</bold></highlight>. Finally, at step <highlight><bold>378</bold></highlight> switch <highlight><bold>135</bold></highlight> issues an appropriate response to the requesting device, determined in part by the particular command. Processing within switch <highlight><bold>135</bold></highlight> then returns to step <highlight><bold>354</bold></highlight> to handle the next command or configuration change. </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 3</cross-reference>C, the overall processing within at attached requesting device will now be described, starting at step <highlight><bold>384</bold></highlight>, with particular emphasis on preferred embodiments wherein the requesting device is an attached host processor such as processor <highlight><bold>100</bold></highlight>. The attached host processor is first initialized, at step <highlight><bold>386</bold></highlight>, establishing the data structures to be used within processor <highlight><bold>100</bold></highlight> to store the port configuration state of one or more attached switches <highlight><bold>135</bold></highlight>. A more detailed discussion of step <highlight><bold>386</bold></highlight> is provided below, with reference to <cross-reference target="DRAWINGS">FIG. 4</cross-reference>. In preferred embodiments of the present invention, processor <highlight><bold>100</bold></highlight> periodically communicates with switch <highlight><bold>135</bold></highlight> to determine whether or not the port configuration information established during step <highlight><bold>386</bold></highlight> should be updated. A wait state, step <highlight><bold>388</bold></highlight>, is therefore used to establish the communication timing intervals. In preferred embodiments of the present invention, processor <highlight><bold>100</bold></highlight> queries switch <highlight><bold>135</bold></highlight> every two minutes, however this particular timing interval is not required. Alternative embodiments of the present invention are envisioned, wherein a longer or shorter wait interval is employed. At each wait interval, processor <highlight><bold>100</bold></highlight> invokes the Update Switch Table process, step <highlight><bold>390</bold></highlight>, which is described in detail below with reference to <cross-reference target="DRAWINGS">FIG. 5A</cross-reference>. Upon completion of step <highlight><bold>390</bold></highlight>, processing returns to step <highlight><bold>388</bold></highlight>, until the completion of the next wait interval. </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 6</cross-reference>, additional details of initialization step <highlight><bold>352</bold></highlight> will now be described. Switch <highlight><bold>135</bold></highlight>, an ESCON or FICON director in preferred embodiments, is given control to begin processing by powering on switch <highlight><bold>135</bold></highlight>, at step <highlight><bold>600</bold></highlight>. Traditional switch initialization occurs at <highlight><bold>605</bold></highlight>, which includes operations such as loading the switch microcode, initializing storage, initializing tables and state information for the switch, identifying the hardware resources available for use, processing customization information supplied by the installation. The foregoing list of operations is for illustrative purposes only, and is not an exhaustive list of initialization operations, nor are all of these initialization operations necessarily required in any particular embodiment of the present invention. During traditional switch initialization, the switch increments the Key Counter <highlight><bold>300</bold></highlight>, at step <highlight><bold>610</bold></highlight>. Although increment Key Counter, step <highlight><bold>610</bold></highlight>, is illustrated following step <highlight><bold>605</bold></highlight> for the purpose of clarity, step <highlight><bold>610</bold></highlight> may alternatively be performed prior to or concurrently with any or all of the specific initialization actions performed in step <highlight><bold>605</bold></highlight>. Traditional switch initialization continues by initializing the state of each port based on the IPL Configuration File <highlight><bold>615</bold></highlight>. The IPL Configuration File is described in an IBM publication titled &ldquo;IBM ESCON Director 9032-5 Presentation,&rdquo; IBM Publication No. SG24-2005-00, September 1999, which is hereby incorporated herein by reference in its entirety. As noted therein, the IPL Configuration File is a stored representation of a particular configuration of switch <highlight><bold>135</bold></highlight>. In preferred embodiments where switch <highlight><bold>135</bold></highlight> is an ESCD, the IPL Configuration File is stored in nonvolatile memory <highlight><bold>145</bold></highlight>, such as an HDD. The IPL Configuration File is used during initialization to reestablish the particular stored switch configuration as the initial switch configuration for the initialization steps. Changes to the switch port configuration, such as the addition of ports or changes to port numbers or addresses, are reflected in the initial configuration data, which is then stored in switch memory <highlight><bold>140</bold></highlight>. At step <highlight><bold>620</bold></highlight>, the switch purges the Director History Buffer <highlight><bold>315</bold></highlight> by setting the value of all History Buffer Entries <highlight><bold>317</bold></highlight> to binary zeroes. At step <highlight><bold>625</bold></highlight>, the switch sets the Maximum Number of History Buffer Entries <highlight><bold>305</bold></highlight> to the maximum supported by this model of switch, and sets the Current History Buffer Entry Index <highlight><bold>310</bold></highlight> to 1, indicating that History Buffer Entry <highlight><bold>317</bold></highlight> number one is the current entry. The switch then, at step <highlight><bold>630</bold></highlight>, initializes the Director History Buffer <highlight><bold>315</bold></highlight> by placing a single Change Vector <highlight><bold>325</bold></highlight> containing 1&apos;s in all positions associated with implemented external ports, and zeroes in all other positions in the Director History Buffer <highlight><bold>315</bold></highlight>, at the History Buffer Entry <highlight><bold>317</bold></highlight> associated with the Current History Buffer Entry Index <highlight><bold>310</bold></highlight>. At step <highlight><bold>635</bold></highlight>, the switch copies the value of the Key Counter <highlight><bold>300</bold></highlight>, which was incremented in step <highlight><bold>610</bold></highlight>, into the Index Entry <highlight><bold>320</bold></highlight> portion of the History Buffer Entry <highlight><bold>317</bold></highlight> associated with the Current History Buffer Entry Index <highlight><bold>310</bold></highlight>. At the completion of step <highlight><bold>635</bold></highlight>, switch <highlight><bold>135</bold></highlight> is configured according to the stored IPL configuration, the History Buffer <highlight><bold>315</bold></highlight> is reset to zeroes in all positions except for the first History Buffer (HB) Entry <highlight><bold>317</bold></highlight>, the History Buffer Index <highlight><bold>310</bold></highlight> is set to 1 and therefore points to the first HB Entry <highlight><bold>317</bold></highlight>, and the first HB Entry <highlight><bold>317</bold></highlight> contains the current value of Key Counter <highlight><bold>300</bold></highlight> (incremented during initialization) in Index Entry <highlight><bold>320</bold></highlight> and a change vector <highlight><bold>325</bold></highlight> indicating that all implemented ports may have changed. Now, traditional switch initialization continues at step <highlight><bold>640</bold></highlight>, and completes at step <highlight><bold>645</bold></highlight>. During step <highlight><bold>640</bold></highlight>, switch <highlight><bold>135</bold></highlight> stores information (i.e. Node Descriptors, described in detail below) describing the devices attached to each switch port. </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 8</cross-reference>, the processing that occurs when the Key Counter is incremented will now be described, beginning at step <highlight><bold>800</bold></highlight>. The Key Counter <highlight><bold>300</bold></highlight> is incremented whenever the switch port configuration is changed, whether the changes are initiated by an application running on attached processor <highlight><bold>100</bold></highlight>, the local switch Console user, or the ESCON or FICON director hardware. In the case of host programming, modification is usually the result of a &ldquo;Test Key and Increment&rdquo; command, with equal comparison, described below with reference to <cross-reference target="DRAWINGS">FIG. 13</cross-reference>. In step <highlight><bold>802</bold></highlight>, the Key Counter <highlight><bold>300</bold></highlight>, which is stored in the switch control unit memory <highlight><bold>140</bold></highlight>, is incremented by 1. If there is a carryout of bit <highlight><bold>0</bold></highlight> (the leftmost or most significant bit) of Key Counter <highlight><bold>300</bold></highlight> when the Key Counter is incremented, the Key Counter <highlight><bold>300</bold></highlight> wraps to a value of all zeroes. In step <highlight><bold>805</bold></highlight>, the switch <highlight><bold>135</bold></highlight> increments the Current History Buffer Index Entry <highlight><bold>310</bold></highlight>. As previously noted, in practical implementations of the present invention, the Director History Buffer <highlight><bold>315</bold></highlight> contains a finite maximum number of entries, represented by the Maximum Number of History Buffer Entries <highlight><bold>305</bold></highlight> in preferred embodiments of the present invention. In preferred embodiments of the present invention, switch <highlight><bold>135</bold></highlight> handles the condition where the maximum number of entries is exceeded by resetting Index <highlight><bold>310</bold></highlight> to 1. Steps <highlight><bold>810</bold></highlight> and <highlight><bold>815</bold></highlight> describe the steps by which this condition is handled. The incremented index <highlight><bold>310</bold></highlight> resulting from step <highlight><bold>805</bold></highlight> is compared, step <highlight><bold>810</bold></highlight>, to the Maximum Number of History Buffer Entries <highlight><bold>305</bold></highlight>. If the Index <highlight><bold>310</bold></highlight> is greater than the Maximum <highlight><bold>305</bold></highlight>, processing branches to step <highlight><bold>815</bold></highlight>, where the Current History Buffer Entry Index <highlight><bold>310</bold></highlight> is set to 1. Processing then continues at step <highlight><bold>820</bold></highlight>. If the incremented index <highlight><bold>310</bold></highlight> is not greater than the maximum <highlight><bold>305</bold></highlight>, processing continues at step <highlight><bold>820</bold></highlight>. In step <highlight><bold>820</bold></highlight>, the Change Vector <highlight><bold>325</bold></highlight> within the History Buffer Entry <highlight><bold>317</bold></highlight> corresponding to the Current History Buffer Entry Index <highlight><bold>310</bold></highlight>, is set to all binary zeroes. Next, at step <highlight><bold>825</bold></highlight>, the Index <highlight><bold>320</bold></highlight>, within the same History Buffer Entry <highlight><bold>317</bold></highlight> is set to the new (i.e. incremented) value of the Key Counter <highlight><bold>300</bold></highlight>. Processing then terminates for Key Counter Increment <highlight><bold>830</bold></highlight>. At this point, a new History Buffer Entry <highlight><bold>317</bold></highlight> is initialized. The initialized, or current, History Buffer (HB) Entry <highlight><bold>317</bold></highlight> contains an Index <highlight><bold>320</bold></highlight> equal to the new (incremented) Key Counter <highlight><bold>300</bold></highlight>, and a Change Vector <highlight><bold>325</bold></highlight> initialized with zeroes in all bit positions. This HB entry <highlight><bold>317</bold></highlight> is ready for use during the next port state change operation, steps <highlight><bold>700</bold></highlight> through <highlight><bold>720</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 7</cross-reference>, described below. </paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 7</cross-reference>, the processes invoked to handle changes in port configuration will now be described, per a preferred embodiment of the present invention. When configuration information changes for a port in switch <highlight><bold>135</bold></highlight>, switch processing begins at step <highlight><bold>700</bold></highlight>. Next, traditional processing occurs <highlight><bold>705</bold></highlight>, which may include updating the Port Information Blocks (PIBs), updating the Port Descriptors, or any other processing switch <highlight><bold>135</bold></highlight> performs to carry out the port configuration change. The switch then records the ports affected by the configuration change, by setting to a value of 1, in step <highlight><bold>710</bold></highlight>, the bit(s) in Change Vector <highlight><bold>325</bold></highlight> corresponding to the port(s) affected by the configuration change implemented in step <highlight><bold>705</bold></highlight>. Note that it is the current Change Vector <highlight><bold>325</bold></highlight> that is updated in step <highlight><bold>710</bold></highlight>; the current Change Vector <highlight><bold>325</bold></highlight> is contained within the HB Entry <highlight><bold>317</bold></highlight> to which the Current History Buffer Index <highlight><bold>310</bold></highlight> points. Traditional port state change processing then continues, step <highlight><bold>715</bold></highlight>, and subsequently terminates <highlight><bold>720</bold></highlight>. At the completion of the steps illustrated in <cross-reference target="DRAWINGS">FIGS. 8 and 7</cross-reference>, the configuration of one or more ports is changed. In response to this change a new HB Entry <highlight><bold>317</bold></highlight> is completed. The new HB Entry <highlight><bold>317</bold></highlight> contains a History Buffer Index equal to the Key Counter value after Key Counter Increment, step <highlight><bold>802</bold></highlight>, and a Change Vector <highlight><bold>325</bold></highlight> indicating the ports affected by the configuration change. </paragraph>
<paragraph id="P-0067" lvl="7"><number>&lsqb;0067&rsqb;</number> Data Fields and Processing within Requesting Device </paragraph>
<paragraph id="P-0068" lvl="0"><number>&lsqb;0068&rsqb;</number> Having described the data fields and data update processes within switch <highlight><bold>135</bold></highlight>, further details of a preferred embodiment will now be provided to illustrate the data fields and processes within an attached requesting device. In particular, a preferred embodiment wherein the requesting device is a device such as processor <highlight><bold>100</bold></highlight> will be described in detail. </paragraph>
<paragraph id="P-0069" lvl="0"><number>&lsqb;0069&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 11</cross-reference>, the data fields and tables within the requesting device (processor <highlight><bold>100</bold></highlight>, in a preferred embodiment) will be described. In particular, <cross-reference target="DRAWINGS">FIG. 11</cross-reference> illustrates the data fields in the Switch Table <highlight><bold>1100</bold></highlight>, Switch Record <highlight><bold>1120</bold></highlight> and Port Record <highlight><bold>1160</bold></highlight>. In preferred embodiments of the present invention where the requesting device is one or more processors <highlight><bold>100</bold></highlight>, this information is stored in memory <highlight><bold>104</bold></highlight>. Switch Table <highlight><bold>1100</bold></highlight> is composed of one or more Switch Records <highlight><bold>1120</bold></highlight>. Each Switch Record <highlight><bold>1120</bold></highlight> is in turn composed of one or more Port Records <highlight><bold>1160</bold></highlight>. The Switch Table <highlight><bold>1100</bold></highlight> represents all of the switches accessible by a particular operating system image operating within processor <highlight><bold>100</bold></highlight>. Each Switch Record <highlight><bold>1120</bold></highlight> represents a single switch that is accessible by this system, and the data within a particular Switch Record <highlight><bold>1120</bold></highlight> describes the switch represented by the particular Switch Record <highlight><bold>1120</bold></highlight>. The Switch Records may or may not occupy contiguous storage locations, and therefore the switch records <highlight><bold>1120</bold></highlight> comprising one particular Switch Table <highlight><bold>1100</bold></highlight> are chained together in a linked list. Each Switch Record <highlight><bold>1120</bold></highlight> has a Pointer <highlight><bold>1140</bold></highlight> to the next switch record in the Switch Table <highlight><bold>1100</bold></highlight>, with a null value for pointer <highlight><bold>1140</bold></highlight> indicating the end of the Switch Table <highlight><bold>1100</bold></highlight>. Each Switch Record contains the Node Descriptor <highlight><bold>1125</bold></highlight> of the switch, a copy of the Switch Key <highlight><bold>1130</bold></highlight> (synonymous with Key Counter, or change index value, as previously described) that was current when the Switch Record was created or last updated, the Device Number of the switch <highlight><bold>1135</bold></highlight>, a pointer <highlight><bold>1140</bold></highlight> to the next Switch Record and an array of Port Records <highlight><bold>1160</bold></highlight>, providing information on all implemented ports within switch <highlight><bold>135</bold></highlight>. The Device Number <highlight><bold>1135</bold></highlight> identifies the switch device to which the I/O will be initiated. The array of port records <highlight><bold>1160</bold></highlight> contains a series of individual port records <highlight><bold>1160</bold></highlight>, each record representing a specific port within switch <highlight><bold>135</bold></highlight>. The port records <highlight><bold>1160</bold></highlight> are indexed by logical port address, and one port record <highlight><bold>1160</bold></highlight> is provided for each implemented port within switch <highlight><bold>135</bold></highlight>. The Port Record <highlight><bold>1160</bold></highlight> provides information on the devices which are connected to the corresponding port. The Port Record <highlight><bold>1160</bold></highlight> contains a physical port number <highlight><bold>1165</bold></highlight>, the Node Descriptor <highlight><bold>1180</bold></highlight> of the device attached to that port (described in detail below, with reference to <cross-reference target="DRAWINGS">FIG. 12</cross-reference>), the Path Count <highlight><bold>1175</bold></highlight>, which contains the total number of channels connected to this destination port; the Port Descriptor <highlight><bold>1185</bold></highlight> which contains various state information, like blocked, off-line, dedicated and maintenance mode; the Prohibit Dynamic Connectivity Mask <highlight><bold>1190</bold></highlight> which consists of a 256-bit mask in which each bit position corresponds to a specific port address. Within Mask <highlight><bold>1190</bold></highlight>, a value of 0 in the bit position corresponding to a particular port indicates that communication with this particular port is allowed; a value of 1 indicates that communication with this particular port is not allowed. Applications running within processor <highlight><bold>100</bold></highlight>, such as Dynamic Channel Path Manager (DCM) may use this information to avoid attempting to add paths which have been prohibited, for example, as may be the case for certain interfaces of Peer to Peer Remote Copy (PPRC) devices. Dynamic channel path management is described in a United States patent application titled &ldquo;Method, System, and Program Products for Managing I/O Configurations of a Computing Environment&rdquo;, Ser. No. 09/407,544, having a filing date of Sep. 28, 1999, which is assigned to the same assignee as the present application, and which is hereby incorporated herein by reference in its entirety. The Path Count field, <highlight><bold>1175</bold></highlight>, is used for ports connected to control units <highlight><bold>150</bold></highlight>, to enable an application running on processor <highlight><bold>100</bold></highlight> (such as DCM) to identify unused ports. </paragraph>
<paragraph id="P-0070" lvl="0"><number>&lsqb;0070&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 12</cross-reference> illustrates additional details of the node descriptor (ND) data field of preferred embodiments of the present invention. As noted above, the ND field provides information describing the physical device attached to a particular port. The Node Descriptor contains the following fields: Flags (<highlight><bold>1305</bold></highlight>), Node Parameters (<highlight><bold>1310</bold></highlight>), Type Number (<highlight><bold>1315</bold></highlight>), Model Number (<highlight><bold>1320</bold></highlight>), Manufacturer (<highlight><bold>1325</bold></highlight>), Plant of Manufacture (<highlight><bold>1330</bold></highlight>), Sequence Number (<highlight><bold>1335</bold></highlight>), and Tag (<highlight><bold>1340</bold></highlight>). Details of each field are provided below: </paragraph>
<paragraph id="P-0071" lvl="1"><number>&lsqb;0071&rsqb;</number> 1. Flags (<highlight><bold>1305</bold></highlight>): Byte <highlight><bold>0</bold></highlight> contains flags which describe the manner in which selected fields of the node descriptor are to be interpreted. </paragraph>
<paragraph id="P-0072" lvl="1"><number>&lsqb;0072&rsqb;</number> 2. Node Parameters (<highlight><bold>1310</bold></highlight>): Bytes <highlight><bold>1</bold></highlight>-<highlight><bold>3</bold></highlight> contain additional information about the node. </paragraph>
<paragraph id="P-0073" lvl="1"><number>&lsqb;0073&rsqb;</number> 3. Type Number (<highlight><bold>1315</bold></highlight>): Word 1 and bytes <highlight><bold>0</bold></highlight>-<highlight><bold>1</bold></highlight> of word 2 contain the six-character (0-9) EBCDIC type number of the SDC. The type number is right justified with leading EBCDIC zeros if necessary. </paragraph>
<paragraph id="P-0074" lvl="1"><number>&lsqb;0074&rsqb;</number> 4. Model Number (<highlight><bold>1320</bold></highlight>): Bytes <highlight><bold>2</bold></highlight>-<highlight><bold>3</bold></highlight> of word 2 and byte <highlight><bold>0</bold></highlight> of word 3 contain, if applicable, the three-character (0-9 or uppercase A-Z) EBCDIC model number of the SDC. The model number is right justified with leading EBCDIC zeros if necessary. </paragraph>
<paragraph id="P-0075" lvl="1"><number>&lsqb;0075&rsqb;</number> 5. Manufacturer (<highlight><bold>1325</bold></highlight>): Bytes <highlight><bold>1</bold></highlight>-<highlight><bold>3</bold></highlight> of word 3 contain a three-character (0-9 or uppercase A-Z) EBCDIC code that identifies the manufacturer of the SDC, for example, &ldquo;IBM&rdquo;. </paragraph>
<paragraph id="P-0076" lvl="1"><number>&lsqb;0076&rsqb;</number> 6. Plant of Manufacture (<highlight><bold>1330</bold></highlight>): Bytes <highlight><bold>0</bold></highlight>-<highlight><bold>1</bold></highlight> of word 4 contain a two-character (0-9 or uppercase A-Z) EBCDIC plant code that identifies the plant of manufacture for the SDC. </paragraph>
<paragraph id="P-0077" lvl="1"><number>&lsqb;0077&rsqb;</number> 7. Sequence Number (<highlight><bold>1335</bold></highlight>): Bytes <highlight><bold>2</bold></highlight>-<highlight><bold>3</bold></highlight> of word 4, words 5-6, and bytes <highlight><bold>0</bold></highlight>-<highlight><bold>1</bold></highlight> of word 7 contain the 12-character (0-9 or uppercase A-Z) EBCDIC sequence number of the SDC. The sequence number is right justified with leading EBCDIC zeros if necessary. A serial number consists of the concatenation of the plant-of-manufacture designation with the sequence-number designation. </paragraph>
<paragraph id="P-0078" lvl="1"><number>&lsqb;0078&rsqb;</number> 8. Tag (<highlight><bold>1340</bold></highlight>): Bytes <highlight><bold>2</bold></highlight>-<highlight><bold>3</bold></highlight> of word 7 contain the physical identifier for the SDC interface that is identified by the preceding 26 bytes of the node descriptor. </paragraph>
<paragraph id="P-0079" lvl="0"><number>&lsqb;0079&rsqb;</number> Initialization of the attached requesting device, such as processor <highlight><bold>100</bold></highlight>, will now be described with reference to <cross-reference target="DRAWINGS">FIG. 4</cross-reference>. In preferred embodiments of the present invention, processor <highlight><bold>100</bold></highlight> is an IBM zSeries&trade;, running an operating system such as the IBM Z/OS&trade;. The IBM zSeries is described in an IBM publication titled &ldquo;zSeries 900 System Overview,&rdquo; IBM Publication No. SA22-1027-00, October 2000, and IBM z/OS is described in an IBM publication titled &ldquo;z/OS Introduction and Release Guide,&rdquo; IBM Publication No. GA22-7502-00, March 2001, both of which are hereby incorporated herein by reference in their entirety. While the following description of a preferred embodiment will focus on z/OS, those of ordinary skill in the art should readily realize that other embodiments are possible, utilizing other processors and other operating systems, in keeping within the spirit and scope of the present invention. At the start of initialization, the operating system is given control to begin processing, step <highlight><bold>400</bold></highlight>. Traditional z/OS operating system initialization occurs, step <highlight><bold>405</bold></highlight> which includes loading the system code from the initial program load (IPL) device, initializing storage, initializing tables and state information for the operating system, identifying the hardware resources available for use, processing customization information supplied by the installation, etc. The foregoing list of operations is for illustrative purposes only, and is not an exhaustive list of initialization operations, nor are all of these initialization operations necessarily required in any particular embodiment of the present invention. During traditional z/OS operating system initialization the operating system performs Switch Table Initialization processing <highlight><bold>420</bold></highlight> to build a switch record <highlight><bold>1120</bold></highlight> for each attached switch, thereby creating data structures which represent the I/O topology at the time of processor initialization. During switch table initialization processing, step <highlight><bold>420</bold></highlight>, the system reads the current Key Counter <highlight><bold>300</bold></highlight> and Node Descriptor <highlight><bold>1300</bold></highlight> of all online switches, then saves the Key Counter <highlight><bold>300</bold></highlight> and Node Descriptor <highlight><bold>1300</bold></highlight> for each switch in the Switch Record <highlight><bold>1120</bold></highlight>. As previously indicated, the current value of Key Counter <highlight><bold>300</bold></highlight> is stored in the Switch Key <highlight><bold>1130</bold></highlight> field within the switch record <highlight><bold>1120</bold></highlight> corresponding to this switch. The Node Descriptor (ND) <highlight><bold>1300</bold></highlight> of the switch is stored in the Node Descriptor of Switch <highlight><bold>1125</bold></highlight> field, within the same switch record <highlight><bold>1120</bold></highlight>. After all the online switches attached to processor <highlight><bold>100</bold></highlight> have been processed, step <highlight><bold>420</bold></highlight>, the operating system within processor <highlight><bold>100</bold></highlight> continues its traditional system initialization, step <highlight><bold>425</bold></highlight>. The system initialization processing then completes, step <highlight><bold>430</bold></highlight>. </paragraph>
<paragraph id="P-0080" lvl="7"><number>&lsqb;0080&rsqb;</number> Communication Processes and Protocols </paragraph>
<paragraph id="P-0081" lvl="0"><number>&lsqb;0081&rsqb;</number> Having described the data structures and initialization processes of preferred embodiments of the present invention pertaining to processor <highlight><bold>100</bold></highlight>, the processes and communication protocols by which switch <highlight><bold>135</bold></highlight> and processor <highlight><bold>100</bold></highlight> communicate regarding port configuration changes will now be described. </paragraph>
<paragraph id="P-0082" lvl="0"><number>&lsqb;0082&rsqb;</number> In order for a host program to determine if a switch supports the Read History Summary command, the General node-element qualifier (NEQ) returned by the &ldquo;Read Configuration Data&rdquo; command is modified. The general NEQ is documented in an IBM publication titled &ldquo;ESA/390 Common I/O-Device Commands and Self Description,&rdquo; SA22-7204-02, August 1995, which is hereby incorporated herein by reference in its entirety. Byte <highlight><bold>0</bold></highlight> of word 4 contains the History Buffer Entries field. This field indicates whether or not the Director History Buffer is supported by a particular switch, and if it is supported, the field indicates the number of units of history buffer entries which are implemented in the particular switch. When set to x&lsquo;00&rsquo;, neither the Director History Buffer nor the Read History Summary command is supported. When set to a value other than x&lsquo;00&rsquo;, the field contains an 8-bit unsigned binary integer whose value indicates the number of Directory History Buffer entries that are implemented on this switch. In alternative embodiments, the value may indicate a number of units, where one unit contains more than one entry, such that the number of buffer entries that are implemented is the integer contained in this field times the number of entries per unit. In prior switches, this History Buffer Entries field was a reserved field, and defined to be binary zeroes, so that a prior switch will correctly indicate that it does not support the new Read History Buffer command. By first issuing the Read Configuration Data command, and inspecting the History Buffer Entries field, the host program can avoid issuing the Read History Buffer command to a switch which does not support it. </paragraph>
<paragraph id="P-0083" lvl="0"><number>&lsqb;0083&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 5</cross-reference>A, an overview of the periodic data update process performed within an attached requesting device, such as processor <highlight><bold>100</bold></highlight>, will now be described. <cross-reference target="DRAWINGS">FIG. 5</cross-reference><highlight><italic>a </italic></highlight>shows the processing that occurs when processor <highlight><bold>100</bold></highlight> updates its Switch Table <highlight><bold>1100</bold></highlight>. As previously described, the Switch Table <highlight><bold>1100</bold></highlight> is built during initialization (see <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, step <highlight><bold>420</bold></highlight>). Since port configuration changes may be initiated by any one of a number of devices, processor <highlight><bold>100</bold></highlight> periodically updates Switch Table <highlight><bold>1100</bold></highlight>. In preferred embodiments of the present invention, the Update Switch Table <highlight><bold>500</bold></highlight> process is called every two minutes in order to maintain current information in Switch Table <highlight><bold>1100</bold></highlight>. Other embodiments employing different time intervals are possible, and may be desirable in some situations, and are therefore contemplated within the spirit and scope of the present invention. Updating switch table <highlight><bold>1100</bold></highlight> begins by scanning through the existing switch table, step <highlight><bold>502</bold></highlight>. Processor <highlight><bold>100</bold></highlight> next determines whether there are Switch Records <highlight><bold>1120</bold></highlight> remaining, step <highlight><bold>503</bold></highlight>. If processor <highlight><bold>100</bold></highlight> holds Switch Records <highlight><bold>1120</bold></highlight> remaining which may need updating, processing continues at step <highlight><bold>504</bold></highlight>. For each Switch Record <highlight><bold>1120</bold></highlight> within the Switch Table, processor <highlight><bold>100</bold></highlight> finds the Unit Control Block (UCB) which represents the switch device. The UCB contains a bit that indicates if the switch device is online or offline, step <highlight><bold>504</bold></highlight>. If processor <highlight><bold>100</bold></highlight> determines that the switch is not online <highlight><bold>506</bold></highlight>, processor <highlight><bold>100</bold></highlight> selects the next switch record, step <highlight><bold>520</bold></highlight>, and continues at step <highlight><bold>503</bold></highlight>. If processor <highlight><bold>100</bold></highlight> determines that the switch is online <highlight><bold>506</bold></highlight>, processor <highlight><bold>100</bold></highlight> builds and issues a &ldquo;Sense ID&rdquo; command channel program to obtain the command codes for the &ldquo;Set Interface Identifier&rdquo; and &ldquo;Read Node Identifier&rdquo; commands from the switch <highlight><bold>135</bold></highlight>, at step <highlight><bold>508</bold></highlight>. This step is performed to accommodate various switches and their associated control commands and protocols. Building Channel Programs is documented in an IBM publication titled &ldquo;z/Architecture&mdash;Principles of Operation,&rdquo; SA22-7832-00, December 2000, which is hereby incorporated herein by reference in its entirety. The Sense ID command is documented in an IBM publication titled &ldquo;ESA/390 Common I/O-Device Commands and Self Description,&rdquo; SA22-7204-02, August 1995, which is hereby incorporated herein by reference in its entirety. In particular, the Read Node Identifier command requests a Node Identifier from switch <highlight><bold>135</bold></highlight>, where the Node Identifier contains the Node Descriptor (ND) previously described with reference to <cross-reference target="DRAWINGS">FIG. 12</cross-reference>. After obtaining the command codes for the &ldquo;Set Interface Identifier&rdquo; and &ldquo;Read Node Identifier&rdquo; commands, a channel program is built, step <highlight><bold>510</bold></highlight>, to obtain the switch node descriptor, key counter, and port descriptors of switch <highlight><bold>135</bold></highlight>. To accomplish this, the following channel commands are chained together in this order; Set Interface ID with a Node Selector equal to zero; Read Node Identifier; Read Key Counter; and Read Port Descriptors. These commands are documented in an IBM publication titled &ldquo;Programming the Interface for Enterprise Systems Connection Directors with FICON Converter Feature&rdquo;, SA23-0356-06, September 1999, which is hereby incorporated herein by reference in its entirety. After obtaining the Node Descriptor and Key Counter, these values are compared, at steps <highlight><bold>511</bold></highlight> and <highlight><bold>513</bold></highlight>, to the values currently in the switch record for this particular switch, which is stored within processor <highlight><bold>100</bold></highlight>. First, processor <highlight><bold>100</bold></highlight> determines if switch <highlight><bold>135</bold></highlight> is precisely the same device that had this particular device number <highlight><bold>1135</bold></highlight> during the previous update interval, at step <highlight><bold>511</bold></highlight>. In preferred embodiments of the present invention, this step is accomplished by comparing the Node Descriptor (ND) of switch <highlight><bold>135</bold></highlight> to the ND last known to processor <highlight><bold>100</bold></highlight>. The specific data comprising a Node Descriptor in accordance with preferred embodiments is described below, with reference to <cross-reference target="DRAWINGS">FIG. 12</cross-reference>. If switch <highlight><bold>135</bold></highlight> is not precisely the same device (ND&apos;s do not match), then processor <highlight><bold>100</bold></highlight> refreshes the port configuration information for all implemented ports within new switch <highlight><bold>135</bold></highlight>, step <highlight><bold>512</bold></highlight>. This step is similar to the procedures performed during initialization, as illustrated in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>. Once a new switch record is created at step <highlight><bold>512</bold></highlight>, processing continues at step <highlight><bold>520</bold></highlight> (next switch record). </paragraph>
<paragraph id="P-0084" lvl="0"><number>&lsqb;0084&rsqb;</number> If, at step <highlight><bold>511</bold></highlight>, processor <highlight><bold>100</bold></highlight> determines that switch <highlight><bold>135</bold></highlight> is the same device that had this particular device number <highlight><bold>1135</bold></highlight> during the previous interval, processing continues at step <highlight><bold>513</bold></highlight>. At step <highlight><bold>513</bold></highlight>, processor <highlight><bold>100</bold></highlight> determines whether or not the current Key Counter <highlight><bold>300</bold></highlight> value within switch <highlight><bold>300</bold></highlight> matches the most recent value known to processor <highlight><bold>100</bold></highlight>. If, at step <highlight><bold>513</bold></highlight>, processor <highlight><bold>100</bold></highlight> determines that the value of Key Counter <highlight><bold>300</bold></highlight> has not changed since the previous interval (i.e. processor <highlight><bold>100</bold></highlight> holds the current value of Key Counter <highlight><bold>300</bold></highlight>), no further action is taken for this Switch Record, and processing continues to step <highlight><bold>520</bold></highlight> (next switch record). If, however, the current value of Key Counter <highlight><bold>300</bold></highlight> within switch <highlight><bold>135</bold></highlight> does not match the value known to processor <highlight><bold>100</bold></highlight>, further action is taken to update the configuration information within processor <highlight><bold>100</bold></highlight>, at step <highlight><bold>514</bold></highlight>. The Update Switch Record process is called at step <highlight><bold>514</bold></highlight>; this process is described in detail below, with reference to <cross-reference target="DRAWINGS">FIG. 5B</cross-reference>. After returning from Update Switch Record <highlight><bold>514</bold></highlight>, processing continues by selecting the next switch record, step <highlight><bold>520</bold></highlight>. After selecting the next switch record, step <highlight><bold>520</bold></highlight>, processing continues at step <highlight><bold>503</bold></highlight>. When all switch records have been updated, step <highlight><bold>503</bold></highlight>, processing ends, step <highlight><bold>516</bold></highlight>. </paragraph>
<paragraph id="P-0085" lvl="0"><number>&lsqb;0085&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 5</cross-reference>B, the process used by processor <highlight><bold>100</bold></highlight> to update switch records will now be described. Update Switch Record <highlight><bold>530</bold></highlight> is invoked at step <highlight><bold>514</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 5</cross-reference><highlight><italic>a</italic></highlight>. Processing begins by building and issuing a channel program to read Port Information Blocks (PIBs) from the switch, step <highlight><bold>535</bold></highlight>. A channel program is then built, step <highlight><bold>540</bold></highlight>, to obtain the history summary vector from switch <highlight><bold>135</bold></highlight>. This is accomplished by building a channel command word (CCW) to issue the Test Key command, and chain it to a CCW to issue the Read History Summary command. A discussion of these commands and the use of command chaining follows, with reference to <cross-reference target="DRAWINGS">FIGS. 2A through 2D</cross-reference>. Additional details of the command structures and protocols of preferred embodiments of the present invention will be described below. With additional reference now to <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, the Test Key CCW <highlight><bold>200</bold></highlight> is built by storing a value of &lsquo;0D&rsquo; x in the command code <highlight><bold>205</bold></highlight>, storing a value of &lsquo;40&rsquo;x in the Flags field <highlight><bold>210</bold></highlight>, indicating command chaining is on, storing a value of &lsquo;0004&rsquo;x in the Count field <highlight><bold>215</bold></highlight>, indicating a data transfer of four bytes, and in the Data Address field <highlight><bold>220</bold></highlight>, a pointer to field <highlight><bold>240</bold></highlight> containing the value of the current key counter field from the switch record <highlight><bold>1130</bold></highlight>. The Read History Summary CCW <highlight><bold>260</bold></highlight> is built by storing a value of &lsquo;0E&rsquo; x in the command code field <highlight><bold>265</bold></highlight>; storing a value of &lsquo;00&rsquo;x in the Flags field <highlight><bold>270</bold></highlight>, indicating that command chaining is off; storing a value of &lsquo;24&rsquo;x in the Count field <highlight><bold>275</bold></highlight>, indicating a transfer of 36 bytes; and in the Data Address field <highlight><bold>280</bold></highlight>, a pointer to the place where the output of the Read History Summary command is to be placed <highlight><bold>285</bold></highlight>. The channel program is then started via the Start Subchannel (SSCH) command. When the channel program completes, each bit of the History Summary Vector <highlight><bold>290</bold></highlight> is scanned, step <highlight><bold>545</bold></highlight>. Starting with the leftmost bit in the History Summary Vector <highlight><bold>290</bold></highlight>, bit <highlight><bold>0</bold></highlight>, where bit <highlight><bold>0</bold></highlight> represents port <highlight><bold>0</bold></highlight>, bit <highlight><bold>1</bold></highlight> represents port <highlight><bold>1</bold></highlight>, etc.; the program checks to see if the bit is equal to 1, at step <highlight><bold>550</bold></highlight>. If the bit is not equal to 1, processing continues at step <highlight><bold>565</bold></highlight>. If the bit is equal to one, then information in the switch record for this port should be updated, and processing continues at step <highlight><bold>555</bold></highlight>. In step <highlight><bold>555</bold></highlight>, a channel program is built and issued to read the attached node identifier at the port corresponding to the bit in the History Summary Vector <highlight><bold>290</bold></highlight>. The Switch Record is then updated with the newly obtained node identifier, at step <highlight><bold>560</bold></highlight>. If this is not the last bit (representing the last port) in the bit string, step <highlight><bold>565</bold></highlight>, then processing continues at step <highlight><bold>545</bold></highlight> by selecting the next bit in the bit string. If it is the last bit in the bit string, step <highlight><bold>565</bold></highlight>, then the key counter in the switch record <highlight><bold>1130</bold></highlight> is updated, at step <highlight><bold>570</bold></highlight>, with the New History Buffer Index <highlight><bold>295</bold></highlight>. Update Switch Record processing then terminates, step <highlight><bold>575</bold></highlight>. </paragraph>
<paragraph id="P-0086" lvl="0"><number>&lsqb;0086&rsqb;</number> Specific details of the communication protocols and commands of preferred embodiments of the present invention will now be described. In particular, the commands by which processor <highlight><bold>100</bold></highlight> queries switch <highlight><bold>135</bold></highlight>, and requests a history summary, are described below. </paragraph>
<paragraph id="P-0087" lvl="0"><number>&lsqb;0087&rsqb;</number> Before discussing the commands in detail, a preliminary discussion of command chaining will be provided. In general, command chaining is a method known in the art, whereby a series of channel commands are &ldquo;chained&rdquo; together for execution. Chaining a series of commands insures that each command in the chain is executed, prior to completion of the channel program. As used in preferred embodiments of the present invention, command chaining is employed to chain two specific commands together: a command by which a requesting device determines whether it has the most recent Key Counter (the Test Key command), and a command by which a requesting device determines which port configuration attributes have been modified (the Read History Summary command). By chaining these commands, processing insures that no other processes intervene between the Test Key and Read History Summary commands, potentially causing the value specified in the Test Key command to be overwritten before the Read History Summary executes and is able to extract the value specified in the Test Key command from the History Base Register <highlight><bold>330</bold></highlight>. The command structure of preferred embodiments further uses a No-op command, the purpose of which will be fully described below. </paragraph>
<paragraph id="P-0088" lvl="0"><number>&lsqb;0088&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 2</cross-reference>A, the Test Key channel command will be described. This command is issued by the requesting device, such as processor <highlight><bold>100</bold></highlight>, to determine if the Key Counter value held by the requesting device (Switch Key <highlight><bold>1130</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 11</cross-reference>, stored within the switch record <highlight><bold>1120</bold></highlight> corresponding to switch <highlight><bold>135</bold></highlight>) is the current value stored in switch <highlight><bold>135</bold></highlight>. <cross-reference target="DRAWINGS">FIG. 2A</cross-reference> illustrates the details of the fields in the Test Key channel command of a preferred embodiment of the present invention. The Test Key Channel Command Word <highlight><bold>200</bold></highlight> is the channel command word (CCW) for the test key command. Bits <highlight><bold>0</bold></highlight>-<highlight><bold>7</bold></highlight> of the Test Key CCW contain the Test Key Channel Command code <highlight><bold>205</bold></highlight>, which is &lsquo;0D&rsquo; x in preferred embodiments. Bits <highlight><bold>8</bold></highlight>-<highlight><bold>15</bold></highlight> contain Test Key Flags <highlight><bold>210</bold></highlight>, which affect the processing of the channel program, as described in detail below for preferred embodiments: </paragraph>
<paragraph id="P-0089" lvl="2"><number>&lsqb;0089&rsqb;</number> Chain-Data (CD) Flag: Bit <highlight><bold>8</bold></highlight>, when equal to 1, specifies chaining of data. It causes the storage area designated by the next CCW to be used with the current I/O operation. When the CD flag is one in a CCW, the chain-command and suppress-length-indication flags (see below) are ignored. </paragraph>
<paragraph id="P-0090" lvl="2"><number>&lsqb;0090&rsqb;</number> Chain-Command (CC) Flag: Bit <highlight><bold>9</bold></highlight>, when equal to 1, and when the CD flag and S flag are both zeros, specifies chaining of commands. It causes the operation specified by the command code in the next CCW to be initiated on normal completion of the current operation. </paragraph>
<paragraph id="P-0091" lvl="2"><number>&lsqb;0091&rsqb;</number> Suppress-Length-Indication (SLI) Flag: Bit <highlight><bold>10</bold></highlight> controls whether an incorrect-length condition is to be indicated to the program. When this bit is equal to 1 and the CD flag is zero, the incorrect-length indication is suppressed. When both the CC and SLI flags are ones, and the CD flag is zero, command chaining takes place, regardless of the presence of an incorrect-length condition. This bit should be specified in all CCWs where suppression of the incorrect-length indication is desired. </paragraph>
<paragraph id="P-0092" lvl="2"><number>&lsqb;0092&rsqb;</number> Skip (SKIP) Flag: Bit <highlight><bold>11</bold></highlight>, when equal to one, specifies the suppression of transfer of information to storage during a read, read-backward, sense ID, or sense operation. </paragraph>
<paragraph id="P-0093" lvl="2"><number>&lsqb;0093&rsqb;</number> Program-Controlled-Interruption (PCI) Flag: Bit <highlight><bold>12</bold></highlight>, when equal to one, causes the channel subsystem to generate an intermediate interruption condition when the CCW takes control of the I/O operation. When the PCI flag bit is zero, normal operation takes place. </paragraph>
<paragraph id="P-0094" lvl="2"><number>&lsqb;0094&rsqb;</number> Indirect-Data-Address (IDA) Flag: Bit <highlight><bold>13</bold></highlight>, when equal to one, specifies indirect data addressing. </paragraph>
<paragraph id="P-0095" lvl="2"><number>&lsqb;0095&rsqb;</number> Suspend (S) Flag: Bit <highlight><bold>14</bold></highlight>, when equal to one, specifies suspension of channel-program execution. When valid, it causes channel-program execution to be suspended prior to execution of the CCW containing the S flag. The S flag is valid when bit <highlight><bold>4</bold></highlight>, word 1 of the associated operation request block (ORB) is one. </paragraph>
<paragraph id="P-0096" lvl="2"><number>&lsqb;0096&rsqb;</number> Bit <highlight><bold>15</bold></highlight> is reserved, and is zero. </paragraph>
<paragraph id="P-0097" lvl="0"><number>&lsqb;0097&rsqb;</number> Bits <highlight><bold>16</bold></highlight>-<highlight><bold>31</bold></highlight> contain the length of data to be transferred during execution of this instruction, referred to as the Test Key Byte Count <highlight><bold>215</bold></highlight>. For the Test Key command of preferred embodiments, this is &lsquo;04&rsquo;x. Bits <highlight><bold>32</bold></highlight>-<highlight><bold>63</bold></highlight> of the CCW contain the Address of Buffer Test Key Value <highlight><bold>220</bold></highlight>, which is the address of the buffer where the input is fetched from memory by the channel, referred to as the Buffer Test Key Value <highlight><bold>240</bold></highlight>. Buffer Test Key Value <highlight><bold>240</bold></highlight> is a buffer where the input is fetched from memory by the channel. For this command code it will receive the test key value, a four byte field, which contains the key value which the requesting device, such as processor <highlight><bold>100</bold></highlight>, compares with the current key value in the switch. </paragraph>
<paragraph id="P-0098" lvl="0"><number>&lsqb;0098&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 2</cross-reference>B, the Read History Summary command will be illustrated. <cross-reference target="DRAWINGS">FIG. 2B</cross-reference> illustrates the details of the fields in the Read History Summary channel command. Read History Summary Channel Command Word <highlight><bold>260</bold></highlight> is the channel command word (CCW) for Read History Summary. Bits <highlight><bold>0</bold></highlight>-<highlight><bold>7</bold></highlight> of the Read History Summary CCW contain the Read History Summary Channel Command Code <highlight><bold>265</bold></highlight>, which is &lsquo;0E&rsquo; x in preferred embodiments of the present invention. Bits <highlight><bold>8</bold></highlight>-<highlight><bold>15</bold></highlight> contain Flags <highlight><bold>270</bold></highlight>, used during the Read History Summary command processing, which affect the processing of the channel program. The definition of these bits are the same as for the Test Key Flags <highlight><bold>210</bold></highlight>, previously discussed with reference to <cross-reference target="DRAWINGS">FIG. 2A</cross-reference>. Bits <highlight><bold>16</bold></highlight>-<highlight><bold>31</bold></highlight> contain the Read History Summary Byte Count <highlight><bold>275</bold></highlight>, which represents the length of data to be transferred during execution of this instruction. For the Read History Summary channel command of preferred embodiments, this is &lsquo;24&rsquo;x. Bits <highlight><bold>32</bold></highlight>-<highlight><bold>63</bold></highlight> of the CCW contain the Address of Read History Summary Results <highlight><bold>280</bold></highlight>, which represents the buffer address where the results of the Read History Summary command are stored. Read History Summary Results <highlight><bold>285</bold></highlight> is a 36 byte field which contains the results of the Read History Summary command which are returned to the requesting device by the switch. The History Summary Vector <highlight><bold>290</bold></highlight> is a 256 bit field which indicates which ports were modified from the time the switch Key Counter <highlight><bold>300</bold></highlight> was equal to the value in the History Base Register <highlight><bold>330</bold></highlight> (which is equal to the value of the Key Counter passed to the switch by the requesting device via the buffer <highlight><bold>240</bold></highlight>), to the current value of the Key Counter <highlight><bold>300</bold></highlight>. The individual bits of History Summary Vector <highlight><bold>290</bold></highlight> bear a one to one correspondence to the ports within switch <highlight><bold>135</bold></highlight>, with the leftmost bit, bit <highlight><bold>0</bold></highlight>, representing port <highlight><bold>0</bold></highlight>, and the rightmost bit, bit <highlight><bold>255</bold></highlight> representing port <highlight><bold>255</bold></highlight>. If a particular bit in the History Summary Vector <highlight><bold>290</bold></highlight> is set to 1, then a change was made to the corresponding switch port configuration during the time period represented by this particular History Summary Vector. If a bit in the History Summary Vector <highlight><bold>290</bold></highlight> is set to 0, then no change was made to the corresponding port configuration during the time period represented by this particular History Summary Vector. The New History Buffer Index field <highlight><bold>295</bold></highlight> is a 4 byte field which contains the value of the current Key Counter <highlight><bold>300</bold></highlight> stored within switch <highlight><bold>135</bold></highlight>, when the Read History Summary command was issued. The requesting device, such as processor <highlight><bold>100</bold></highlight>, can use this Key Counter value as the starting point for determining if changes have been made subsequent to its last invocation of Read History Summary. </paragraph>
<paragraph id="P-0099" lvl="0"><number>&lsqb;0099&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 2</cross-reference>C, the No-Operation (or no-op) command will be illustrated. <cross-reference target="DRAWINGS">FIG. 2</cross-reference><highlight><italic>c </italic></highlight>shows the details of the fields in the No-Operation channel command. No-Operation Channel Command Word <highlight><bold>1200</bold></highlight> is the channel command word for No-Operation. Bits <highlight><bold>0</bold></highlight>-<highlight><bold>7</bold></highlight> of the CCW contain the No-Operation Channel Command Code <highlight><bold>1205</bold></highlight>, which is &lsquo;03&rsquo;x. Bits <highlight><bold>8</bold></highlight>-<highlight><bold>15</bold></highlight> contain Flags <highlight><bold>1210</bold></highlight> which may be used with the No-Operation command, which affect the processing of the channel program. The definition of these bits are the same as for the Test Key Flags <highlight><bold>210</bold></highlight> previously described. Bits <highlight><bold>16</bold></highlight>-<highlight><bold>31</bold></highlight> contain the No-Operation Byte Count <highlight><bold>1215</bold></highlight>, which represents the length of data to be transferred during execution of this instruction. For the No-Operation command, this is &lsquo;00&rsquo;x. Bits <highlight><bold>32</bold></highlight>-<highlight><bold>63</bold></highlight> of the CCW contain the Address of No-Operation Results <highlight><bold>1220</bold></highlight>, which should be set to binary zeroes, since a No-Operation command transfers no data. </paragraph>
<paragraph id="P-0100" lvl="0"><number>&lsqb;0100&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 2</cross-reference>D, the chaining of the &ldquo;Test Key,&rdquo; &ldquo;No-Operation,&rdquo; and &ldquo;Read History Summary&rdquo; commands used in preferred embodiments of the present invention will be illustrated. <cross-reference target="DRAWINGS">FIG. 2</cross-reference><highlight><italic>d </italic></highlight>shows the details of how these CCWs are placed in memory <highlight><bold>1250</bold></highlight>. In order to issue the Read History Summary command, the Read History Summary command is preceded by, and chained to, a Test Key command. This is normally done by placing the Test Key CCW first in storage <highlight><bold>1255</bold></highlight>, followed directly by (and adjacent in memory to) a No-Operation CCW <highlight><bold>1260</bold></highlight>, followed directly by (and adjacent in memory to) a Read History Summary CCW <highlight><bold>1265</bold></highlight>. Typically, the Chain-Command bit in the Test Key CCW flags <highlight><bold>210</bold></highlight> is set on, while the Chain-Command bit in the No-Operation CCW flags <highlight><bold>1210</bold></highlight> and the Read History Summary CCW flags <highlight><bold>270</bold></highlight> are set to zero. As a result, when the Test Key command completes, if the &ldquo;Test Key Value&rdquo; is equal to the &ldquo;Key Value&rdquo; (step <highlight><bold>915</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 9</cross-reference>), Test Key will present Normal Ending Status (step <highlight><bold>925</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 9</cross-reference>). This causes the channel subsystem to execute the next CCW, which in this case is the No-Operation CCW. Since the Chain-Command bit is off, after the no-op is executed, the channel command will terminate. If the &ldquo;Test Key Value&rdquo; is not equal to the &ldquo;Key Value&rdquo; (step <highlight><bold>915</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 9</cross-reference>), Test Key will still present Normal Ending Status, but in addition sets the Status Modifier flag on (step <highlight><bold>920</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 9</cross-reference>). Returning a value of one for the Status Modifier flag causes the channel subsystem to skip over the next CCW <highlight><bold>1260</bold></highlight>, and instead process the one after that <highlight><bold>1265</bold></highlight>, which is the Read History Summary CCW. After executing the Read History Summary command, the channel program will end since the Chain-Command bit is off in this CCW <highlight><bold>1265</bold></highlight> also. In order to determine whether step <highlight><bold>920</bold></highlight> or step <highlight><bold>925</bold></highlight> executed, the CCW address within the Subchannel Status Word (SCSW) within the Interruption Request Block (IRB) is examined. This field will contain the address of the last CCW executed, plus 8. The SCSW and IRB are documented in an IBM Publication titled &ldquo;z/Architecture&mdash;Principles of Operation&rdquo;, IBM Publication No. SA22-7832-00, December 2000, which is hereby incorporated herein by reference in its entirety. </paragraph>
<paragraph id="P-0101" lvl="0"><number>&lsqb;0101&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 9</cross-reference>, the processing performed by switch <highlight><bold>135</bold></highlight> in response to a Test Key command will now be described. <cross-reference target="DRAWINGS">FIG. 9</cross-reference> illustrates the processing performed by the switch, beginning at step <highlight><bold>900</bold></highlight>, when it receives the Test Key Channel Command. The switch first obtains the Test Key Value <highlight><bold>240</bold></highlight>, at step <highlight><bold>905</bold></highlight>, pointed to by the Address of Test Key Value <highlight><bold>220</bold></highlight>. The Test Key Value <highlight><bold>240</bold></highlight> is then stored, step <highlight><bold>910</bold></highlight>, in the History Base Register <highlight><bold>330</bold></highlight> for use by switch <highlight><bold>135</bold></highlight> in subsequent processing. In step <highlight><bold>915</bold></highlight>, the Test Key Value <highlight><bold>240</bold></highlight>, which is stored in History Base Register <highlight><bold>330</bold></highlight>, is compared to the Key Counter <highlight><bold>300</bold></highlight>, which is the current value stored in and in use by the switch. If the values of Key Counter <highlight><bold>300</bold></highlight> and Test Key Value <highlight><bold>240</bold></highlight> are equal, the requesting device (such as processor <highlight><bold>100</bold></highlight>) has the current port configuration information, and no updates are necessary. In this case, processing continues at step <highlight><bold>925</bold></highlight>, where the Test Key instruction presents normal ending status without presenting Status Modifier (indicating to the requesting device that updates are unnecessary), and processing then terminates for the Test Key instruction, step <highlight><bold>930</bold></highlight>. If the values of Key Counter <highlight><bold>300</bold></highlight> and Test Key Value <highlight><bold>240</bold></highlight> are not equal, the requesting device does not have the current port configuration information, and an update is indicated. In this case, processing continues at step <highlight><bold>920</bold></highlight>, where the Test Key instruction presents normal ending status, plus &ldquo;Status Modifier&rdquo; indicating to the requesting device that the Key Counter values did not match, and therefore that its port configuration information is in need of an update. Processing then terminates for the Test Key instruction, step <highlight><bold>930</bold></highlight>. </paragraph>
<paragraph id="P-0102" lvl="0"><number>&lsqb;0102&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10</cross-reference> illustrates the processing of the new Read History Summary channel command performed by switch <highlight><bold>135</bold></highlight>, beginning at step <highlight><bold>1000</bold></highlight>, when the switch receives the Read History Summary Channel Command from a requesting device such as processor <highlight><bold>100</bold></highlight>. At step <highlight><bold>1005</bold></highlight>, the switch obtains the test key value from the History Base Register <highlight><bold>330</bold></highlight>. The Key Counter value obtained from the History Base Register <highlight><bold>330</bold></highlight>, in step <highlight><bold>1005</bold></highlight>, is then compared to the current Key Counter <highlight><bold>300</bold></highlight>, in step <highlight><bold>1010</bold></highlight>. If these values are equal, processing continues at step <highlight><bold>1015</bold></highlight>. If these values are not equal, processing continues at step <highlight><bold>1020</bold></highlight>. For equal keys, the switch sets the History Summary Vector <highlight><bold>290</bold></highlight> to all zeroes, step <highlight><bold>1015</bold></highlight>, indicating to the requesting device that no updates are necessary, and switch processing then proceeds to step <highlight><bold>1045</bold></highlight>. For unequal keys, at step <highlight><bold>1020</bold></highlight> the switch searches the Director History Buffer <highlight><bold>315</bold></highlight> for an Index <highlight><bold>320</bold></highlight> which is equal to the key value obtained from the History Base Register <highlight><bold>330</bold></highlight> during step <highlight><bold>1005</bold></highlight>. In step <highlight><bold>1030</bold></highlight>, processing continues by determining if an Index <highlight><bold>320</bold></highlight> matching the key obtained from the History Base Register <highlight><bold>330</bold></highlight> (step <highlight><bold>1005</bold></highlight>), was found within Director History Buffer <highlight><bold>315</bold></highlight>. If no matching Index <highlight><bold>320</bold></highlight> is found within Director History Buffer <highlight><bold>315</bold></highlight>, it is most likely because the History Buffer Record <highlight><bold>317</bold></highlight> that once contained the matching Index has been reused, and has therefore been overwritten with a more recent Key Counter <highlight><bold>300</bold></highlight>. This situation occurs when the number of change events occurring between subsequent queries exceeds the Maximum Number of History Buffer Entries <highlight><bold>305</bold></highlight>. When this condition occurs, switch <highlight><bold>135</bold></highlight> is therefore unable to determine which ports have changed configuration since the key counter was equal to the value stored in the History Base Register <highlight><bold>330</bold></highlight>. In this case, processing continues by setting the individual bits within History Summary Vector <highlight><bold>290</bold></highlight> to ones for all positions associated with implemented external ports, step <highlight><bold>1035</bold></highlight>. Bits in all other bit positions within History Summary Vector <highlight><bold>290</bold></highlight> are set to zeroes. By returning this History Summary Vector <highlight><bold>290</bold></highlight> to the requesting device, switch <highlight><bold>135</bold></highlight> indicates that the requesting device should refresh its port configuration information for all implemented ports within switch <highlight><bold>135</bold></highlight>. Processing then continues at step <highlight><bold>1045</bold></highlight>. If an Index <highlight><bold>320</bold></highlight> matching the key value obtained from the History Base Register <highlight><bold>330</bold></highlight> (from step <highlight><bold>1005</bold></highlight>) is found within Director History Buffer <highlight><bold>315</bold></highlight>, then a connective OR is applied, step <highlight><bold>1040</bold></highlight>, bit-by-bit to all applicable History Buffer Entries <highlight><bold>317</bold></highlight> (i.e. History Buffer Entries <highlight><bold>317</bold></highlight> which have changed since the matching key was current), such that the bit in the History Summary Vector <highlight><bold>290</bold></highlight> is set to a 1 if there is a 1 in the corresponding bit position of any Change Vector <highlight><bold>325</bold></highlight> of the applicable History Buffer Entries <highlight><bold>317</bold></highlight>. If there is a zero in the corresponding bit position of all Change Vectors <highlight><bold>325</bold></highlight> of the applicable History Buffer Entries <highlight><bold>317</bold></highlight>, then the bit in the History Summary Vector <highlight><bold>290</bold></highlight> is set to 0. The set of applicable History Buffer Entries <highlight><bold>317</bold></highlight> is determined by using the results of step <highlight><bold>1030</bold></highlight>: the set of applicable History Buffer Entries <highlight><bold>317</bold></highlight> includes all Entries <highlight><bold>317</bold></highlight> more recent than (and not including) the Entry <highlight><bold>317</bold></highlight> found in step <highlight><bold>1030</bold></highlight> (i.e. the Entry <highlight><bold>317</bold></highlight> having the matching Index value <highlight><bold>320</bold></highlight>), up to and including the current Entry <highlight><bold>317</bold></highlight> pointed to by the Current History Buffer Entry Index <highlight><bold>310</bold></highlight>. Processing then continues at step <highlight><bold>1045</bold></highlight>. In step <highlight><bold>1045</bold></highlight>, the New History Buffer Index <highlight><bold>295</bold></highlight> is set to the current value of the Key Counter <highlight><bold>300</bold></highlight> stored in and in use by switch <highlight><bold>135</bold></highlight>. Processing for the Read History Summary channel command then terminates <highlight><bold>1050</bold></highlight>. </paragraph>
<paragraph id="P-0103" lvl="0"><number>&lsqb;0103&rsqb;</number> Existing commands may be used with preferred embodiments of the present invention. Some existing commands may cause changes to the Key Counter value and port configuration, thereby invoking some aspect of the present invention. Two types of existing commands are discussed below: a command which may increment the Key Counter, and various commands which modify the configuration of one or more ports. </paragraph>
<paragraph id="P-0104" lvl="0"><number>&lsqb;0104&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 13</cross-reference> illustrates the processing of the Test Key and Increment channel command that switch <highlight><bold>135</bold></highlight> performs, beginning at step <highlight><bold>1350</bold></highlight>, when the switch receives the Test Key and Increment command from a requesting device such as processor <highlight><bold>100</bold></highlight>. The Test Key and Increment command is documented in an IBM publication titled &ldquo;Programming the Interface for Enterprise Systems Connection Directors with FICON Converter Feature,&rdquo; SA23-0356-06, September 1999, which is hereby incorporated herein by reference in its entirety. Next, traditional processing occurs <highlight><bold>1355</bold></highlight>. In similar fashion to the Test Key command previously described, the Test Key and Increment command passes a key value from processor <highlight><bold>100</bold></highlight> to switch <highlight><bold>135</bold></highlight>, step <highlight><bold>1355</bold></highlight>. In step <highlight><bold>1360</bold></highlight>, if the values of Key Counter <highlight><bold>300</bold></highlight> and the test key value are equal, the requesting device has the current port configuration information (indicating that processor <highlight><bold>100</bold></highlight> need not update its port configuration information for switch <highlight><bold>135</bold></highlight>), and processing continues at step <highlight><bold>1365</bold></highlight>. As previously described in detail with reference to <cross-reference target="DRAWINGS">FIG. 8</cross-reference>, at step <highlight><bold>1365</bold></highlight> the value of the key counter <highlight><bold>300</bold></highlight> is incremented and a new history buffer entry is created. Processing continues at step <highlight><bold>1370</bold></highlight> where the Test Key and Increment instruction presents normal ending status without presenting Status Modifier, thereby indicating to the requesting device that the key has been incremented and that commands that are serialized can be processed for the remainder of the channel program. Such a serialized command might include, for example, one or more of the commands described below which modify the configuration of one or more ports. Processing then terminates for the Test Key and Increment instruction, step <highlight><bold>1380</bold></highlight>. If, however, at step <highlight><bold>1360</bold></highlight> the values of Key Counter <highlight><bold>300</bold></highlight> and test key value are not equal, the requesting device does not have the current port configuration information. In this case, processing continues at step <highlight><bold>1375</bold></highlight>, where the Test Key and Increment instruction presents normal ending status plus &ldquo;Status Modifier,&rdquo; indicating to the requesting device that the Key Counter values did not match, and therefore the key has not been incremented and commands that are serialized cannot be processed for the remainder of the channel program. This prevents processor <highlight><bold>100</bold></highlight> from making any changes to the configuration of any ports within switch <highlight><bold>135</bold></highlight> based on inaccurate port configuration information. Processing then terminates for the Test Key and Increment instruction, step <highlight><bold>1380</bold></highlight>. </paragraph>
<paragraph id="P-0105" lvl="0"><number>&lsqb;0105&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 14</cross-reference> illustrates the generic processing of one or more commands which modify the configuration of one or more ports within switch <highlight><bold>135</bold></highlight>, beginning at step <highlight><bold>1400</bold></highlight>. In preferred embodiments of the present invention, such a command is issued by an attached requesting device such as processor <highlight><bold>100</bold></highlight>, and subsequently processed by switch <highlight><bold>135</bold></highlight>. Such commands might include, for example &ldquo;Modify Blocked State,&rdquo; &ldquo;Modify Dedicated Connection,&rdquo; or &ldquo;Modify PDCM.&rdquo; These commands are documented in an IBM publication titled &ldquo;Programming the Interface for Enterprise Systems Connection Directors with FICON Converter Feature,&rdquo; SA23-0356-06, September 1999, which is hereby incorporated herein by reference in its entirety. Such commands are advantageously preceded by a command such as the Test Key and Increment command previously described, in order to insure that processor <highlight><bold>100</bold></highlight> initiates port configuration changes only when such changes are based upon current and accurate information (i.e. matching Key Counter values), and that the Key Counter increment process of <cross-reference target="DRAWINGS">FIG. 8</cross-reference> is performed. Next, traditional processing occurs <highlight><bold>1405</bold></highlight>, which includes whatever is normally performed by switch <highlight><bold>135</bold></highlight> in response to the particular command being processed. Processing continues at step <highlight><bold>1410</bold></highlight> where port state change processing is performed, as previously described in detail with reference to <cross-reference target="DRAWINGS">FIG. 7</cross-reference>. The processing of step <highlight><bold>1410</bold></highlight> (i.e. <cross-reference target="DRAWINGS">FIG. 7</cross-reference>) sets a bit in the current change vector, corresponding to each port modified by the command being processed. For example, for &ldquo;Modify PDCM&rdquo; processing would include modifying the Prohibit Dynamic Connectivity Mask (step <highlight><bold>1405</bold></highlight>) and modifying the bit in the change vector corresponding to the port (or ports) who&apos;s state has changed (step <highlight><bold>1410</bold></highlight>). Next, processing continues at step <highlight><bold>715</bold></highlight> where any remaining traditional processing is performed. Processing then terminates at step <highlight><bold>720</bold></highlight>. </paragraph>
<paragraph id="P-0106" lvl="7"><number>&lsqb;0106&rsqb;</number> Alternative Embodiments </paragraph>
<paragraph id="P-0107" lvl="0"><number>&lsqb;0107&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1C</cross-reference> illustrates additional features that may be present in one or more alternative embodiments of the present invention. In general, each switch <highlight><bold>135</bold></highlight> may be connected to one or more processors <highlight><bold>100</bold></highlight>. Further, each processor <highlight><bold>100</bold></highlight> may be connected to one or more switches <highlight><bold>135</bold></highlight>. Each of these possibilities is contemplated within the spirit and scope of the present invention. </paragraph>
<paragraph id="P-0108" lvl="0"><number>&lsqb;0108&rsqb;</number> As further illustrated in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>C, alternative embodiments are contemplated wherein multiple switches <highlight><bold>135</bold></highlight> are chained or cascaded. In particular, processor <highlight><bold>100</bold></highlight> may be attached to switch <highlight><bold>135</bold></highlight>, and switch <highlight><bold>135</bold></highlight> may be attached to a second switch <highlight><bold>136</bold></highlight>. Communication between processor <highlight><bold>100</bold></highlight> and CU&apos;s <highlight><bold>150</bold></highlight> is accomplished through both switches <highlight><bold>135</bold></highlight> and <highlight><bold>136</bold></highlight>: in the configuration illustrated in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>C, processor <highlight><bold>100</bold></highlight> does not have access to a direct communication path to switch <highlight><bold>136</bold></highlight>. Under these or similar circumstances, the requesting device may be another switch, rather than a processor. For example, the requesting device for switch <highlight><bold>136</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 1C</cross-reference> may be switch <highlight><bold>135</bold></highlight>. Switch <highlight><bold>135</bold></highlight> may have knowledge of the configuration of switch <highlight><bold>136</bold></highlight>, enabling switch <highlight><bold>135</bold></highlight> to process routing requests efficiently, to provide the configuration information of switch <highlight><bold>136</bold></highlight> to another requesting device, such as processor <highlight><bold>100</bold></highlight>, in the case that the other requesting device does not have access to all switches in the topology, or is unable to access switch <highlight><bold>136</bold></highlight> directly. In such a case, the requesting switch would issue commands to the other switch, presenting itself to the other switch as if it were a host. The data structures, processes, and communication protocols described herein also apply to such circumstances, where the requesting device is a switch. </paragraph>
<paragraph id="P-0109" lvl="0"><number>&lsqb;0109&rsqb;</number> In alternative embodiments, the requesting device may be a process which manages or monitors a switched storage environment (or topology), for example a SAN manager. In such an embodiment the process could reside on a host processor, a switch within the environment, or as a separate processor used for managing and/or monitoring the storage topology or environment. </paragraph>
<paragraph id="P-0110" lvl="0"><number>&lsqb;0110&rsqb;</number> While the invention has been described in detail herein in accord with certain preferred embodiments thereof, many modifications and changes therein may be effected by those skilled in the art. Accordingly, it is intended by the appended claims to cover all such modifications and changes as fall within the true spirit and scope of the invention. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method of informing a requesting device of configuration changes in a switched I/O network in communication with said requesting device, said method comprising the steps of: 
<claim-text>initializing a switch in communication with said requesting device, said switch including a plurality of communication ports, said initializing including the steps of setting an initial change index value, creating an initial data vector identifying implemented ports, and storing said change index value in association with said initial data vector; </claim-text>
<claim-text>incrementing said change index in response to a subsequent configuration change; </claim-text>
<claim-text>creating a data vector in response to said subsequent configuration change, said data vector identifying each of said plurality of ports affected by said subsequent configuration change; </claim-text>
<claim-text>storing said data vector in association with said incremented change index; </claim-text>
<claim-text>responding to a query from said requesting device, by identifying to said requesting device all ports previously identified as affected by a configuration change in one or more data vectors associated with change index values more recent than the most recent change index value known to said requesting device. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein said initializing further includes the steps of: 
<claim-text>determining the current configuration of said plurality of ports, </claim-text>
<claim-text>storing port configuration information describing said current configuration. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, further comprising the steps of: 
<claim-text>communicating at least a portion of said stored port configuration information to said requesting device; </claim-text>
<claim-text>storing said communicated port configuration information in said requesting device. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, further comprising the steps of: 
<claim-text>updating said stored configuration information to reflect said subsequent configuration change; </claim-text>
<claim-text>storing said updated configuration information. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00004">claim 4</dependent-claim-reference>, further comprising the steps of: 
<claim-text>communicating at least a portion of said updated port configuration information to said requesting device; </claim-text>
<claim-text>storing said communicated port configuration information in said requesting device. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein a limited number of the most recent pairs of associated change indices and data vectors are stored. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference>, wherein when the most recent change index known to the requesting device is no longer stored by said switch, the requesting device is informed that all of said implemented ports have been affected by a configuration change. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising the step of passing from said requesting device to said switch, substantially concurrently with said query, the most recent change index value known to said requesting device. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference>, further comprising the steps of: 
<claim-text>storing in said switch said most recent change index value known to said requesting device, and </claim-text>
<claim-text>using said stored change index value to identify the first change index value for which port configuration changes are identified. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. A method of informing a requesting device of configuration changes in a switched I/O network in communication with said requesting device, said method comprising the steps of: 
<claim-text>initializing a switch in processing communication with said requesting device, said switch comprising a plurality of communication ports, said initializing including the steps of determining the current port configuration, storing port configuration information describing said current port configuration, setting an initial change index value, creating an initial data vector identifying implemented ports, and storing said change index value in association with said initial data vector; changing said port configuration; </claim-text>
<claim-text>updating said stored port configuration information to describe said changed port configuration; </claim-text>
<claim-text>storing said updated port configuration information; </claim-text>
<claim-text>incrementing said change index in response to said configuration change; </claim-text>
<claim-text>creating a data vector identifying each of said plurality of ports affected by said configuration change; </claim-text>
<claim-text>storing said data vector in association with said incremented change index; </claim-text>
<claim-text>responding to a query from said requesting device, by identifying to said requesting device all ports previously identified as affected by a configuration change in one or more data vectors associated with change index values more recent than the most recent change index value known to said requesting device. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, further comprising the steps of: 
<claim-text>communicating at least a portion of said stored port configuration information to said requesting device; </claim-text>
<claim-text>storing said communicated port configuration information in said requesting device. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, further comprising the steps of: 
<claim-text>communicating at least a portion of said updated port configuration information to said requesting device; </claim-text>
<claim-text>storing said communicated port configuration information in said requesting device. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein a limited number of the most recent pairs of associated change indices and data vectors are stored. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference>, wherein when the most recent change index known to the requesting device is no longer stored, the requesting device is informed that all of said implemented ports have been affected by a configuration change. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, further comprising the step of: 
<claim-text>passing, from said requesting device to said switch substantially concurrently with said query, the most recent change index value known to said requesting device. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference>, further comprising the steps of: 
<claim-text>storing in said switch said most recent change index value known to said requesting device, and </claim-text>
<claim-text>using said stored change index value to identify the first change index value for which port configuration changes are identified. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. An input/output (I/O) network switching device, said device comprising: 
<claim-text>a plurality of communication ports, each of said ports capable of being in communication with an external data processing device; </claim-text>
<claim-text>a switch processor in communication with said plurality of communication ports, said switch processor further capable of being in communication with a requesting device; </claim-text>
<claim-text>a port configuration history data structure accessible to said switch processor, said history data structure comprising associated pairs of change index values and change data vectors, each of said associated pairs relating to a port configuration change event, each of said change index values providing for said history data structure an index corresponding to said related port configuration change event, each of said change data vectors identifying specific ones of said plurality of ports affected by said related port configuration change event; </claim-text>
<claim-text>an incrementing unit, said incrementing unit increasing by one the current value of said change index value in response to a port configuration change event; </claim-text>
<claim-text>port configuration data accessible to said switch processor, said port configuration data being used by said switch processor to create one of said change data vectors in response to and in association with a port configuration change event, said switch processor storing said incremented change index value and said one of said change data vectors as one of said associated pairs within said port configuration history data structure; </claim-text>
<claim-text>a configuration history summary unit, wherein in response to a query from said requesting device said configuration history summary unit produces a summary vector identifying all ports previously identified as affected by a configuration change in one or more change data vectors associated with change index values more recent than the most recent change index value known to said requesting device, said summary vector capable of being communicated to said requesting device in response to said query. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The device of <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference>, wherein said requesting device is a host processor. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The device of <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference>, wherein said requesting device is a second input/output network switching device. </claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The device of <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference>, wherein said input/output switching device is an ESCON director. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The device of <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference>, wherein said I/O switching device is a FICON director. </claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The device of <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference>, wherein said requesting device is a process which manages a switched storage environment. </claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The device of <dependent-claim-reference depends_on="CLM-00022">claim 22</dependent-claim-reference>, wherein said requesting device is a SAN manager. </claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The device of <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference>, wherein said external data processing device is selected from the group consisting of a host processor, an I/O device controller, and another I/O network switching device. </claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. At least one program storage device readable by a machine tangibly embodying at least one program of instructions executable by machine to perform a method for informing a requesting device of configuration changes in a switched I/O network in communication with said requesting device, said method comprising: 
<claim-text>initializing a switch in communication with said requesting device, said switch including a plurality of communication ports, said initializing including the steps of setting an initial change index value, and storing said change index value in association with an initial configuration of said plurality of ports; </claim-text>
<claim-text>incrementing said change index in response to a subsequent configuration change; </claim-text>
<claim-text>creating a data vector in response to said subsequent configuration change, said data vector identifying each of said plurality of ports affected by said subsequent configuration change; </claim-text>
<claim-text>storing said data vector in association with said incremented change index; </claim-text>
<claim-text>responding to a query from said requesting device, by identifying to said requesting device all ports previously identified as affected by a configuration change in one or more data vectors associated with change index values more recent than the most recent change index value known to said requesting device. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. The at least one program storage device of <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>, wherein said initializing further includes the steps of: 
<claim-text>determining the current configuration of said plurality of ports, </claim-text>
<claim-text>storing port configuration information describing said current configuration. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. The at least one program storage device of <dependent-claim-reference depends_on="CLM-00022">claim 26</dependent-claim-reference>, further comprising the steps of: 
<claim-text>communicating at least a portion of said stored port configuration information to said requesting device; </claim-text>
<claim-text>storing said communicated port configuration information in said requesting device. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. The at least one program storage device of <dependent-claim-reference depends_on="CLM-00022">claim 26</dependent-claim-reference>, further comprising the steps of: 
<claim-text>updating said stored configuration information to reflect said subsequent configuration change; </claim-text>
<claim-text>storing said updated configuration information. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00029">
<claim-text><highlight><bold>29</bold></highlight>. The at least one program storage device of <dependent-claim-reference depends_on="CLM-00022">claim 28</dependent-claim-reference>, further comprising the steps of: 
<claim-text>communicating at least a portion of said updated port configuration information to said requesting device; </claim-text>
<claim-text>storing said communicated port configuration information in said requesting device. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00030">
<claim-text><highlight><bold>30</bold></highlight>. The at least one program storage device of <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>, wherein a limited number of the most recent pairs of associated change indices and data vectors are stored. </claim-text>
</claim>
<claim id="CLM-00031">
<claim-text><highlight><bold>31</bold></highlight>. The at least one program storage device of <dependent-claim-reference depends_on="CLM-00033">claim 30</dependent-claim-reference>, wherein when the most recent change index known to the requesting device is no longer stored, the requesting device is informed that all of said plurality of ports have been affected by a configuration change. </claim-text>
</claim>
<claim id="CLM-00032">
<claim-text><highlight><bold>32</bold></highlight>. The at least one program storage device of <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>, further comprising the step of passing from said requesting device to said switch, substantially concurrently with said query, the most recent change index value known to said requesting device. </claim-text>
</claim>
<claim id="CLM-00033">
<claim-text><highlight><bold>33</bold></highlight>. The at least one program storage device of <dependent-claim-reference depends_on="CLM-00033">claim 32</dependent-claim-reference>, further comprising the steps of: 
<claim-text>storing in said switch said most recent change index value known to said requesting device, and </claim-text>
<claim-text>using said stored change index value to identify the first change index value for which port configuration changes are identified. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00034">
<claim-text><highlight><bold>34</bold></highlight>. The at least one program storage device of <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>, further comprising the step of informing said requesting device that said switch support the history buffer feature, prior to said responding.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>1A</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030002492A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030002492A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030002492A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030002492A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030002492A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030002492A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030002492A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030002492A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030002492A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00009">
<image id="EMI-D00009" file="US20030002492A1-20030102-D00009.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00010">
<image id="EMI-D00010" file="US20030002492A1-20030102-D00010.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00011">
<image id="EMI-D00011" file="US20030002492A1-20030102-D00011.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00012">
<image id="EMI-D00012" file="US20030002492A1-20030102-D00012.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00013">
<image id="EMI-D00013" file="US20030002492A1-20030102-D00013.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00014">
<image id="EMI-D00014" file="US20030002492A1-20030102-D00014.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00015">
<image id="EMI-D00015" file="US20030002492A1-20030102-D00015.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00016">
<image id="EMI-D00016" file="US20030002492A1-20030102-D00016.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00017">
<image id="EMI-D00017" file="US20030002492A1-20030102-D00017.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00018">
<image id="EMI-D00018" file="US20030002492A1-20030102-D00018.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00019">
<image id="EMI-D00019" file="US20030002492A1-20030102-D00019.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00020">
<image id="EMI-D00020" file="US20030002492A1-20030102-D00020.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
