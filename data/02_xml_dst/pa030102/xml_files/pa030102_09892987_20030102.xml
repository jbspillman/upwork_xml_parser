<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030002537A1-20030102-D00000.TIF SYSTEM "US20030002537A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030002537A1-20030102-D00001.TIF SYSTEM "US20030002537A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030002537A1-20030102-D00002.TIF SYSTEM "US20030002537A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030002537A1-20030102-D00003.TIF SYSTEM "US20030002537A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030002537A1-20030102-D00004.TIF SYSTEM "US20030002537A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030002537A1-20030102-D00005.TIF SYSTEM "US20030002537A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030002537A1-20030102-D00006.TIF SYSTEM "US20030002537A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030002537A1-20030102-D00007.TIF SYSTEM "US20030002537A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030002537A1-20030102-D00008.TIF SYSTEM "US20030002537A1-20030102-D00008.TIF" NDATA TIF>
<!ENTITY US20030002537A1-20030102-D00009.TIF SYSTEM "US20030002537A1-20030102-D00009.TIF" NDATA TIF>
<!ENTITY US20030002537A1-20030102-D00010.TIF SYSTEM "US20030002537A1-20030102-D00010.TIF" NDATA TIF>
<!ENTITY US20030002537A1-20030102-D00011.TIF SYSTEM "US20030002537A1-20030102-D00011.TIF" NDATA TIF>
<!ENTITY US20030002537A1-20030102-D00012.TIF SYSTEM "US20030002537A1-20030102-D00012.TIF" NDATA TIF>
<!ENTITY US20030002537A1-20030102-D00013.TIF SYSTEM "US20030002537A1-20030102-D00013.TIF" NDATA TIF>
<!ENTITY US20030002537A1-20030102-D00014.TIF SYSTEM "US20030002537A1-20030102-D00014.TIF" NDATA TIF>
<!ENTITY US20030002537A1-20030102-D00015.TIF SYSTEM "US20030002537A1-20030102-D00015.TIF" NDATA TIF>
<!ENTITY US20030002537A1-20030102-D00016.TIF SYSTEM "US20030002537A1-20030102-D00016.TIF" NDATA TIF>
<!ENTITY US20030002537A1-20030102-D00017.TIF SYSTEM "US20030002537A1-20030102-D00017.TIF" NDATA TIF>
<!ENTITY US20030002537A1-20030102-D00018.TIF SYSTEM "US20030002537A1-20030102-D00018.TIF" NDATA TIF>
<!ENTITY US20030002537A1-20030102-D00019.TIF SYSTEM "US20030002537A1-20030102-D00019.TIF" NDATA TIF>
<!ENTITY US20030002537A1-20030102-D00020.TIF SYSTEM "US20030002537A1-20030102-D00020.TIF" NDATA TIF>
<!ENTITY US20030002537A1-20030102-D00021.TIF SYSTEM "US20030002537A1-20030102-D00021.TIF" NDATA TIF>
<!ENTITY US20030002537A1-20030102-D00022.TIF SYSTEM "US20030002537A1-20030102-D00022.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030002537</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09892987</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010627</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>H04J003/06</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>370</class>
<subclass>503000</subclass>
</uspc>
</classification-us-primary>
<classification-us-secondary>
<uspc>
<class>370</class>
<subclass>345000</subclass>
</uspc>
</classification-us-secondary>
</classification-us>
<title-of-invention>Method and apparatus for controlling the timing of a communication device</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Lane</given-name>
<middle-name>B.</middle-name>
<family-name>Schaller</family-name>
</name>
<residence>
<residence-us>
<city>Western Springs</city>
<state>IL</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
</inventors>
<correspondence-address>
<name-1>GREER, BURNS &amp; CRAIN</name-1>
<name-2></name-2>
<address>
<address-1>300 S WACKER DR</address-1>
<address-2>25TH FLOOR</address-2>
<city>CHICAGO</city>
<state>IL</state>
<postalcode>60606</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A system timer controls the timing at which a mobile communication device communicates with a base station. The system timer includes a sequencer that executes a set of instructions stored in a sequencer RAM thereby causing a set of control signals to be supplied to a set of components residing in the mobile communication device including, a set of RF hardware devices, a microprocessor and a digital signal processor. The microprocessor or the digital signal processor may alter the order in which the instructions are executed by the sequencer thereby allowing the mobile communication device to communicate in a dynamic multi-slot communication environment. The system timer may include a timebase counter used to synchronize the timing of the mobile communication device with the timing of the base station. A value stored in the timebase counter is incremented at a predefined rate and the value stored in the timebase counter wraps to zero upon reaching a predefined value. The system timer may further include a set of registers for storing a value that may be used to adjust the predefined value at which the timebase counter wraps and for storing a value that may be used to either increment or decrement the value stored in the timebase counter allowing the system timer to remain synchronized with the base station despite movement of the mobile communication device relative to the base station. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> The present invention generally relates to a communication system timer, and more particularly to a communication system timer and a method for controlling the timing of a communication device to enable dynamic multi-slot communication. </paragraph>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> Enabling communication between a mobile communication device and one or more base stations is largely dependent on the ability to coordinate the timing of the mobile device with the timing of the base station(s). Toward this end, base stations are conventionally configured to communicate at a standard frequency or set of frequencies that may be defined for example, in an industry standard such as the TIA-EIA-136 standard or the standard that governs communication within a GSM communication system. In addition, base stations are configured to communicate using signals that are formatted according to a communication protocol that is also defined via the communication standard in use. For example, communication is typically defined to be cyclical in that each communication signal comprises a series of data frames having a defined format. Specifically, each frame is typically defined to include a fixed number of data symbols and a fixed number of time slots during which predefined forms of communication may occur. The time slots may comprise one or more receive slots during which the mobile communication device may be designated to receive information transmitted by the base station and one or more transmit slots during which the mobile communication device may be designated to transmit information to the base station. Thus, after a first frame comprising, for example, a receive slot and a transmit slot, the cycle repeats, i.e., another frame having a receive slot and a transmit slot follow. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> As a result, the duration of each frame is equal to the smallest amount of time before the communication cycle repeats. Due to the cyclical nature of the communication signal and because the positions within a frame at which the receive and transmit slots are located may be fixed relative to the start of the frame, once the mobile device determines where the start of a frame occurs within a communication signal, the mobile device may synchronize to the frame start time so that subsequently transmitted frames are properly received. More particularly, once the start of a frame is identified, a system timer disposed in the mobile device synchronizes to the frame start and then generates control signals to control the timing at which various components disposed within the mobile device operate. For example, the system timer may generate control signals that enable a transmitter during the transmit slot and that enable a receiver during the receive slot. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> Conventionally, system timers are configured to perform timing control by executing a set of software instructions that have been preprogrammed into the timer during manufacture. Thus, the conventional system timer may be programmed to operate according to a single predefined communication protocol. However, communication protocols are becoming more robust and are able to support a greater number and increasingly diverse set of signal formats. For example, mobile communication protocols that were once formatted exclusively to support the transmission of voice data are now being adapted to support the transmission of digital data. Unfortunately, the programming associated with conventional system timers is fixed such that the mobile communication device is limited to communicating in the protocol or format for which the system timer was originally programmed. In addition, system timers are currently used in a variety of different wireless communication devices that may each be adapted to operate according to different communication protocols. However, due to the preprogrammed, inflexible configuration of conventional system timers, a different system timer must be manufactured for each specific application. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> Moreover, due to the mobility of a mobile communication device a system timer that has successfully synchronized to the base station may become unsynchronized due to movement of the mobile communication device relative to the base station. Specifically, the distance between a mobile communication device and a base station may vary when, for example, the mobile communication device is disposed in an automobile that is traveling either nearer or farther away from the base station and may adversely affect the timing between the mobile communication device and the base station and may cause interference between the signals being transmitted by the mobile communication device and signals being transmitted by one or more other mobile communication devices. More particularly, the base station assigns each mobile communication device disposed in a service area, referred to as a cell, associated with the base station a slot of time occurring at a specific location in a frame during which the mobile communication device may transmit signals for reception at the base station. However, a mobile telephone disposed in an automobile traveling toward the base station may generate signals that arrive at the base station earlier than the time slot assigned to that mobile communication device. Specifically, because the distance between the mobile station and the base station is decreasing as the automobile moves toward the base station the signal arrives earlier because the signal travels a shorter distance to reach the base station. Unfortunately, a signal arriving too early will interfere with a communication signal transmitted by a mobile communication device that has been assigned the earlier time slot. In contrast, a mobile communication device disposed in an automobile traveling away from the base station may generate signals that arrive at the base station later than anticipated because the distance between the mobile station and the base station is increasing as the automobile moves away from the base station so that the signal must travel a longer distance before reaching the base station. Thus, the signals that arrive at the base station late will interfere with communication signals transmitted by a mobile communication device that has been assigned to the later time slot. To combat this phenomenon, the base station is adapted to measure a timing delay associated with each mobile communication device communicating with the base station that represents the amount of time that a signal emanating from each mobile station is arriving either early or late. The base station then requests that each mobile telephone adjust the times at which information is transmitted to the base station by an amount of time equal to the time delay. When received at the mobile telephone, a microprocessor disposed in the mobile communication device may cause the system timer to use the timing delay to adjust the timing of the mobile communication device. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> Conventional system timers are typically configured to use the timing delay information transmitted by the base station as it is received from the base station. Thus, timing delay information transmitted to the mobile communication device is supplied to the system timer at any time during the frame and often at multiple times during the frame. As a result, the system timer may interrupt the operation of the microprocessor or the digital signal processor several times during each frame to receive the delay data required for the timer to remain synchronous with the base station. Unfortunately, repeated interruptions unnecessarily burden the microprocessor/digital signal processor and unnecessarily limit the ability of the mobile device to perform at higher data rates. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> Thus, there is a need in the art for a method and apparatus for controlling the timing at which a mobile communication device communicates that is adapted to execute instructions in a non-fixed order so that the mobile communication device may communicate different amounts of data using differently formatted signals. In addition, there is a further need in the art for a method and apparatus for controlling the timing at which a mobile communication device communicates that is able to compensate for movement of the mobile communication device relative to the base station in an efficient manner.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a block diagram of a communication network having a set of base stations for providing service to a mobile communication device located within a cell region; </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a block diagram of a base station of <cross-reference target="DRAWINGS">FIG. 1</cross-reference> coupled to a public switched telephone network; </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a diagram of a format for a frame of data symbols associated with a communication signal; </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a block diagram of one of the mobile communication devices of <cross-reference target="DRAWINGS">FIG. 1</cross-reference>; </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> illustrates a model of the architecture of the mobile communication device of <cross-reference target="DRAWINGS">FIG. 4</cross-reference>; </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is a block diagram of a system timer disposed in the mobile communication device of <cross-reference target="DRAWINGS">FIG. 4</cross-reference> and configured in accordance with the present invention; </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> is a diagram of the internal configuration of a control register shown in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>; </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> is a diagram of the internal configuration of a microprocessor interrupt status register shown in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>; </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference> is a table having a set of software instructions for programming the system timer of <cross-reference target="DRAWINGS">FIG. 4</cross-reference>; </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10</cross-reference> is a table having a set of interrupt signals that may be supplied by the system timer of <cross-reference target="DRAWINGS">FIG. 4</cross-reference> to the DSP of <cross-reference target="DRAWINGS">FIG. 4</cross-reference>; </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 11</cross-reference> is a block diagram illustrating a set of mode programs stored in the sequencer RAM associated with the system timer; </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 12</cross-reference> is a flow chart illustrating a method of system timer operation associated with an Idle mode; </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 13</cross-reference> is a flow chart illustrating a first method of system timer operation associated with an Acquisition mode; </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 14</cross-reference> is a flow chart illustrating a first method of system timer operation associated with a Steady State mode; </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 15</cross-reference> is a flow chart illustrating a second method of system timer operation associated with a Steady State mode; </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 16</cross-reference> is a diagram of a set of data frames having different timing characteristics; </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 17</cross-reference> is a flow chart illustrating a method for adjusting the length of a frame to change the time at which a receive slot begins; </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 18</cross-reference> is a flow chart illustrating a method for adjusting the timebase counter to change the time at which a transmit slot begins; </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 19</cross-reference> is a set of waveforms that may be generated by the system timer; </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 20</cross-reference> is a table of software instructions that may be used to program the system timer to generate the waveforms of <cross-reference target="DRAWINGS">FIG. 19</cross-reference>; </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 21</cross-reference> is a table of software instructions that may be used to program the system timer to generate the waveforms of <cross-reference target="DRAWINGS">FIG. 19</cross-reference>; </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 22</cross-reference> is a table of software instructions that may be used to program the system timer to generate the waveforms of <cross-reference target="DRAWINGS">FIG. 19</cross-reference>; </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 23A and 23B</cross-reference> provide a set of generic program blocks that may be stored in the sequencer RAM and executed by the system timer under the control of the microprocessor of <cross-reference target="DRAWINGS">FIG. 4</cross-reference>; </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 24</cross-reference> is a waveform that may be generated by the system timer using the generic program blocks of <cross-reference target="DRAWINGS">FIGS. 23A and 23B</cross-reference>; </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 25</cross-reference> is a waveform that may be generated by the system timer using the generic program blocks of <cross-reference target="DRAWINGS">FIGS. 23A and 23B</cross-reference>; and, </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 26</cross-reference> is a block diagram of a system timer configured to control two serial devices.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> According to one aspect of the invention, a system timer controls the timing at which a mobile device communicates and includes a processor for executing a set of software instructions and a memory device coupled to the processor for storing the software instructions. In response to executing the set of software instructions, the processor causes a set of control signals that are adapted to control the timing of the communication device to be generated. The order in which the processor executes the instructions is not fixed but may instead be altered by a microprocessor and/or a digital signal processor disposed in the mobile device. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> The mobile device further includes a timebase counter and frame counter that operate at a predefined communication frequency. A timebase length register, timebase adjust register and timing adjust register may be used to alter the values stored in the timebase counter to thereby compensate for movement of the mobile device relative to the base station. </paragraph>
</section>
<section>
<heading lvl="1">DETAILED DESCRIPTION </heading>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> Referring now to the drawings, wherein like reference numerals refer to similar or identical parts throughout the several views, and more specifically to <cross-reference target="DRAWINGS">FIG. 1</cross-reference> thereof, there is shown a block diagram representation of a network of mobile communication system base stations <highlight><bold>10</bold></highlight> that provide wireless communication service to a wireless communication device <highlight><bold>12</bold></highlight> (&ldquo;communication device&rdquo;) on a subscription basis. Specifically, each base station <highlight><bold>10</bold></highlight> is adapted to provide service to the communication device <highlight><bold>12</bold></highlight> that is located within a respective, geographically defined service area, referred to as a cell <highlight><bold>14</bold></highlight>, having a six-sided geometric shape. Further, the base stations <highlight><bold>10</bold></highlight> are geographically positioned so that the cell <highlight><bold>14</bold></highlight> associated with each base station <highlight><bold>10</bold></highlight> abuts against the cells <highlight><bold>14</bold></highlight> associated with six other base stations <highlight><bold>10</bold></highlight> to thereby form a honeycomb-like pattern (see <cross-reference target="DRAWINGS">FIG. 2</cross-reference>) of cells <highlight><bold>14</bold></highlight> in which continuous communication service is available to the communication device <highlight><bold>12</bold></highlight> disposed therein. As will be understood by one having ordinary skill in the art, the shape of the cell is not limited to a six-sided figure and may instead have any desired configuration. Further, the cell octagonal shape is typically generated by causing a set of six cells having circularly shaped coverage areas to overlap in manner such that each cell has a coverage area shaped like an octagon. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> Referring now to <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, each base station <highlight><bold>10</bold></highlight> has a set of wireless communication equipment <highlight><bold>16</bold></highlight>, including, for example, a transmitting device <highlight><bold>18</bold></highlight> and a receiving device <highlight><bold>20</bold></highlight>, to enable communication with the communication devices <highlight><bold>12</bold></highlight> and to further enable communication between the communication devices <highlight><bold>12</bold></highlight> and a public switched telephone network (&ldquo;PSTN&rdquo;) <highlight><bold>22</bold></highlight>. A base station system clock <highlight><bold>24</bold></highlight>, also disposed at the base station <highlight><bold>10</bold></highlight>, operates at a multiple of the rate at which the base station <highlight><bold>10</bold></highlight> generates data symbols. For example, the system clock <highlight><bold>24</bold></highlight> may operate at a frequency of 13 MHz for a GSM system or at a frequency of 9.72 MHz for a system governed by TIA-IA-136. As will be understood by one having ordinary skill in the art, a data symbol is a term of art that generally refers to a predefined quantity of data. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> Referring also to <cross-reference target="DRAWINGS">FIG. 3</cross-reference>, wireless communication signals <highlight><bold>26</bold></highlight> are conventionally formatted to include a stream of data symbols that are further formatted into frames <highlight><bold>26</bold></highlight>, each of which includes a defined quantity of symbols. In addition, portions of each frame <highlight><bold>26</bold></highlight>, referred to as time slots, are reserved for specific forms of communication. For example, depending upon the standard in use, each frame <highlight><bold>26</bold></highlight> will typically include a receive slot <highlight><bold>28</bold></highlight> during which a receiver (not shown) disposed in the communication device <highlight><bold>12</bold></highlight> is enabled so that communication signals may be received from the base station <highlight><bold>10</bold></highlight>. In addition, each frame <highlight><bold>26</bold></highlight> will typically include a transmit slot <highlight><bold>30</bold></highlight> during which a transmitter (not shown) disposed in the communication device <highlight><bold>12</bold></highlight> is enabled so that communication signals may be transmitted from the communication device <highlight><bold>12</bold></highlight> to the base station <highlight><bold>10</bold></highlight>. Of course, a transmit slot <highlight><bold>30</bold></highlight> occurring at the communication device <highlight><bold>12</bold></highlight> is treated as a receive slot <highlight><bold>28</bold></highlight> at the base station <highlight><bold>10</bold></highlight> and a receive slot <highlight><bold>28</bold></highlight> is treated as a transmit slot <highlight><bold>30</bold></highlight> at the base station <highlight><bold>10</bold></highlight>. Moreover, each frame may include a single receive slot and a single transmit slot that are both designated for communication with a single communication device <highlight><bold>12</bold></highlight>, as depicted in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>, or may instead include multiple receive slots <highlight><bold>28</bold></highlight> and/or multiple transmit slots <highlight><bold>30</bold></highlight> that are designated for communication with a single communication device <highlight><bold>12</bold></highlight> to permit multi-slot communication. As will be understood by one having ordinary skill in the art, the positions at which the receive and transmit slots <highlight><bold>28</bold></highlight>, <highlight><bold>30</bold></highlight> are disposed in the frame <highlight><bold>26</bold></highlight> may vary depending on the communication standard in use. Each frame <highlight><bold>26</bold></highlight> will typically further include a handoff time slot <highlight><bold>32</bold></highlight> reserved for the receipt of handoff information at the communication device <highlight><bold>12</bold></highlight> that may be positioned at any number of locations in the frame <highlight><bold>26</bold></highlight> depending upon the communication standard in use. For example, the handoff time slot <highlight><bold>32</bold></highlight> may be located at a first position <highlight><bold>32</bold></highlight>A that is disposed before the transmit slot <highlight><bold>30</bold></highlight> and after the receive slot <highlight><bold>28</bold></highlight> or at a second position <highlight><bold>32</bold></highlight>B that is disposed after the transmit slot <highlight><bold>30</bold></highlight>. As will be understood by one having ordinary skill in the art, during the handoff time slot <highlight><bold>32</bold></highlight>, the communication device <highlight><bold>12</bold></highlight> tunes to an off-channel frequency in an attempt to locate a control channel on which a neighboring base station <highlight><bold>10</bold></highlight> is transmitting control information. Upon locating such a control channel, the communication device <highlight><bold>12</bold></highlight> receives information transmitted on the control channel and uses the received information to determine whether the neighboring base station <highlight><bold>10</bold></highlight> is an acceptable candidate for handling a call handoff procedure for the communication device <highlight><bold>12</bold></highlight>. As will further be understood by one having ordinary skill in the art, a call handoff procedure typically occurs when the communication device <highlight><bold>12</bold></highlight> is traveling from a first cell <highlight><bold>14</bold></highlight> that is serviced by a first base station <highlight><bold>10</bold></highlight> to a second, neighboring cell <highlight><bold>14</bold></highlight> that is serviced by a second, neighboring base station <highlight><bold>10</bold></highlight>. Specifically, when traveling away from the first base station <highlight><bold>10</bold></highlight> and toward the neighboring base station <highlight><bold>10</bold></highlight>, the signal strength and quality of an on-going telephone call being transmitted by the first base station <highlight><bold>10</bold></highlight> to the communication device <highlight><bold>12</bold></highlight> may begin to degrade due to reduced communication signal power strength. When signal degradation occurs, the first base station <highlight><bold>10</bold></highlight> transfers, or hands off, the telephone call to the neighboring base station <highlight><bold>10</bold></highlight>. To prevent an interrupt in service during the call hand-off procedure, the communication device <highlight><bold>12</bold></highlight> uses the handoff time slot <highlight><bold>32</bold></highlight> to identify a neighboring base station <highlight><bold>10</bold></highlight> that is an acceptable candidate for receiving the telephone call during the hand-off procedure. A base station <highlight><bold>10</bold></highlight> generally qualifies as an acceptable candidate depending on whether the base station <highlight><bold>10</bold></highlight> is near enough to provide sufficient signal power to carry the call and further depending on the amount of communication traffic being carried by the candidate base station <highlight><bold>10</bold></highlight> at the time of call handoff. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> Referring now to <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, the communication device <highlight><bold>12</bold></highlight> may include a microprocessor <highlight><bold>34</bold></highlight>, that may implemented using, for example, a reduced instruction set microprocessor, and a digital signal processor (DSP) <highlight><bold>36</bold></highlight> both of which are coupled to and receive data from an interface managing unit <highlight><bold>38</bold></highlight>. The interface managing unit <highlight><bold>38</bold></highlight> is further coupled to a set of interface devices (not shown) by which a user may interface with the microprocessor <highlight><bold>34</bold></highlight> and the DSP <highlight><bold>36</bold></highlight> including, for example, a keypad, a liquid crystal display, a microphone and a speaker. The DSP <highlight><bold>36</bold></highlight> is further coupled to and controls a set of RF hardware devices <highlight><bold>40</bold></highlight> that may include, for example, a transmitter and a receiver, in addition to other conventional communication signal processing hardware devices, via a set of analog to digital and digital to analog converters <highlight><bold>42</bold></highlight>. The microprocessor <highlight><bold>34</bold></highlight> controls the tuning of the RF hardware devices <highlight><bold>40</bold></highlight> using a frequency synthesizer <highlight><bold>44</bold></highlight> that is coupled to the microprocessor <highlight><bold>34</bold></highlight> via a synthesizer interface <highlight><bold>46</bold></highlight>. Specifically, frequency data is supplied by the microprocessor <highlight><bold>34</bold></highlight> to the synthesizer interface <highlight><bold>46</bold></highlight>, which subsequently transfers the frequency data to the frequency synthesizer <highlight><bold>44</bold></highlight> for use in tuning the RF hardware devices <highlight><bold>40</bold></highlight> to one, or more of a set of frequency levels provided in the frequency data. The microprocessor <highlight><bold>34</bold></highlight> and DSP <highlight><bold>36</bold></highlight> are further programmed to execute a set of instructions disposed in a set of memory devices <highlight><bold>48</bold></highlight>, <highlight><bold>49</bold></highlight>, respectively, to allow the communication device <highlight><bold>12</bold></highlight> to perform any of a number of tasks including, for example, receiving/transmitting incoming and outgoing phone calls, and storing/retrieving frequently used telephone numbers. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> A system timer <highlight><bold>50</bold></highlight> is coupled to and adapted to provide timing critical control signals to the microprocessor <highlight><bold>34</bold></highlight>, the DSP <highlight><bold>36</bold></highlight>, the RF hardware devices <highlight><bold>40</bold></highlight> and the synthesizer interface <highlight><bold>46</bold></highlight>. Specifically, the system timer <highlight><bold>50</bold></highlight> is adapted to provide interrupt signals to the DSP <highlight><bold>36</bold></highlight> and/or the microprocessor <highlight><bold>34</bold></highlight> and is further adapted to provide control signals that cause the receiver and transmitter to be enabled/disabled at specific time slots during each frame <highlight><bold>26</bold></highlight>. The system timer <highlight><bold>50</bold></highlight> is further coupled to and provides a synchronization signal to the synthesizer interface <highlight><bold>46</bold></highlight>, as will be described in greater detail below, and includes a set of sixteen output pins <highlight><bold>47</bold></highlight> that may be used to control any desired set of devices (not shown). </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> Referring also to <cross-reference target="DRAWINGS">FIG. 5</cross-reference>, as is conventional, the architecture of the communication device <highlight><bold>12</bold></highlight> may be modeled using a set of layers <highlight><bold>52</bold></highlight>, <highlight><bold>54</bold></highlight>, <highlight><bold>56</bold></highlight>, <highlight><bold>58</bold></highlight> that are each responsible for performing a specific set of tasks. Although the number of layers in the architecture and the tasks performed by each are typically defined, at least in part, by the communication standard in use, for illustrative purposes, the architecture of the communication device <highlight><bold>12</bold></highlight> may be modeled as having four layers: a first layer referred to as an application layer <highlight><bold>52</bold></highlight>; a second layer disposed beneath the application layer and referred to as a network layer <highlight><bold>54</bold></highlight>; a third layer disposed beneath the network layer and referred to as a wireless hardware abstraction layer (WHAL) <highlight><bold>56</bold></highlight>; and a fourth, bottom layer referred to as a physical layer <highlight><bold>58</bold></highlight>. The application layer <highlight><bold>52</bold></highlight> represents any software instructions and hardware devices, such as the keypad and the microphone, that allow a user to interface with and operate the communication device <highlight><bold>12</bold></highlight>. For example, when the user enters a telephone number at the keypad, the application layer <highlight><bold>52</bold></highlight> is invoked. Likewise, when the user speaks into the microphone, the voice data received at the microphone is initially handled by the application layer <highlight><bold>52</bold></highlight> that converts the voice data to a format that is recognizable to the network layer <highlight><bold>54</bold></highlight>. The network layer <highlight><bold>54</bold></highlight> is driven by an apparatus referred to as a protocol engine that is implemented as a set of software instructions executed by the microprocessor <highlight><bold>34</bold></highlight> that allow the communication device <highlight><bold>12</bold></highlight> to use the proper protocol when communicating with the base station <highlight><bold>10</bold></highlight>. For example, the protocol engine may convert voice data received from the user into a protocol that is compatible with the protocol used by the base station <highlight><bold>10</bold></highlight> and that conforms to the communication standard in use. In addition, the protocol engine may interpret/convert protocol-formatted signals received from the base station <highlight><bold>10</bold></highlight> into signals that may be used by the application layer <highlight><bold>52</bold></highlight> or any of the other layers of the communication device <highlight><bold>12</bold></highlight>. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> As will be understood by one having ordinary skill in the art, the communication protocol used by the base station <highlight><bold>10</bold></highlight> and the communication device <highlight><bold>12</bold></highlight> is conventionally defined by the communication standard in use. The protocol may define a format for communication signals and may further define a standard set of procedures that control the manner in which the communication device <highlight><bold>12</bold></highlight> and the base station <highlight><bold>10</bold></highlight> communicate. For example, the protocol may define a registration procedure that allows the communication device <highlight><bold>12</bold></highlight> to register with the base station <highlight><bold>10</bold></highlight> upon entering the cell serviced by the base station <highlight><bold>10</bold></highlight>. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> The protocol engine of the network layer <highlight><bold>54</bold></highlight> invokes the WHAL <highlight><bold>56</bold></highlight> which may be implemented using a set of instructions executed by the microprocessor <highlight><bold>34</bold></highlight> that enable communication between the network layer <highlight><bold>54</bold></highlight> and the physical layer <highlight><bold>58</bold></highlight>. Specifically, the WHAL <highlight><bold>56</bold></highlight> translates a set of single statement instructions referred to as &ldquo;function calls&rdquo; provided by the protocol engine into a detailed and potentially complex set of instructions that may be used to direct the physical layer <highlight><bold>58</bold></highlight> to perform a specified set of tasks such as transmitting and receiving data. The physical layer <highlight><bold>58</bold></highlight> comprises a set of software instructions and hardware devices such as the DSP <highlight><bold>36</bold></highlight>, data converters <highlight><bold>42</bold></highlight> and RF hardware devices <highlight><bold>40</bold></highlight> that are directly responsible for transmitting the data to the base station <highlight><bold>10</bold></highlight> and for receiving data from the base station <highlight><bold>10</bold></highlight>. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> Referring now to <cross-reference target="DRAWINGS">FIG. 6</cross-reference>, the system timer <highlight><bold>50</bold></highlight> includes a programmable sequence generator (&ldquo;the sequencer&rdquo;) <highlight><bold>60</bold></highlight> adapted to execute a set of instructions disposed in a random access memory (&ldquo;sequencer RAM&rdquo;) <highlight><bold>62</bold></highlight> to thereby enable the generation of a set of control signals for controlling a set of counters <highlight><bold>64</bold></highlight>, <highlight><bold>66</bold></highlight>, and the RF hardware devices <highlight><bold>40</bold></highlight>, and to enable the generation of a set of interrupt signals that interrupt the operation of the microprocessor <highlight><bold>34</bold></highlight> and the DSP <highlight><bold>36</bold></highlight>. The system timer is further adapted to generate a pulse signal that is supplied to the synthesizer interface <highlight><bold>46</bold></highlight> for controlling the rate at which frequency information is supplied by the microprocessor <highlight><bold>34</bold></highlight> to the frequency synthesizer <highlight><bold>44</bold></highlight>. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> The set of counters <highlight><bold>64</bold></highlight>, <highlight><bold>66</bold></highlight> controlled by the sequencer <highlight><bold>60</bold></highlight> may include, for example, a fifteen bit timebase counter <highlight><bold>64</bold></highlight> adapted to increment at a speed equal to a fraction of the symbol rate. Specifically, the timebase counter <highlight><bold>64</bold></highlight> is configurable to increment at a rate equal to {fraction (1/32)}, {fraction (1/16)}, &frac18; or &frac14; of the symbol rate when used in a TIA-EIA-136 communication system having a system clock rate operating at 19.44 MHz. Further the timebase counter <highlight><bold>64</bold></highlight> is configurable to increment at a rate equal to {fraction (1/16)}, &frac18;, &frac14; or &frac12; of the symbol rate when used in a TIA-EIA-136 communication system having a system clock <highlight><bold>24</bold></highlight> operating at 9.72 MHz and in a GSM communication system having a system clock <highlight><bold>24</bold></highlight> operating at 13 MHz. The timebase counter <highlight><bold>64</bold></highlight> is further adapted to reset or wrap to zero when a nominal period of time has expired. More particularly, a value equal to the nominal period of time is stored in a timebase counter length register <highlight><bold>68</bold></highlight> such that whenever the timebase counter <highlight><bold>64</bold></highlight> increments to a value equal to the value stored in the timebase counter length register <highlight><bold>68</bold></highlight>, the timebase counter <highlight><bold>64</bold></highlight> is reset or wraps to zero. The nominal period of time which may be, for example, 20 ms for a TIA-EIA-136 communication system and 4.615 ms for a GSM communication system, is typically equal to the amount of time required for the base station <highlight><bold>10</bold></highlight> to transmit a frame <highlight><bold>26</bold></highlight> of symbols. As will be understood by one having ordinary skill in the art, a &ldquo;frame&rdquo; is a term of art that generally refers to a discrete portion of a communication signal that may comprise, for example, a predefined number of symbols. Further, the term &ldquo;frame&rdquo; is a term of art that is typically defined according to a communication standard and thus the definition of the term may vary depending on the standard in use. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> In addition, the system timer <highlight><bold>50</bold></highlight> may further include a timebase adjust register <highlight><bold>70</bold></highlight> that may be used to synchronize the communication device <highlight><bold>12</bold></highlight> with the base station <highlight><bold>10</bold></highlight>. Specifically, the base station <highlight><bold>10</bold></highlight> determines an amount of time by which the timing of the communication device <highlight><bold>12</bold></highlight> is offset from the timing of the base station <highlight><bold>10</bold></highlight>. The base station <highlight><bold>10</bold></highlight> then transmits this calculated offset to the communication device <highlight><bold>12</bold></highlight>. The microprocessor <highlight><bold>34</bold></highlight> causes a value equal to the nominal time period plus the offset value to be stored in a timebase adjust register <highlight><bold>70</bold></highlight>. The timebase counter <highlight><bold>64</bold></highlight> then uses the value stored in the timebase adjust register <highlight><bold>70</bold></highlight> as the wrap point for the next data frame <highlight><bold>26</bold></highlight> received at the communication device <highlight><bold>12</bold></highlight> causing the period of the timebase counter <highlight><bold>64</bold></highlight> to be extended or shortened by an amount of time equal to the offset. After the shortened/lengthened frame <highlight><bold>26</bold></highlight>, the timebase counter <highlight><bold>64</bold></highlight> returns to wrapping to zero at the nominal time period stored in the timebase counter length register <highlight><bold>68</bold></highlight>. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> The counters <highlight><bold>64</bold></highlight>, <highlight><bold>66</bold></highlight> may also include an eleven bit frame counter <highlight><bold>66</bold></highlight> adapted to increment each time the timebase counter <highlight><bold>64</bold></highlight> overflows so that the frame counter operates at the frame rate. The frame counter <highlight><bold>66</bold></highlight> is further adapted to reset or wrap to zero when a number of frames <highlight><bold>26</bold></highlight> equal to a number stored in a frame counter length register <highlight><bold>72</bold></highlight> have been counted. A timing adjust register <highlight><bold>74</bold></highlight> may further be included in the system timer <highlight><bold>50</bold></highlight> for storing timing adjustment values by which the timebase counter <highlight><bold>64</bold></highlight> may be adjusted. Specifically, the timing adjust register <highlight><bold>74</bold></highlight> may include a value by which the value stored in the timebase counter <highlight><bold>64</bold></highlight> is either incremented or decremented. Adjusting the operation of the timebase counter <highlight><bold>64</bold></highlight> using the timebase adjust <highlight><bold>70</bold></highlight> and timing adjust registers <highlight><bold>74</bold></highlight> will be described in greater detail below. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> Referring also to <cross-reference target="DRAWINGS">FIG. 7</cross-reference>, the sequencer <highlight><bold>60</bold></highlight> is adapted to execute the instructions stored in the sequencer RAM <highlight><bold>62</bold></highlight> according to the status of a set of control bits residing in a control register <highlight><bold>76</bold></highlight>. Specifically, the control register <highlight><bold>76</bold></highlight> may include a set of bits that may be set by the microprocessor <highlight><bold>34</bold></highlight> to cause the sequencer <highlight><bold>60</bold></highlight> to operate in a particular manner. For example, the control register <highlight><bold>76</bold></highlight> may include a set of &ldquo;RESET&rdquo; bits <highlight><bold>78</bold></highlight> that allow the microprocessor <highlight><bold>34</bold></highlight> to reset one or more of a sequence program counter <highlight><bold>80</bold></highlight> (see <cross-reference target="DRAWINGS">FIG. 6</cross-reference>), the frame counter <highlight><bold>66</bold></highlight> and/or the timebase counter <highlight><bold>64</bold></highlight>. For example, if the RESET bits <highlight><bold>78</bold></highlight> are set to a first value of &ldquo;000&rdquo; then the sequencer <highlight><bold>60</bold></highlight> may take no action with respect to resetting any of counters <highlight><bold>64</bold></highlight>, <highlight><bold>66</bold></highlight> and <highlight><bold>80</bold></highlight>. If instead the RESET bits <highlight><bold>78</bold></highlight> are set to a second value of &ldquo;001,&rdquo; then the sequencer <highlight><bold>60</bold></highlight> may cause the sequence program counter <highlight><bold>80</bold></highlight> to be set to a value equal to the last value stored in a command register <highlight><bold>82</bold></highlight>. The command register <highlight><bold>82</bold></highlight> comprises a memory register in which addresses may be stored by the microprocessor <highlight><bold>34</bold></highlight> and the sequence program counter <highlight><bold>80</bold></highlight> is adapted to contain the address of the instruction currently being executed by the sequencer <highlight><bold>60</bold></highlight>. Thus, moving an address from the command register <highlight><bold>82</bold></highlight> to the sequence program counter <highlight><bold>80</bold></highlight> causes the sequencer <highlight><bold>60</bold></highlight> to jump to and execute the instruction located at that address. As a result, the RESET bits <highlight><bold>78</bold></highlight> may be used to alter the sequence of instructions executed by the sequencer <highlight><bold>60</bold></highlight>. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> Alternatively, the RESET bits <highlight><bold>78</bold></highlight> may be set to a third value of &ldquo;010&rdquo; causing the sequence program counter <highlight><bold>80</bold></highlight> to be set to the starting address sequencer <highlight><bold>60</bold></highlight> instruction set stored in the RAM <highlight><bold>62</bold></highlight>. In addition, the RESET bits <highlight><bold>78</bold></highlight> may be set to a value of &ldquo;100&rdquo; and &ldquo;101,&rdquo; to reset or clear the timebase counter <highlight><bold>64</bold></highlight> or the frame counter <highlight><bold>66</bold></highlight>, respectively. The action performed by the sequencer <highlight><bold>60</bold></highlight> upon setting the RESET bits <highlight><bold>78</bold></highlight> to one or more other values, such as &ldquo;011,&rdquo; &ldquo;110&rdquo; and &ldquo;111,&rdquo; may be defined in any of a number of ways as necessary to enhance the functionality of the system timer <highlight><bold>50</bold></highlight> and support the needs of the user of the mobile communication device <highlight><bold>12</bold></highlight>. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> A set of &ldquo;INTSEL&rdquo; bits <highlight><bold>84</bold></highlight> that are used to define a set of conditions that will cause the sequencer <highlight><bold>60</bold></highlight> to interrupt the microprocessor <highlight><bold>34</bold></highlight> may further be included in the control register <highlight><bold>76</bold></highlight>. Specifically, if the INTSEL bits <highlight><bold>84</bold></highlight> are set to &ldquo;00,&rdquo; then no interrupt signal is generated. Alternatively, if the INTSEL bits <highlight><bold>84</bold></highlight> are set to &ldquo;01,&rdquo; then the sequencer <highlight><bold>60</bold></highlight> interrupts the microprocessor <highlight><bold>34</bold></highlight> when the timebase counter <highlight><bold>64</bold></highlight> overflows and, if the INTSEL bits <highlight><bold>84</bold></highlight> are set to &ldquo;10,&rdquo; then the sequencer <highlight><bold>60</bold></highlight> interrupts the microprocessor <highlight><bold>34</bold></highlight> when the frame counter <highlight><bold>66</bold></highlight> overflows. If the INTSEL bits <highlight><bold>84</bold></highlight> are set to &ldquo;11,&rdquo; then the sequencer <highlight><bold>60</bold></highlight> interrupts the microprocessor <highlight><bold>34</bold></highlight> when either the timebase counter <highlight><bold>64</bold></highlight> or the frame counter <highlight><bold>66</bold></highlight> overflows. As will be understood by one having ordinary skill in the art, an interrupt signal is typically supplied to the microprocessor <highlight><bold>34</bold></highlight> to inform the microprocessor <highlight><bold>34</bold></highlight> than an event has occurred upon which further action by the microprocessor <highlight><bold>34</bold></highlight> is contingent. For example, it may be desirable to retune the frequency synthesizer <highlight><bold>44</bold></highlight> to a new frequency after a predetermined number of frames <highlight><bold>26</bold></highlight> have been counted so that the communication device <highlight><bold>12</bold></highlight> may begin transmitting instead of receiving data. To inform the microprocessor <highlight><bold>34</bold></highlight> as to when the predetermined number of frames <highlight><bold>26</bold></highlight> have been counted, the system timer <highlight><bold>50</bold></highlight> may interrupt the microprocessor <highlight><bold>34</bold></highlight> in response to a frame counter <highlight><bold>66</bold></highlight> overflow condition. Unlike interrupt signals that are generated in response to the occurrence of a predefined condition, such as a frame counter or timebase counter overflow, interrupt signals that are generated by the sequencer <highlight><bold>60</bold></highlight> in response to a software instruction are always enabled so that a specific set of control register bits are not reserved for enabling an interrupt of this type. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> Referring still to <cross-reference target="DRAWINGS">FIG. 7</cross-reference>, the control register <highlight><bold>76</bold></highlight> may also include a &ldquo;countrun&rdquo; bit <highlight><bold>86</bold></highlight> that controls the operational state of one or both of the timebase and frame counters <highlight><bold>64</bold></highlight>, <highlight><bold>66</bold></highlight> and a &ldquo;seqrun&rdquo; bit <highlight><bold>88</bold></highlight> that controls the operational state of the sequencer <highlight><bold>60</bold></highlight>. For example, when the countrun bit <highlight><bold>86</bold></highlight> is high, the timebase and frame counters <highlight><bold>64</bold></highlight>, <highlight><bold>66</bold></highlight> may be enabled, i.e., may count, and when the countrun bit <highlight><bold>86</bold></highlight> is low, the timebase and frame counters <highlight><bold>64</bold></highlight>, <highlight><bold>66</bold></highlight> may be disabled and hold their current values. Similarly, when the seqrun bit <highlight><bold>88</bold></highlight> is high, the sequencer <highlight><bold>60</bold></highlight> executes instructions and when the seqrun bit <highlight><bold>88</bold></highlight> is low, the sequencer <highlight><bold>60</bold></highlight> stops executing instructions, i.e., halts. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> The control register <highlight><bold>76</bold></highlight> may farther include a set of &ldquo;CLKDIV&rdquo; bits <highlight><bold>90</bold></highlight> and a &ldquo;predivide&rdquo; bit <highlight><bold>92</bold></highlight> that affect the manner in which a system clock signal is divided. Specifically, the predivide bit <highlight><bold>92</bold></highlight> dictates whether the system clock signal shall be divided by either twenty five (25) or by six (6). More particularly, the system clock signal, which is generated by a clock device (not shown) disposed in the communication device <highlight><bold>12</bold></highlight> and which is supplied to the sequencer <highlight><bold>60</bold></highlight>, the sequencer RAM <highlight><bold>62</bold></highlight> and to a clock rate control unit <highlight><bold>94</bold></highlight>, operates at the same frequency as the base station <highlight><bold>10</bold></highlight>, i.e., 13 MHz in a GSM communication system and 19.44 MHz in an TIA-EIA-136 communication system. The system clock signal is thereafter divided at the clock rate control unit <highlight><bold>94</bold></highlight> by either 25 or 6, depending on whether the predivide bit <highlight><bold>92</bold></highlight> is set to a zero or a one, respectively, so that the communication device <highlight><bold>12</bold></highlight> may synchronize to the base station <highlight><bold>10</bold></highlight> within a resolution of &frac18;th of a symbol (eight counts per symbol) or within a resolution of {fraction (1/24)}th of a symbol (wherein exactly three (3) sequencer instructions are executed for each count of the timebase counter <highlight><bold>64</bold></highlight>) when operating in the GSM mode. Specifically, the TIA-EIA-136 signal frequency of 19.44 MHz is divided by 25 to obtain a resolution of &frac18;th symbol and the GSM signal frequency of 13 MHz is divided by 6 to obtain a resolution of &frac18;th symbol. In addition, the clkdiv bits <highlight><bold>90</bold></highlight> may dictate whether the system clock signal is further divided by either one (1), two (2), four (4) or eight (8). Thus, the clock rate control unit <highlight><bold>94</bold></highlight> divides the incoming clock signal according to the settings of the clkdiv and predivide bits <highlight><bold>90</bold></highlight>, <highlight><bold>92</bold></highlight> stored in the control register <highlight><bold>76</bold></highlight>. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> The control register <highlight><bold>76</bold></highlight> may additionally include a set of MODE bits <highlight><bold>96</bold></highlight>, denoted A&prime;, B&prime;, C&prime;, and D&prime;, that may be used to control whether the sequencer <highlight><bold>60</bold></highlight> will branch to a first address located in the sequencer RAM <highlight><bold>62</bold></highlight> or whether the sequencer <highlight><bold>60</bold></highlight> will instead branch to a second address located in the sequencer RAM <highlight><bold>62</bold></highlight>. Further, a set of bits <highlight><bold>98</bold></highlight> may be included in the control register <highlight><bold>76</bold></highlight> and used for any desired purpose as necessary to enhance the functionality of the system timer <highlight><bold>50</bold></highlight>. As will be appreciated by one having ordinary skill in the art, the microprocessor <highlight><bold>34</bold></highlight> may set the bits <highlight><bold>78</bold></highlight>, <highlight><bold>84</bold></highlight>, <highlight><bold>86</bold></highlight>, <highlight><bold>88</bold></highlight>, <highlight><bold>90</bold></highlight>, <highlight><bold>92</bold></highlight>, <highlight><bold>96</bold></highlight> and <highlight><bold>98</bold></highlight> residing in the control register <highlight><bold>76</bold></highlight> upon, for example, powering up the communication device <highlight><bold>12</bold></highlight> or when the communication device <highlight><bold>12</bold></highlight> changes operating frequency from a first frequency level, e.g., 30 kHz channel, to a second frequency level, e.g., 200 kHz channel. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> Upon power up or when changing operating frequencies, the microprocessor <highlight><bold>34</bold></highlight> may also be programmed to initialize one or more of the counters <highlight><bold>64</bold></highlight>, <highlight><bold>66</bold></highlight>, <highlight><bold>80</bold></highlight>, one or more of the registers <highlight><bold>68</bold></highlight>, <highlight><bold>72</bold></highlight>, <highlight><bold>100</bold></highlight> and the sequencer RAM <highlight><bold>62</bold></highlight>. Specifically, the timebase counter length register <highlight><bold>68</bold></highlight> may be set to a predetermined value such as, for example, 3888 counts/frame for TIA-EIA-136 and 10000 counts/frame for GSM, and the frame counter length register <highlight><bold>72</bold></highlight> may be set to any value depending upon the application in which the system timer <highlight><bold>50</bold></highlight> is to be used. The programs to be executed by the sequencer <highlight><bold>60</bold></highlight> may also be copied from the memory device <highlight><bold>48</bold></highlight> associated with the microprocessor <highlight><bold>34</bold></highlight> to the sequencer RAM <highlight><bold>62</bold></highlight>. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> Referring now to <cross-reference target="DRAWINGS">FIG. 8</cross-reference>, in addition to the control register <highlight><bold>76</bold></highlight>, the system timer <highlight><bold>50</bold></highlight> may also include a microprocessor interrupt status register <highlight><bold>100</bold></highlight> containing a set of bits that indicate which of a set of conditions caused the system timer <highlight><bold>50</bold></highlight> to interrupt the microprocessor <highlight><bold>34</bold></highlight>. For example, the microprocessor interrupt status register <highlight><bold>100</bold></highlight> may include an &ldquo;IS_TBCOUNT&rdquo; bit <highlight><bold>102</bold></highlight> that is set when the system timer <highlight><bold>50</bold></highlight> interrupts the microprocessor <highlight><bold>34</bold></highlight> because of a timebase counter <highlight><bold>64</bold></highlight> overflow condition and may further include an &ldquo;IS_FRCOUNT&rdquo; bit <highlight><bold>104</bold></highlight> that is set when the system timer <highlight><bold>50</bold></highlight> interrupts the microprocessor <highlight><bold>34</bold></highlight> because of a frame counter <highlight><bold>66</bold></highlight> overflow condition. In addition, an &ldquo;IS_SEQ&rdquo; bit <highlight><bold>106</bold></highlight> may be set when the system timer <highlight><bold>50</bold></highlight> interrupts the microprocessor <highlight><bold>34</bold></highlight> as a result of a software instruction, referred to as an ARMINT instruction, that causes the system timer <highlight><bold>50</bold></highlight> to interrupt the microprocessor <highlight><bold>34</bold></highlight>. A set of &ldquo;IS_SEQTYPE&rdquo; bits <highlight><bold>108</bold></highlight> may also be set to indicate the type of interrupt that was generated as a result of the ARMINT software instruction. Specifically, the IS_SEQTYPE bits <highlight><bold>108</bold></highlight> may be set by the sequencer <highlight><bold>60</bold></highlight> using type information contained in a type field included in the ARMINT instruction. An additional set of bits <highlight><bold>110</bold></highlight> may further be included in the microprocessor interrupt status register <highlight><bold>100</bold></highlight> and may be defined to indicate that any desired type of microprocessor interrupt signal has been generated as needed to enhance the functionality of the system timer and to support the needs of the user of the communication device <highlight><bold>12</bold></highlight>. After an interrupt signal has been received by the microprocessor <highlight><bold>34</bold></highlight>, the microprocessor <highlight><bold>34</bold></highlight> reads the information contained in the interrupt status bit register <highlight><bold>100</bold></highlight> to determine the cause of the interrupt so that an appropriate action may be taken and then causes the contents of the register <highlight><bold>100</bold></highlight> to clear. Of course, if an event occurs that may potentially cause an interrupt but that-is not enabled via the INTSEL bits <highlight><bold>84</bold></highlight> disposed in the control register <highlight><bold>76</bold></highlight>, then the interrupt signal will not be generated and, likewise, the interrupt status bits associated with the cause of the interrupt signal will not be set. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> Referring also to <cross-reference target="DRAWINGS">FIGS. 6 and 9</cross-reference>, the order in which the instructions stored in the sequencer RAM <highlight><bold>62</bold></highlight> are executed by the sequencer <highlight><bold>60</bold></highlight> depends, at least in part, upon whether a &ldquo;JCMD&rdquo; instruction <highlight><bold>112</bold></highlight>, formatted as &ldquo;JCMD aaaa aaaa,&rdquo; has been encountered by the sequencer <highlight><bold>60</bold></highlight> and upon whether the command register <highlight><bold>82</bold></highlight> is empty when the JCMD instruction <highlight><bold>112</bold></highlight> is executed. More particularly, the sequencer <highlight><bold>60</bold></highlight> executes the instructions located at a set of specified addresses in the sequencer RAM <highlight><bold>62</bold></highlight> in the order that the instructions are arranged in the sequencer RAM <highlight><bold>62</bold></highlight>, until a JCMD instruction <highlight><bold>112</bold></highlight> is encountered. When a JCMD instruction <highlight><bold>112</bold></highlight> is encountered, the sequencer <highlight><bold>60</bold></highlight> examines the contents of the command register <highlight><bold>82</bold></highlight> to determine whether the command register <highlight><bold>82</bold></highlight> is empty. If the command register <highlight><bold>82</bold></highlight> is empty, the sequencer <highlight><bold>60</bold></highlight> jumps to and executes the instruction located at an address specified in the address field, &ldquo;aaaa aaaa,&rdquo; of the JCMD instruction <highlight><bold>112</bold></highlight>. After executing the instruction located at the specified address, the sequencer <highlight><bold>60</bold></highlight> returns to executing the instructions in the order in which they are arranged by executing the instruction located at the next consecutive address in the sequencer RAM <highlight><bold>62</bold></highlight>. If the command register <highlight><bold>82</bold></highlight> is not empty when the JCMD instruction <highlight><bold>112</bold></highlight> is executed, the sequencer <highlight><bold>60</bold></highlight> jumps to and executes the instruction located at the sequencer RAM address that is stored in the command register <highlight><bold>82</bold></highlight>. The sequencer <highlight><bold>60</bold></highlight> then executes the instruction stored in the next, consecutive sequencer RAM <highlight><bold>62</bold></highlight> address and continues in this fashion until a JCMD instruction <highlight><bold>112</bold></highlight> is again encountered. The addresses stored in the command register <highlight><bold>82</bold></highlight> are extracted by the sequencer <highlight><bold>60</bold></highlight> in a first-in/first-out manner wherein the first address stored in the command register <highlight><bold>82</bold></highlight> is the first address to be extracted by the sequencer <highlight><bold>60</bold></highlight> when a JCMD instruction <highlight><bold>112</bold></highlight> is encountered and for each additional JCMD instruction <highlight><bold>112</bold></highlight> executed, the sequencer <highlight><bold>60</bold></highlight> continues to extract addresses according to the order in which the addresses were written to the command register <highlight><bold>82</bold></highlight>. Thus, the order in which instructions are executed by the sequencer <highlight><bold>60</bold></highlight> is not limited to the order in which the instructions are stored in the sequencer RAM <highlight><bold>62</bold></highlight> but may instead be altered by the microprocessor <highlight><bold>34</bold></highlight>. To eliminate the need to frequently update the command register <highlight><bold>82</bold></highlight> during each frame <highlight><bold>26</bold></highlight>, the microprocessor <highlight><bold>34</bold></highlight> may cause a set of addresses to be stored in the command register <highlight><bold>82</bold></highlight> once before each frame <highlight><bold>26</bold></highlight>. </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> Referring still to <cross-reference target="DRAWINGS">FIGS. 6 and 9</cross-reference>, in addition to the JCMD instruction <highlight><bold>112</bold></highlight> described above, the sequencer RAM <highlight><bold>62</bold></highlight> may be used to store any number of instructions, including instructions that cause the sequencer <highlight><bold>60</bold></highlight> to conditionally jump to a specified address in the sequencer RAM <highlight><bold>62</bold></highlight>, instructions that cause the sequencer <highlight><bold>60</bold></highlight> to set or clear specific system timer <highlight><bold>50</bold></highlight> outputs, instructions that cause the sequencer <highlight><bold>60</bold></highlight> to supply an interrupt signal to either the microprocessor <highlight><bold>34</bold></highlight> or the DSP <highlight><bold>36</bold></highlight>, and instructions that cause the sequencer <highlight><bold>60</bold></highlight> to generate control signals for controlling the synthesizer interface <highlight><bold>46</bold></highlight> and the RF hardware devices <highlight><bold>40</bold></highlight>. Moreover, the instructions may cause the sequencer <highlight><bold>60</bold></highlight> to perform the above-listed tasks in any number of ways. For example, the instructions that cause the sequencer <highlight><bold>60</bold></highlight> to jump to a new address in the sequencer RAM <highlight><bold>62</bold></highlight> may cause the sequencer <highlight><bold>60</bold></highlight> to jump conditionally or unconditionally. Specifically, a conditional &ldquo;JMP&rdquo; instruction <highlight><bold>114</bold></highlight> may be formatted as &ldquo;JMP ABCD aaaa aaaa&rdquo; and may cause the sequencer <highlight><bold>60</bold></highlight> to jump to an address specified in the address field &ldquo;aaaa aaaa&rdquo; of the JMP instruction <highlight><bold>114</bold></highlight>, if the result of an equation is zero. The equation used to determine whether a jump shall occur may depend upon the values of the MODE bits A&prime;, B&prime;, C&prime; and D&prime; stored in the control register <highlight><bold>76</bold></highlight> and a set of bits A, B, C and D having values that are supplied in the &ldquo;ABCD&rdquo; field of the JMP instruction <highlight><bold>114</bold></highlight>, and may further depend upon the value of a bit denoted, TX_ENA, as follows:</paragraph>
<paragraph lvl="0"><in-line-formula>RESULT&equals;<highlight><italic>A&Circlesolid;A&prime;&plus;B&Circlesolid;B&prime;&plus;C&Circlesolid;C&prime;&plus;D&Circlesolid;D&prime;&Circlesolid;</italic></highlight>TX_ENA</in-line-formula></paragraph>
<paragraph id="P-0058" lvl="7"><number>&lsqb;0058&rsqb;</number> The TX_ENA bit is set by the DSP <highlight><bold>36</bold></highlight> when data is available at the physical layer for transmission to the base station <highlight><bold>10</bold></highlight> and may be stored, for example, in an interface register <highlight><bold>116</bold></highlight> that operates as a shared memory interface between the microprocessor <highlight><bold>34</bold></highlight>, the DSP <highlight><bold>36</bold></highlight> and the system timer <highlight><bold>50</bold></highlight>. The interface register <highlight><bold>116</bold></highlight> may be implemented via a memory location that is readable by the microprocessor <highlight><bold>34</bold></highlight>, the system timer <highlight><bold>50</bold></highlight> and the DSP <highlight><bold>36</bold></highlight> and that may be written to by the microprocessor <highlight><bold>34</bold></highlight> and the DSP <highlight><bold>36</bold></highlight>. The JMP instruction <highlight><bold>114</bold></highlight> may be used, for example, to cause the sequencer <highlight><bold>60</bold></highlight> to continue to loop through a set of instructions beginning at the address specified in the address field of the JMP instruction <highlight><bold>114</bold></highlight> and ending at the address where the JMP instruction <highlight><bold>114</bold></highlight> is located until a desired condition has been met. To use the JMP instruction <highlight><bold>114</bold></highlight> in this manner, the bits A, B. C and D may be set to a logic level high in the &ldquo;ABCD&rdquo; field of the JMP instruction <highlight><bold>114</bold></highlight> and the bits A&prime;, B&prime;, C&prime; and D&prime; may all be set to a logic level zero until a desired condition has been met at which time one or more of the MODE bits, A&prime;, B&prime;, C&prime; and/or D&prime;, is set to a logic level high. Thus, when the bits in the &ldquo;ABCD&rdquo; field of the JMP instruction <highlight><bold>114</bold></highlight> are set to a logic level high and the MODE bits, A&prime;, B&prime;, C&prime; and D,&prime; are set to a logic level low, &ldquo;RESULT&rdquo; is a logic level low causing the sequencer <highlight><bold>60</bold></highlight> to jump to the address provided in the address field of the JMP instruction <highlight><bold>114</bold></highlight>. The RESULT will remain at a logic level low until one or more of the mode bits A&prime;, B&prime;, C&prime; are set to a logic level high and/or until the bits D&prime; and TX_ENA are set to a logic level high at which time the JMP instruction <highlight><bold>114</bold></highlight> will cause the sequencer <highlight><bold>60</bold></highlight> to execute an instruction that immediately follows the JMP instruction <highlight><bold>114</bold></highlight>. Thus, the JMP instruction <highlight><bold>114</bold></highlight> may cause the sequencer <highlight><bold>60</bold></highlight> to continuously execute or loop through the same set of instructions until a desired condition has been met. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> By way of further example, the JMP instruction <highlight><bold>114</bold></highlight> may also be used to control whether a set of instructions that enable data transmission by the communication device <highlight><bold>12</bold></highlight> are executed within a given frame. Specifically, the TX_ENA and the D&prime; bits may be set to a logic level low when data is not available for transmission because, for example, the user of the communication device <highlight><bold>12</bold></highlight> is not speaking during a telephone call. Setting the TX_ENA and D&prime; bits to a logic level low causes RESULT to be equal to a logic level low (provided of course that the MODE bits A&prime;, B&prime;and C&prime; are set to a logic level low) causing the sequencer <highlight><bold>60</bold></highlight> to skip a set of instructions that are located after the JMP instruction <highlight><bold>114</bold></highlight> and to instead jump back to the set of instructions that begin at the address specified in the address field of the JMP instruction <highlight><bold>114</bold></highlight>. In contrast, when the TX_ENA and D&prime; bits are set to a logic level high, the sequencer <highlight><bold>60</bold></highlight> will not jump back to the address specified in the address field of the JMP instruction <highlight><bold>114</bold></highlight> but will instead execute the set of instructions that are located after the JMP instruction <highlight><bold>114</bold></highlight>. Thus, provided that the instructions located after the JMP instruction <highlight><bold>114</bold></highlight> enable the transmitter and data transmission, the JMP instruction <highlight><bold>114</bold></highlight> may be used to control whether the transmitter and data transmission are enabled. As will be appreciated by one having ordinary skill in the art, the transmitter typically represents a large load on a power supply (not shown) used to energize the communication device <highlight><bold>12</bold></highlight> such that skipping the set of instructions that enable the transmitter, when possible, may result in significant battery power conservation. </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> Referring still to <cross-reference target="DRAWINGS">FIGS. 6 and 9</cross-reference>, the instructions stored in the sequencer RAM <highlight><bold>62</bold></highlight> may further include instructions that cause the sequencer <highlight><bold>60</bold></highlight> to set a group of system timer outputs denoted, SYSTIMERm, SYSTIMERk and SYSTIMERj, equal to either a logic level one or a logic level zero. Specifically, a &ldquo;SET&rdquo; instruction <highlight><bold>117</bold></highlight> formatted as &ldquo;SET mmmm, kkkk, jjjj&rdquo; may cause the sequencer <highlight><bold>60</bold></highlight> to set the SYSTIMERm, SYSTIMERk and SYSTIMERj outputs to a logic level high. Further, a &ldquo;CLR&rdquo; instruction <highlight><bold>118</bold></highlight>, formatted as &ldquo;CLR mmmm, kkkk, jjjj,&rdquo; may cause the sequencer <highlight><bold>60</bold></highlight> to set the SYSTIMERj, SYSTIMERk and SYSTIMERm outputs to a logic level zero. Alternatively, the SET and CLR instructions <highlight><bold>117</bold></highlight>, <highlight><bold>118</bold></highlight> may instead be used to set a single one of the system timer outputs to a logic level one or logic level zero, respectively, by setting the values in the mmmm, kkkk, jjjj fields in the instructions <highlight><bold>117</bold></highlight>, <highlight><bold>118</bold></highlight> equal to each other. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> A &ldquo;DSPINT&rdquo; instruction <highlight><bold>120</bold></highlight> and an &ldquo;ARMINT&rdquo; instruction <highlight><bold>122</bold></highlight> formatted &ldquo;DSPINT tttt&rdquo; and &ldquo;ARMINT tttt,&rdquo; respectively, may cause the sequencer <highlight><bold>60</bold></highlight> to supply an interrupt signal to the DSP <highlight><bold>36</bold></highlight> and to the microprocessor <highlight><bold>34</bold></highlight>, respectively. The sequencer <highlight><bold>60</bold></highlight> may supply any of several different types of interrupt signals to the DSP <highlight><bold>36</bold></highlight> wherein the type of the interrupt signal is specified in the type field, &ldquo;tttt,&rdquo; of the DSPINT instruction <highlight><bold>120</bold></highlight> and is further supplied by the sequencer <highlight><bold>60</bold></highlight> to the DSP <highlight><bold>36</bold></highlight> on a set of three output pins <highlight><bold>124</bold></highlight>, denoted DSP_INT_TYPE, that are coupled between the system timer <highlight><bold>50</bold></highlight> and the DSP <highlight><bold>36</bold></highlight>. Thus, the sequencer <highlight><bold>60</bold></highlight> sets the DSP_INT_TYPE output pins <highlight><bold>124</bold></highlight> according to the type of interrupt generated so that the DSP <highlight><bold>36</bold></highlight> may respond to the interrupt appropriately. In addition, the sequencer <highlight><bold>60</bold></highlight> may supply any of several different types of interrupt signals to the microprocessor <highlight><bold>34</bold></highlight>. The sequencer <highlight><bold>60</bold></highlight> indicates the type of interrupt signal, which is dictated by the type field &ldquo;tttt tttt,&rdquo; of the ARMINT instruction <highlight><bold>122</bold></highlight>, by setting the IS_SEQTYPE bits in the microprocessor interrupt status register <highlight><bold>100</bold></highlight>. Upon receiving an interrupt signal, the microprocessor <highlight><bold>34</bold></highlight> reads the IS_SEQTYPE bits in the interrupt status register <highlight><bold>100</bold></highlight> and then clears the interrupt status register <highlight><bold>100</bold></highlight>. </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> The sequencer RAM <highlight><bold>62</bold></highlight> may also be used to store a &ldquo;SYNSEND&rdquo; instruction <highlight><bold>126</bold></highlight> that causes the sequencer <highlight><bold>60</bold></highlight> to provide a pulse signal to the synthesizer interface <highlight><bold>46</bold></highlight> which is used to tune the receiver and transmitter associated with the RF hardware devices <highlight><bold>40</bold></highlight> to an appropriate frequency. The microprocessor <highlight><bold>34</bold></highlight> supplies a set of data words that may define, for example, the appropriate frequency(ies) to which the RF hardware devices <highlight><bold>40</bold></highlight> shall be tuned, to the synthesizer interface <highlight><bold>44</bold></highlight> which, in turn, supplies the data words to the frequency synthesizer <highlight><bold>44</bold></highlight>. The synthesizer interface <highlight><bold>46</bold></highlight> may operate in either of two modes, both of which affect the manner in which the synthesizer interface <highlight><bold>46</bold></highlight> supplies the data words to the frequency synthesizer <highlight><bold>44</bold></highlight>. Specifically, in an immediate mode, the microprocessor <highlight><bold>34</bold></highlight> writes a data word to a register <highlight><bold>128</bold></highlight> disposed in the synthesizer interface <highlight><bold>46</bold></highlight> referred to as the synthesizer interface immediate register (IMMD) <highlight><bold>128</bold></highlight> and the synthesizer interface <highlight><bold>46</bold></highlight> responds by immediately sending the data word, which may comprise, for example, one (1) to eighty (80) bits, at a rate of one bit per clock count to the frequency synthesizer <highlight><bold>44</bold></highlight>. In a timed mode, the microprocessor <highlight><bold>34</bold></highlight> queues up words to be sent to the frequency synthesizer <highlight><bold>44</bold></highlight> by writing the data words into a set of nine registers (not shown) that are disposed in the synthesizer interface <highlight><bold>46</bold></highlight>. The system timer <highlight><bold>50</bold></highlight> then acts as a timing agent to control when the synthesizer interface <highlight><bold>46</bold></highlight> actually sends the data. Specifically, each time a &ldquo;SYNSEND&rdquo; instruction <highlight><bold>126</bold></highlight> is encountered by the sequencer <highlight><bold>60</bold></highlight>, the sequencer <highlight><bold>60</bold></highlight> sends a pulse signal to the synthesizer interface <highlight><bold>46</bold></highlight> to command it to send out a one (1) to eighty (80) bit word to the frequency synthesizer <highlight><bold>44</bold></highlight>. A timed mode bit (not shown) disposed in the synthesizer interface <highlight><bold>46</bold></highlight> determines whether a single pulse signal received from the sequencer <highlight><bold>60</bold></highlight> will cause only a single frequency word to be sent to the frequency synthesizer <highlight><bold>44</bold></highlight> or whether a single pulse will cause all frequency words to be sent to the frequency synthesizer <highlight><bold>44</bold></highlight> sequentially. </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> Referring still to <cross-reference target="DRAWINGS">FIGS. 6 and 9</cross-reference>, the sequencer RAM <highlight><bold>62</bold></highlight> may also be used to store instructions that cause the sequencer <highlight><bold>60</bold></highlight> to generate signals for controlling the receiver and transmitter associated with the RF hardware devices <highlight><bold>40</bold></highlight>. Specifically, an &ldquo;RXENA&rdquo; instruction <highlight><bold>132</bold></highlight> causes the sequencer <highlight><bold>60</bold></highlight> to generate a control signal that is supplied to the RF hardware devices <highlight><bold>40</bold></highlight> and that causes the receiver to be enabled and that further causes a set of bits received by the receiver to be placed into a memory stack (not shown) associated with the receiver. Similarly, an &ldquo;RXDIS&rdquo; instruction <highlight><bold>133</bold></highlight> causes the sequencer <highlight><bold>60</bold></highlight> to generate a control signal that is supplied to the RF hardware devices <highlight><bold>40</bold></highlight> and that causes the receiver to be disabled. A &ldquo;TXSTART&rdquo; instruction <highlight><bold>134</bold></highlight> causes the sequencer <highlight><bold>60</bold></highlight> to generate a control signal that is supplied to the RF hardware devices <highlight><bold>40</bold></highlight> to enable data transmission. Specifically, the control signal may cause a modulator co-processor (not shown) associated with the transmitter to modulate a set of bits stored in a memory stack (not shown) associated with the transmitter and may further cause the transmitter to begin transmitting the modulated bits via a transmission burst. As will be understood by one having skill in the art, a &ldquo;burst&rdquo; is a term of art that generally refers to a signal having a short, defined duration. Moreover, &ldquo;burst&rdquo; is term of art that is typically defined according to a communication standard and thus the definitions of the term may vary depending on the standard in use. </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> A further set of instructions that cause the sequencer <highlight><bold>60</bold></highlight> to wait a specified length of time before executing the next instruction, and that further cause the sequencer <highlight><bold>60</bold></highlight> to increment and/or decrement the value held in the timebase counter <highlight><bold>64</bold></highlight> by a specified amount of time may also be stored in the sequencer RAM <highlight><bold>62</bold></highlight>. Specifically, an &ldquo;RTBWAIT&rdquo; instruction <highlight><bold>136</bold></highlight> formatted as &ldquo;RTBWAIT w&rdquo; causes the sequencer <highlight><bold>60</bold></highlight> to wait a length of time equal to the value specified in the field, &ldquo;w,&rdquo; of the RTBWAIT instruction <highlight><bold>136</bold></highlight>, an &ldquo;FRWAIT&rdquo; instruction <highlight><bold>138</bold></highlight> formatted as &ldquo;FRWAIT d&rdquo; causes the sequencer <highlight><bold>60</bold></highlight> to wait until the value stored in the frame counter <highlight><bold>66</bold></highlight> is equal to the value of specified in the field, &ldquo;d,&rdquo; of the FRWAIT instruction <highlight><bold>138</bold></highlight>, and a &ldquo;TBWAIT&rdquo; instruction <highlight><bold>140</bold></highlight> formatted as &ldquo;TBWAIT d&rdquo; causes the sequencer <highlight><bold>60</bold></highlight> to wait until the value in the timebase counter <highlight><bold>64</bold></highlight> is equal to the value specified in the field, &ldquo;d,&rdquo; of the TBWAIT instruction <highlight><bold>140</bold></highlight>. Further, a &ldquo;TBADJSN&rdquo; instruction <highlight><bold>142</bold></highlight> formatted as &ldquo;TBADJSN d&rdquo; causes the sequencer <highlight><bold>60</bold></highlight> to increment (if the value of d is equal to a logic level 1) or decrement (if the value of d is equal to a logic level zero) the value stored in the timebase counter <highlight><bold>64</bold></highlight> by an amount equal to a value stored in the timebase adjust register <highlight><bold>70</bold></highlight>. The value stored in the timebase counter <highlight><bold>64</bold></highlight> is adjusted in this manner to synchronize the communication device <highlight><bold>12</bold></highlight> with the base station <highlight><bold>10</bold></highlight>. </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> Referring still to <cross-reference target="DRAWINGS">FIGS. 6 and 9</cross-reference>, in addition to the instructions described above, the instructions stored in the sequencer RAM <highlight><bold>62</bold></highlight> may further include an &ldquo;NOP&rdquo; instruction <highlight><bold>144</bold></highlight> that causes the sequencer <highlight><bold>60</bold></highlight> to continue to the instruction located at the next consecutive address in the event that an instruction has not been written to the current address. Thus, instead of generating an error signal and potentially halting operation when an address having no instruction is encountered, the sequencer <highlight><bold>60</bold></highlight> merely proceeds to the instruction located at the next consecutive address in the sequencer RAM <highlight><bold>62</bold></highlight>. </paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> Referring now to <cross-reference target="DRAWINGS">FIG. 10</cross-reference>, the sequencer <highlight><bold>60</bold></highlight> may supply different types of interrupt signals to the DSP <highlight><bold>36</bold></highlight>, each of which may cause the DSP <highlight><bold>36</bold></highlight> to respond in a different, predefined manner. The system timer <highlight><bold>50</bold></highlight> indicates the type of interrupt signal by setting the DSP_INT_TYPE output pins <highlight><bold>124</bold></highlight> which are coupled to the DSP <highlight><bold>36</bold></highlight>. A first type of interrupt signal referred to as an invalid interrupt <highlight><bold>146</bold></highlight> and represented by setting the DSP_INT_TYPE output pins <highlight><bold>124</bold></highlight> to &ldquo;000&rdquo; may be used to indicate that an invalid interrupt <highlight><bold>146</bold></highlight> has been generated and may cause the DSP <highlight><bold>36</bold></highlight> to report to the microprocessor <highlight><bold>34</bold></highlight> that an invalid interrupt has been received with a request that the microprocessor <highlight><bold>34</bold></highlight> respond with instructions as to what actions, if any, should be taken in response to the invalid interrupt. </paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> A second type of interrupt, referred to as a frame interrupt <highlight><bold>148</bold></highlight> and represented by setting the DSP_INT_TYPE output pins <highlight><bold>124</bold></highlight> to &ldquo;001&rdquo; may be used to instruct the DSP <highlight><bold>36</bold></highlight> to trigger a procedure wherein a downlink data transfer and an uplink data transfer are performed. During the downlink data transfer, the DSP <highlight><bold>36</bold></highlight> causes a frame <highlight><bold>26</bold></highlight> of data received from the base station <highlight><bold>10</bold></highlight> at the RF hardware devices <highlight><bold>40</bold></highlight> to be stored in a first pre-designated memory location and then supplies an interrupt signal to the microprocessor <highlight><bold>34</bold></highlight> informing the microprocessor <highlight><bold>34</bold></highlight> that the frame <highlight><bold>26</bold></highlight> of data has been stored in the first pre-designated memory location. The microprocessor <highlight><bold>34</bold></highlight> responds to the interrupt signal by reading the first pre-designated memory location to retrieve the frame <highlight><bold>26</bold></highlight> of data therefrom. During the uplink data transfer, the microprocessor <highlight><bold>34</bold></highlight> causes a frame <highlight><bold>26</bold></highlight> of data to be stored in a second pre-designated memory location and then supplies an interrupt signal to the DSP <highlight><bold>36</bold></highlight> informing the DSP <highlight><bold>36</bold></highlight> that the frame <highlight><bold>26</bold></highlight> of data has been stored in the second pre-designated memory location. The DSP <highlight><bold>36</bold></highlight> responds to the interrupt signal supplied by the microprocessor <highlight><bold>34</bold></highlight> by retrieving the frame <highlight><bold>26</bold></highlight> of data from the second pre-designated memory location and then causes the frame <highlight><bold>26</bold></highlight> of data to be transmitted to the base station <highlight><bold>10</bold></highlight> via the RF hardware devices <highlight><bold>40</bold></highlight>. </paragraph>
<paragraph id="P-0068" lvl="0"><number>&lsqb;0068&rsqb;</number> A third type of interrupt, referred to as an RXWin interrupt <highlight><bold>150</bold></highlight> and represented by setting the DSP_INT_TYPE output pins <highlight><bold>124</bold></highlight> to &ldquo;010,&rdquo; may be used to instruct the DSP <highlight><bold>36</bold></highlight> to enable the receiver associated with the RF hardware devices <highlight><bold>40</bold></highlight> so that the receiver may begin receiving data. A fourth type of interrupt, referred to as a TXWin interrupt <highlight><bold>152</bold></highlight> and represented by setting the DSP_INT_TYPE output pins <highlight><bold>124</bold></highlight> to &ldquo;011,&rdquo; may be used to instruct the DSP <highlight><bold>36</bold></highlight> to enable the transmitter associated with the RF hardware devices <highlight><bold>40</bold></highlight>, to begin transmitter ramp-up operation and to modulate a burst of data stored in a memory device (not shown) associated with the transmitter. </paragraph>
<paragraph id="P-0069" lvl="0"><number>&lsqb;0069&rsqb;</number> A fifth type of interrupt, referred to as a handoff interrupt <highlight><bold>154</bold></highlight> and represented by setting the DSP_INT_TYPE output pins <highlight><bold>124</bold></highlight> to &ldquo;101,&rdquo; may be used to instruct the DSP <highlight><bold>36</bold></highlight> to enable the receiver to take off-channel signal strength and signal timing measurements. As will be understood by one having ordinary skill in the art, a communication device <highlight><bold>12</bold></highlight> may either communicate with the base station <highlight><bold>10</bold></highlight> directly or the base station <highlight><bold>10</bold></highlight> may serve as a conduit through which communication with a second mobile communication device may be routed. Moreover, the frequencies at which the two different types of communication are conducted are different. Specifically, when the communication device <highlight><bold>12</bold></highlight> is sending communication signals to the base station <highlight><bold>10</bold></highlight> for further routing, the communication device <highlight><bold>12</bold></highlight> may be tuned to a first frequency and is described as being &ldquo;on-channel.&rdquo; In contrast, when communicating with the base station <highlight><bold>10</bold></highlight> directly, the communication device <highlight><bold>12</bold></highlight> may be tuned to a second frequency and is described as being &ldquo;off-channel.&rdquo; As will further be understood by one having ordinary skill in the art, the communication device <highlight><bold>12</bold></highlight> may take signal strength and signal timing measurements off-channel for a variety of purposes including, for example, to enable a mobile assisted handoff. More particularly, and as will be understood by one having ordinary skill in the art, a mobile assisted call handoff procedure is typically performed when a communication device <highlight><bold>12</bold></highlight> is traveling from a first cell <highlight><bold>14</bold></highlight> that is serviced by a first base station <highlight><bold>10</bold></highlight> to a second, neighboring cell <highlight><bold>14</bold></highlight> that is serviced by a second, neighboring base station <highlight><bold>10</bold></highlight>. Specifically, when traveling from the first cell <highlight><bold>14</bold></highlight> to the second cell <highlight><bold>14</bold></highlight>, the first base station <highlight><bold>10</bold></highlight> causes the communication traffic associated with the communication device <highlight><bold>12</bold></highlight> to be transferred to and routed through the second base station <highlight><bold>10</bold></highlight>. The procedure typically involves obtaining a frequency at which communication may occur between the second base station <highlight><bold>10</bold></highlight> and the communication device <highlight><bold>12</bold></highlight>, and causing the communication device <highlight><bold>12</bold></highlight> to retune to the assigned frequency. Generally, the procedure may further involve any number of additional steps performed at any of the first and second base stations <highlight><bold>10</bold></highlight> and the communication device <highlight><bold>12</bold></highlight>. </paragraph>
<paragraph id="P-0070" lvl="0"><number>&lsqb;0070&rsqb;</number> A sixth type of interrupt, referred to as an APC interrupt <highlight><bold>156</bold></highlight> and represented by setting the DSP_INT_TYPE output bits <highlight><bold>124</bold></highlight> to &ldquo;110,&rdquo; may be used to instruct the DSP <highlight><bold>36</bold></highlight> to perform automatic power control. To perform automatic power control, the DSP <highlight><bold>36</bold></highlight> supplies a digital power control signal to one or more of the digital to analog converters <highlight><bold>42</bold></highlight> which then supplies a resulting analog power control signal to the transmitter associated with the RF hardware devices <highlight><bold>40</bold></highlight>. The analog power control signal controls the power level at which the transmitter operates. </paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> In addition, a seventh type of interrupt, referred to as a TXWinOff <highlight><bold>158</bold></highlight> interrupt and represented by setting the DSP_INT_TYPE bits to &ldquo;111,&rdquo; may be used to instruct the DSP <highlight><bold>36</bold></highlight> to stop performing automatic power control, to begin transmitter ramp-down operation and to disable the transmitter. The timing at which the DSP <highlight><bold>36</bold></highlight> stops performing automatic power control, and ramps down/disables the transmitter depends on whether normal or shortened communication burst modes are in use. Specifically, and as will be understood by one having ordinary skill in the art, the TIA-EIA-136 communication standard allows for bursts of differing lengths and, as a result, the timing at which the events associated with the TxWinOff interrupt <highlight><bold>158</bold></highlight> are performed will vary depending on the length of the bursts in use. </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> An eighth type of interrupt <highlight><bold>157</bold></highlight> may be represented by setting the DSP_INT_TYPE bits to <highlight><bold>100</bold></highlight> and may be reserved for performing a function to be assigned at a later time to enhance the flexibility of the system timer <highlight><bold>50</bold></highlight> and to meet the needs of the user of the communication device <highlight><bold>12</bold></highlight>. </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> Referring now to <cross-reference target="DRAWINGS">FIG. 11</cross-reference>, the system timer <highlight><bold>50</bold></highlight> may be adapted to execute any number or variety of instructions, including the instructions described above, in any desired sequence depending upon the type of system or device in which the system timer <highlight><bold>50</bold></highlight> is disposed. For example, if the system timer <highlight><bold>50</bold></highlight> is disposed in the communication device <highlight><bold>12</bold></highlight> shown in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, then the sequencer <highlight><bold>60</bold></highlight> may be programmed to execute instructions that allow the mobile device to synchronize with the base station <highlight><bold>10</bold></highlight> to thereby enable communication between the communication device <highlight><bold>12</bold></highlight> and the base station <highlight><bold>10</bold></highlight>. More specifically, the system timer <highlight><bold>50</bold></highlight> may be programmed to perform tasks that support functions performed by the various layers <highlight><bold>52</bold></highlight>, <highlight><bold>54</bold></highlight>, <highlight><bold>56</bold></highlight> and <highlight><bold>58</bold></highlight> (see <cross-reference target="DRAWINGS">FIG. 5</cross-reference>) associated with the communication device <highlight><bold>12</bold></highlight>. </paragraph>
<paragraph id="P-0074" lvl="0"><number>&lsqb;0074&rsqb;</number> Thus, for example, if the physical layer <highlight><bold>58</bold></highlight> is configured to operate in three different modes including an Idle mode, an Acquisition mode and a Steady State mode, then the system timer <highlight><bold>50</bold></highlight> may also be configured to operate in three different modes by programming the sequencer <highlight><bold>60</bold></highlight> to execute a different set of instructions for each mode. More particularly, an Idle mode program <highlight><bold>160</bold></highlight>, an Acquisition mode program <highlight><bold>162</bold></highlight> and a Steady State mode program <highlight><bold>164</bold></highlight> may each be stored at a different set of memory locations in the sequencer RAM <highlight><bold>62</bold></highlight>, each of which begins with a different starting address. When transition between the mode programs <highlight><bold>160</bold></highlight>, <highlight><bold>162</bold></highlight> and <highlight><bold>164</bold></highlight> is appropriate, the WHAL <highlight><bold>56</bold></highlight> may write the starting address of an appropriate one of the programs to the command register <highlight><bold>82</bold></highlight> so that, when a JCMD instruction <highlight><bold>112</bold></highlight> is executed by the sequencer <highlight><bold>60</bold></highlight>, the sequencer <highlight><bold>60</bold></highlight> jumps to the address written in the command register <highlight><bold>82</bold></highlight> and thus begins to execute the first instruction stored at the starting address of the corresponding program. </paragraph>
<paragraph id="P-0075" lvl="0"><number>&lsqb;0075&rsqb;</number> Referring now to <cross-reference target="DRAWINGS">FIG. 12</cross-reference>, the system timer <highlight><bold>50</bold></highlight> may use the Idle mode program <highlight><bold>160</bold></highlight> to control the timing of the communication device <highlight><bold>12</bold></highlight> when the communication device <highlight><bold>12</bold></highlight> is powered up but not in use. Further, when operating in the Idle mode, the sequencer <highlight><bold>60</bold></highlight> may send a frame-type interrupt signal to the DSP <highlight><bold>36</bold></highlight> causing the DSP <highlight><bold>36</bold></highlight> to make any received data available to the microprocessor <highlight><bold>34</bold></highlight> (step <highlight><bold>166</bold></highlight>). Specifically, the sequencer <highlight><bold>60</bold></highlight> may execute, for example, a DSPINT instruction <highlight><bold>120</bold></highlight> having a type field that indicates a frame interrupt signal <highlight><bold>148</bold></highlight>. After the frame-type interrupt has been generated, the sequencer <highlight><bold>60</bold></highlight> may either enter the Acquisition mode or may remain in the Idle mode depending on the outcome of a conditional jump instruction (step <highlight><bold>168</bold></highlight>), which may be implemented using a JCMD instruction <highlight><bold>112</bold></highlight>. The jump instruction may cause the sequencer <highlight><bold>60</bold></highlight> to jump to the starting address of the Acquisition mode program <highlight><bold>162</bold></highlight> (step <highlight><bold>170</bold></highlight>) which the microprocessor <highlight><bold>34</bold></highlight> will have stored in the command register <highlight><bold>82</bold></highlight> if transition to the Acquisition mode program <highlight><bold>162</bold></highlight> is appropriate. Alternatively, if the command register <highlight><bold>82</bold></highlight> is empty, the sequencer <highlight><bold>60</bold></highlight> instead loops back to the start of the Idle mode program <highlight><bold>160</bold></highlight> where an interrupt signal is again generated (step <highlight><bold>166</bold></highlight>). </paragraph>
<paragraph id="P-0076" lvl="0"><number>&lsqb;0076&rsqb;</number> When the communication device <highlight><bold>12</bold></highlight> needs to acquire a communication channel, which may occur, for example, when a user attempts to initiate a telephone call, the communication device <highlight><bold>12</bold></highlight> transitions to the Acquisition mode program <highlight><bold>162</bold></highlight>. More particularly, and referring now to <cross-reference target="DRAWINGS">FIG. 13</cross-reference> which aligns with <cross-reference target="DRAWINGS">FIG. 12</cross-reference> at connecting point A, the Acquisition mode program <highlight><bold>162</bold></highlight> may be initiated when the WHAL <highlight><bold>56</bold></highlight> writes the starting address of the Acquisition mode program <highlight><bold>162</bold></highlight> in the command register <highlight><bold>82</bold></highlight> in response to a communication channel setup command received from the protocol engine. When a communication channel is needed, the protocol engine may use an appropriate function call to instruct the WHAL <highlight><bold>56</bold></highlight> to set up, or acquire, either a control channel or a traffic channel causing the WHAL <highlight><bold>56</bold></highlight> to write the starting address of the Acquisition mode program <highlight><bold>162</bold></highlight> to the command register <highlight><bold>82</bold></highlight>. As a result, the sequencer <highlight><bold>60</bold></highlight> jumps to the starting address of the Acquisition mode program <highlight><bold>162</bold></highlight> when the JCMD instruction <highlight><bold>112</bold></highlight> is executed during the Idle mode program <highlight><bold>160</bold></highlight> (step <highlight><bold>168</bold></highlight>). As will be understood by one having ordinary skill in the art, a control channel is a communication channel that is reserved for transmitting control information from the base station <highlight><bold>10</bold></highlight> to the communication device <highlight><bold>12</bold></highlight> and a traffic channel is a communication channel that is reserved for communication between a first communication device <highlight><bold>12</bold></highlight> and a second communication device (either mobile or stationary) that is routed through the base station <highlight><bold>10</bold></highlight>. </paragraph>
<paragraph id="P-0077" lvl="0"><number>&lsqb;0077&rsqb;</number> Although the steps of the Idle mode program <highlight><bold>160</bold></highlight>, as described above, may be appropriate for a communication device <highlight><bold>12</bold></highlight> configured to operate in a TIA-EIA-136 communication system as well as a GSM communication system, a set of steps associated with the Acquisition mode program <highlight><bold>162</bold></highlight> may vary depending upon the communication system in which the communication device <highlight><bold>12</bold></highlight> is configured to operate. If the communication device <highlight><bold>12</bold></highlight> is configured to operate in a TIA-EIA-136 communication system, then, when operating in the Acquisition mode the sequencer <highlight><bold>60</bold></highlight> may send an RxWin-type interrupt <highlight><bold>150</bold></highlight> to the DSP <highlight><bold>36</bold></highlight> causing the DSP <highlight><bold>36</bold></highlight> to enable the receiver and begin receiving data from the base station <highlight><bold>10</bold></highlight> (step <highlight><bold>172</bold></highlight>). The sequencer <highlight><bold>60</bold></highlight> may generate the RxWin-type interrupt <highlight><bold>150</bold></highlight>, for example, in response to a DSPINT instruction <highlight><bold>120</bold></highlight> having a type field that indicates an RxWin-type interrupt <highlight><bold>150</bold></highlight>. After generating the RxWin-type interrupt <highlight><bold>150</bold></highlight>, the sequencer <highlight><bold>60</bold></highlight> may generate a further interrupt causing the DSP <highlight><bold>36</bold></highlight> to make the received data available to the microprocessor <highlight><bold>34</bold></highlight> for processing (step <highlight><bold>174</bold></highlight>). For example, the sequencer <highlight><bold>60</bold></highlight> may generate the frame-type interrupt <highlight><bold>148</bold></highlight> by executing a DSPINT instruction <highlight><bold>120</bold></highlight> having a type field that indicates a frame-type interrupt <highlight><bold>148</bold></highlight>. The microprocessor <highlight><bold>34</bold></highlight> may use the data received from the DSP <highlight><bold>36</bold></highlight> during the frame-type interrupt <highlight><bold>148</bold></highlight> to determine whether a channel has been successfully acquired by measuring, for example, burst position data and burst quality data. The microprocessor <highlight><bold>34</bold></highlight> may examine the data to determine, for example, whether the bursts are located at expected, predefined positions and whether the burst quality exceeds a predetermine threshold. If the measured data indicates that a control channel has been successfully acquired, the WHAL <highlight><bold>56</bold></highlight> writes the starting address of the Steady State program <highlight><bold>164</bold></highlight> into the command register <highlight><bold>82</bold></highlight>. After the sequencer <highlight><bold>60</bold></highlight> generates the frame-type interrupt <highlight><bold>148</bold></highlight> (step <highlight><bold>174</bold></highlight>), the sequencer <highlight><bold>60</bold></highlight> may execute a jump instruction (step <highlight><bold>176</bold></highlight>), implemented using the JCMD instruction <highlight><bold>112</bold></highlight>, causing the sequencer <highlight><bold>60</bold></highlight> to either jump to the starting address of the Steady State mode program <highlight><bold>164</bold></highlight> stored in the command register <highlight><bold>82</bold></highlight> (step <highlight><bold>178</bold></highlight>) (if a channel has been successfully acquired) or return to the starting address of the Acquisition mode program <highlight><bold>162</bold></highlight> (step <highlight><bold>172</bold></highlight>) so that a repeated attempt at channel acquisition may be performed. </paragraph>
<paragraph id="P-0078" lvl="0"><number>&lsqb;0078&rsqb;</number> Referring still to <cross-reference target="DRAWINGS">FIG. 13</cross-reference>, if the communication device <highlight><bold>12</bold></highlight> is instead configured to operate in a GSM communication system, the system timer <highlight><bold>50</bold></highlight> may be configured to perform similar tasks in a different manner during the Acquisition mode. For example, when operating in the Acquisition mode the sequencer <highlight><bold>60</bold></highlight> may enable the receiver and cause a set of received data symbols to be placed into a memory stack associated with the receiver by sending a control signal directly to the RF hardware devices <highlight><bold>40</bold></highlight> instead of supplying an interrupt signal to the DSP <highlight><bold>36</bold></highlight> to accomplish the receiver enabling tasks. Specifically, the sequencer <highlight><bold>60</bold></highlight> may enable the receiver in response to an RXENA instruction <highlight><bold>132</bold></highlight> instead of executing a DSPINT instruction <highlight><bold>120</bold></highlight> having a type field that indicates an RxWin-type interrupt <highlight><bold>150</bold></highlight> as was used when configured for operation in a TIA-EIA-136 communication system. An RXENA instruction <highlight><bold>132</bold></highlight> may be preferable to using a DSPINT instruction <highlight><bold>120</bold></highlight> while operating in a GSM communication system due to the shorter frame lengths and thus, tighter timing requirements associated with the GSM communication protocol. More particularly, an RXENA instruction <highlight><bold>132</bold></highlight> allows the sequencer <highlight><bold>60</bold></highlight> to enable the receiver directly. In contrast, a DSPINT instruction <highlight><bold>120</bold></highlight> having a type field indicating an RXWin-type interrupt <highlight><bold>150</bold></highlight> does not directly enable the receiver but instead causes the sequencer <highlight><bold>60</bold></highlight> to interrupt the DSP <highlight><bold>36</bold></highlight> which, in turn, responds to the interrupt by enabling the receiver and associated hardware <highlight><bold>40</bold></highlight>. Thus, an RXENA instruction <highlight><bold>132</bold></highlight>, having fewer steps, enables data reception sooner than an RXWin-type interrupt <highlight><bold>150</bold></highlight> and therefore may be preferable when operating in a GSM communication system. </paragraph>
<paragraph id="P-0079" lvl="0"><number>&lsqb;0079&rsqb;</number> Further, when the incoming data has been received at the receiver and transferred to the DSP <highlight><bold>36</bold></highlight>, the DSP <highlight><bold>36</bold></highlight> may also perform a set of tasks necessary to extract control data from the received data stream (step <highlight><bold>172</bold></highlight>). For example, the DSP may search a first data frame <highlight><bold>26</bold></highlight> for a frequency correction burst (&ldquo;FCB&rdquo;that comprises a specific, predefined bit pattern that when, properly modulated, will result in a pure sine wave having a predefined length. Once the location of the FCB within the frame is known, the DSP <highlight><bold>36</bold></highlight> searches the same location in other subsequently received frames to confirm the location of the FCB. In addition, the DSP <highlight><bold>36</bold></highlight> may use information contained in the FCB to determine a bit offset that indicates the amount by which the timing of the communication device <highlight><bold>12</bold></highlight> is offset from the timing of the base station <highlight><bold>10</bold></highlight>. Once determined, the bit offset may be used to calculate the time at which the next slot will be received at the communication device <highlight><bold>12</bold></highlight> so that the DSP <highlight><bold>36</bold></highlight> can enable receipt of the next slot at the proper time. Next, the DSP <highlight><bold>36</bold></highlight> may use the location of the FCB to enable receipt of a synchronization correction burst (&ldquo;SCB&rdquo;located a fixed distance from the position of the FCB and the DSP <highlight><bold>36</bold></highlight> may demodulate and decode the SCB. Finally, the sequencer <highlight><bold>60</bold></highlight> may generate a frame interrupt <highlight><bold>148</bold></highlight> so that the decoded SCB is forwarded by the DSP <highlight><bold>36</bold></highlight> to the microprocessor <highlight><bold>34</bold></highlight> (step <highlight><bold>174</bold></highlight>) which uses the SCB to obtain information that identifies the base station <highlight><bold>10</bold></highlight> that transmitted the SCB and to obtain information that allows the communication device <highlight><bold>12</bold></highlight> to fully synchronize with the base station <highlight><bold>10</bold></highlight> and complete channel acquisition. Depending on whether a channel was successfully acquired (step <highlight><bold>176</bold></highlight>), the sequencer <highlight><bold>60</bold></highlight> may then either enter the Steady State mode (step <highlight><bold>178</bold></highlight>) or remain in the Acquisition mode (step <highlight><bold>172</bold></highlight>) SO that a second attempt at channel acquisition may be performed. As will be appreciated by one having ordinary skill in the art, the steps described above for processing off-channel data received while operating in the Acquisition mode may include a fewer or greater number of steps and are intended to be illustrative only. Further, the system timer <highlight><bold>50</bold></highlight> may be programmed as necessary to support any data processing tasks performed by the various layers associated with the communication device <highlight><bold>12</bold></highlight>. </paragraph>
<paragraph id="P-0080" lvl="0"><number>&lsqb;0080&rsqb;</number> Referring now to <cross-reference target="DRAWINGS">FIG. 14</cross-reference> which aligns with <cross-reference target="DRAWINGS">FIG. 13</cross-reference> at connecting point B, the steps performed during the Steady State mode program <highlight><bold>164</bold></highlight> may also vary depending upon the type of communication system in which the communication device <highlight><bold>12</bold></highlight> is being used. For example, when configured for a TIA-EIA-136 communication system, the sequencer <highlight><bold>60</bold></highlight> may, in response to a DSPINT instruction <highlight><bold>120</bold></highlight> having a type field that indicates an RXWIN-type interrupt <highlight><bold>150</bold></highlight>, cause the DSP <highlight><bold>36</bold></highlight> to enable the receiver associated with the RF hardware devices <highlight><bold>40</bold></highlight> and begin receiving data from the base station <highlight><bold>10</bold></highlight> until the receive slot has ended (step <highlight><bold>180</bold></highlight>). After the receive slot has ended, the sequencer <highlight><bold>60</bold></highlight> may prepare for the handoff slot by interrupting the microprocessor <highlight><bold>34</bold></highlight> in response to an ARMINT instruction <highlight><bold>122</bold></highlight> thereby causing the microprocessor <highlight><bold>34</bold></highlight> to write off-channel frequency data to the synthesizer interface <highlight><bold>46</bold></highlight> (step <highlight><bold>182</bold></highlight>). Further, the sequencer <highlight><bold>60</bold></highlight> may execute a SYNSEND instruction <highlight><bold>126</bold></highlight> causing the synthesizer interface <highlight><bold>46</bold></highlight> to forward the off-channel frequency data to the synthesizer controller <highlight><bold>44</bold></highlight> (step <highlight><bold>184</bold></highlight>) which may use the data to tune the receiver associated with the RF hardware devices <highlight><bold>40</bold></highlight> to an appropriate off-channel frequency level so that handoff data may be collected. After the receiver is properly tuned, the sequencer <highlight><bold>60</bold></highlight> may interrupt the DSP <highlight><bold>36</bold></highlight> and the microprocessor <highlight><bold>34</bold></highlight> to enable the receipt and measurement of off-channel data (step <highlight><bold>186</bold></highlight>). Specifically, the sequencer <highlight><bold>60</bold></highlight> may execute a DSPINT instruction <highlight><bold>120</bold></highlight> having a type field that indicates a handoff-type interrupt <highlight><bold>154</bold></highlight> and the sequencer <highlight><bold>60</bold></highlight> may further execute an ARMINT instruction <highlight><bold>122</bold></highlight>. After the off-channel data has been measured by the microprocessor <highlight><bold>34</bold></highlight>, the sequencer <highlight><bold>60</bold></highlight> may again interrupt the microprocessor <highlight><bold>34</bold></highlight> in response to another ARMINT instruction <highlight><bold>122</bold></highlight> to thereby disable the recording of off-channel data measurements (step <highlight><bold>190</bold></highlight>). After the handoff slot, at the start of the transmit slot, the sequencer <highlight><bold>60</bold></highlight> may generate an interrupt causing the DSP <highlight><bold>36</bold></highlight> to transmit data (step <highlight><bold>192</bold></highlight>) and, during the transmit slot, the sequencer <highlight><bold>60</bold></highlight> may further generate a frame interrupt causing the frame <highlight><bold>26</bold></highlight> of data received by the DSP <highlight><bold>36</bold></highlight> during the receive slot to be made available to the microprocessor <highlight><bold>34</bold></highlight> (step <highlight><bold>194</bold></highlight>). At the end of the transmit slot, the sequencer <highlight><bold>60</bold></highlight> may interrupt the DSP <highlight><bold>36</bold></highlight> causing the DSP <highlight><bold>36</bold></highlight> to stop transmitting data (step <highlight><bold>196</bold></highlight>). The sequencer <highlight><bold>60</bold></highlight> may enable and disable data transmission via, for example, the execution of DSPINT instructions <highlight><bold>120</bold></highlight> having type fields that indicate a TxWin-type interrupt <highlight><bold>152</bold></highlight> and a TxWinOff-type interrupt <highlight><bold>158</bold></highlight>, respectively. </paragraph>
<paragraph id="P-0081" lvl="0"><number>&lsqb;0081&rsqb;</number> Referring also to <cross-reference target="DRAWINGS">FIG. 15</cross-reference> which aligns with <cross-reference target="DRAWINGS">FIG. 13</cross-reference> at connecting point B, the sequencer <highlight><bold>60</bold></highlight>, when configured for a GSM communication system and when operating in the Steady State mode, may perform tasks similar to the tasks performed by a sequencer <highlight><bold>60</bold></highlight> configured for a TIA-EIA-136 communication system with a few differences to account for the differences between the frame format associated with the GSM system and the frame format associated with the TIA-EIA-136 communication system. For example, in a TIA-EIA-136 communication frame, the handoff slot <highlight><bold>32</bold></highlight> occurs after the receive slot <highlight><bold>28</bold></highlight> and before the transmit slot <highlight><bold>30</bold></highlight>. In contrast, in a GSM communication frame the handoff <highlight><bold>32</bold></highlight> slot occurs after both of the receive and transmit slots <highlight><bold>28</bold></highlight>, <highlight><bold>30</bold></highlight>. In addition, the timing requirements are tighter in a GSM communication system than in a TIA-EIA-136 communication system. At the start of a frame in the Steady State mode for a GSM communication system, the sequencer <highlight><bold>60</bold></highlight> may generate a control signal to enable the receiver and the memory associated with the receiver so that data may be received at the communication device <highlight><bold>12</bold></highlight> (step <highlight><bold>198</bold></highlight>). To meet the tighter timing requirements associated with the GSM communication-system, the sequencer <highlight><bold>60</bold></highlight> may control the receiver directly in response to an RXENA instruction <highlight><bold>132</bold></highlight> instead of indirectly controlling the receiver using a DSP_INT instruction <highlight><bold>120</bold></highlight> as was used to enable the receiver in the during the steady state mode program <highlight><bold>164</bold></highlight> in the TIA-EIA-136 communication system. After the RXENA instruction <highlight><bold>132</bold></highlight> has been executed and when the transmit slot begins, the sequencer <highlight><bold>60</bold></highlight> may enable the transmitter for a length of time equal to the length of the transmit slot via the execution of a TXSTART instruction (step <highlight><bold>200</bold></highlight>). After the transmit slot and at the start of the handoff slot, the sequencer <highlight><bold>60</bold></highlight> may enable the receipt and measurement of off-channel signals. Specifically, the sequencer <highlight><bold>60</bold></highlight> may interrupt the microprocessor <highlight><bold>34</bold></highlight> causing the microprocessor <highlight><bold>34</bold></highlight> to supply off-channel frequency data to the synthesizer interface <highlight><bold>46</bold></highlight> (step <highlight><bold>202</bold></highlight>) and may further cause the synthesizer interface <highlight><bold>46</bold></highlight> to forward the off-channel frequency data to the synthesizer controller <highlight><bold>44</bold></highlight> (step <highlight><bold>204</bold></highlight>). The interrupt signal may be generated, for example, in response to an ARMINT instruction <highlight><bold>122</bold></highlight> and the off-channel frequency data may be supplied to the synthesizer controller <highlight><bold>44</bold></highlight> via the SYNSEND instruction <highlight><bold>126</bold></highlight>. Provided that the receiver is still enabled, the sequencer <highlight><bold>60</bold></highlight> need not re-enable the receiver associated with the hardware devices <highlight><bold>40</bold></highlight> to receive the off-channel data. If instead the receiver has been disabled, then the sequencer <highlight><bold>60</bold></highlight> may again use an RXENA instruction <highlight><bold>132</bold></highlight> to enable the receiver (step <highlight><bold>206</bold></highlight>). In addition, the sequencer <highlight><bold>60</bold></highlight> causes the microprocessor <highlight><bold>34</bold></highlight> to begin measuring the off-channel frequency data being received at the receiver (step <highlight><bold>208</bold></highlight>) via, for example, an ARMINT instruction <highlight><bold>122</bold></highlight>. If necessary, the sequencer <highlight><bold>60</bold></highlight> may also executing a DSPINT instruction <highlight><bold>120</bold></highlight> having a type field that indicates a frame interrupt <highlight><bold>148</bold></highlight> thereby causing the DSP <highlight><bold>36</bold></highlight> to make data received at the receiver available to the microprocessor <highlight><bold>34</bold></highlight> (step <highlight><bold>208</bold></highlight>). Of course, as will be understood by one having ordinary skill in the art, while operating in the Steady State mode, the sequencer <highlight><bold>60</bold></highlight> may also cause a set of system timer outputs to change state as necessary to control the RF hardware devices <highlight><bold>40</bold></highlight> to enable the reception and transmission of data during the receive and transmit slots, respectively. </paragraph>
<paragraph id="P-0082" lvl="0"><number>&lsqb;0082&rsqb;</number> Referring now to <cross-reference target="DRAWINGS">FIG. 16</cross-reference>, the timebase adjust register <highlight><bold>70</bold></highlight> and timing adjust register <highlight><bold>74</bold></highlight> contain values that allow the timing of the receive <highlight><bold>28</bold></highlight> and transmit slots <highlight><bold>30</bold></highlight> associated with each frame <highlight><bold>26</bold></highlight> to be adjusted to account for movement of the communication device <highlight><bold>12</bold></highlight> relative to the base station <highlight><bold>10</bold></highlight>. Movement of the communication device <highlight><bold>12</bold></highlight> relative to the base station <highlight><bold>10</bold></highlight> changes the distance between the communication device <highlight><bold>12</bold></highlight> and the base station <highlight><bold>10</bold></highlight> which affects the timing of communication between the communication device <highlight><bold>12</bold></highlight> and the base station <highlight><bold>10</bold></highlight>. For illustrative purposes, the effect that a change in distance has on the timing of communication between the communication device <highlight><bold>12</bold></highlight> and the base station <highlight><bold>10</bold></highlight> is described with reference to the timing associated with the transmission and reception of three data frames <highlight><bold>500</bold></highlight>, <highlight><bold>502</bold></highlight>, <highlight><bold>504</bold></highlight> between the communication device <highlight><bold>12</bold></highlight> and the base station <highlight><bold>10</bold></highlight>. Specifically, a set of frames <highlight><bold>500</bold></highlight>A, <highlight><bold>502</bold></highlight>A and <highlight><bold>504</bold></highlight>A represent the timing at which the base station <highlight><bold>10</bold></highlight> is configured to transmit and receive data during each frame <highlight><bold>500</bold></highlight>, <highlight><bold>502</bold></highlight>, <highlight><bold>504</bold></highlight>. As is conventional, the timing associated with the base station <highlight><bold>10</bold></highlight> is fixed such that a transmit slot occurs at a fixed time during each frame and a receive slot occurs at a fixed time during each frame. In addition, all of the frames <highlight><bold>500</bold></highlight>A, <highlight><bold>502</bold></highlight>A, <highlight><bold>504</bold></highlight>A are equally long. </paragraph>
<paragraph id="P-0083" lvl="0"><number>&lsqb;0083&rsqb;</number> A set of frames <highlight><bold>500</bold></highlight>B, <highlight><bold>502</bold></highlight>B, <highlight><bold>504</bold></highlight>B represent the timing at which the communication device <highlight><bold>12</bold></highlight> is configured to transmit and receive data during each of the frames <highlight><bold>500</bold></highlight>, <highlight><bold>502</bold></highlight>, <highlight><bold>504</bold></highlight>, respectively. A set of frames <highlight><bold>500</bold></highlight>C, <highlight><bold>502</bold></highlight>C, <highlight><bold>504</bold></highlight>C represent the timing at which the communication device <highlight><bold>12</bold></highlight> must actually transmit and receive data during each frame <highlight><bold>500</bold></highlight>, <highlight><bold>502</bold></highlight>, <highlight><bold>504</bold></highlight> to ensure that communication between the base station <highlight><bold>10</bold></highlight> and the communication device <highlight><bold>12</bold></highlight> is enabled. During the first frame <highlight><bold>500</bold></highlight>, the communication device <highlight><bold>12</bold></highlight> is located very near to the base station <highlight><bold>10</bold></highlight> and during the second and third frames the communication device <highlight><bold>12</bold></highlight> has moved an unspecified distance away from the base station. </paragraph>
<paragraph id="P-0084" lvl="0"><number>&lsqb;0084&rsqb;</number> During the first frame <highlight><bold>500</bold></highlight>, the communication device <highlight><bold>12</bold></highlight> is configured to receive data at the same time that the base station <highlight><bold>10</bold></highlight> transmits data and the communication device <highlight><bold>12</bold></highlight> is further configured to transmit data at the same time that the base station <highlight><bold>10</bold></highlight> receives data. Thus, a receive slot <highlight><bold>506</bold></highlight>B at the communication device <highlight><bold>12</bold></highlight> is aligned with a transmit slot <highlight><bold>506</bold></highlight>A at the base station <highlight><bold>10</bold></highlight> and a transmit slot <highlight><bold>508</bold></highlight>B at the communication device <highlight><bold>12</bold></highlight> is aligned with a receive slot <highlight><bold>508</bold></highlight>A at the base station. Moreover, because the communication device <highlight><bold>12</bold></highlight> is located very near to the base station <highlight><bold>10</bold></highlight> such that there is a very short distance separating the communication device <highlight><bold>12</bold></highlight> and the base station <highlight><bold>10</bold></highlight>, the data travels between the communication device <highlight><bold>12</bold></highlight> and the base station <highlight><bold>10</bold></highlight> without delay. As a result, the times at which the communication device <highlight><bold>12</bold></highlight> must actually transmit <highlight><bold>508</bold></highlight>C and receive <highlight><bold>506</bold></highlight>C data to ensure proper communication with the base station <highlight><bold>10</bold></highlight> are aligned with the times at which the communication device <highlight><bold>12</bold></highlight> is configured to transmit <highlight><bold>508</bold></highlight>B and receive <highlight><bold>506</bold></highlight>B data such that proper communication is enabled. </paragraph>
<paragraph id="P-0085" lvl="0"><number>&lsqb;0085&rsqb;</number> As with respect to the first frame <highlight><bold>500</bold></highlight>, during the second frame <highlight><bold>502</bold></highlight>, the communication device <highlight><bold>12</bold></highlight> is configured to receive data at the same time that the base station <highlight><bold>10</bold></highlight> transmits data and the communication device <highlight><bold>12</bold></highlight> is further configured to transmit data at the same time that the base station <highlight><bold>10</bold></highlight> receives data. Thus, a receive slot <highlight><bold>510</bold></highlight>B at the communication device <highlight><bold>12</bold></highlight> is aligned with a transmit slot <highlight><bold>512</bold></highlight>A at the base station <highlight><bold>10</bold></highlight> and a transmit slot <highlight><bold>512</bold></highlight>B at the communication device <highlight><bold>12</bold></highlight> is aligned with a receive slot <highlight><bold>512</bold></highlight>A at the base station <highlight><bold>10</bold></highlight>. However, during the second frame <highlight><bold>502</bold></highlight>, the communication device <highlight><bold>12</bold></highlight> has moved an unspecified distance away from the base station <highlight><bold>10</bold></highlight> such that data transmitted by the base station <highlight><bold>10</bold></highlight> arrives at the communication device <highlight><bold>12</bold></highlight> after a delay &ldquo;t&rdquo; and data transmitted by the communication device <highlight><bold>12</bold></highlight> to the base station <highlight><bold>10</bold></highlight> arrives at the mobile device after a delay &ldquo;T.&rdquo; Thus, to ensure proper communication, the communication device <highlight><bold>12</bold></highlight> should have been configured to receive data at a receive slot <highlight><bold>510</bold></highlight>C occurring later than the receive slot <highlight><bold>510</bold></highlight>B to account for the delay caused by the unspecified distance. Similarly, the communication device <highlight><bold>12</bold></highlight> further should have been configured to transmit data at a transmit slot <highlight><bold>512</bold></highlight>C that is offset from the transmit slot <highlight><bold>512</bold></highlight>B by the amount of time &ldquo;T&rdquo; wherein &ldquo;T&rdquo; is sufficient to compensate for the additional time required for the data to travel from the communication device <highlight><bold>12</bold></highlight> to the base station <highlight><bold>10</bold></highlight>. As a result, the times at which the communication device <highlight><bold>12</bold></highlight> must actually transmit <highlight><bold>512</bold></highlight>C and receive <highlight><bold>510</bold></highlight>C data to ensure proper communication with the base station <highlight><bold>10</bold></highlight> are not aligned with the times at which the communication device <highlight><bold>12</bold></highlight> is configured to transmit <highlight><bold>510</bold></highlight>B and receive <highlight><bold>512</bold></highlight>B data thereby indicating that the times at which the communication device <highlight><bold>12</bold></highlight> is configured to transmit <highlight><bold>512</bold></highlight>B and receive <highlight><bold>510</bold></highlight>B data must be adjusted to prevent communication between the communication device <highlight><bold>12</bold></highlight> and the base station <highlight><bold>10</bold></highlight> from being impaired. </paragraph>
<paragraph id="P-0086" lvl="0"><number>&lsqb;0086&rsqb;</number> Specifically, unless the receive slot <highlight><bold>510</bold></highlight>B associated with the communication device <highlight><bold>12</bold></highlight> is adjusted, at least some of the information transmitted by the base station <highlight><bold>10</bold></highlight> will not be received at the communication device <highlight><bold>12</bold></highlight>, and unless the transmit slot <highlight><bold>512</bold></highlight>B associated with the communication device <highlight><bold>12</bold></highlight> is adjusted, at least some of the information transmitted by the communication device <highlight><bold>12</bold></highlight> will not be received at the base station <highlight><bold>10</bold></highlight>. </paragraph>
<paragraph id="P-0087" lvl="0"><number>&lsqb;0087&rsqb;</number> Referring also to <cross-reference target="DRAWINGS">FIG. 17, a</cross-reference> method <highlight><bold>209</bold></highlight> for adjusting the time at which the receive slot occurs in a given frame may be implemented using the sequencer <highlight><bold>60</bold></highlight>, the microprocessor <highlight><bold>34</bold></highlight> and a set of software instructions and may begin, for example, when the microprocessor <highlight><bold>34</bold></highlight> calculates a first offset value, denoted FIRST OFFSET, equal to an amount of time by which the receive slot <highlight><bold>510</bold></highlight>B at the communication device <highlight><bold>12</bold></highlight> should be offset during the next frame <highlight><bold>504</bold></highlight>B, to enable reception of the complete set of data transmitted by the base station <highlight><bold>10</bold></highlight> during the next frame <highlight><bold>504</bold></highlight>B (step <highlight><bold>210</bold></highlight>). Thus, for example, if the sequencer <highlight><bold>60</bold></highlight> enabled the receiver at the start of the receive slot <highlight><bold>510</bold></highlight>B but the microprocessor <highlight><bold>34</bold></highlight> did not detect received data until a period of time, &ldquo;t,&rdquo; had elapsed after the start of the receive slot <highlight><bold>510</bold></highlight>B, then the microprocessor <highlight><bold>34</bold></highlight> causes the FIRST OFFSET value to be equal to the time &ldquo;t.&rdquo; Next, the microprocessor <highlight><bold>34</bold></highlight> causes a period of time equal to the current frame length plus the value of FIRST OFFSET to be stored in the timebase adjust register <highlight><bold>70</bold></highlight> (step <highlight><bold>212</bold></highlight>). The sequencer <highlight><bold>60</bold></highlight> may then detect the presence of the newly stored value in the timebase adjust register <highlight><bold>70</bold></highlight> and adjust the current frame length by causing the timebase counter <highlight><bold>64</bold></highlight> to wrap to zero when the value in the timebase counter <highlight><bold>64</bold></highlight> is equal to the newly stored value located in the timebase adjust register <highlight><bold>70</bold></highlight>. Thus, the point at which the timebase counter <highlight><bold>64</bold></highlight> wraps to zero is adjustable by storing a new frame length in the timebase adjust register <highlight><bold>70</bold></highlight>. Lengthening the current frame <highlight><bold>502</bold></highlight>B by an amount of time, t, causes the start of the subsequent frame <highlight><bold>504</bold></highlight>B to occur later by an amount of time equal to t, thereby causing the start of the receive slot <highlight><bold>514</bold></highlight>B to occur later by an amount of time equal to t during the next frame <highlight><bold>504</bold></highlight>B. More particularly, the receive slot <highlight><bold>510</bold></highlight>B occurs at a fixed time relative to the start of the frame <highlight><bold>502</bold></highlight>B such that the time at which the receive slot <highlight><bold>514</bold></highlight>B occurs in the frame <highlight><bold>504</bold></highlight>B may be adjusted by changing the length of the frame <highlight><bold>502</bold></highlight>B. If the communication device <highlight><bold>12</bold></highlight> is moving nearer to the base station <highlight><bold>10</bold></highlight> instead of farther away, then the microprocessor <highlight><bold>34</bold></highlight> stores a value in the timebase adjust register <highlight><bold>70</bold></highlight> that shortens the length of the current frame, <highlight><bold>502</bold></highlight>B, thereby causing the start of the next frame, <highlight><bold>504</bold></highlight>B, to occur earlier and thus causing the start of the receive slot <highlight><bold>514</bold></highlight>B associated with the next frame <highlight><bold>504</bold></highlight>B to begin earlier. </paragraph>
<paragraph id="P-0088" lvl="0"><number>&lsqb;0088&rsqb;</number> Referring also to <cross-reference target="DRAWINGS">FIG. 18, a</cross-reference> method <highlight><bold>215</bold></highlight> for adjusting the time at which the transmit slot occurs in a given frame may be implemented using the sequencer <highlight><bold>60</bold></highlight>, the microprocessor <highlight><bold>34</bold></highlight> and a set of software instructions and may begin, for example, when the microprocessor <highlight><bold>34</bold></highlight> calculates a second offset value, denoted SECOND OFFSET, equal to an amount of time, T, by which the transmit slot should be either delayed or advanced within the next frame, <highlight><bold>504</bold></highlight>B. Conventionally, the time at which the transmit slot <highlight><bold>512</bold></highlight>B occurs is fixed relative to the time at which the receive slot <highlight><bold>510</bold></highlight>B occurs, i.e., the amount of time between the receive slot <highlight><bold>510</bold></highlight>B and the transmit slot <highlight><bold>512</bold></highlight>B is the same during each frame <highlight><bold>500</bold></highlight> <highlight><bold>502</bold></highlight>, <highlight><bold>504</bold></highlight>. If the length of the previous frame <highlight><bold>502</bold></highlight>B has been adjusted by an amount of time t, then the receive slot <highlight><bold>514</bold></highlight>B will be delayed by an amount of time t. However, as described above, as the distance separating the communication device <highlight><bold>12</bold></highlight> from the base station <highlight><bold>10</bold></highlight> increases, as has occurred in frame <highlight><bold>502</bold></highlight>B, the transmit slot <highlight><bold>512</bold></highlight>B must occur earlier so that information transmitted by the communication device <highlight><bold>12</bold></highlight> has sufficient time to reach the base station <highlight><bold>10</bold></highlight> at the start of the receive slot <highlight><bold>512</bold></highlight>A. Thus, the method <highlight><bold>215</bold></highlight> may begin when the microprocessor <highlight><bold>34</bold></highlight> calculates the value of SECOND OFFSET by determining the amount of time by which the transmit slot <highlight><bold>512</bold></highlight>B was either too late or too early relative to the frame <highlight><bold>502</bold></highlight> (step <highlight><bold>216</bold></highlight>). Next, the microprocessor <highlight><bold>34</bold></highlight> causes a value equal to SECOND OFFSET to be stored in the timing adjust register <highlight><bold>74</bold></highlight> (step <highlight><bold>218</bold></highlight>). The sequencer <highlight><bold>60</bold></highlight> may then adjust the value stored in the timebase counter <highlight><bold>64</bold></highlight> by an amount of time equal to SECOND OFFSET thereby causing the transmit slot to be either advanced or delayed by an amount of time equal to SECOND OFFSET (step <highlight><bold>220</bold></highlight>). The sequencer <highlight><bold>60</bold></highlight> may adjust the value stored in the timebase counter <highlight><bold>64</bold></highlight> by, for example, executing the &ldquo;TBADJSN d&rdquo; instruction <highlight><bold>142</bold></highlight>. As described above, the sequencer <highlight><bold>60</bold></highlight> causes the value in the timebase counter <highlight><bold>64</bold></highlight> to be advanced by an amount of time equal to the value stored in the timing adjust register if &ldquo;d&rdquo; is equal to one (1) thereby causing the transmit slot to begin earlier and the sequencer <highlight><bold>60</bold></highlight> causes the value in the timebase counter <highlight><bold>64</bold></highlight> to be delayed by an amount of time equal to the value stored in the timing adjust register if &ldquo;d&rdquo; is equal to zero (0) thereby causing the transmit slot to start later. The microprocessor <highlight><bold>34</bold></highlight> may cause the sequencer <highlight><bold>60</bold></highlight> to execute the TBADJSN instruction <highlight><bold>142</bold></highlight> by storing the address of the TBADJSN instruction <highlight><bold>142</bold></highlight> in the command register <highlight><bold>82</bold></highlight> or the TBADJSN instruction <highlight><bold>142</bold></highlight> may instead be stored at a location in the sequencer RAM <highlight><bold>62</bold></highlight> that ensures that the TBADJSN instruction <highlight><bold>142</bold></highlight> is executed once during every frame <highlight><bold>500</bold></highlight>, <highlight><bold>502</bold></highlight>, <highlight><bold>504</bold></highlight>. Of course, if no adjustment to the timing of the transmit slot <highlight><bold>512</bold></highlight>B is required for the frame <highlight><bold>502</bold></highlight>B, the microprocessor <highlight><bold>34</bold></highlight> may store a value of zero (0) in the timing adjust register <highlight><bold>74</bold></highlight> so that the timebase counter <highlight><bold>64</bold></highlight> is neither advanced nor delayed by the execution of the TBADJSN instruction <highlight><bold>142</bold></highlight> during the next frame <highlight><bold>504</bold></highlight>B. Further, the TBADJSN instruction <highlight><bold>142</bold></highlight> must be executed after the receive slot <highlight><bold>514</bold></highlight>B has ended so that the TBADJSN instruction <highlight><bold>142</bold></highlight> does not affect the time at which the receive slot <highlight><bold>514</bold></highlight>B occurs within the frame <highlight><bold>504</bold></highlight>B. As will be appreciated by one having ordinary skill in the art, the execution of the TBADJSN instruction <highlight><bold>142</bold></highlight> will affect the overall length of the frame for which the TBADJSN instruction <highlight><bold>142</bold></highlight> is executed. Thus, when calculating the value of the FIRST OFFSET to be stored in the timebase adjust register <highlight><bold>70</bold></highlight> for adjusting the length of the next frame, the microprocessor <highlight><bold>34</bold></highlight> may account for the amount of time by which the timebase counter <highlight><bold>64</bold></highlight> was either incremented or delayed during the current frame, i.e., SECOND OFFSET. Likewise, when calculating the value of the SECOND OFFSET for a current frame, the microprocessor <highlight><bold>34</bold></highlight> may account for the amount of time, i.e., FIRST OFFSET, by which the frame was lengthened or shortened during the previous frame. </paragraph>
<paragraph id="P-0089" lvl="0"><number>&lsqb;0089&rsqb;</number> Referring now to <cross-reference target="DRAWINGS">FIG. 19</cross-reference>, to illustrate the versatility of the system timer <highlight><bold>50</bold></highlight>, a variety of methods that may be used to cause the sequencer <highlight><bold>60</bold></highlight> to generate a set of system timer output waveforms referred to as SYSTIMER<highlight><bold>1</bold></highlight>, SYSTIMER<highlight><bold>2</bold></highlight> and ARM_INT are described. The output waveform SYSTIMER<highlight><bold>1</bold></highlight> may represent an RXWIN interrupt <highlight><bold>150</bold></highlight> signal such that when SYSTIMER<highlight><bold>1</bold></highlight> is at a logic level high, the sequencer <highlight><bold>60</bold></highlight> supplies an RXWIN interrupt signal <highlight><bold>150</bold></highlight> to the DSP <highlight><bold>36</bold></highlight>. In addition, the output waveform SYSTIMER<highlight><bold>2</bold></highlight> may represent a TXWIN interrupt <highlight><bold>152</bold></highlight> signal such that when SYSTIMER<highlight><bold>2</bold></highlight> is at a logic level high, the sequencer <highlight><bold>60</bold></highlight> supplies a TXWIN interrupt <highlight><bold>152</bold></highlight> signal to the DSP <highlight><bold>36</bold></highlight>. The ARM_INT <highlight><bold>122</bold></highlight> signal represents an interrupt signal supplied by the sequencer <highlight><bold>60</bold></highlight> to the microprocessor <highlight><bold>34</bold></highlight> for any desired purpose, such as, for example, to inform the microprocessor <highlight><bold>34</bold></highlight> as to when an event shall occur. Referring also to <cross-reference target="DRAWINGS">FIG. 20</cross-reference>, in a first method, a series of instructions <highlight><bold>222</bold></highlight> may be stored in the sequencer RAM <highlight><bold>62</bold></highlight> and executed by the sequencer <highlight><bold>60</bold></highlight> beginning with a TBWAIT 1000 instruction <highlight><bold>224</bold></highlight> that causes the sequencer <highlight><bold>60</bold></highlight> to wait until the timebase counter <highlight><bold>64</bold></highlight> is equal to a value of 1000. The next sequential RAM address may include an ARMINT <highlight><bold>3</bold></highlight> instruction <highlight><bold>226</bold></highlight> causing the sequencer <highlight><bold>60</bold></highlight> to send an interrupt signal to the microprocessor <highlight><bold>34</bold></highlight> and to further cause a type three interrupt to be indicated by the bits stored in the IS_SEQTYPE field of the ARM Interrupt Status Register. A type three interrupt may be defined to represent any desired type of interrupt. A SET <highlight><bold>1</bold></highlight>,<highlight><bold>1</bold></highlight>,<highlight><bold>1</bold></highlight> instruction <highlight><bold>228</bold></highlight> may follow the ARMINT <highlight><bold>3</bold></highlight> instruction thereby causing the sequencer <highlight><bold>60</bold></highlight> to generate a logic level high on the SYSTIMER<highlight><bold>1</bold></highlight> output which, as described above, causes an RXWIN interrupt signal <highlight><bold>150</bold></highlight> to be sent to the DSP <highlight><bold>36</bold></highlight>. The sequencer RAM <highlight><bold>62</bold></highlight> may then include a TBWAIT 2000 instruction <highlight><bold>230</bold></highlight> causing the sequencer <highlight><bold>60</bold></highlight> to wait until the timebase counter <highlight><bold>64</bold></highlight> is equal to 2000 before executing the next instruction stored in the sequencer RAM <highlight><bold>62</bold></highlight> which may comprise a CLR <highlight><bold>1</bold></highlight>,<highlight><bold>1</bold></highlight>,<highlight><bold>1</bold></highlight> instruction <highlight><bold>232</bold></highlight>. The CLR <highlight><bold>1</bold></highlight>,<highlight><bold>1</bold></highlight>,<highlight><bold>1</bold></highlight> instruction <highlight><bold>232</bold></highlight> causes the sequencer <highlight><bold>60</bold></highlight> to set the SYSTIMER<highlight><bold>1</bold></highlight> output equal to a logic level low thereby disabling the receiver. After the CLR <highlight><bold>1</bold></highlight>,<highlight><bold>1</bold></highlight>,<highlight><bold>1</bold></highlight> instruction <highlight><bold>232</bold></highlight>, the sequencer RAM <highlight><bold>62</bold></highlight> may include a TBWAIT 3000 instruction <highlight><bold>234</bold></highlight> causing the sequencer <highlight><bold>60</bold></highlight> to wait until the timebase counter <highlight><bold>64</bold></highlight> is equal to 3000 before executing the instruction located at the next sequential sequencer RAM address. The instruction located at the next sequential sequencer RAM <highlight><bold>62</bold></highlight> address may include a SET <highlight><bold>2</bold></highlight>,<highlight><bold>2</bold></highlight>,<highlight><bold>2</bold></highlight> instruction <highlight><bold>236</bold></highlight> which causes the sequencer <highlight><bold>60</bold></highlight> to place a logic level high on the SYSTIMER<highlight><bold>2</bold></highlight> output thereby causing a TXWIN interrupt signal <highlight><bold>152</bold></highlight> to be sent to the DSP <highlight><bold>36</bold></highlight>. A TBWAIT 5000 instruction <highlight><bold>238</bold></highlight> then causes the SYSTIMER<highlight><bold>2</bold></highlight> output signal to remain high until the timebase counter <highlight><bold>64</bold></highlight> is equal to a value of 5000. After the timebase counter <highlight><bold>64</bold></highlight> reaches 5000, a CLR <highlight><bold>2</bold></highlight>,<highlight><bold>2</bold></highlight>,<highlight><bold>2</bold></highlight> instruction <highlight><bold>240</bold></highlight> causes the sequencer <highlight><bold>60</bold></highlight> to set the SYSTIMER<highlight><bold>2</bold></highlight> output to a logic level zero causing the TXWIN interrupt signal <highlight><bold>152</bold></highlight> to be set at a logic level low so that the transmitter is disabled. After the CLR <highlight><bold>2</bold></highlight>,<highlight><bold>2</bold></highlight>,<highlight><bold>2</bold></highlight> instruction <highlight><bold>240</bold></highlight>, the sequencer RAM <highlight><bold>62</bold></highlight> may include a JCMD <highlight><bold>0</bold></highlight> instruction <highlight><bold>242</bold></highlight> that causes the sequencer <highlight><bold>60</bold></highlight> to jump to the address stored in the command register <highlight><bold>82</bold></highlight> provided that the command register <highlight><bold>82</bold></highlight> is not empty. If the command register <highlight><bold>82</bold></highlight> is empty, the sequencer <highlight><bold>60</bold></highlight> returns to the first address, i.e., address <highlight><bold>0</bold></highlight>, located in the sequencer RAM <highlight><bold>62</bold></highlight>. </paragraph>
<paragraph id="P-0090" lvl="0"><number>&lsqb;0090&rsqb;</number> Referring now to <cross-reference target="DRAWINGS">FIG. 21</cross-reference>, an alternative set of instructions <highlight><bold>244</bold></highlight> may also be used to generate the waveforms shown in <cross-reference target="DRAWINGS">FIG. 19</cross-reference>, depending on the setting of the MODE bits, A&prime;, B&prime;, C&prime;, D&prime; stored in the control register <highlight><bold>76</bold></highlight> and the status of the TX_ENA bit. Specifically, the set of instructions <highlight><bold>244</bold></highlight> include a set of strategically placed conditional JMP instructions <highlight><bold>114</bold></highlight> that may affect the sequence of the instructions executed by the sequencer <highlight><bold>60</bold></highlight>. For purposes of describing the operation of the sequencer <highlight><bold>60</bold></highlight> when executing the instructions of <cross-reference target="DRAWINGS">FIG. 21</cross-reference>, the mode bits A&prime;, B&prime;, C&prime; and D&prime; stored in the control register <highlight><bold>76</bold></highlight> are assumed to be set to <highlight><bold>1101</bold></highlight> and the TX_ENA bit is assumed to be set to a logic level high (1). As described above, the setting of each of the bits A, B, C, and D are defined in the &ldquo;ABCD&rdquo; field of the JMP instruction <highlight><bold>114</bold></highlight>. The set of instructions <highlight><bold>244</bold></highlight> begin with a conditional jump instruction <highlight><bold>246</bold></highlight> that causes the sequencer <highlight><bold>60</bold></highlight> to either jump to the sixth address stored in the sequencer RAM <highlight><bold>62</bold></highlight> (if &ldquo;RESULT&rdquo; is equal to zero) or to continue to the next consecutive instruction stored in the sequencer RAM <highlight><bold>62</bold></highlight>. Based on the setting of the MODE bits, A&prime;, B&prime;, C&prime; and D&prime;, the &ldquo;ABCD&rdquo; field and the setting of the TX_ENA bit, the conditional jump instruction <highlight><bold>246</bold></highlight> at the address zero in the sequencer RAM <highlight><bold>62</bold></highlight> causes RESULT to be equal to a logic level high (1) such that the sequencer <highlight><bold>60</bold></highlight> continues at the next consecutive instruction stored in the sequencer RAM <highlight><bold>62</bold></highlight>. The next five instructions <highlight><bold>248</bold></highlight>, <highlight><bold>250</bold></highlight>, <highlight><bold>252</bold></highlight>, <highlight><bold>254</bold></highlight>, <highlight><bold>256</bold></highlight> stored at sequencer RAM addresses one through five are identical to the instructions <highlight><bold>224</bold></highlight>, <highlight><bold>226</bold></highlight>, <highlight><bold>228</bold></highlight>, <highlight><bold>230</bold></highlight>, <highlight><bold>232</bold></highlight> stored in the sequencer RAM <highlight><bold>62</bold></highlight> addresses <highlight><bold>0</bold></highlight> through <highlight><bold>4</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 20</cross-reference> and, as a result, will cause the sequencer <highlight><bold>60</bold></highlight> to respond in the manner described above for the respective instructions. Thus, the sequencer <highlight><bold>60</bold></highlight> waits until the value stored in the timebase counter <highlight><bold>64</bold></highlight> is equal to 1000, generates a microprocessor interrupt signal, sets the SYSTIMER<highlight><bold>1</bold></highlight> output to a logic level high, waits until the value stored in the timebase counter <highlight><bold>64</bold></highlight> is equal to 2000 and then clears the SYSTIMER<highlight><bold>1</bold></highlight> output by setting the SYSTIMER<highlight><bold>1</bold></highlight> output equal to a logic level zero (0). After the instructions stored at sequencer RAM <highlight><bold>62</bold></highlight> addresses one through five are executed, the sequencer <highlight><bold>60</bold></highlight> executes the conditional jump instruction stored at sequencer RAM <highlight><bold>62</bold></highlight> address six. The conditional jump instruction <highlight><bold>258</bold></highlight> at address six in the sequencer RAM <highlight><bold>62</bold></highlight> causes RESULT to be equal to a logic level high (1) so that the sequencer <highlight><bold>60</bold></highlight> executes the next four consecutive instructions <highlight><bold>260</bold></highlight>, <highlight><bold>262</bold></highlight>, <highlight><bold>264</bold></highlight>, <highlight><bold>266</bold></highlight> stored in the sequencer RAM <highlight><bold>62</bold></highlight>, i.e., sequencer RAM <highlight><bold>62</bold></highlight> addresses seven through ten. The instructions <highlight><bold>260</bold></highlight>, <highlight><bold>262</bold></highlight>, <highlight><bold>264</bold></highlight>, <highlight><bold>266</bold></highlight> stored at sequencer RAM <highlight><bold>62</bold></highlight> addresses seven through ten are identical to the instructions <highlight><bold>234</bold></highlight>, <highlight><bold>236</bold></highlight>, <highlight><bold>238</bold></highlight>, <highlight><bold>240</bold></highlight> shown in <cross-reference target="DRAWINGS">FIG. 20</cross-reference> as being stored at sequencer RAM <highlight><bold>62</bold></highlight> addresses five through eight. Thus, the instructions <highlight><bold>260</bold></highlight>, <highlight><bold>262</bold></highlight>, <highlight><bold>264</bold></highlight>, <highlight><bold>266</bold></highlight> stored at sequencer RAM <highlight><bold>62</bold></highlight> addresses seven through ten cause the sequencer <highlight><bold>60</bold></highlight> to perform the same tasks as described above for the corresponding instructions of <cross-reference target="DRAWINGS">FIG. 20</cross-reference>. Specifically, the sequencer <highlight><bold>60</bold></highlight> waits until the value stored in the timebase counter <highlight><bold>64</bold></highlight> is equal to 3000, sets the SYSTIMER<highlight><bold>2</bold></highlight> output equal to a logic level high, waits until the value stored in the timebase counter <highlight><bold>64</bold></highlight> is equal to 5000 and then clears the SYSTIMER<highlight><bold>2</bold></highlight> output. After executing the instructions stored at sequencer RAM <highlight><bold>62</bold></highlight> addresses seven through ten, the sequencer <highlight><bold>60</bold></highlight> encounters a conditional jump instruction <highlight><bold>268</bold></highlight> at the next, consecutive sequencer RAM address eleven. The conditional jump instruction <highlight><bold>268</bold></highlight> causes RESULT to be equal to a logic level zero such that the sequencer <highlight><bold>60</bold></highlight> jumps to the instruction <highlight><bold>278</bold></highlight> stored at sequencer RAM address sixteen thereby skipping over, i.e., not executing, the instructions <highlight><bold>270</bold></highlight>, <highlight><bold>272</bold></highlight>, <highlight><bold>274</bold></highlight>, <highlight><bold>276</bold></highlight> stored at the sequencer RAM addresses twelve through fifteen. At sequencer RAM <highlight><bold>62</bold></highlight> address sixteen, the sequencer <highlight><bold>60</bold></highlight> encounters another conditional jump instruction <highlight><bold>278</bold></highlight>. The conditional jump instruction <highlight><bold>278</bold></highlight> stored at sequencer RAM address sixteen causes RESULT to be equal to zero so that the sequencer <highlight><bold>60</bold></highlight> jumps to the sequencer RAM <highlight><bold>62</bold></highlight> address specified in the address field of the conditional jump instruction <highlight><bold>278</bold></highlight>, i.e., sequencer RAM <highlight><bold>62</bold></highlight> address twenty one, thereby skipping the instructions <highlight><bold>280</bold></highlight>, <highlight><bold>282</bold></highlight>, <highlight><bold>284</bold></highlight>, <highlight><bold>286</bold></highlight> stored in the sequencer RAM <highlight><bold>62</bold></highlight> addresses seventeen through twenty. The instruction <highlight><bold>288</bold></highlight> stored in sequencer RAM address twenty one, i.e., JCMD <highlight><bold>0</bold></highlight>, causes the sequencer <highlight><bold>60</bold></highlight> to either jump to sequencer RAM address zero or to the address stored in the command register <highlight><bold>82</bold></highlight>, depending on whether the command register <highlight><bold>82</bold></highlight> is empty. Thus, the settings of the mode bits A&prime;, B&prime;, C&prime; and D&prime; and the setting of the TX_ENA bit cause the sequencer <highlight><bold>60</bold></highlight> to skip the instructions stored in the sequencer RAM <highlight><bold>62</bold></highlight> at the addresses twelve through fifteen and seventeen through twenty thereby allowing the waveforms shown in <cross-reference target="DRAWINGS">FIG. 19</cross-reference> to be generated. Of course, the microprocessor <highlight><bold>34</bold></highlight> may instead set the bits A&prime;, B&prime;, C&prime; and D&prime; in a manner that causes the sequencer <highlight><bold>60</bold></highlight> to execute the instructions stored at the addresses twelve through fifteen and seventeen through twenty thereby lending flexibility and versatility to the capabilities of the sequencer <highlight><bold>60</bold></highlight> and thus the communication device <highlight><bold>12</bold></highlight>. </paragraph>
<paragraph id="P-0091" lvl="0"><number>&lsqb;0091&rsqb;</number> Referring now to <cross-reference target="DRAWINGS">FIG. 22</cross-reference>, alternatively, the waveforms of <cross-reference target="DRAWINGS">FIG. 19</cross-reference> may also be generated under the control of the microprocessor <highlight><bold>34</bold></highlight> using the conditional jump capabilities provided by the JCMD instruction <highlight><bold>112</bold></highlight>. More particularly, the instructions described with respect to <cross-reference target="DRAWINGS">FIG. 20</cross-reference> may be populated with strategically placed JCMD instructions <highlight><bold>112</bold></highlight> that allow the microprocessor <highlight><bold>34</bold></highlight> to control the sequence at which the instructions are executed. Further, the microprocessor <highlight><bold>34</bold></highlight> may store the following set of sequencer RAM addresses in the command register <highlight><bold>82</bold></highlight>: one, six, eight, eleven and thirteen. As described above, the microprocessor <highlight><bold>34</bold></highlight> may write to the command register <highlight><bold>82</bold></highlight> at the beginning of each frame thereby preventing the need for the microprocessor <highlight><bold>34</bold></highlight> to continuously update the instructions stored in the sequencer RAM <highlight><bold>62</bold></highlight> as timing data becomes available from the base station <highlight><bold>10</bold></highlight>. Thus, for example, a set of instructions <highlight><bold>290</bold></highlight> may be stored in the sequencer RAM <highlight><bold>62</bold></highlight> and may begin at an address zero with a JCMD <highlight><bold>1</bold></highlight> instruction <highlight><bold>292</bold></highlight> that causes the sequencer <highlight><bold>60</bold></highlight> to execute the instruction <highlight><bold>294</bold></highlight> stored at sequencer RAM address one. Note that, as described above, the JCMD instruction <highlight><bold>112</bold></highlight> causes the sequencer <highlight><bold>60</bold></highlight> to jump to an address stored in the command register <highlight><bold>82</bold></highlight>, unless the command register <highlight><bold>82</bold></highlight> is empty in which case the sequencer <highlight><bold>60</bold></highlight> instead jumps to the address specified in the address field of the JCMD instruction <highlight><bold>112</bold></highlight>. In this instance, the address stored in the command register <highlight><bold>82</bold></highlight> and the address specified in the JCMD instruction <highlight><bold>292</bold></highlight> are identical thereby causing the JCMD instruction <highlight><bold>292</bold></highlight> to operate as an unconditional jump. Thus, the sequencer <highlight><bold>60</bold></highlight> proceeds to execute the instructions stored at sequencer RAM address one and, subsequently, the instructions stored at sequencer RAM addresses two through four. The instructions <highlight><bold>294</bold></highlight>, <highlight><bold>296</bold></highlight>, <highlight><bold>298</bold></highlight> stored in the sequencer RAM <highlight><bold>62</bold></highlight> address numbers one through three of <cross-reference target="DRAWINGS">FIG. 23</cross-reference> are identical to the instructions <highlight><bold>224</bold></highlight>, <highlight><bold>226</bold></highlight>, <highlight><bold>228</bold></highlight> stored at sequencer RAM addresses zero through two of <cross-reference target="DRAWINGS">FIG. 20</cross-reference>, and thus, cause the sequencer <highlight><bold>60</bold></highlight> to perform an identical set of tasks, i.e., wait until the value stored in the timebase counter <highlight><bold>64</bold></highlight> is equal to 1000, supply a type-three interrupt to the microprocessor <highlight><bold>34</bold></highlight> and then set the SYSTIMER<highlight><bold>1</bold></highlight> output to a logic level high. After setting the SYSTIMER<highlight><bold>1</bold></highlight> output, the sequencer <highlight><bold>60</bold></highlight> executes an RTBWAIT 1000 instruction <highlight><bold>300</bold></highlight> stored at sequencer RAM address four. The RTBWAIT instruction <highlight><bold>300</bold></highlight> causes the sequencer <highlight><bold>60</bold></highlight> to wait for <highlight><bold>1000</bold></highlight> clock counts to elapse before executing the next, consecutive instruction <highlight><bold>302</bold></highlight>. After 1000 clock counts have elapsed, the sequencer <highlight><bold>60</bold></highlight> encounters a JCMD <highlight><bold>6</bold></highlight> instruction <highlight><bold>302</bold></highlight> at sequencer RAM address five causing the sequencer <highlight><bold>60</bold></highlight> to execute the CLR <highlight><bold>1</bold></highlight>,<highlight><bold>1</bold></highlight>,<highlight><bold>1</bold></highlight> instruction <highlight><bold>304</bold></highlight> stored at sequencer RAM address six by setting the SYSTIMER<highlight><bold>1</bold></highlight> output to a logic level low. After setting the SYSTIMER<highlight><bold>1</bold></highlight> output low, the sequencer <highlight><bold>60</bold></highlight> executes a JCMD <highlight><bold>8</bold></highlight> instruction <highlight><bold>306</bold></highlight> stored at sequencer RAM address seven causing the sequencer <highlight><bold>60</bold></highlight> to jump to an instruction <highlight><bold>308</bold></highlight> stored at sequencer RAM address eight. At sequencer RAM address eight, the sequencer <highlight><bold>60</bold></highlight> executes a &ldquo;TBADJSN <highlight><bold>0</bold></highlight>&rdquo; instruction <highlight><bold>308</bold></highlight> causing the sequencer <highlight><bold>60</bold></highlight> to decrement the value in the timebase counter <highlight><bold>64</bold></highlight> by the value stored in the timing adjust register <highlight><bold>74</bold></highlight>. Assuming, for example, that the value stored in the timing adjust register <highlight><bold>74</bold></highlight> is equal to 1000, then the value in the timebase counter <highlight><bold>64</bold></highlight>, which is currently equal to 2000, is decreased to a value of 1000. After decrementing the timebase counter <highlight><bold>64</bold></highlight>, the sequencer <highlight><bold>60</bold></highlight> executes an RTBWVAIT 2000 instruction <highlight><bold>310</bold></highlight> stored at the sequencer RAM <highlight><bold>62</bold></highlight> address nine which causes the sequencer <highlight><bold>60</bold></highlight> to wait until 2000 clock counts have elapsed before executing a SET <highlight><bold>2</bold></highlight>,<highlight><bold>2</bold></highlight>,<highlight><bold>2</bold></highlight> instruction <highlight><bold>312</bold></highlight> causing the sequencer <highlight><bold>60</bold></highlight> to set the SYSTIMER<highlight><bold>2</bold></highlight> output to a logic level high. Next, the sequencer <highlight><bold>60</bold></highlight> executes an RTBWAIT 1000 instruction <highlight><bold>314</bold></highlight> at sequencer RAM address eleven causing the sequencer <highlight><bold>60</bold></highlight> to wait for 1000 clock counts to elapse before executing a JCMD <highlight><bold>13</bold></highlight> instruction <highlight><bold>310</bold></highlight> stored at sequencer RAM address twelve. The sequencer <highlight><bold>60</bold></highlight> then executes the instruction stored at sequencer RAM address eleven causing the sequencer <highlight><bold>60</bold></highlight> to again wait for 1000 clock counts to elapse. During the 2000 clock counts that elapse while executing the RTBWAIT 1000 instruction <highlight><bold>314</bold></highlight> stored at the sequencer RAM <highlight><bold>62</bold></highlight> address number eleven twice consecutively, the SYSTIMER<highlight><bold>2</bold></highlight> output is maintained at a logic level high. Thereafter, the sequencer <highlight><bold>60</bold></highlight> again encounters, the JCMD <highlight><bold>13</bold></highlight> instruction <highlight><bold>316</bold></highlight>, this time causing the sequencer <highlight><bold>60</bold></highlight> to jump to sequencer RAM <highlight><bold>62</bold></highlight> address thirteen. At sequencer RAM address thirteen, the sequencer <highlight><bold>60</bold></highlight> is instructed to set the SYSTIMER<highlight><bold>2</bold></highlight> output to a logic level low via a CLR <highlight><bold>2</bold></highlight>,<highlight><bold>2</bold></highlight>,<highlight><bold>2</bold></highlight> instruction <highlight><bold>318</bold></highlight>. Next, the sequencer <highlight><bold>60</bold></highlight> executes the instruction <highlight><bold>320</bold></highlight> stored at sequencer RAM address fourteen causing the sequencer <highlight><bold>60</bold></highlight> to increment the value stored in the timebase counter <highlight><bold>64</bold></highlight> by the value stored in the timing adjust register <highlight><bold>74</bold></highlight>, i.e., 1000, thereby causing the value stored in the timebase counter <highlight><bold>64</bold></highlight> to be equal to 6000. After the timebase counter <highlight><bold>64</bold></highlight> has been adjusted, the sequencer <highlight><bold>60</bold></highlight> executes a JCMD <highlight><bold>0</bold></highlight> instruction <highlight><bold>322</bold></highlight> causing the sequencer <highlight><bold>60</bold></highlight> to jump back to the sequencer RAM <highlight><bold>62</bold></highlight> address zero because the command register <highlight><bold>82</bold></highlight> is empty. </paragraph>
<paragraph id="P-0092" lvl="0"><number>&lsqb;0092&rsqb;</number> Referring now to <cross-reference target="DRAWINGS">FIGS. 23A and 23B</cross-reference>, the system timer <highlight><bold>50</bold></highlight> may also be programmed to execute a set of generic program blocks having any desired set of instructions. Moreover, each generic program block may be stored at a specific memory location in the sequencer RAM <highlight><bold>62</bold></highlight> such that the microprocessor <highlight><bold>34</bold></highlight> may cause the sequencer <highlight><bold>60</bold></highlight> to execute a desired one of the generic program blocks by writing the starting address of the desired generic program block into the command register <highlight><bold>82</bold></highlight>. As described above, the sequencer <highlight><bold>60</bold></highlight> will jump to the address stored in the command register <highlight><bold>82</bold></highlight> when the sequencer <highlight><bold>60</bold></highlight> executes a JCMD instruction <highlight><bold>112</bold></highlight> or when the microprocessor <highlight><bold>34</bold></highlight> causes the RESET bits <highlight><bold>78</bold></highlight> in the command register <highlight><bold>82</bold></highlight> to be set to a value of &ldquo;001.&rdquo; Thus, the system timer <highlight><bold>50</bold></highlight> is not limited to generating only the waveforms that are defined according to the instructions stored in the sequencer RAM <highlight><bold>62</bold></highlight> but may instead generate waveforms having any desired pattern using generic program blocks. For illustrative purposes, a set of eight generic program blocks are described below. However, any number of instructions arranged in any desired order may be used to create any number of generic program blocks such that the eight generic program blocks described herein are intended to be exemplary only. </paragraph>
<paragraph id="P-0093" lvl="0"><number>&lsqb;0093&rsqb;</number> Referring specifically to <cross-reference target="DRAWINGS">FIG. 23A, a</cross-reference> first of the generic program blocks <highlight><bold>324</bold></highlight>, denoted &ldquo;FIRST Program,&rdquo; provides time during which any steps necessary to set up the RF hardware devices <highlight><bold>40</bold></highlight> may be performed and may be implemented using a TBWAIT 50 instruction <highlight><bold>326</bold></highlight> that causes the system timer <highlight><bold>50</bold></highlight> to wait until the timebase counter <highlight><bold>64</bold></highlight> is equal to a value of fifty (50) and may further use a JCMD instruction <highlight><bold>328</bold></highlight> that causes the sequencer <highlight><bold>60</bold></highlight> to jump to the address stored in the command register <highlight><bold>82</bold></highlight> unless the command register <highlight><bold>82</bold></highlight> is empty in which case the sequencer <highlight><bold>60</bold></highlight> instead jumps to address zero in the sequencer RAM <highlight><bold>62</bold></highlight>. As will be understood by one having ordinary skill in the art, the amount of time necessary to allow the system setup functions to occur may vary depending upon the RF hardware devices <highlight><bold>40</bold></highlight> installed in the communication device <highlight><bold>12</bold></highlight> and will typically be determined via testing of the RF hardware devices <highlight><bold>40</bold></highlight>. </paragraph>
<paragraph id="P-0094" lvl="0"><number>&lsqb;0094&rsqb;</number> A second of the generic program blocks <highlight><bold>330</bold></highlight>, denoted &ldquo;RXSTART Program,&rdquo; may be used to enable the receiver and may include an RTBWAIT 30 instruction <highlight><bold>332</bold></highlight> that causes the system timer to wait for thirty clock counts to elapse and may further include a SET <highlight><bold>1</bold></highlight>,<highlight><bold>1</bold></highlight>,<highlight><bold>1</bold></highlight> instruction <highlight><bold>334</bold></highlight> that causes the system timer to set SYSTIMER<highlight><bold>1</bold></highlight> output to a logic level high. The SYSTIMER<highlight><bold>1</bold></highlight> output may be coupled to, for example, a portion of the RF hardware devices <highlight><bold>40</bold></highlight> that are associated with setting the receiver to a desired receive frequency. Alternatively, the SYSTIMER<highlight><bold>1</bold></highlight> output may be coupled to any other portion of the RF hardware devices <highlight><bold>40</bold></highlight> that are associated with preparing the receiver for operation. Next, the RXSTART Program <highlight><bold>330</bold></highlight> may include an RTBWAIT 20 instruction <highlight><bold>336</bold></highlight> causing the sequencer <highlight><bold>60</bold></highlight> to wait for twenty clock counts to elapse followed by an RXENA instruction <highlight><bold>338</bold></highlight> causing the sequencer <highlight><bold>60</bold></highlight> to enable the receiver associated with the RF hardware devices <highlight><bold>40</bold></highlight>. The RXSTART Program <highlight><bold>330</bold></highlight> may further include an RTBWAIT 50 instruction <highlight><bold>340</bold></highlight> causing the sequencer <highlight><bold>60</bold></highlight> to wait fifty clock counts from the current timebase value before executing a JCMD <highlight><bold>0</bold></highlight> instruction <highlight><bold>342</bold></highlight>. As described above, the JCMD <highlight><bold>0</bold></highlight> instruction <highlight><bold>342</bold></highlight> causes the sequencer <highlight><bold>60</bold></highlight> to either jump to the address stored in the command register <highlight><bold>82</bold></highlight> or to the address specified in the address field of the JCMD instruction <highlight><bold>342</bold></highlight> depending on whether the command register <highlight><bold>82</bold></highlight> is empty. </paragraph>
<paragraph id="P-0095" lvl="0"><number>&lsqb;0095&rsqb;</number> A third of the generic program blocks <highlight><bold>344</bold></highlight>, denoted &ldquo;RXEND Program,&rdquo; may be used to disable the receiver and may include an RTBWAIT 50 instruction <highlight><bold>346</bold></highlight> that causes the sequencer <highlight><bold>60</bold></highlight> to wait for fifty clock counts to elapse before disabling the receiver using an RXDIS instruction <highlight><bold>348</bold></highlight>. After the RXDIS instruction <highlight><bold>348</bold></highlight>, the RXEND program <highlight><bold>344</bold></highlight> may include an RTBWAIT 20 instruction <highlight><bold>350</bold></highlight> causing the sequencer <highlight><bold>60</bold></highlight> to wait for twenty clock counts to elapse from the current value of the timebase counter <highlight><bold>64</bold></highlight> before executing a CLR <highlight><bold>1</bold></highlight>,<highlight><bold>1</bold></highlight>,<highlight><bold>1</bold></highlight> instruction <highlight><bold>352</bold></highlight> that causes the sequencer <highlight><bold>60</bold></highlight> to clear SYSTIMER<highlight><bold>1</bold></highlight> output so that the receiver associated with the RF hardware devices <highlight><bold>40</bold></highlight> is disabled. After the CLR <highlight><bold>1</bold></highlight>,<highlight><bold>1</bold></highlight>,<highlight><bold>1</bold></highlight> instruction <highlight><bold>352</bold></highlight>, the RXEND program <highlight><bold>344</bold></highlight> may include an RTBWAIT 30 instruction <highlight><bold>354</bold></highlight> causing the system timer to wait for thirty clock counts to elapse before executing a JCMD <highlight><bold>0</bold></highlight> instruction <highlight><bold>356</bold></highlight> that causes the sequencer <highlight><bold>60</bold></highlight> to either jump to an address in the command register <highlight><bold>82</bold></highlight> or to the next address stored in the sequencer RAM <highlight><bold>62</bold></highlight>, depending on whether the command register <highlight><bold>82</bold></highlight> is empty. </paragraph>
<paragraph id="P-0096" lvl="0"><number>&lsqb;0096&rsqb;</number> A fourth of the generic program blocks <highlight><bold>358</bold></highlight>, denoted &ldquo;TXSTART Program,&rdquo; may be used to enable the transmitter and may include an RTBWAIT 29 instruction <highlight><bold>360</bold></highlight> that causes the sequencer <highlight><bold>60</bold></highlight> to wait for twenty nine clock counts to elapse before setting a SYSTIMER<highlight><bold>2</bold></highlight> output using a SET <highlight><bold>2</bold></highlight>,<highlight><bold>2</bold></highlight>,<highlight><bold>2</bold></highlight> instruction <highlight><bold>362</bold></highlight>. The SYSTIMER<highlight><bold>2</bold></highlight> output may be used to control any of a portion of the RF hardware devices <highlight><bold>40</bold></highlight> that are used to prepare the transmitter for operation. After the SET <highlight><bold>2</bold></highlight>,<highlight><bold>2</bold></highlight>,<highlight><bold>2</bold></highlight> instruction <highlight><bold>362</bold></highlight>, the TXSTART program <highlight><bold>358</bold></highlight> may include an RTBWAIT 20 instruction <highlight><bold>364</bold></highlight> that causes the sequencer <highlight><bold>60</bold></highlight> to wait for twenty clock counts to elapse before executing a TXSTART instruction <highlight><bold>366</bold></highlight> that causes the sequencer <highlight><bold>60</bold></highlight> to enable the transmitter. After executing the TXSTART instruction <highlight><bold>366</bold></highlight>, the sequencer <highlight><bold>60</bold></highlight> may encounter an RTBWAIT 50 instruction <highlight><bold>368</bold></highlight> causing the sequencer <highlight><bold>60</bold></highlight> to wait for fifty counts to elapse before executing a JCMD <highlight><bold>0</bold></highlight> instruction <highlight><bold>370</bold></highlight> that causes the sequencer <highlight><bold>60</bold></highlight> to either jump to an address in the command register <highlight><bold>82</bold></highlight> or to an address specified in the address field of the JCMD instruction, depending on whether the command register <highlight><bold>82</bold></highlight> is empty. </paragraph>
<paragraph id="P-0097" lvl="0"><number>&lsqb;0097&rsqb;</number> Referring specifically to <cross-reference target="DRAWINGS">FIG. 23B, a</cross-reference> fifth of the generic program blocks <highlight><bold>372</bold></highlight>, denoted &ldquo;TXEND Program,&rdquo; may be used to disable the transmitter and may include an RTBWAIT 70 instruction <highlight><bold>374</bold></highlight> that causes the sequencer <highlight><bold>60</bold></highlight> to wait for seventy clock counts to elapse before clearing the SYSTIMER<highlight><bold>2</bold></highlight> output using a CLR <highlight><bold>2</bold></highlight>,<highlight><bold>2</bold></highlight>,<highlight><bold>2</bold></highlight> instruction <highlight><bold>376</bold></highlight>. After the CLR <highlight><bold>2</bold></highlight>,<highlight><bold>2</bold></highlight>,<highlight><bold>2</bold></highlight> instruction <highlight><bold>376</bold></highlight>, the TXEND Program <highlight><bold>372</bold></highlight> may include an RTBWAIT 30 instruction <highlight><bold>378</bold></highlight> that causes the sequencer <highlight><bold>60</bold></highlight> to wait for thirty clock counts to elapse before executing a JCMD <highlight><bold>0</bold></highlight> instruction <highlight><bold>380</bold></highlight> that causes the sequencer <highlight><bold>60</bold></highlight> to either jump to an address in the command register <highlight><bold>82</bold></highlight> or to the address specified in an address field of the JCMD instruction, depending on whether the command register <highlight><bold>82</bold></highlight> is empty. </paragraph>
<paragraph id="P-0098" lvl="0"><number>&lsqb;0098&rsqb;</number> A sixth of the generic program blocks <highlight><bold>382</bold></highlight>, denoted &ldquo;REPEAT Program,&rdquo; may be used to pause the operation of the sequencer <highlight><bold>60</bold></highlight> for a desired length of time by including an RTBWAIT 100 <highlight><bold>1</bold></highlight>nstruction <highlight><bold>384</bold></highlight> that causes the sequencer <highlight><bold>60</bold></highlight> to wait for 100 clock counts to elapse before executing a JCMD <highlight><bold>0</bold></highlight> instruction <highlight><bold>386</bold></highlight> that causes the sequencer <highlight><bold>60</bold></highlight> to either jump to an address stored in the command register <highlight><bold>82</bold></highlight> or to an address specified in the address field of the JCMD instruction <highlight><bold>386</bold></highlight>, depending on whether the command register <highlight><bold>82</bold></highlight> is empty. </paragraph>
<paragraph id="P-0099" lvl="0"><number>&lsqb;0099&rsqb;</number> A seventh of the generic program blocks <highlight><bold>388</bold></highlight>, denoted &ldquo;LAST Program,&rdquo; may be used to pause the operation of the sequencer <highlight><bold>60</bold></highlight> between the end of the TXEND Program <highlight><bold>372</bold></highlight> and the beginning of the next frame by including an RTBWAIT 50 instruction <highlight><bold>390</bold></highlight> that causes the sequencer <highlight><bold>60</bold></highlight> to wait for fifty clock counts to elapse before executing a JCMD <highlight><bold>0</bold></highlight> instruction <highlight><bold>392</bold></highlight> that causes the sequencer <highlight><bold>60</bold></highlight> to either jump to an address stored in the command register <highlight><bold>82</bold></highlight> or to an address specified in the address field of the JCMD instruction <highlight><bold>392</bold></highlight>, depending on whether the command register <highlight><bold>82</bold></highlight> is empty. Preferably, the amount of time that the sequencer <highlight><bold>60</bold></highlight> waits due to the RTBWAIT instruction <highlight><bold>390</bold></highlight> is sufficient to reach the end of the frame. </paragraph>
<paragraph id="P-0100" lvl="0"><number>&lsqb;0100&rsqb;</number> An eighth of the generic program blocks <highlight><bold>394</bold></highlight>, denoted &ldquo;ADVANCE Program,&rdquo; may be used to advance the timebase counter <highlight><bold>64</bold></highlight> by including a TBADJSN <highlight><bold>0</bold></highlight> instruction <highlight><bold>396</bold></highlight> that causes the sequencer <highlight><bold>60</bold></highlight> to decrement the timebase counter <highlight><bold>64</bold></highlight> by an amount of time equal to the value stored in the timing adjust register <highlight><bold>74</bold></highlight>. After the TBADJSN instruction <highlight><bold>396</bold></highlight>, the ADVANCE Program <highlight><bold>394</bold></highlight> may include a JCMD <highlight><bold>0</bold></highlight> instruction <highlight><bold>397</bold></highlight> that causes the sequencer <highlight><bold>60</bold></highlight> to jump to an address stored in the command register <highlight><bold>82</bold></highlight> or to the next address stored in the sequencer RAM <highlight><bold>62</bold></highlight>, depending on whether the command register <highlight><bold>82</bold></highlight> is empty. A ninth of the generic program blocks <highlight><bold>400</bold></highlight>, referred to as &ldquo;RETARD Program&rdquo; may be used to retard the timebase counter <highlight><bold>64</bold></highlight> and may be identical to the ADVANCE Program <highlight><bold>394</bold></highlight> except that a TBADJSN instruction <highlight><bold>402</bold></highlight> included in the RETARD Program <highlight><bold>394</bold></highlight> will be formatted as &ldquo;TBADJSN <highlight><bold>1</bold></highlight>&rdquo; so that the timebase counter <highlight><bold>64</bold></highlight> is decremented by an amount of time equal to the value stored in the timing adjust register <highlight><bold>74</bold></highlight>. </paragraph>
<paragraph id="P-0101" lvl="0"><number>&lsqb;0101&rsqb;</number> Referring also to <cross-reference target="DRAWINGS">FIG. 24</cross-reference>, the generic program blocks may be used, for example, to program the system timer <highlight><bold>50</bold></highlight> to generate waveforms that allow the communication device <highlight><bold>12</bold></highlight> to operate in a multi-slot communication environment. As will be understood by one having ordinary skill in the art, a multi-slot communication environment is an environment in which the communication device <highlight><bold>12</bold></highlight> is assigned more than one receive and/or transmit slot per frame allowing more data to be transmitted/received by the communication device <highlight><bold>12</bold></highlight> per frame. Thus, for example, a waveform having three receive slots <highlight><bold>412</bold></highlight>, <highlight><bold>414</bold></highlight>, <highlight><bold>416</bold></highlight>, two of which <highlight><bold>414</bold></highlight>, <highlight><bold>416</bold></highlight> occur sequentially, and one transmit slot <highlight><bold>418</bold></highlight> may be generated by loading the starting addresses of the following generic program blocks into the command register <highlight><bold>82</bold></highlight> at the beginning of a frame: 1) FIRST program <highlight><bold>324</bold></highlight>; 2) RXSTART program <highlight><bold>330</bold></highlight>; 3) RXEND program <highlight><bold>344</bold></highlight>; 4) RXSTART program <highlight><bold>330</bold></highlight>; 5) REPEAT program <highlight><bold>382</bold></highlight>; 6) RXEND program <highlight><bold>344</bold></highlight>; 7) TXSTART program <highlight><bold>394</bold></highlight>; 8) TXEND program <highlight><bold>372</bold></highlight> and 9) LAST program <highlight><bold>388</bold></highlight>. </paragraph>
<paragraph id="P-0102" lvl="0"><number>&lsqb;0102&rsqb;</number> Referring also to <cross-reference target="DRAWINGS">FIG. 25</cross-reference>, and by way of further example, generic program blocks may also be used to program the system timer <highlight><bold>50</bold></highlight> to generate a waveform <highlight><bold>420</bold></highlight> having three receive slots <highlight><bold>422</bold></highlight>, <highlight><bold>424</bold></highlight>, <highlight><bold>426</bold></highlight>, two <highlight><bold>424</bold></highlight>, <highlight><bold>426</bold></highlight> of which occur sequentially, and one transmit slot <highlight><bold>428</bold></highlight> and further including an adjustment <highlight><bold>430</bold></highlight> to the timebase counter <highlight><bold>64</bold></highlight>. Specifically, the waveform <highlight><bold>420</bold></highlight> may be generated by loading the starting addresses of the following generic program blocks into the command register <highlight><bold>82</bold></highlight> at the beginning of a frame: 1) FIRST program <highlight><bold>324</bold></highlight>; 2) RXSTART program <highlight><bold>330</bold></highlight>; 3) RXEND program <highlight><bold>344</bold></highlight>; 4) RXSTART program <highlight><bold>330</bold></highlight>; 5) REPEAT program <highlight><bold>382</bold></highlight>; 6) RXEND program <highlight><bold>344</bold></highlight>; 7) ADVANCE program <highlight><bold>394</bold></highlight>; 8) TXSTART program <highlight><bold>358</bold></highlight>; 9) TXEND program <highlight><bold>372</bold></highlight>; 10) RETARD program <highlight><bold>400</bold></highlight>; and 11) LAST program <highlight><bold>388</bold></highlight>. The ADVANCE program <highlight><bold>394</bold></highlight> included in the command register <highlight><bold>82</bold></highlight> for generating the waveform <highlight><bold>420</bold></highlight> causes the transmit slot <highlight><bold>428</bold></highlight> to occur earlier and the RETARD program <highlight><bold>400</bold></highlight> is used to compensate for the timing adjustment caused by the ADVANCE program <highlight><bold>394</bold></highlight> so that the overall frame length is not altered by the timing adjustments made during the ADVANCE program <highlight><bold>394</bold></highlight>. </paragraph>
<paragraph id="P-0103" lvl="0"><number>&lsqb;0103&rsqb;</number> Referring now to <cross-reference target="DRAWINGS">FIG. 26</cross-reference>, the system timer <highlight><bold>50</bold></highlight> may also be used, in conjunction with the synthesizer interface <highlight><bold>46</bold></highlight> to control multiple serial devices such as, for example, multiple frequency synthesizers <highlight><bold>44</bold></highlight>. Specifically, the system timer <highlight><bold>50</bold></highlight> may control the rate at which data signals are supplied by the synthesizer interface <highlight><bold>46</bold></highlight> to the serial devices via SYNSEND instructions <highlight><bold>126</bold></highlight>. As described above, the SYNSEND instruction <highlight><bold>126</bold></highlight> causes the sequencer <highlight><bold>60</bold></highlight> to supply a signal to the synthesizer interface <highlight><bold>46</bold></highlight> that, in turn, causes the synthesizer interface <highlight><bold>46</bold></highlight> to supply frequency data to the frequency synthesizer <highlight><bold>44</bold></highlight>. The system timer <highlight><bold>50</bold></highlight> may further be coupled to supply signals to the serial frequency synthesizers <highlight><bold>44</bold></highlight> thereby enabling the serial frequency synthesizers <highlight><bold>44</bold></highlight> to receive the frequency data signals supplied by the synthesizer interface <highlight><bold>46</bold></highlight>. From the foregoing description, it should be understood that a system timer for use in controlling the timing at which a mobile device communicates with a base station has been shown and described, having many desirable attributes and advantages. In particular, the system timer <highlight><bold>50</bold></highlight> allows the microprocessor <highlight><bold>34</bold></highlight> to control the sequence in which instructions are executed by the system timer <highlight><bold>50</bold></highlight> to thereby facilitate communication using multiple signal formats. Specifically, the system timer includes a command register <highlight><bold>82</bold></highlight> that may be used in conjunction with a JCMD instruction <highlight><bold>112</bold></highlight> that, when executed by a sequencer <highlight><bold>60</bold></highlight> disposed in the system timer <highlight><bold>50</bold></highlight>, causes the sequencer to conditionally jump to the instruction located at an address stored in the command register <highlight><bold>82</bold></highlight> or to instead jump to an address specified in the JCMD instruction, depending on whether the command register <highlight><bold>82</bold></highlight> is empty. </paragraph>
<paragraph id="P-0104" lvl="0"><number>&lsqb;0104&rsqb;</number> In addition, the system timer <highlight><bold>50</bold></highlight> includes a timebase counter <highlight><bold>64</bold></highlight>, a time base counter length register <highlight><bold>68</bold></highlight>, a timebase adjust register <highlight><bold>70</bold></highlight> and a timing adjust register <highlight><bold>74</bold></highlight> that allow the system timer <highlight><bold>50</bold></highlight> to update the timing of the communication device <highlight><bold>12</bold></highlight> once each frame to compensate for signals that are delayed or that arrive earlier than anticipated due to movement of the communication device <highlight><bold>12</bold></highlight> relative to the base station <highlight><bold>10</bold></highlight>. </paragraph>
<paragraph id="P-0105" lvl="0"><number>&lsqb;0105&rsqb;</number> While various embodiments of the present invention have been shown and described, it should be understood that other modifications, substitutions and alternatives are apparent to one of ordinary skill in the art. For example, although much of the detailed description describes the microprocessor as controlling the order in which the instructions disposed in the system timer memory are executed, the DSP may instead control the order in which the system timer software instructions are executed in much the same manner as the microprocessor. Specifically, and as will be known by one having ordinary skill in the art, many conventional system timers are configured such that the DSP performs the functions described herein as being performed by the microprocessor. Thus, one having ordinary skill in the art will understand that the DSP may be programmed to perform most if not all of the functions described as being performed by the microprocessor. </paragraph>
<paragraph id="P-0106" lvl="0"><number>&lsqb;0106&rsqb;</number> In addition, the set of software instructions described herein as being used to program the sequencer disposed in the system timer are intended to be exemplary only. More particularly, any set of software instructions defined to perform similar functions will provide the system timer with the enhanced flexibility described. Moreover, although the timing of the timebase counter is described as being performed using the timing adjust register and the timebase adjust register, any number of registers configured in a variety of manners may be used to achieve the timing adjustment features described herein. </paragraph>
<paragraph id="P-0107" lvl="0"><number>&lsqb;0107&rsqb;</number> Further, although the system timer is described as being used in a communication device such as a wireless telephone, the system timer may instead be used in any type of wireless communication device including, for example, a pager, a personal digital assistant having communication capabilities or any other type of device having communication capabilities. Specifically, the output pins of the system timer may be adapted to control any type of communication device to thereby allow any type of communication device to synchronize with any other type of communication device. </paragraph>
<paragraph id="P-0108" lvl="0"><number>&lsqb;0108&rsqb;</number> Such modifications, substitutions and alternatives can be made without departing from the spirit and scope of the invention, which should be determined from the appended claims. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A system timer for controlling the timing at which a communication device communicates, said system timer comprising: 
<claim-text>a memory device adapted to store a set of software instructions; </claim-text>
<claim-text>a processor coupled to said memory device, said processor being adapted to execute any of said software instructions in any of a plurality of sequences, each of said sequences causing said processor to generate a corresponding set of control signals, each of said corresponding set of control signals being adapted to enable communication by said communication device in one of a multiplicity of communication formats, wherein each of said communication formats defines the timing at which a set of data is communicated by said communication device. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The system timer of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein said processor comprises a first processor and further wherein said communication device comprises a second processor, wherein said plurality of sequences in which said first processor executes said software instructions is controlled by said second processor. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The system timer of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference> wherein said system timer further comprises a memory register for storing addresses, said addresses indicating a set of locations at which at least some of said software instructions are stored in said memory device, wherein said first processor is adapted to extract said addresses from said memory register and to execute said software instructions located at said addresses thereby causing said first processor to execute said software instructions in a sequence defined by an order in which said addresses are stored in said memory register. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The system timer of <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference> wherein said second processor controls said plurality of sequences in which said first processor executes said software instructions by controlling said order in which said addresses are stored in said memory register. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The system timer of <dependent-claim-reference depends_on="CLM-00004">claim 4</dependent-claim-reference> wherein said software instructions comprise a first software instruction that, when executed by said first processor, causes said first processor to extract one of said addresses stored in said memory register and to execute a second software instruction located at said one of said addresses provided that said second processor has caused at least one of said addresses to be stored in said memory register. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The system timer of <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference> wherein said first software instruction further causes said first processor to execute a third software instruction stored in said memory device provided that said second processor has not stored said at least one address in said memory register, wherein an address at which said third software instruction is stored in said memory device is specified in said first software instruction. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The system timer of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference> wherein said set of software instructions stored in said memory device comprises a first instruction, said first instruction, when executed by said first processor, causing said first processor to execute a first sequence of software instructions provided that a condition has been satisfied by said second processor and further causing said first processor to execute a second sequence of software instructions provided that said condition has not been satisfied. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The system timer of <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference> wherein said first sequence of software instructions begins with a second instruction located at an address specified in said first instruction. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The system timer of <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference> wherein said condition comprises a mode bit being set to a first logic level. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The system timer of <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference> wherein said condition comprises an equation being equal to a predefined value. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The system timer of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference> wherein said equation being equal to said predefined value depends upon whether a set of mode bits have been set by said second processor. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The system timer of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference> wherein said plurality of sequences comprises a first sequence that causes said communication device to perform single slot communication and wherein said second processor is adapted to modify said first sequence to a second sequence that causes said communication device to perform multi-slot communication. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The system timer of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference> wherein said second processor controls said sequence by setting a control bit stored in a memory register. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The system timer of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference> wherein said second processor comprises a digital signal processor. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The system timer of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference> wherein said second processor comprises a microprocessor. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The system timer of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein said plurality of sequences comprises a first sequence of said software instructions that, when executed by said first processor, enables operation of said communication device in a first mode, wherein said plurality of sequences further comprises a second sequence of said software instructions that, when executed by said first processor, enables operation of said communication device in a second mode, and wherein said second processor is adapted to cause said first processor to switch between executing said first and second sequences thereby causing said communication device to switch between said first and second modes. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The system timer of <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference> wherein said first mode comprises a stand by mode and wherein said second mode comprises an acquisition mode. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The system timer of <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference> wherein said first mode comprises an acquisition mode and wherein said second mode comprises a steady state mode. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The system timer of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein said multiplicity of communication formats comprises a single slot communication format. </claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The system timer of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein said multiplicity of communication formats comprises a multi-slot communication format. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. A system timer for controlling a timing at which a set of data frames are communicated between a first communication device and a second communication device, wherein said system timer is disposed in said first communication device, said system timer comprising: 
<claim-text>a processor adapted to adjust a frame length during which a first frame of data is communicated, wherein adjusting said frame length of said first frame of data causes a start time of a second frame of data to be adjusted and further wherein adjusting said start time of said second frame of data causes a communication time slot to be adjusted, said communication time slot occurring at a fixed start time relative to said start time of said second frame of data. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The system timer of <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference> wherein said frame length comprises a first frame length, said system timer further comprising: 
<claim-text>a counter adapted to count at a rate that corresponds to a set of clock pulses and further being adapted to wrap to zero upon reaching said first frame length; </claim-text>
<claim-text>a first memory register for storing said first frame length; </claim-text>
<claim-text>a second memory register for storing a second frame length; </claim-text>
<claim-text>said processor being adapted to adjust said first frame length by causing said counter to wrap to zero upon reaching said second frame length. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The system timer of <dependent-claim-reference depends_on="CLM-00022">claim 22</dependent-claim-reference> wherein said communication time slot comprises a first communication time slot and further wherein said processor is further adapted to adjust said counter by an amount of time equal to an offset value upon executing a software instruction thereby causing a time at which a second communication time slot occurs to be adjusted by said amount of time equal to said offset value. </claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The system timer of <dependent-claim-reference depends_on="CLM-00022">claim 23</dependent-claim-reference> wherein said software instruction includes a field for containing data that indicates whether said counter will be incremented by said offset value. </claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. The system timer of <dependent-claim-reference depends_on="CLM-00022">claim 23</dependent-claim-reference> wherein said software instruction includes a field for containing data that indicates whether said counter will be decremented by said offset value. </claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. The system timer of <dependent-claim-reference depends_on="CLM-00022">claim 23</dependent-claim-reference> wherein said offset value is equal to an amount of time by which the timing of the first communication device is offset from the timing of the second communication device. </claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. The system timer of <dependent-claim-reference depends_on="CLM-00022">claim 23</dependent-claim-reference> further comprising a memory device for storing said software instruction. </claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. The system timer of <dependent-claim-reference depends_on="CLM-00022">claim 23</dependent-claim-reference> wherein said first communication time slot comprises a receive time slot during which said first communication device is configured to receive data and wherein said second communication time slot comprises a transmit time slot during which said first communication device is configured to transmit data. </claim-text>
</claim>
<claim id="CLM-00029">
<claim-text><highlight><bold>29</bold></highlight>. A system timer for controlling a timing at which a set of data frames having a set of time slots are communicated between a first communication device and a second communication device, wherein said system timer is disposed in said first communication device, said system timer comprising: 
<claim-text>a processor adapted to adjust a first time slot in a first direction to compensate for a first timing offset, said processor being further adapted to adjust a second time slot in a second direction to compensate for a second timing offset, wherein said first time slot occurs in each of said frames before said second time slot, and further wherein said processor adjusts said second time slot after said first time slot has ended. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00030">
<claim-text><highlight><bold>30</bold></highlight>. The system timer of <dependent-claim-reference depends_on="CLM-00022">claim 29</dependent-claim-reference> wherein said first time slot is fixed relative to a frame start and wherein said processor is adapted to adjust said first time slot in said first direction by adjusting said frame start in said first direction. </claim-text>
</claim>
<claim id="CLM-00031">
<claim-text><highlight><bold>31</bold></highlight>. The system timer of <dependent-claim-reference depends_on="CLM-00033">claim 30</dependent-claim-reference> wherein said frame start is associated with a first frame and wherein said processor is adapted to adjust said frame start in said first direction by adjusting a frame length of a second frame, said second frame preceding said first frame. </claim-text>
</claim>
<claim id="CLM-00032">
<claim-text><highlight><bold>32</bold></highlight>. The system timer of <dependent-claim-reference depends_on="CLM-00033">claim 31</dependent-claim-reference> further comprising a memory register for storing a frame length value and a counter associated with said timing at which said frames are communicated, said counter being adapted to wrap to zero upon reaching said frame length value, wherein said processor is adapted to adjust said frame length of said second frame by changing said frame length value during said second frame. </claim-text>
</claim>
<claim id="CLM-00033">
<claim-text><highlight><bold>33</bold></highlight>. The system timer of <dependent-claim-reference depends_on="CLM-00022">claim 29</dependent-claim-reference> further comprising a counter associated with said timing at which said frames are communicated, wherein said processor adjusts said second time slot in said second direction by causing said counter to be adjusted. </claim-text>
</claim>
<claim id="CLM-00034">
<claim-text><highlight><bold>34</bold></highlight>. The system timer of <dependent-claim-reference depends_on="CLM-00022">claim 29</dependent-claim-reference> wherein adjusting said first time slot in said first direction causes said first time slot to occur later and wherein said step of adjusting said second time slot in said second direction causes said second time slot to occur earlier. </claim-text>
</claim>
<claim id="CLM-00035">
<claim-text><highlight><bold>35</bold></highlight>. The system timer of <dependent-claim-reference depends_on="CLM-00033">claim 34</dependent-claim-reference> wherein said first time slot comprises a receive slot during which said first communication device is configured to receive data from said second communication device and wherein said second time slot comprises a transmit slot during which said first communication device is configured to transmit data to said second communication device. </claim-text>
</claim>
<claim id="CLM-00036">
<claim-text><highlight><bold>36</bold></highlight>. The system timer of <dependent-claim-reference depends_on="CLM-00033">claim 34</dependent-claim-reference> wherein said receive slot is adjusted to occur later so that said data transmitted by said second communication device has sufficient time to reach said first communication device and wherein said transmit slot is adjusted to occur earlier so that said data transmitted by said first communication device has sufficient time to reach said second communication device. </claim-text>
</claim>
<claim id="CLM-00037">
<claim-text><highlight><bold>37</bold></highlight>. A method for controlling the timing at which a communication device communicates, said communication device comprising a first processor and a system timer, said system timer comprising a second processor and a memory device adapted to store a set of software instructions, said method comprising the steps of: 
<claim-text>causing said second processor to execute a set of software instructions in any of a plurality of sequences, each of said sequences causing said second processor to generate a corresponding set of control signals, each of said corresponding set of control signals being adapted to enable communication by said communication device in one of a multiplicity of communication formats, wherein each of said communication formats defines the timing at which a set of data is communicated by said communication device; and, </claim-text>
<claim-text>causing said first processor to define said sequences in which said second processor executes said software instructions. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00038">
<claim-text><highlight><bold>38</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00033">claim 37</dependent-claim-reference> wherein a first of said sequences causes said communication device to communicate in a first timing format and wherein a second of said sequences causes said communication device to communicate in a second timing format. </claim-text>
</claim>
<claim id="CLM-00039">
<claim-text><highlight><bold>39</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00033">claim 37</dependent-claim-reference> wherein said first timing format comprises a single slot timing format and wherein said second timing format comprises a multi-slot timing format. </claim-text>
</claim>
<claim id="CLM-00040">
<claim-text><highlight><bold>40</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00033">claim 37</dependent-claim-reference> wherein a first of said sequences defined by said first processor causes said communication device to operate in a first mode and wherein a second of said sequences defined by said first processor causes said communication device to communicate in a second mode. </claim-text>
</claim>
<claim id="CLM-00041">
<claim-text><highlight><bold>41</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00033">claim 39</dependent-claim-reference> wherein said first mode comprises a stand by mode and wherein said second mode comprises an acquisition mode. </claim-text>
</claim>
<claim id="CLM-00042">
<claim-text><highlight><bold>42</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00044">claim 40</dependent-claim-reference> wherein said first mode comprises an acquisition mode and wherein said second mode comprises a steady state mode. </claim-text>
</claim>
<claim id="CLM-00043">
<claim-text><highlight><bold>43</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00033">claim 36</dependent-claim-reference> wherein said first processor defines said sequences in which said second processor executes said software instructions by storing a set of addresses in an order in a memory register disposed in said system timer, said set of addresses indicating a set of locations at which at least some of said software instructions are stored in said memory device, wherein said second processor is adapted to extract and execute said addresses from said memory register in said order in which said addresses are stored. </claim-text>
</claim>
<claim id="CLM-00044">
<claim-text><highlight><bold>44</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00033">claim 36</dependent-claim-reference> wherein an order in which said instructions are executed in at least one of said sequences is dependent upon said first processor setting a mode bit to a first logic level. </claim-text>
</claim>
<claim id="CLM-00045">
<claim-text><highlight><bold>45</bold></highlight>. A method for compensating for a first timing offset associated with a first time slot and for compensating for a second timing offset associated with a second time slot, said first time slot and said second time slot occurring in each of a set of frames, wherein said first time slot occurs before said second time slot, said method comprising the steps of: 
<claim-text>adjusting said first time slot in a first direction during a first frame, said first time slot being fixed relative to a frame start associated with said first frame, wherein said first time slot is adjusted in said first direction by adjusting said frame start associated with said first frame in said first direction; and, </claim-text>
<claim-text>adjusting said second time slot in a second direction after said first time slot has ended. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00046">
<claim-text><highlight><bold>46</bold></highlight>. The method <dependent-claim-reference depends_on="CLM-00044">claim 45</dependent-claim-reference> wherein said step of adjusting said first time slot in a first direction during a first frame is performed by adjusting a frame length associated with a second frame, said second frame preceding said first frame. </claim-text>
</claim>
<claim id="CLM-00047">
<claim-text><highlight><bold>47</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00044">claim 46</dependent-claim-reference> wherein said step of adjusting said frame length associated with said second frame is performed by changing a value at which a counter wraps to zero during said second frame. </claim-text>
</claim>
<claim id="CLM-00048">
<claim-text><highlight><bold>48</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00044">claim 45</dependent-claim-reference> wherein said step of adjusting said second time slot in a second direction after said first time slot has ended is performed by causing a counter to be adjusted. </claim-text>
</claim>
<claim id="CLM-00049">
<claim-text><highlight><bold>49</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00044">claim 45</dependent-claim-reference> wherein said step of adjusting said first time slot in said first direction causes said first time slot to occur later and wherein said step of adjusting said second time slot in said second direction causes said second time slot to occur earlier. </claim-text>
</claim>
<claim id="CLM-00050">
<claim-text><highlight><bold>50</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00044">claim 44</dependent-claim-reference> wherein said first time slot comprises a receive slot during which a first communication device is configured to receive a first set of data from a second communication device and wherein said second time slot comprises a transmit slot during which said first communication device is configured to transmit a second set of data to said second communication device. </claim-text>
</claim>
<claim id="CLM-00051">
<claim-text><highlight><bold>51</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00044">claim 49</dependent-claim-reference> wherein said first time slot is adjusted to occur later so that said first set of data has sufficient time to reach said first communication device </claim-text>
</claim>
<claim id="CLM-00052">
<claim-text><highlight><bold>52</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00044">claim 49</dependent-claim-reference> wherein said second time slot is adjusted to occur earlier so that said second set of data has sufficient time to reach said second communication device.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>6</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030002537A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030002537A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030002537A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030002537A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030002537A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030002537A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030002537A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030002537A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030002537A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00009">
<image id="EMI-D00009" file="US20030002537A1-20030102-D00009.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00010">
<image id="EMI-D00010" file="US20030002537A1-20030102-D00010.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00011">
<image id="EMI-D00011" file="US20030002537A1-20030102-D00011.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00012">
<image id="EMI-D00012" file="US20030002537A1-20030102-D00012.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00013">
<image id="EMI-D00013" file="US20030002537A1-20030102-D00013.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00014">
<image id="EMI-D00014" file="US20030002537A1-20030102-D00014.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00015">
<image id="EMI-D00015" file="US20030002537A1-20030102-D00015.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00016">
<image id="EMI-D00016" file="US20030002537A1-20030102-D00016.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00017">
<image id="EMI-D00017" file="US20030002537A1-20030102-D00017.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00018">
<image id="EMI-D00018" file="US20030002537A1-20030102-D00018.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00019">
<image id="EMI-D00019" file="US20030002537A1-20030102-D00019.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00020">
<image id="EMI-D00020" file="US20030002537A1-20030102-D00020.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00021">
<image id="EMI-D00021" file="US20030002537A1-20030102-D00021.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00022">
<image id="EMI-D00022" file="US20030002537A1-20030102-D00022.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
