<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005161A1-20030102-D00000.TIF SYSTEM "US20030005161A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005161A1-20030102-D00001.TIF SYSTEM "US20030005161A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005161A1-20030102-D00002.TIF SYSTEM "US20030005161A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005161A1-20030102-D00003.TIF SYSTEM "US20030005161A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005161A1-20030102-D00004.TIF SYSTEM "US20030005161A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005161A1-20030102-D00005.TIF SYSTEM "US20030005161A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030005161A1-20030102-D00006.TIF SYSTEM "US20030005161A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030005161A1-20030102-D00007.TIF SYSTEM "US20030005161A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030005161A1-20030102-D00008.TIF SYSTEM "US20030005161A1-20030102-D00008.TIF" NDATA TIF>
<!ENTITY US20030005161A1-20030102-D00009.TIF SYSTEM "US20030005161A1-20030102-D00009.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005161</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09893170</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010627</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F015/16</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>709</class>
<subclass>248000</subclass>
</uspc>
</classification-us-primary>
<classification-us-secondary>
<uspc>
<class>709</class>
<subclass>203000</subclass>
</uspc>
</classification-us-secondary>
<classification-us-secondary>
<uspc>
<class>707</class>
<subclass>201000</subclass>
</uspc>
</classification-us-secondary>
</classification-us>
<title-of-invention>System and method for recovering from a failed synchronization session</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>James</given-name>
<middle-name>S.L.</middle-name>
<family-name>Chen</family-name>
</name>
<residence>
<residence-non-us>
<city>Mississauga</city>
<country-code>CA</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Stephen</given-name>
<middle-name>D.</middle-name>
<family-name>Flanagin</family-name>
</name>
<residence>
<residence-us>
<city>Sammamish</city>
<state>WA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Brian</given-name>
<family-name>Moore</family-name>
</name>
<residence>
<residence-us>
<city>Sammamish</city>
<state>WA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<assignee>
<organization-name>Microsoft Corporation</organization-name>
<assignee-type>03</assignee-type>
</assignee>
<correspondence-address>
<name-1>Merchant &amp; Gould P.C.</name-1>
<name-2></name-2>
<address>
<address-1>P.O. Box 2903</address-1>
<city>Minneapolis</city>
<state>MN</state>
<postalcode>55402-0903</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A system and method is described for recovering from a failed synchronization session between a first data store and a second data store. Once a failed synchronization session is detected, a synchronization recovery process is performed. The synchronization recovery process includes creating an update manifest based on a sync request and on a synchronization state table. The synchronization state table is updated for each sync request initiating a synchronization session, whether the synchronization session succeeded or failed. The update manifest may include one or more objects and an update action associated with each of the objects. The update action may be identical to a current action specified in the sync request for the object, identical to a last action stored in the synchronization state table for the object, or different from both the current action and the last action. In general, the update action minimizes the likelihood of duplicate objects. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">TECHNICAL FIELD </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> The present invention relates to synchronization between mobile devices and fixed devices, and, more specifically, to systems for recovering from a failed synchronization session between the mobile device and the fixed device. </paragraph>
</section>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> Mobile devices have become quite common today. The users of these mobile devices want to have their mobile devices updated with current information quite frequently. The process for updating information involves communicating with a fixed device (i.e., server) and is commonly referred to as a synchronization session. Synchronization sessions between mobile devices and servers are quite different from synchronization sessions between hard-wired devices and servers. For example, synchronization sessions between mobile devices and servers are more prone to lost or terminated transmissions. If there is a lost or terminated transmission, the information on the mobile device and on the server may not be identical. Thus, there is a need for an efficient method for recovering from a failed synchronization session due to a lost or terminated transmission that ensures a successful update to both the mobile device and the server. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> Briefly described, the present invention provides a method for recovering from a failed synchronization session. The recovery detection method is able to identify a sync failure with a minimal amount of data transmitted between the two devices, and thus, provides an economic method of recovering from a failed synchronization session using wireless technology. The method achieves this recovery without requiring the server to maintain and track errors of the client, without waiting for an explicit acknowledgement from the client, and without other time consuming and bandwidth intensive tasks. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> In general, the method includes detecting and recovering from a failed prior synchronization session. In one embodiment, a failed synchronization session is detected by comparing a sync key transmitted by the mobile device in a sync request to a prior sync key stored in a synchronization state table. For this embodiment, a failed synchronization session is detected when the request sync key is one less than the prior sync key. Once a failed synchronization session is detected, a synchronization recovery process is performed. The synchronization recovery process includes creating an update manifest based on the sync request and the synchronization state table. In one embodiment, the update manifest includes one or more objects and an update action associated with each of the objects. The update action may be identical to a current action specified in the sync request for the object, identical to a last action stored in the synchronization state table for the object, or different from both the current action and the last action. In general, the update action that is specified minimizes the likelihood that duplicate objects are created in either data store. Once the server data store is updated, the synchronization state table is updated. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> In another aspect of the invention, the present invention provides a system that recovers from a failed synchronization session between a first data store and a second data store. The system includes a first device associated with the first data store, a second device associated with the second data store, and a server. The server is coupled to a storage medium on which a synchronization state is stored. The synchronization state is updated for each successful and failed synchronization session. The server is configured to access the synchronization state upon receiving a synchronization request and to determine whether a prior synchronization session failed. If the prior synchronization session failed, the server is configured to initiate a recovery synchronization session. The recovery synchronization session includes creating an update manifest based on the synchronization state and the synchronization request. The update action may be identical to a current action specified in the synchronization request for the object, identical to a last action stored in the synchronization state for the object, or different from both the current action and the last action. In general, the update action that is specified minimizes the likelihood that duplicate objects are created in either data store. Once the server data store is updated, the synchronization state is updated.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> illustrates an exemplary computing device that may be used in one exemplary embodiment of the present invention; </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> illustrates an exemplary mobile computing device that may be used in one exemplary embodiment of the present invention; </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a functional block diagram of one exemplary synchronization recovery system as implemented using the computer device shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference> and the mobile computing device shown in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>; </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a graphical representation of one embodiment of client synchronization data exchanged during a synchronization session; </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a graphical representation of one embodiment of server synchronization data exchanged during a synchronization session; </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is a graphical representation generally illustrating the salient portions of a sample manifest suitable for use in the synchronization data shown in <cross-reference target="DRAWINGS">FIGS. 5 and 6</cross-reference>; </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> is a graphical representation generally illustrating the salient portions of a sample synchronization state table shown in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>; </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> is a logical flow diagram generally illustrating an overview of a process for recovering from a failed synchronization session; </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference> is a logical flow diagram illustrating a recovery process suitable for use in <cross-reference target="DRAWINGS">FIG. 8</cross-reference>, in accordance with one embodiment of the present invention; </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10</cross-reference> is a logical flow diagram illustrating one embodiment of a synchronization recovery process suitable for use in <cross-reference target="DRAWINGS">FIG. 8</cross-reference>; and </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 11</cross-reference> is a table illustrating various outcomes for the update manifest based on various conditions. </paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT </heading>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> The present invention may be implemented in one or more components operating within a distributed or wireless computing network. Those components may include software programs or applications operating on computing systems of various configurations. Two general types of computing systems are being used to implement the embodiments of the invention described here. Those two general types are illustrated in <cross-reference target="DRAWINGS">FIG. 1</cross-reference> and <cross-reference target="DRAWINGS">FIG. 2</cross-reference> and described below, followed by a detailed discussion of one illustrative implementation of the invention, illustrated in FIGS. <highlight><bold>3</bold></highlight>-<highlight><bold>11</bold></highlight>, based on these two types of computer systems. </paragraph>
<paragraph id="P-0018" lvl="7"><number>&lsqb;0018&rsqb;</number> Illustrative Operating Environment </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> With reference to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, one exemplary system for implementing the invention includes a computing device, such as computing device <highlight><bold>100</bold></highlight>. In a very basic configuration, computing device <highlight><bold>100</bold></highlight> typically includes at least one processing unit <highlight><bold>102</bold></highlight> and system memory <highlight><bold>104</bold></highlight>. Depending on the exact configuration and type of computing device, system memory <highlight><bold>104</bold></highlight> may be volatile (such as RAM), non-volatile (such as ROM, flash memory, etc.) or some combination of the two. System memory <highlight><bold>104</bold></highlight> typically includes an operating system <highlight><bold>105</bold></highlight>, one or more program modules <highlight><bold>106</bold></highlight>, and may include program data <highlight><bold>107</bold></highlight>. This basic configuration is illustrated in <cross-reference target="DRAWINGS">FIG. 1</cross-reference> by those components within dashed line <highlight><bold>108</bold></highlight>. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> Computing device <highlight><bold>100</bold></highlight> may have additional features or functionality. For example, computing device <highlight><bold>100</bold></highlight> may also include additional data storage devices (removable and/or non-removable) such as, for example, magnetic disks, optical disks, or tape. Such additional storage is illustrated in <cross-reference target="DRAWINGS">FIG. 1</cross-reference> by removable storage <highlight><bold>109</bold></highlight> and non-removable storage <highlight><bold>110</bold></highlight>. Computer storage media may include volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information, such as computer readable instructions, data structures, program modules, or other data. System memory <highlight><bold>104</bold></highlight>, removable storage <highlight><bold>109</bold></highlight> and non-removable storage <highlight><bold>110</bold></highlight> are all examples of computer storage media. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by computing device <highlight><bold>100</bold></highlight>. Any such computer storage media may be part of device <highlight><bold>100</bold></highlight>. Computing device <highlight><bold>100</bold></highlight> may also have input device(s) <highlight><bold>112</bold></highlight> such as keyboard, mouse, pen, voice input device, touch input device, etc. Output device(s) <highlight><bold>114</bold></highlight> such as a display, speakers, printer, etc. may also be included. These devices are well know in the art and need not be discussed at length here. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> Computing device <highlight><bold>100</bold></highlight> may also contain communication connections <highlight><bold>116</bold></highlight> that allow the device to communicate with other computing devices <highlight><bold>118</bold></highlight>, such as over a network. Communication connections <highlight><bold>116</bold></highlight> is one example of communication media. Communication media may typically be embodied by computer readable instructions, data structures, program modules, or other data in a modulated data signal, such as a carrier wave or other transport mechanism, and includes any information delivery media. The term &ldquo;modulated data signal&rdquo; means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. The term computer readable media as used herein includes both storage media and communication media. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> With reference to <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, one exemplary system for implementing the invention includes a mobile computing device, such as mobile computing device <highlight><bold>200</bold></highlight>. The mobile computing device <highlight><bold>200</bold></highlight> has a processor <highlight><bold>260</bold></highlight>, a memory <highlight><bold>262</bold></highlight>, a display <highlight><bold>228</bold></highlight>, and a keypad <highlight><bold>232</bold></highlight>. The memory <highlight><bold>262</bold></highlight> generally includes both volatile memory (e.g., RAM) and non-volatile memory (e.g., ROM, Flash Memory, or the like). The mobile computing device <highlight><bold>200</bold></highlight> includes an operating system <highlight><bold>264</bold></highlight>, such as the Windows CE operating system from Microsoft Corporation or other operating system, which is resident in the memory <highlight><bold>262</bold></highlight> and executes on the processor <highlight><bold>260</bold></highlight>. The keypad <highlight><bold>232</bold></highlight> may be a push button numeric dialing pad (such as on a typical telephone), a multi-key keyboard (such as a conventional keyboard). The display <highlight><bold>228</bold></highlight> may be a liquid crystal display, or any other type of display commonly used in mobile computing devices. The display <highlight><bold>228</bold></highlight> may be touch-sensitive, and would then also act as an input device. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> One or more application programs <highlight><bold>266</bold></highlight> are loaded into memory <highlight><bold>262</bold></highlight> and run on the operating system <highlight><bold>264</bold></highlight>. Examples of application programs include phone dialer programs, email programs, scheduling programs, PIM (personal information management) programs, word processing programs, spreadsheet programs, Internet browser programs, and so forth. The mobile computing device <highlight><bold>200</bold></highlight> also includes nonvolatile storage <highlight><bold>268</bold></highlight> within the memory <highlight><bold>262</bold></highlight>. The non-volatile storage <highlight><bold>268</bold></highlight> may be used to store persistent information which should not be lost if the mobile computing device <highlight><bold>200</bold></highlight> is powered down. The applications <highlight><bold>266</bold></highlight> may use and store information in the storage <highlight><bold>268</bold></highlight>, such as e-mail or other messages used by an e-mail application, contact information used by a PIM, appointment information used by a scheduling program, documents used by a word processing application, and the like. A synchronization application also resides on the mobile computing device <highlight><bold>200</bold></highlight> and is programmed to interact with a corresponding synchronization application resident on a host computer to keep the information stored in the storage <highlight><bold>268</bold></highlight> synchronized with corresponding information stored at the host computer. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> The mobile computing device <highlight><bold>200</bold></highlight> has a power supply <highlight><bold>270</bold></highlight>, which may be implemented as one or more batteries. The power supply <highlight><bold>270</bold></highlight> might further include an external power source, such as an AC adapter or a powered docking cradle, that supplements or recharges the batteries. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> The mobile computing device <highlight><bold>200</bold></highlight> is also shown with two types of external notification mechanisms: an LED <highlight><bold>240</bold></highlight> and an audio interface <highlight><bold>274</bold></highlight>. These devices may be directly coupled to the power supply <highlight><bold>270</bold></highlight> so that when activated, they remain on for a duration dictated by the notification mechanism even though the processor <highlight><bold>260</bold></highlight> and other components might shut down to conserve battery power. The LED <highlight><bold>240</bold></highlight> may be programmed to remain on indefinitely until the user takes action to indicate the powered-on status of the device. The audio interface <highlight><bold>274</bold></highlight> is used to provide audible signals to and receive audible signals from the user. For example, the audio interface <highlight><bold>274</bold></highlight> may be coupled to a speaker for providing audible output and to a microphone for receiving audible input, such as to facilitate a telephone conversation. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> The mobile computing device <highlight><bold>200</bold></highlight> also includes a radio interface layer <highlight><bold>272</bold></highlight> that performs the function of transmitting and receiving radio frequency communications. The radio interface layer <highlight><bold>272</bold></highlight> facilitates wireless connectivity between the mobile computing device <highlight><bold>200</bold></highlight> and the outside world, via a communications carrier or service provider. Transmissions to and from the radio interface layer <highlight><bold>272</bold></highlight> are conducted under control of the operating system <highlight><bold>264</bold></highlight>. In other words, communications received by the radio interface layer <highlight><bold>272</bold></highlight> may be disseminated to application programs <highlight><bold>266</bold></highlight> via the operating system <highlight><bold>264</bold></highlight>, and vice versa. </paragraph>
<paragraph id="P-0027" lvl="7"><number>&lsqb;0027&rsqb;</number> Illustrative Synchronization Recovery System </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a functional block diagram generally illustrating one embodiment for a synchronization recovery system <highlight><bold>300</bold></highlight> for recovering from a failed synchronization session between a fixed computing device, such as an information server <highlight><bold>310</bold></highlight> and a mobile device <highlight><bold>320</bold></highlight>, in accordance with the present invention. For the purposes of the following discussion, the term session refers to the period devoted to synchronization activities. In one embodiment, the synchronization session includes a single request/response. In this implementation, the information server <highlight><bold>310</bold></highlight> is a computing device such as the one described above in conjunction with <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, and the mobile device <highlight><bold>320</bold></highlight> (i.e., client) is a mobile computing device such as the one described above in conjunction with <cross-reference target="DRAWINGS">FIG. 2</cross-reference>. A synchronization application <highlight><bold>342</bold></highlight> performs the synchronization process between the information server <highlight><bold>310</bold></highlight> and the mobile device <highlight><bold>320</bold></highlight>. In the embodiment illustrated, the synchronization application <highlight><bold>342</bold></highlight> resides on a synchronization server <highlight><bold>340</bold></highlight>, which is a computing device as described above in conjunction with <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. The synchronization server <highlight><bold>340</bold></highlight> is shown coupled to the information server <highlight><bold>310</bold></highlight> over a local or wide area network in the conventional manner. In another embodiment, the synchronization application <highlight><bold>342</bold></highlight> may reside on information server <highlight><bold>310</bold></highlight> without departing from the scope of the present invention. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> The mobile device <highlight><bold>320</bold></highlight> maintains mobile data <highlight><bold>322</bold></highlight> (i.e., a mobile data store) locally in its non-volatile storage <highlight><bold>268</bold></highlight> (shown in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>). Information server <highlight><bold>310</bold></highlight> maintains server data <highlight><bold>312</bold></highlight> (i.e., a server data store) on its removable storage <highlight><bold>109</bold></highlight> or non-removable storage <highlight><bold>110</bold></highlight> (shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>). As mentioned earlier, the mobile data <highlight><bold>322</bold></highlight> and the server data <highlight><bold>312</bold></highlight> may include e-mail or other messages used by an e-mail application, contact information used by a PIM, appointment information used by a scheduling program, and the like. Typically, each type of information in the mobile data <highlight><bold>322</bold></highlight> or server data <highlight><bold>312</bold></highlight> is referred to as a &ldquo;collection&rdquo; (e.g., e-mail and contacts are two separate collections). The mobile device <highlight><bold>320</bold></highlight> may change the mobile data <highlight><bold>322</bold></highlight> on the mobile device <highlight><bold>320</bold></highlight> at anytime. Once the mobile data <highlight><bold>322</bold></highlight> is changed, server data <highlight><bold>312</bold></highlight> accessible by the information server <highlight><bold>310</bold></highlight> will not have identical information. Similarly, the information server <highlight><bold>310</bold></highlight> may change the server data <highlight><bold>312</bold></highlight>, such as through any number of networked personal computers (not shown) connected to the information server <highlight><bold>310</bold></highlight>. Again, once the server data <highlight><bold>312</bold></highlight> is changed, the mobile data <highlight><bold>322</bold></highlight> and server data <highlight><bold>312</bold></highlight> are no longer identical (i.e., data is not synchronized). In order for the mobile data <highlight><bold>322</bold></highlight> and the server data <highlight><bold>312</bold></highlight> to become identical (i.e., synchronized), typically, the mobile device <highlight><bold>320</bold></highlight> initiates a synchronization session. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> Briefly, during the synchronization session, client synchronization data <highlight><bold>323</bold></highlight> is transmitted between the mobile device <highlight><bold>320</bold></highlight> and the synchronization application <highlight><bold>342</bold></highlight> through wireless technology, and server synchronization data <highlight><bold>350</bold></highlight> is transmitted between the synchronization application <highlight><bold>342</bold></highlight> and the information server <highlight><bold>310</bold></highlight>. The client synchronization data <highlight><bold>323</bold></highlight> includes client requests <highlight><bold>324</bold></highlight> sent by the mobile device <highlight><bold>320</bold></highlight> and client responses <highlight><bold>326</bold></highlight> sent by the synchronization application <highlight><bold>342</bold></highlight> to the mobile device <highlight><bold>320</bold></highlight>. The client requests <highlight><bold>324</bold></highlight> specify changes to the mobile data <highlight><bold>322</bold></highlight> since the last successful synchronization session. The client responses specify changes to the server data <highlight><bold>312</bold></highlight> since the last successful synchronization session. The client requests <highlight><bold>324</bold></highlight> and the client responses <highlight><bold>326</bold></highlight> are illustrated in <cross-reference target="DRAWINGS">FIG. 4</cross-reference> and described in greater detail below. The synchronization application <highlight><bold>342</bold></highlight> saves information regarding the synchronization session in a synchronization state table <highlight><bold>344</bold></highlight>. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> Thus, by using the synchronization state table <highlight><bold>344</bold></highlight>, client requests <highlight><bold>324</bold></highlight>, and client responses <highlight><bold>326</bold></highlight> in accordance with the present invention, the synchronization application <highlight><bold>342</bold></highlight> is able to detect and handle &ldquo;old&rdquo; client requests <highlight><bold>324</bold></highlight> that have already been updated on the server data <highlight><bold>312</bold></highlight> without duplicating processing (i.e., creating duplicate objects) on the information server <highlight><bold>310</bold></highlight>. In addition, the synchronization application <highlight><bold>342</bold></highlight> can perform incremental updates to the mobile device <highlight><bold>320</bold></highlight> to resynchronize the mobile data <highlight><bold>322</bold></highlight> and the server data <highlight><bold>312</bold></highlight> after a failed synchronization session without re-transmitting the entire server data <highlight><bold>312</bold></highlight> to the mobile device <highlight><bold>320</bold></highlight>. Thus, providing an efficient method for recovering from a failed synchronization session using wireless technology. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a graphical representation of one embodiment of client synchronization data <highlight><bold>323</bold></highlight> exchanged during a synchronization session. In the illustrated embodiment, the synchronization data <highlight><bold>323</bold></highlight> includes a client request <highlight><bold>324</bold></highlight> and a client response <highlight><bold>326</bold></highlight>. The client request <highlight><bold>324</bold></highlight> includes a sync key <highlight><bold>402</bold></highlight> and a client manifest <highlight><bold>404</bold></highlight>. The sync key <highlight><bold>402</bold></highlight>, described in a co-pending application entitled &ldquo;SYNC KEY&rdquo; which is commonly owned and filed on the same date as the current application, provides one illustrative method for synchronizing data using wireless technology. The method for detecting a failed synchronization session using the sync key <highlight><bold>402</bold></highlight> will be described in greater detail below. The client manifest <highlight><bold>404</bold></highlight> identifies information that has changed in the mobile data <highlight><bold>322</bold></highlight> since the last successful synchronization session or may identify information that the mobile device <highlight><bold>320</bold></highlight> wants from the server data <highlight><bold>312</bold></highlight>. For example, in one embodiment, if the client manifest <highlight><bold>404</bold></highlight> is null, the synchronization application <highlight><bold>342</bold></highlight> sends all the currently stored server data <highlight><bold>312</bold></highlight> to the mobile device <highlight><bold>320</bold></highlight> to store as mobile data <highlight><bold>322</bold></highlight>. A representative client manifest <highlight><bold>404</bold></highlight> is illustrated in <cross-reference target="DRAWINGS">FIG. 6</cross-reference> and described below. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> The client response <highlight><bold>326</bold></highlight> includes a sync key <highlight><bold>412</bold></highlight> and a server manifest <highlight><bold>414</bold></highlight>. The server manifest <highlight><bold>414</bold></highlight> identifies information that has changed in the server data <highlight><bold>312</bold></highlight> that must be updated in the mobile data <highlight><bold>322</bold></highlight>. A representative server manifest <highlight><bold>414</bold></highlight> is illustrated in <cross-reference target="DRAWINGS">FIG. 6</cross-reference> and described below. The sync key <highlight><bold>412</bold></highlight> in the client response <highlight><bold>326</bold></highlight> is similar to the sync key <highlight><bold>402</bold></highlight> described in the client request <highlight><bold>324</bold></highlight>. Again, an illustrative embodiment for using the sync key <highlight><bold>412</bold></highlight> in the client response <highlight><bold>326</bold></highlight> is described in the co-pending application entitled &ldquo;SYNC KEY&rdquo; referred to above. In the aforementioned embodiment, a value stored in the sync key <highlight><bold>402</bold></highlight> in the client request <highlight><bold>324</bold></highlight> having the same value as the value stored in the sync key <highlight><bold>412</bold></highlight> of the client response <highlight><bold>326</bold></highlight> indicates a successful synchronization session. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a graphical representation of one embodiment of server synchronization data <highlight><bold>350</bold></highlight> exchanged between the synchronization application <highlight><bold>342</bold></highlight> and the information server <highlight><bold>310</bold></highlight> during a synchronization session. In the illustrated embodiment, the server synchronization data <highlight><bold>350</bold></highlight> includes a server update processing <highlight><bold>352</bold></highlight>, a server sync request <highlight><bold>353</bold></highlight>, and a server response <highlight><bold>354</bold></highlight>. The server update processing <highlight><bold>352</bold></highlight> includes an update manifest <highlight><bold>504</bold></highlight>, which is created by the synchronization application <highlight><bold>342</bold></highlight> based on one or more client manifests <highlight><bold>404</bold></highlight>. The update manifest <highlight><bold>504</bold></highlight> lists the updates from the mobile data <highlight><bold>322</bold></highlight> that need to be updated in the server data <highlight><bold>312</bold></highlight>. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> Once a client request <highlight><bold>324</bold></highlight> for synchronization is received, the synchronization application <highlight><bold>342</bold></highlight> sends a server sync request <highlight><bold>353</bold></highlight> to the information server <highlight><bold>310</bold></highlight>. The server sync request <highlight><bold>353</bold></highlight> includes a watermark <highlight><bold>505</bold></highlight> and an incremental update <highlight><bold>506</bold></highlight>. The watermark <highlight><bold>505</bold></highlight> identifies the last successful synchronization transaction so that the information server <highlight><bold>310</bold></highlight> knows which new data must be sent. The incremental update <highlight><bold>506</bold></highlight> corresponds to changes that were made from the synchronization application <highlight><bold>342</bold></highlight> to the information server <highlight><bold>310</bold></highlight> since the last synchronization session. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> In response to the server sync request <highlight><bold>353</bold></highlight>, the information server <highlight><bold>310</bold></highlight> transmits to the synchronization application <highlight><bold>342</bold></highlight> a server response <highlight><bold>354</bold></highlight>. The server response includes a server manifest <highlight><bold>514</bold></highlight> and a new watermark <highlight><bold>512</bold></highlight>. The server manifest <highlight><bold>514</bold></highlight> identifies the information that has changed in the server data <highlight><bold>312</bold></highlight> since the synchronization transaction identified by the watermark <highlight><bold>505</bold></highlight>. A representative server manifest <highlight><bold>514</bold></highlight> is illustrated in <cross-reference target="DRAWINGS">FIG. 6</cross-reference> and described below. The new watermark <highlight><bold>512</bold></highlight> is a value that will be used in the future (in the same manner as watermark <highlight><bold>505</bold></highlight>) to identify the state of the current synchronization transaction if successful. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> In one embodiment, in which the information server <highlight><bold>310</bold></highlight> incorporates the Microsoft&reg; Exchange Server suite of software, the incremental update <highlight><bold>506</bold></highlight> may use &ldquo;CollBlobs&rdquo; and &ldquo;AddBlobs&rdquo; in a well-known manner. Briefly, a CollBlob is a list of the item identifiers (IDs) stored in the server data <highlight><bold>312</bold></highlight> and their version at the time (i.e., checkpoint) at which the manifest or update was sent. Typically, the checkpoint refers to a position in time at which the information server <highlight><bold>310</bold></highlight> has synchronized. In addition, the checkpoint may be thought of as corresponding to a state for each object in the server data <highlight><bold>312</bold></highlight>. An AddBlob is a list of the item IDs and their version that were added or changed by the sync application. Thus, in one implementation, the watermarks <highlight><bold>505</bold></highlight>, <highlight><bold>512</bold></highlight> may be CollBlobs. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> If the client response <highlight><bold>326</bold></highlight> is lost or terminated, the watermark associated with the server data <highlight><bold>312</bold></highlight> that identifies the state at which the information server <highlight><bold>310</bold></highlight> believes it has been synchronized may not correspond to the same state at which the mobile data <highlight><bold>322</bold></highlight> is synchronized. As will be illustrated in FIGS. <highlight><bold>8</bold></highlight>-<highlight><bold>11</bold></highlight> and described below, the present invention performs a synchronization recovery process from a prior watermark, which may be different than the watermark identified for the last successful synchronization session. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is a graphical representation generally illustrating the salient portions of a sample manifest <highlight><bold>600</bold></highlight> that may be used as a client manifest <highlight><bold>404</bold></highlight>, an update manifest <highlight><bold>504</bold></highlight> or a server manifest <highlight><bold>414</bold></highlight> in conjunction with present invention. In the sample manifest <highlight><bold>600</bold></highlight>, there are four columns of information: an action column <highlight><bold>601</bold></highlight>, an ID column <highlight><bold>603</bold></highlight>, a new property column <highlight><bold>605</bold></highlight>, and a new value column <highlight><bold>607</bold></highlight>. The ID column <highlight><bold>603</bold></highlight> identifies the particular item (e.g., an e-mail message) to which the record in the manifest <highlight><bold>600</bold></highlight> pertains. For example, an item in the collection could be an e-mail message identified by the Object ID &ldquo;XXXX123.&rdquo; The property column <highlight><bold>605</bold></highlight> identifies the particular property of the item, such as a last modified time, or the like. The new value column <highlight><bold>607</bold></highlight> identifies the value to which the property has changed since the last synchronization. In this example, the property column <highlight><bold>605</bold></highlight> may identify the entire object, such as an entire e-mail message, or a property of that object, such as the subject field of an e-mail message or the telephone number of a contact. Thus, in one embodiment, once an object ID is listed in the ID column <highlight><bold>603</bold></highlight>, all the properties associated with that object and all the property values for that object are included in the manifest. In another embodiment, just the new values for the property are included in the manifest. The action column <highlight><bold>601</bold></highlight> identifies the particular action to perform on the property. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> is a graphical representation generally illustrating the salient portions of a sample synchronization state table <highlight><bold>344</bold></highlight> used in conjunction with the present invention. As mentioned earlier, the synchronization application <highlight><bold>342</bold></highlight> maintains the synchronization state table <highlight><bold>344</bold></highlight> in order to recover from a failed synchronization session in accordance with the present invention. In one embodiment, the sample synchronization state table <highlight><bold>344</bold></highlight> includes a last sync key entry <highlight><bold>702</bold></highlight>, a watermark entry <highlight><bold>704</bold></highlight>, a previous watermark entry <highlight><bold>706</bold></highlight>, a last manifest entry <highlight><bold>708</bold></highlight>, and an incremental watermarks entry <highlight><bold>710</bold></highlight>. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> The last sync key entry <highlight><bold>702</bold></highlight> stores the sync key <highlight><bold>402</bold></highlight> from the last client request <highlight><bold>324</bold></highlight>. The watermark entry <highlight><bold>704</bold></highlight> stores a state identifier identifying a state within the server data <highlight><bold>312</bold></highlight> at which the information server <highlight><bold>310</bold></highlight> believes it has synchronized. In one embodiment, the watermark entry <highlight><bold>704</bold></highlight> may store the last CollBlob received in the server response <highlight><bold>354</bold></highlight>. The previous watermark entry <highlight><bold>706</bold></highlight> stores the state identifier for a location within the server data at which the information server <highlight><bold>310</bold></highlight> and the mobile device <highlight><bold>320</bold></highlight> were successfully synchronized. In one embodiment, the previous watermark entry <highlight><bold>706</bold></highlight> may store a prior CollBlob. The last manifest entry <highlight><bold>708</bold></highlight> contains one or more client update commands from the client request <highlight><bold>324</bold></highlight>. In another embodiment, the last manifest entry <highlight><bold>708</bold></highlight> may contain a merged manifest based on the one or more client manifests that have not successfully been synchronized. The incremental watermarks entry <highlight><bold>710</bold></highlight> identifies the information that has been transmitted to the information server <highlight><bold>310</bold></highlight> from the mobile data <highlight><bold>322</bold></highlight> since the last successful synchronization transaction (identified by the previous watermark <highlight><bold>706</bold></highlight>). In one embodiment, the incremental watermarks entry <highlight><bold>710</bold></highlight> may contain AddBlobs. The synchronization state table <highlight><bold>344</bold></highlight> may be stored as a file in a hidden directory on the synchronization server <highlight><bold>340</bold></highlight>. One skilled in the art will appreciate that the synchronization state table <highlight><bold>344</bold></highlight> may also contain other information that is not pertinent to the discussion of the present invention. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> is a logical flow diagram generally illustrating an overview of a synchronization process having a synchronization recovery process for recovering from a failed synchronization session. The synchronization process with synchronization recovery <highlight><bold>800</bold></highlight> begins at block <highlight><bold>801</bold></highlight>, where the mobile device <highlight><bold>320</bold></highlight> has initiated a synchronization session. The mobile device <highlight><bold>320</bold></highlight> generates a client request <highlight><bold>324</bold></highlight> based on updated object information stored in its mobile data <highlight><bold>322</bold></highlight>. Processing continues at block <highlight><bold>802</bold></highlight>. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> At block <highlight><bold>802</bold></highlight>, the synchronization application <highlight><bold>342</bold></highlight> receives the client request <highlight><bold>324</bold></highlight>. The client request <highlight><bold>324</bold></highlight> includes the client manifest <highlight><bold>404</bold></highlight> that lists the updated object information in the mobile data <highlight><bold>322</bold></highlight>. In one embodiment, if the mobile device <highlight><bold>320</bold></highlight> does not receive a client response <highlight><bold>326</bold></highlight> associated with an earlier client request <highlight><bold>324</bold></highlight>, the mobile device <highlight><bold>320</bold></highlight> may repeat updated object information in the client manifest <highlight><bold>404</bold></highlight> that was included in the earlier client request. When this occurs, the information server <highlight><bold>310</bold></highlight> is unaware that the mobile device <highlight><bold>320</bold></highlight> has not received the client response <highlight><bold>326</bold></highlight> and the mobile device <highlight><bold>320</bold></highlight> is unaware that the information server <highlight><bold>310</bold></highlight> has already processed the earlier client request. Thus, in accordance with the present invention, the mobile device <highlight><bold>320</bold></highlight> repeats any updated object information in the next client manifest <highlight><bold>404</bold></highlight>. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> At block <highlight><bold>804</bold></highlight>, the synchronization application <highlight><bold>342</bold></highlight> tests whether there has been a synchronization failure. One embodiment is illustrated in <cross-reference target="DRAWINGS">FIG. 9</cross-reference> and implements the synchronization method described in the co-pending application entitled &ldquo;SYNC KEY&rdquo; referenced above. Briefly, as stated above, in that embodiment, an incrementing sync key is included in each client request. The sync key is incremented each time the mobile device <highlight><bold>320</bold></highlight> receives and successfully processes a client response <highlight><bold>326</bold></highlight> associated with the client request <highlight><bold>324</bold></highlight>. For this embodiment, testing for a synchronization failure begins at block <highlight><bold>901</bold></highlight> and proceeds to block <highlight><bold>902</bold></highlight>. At block <highlight><bold>902</bold></highlight>, the synchronization application <highlight><bold>342</bold></highlight> reads the synchronization state table <highlight><bold>344</bold></highlight> to determine the value of the last sync key that is stored in the last sync key entry <highlight><bold>702</bold></highlight> (shown in <cross-reference target="DRAWINGS">FIG. 7</cross-reference>). At block <highlight><bold>904</bold></highlight>, the value in the last sync entry <highlight><bold>702</bold></highlight> is compared to the value in the sync key field <highlight><bold>402</bold></highlight> in the client request <highlight><bold>324</bold></highlight>. Processing then returns to block <highlight><bold>806</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 8</cross-reference>. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> At decision block <highlight><bold>806</bold></highlight>, the synchronization application <highlight><bold>342</bold></highlight> determines whether there has been a synchronization failure. In the embodiment illustrated in <cross-reference target="DRAWINGS">FIG. 9</cross-reference> and described above, the synchronization application <highlight><bold>342</bold></highlight> bases the determination on the value in the last sync entry <highlight><bold>702</bold></highlight> and the value in the sync key field <highlight><bold>402</bold></highlight> of the client request <highlight><bold>324</bold></highlight>. If the value of the sync key in the client request <highlight><bold>324</bold></highlight> is one more than the value stored in the state table, there has not been any synchronization failure and processing proceeds to block <highlight><bold>810</bold></highlight>, where normal synchronization with the server data <highlight><bold>312</bold></highlight> is performed since there is no need to perform recovery. After the server data <highlight><bold>312</bold></highlight> is synchronized, the synchronization application <highlight><bold>342</bold></highlight> creates a client response <highlight><bold>326</bold></highlight>. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> At block <highlight><bold>812</bold></highlight>, the synchronization application <highlight><bold>342</bold></highlight> sends the client response <highlight><bold>326</bold></highlight> to the mobile device <highlight><bold>320</bold></highlight>. Once the mobile device <highlight><bold>320</bold></highlight> receives the client response <highlight><bold>326</bold></highlight> and processes the updates in the server manifest <highlight><bold>414</bold></highlight>, the synchronization session is complete. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> However, returning to decision block <highlight><bold>806</bold></highlight>, when the synchronization application <highlight><bold>342</bold></highlight> determines that there has been a synchronization failure, processing proceeds to block <highlight><bold>808</bold></highlight>. A synchronization failure will be detected, in the embodiment using sync keys described above, when the value in the last sync entry <highlight><bold>702</bold></highlight> is identical to the value in the sync key field <highlight><bold>402</bold></highlight> in the client request <highlight><bold>324</bold></highlight>. One skilled in the art will appreciate that other synchronization methods may be used without departing from the scope of the present invention. For example, in another embodiment, the server may generate and update a sync key. In this embodiment, a synchronization failure is detected if the sync key for the client and the server are not identical and the sync key for the client is one less than the sync key for the server. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> Briefly, at block <highlight><bold>808</bold></highlight>, the synchronization application <highlight><bold>342</bold></highlight>, in accordance with the present invention, accesses its synchronization state table <highlight><bold>344</bold></highlight> to determine the state of both the information server <highlight><bold>310</bold></highlight> and the mobile device <highlight><bold>320</bold></highlight> so that duplicate objects are not created in the server data <highlight><bold>312</bold></highlight> when the server data <highlight><bold>312</bold></highlight> and the mobile data <highlight><bold>322</bold></highlight> become synchronized. One embodiment of the synchronization recovery process is illustrated in <cross-reference target="DRAWINGS">FIG. 10</cross-reference> and described below. Once the synchronization recovery process is completed, processing proceeds to block <highlight><bold>812</bold></highlight> as described above and ends at end block <highlight><bold>814</bold></highlight>. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10</cross-reference> is a logical flow diagram illustrating one embodiment of a synchronization recovery process <highlight><bold>1000</bold></highlight> suitable for use in <cross-reference target="DRAWINGS">FIG. 8</cross-reference>. The synchronization recovery process <highlight><bold>1000</bold></highlight> begins at block <highlight><bold>1001</bold></highlight>, after the synchronization application <highlight><bold>342</bold></highlight> has determined that there has been a synchronization failure. Processing continues at block <highlight><bold>1002</bold></highlight>. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> At block <highlight><bold>1002</bold></highlight>, the synchronization application <highlight><bold>342</bold></highlight> creates an update manifest <highlight><bold>504</bold></highlight> which will be sent in the server request <highlight><bold>352</bold></highlight>. Briefly, the update manifest <highlight><bold>504</bold></highlight> is based on the last saved manifest located in the synchronization state table <highlight><bold>344</bold></highlight> and the current client manifest <highlight><bold>404</bold></highlight> included within the client request <highlight><bold>324</bold></highlight>. The update manifest <highlight><bold>504</bold></highlight> and client manifest <highlight><bold>324</bold></highlight> may have the same format. An example of one embodiment of the format is illustrated in <cross-reference target="DRAWINGS">FIG. 6</cross-reference> and described above. The creation of the update manifest <highlight><bold>504</bold></highlight>, in accordance with the present invention, allows the mobile data <highlight><bold>322</bold></highlight> and the server data <highlight><bold>312</bold></highlight> to become synchronized without duplicating objects in either location and without sending client errors to the information server <highlight><bold>310</bold></highlight>. The criteria for creating the update manifest <highlight><bold>504</bold></highlight> is illustrated in <cross-reference target="DRAWINGS">FIG. 11</cross-reference> and described below. Processing continues at block <highlight><bold>1004</bold></highlight>. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> At block <highlight><bold>1004</bold></highlight>, conflict resolution may optionally be performed. In general, when conflict resolution is performed, the synchronization application resolves conflicts with objects in the mobile data and the server data. In one embodiment, the synchronization application performs conflict resolution by comparing a server manifest with a client manifest to determine any conflicts. The conflicts may then be resolved using predetermined criteria, such as always keep the mobile data object. Processing continues at block <highlight><bold>1006</bold></highlight>. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> At block <highlight><bold>1006</bold></highlight>, the update manifest <highlight><bold>504</bold></highlight> is sent to the information server <highlight><bold>301</bold></highlight>. The information server performs any updates to the server data <highlight><bold>312</bold></highlight>. The information server then sends the server response <highlight><bold>354</bold></highlight> to the synchronization application <highlight><bold>342</bold></highlight>. Processing continues at block <highlight><bold>1008</bold></highlight>. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> At block <highlight><bold>1008</bold></highlight>, the synchronization application <highlight><bold>342</bold></highlight> receives the server response <highlight><bold>354</bold></highlight>. Once the server response <highlight><bold>354</bold></highlight> is received, the synchronization application <highlight><bold>342</bold></highlight> updates the synchronization state table <highlight><bold>344</bold></highlight> at block <highlight><bold>1010</bold></highlight>. In general, the synchronization application <highlight><bold>342</bold></highlight> stores the sync key <highlight><bold>402</bold></highlight> and the client manifest <highlight><bold>404</bold></highlight> from the client request <highlight><bold>324</bold></highlight> in the last sync key entry <highlight><bold>702</bold></highlight> and last manifest entry <highlight><bold>708</bold></highlight>, respectively. The synchronization application <highlight><bold>342</bold></highlight> stores the watermark <highlight><bold>512</bold></highlight> from the server response <highlight><bold>354</bold></highlight> in the watermark entry <highlight><bold>704</bold></highlight> of the synchronization state table <highlight><bold>344</bold></highlight>. Once the synchronization state table <highlight><bold>344</bold></highlight> is updated, the synchronization application <highlight><bold>342</bold></highlight> builds the client response <highlight><bold>326</bold></highlight> that, in one embodiment, includes the sync key <highlight><bold>412</bold></highlight> and the server manifest <highlight><bold>414</bold></highlight>. The synchronization recovery process is then complete. Processing continue to return block <highlight><bold>1014</bold></highlight> which returns to block <highlight><bold>812</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 8</cross-reference> and proceeds as described above. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 11</cross-reference> is a table illustrating various outcomes for the update manifest based on various conditions of the last manifest and the current manifest that may occur in accordance with one embodiment of the present invention. In the table <highlight><bold>1100</bold></highlight>, there are five columns of information: a case column <highlight><bold>1102</bold></highlight>, a last saved manifest column <highlight><bold>1104</bold></highlight>, a current manifest column <highlight><bold>1106</bold></highlight>, an update manifest column <highlight><bold>1108</bold></highlight> and a criteria for creating the update manifest column <highlight><bold>1110</bold></highlight>. The case column <highlight><bold>1102</bold></highlight> identifies one of several cases that the synchronization application <highlight><bold>342</bold></highlight> may incur while creating the update manifest. In the table <highlight><bold>1100</bold></highlight> shown, there are nine such cases <highlight><bold>1120</bold></highlight>-<highlight><bold>1136</bold></highlight>. The last saved manifest column <highlight><bold>1104</bold></highlight> identifies an action <highlight><bold>601</bold></highlight> for an object as specified in the client manifest for which the information server <highlight><bold>310</bold></highlight> has completed processing. This information is obtained from the synchronization state table <highlight><bold>344</bold></highlight>. Typically, the action <highlight><bold>601</bold></highlight> may include an &ldquo;ADD&rdquo;, a &ldquo;DELETE&rdquo;, or a &ldquo;CHANGE&rdquo;. The current manifest column <highlight><bold>1106</bold></highlight> identifies the action for the same object as specified in the current client manifest <highlight><bold>404</bold></highlight> received by the synchronization application <highlight><bold>342</bold></highlight>. The update manifest column <highlight><bold>1108</bold></highlight> identifies the action for the object based on the action specified in the last saved manifest column <highlight><bold>1104</bold></highlight> and the current manifest field <highlight><bold>1106</bold></highlight> using the criteria specified in column <highlight><bold>1110</bold></highlight>. The abbreviation &ldquo;O-N-E&rdquo; means the object is non-existent. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> In general, the criterion listed in column <highlight><bold>1110</bold></highlight> insures that the number of duplicate objects created in the server data <highlight><bold>312</bold></highlight> or the mobile data <highlight><bold>322</bold></highlight> is minimized and that proper update commands are sent to the server. For case 1, entry <highlight><bold>1120</bold></highlight>, if the object is specified as an &ldquo;ADD&rdquo; in both the last saved manifest and the current manifest, the update manifest may specify the object as an &ldquo;ADD&rdquo; or &ldquo;CHANGE&rdquo; depending on whether the object has an associated serverId in the synchronization state table <highlight><bold>344</bold></highlight>. The serverID is identified in the ID column <highlight><bold>603</bold></highlight> of the sample manifest <highlight><bold>600</bold></highlight> illustrated in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>. If there is an associated serverId, the synchronization application <highlight><bold>342</bold></highlight> knows that the information server <highlight><bold>310</bold></highlight> has already successfully added this object and the update manifest should specify the object as a &ldquo;CHANGE&rdquo; in order to incorporate any differences between the manifests. However, if an associated serverID is not in the synchronization state table, the synchronization application <highlight><bold>342</bold></highlight> knows that the information server <highlight><bold>310</bold></highlight> failed to add this object during the last synchronization session. Therefore, the synchronization application <highlight><bold>342</bold></highlight> specifies an &ldquo;ADD&rdquo; for the object in the update manifest. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> For case 2, entry <highlight><bold>1122</bold></highlight>, if the object is specified as an &ldquo;ADD&rdquo; in the last saved manifest and is specified as a &ldquo;CHANGE&rdquo; in the current manifest, the synchronization application <highlight><bold>342</bold></highlight> will not include the object in the update manifest and will instead return an error to the mobile device. Alternatively, the &ldquo;CHANGE&rdquo; specification may be included in current manifest. </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> For case 3, entry <highlight><bold>1124</bold></highlight>, if the object is specified as an &ldquo;ADD&rdquo; in the last saved manifest and is non-existent in the current manifest, the synchronization application <highlight><bold>342</bold></highlight> will specify a &ldquo;DELETE&rdquo; for the object in the update manifest. This case occurs when the mobile device <highlight><bold>320</bold></highlight> deletes an object after including it in a sync manifest, but before receiving confirmation that the information server properly added the object in response to an earlier client request. Alternatively, the &ldquo;DELETE&rdquo; specification may be included in current manifest. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> For case 4, entry <highlight><bold>1126</bold></highlight>, if the object is specified as a &ldquo;DELETE&rdquo; in the last saved manifest and specified as an &ldquo;ADD&rdquo; in the current manifest, the synchronization application <highlight><bold>342</bold></highlight> will not include the object in the update manifest and will instead return an error to the mobile device. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> For case 5, entry <highlight><bold>1128</bold></highlight>, if the object is specified as a &ldquo;DELETE&rdquo; in the last saved manifest and specified as a &ldquo;DELETE&rdquo; in the current manifest, the synchronization application <highlight><bold>342</bold></highlight> will specify a &ldquo;DELETE&rdquo; in the update manifest. For this case, even if the information server had successfully performed the &ldquo;DELETE&rdquo; in the prior failed synchronization session, by performing the &ldquo;DELETE&rdquo; again, the error message stating that the object does not exist will be ignored and the &ldquo;DELETE&rdquo; will be successful. </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> For case 6, entry <highlight><bold>1130</bold></highlight>, if the object is specified as a &ldquo;DELETE&rdquo; in the last saved manifest and specified as a &ldquo;CHANGE&rdquo; in the current manifest, the synchronization application <highlight><bold>342</bold></highlight> will not include the object in the update manifest and will instead return an error to the mobile device. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> For case 7, entry <highlight><bold>1132</bold></highlight>, if the object is specified as a &ldquo;CHANGE&rdquo; in the last saved manifest and specified as an &ldquo;ADD&rdquo; in the current manifest, the synchronization application <highlight><bold>342</bold></highlight> will not include the object in the update manifest and will instead return an error to the mobile device. </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> For case 8, entry <highlight><bold>1134</bold></highlight>, if the object is specified as a &ldquo;CHANGE&rdquo; in the last saved manifest and specified as a &ldquo;CHANGE&rdquo; in the current manifest, the synchronization application <highlight><bold>342</bold></highlight> will specify a &ldquo;CHANGE&rdquo; for the object in the update manifest. This will allow any differences in the object to be properly included on the server data <highlight><bold>312</bold></highlight>. </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> For case 9, entry <highlight><bold>1136</bold></highlight>, if the object is specified as a &ldquo;CHANGE&rdquo; in the last saved manifest and specified as a &ldquo;DELETE&rdquo; in the current manifest, the synchronization application <highlight><bold>342</bold></highlight> will specify a &ldquo;DELETE&rdquo; for the object in the update manifest. Because the mobile device <highlight><bold>320</bold></highlight> does not wish to keep the object anymore, the changes from the last saved manifest are not needed. </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> The remaining entries (2.5, 10, 11, 12, 13, 14) are included as further examples of outcomes for the update manifest based on various conditions of the last manifest and the current manifest that may occur in one illustrative embodiment. One skilled in the art will appreciate that the actions illustrated in <cross-reference target="DRAWINGS">FIG. 11</cross-reference> may be changed based on an agreement between the client and server without departing from the scope of the present invention. Thus, by maintaining the synchronization state table <highlight><bold>344</bold></highlight> in accordance with the present invention, the present invention can reduce the number of duplicate objects in the server data <highlight><bold>312</bold></highlight> and the mobile data <highlight><bold>322</bold></highlight> due to failed synchronization sessions. While the described embodiment of this invention uses wireless technology due to its tendency for lost or terminated sessions, the invention may be implemented using fixed devices without departing from the spirit of the invention. </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> The above specification, examples and data provide a complete description of the manufacture and use of the composition of the invention. Since many embodiments of the invention can be made without departing from the spirit and scope of the invention, the invention resides in the claims hereinafter appended. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">We claim: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A computer-implemented method for recovering from a failed synchronization session between a mobile device and a server, comprising: 
<claim-text>a) receiving a client request for a synchronization session; </claim-text>
<claim-text>b) determining whether a prior synchronization session failed; and </claim-text>
<claim-text>c) if the prior synchronization session failed, 
<claim-text>1) creating a server request based on the client request and on a synchronization state associated with the failed prior synchronization session; </claim-text>
<claim-text>2) sending the server request to the server for processing; </claim-text>
<claim-text>3) receiving a server response from the server based on the processing of the server request at the server; </claim-text>
<claim-text>4) modifying the synchronization state based on the server response and the client request; </claim-text>
<claim-text>5) creating a client response based on the server response; and </claim-text>
<claim-text>6) sending the client response to the mobile device. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The computer-implemented method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the client request includes a sync key that updates to a pre-determined value each time the client request for the synchronization session is successful, the synchronization state includes a last sync key and determining whether the prior synchronization session failed comprises comparing the sync key in the client request with the last sync key. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The computer-implemented method of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, wherein the prior synchronization session is determined to have failed if the sync key in the client request is one less than the last sync key. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The computer-implemented method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the client request includes a manifest comprising changes to a mobile data store after a prior successful synchronization session. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The computer-implemented method of <dependent-claim-reference depends_on="CLM-00004">claim 4</dependent-claim-reference>, wherein the changes include changes from a prior manifest associated with the synchronization session that failed. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The computer-implemented method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the server request includes an update manifest, the update manifest comprises one or more objects and an update action associated with each of the one or more objects, the update action being based on the client request and the synchronization state. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The computer-implemented method of <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference>, wherein the client request includes a manifest and at least one of the one or more objects in the update manifest does not have a corresponding object in the manifest of the client request. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The computer-implemented method of <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference>, wherein the update action is based on a current action specified in the client request and a last action specified in the synchronization state. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The computer-implemented method of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference>, wherein the update action is identical to the current action. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The computer-implemented method of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference>, wherein the update action is identical to the last action. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The computer-implemented method of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference>, wherein the update action is different than the current action and the last action. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The computer-implemented method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the synchronization state includes a last manifest associated with a manifest in the client request for the prior synchronization session that lists changes to a mobile data store after a prior successful synchronization session, a watermark identifying a state within a server store at which the server has synchronized the server store, a prior watermark which identifies a prior state of the watermark. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The computer-implemented method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising storing the synchronization state to a non-volatile storage media. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. A computer-readable medium having computer-executable components with instructions for recovering from a failed synchronization session between a first data store and a second data store, comprising: 
<claim-text>a synchronization component configured to detect a failed synchronization session based on a client synchronization request and a synchronization state and to perform a synchronization recovery upon detecting the failed synchronization session, the synchronization recovery comprising: 
<claim-text>creating an update manifest based on the synchronization state and the synchronization request, the update manifest includes changes to the first data store that were not provided in a prior synchronization request and excludes changes provided in the synchronization request that were previously updated on the second data store during the failed synchronization session; and </claim-text>
<claim-text>sending the update manifest to a device configured to update the second data store. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference>, wherein the synchronization state includes a last client manifest associated with the failed synchronization session, a watermark identifying a position with the second data store at which the second data store is synchronized. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference>, wherein the watermark comprises a collblob. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference>, wherein the synchronization component is further configured to store the synchronization state to a non-volatile storage media. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference>, wherein the synchronization component is further configured to store the synchronization state to a non-volatile storage media. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. A system for recovering from a failed synchronization session between a first data store and a second data store, comprising: 
<claim-text>a first device associated with the first data store; </claim-text>
<claim-text>a second device associated with the second data store; and </claim-text>
<claim-text>a server coupled to a storage medium on which a synchronization state associated with a first synchronization session is stored, the server configured to access the synchronization state upon receiving a subsequent synchronization request and to determine whether the subsequent synchronization request corresponds to the first synchronization session, if the synchronization request corresponds to the first synchronization session, the server is configured to initiate a recovery synchronization session. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference>, wherein the recovery synchronization session includes creating an update manifest based on the synchronization state and the subsequent synchronization request and sending the update manifest for processing on the second device, the update manifest includes changes to the first data store that were not previously updated on the second data store and excludes changes provided in the subsequent synchronization request that were previously updated on the second data store during the failed synchronization session. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference>, wherein the second device comprises the server. </claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference>, wherein the subsequent synchronization request corresponds to the first synchronization session when a sync key in the subsequent synchronization request is one less than a last sync key stored in the synchronization state.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>3</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005161A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005161A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005161A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005161A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005161A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005161A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030005161A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030005161A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030005161A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00009">
<image id="EMI-D00009" file="US20030005161A1-20030102-D00009.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
