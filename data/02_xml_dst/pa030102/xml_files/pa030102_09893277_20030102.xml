<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030002348A1-20030102-D00000.TIF SYSTEM "US20030002348A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030002348A1-20030102-D00001.TIF SYSTEM "US20030002348A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030002348A1-20030102-D00002.TIF SYSTEM "US20030002348A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030002348A1-20030102-D00003.TIF SYSTEM "US20030002348A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030002348A1-20030102-D00004.TIF SYSTEM "US20030002348A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030002348A1-20030102-D00005.TIF SYSTEM "US20030002348A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030002348A1-20030102-D00006.TIF SYSTEM "US20030002348A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030002348A1-20030102-D00007.TIF SYSTEM "US20030002348A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030002348A1-20030102-D00008.TIF SYSTEM "US20030002348A1-20030102-D00008.TIF" NDATA TIF>
<!ENTITY US20030002348A1-20030102-D00009.TIF SYSTEM "US20030002348A1-20030102-D00009.TIF" NDATA TIF>
<!ENTITY US20030002348A1-20030102-D00010.TIF SYSTEM "US20030002348A1-20030102-D00010.TIF" NDATA TIF>
<!ENTITY US20030002348A1-20030102-D00011.TIF SYSTEM "US20030002348A1-20030102-D00011.TIF" NDATA TIF>
<!ENTITY US20030002348A1-20030102-D00012.TIF SYSTEM "US20030002348A1-20030102-D00012.TIF" NDATA TIF>
<!ENTITY US20030002348A1-20030102-D00013.TIF SYSTEM "US20030002348A1-20030102-D00013.TIF" NDATA TIF>
<!ENTITY US20030002348A1-20030102-D00014.TIF SYSTEM "US20030002348A1-20030102-D00014.TIF" NDATA TIF>
<!ENTITY US20030002348A1-20030102-D00015.TIF SYSTEM "US20030002348A1-20030102-D00015.TIF" NDATA TIF>
<!ENTITY US20030002348A1-20030102-D00016.TIF SYSTEM "US20030002348A1-20030102-D00016.TIF" NDATA TIF>
<!ENTITY US20030002348A1-20030102-D00017.TIF SYSTEM "US20030002348A1-20030102-D00017.TIF" NDATA TIF>
<!ENTITY US20030002348A1-20030102-D00018.TIF SYSTEM "US20030002348A1-20030102-D00018.TIF" NDATA TIF>
<!ENTITY US20030002348A1-20030102-D00019.TIF SYSTEM "US20030002348A1-20030102-D00019.TIF" NDATA TIF>
<!ENTITY US20030002348A1-20030102-D00020.TIF SYSTEM "US20030002348A1-20030102-D00020.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030002348</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09893277</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010627</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G11C005/00</ipc>
</classification-ipc-primary>
<classification-ipc-secondary>
<ipc>G11C011/34</ipc>
</classification-ipc-secondary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>365</class>
<subclass>189010</subclass>
</uspc>
</classification-us-primary>
<classification-us-secondary>
<uspc>
<class>365</class>
<subclass>230030</subclass>
</uspc>
</classification-us-secondary>
</classification-us>
<title-of-invention>OPERATING TECHNIQUES FOR REDUCING EFFECTS OF COUPLING BETWEEN STORAGE ELEMENTS OF A NON-VOLATILE MEMORY OPERATED IN MULTIPLE DATA STATES</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Jian</given-name>
<family-name>Chen</family-name>
</name>
<residence>
<residence-us>
<city>San Jose</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Tomoharu</given-name>
<family-name>Tanaka</family-name>
</name>
<residence>
<residence-non-us>
<city>Yokohama</city>
<country-code>JP</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Yupin</given-name>
<family-name>Fong</family-name>
</name>
<residence>
<residence-us>
<city>Fremont</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Khandker</given-name>
<middle-name>N.</middle-name>
<family-name>Quader</family-name>
</name>
<residence>
<residence-us>
<city>Sunnyvale</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<assignee>
<organization-name>SanDisk Corporation</organization-name>
<assignee-type>02</assignee-type>
</assignee>
<correspondence-address>
<name-1>SKJERVEN MORRILL LLP</name-1>
<name-2></name-2>
<address>
<address-1>THREE EMBARCADERO CENTER, 28TH FLOOR</address-1>
<city>SAN FRANCISCO</city>
<state>CA</state>
<postalcode>94111</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A non-volatile memory system having an array of memory cells with at least one storage element each is operated with a plurality of storage level ranges per storage element. A flash electrically erasable and programmable read only memory (EEPROM) is an example, wherein the storage elements are electrically floating gates. The memory is operated to minimize the effect of charge coupled between adjacent floating gates, by programming some cells a second time after adjacent cells have been programmed. The second programming step also compacts a distribution of charge levels within at least some of the programming states. This increases the separation between states and/or allows more states to be included within a given storage window. An implementation that is described is for a NAND type of flash EEPROM. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">FIELD OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> This invention relates generally to a non-volatile memory and its operation, and, more specifically, to techniques for reducing the effects of data stored in one memory storage element upon data read from other storage elements. </paragraph>
</section>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> The principles of the present invention have application to various types of non-volatile memories, those currently existing and those contemplated to use new technology being developed. Implementations of the present invention, however, are described with respect to a flash electrically-erasable and programmable read-only memory (EEPROM), wherein the storage elements are floating gates. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> Field effect coupling between adjacent floating gates is described in U.S. Pat. No. 5,867,429 of Jian Chen and Yupin Fong, which patent is incorporated herein in its entirety by this reference. The degree of this coupling is necessarily increasing as the sizes of memory cell arrays are being decreased as the result of improvements of integrated circuit manufacturing techniques. The problem occurs most pronouncedly between two sets of adjacent cells that have been programmed at different times. One set of cells is programmed to add a level of charge to their floating gates that corresponds to one set of data. After the second set of cells is programmed with a second set of data, the charge levels read from the floating gates of the first set of cells often appears to be different than programmed because of the effect of the charge on the second set of floating gates being coupled with the first. This is known as the Yupin effect. Aforementioned U.S. Pat. No. 5,867,429 suggests either physically isolating the two sets of floating gates from each other, or taking into account the effect of the charge on the second set of floating gates when reading that of the first. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> This effect is present in various types of flash EEPROM cell arrays. A NOR array of one design has its memory cells connected between adjacent bit (column) lines and control gates connected to word (row) lines. The individual cells contain either one floating gate transistor, with or without a select transistor formed in series with it, or two floating gate transistors separated by a single select transistor. Examples of such arrays and their use in storage systems are given in the following U.S. patents and pending applications of SanDisk Corporation that are incorporated herein in their entirety by this reference: U.S. Pat. Nos. 5,095,344, 5,172,338, 5,602,987, 5,663,901, 5,430,859, 5,657,332, 5,712,180, 5,890,192, and 6,151,248, and Ser. Nos. 09/505,555, filed Feb. 17, 2000, and 09/667,344, filed Sep. 22, 2000. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> A NAND array of one design has a number of memory cells, such as 8, 16 or even 32, connected in series string between a bit line and a reference potential through select transistors at either end. Word lines are connected with control gates of cells in different series strings. Relevant examples of such arrays and their operation are given in the following U.S. patents and pending application of Toshiba that are incorporated herein in their entirety by this reference: U.S. Pat. Nos. 5,570,315, 5,774,397 and 6,046,935, and Ser. No. 09/667,610. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> It is still most common in current commercial products for each floating gate to store a single bit of data by operating in a binary mode, where only two ranges of threshold levels of the floating gate transistors are defined as storage levels. The threshold levels of a floating gate transistor correspond to ranges of charge levels stored on their floating gates. In addition to shrinking the size of the memory arrays, the trend is to further increase the density of data storage of such memory arrays by storing more than one bit of data in each floating gate transistor. This is accomplished by defining more than two threshold levels as storage states for each floating gate transistor, four such states (2 bits of data per floating gate) now being included in commercial products. More storage states, such as 16 states per storage element, are contemplated. Each floating gate transistor has a certain total range (window) of threshold voltages in which it may practically be operated, and that range is divided into the number of states defined for it plus margins between the states to allow for them to be clearly differentiated from one another. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> A common operation of these types of non-volatile memories is to erase blocks of memory cells prior to reprogramming them. The cells within the block are then individually programmed out of erase into states represented by the incoming data being stored. Programming typically includes alternate application to a large number of memory cells in parallel of programming voltage pulses and a reading of their individual states to determine whether the individual cells have reached their intended levels. Programming is stopped for any cell that is verified to have reached its intended threshold level while programming of the other cells being programmed in parallel continues until all of those cells are programmed. When the number of storage states per storage element is increased, the time to perform the programming will usually be increased since the smaller voltage ranges for the individual states requires a greater precision of programming. This can have a significant adverse impact on the performance of the memory system. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> The narrower ranges of the defined floating gate storage levels that result from multi-state operation increases the level of sensitivity of a first group of storage elements to the amount of charge stored on a later programmed second group of adjacent storage elements. When the first group is being read, for example, the charge on the second group can lead to errors in reading the states of the first group. The field coupled from the adjacent memory elements can shift the apparent state being read a sufficient amount to lead to an erroneous read of at least some bits of a group of stored data. If the number of erroneous bits is maintained within the capability of an error correction code (ECC), the errors are corrected but if the number of errors is typically larger than that, some other structural and/or operating technique(s) needs to be employed. The techniques described in aforementioned U.S. Pat. No. 5,867,429 are suitable for many arrays but it is desired to provide additional techniques to compensate for the operational effect of field coupling between adjacent floating gates. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> Therefore, according to one primary aspect of the present invention, a first group of memory storage elements are reprogrammed to their desired states after a second adjacent group of storage elements has been programmed. Since periodically reading the state of the cells is part of the programming process in order to know when to stop, the reprogramming places any additional charge on the first group of storage elements that is necessary to compensate for the effect of the field coupling with the later programmed adjacent storage elements. An alternating pulse and reading sequence of a typical programming operation may be used to reprogram the first group of storage elements in the presence of the effect of the second adjacent programmed group of storage elements. A later reading of the first group of cells, even though still influenced by the charge on adjacent cells, is now more accurate since the effect of the charge on the adjacent cells has been taken into account as a result of the reprogramming. In order to avoid having to maintain a data buffer that is large enough to hold the data programmed in the first pass for later use in the second programming pass, the data stored by the first pass may be read from the memory with adjusted read margins and then that data is reprogrammed in the second pass. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> According to another primary aspect of the present invention, a distribution of programming levels among storage elements programmed to the same state is compacted by reprogramming some of the storage elements on one side of the distribution into the other side of the distribution. The storage elements of a given state are all read and those having programmed levels below a defined threshold within the distribution are given additional programming to raise their levels above the defined threshold. This has the effect of reducing the amount of the programming window that is required for each of the states of the memory, thus allowing additional states to be included and/or additional space to be provided between states. Such compacting can be performed independently of the aspect described in the preceding paragraph but may also advantageously be included as part of the reprogramming steps. Indeed, the second programming pass may occur immediately after the first programming of the same group of cells in order to narrow the programmed level distributions to an extent that takes into account the apparent spreading of these distributions that occurs after programming of adjacent cells. The step increase of programming pulse voltage levels may be made higher than usual for the first programming pass, in order to quickly program a group of cells to their initial levels within broad distributions, and then the usual small incremental voltage increase of programming pulses during the second pass in order to compact the spread of those distributions. These techniques result in improved performance by allowing the narrow voltage threshold distributions of the programmed memory cells to be reached quickly. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> According to another primary aspect of the present invention, the order in which adjacent memory cells are programmed according to an existing multi-state programming technique is accomplished in a manner that minimizes the Yupin effect of cross-coupling between such adjacent cells. According to the existing programming technique, a first group of alternate adjacent cells in a row or column is partially programmed in a first programming step to the levels of a first data bit, a remaining second group of alternate cells is then similarly partially programmed to the levels of a first data bit for those cells, followed by completing the programming of the first group with a second bit of data per cell, and, finally, the programming of the second group is then completed with its second bit. But in order to minimize the Yupin effect among the storage elements of such cells, according to a third primary aspect of the present invention, both bits are programmed in separate steps into the first group of cells, followed by programming the second group of cells with its two bits of data in separate steps. This technique is particularly applicable, but not limited to, use during programming a NAND memory. This technique may be used by itself, or with the techniques of the first and/or second primary aspects of the present invention that are summarized above, to counteract, in various degrees, the Yupin effect of coupling between adjacent storage elements. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> Additional aspects, features and advantages of the present invention are included in the following description of exemplary embodiments, which description should be taken in conjunction with the accompanying drawings.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a block diagram of a non-volatile memory system in which the various aspects of the present invention are described to be implemented; </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> illustrates an existing circuit and organization of the memory array of <cross-reference target="DRAWINGS">FIG. 1</cross-reference> when a NAND type; </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> shows a cross-sectional view, along a column, of a NAND type of memory array formed on a semiconductor substrate; </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a cross-sectional view of the memory array of <cross-reference target="DRAWINGS">FIG. 3</cross-reference>, taken at section <highlight><bold>4</bold></highlight>-<highlight><bold>4</bold></highlight> thereof; </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a cross-sectional view of the memory array of <cross-reference target="DRAWINGS">FIG. 3</cross-reference>, taken at section <highlight><bold>5</bold></highlight>-<highlight><bold>5</bold></highlight> thereof; </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> provides Table 1 of example operating voltages of the NAND memory cell array of FIGS. <highlight><bold>2</bold></highlight>-<highlight><bold>5</bold></highlight>; </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> illustrates another feature of the NAND memory cell array of FIGS. <highlight><bold>2</bold></highlight>-<highlight><bold>5</bold></highlight>; </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> shows an example existing distribution of threshold voltages of the NAND memory cell array of FIGS. <highlight><bold>2</bold></highlight>-<highlight><bold>5</bold></highlight> when operated in four states; </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9B</cross-reference> shows existing voltage threshold responses of the memory cell array of FIGS. <highlight><bold>2</bold></highlight>-<highlight><bold>5</bold></highlight> in response to being programmed with voltage pulses of <cross-reference target="DRAWINGS">FIG. 9A</cross-reference>; </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 10A and 10B</cross-reference> are voltage threshold level distributions that illustrate an existing technique for programming the memory cell array of FIGS. <highlight><bold>2</bold></highlight>-<highlight><bold>5</bold></highlight>; </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 11</cross-reference> shows the Yupin effect on threshold distributions of the memory cell array of FIGS. <highlight><bold>2</bold></highlight>-<highlight><bold>5</bold></highlight> when programmed with an existing technique; </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 12</cross-reference> shows the Yupin effect on threshold distributions of the memory cell array of FIGS. <highlight><bold>2</bold></highlight>-<highlight><bold>5</bold></highlight> when programmed with a first technique illustrating the present invention; </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 13</cross-reference> illustrates the steps of programming the memory cell array of FIGS. <highlight><bold>2</bold></highlight>-<highlight><bold>5</bold></highlight> according to the first technique whose results are shown in <cross-reference target="DRAWINGS">FIG. 12</cross-reference>. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 14B</cross-reference> shows voltage threshold level responses of the memory cell array of FIGS. <highlight><bold>2</bold></highlight>-<highlight><bold>5</bold></highlight> to programming pulses of <cross-reference target="DRAWINGS">FIG. 14A</cross-reference> according to the programming method of <cross-reference target="DRAWINGS">FIG. 13</cross-reference>; </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 15B</cross-reference> shows voltage threshold level responses of the memory cell array of FIGS. <highlight><bold>2</bold></highlight>-<highlight><bold>5</bold></highlight> to an alternate set of programming pulses of <cross-reference target="DRAWINGS">FIG. 15A</cross-reference> according to the programming method of <cross-reference target="DRAWINGS">FIG. 13</cross-reference>; </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 16</cross-reference> shows the Yupin effect on threshold distributions of the memory cell array of FIGS. <highlight><bold>2</bold></highlight>-<highlight><bold>5</bold></highlight> when programmed with a second technique illustrating the present invention; </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 17</cross-reference> illustrates the steps of programming the memory cell array of FIGS. <highlight><bold>2</bold></highlight>-<highlight><bold>5</bold></highlight> according to the second technique whose results are shown in <cross-reference target="DRAWINGS">FIG. 16</cross-reference>; </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 18</cross-reference> shows the Yupin effect on threshold distributions of the memory cell array of FIGS. <highlight><bold>2</bold></highlight>-<highlight><bold>5</bold></highlight> when programmed with a variation of the second technique illustrating the present invention; </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 19</cross-reference> illustrates the steps of programming the memory cell array of FIGS. <highlight><bold>2</bold></highlight>-<highlight><bold>5</bold></highlight> according to the variation of the second technique whose results are shown in <cross-reference target="DRAWINGS">FIG. 18</cross-reference>; </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 20</cross-reference> shows the Yupin effect on threshold distributions of the memory cell array of FIGS. <highlight><bold>2</bold></highlight>-<highlight><bold>5</bold></highlight> when programmed with a third technique illustrating the present invention; </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 21</cross-reference> is a flow chart showing a first part of a first exemplary embodiment of a method of programming the memory cell array of FIGS. <highlight><bold>2</bold></highlight>-<highlight><bold>5</bold></highlight>; </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 22</cross-reference> is a flow chart showing a second part of the first exemplary embodiment of a method of programming the memory cell array of FIGS. <highlight><bold>2</bold></highlight>-<highlight><bold>5</bold></highlight>; </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 23</cross-reference> is a flow chart showing a first part of a second exemplary embodiment of a method of programming the memory cell array of FIGS. <highlight><bold>2</bold></highlight>-<highlight><bold>5</bold></highlight>; </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 24</cross-reference> is a flow chart showing a second part of the second exemplary embodiment of a method of programming the memory cell array of FIGS. <highlight><bold>2</bold></highlight>-<highlight><bold>5</bold></highlight>; </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 25</cross-reference> is a flow chart showing, when combined with <cross-reference target="DRAWINGS">FIG. 21, a</cross-reference> first part of a third exemplary embodiment of a method of programming the memory cell array of FIGS. <highlight><bold>2</bold></highlight>-<highlight><bold>5</bold></highlight>; </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 26</cross-reference> is a flow chart showing, when combined with <cross-reference target="DRAWINGS">FIG. 22, a</cross-reference> second part of the third exemplary embodiment of a method of programming the memory cell array of FIGS. <highlight><bold>2</bold></highlight>-<highlight><bold>5</bold></highlight>; </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 27</cross-reference> is a flow chart showing, when combined with <cross-reference target="DRAWINGS">FIG. 23, a</cross-reference> first part of a fourth exemplary embodiment of a method of programming the memory cell array of FIGS. <highlight><bold>2</bold></highlight>-<highlight><bold>5</bold></highlight>; </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 28</cross-reference> is a flow chart showing, when combined with <cross-reference target="DRAWINGS">FIG. 24, a</cross-reference> second part of the fourth exemplary embodiment of a method of programming the memory cell array of FIGS. <highlight><bold>2</bold></highlight>-<highlight><bold>5</bold></highlight>; </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 29</cross-reference> illustrates a programming sequence utilizing the third and fourth embodiments; </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 30</cross-reference> shows a first part of a method to read data from the memory of FIGS. <highlight><bold>2</bold></highlight>-<highlight><bold>5</bold></highlight>; and </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 31</cross-reference> shows a second part of the method to read data from the memory of FIGS. <highlight><bold>2</bold></highlight>-<highlight><bold>5</bold></highlight>.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DESCRIPTION OF EXEMPLARY EMBODIMENTS </heading>
<paragraph id="P-0044" lvl="7"><number>&lsqb;0044&rsqb;</number> Example Non-Volatile Memory System </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> With reference to FIGS. <highlight><bold>1</bold></highlight>-<highlight><bold>7</bold></highlight>, a specific non-volatile memory system is described in which the various aspects of the present invention are implemented, in order to provide specific examples. <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a block diagram of a flash memory system. Memory cell array <highlight><bold>1</bold></highlight> including a plurality of memory cells M arranged in a matrix is controlled by a column control circuit <highlight><bold>2</bold></highlight>, a row control circuit <highlight><bold>3</bold></highlight>, a c-source control circuit <highlight><bold>4</bold></highlight> and a c-p-well control circuit <highlight><bold>5</bold></highlight>. The column control circuit <highlight><bold>2</bold></highlight> is connected to bit lines (BL) of the memory cell array <highlight><bold>1</bold></highlight> for reading data stored in the memory cells (M), for determining a state of the memory cells (M) during a program operation, and for controlling potential levels of the bit lines (BL) to promote the programming or to inhibit the programming. The row control circuit <highlight><bold>3</bold></highlight> is connected to word lines (WL) to select one of the word lines (WL), to apply read voltages, to apply a program voltages combined with the bit line potential levels controlled by the column control circuit <highlight><bold>2</bold></highlight>, and to apply an erase voltage coupled with a voltage of a p-type region (labeled as &ldquo;c-p-well&rdquo; <highlight><bold>11</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>) on which the memory cells (M) are formed. The c-source control circuit <highlight><bold>4</bold></highlight> controls a common source line (labeled as &ldquo;c-source&rdquo; in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>) connected to the memory cells (M). The c-p-well control circuit <highlight><bold>5</bold></highlight> controls the c-p-well voltage. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> The data stored in the memory cells (M) are read out by the column control circuit <highlight><bold>2</bold></highlight> and are output to external I/O lines via an I/O line and a data input/output buffer <highlight><bold>6</bold></highlight>. Program data to be stored in the memory cells are input to the data input/output buffer <highlight><bold>6</bold></highlight> via the external I/O lines, and transferred to the column control circuit <highlight><bold>2</bold></highlight>. The external I/O lines are connected to a controller <highlight><bold>20</bold></highlight>. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> Command data for controlling the flash memory device are input to a command interface) connected to external control lines which are connected with the controller <highlight><bold>20</bold></highlight>. The command data informs the flash memory of what operation is requested. The input command is transferred to a state machine <highlight><bold>8</bold></highlight> that controls the column control circuit <highlight><bold>2</bold></highlight>, the row control circuit <highlight><bold>3</bold></highlight>, the c-source control circuit <highlight><bold>4</bold></highlight>, the c-p-well control circuit <highlight><bold>5</bold></highlight> and the data input/output buffer <highlight><bold>6</bold></highlight>. The state machine <highlight><bold>8</bold></highlight> can output a status data of the flash memory such as READY/BUSY or PASS/FAIL. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> The controller <highlight><bold>20</bold></highlight> is connected or connectable with a host system such as a personal computer, a digital camera, a personal digital assistant. It is the host which initiates commands, such as to store or read data to or from the memory array <highlight><bold>1</bold></highlight>, and provides or receives such data, respectively. The controller converts such commands into command signals that can be interpreted and executed by the command circuits <highlight><bold>7</bold></highlight>. The controller also typically contains buffer memory for the user data being written to or read from the memory array. A typical memory system includes one integrated circuit chip <highlight><bold>21</bold></highlight> that includes the controller <highlight><bold>20</bold></highlight>, and one or more integrated circuit chips <highlight><bold>22</bold></highlight> that each contain a memory array and associated control, input/output and state machine circuits. The trend, of course, is to integrate the memory array and controller circuits of a system together on one or more integrated circuit chips. The memory system may be embedded as part of the host system, or may be included in a memory card that is removably insertable into a mating socket of host systems. Such a card may include the entire memory system, or the controller and memory array, with associated peripheral circuits, may be provided in separate cards. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> With reference to <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, an example structure of the memory cell array <highlight><bold>1</bold></highlight> is described. A flash EEPROM of a NAND type is described as an example. The memory cells (M) are partitioned into 1,024 blocks, in a specific example. The data stored in each block are simultaneously erased. The block is thus the minimum unit of a number of cells that are simultaneously erasable. In each block, in this example, there are 8,512 columns that are divided into even columns and odd columns. The bit lines are also divided into even bit lines (BLe) and odd bit lines (BLo). Four memory cells connected to the word lines (WL<highlight><bold>0</bold></highlight> to WL<highlight><bold>3</bold></highlight>) at each gate electrode are connected in series to form a NAND cell unit. One terminal of the NAND cell unit is connected to corresponding bit line (BL) via a first select transistor (S) which gate electrode is coupled to a first select gate line (SGD), and another terminal is connected to the c-source via a second select transistor (S) which gate electrode is coupled to a second select gate line (SGS). Although four floating gate transistors are shown to be included in each cell unit, for simplicity, a higher number of transistors, such as 8, 16 or even 32, are used. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> During a user data read and programming operation, 4,256 cells (M) are simultaneously selected, in this example. The cells (M) selected have the same word line (WL), for example WL<highlight><bold>2</bold></highlight>, and the same kind of bit line (BL), for example the even bit lines BLe<highlight><bold>0</bold></highlight> to BLe<highlight><bold>4255</bold></highlight>. Therefore, 532 bytes of data can be read or programmed simultaneously. This 532B data simultaneously read or programmed forms a &ldquo;page&rdquo; logically. Therefore, one block can store at least eight pages. When each memory cell (M) stores two bits of data, namely a multi-level cell, one block stores 16 pages in the case of two bit per cell storage. In this embodiment, the storage element of each of the memory cells, in this case the floating gate of each of the memory cells, stores two bits of user data. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> shows a cross sectional view of a NAND cell unit of the type shown schematically in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, in the direction of the bit line (BL). At a surface of a p-type semiconductor substrate <highlight><bold>9</bold></highlight>, a p-type region c-p-well <highlight><bold>11</bold></highlight> is formed, the c-p-well being enclosed by an n-type region <highlight><bold>10</bold></highlight> to electrically isolate the c-p-well from the p-type substrate. The n-type region <highlight><bold>10</bold></highlight> is connected to a c-p-well line made of a first metal M<highlight><bold>0</bold></highlight> via a first contact hole (CB) and an n-type diffusion layer <highlight><bold>12</bold></highlight>. The p-type region c-p-well <highlight><bold>11</bold></highlight> is also connected to the c-p-well line via the first contact hole (CB) and a p-type diffusion layer <highlight><bold>13</bold></highlight>. The c-p-well line is connected to the c-p-well control circuit <highlight><bold>5</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 1</cross-reference>). </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> Each memory cell has a floating gate (FG) that stores an amount of electric charge corresponding to the data being stored in the cell, the word line (WL) forming the gate electrode, and drain and source electrodes made of the p-type diffusion layer <highlight><bold>12</bold></highlight>. The floating gate (FG) is formed on the surface of the c-p-well via a tunnel oxide film (<highlight><bold>14</bold></highlight>). The word line (WL) is stacked on the floating gate (FG) via an insulator film (<highlight><bold>15</bold></highlight>). The source electrode is connected to the common source line (c-source) made of the first metal (M<highlight><bold>0</bold></highlight>) via the second select transistor (S) and the first contact hole (CB). The common source line is connected to the c-source control circuit (<highlight><bold>4</bold></highlight>). The drain electrode is connected to the bit line (BL) made of a second metal (M<highlight><bold>1</bold></highlight>) via the first select transistor (S), the first contact hole (CB), an intermediate wiring of the first metal (M<highlight><bold>0</bold></highlight>) and a second contact hole (V<highlight><bold>1</bold></highlight>). The bit line is connected to the column control circuit (<highlight><bold>2</bold></highlight>). </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 4 and 5</cross-reference> show cross sectional views of a memory cell (section <highlight><bold>4</bold></highlight>-<highlight><bold>4</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 3</cross-reference>) and a select transistor (section <highlight><bold>5</bold></highlight>-<highlight><bold>5</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 3</cross-reference>), respectively, in the direction of the word line (WL<highlight><bold>2</bold></highlight>). Each column is isolated from the neighbor columns by a trench formed in the substrate and filled with isolation material, known as a shallow trench isolation (STI). The floating gates (FG) are isolated from each other by the STI and insulator film <highlight><bold>15</bold></highlight> and word line (WL). These days, a space between the floating gates (FG) is going to less than 0.1 um, and a capacitive coupling between the floating gates has been increasing. Since the gate electrode (SG) of the select transistor (S) is formed in the same formation process steps as the floating gate (FG) and word line (WL), it shows a stacked gate structure. These two select gate lines (SG) are shunted at the end of lines. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> Table I of <cross-reference target="DRAWINGS">FIG. 6</cross-reference> summarizes voltages applied to operate the memory cell array <highlight><bold>1</bold></highlight>, in a specific example, each memory cell&apos;s floating gate storing two bits, having one of the states &ldquo;11&rdquo;, &ldquo;10&rdquo;, &ldquo;01&rdquo;, &ldquo;00&rdquo;. This table shows the case where the word line &ldquo;WL<highlight><bold>2</bold></highlight>&rdquo; and the bit lines of &ldquo;BLe&rdquo; are selected for reading and programming. By raising the c-p-well to an erase voltage of 20V and grounding the word lines (WL) of a selected block, the data of the selected block is erased. Since all of the word lines (WL) of the unselected blocks, bit lines (BL), select lines (SG) and c-source are put in a floating state, these are also raised to almost 20V due to a capacitive coupling with the c-p-well. Therefore, a strong electric field is applied to only the tunnel oxide films <highlight><bold>14</bold></highlight> (<cross-reference target="DRAWINGS">FIGS. 4 and 5</cross-reference>) of the selected memory cells (M), and the data of the selected memory cells are erased as a tunnel current flows across the tunnel oxide film <highlight><bold>14</bold></highlight>. The erased cell is, in this example, one of the four possible programmed states, namely &ldquo;11&rdquo;. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> In order to store electrons in the floating gate (FG) during a programming operation, the selected word line WL<highlight><bold>2</bold></highlight> is connected to a program pulse Vpgm and the selected bit lines BLe are grounded. On the other hand, in order to inhibit the program on the memory cells (M) in which programming is not to take place, the corresponding bit lines BLe are connected to Vdd of a power supply, for example 3V, as well as the unselected bit lines BLo. The unselected word lines WL<highlight><bold>0</bold></highlight>, WL<highlight><bold>1</bold></highlight> and WL<highlight><bold>3</bold></highlight> are connected to 10V, the first select gate (SGD) is connected to Vdd, and the second select gate (SGS) is grounded. As a result, a channel potential of the memory cell (M) that is being programmed is set at 0V. The channel potential in the program inhibition is raised to around 6V as a result of the channel potential being pulled up by the capacitive coupling with the word lines (WL). As explained above, a strong electric field is applied to only the tunnel oxide films <highlight><bold>14</bold></highlight> of the memory cells (M) during programming, and the tunnel current flows across the tunnel oxide film <highlight><bold>14</bold></highlight> in the reverse direction compared to the erase, and then the logical state is changed from &ldquo;11&rdquo; to one of the other states &ldquo;10&rdquo;, &ldquo;01&rdquo;, or &ldquo;00&rdquo;. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> In the read and verify operations, the select gates (SGD and SGS) and the unselected word lines (WL<highlight><bold>0</bold></highlight>, WL<highlight><bold>1</bold></highlight> and WL<highlight><bold>3</bold></highlight>) are raised to a read pass voltage of 4.5V to make these as pass gates. The selected word line (WL<highlight><bold>2</bold></highlight>) is connected to a voltage a level of which is specified for each read and verify operation in order to determine whether a threshold voltage of the concerned memory cell has reached such level. For example, in a READ 10 operation, the selected word line WL<highlight><bold>2</bold></highlight> is grounded, so that it is detected whether the threshold voltage is higher than 0V. In this read case, it can be said that a read level is 0V. In a VERIFY 01 operation, the selected word line WL<highlight><bold>2</bold></highlight> is connected to 2.4V, so that it is verified that whether the threshold voltage has reached 2.4V. In this verify case, it can be said that a verify level is 2.4V. </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> The selected bit lines (BLe) are precharged to a high level, for example 0.7V. If the threshold voltage is higher than the read or verify level, the potential level of the concerned bit line (BLe) maintains the high level, because of the non-conductive memory cell (M). On the other hand, If the threshold voltage is lower than the read or verify level, the potential level of the concerned bit line (BLe) decreases to a low level, for example less than 0.5V, because of the conductive memory cell (M). Further details of the read and verify operations are explained below. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> shows a part of the column control circuit <highlight><bold>2</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. Each pair of bit lines (BLe and BLo) is coupled to a data storage portion <highlight><bold>16</bold></highlight> which includes two data storage (DS<highlight><bold>1</bold></highlight> and DS<highlight><bold>2</bold></highlight>) registers, each being capable of storing one bit of data. The data storage portion <highlight><bold>16</bold></highlight> senses the potential level of the selected bit line (BL) during read or verify operation and then stores the data in a binary manner, and controls the bit line voltage in the program operation. The data storage portion <highlight><bold>16</bold></highlight> is selectively connected to the selected bit line (BL) by selecting one of signals of &ldquo;EVENBL&rdquo; and &ldquo;ODDBL&rdquo;. The data storage portion <highlight><bold>16</bold></highlight> is also coupled to the I/O line to output the read data and to store the program data. The I/O line is connected to the data input/output buffer <highlight><bold>6</bold></highlight>, as described above with respect to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. </paragraph>
<paragraph id="P-0059" lvl="7"><number>&lsqb;0059&rsqb;</number> General Operation of the Memory System </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> illustrates threshold voltage distributions for the memory cell array <highlight><bold>1</bold></highlight> when each floating gate storage element stores two bits of data, namely four data states, in each memory cell (M). The curve <highlight><bold>25</bold></highlight> represents a distribution of the threshold levels V<highlight><subscript>T </subscript></highlight>of the cells within the array <highlight><bold>1</bold></highlight> that are in the erased state (&ldquo;11&rdquo; data state), being negative threshold voltage levels. Threshold voltage distributions <highlight><bold>26</bold></highlight> and <highlight><bold>27</bold></highlight> of memory cells storing &ldquo;10&rdquo; and &ldquo;00&rdquo; user data, respectively, are shown to be between 0V and 1V and between 1V and 2V. A curve <highlight><bold>28</bold></highlight> shows the distribution of cells that have been programmed to the &ldquo;01&rdquo; data state, being the highest threshold voltage level set more than 2V and less than 4.5V of the read pass voltage. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> Each of the two bits stored in a single memory cell (M), in this example, is from a different logical page. That is, each bit of the two bits stored in each memory cell carries a different logical page address from each other. The right side bit shown in <cross-reference target="DRAWINGS">FIG. 8</cross-reference> is accessed when a lower page address (&equals;0, 2, 4, . . . , 16,382) is input. The left side bit is accessed when an upper page address (&equals;1, 3, 5, . . . , 16,383) is input. </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> In order to provide improved reliability, it is better for the individual distributions to be tightened (distribution narrowed), because the tighter distribution brings a wider read margin (distance between them). According to the present invention, the distribution width is made tighter without a conspicuous degradation in the programming speed. </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> According to the article &ldquo;Fast and Accurate Programming Method for Multi-level NAND EEPROMs, pp129-130, <highlight><italic>Digest of </italic></highlight>1995 <highlight><italic>Symposium on VLSI Technology</italic></highlight>,&rdquo; which article is incorporated herein by this reference, in principle, limiting a distribution to a 0.2V-width requires that the usual repetitive programming pulses be incremented 0.2V between steps. To tighten the distribution within a 0.05V-width, 0.05V-step-up pulses are required. In order to program cells with such small step increments in programming voltage results in increasing the programming time by a factor of 4. However, according to the principle aspects of the present invention, described below, such significant increases in programming time are unnecessary to reduce the width of a threshold voltage distribution. </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 9A and 9B</cross-reference> show an existing programming pulse technique and a resulting threshold distribution width of cells programmed to a particular state, respectively. A programming voltage Vpgm waveform is illustrated in <cross-reference target="DRAWINGS">FIG. 9A</cross-reference>. The programming voltage Vpgm is divided into many of pluses, and increased 0.2V pulse by pulse. It can be said a Vpgm step size is 0.2V. The starting level of Vpgm is 12V, in this particular example. The change of the threshold voltage of the fastest-program memory cell is represented by the white squares of <cross-reference target="DRAWINGS">FIG. 9</cross-reference>B, the slowest by the black squares. The fastest programmed memory cell is reached the verify level for 1stPass after 14V-pluse. The maximum width of the resulting distribution is &Dgr;V<highlight><subscript>T</subscript></highlight>&equals;0.2V. </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> In periods between the pluses, the program verify operations are carried out. That is, the programmed level of each cell being programmed in parallel is read between each programming pulse to determine whether it is equal to or greater than the verify level to which it is being programmed. If it is determined that the threshold voltage of a given memory cell has exceeded the verify level, Vpgm is removed by raising the voltage of the bit line to which the series cell unit of the given cell is connected from 0V to Vdd. Programming of others of the cells being programmed in parallel continues until they in turn reach their verify levels. When the threshold voltage moves from below the verify level to above it during the cell&apos;s last programming pulse, the shift of the threshold voltage is equal to the Vpgm step size of 0.2V. Therefore, the threshold voltages are controlled within a 0.2V-width. </paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 10A and 10B</cross-reference> illustrate a specific existing technique of programming a 4-state NAND memory cell in an array of the type described above. In a first programming pass, the cell&apos;s threshold level is set according to the bit from the lower logical page. If that bit is a &ldquo;1&rdquo;, nothing is done since it is in that state as a result of having been earlier erased. However, if that bit is a &ldquo;0&rdquo;, the level of the cell is increased to the first programmed state <highlight><bold>34</bold></highlight>. That concludes the first programming pass. </paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> In a second programming pass, the cell&apos;s threshold level is set according to the bit being stored in the cell from the upper logical page. If a &ldquo;1&rdquo;, no programming occurs since the cell is in one of the states <highlight><bold>33</bold></highlight> or <highlight><bold>34</bold></highlight>, depending upon the programming of the lower page bit, both of which carry an upper page bit of &ldquo;1&rdquo;. If the upper page bit is a &ldquo;0&rdquo;, however, the cell is programmed a second time. If the first pass resulted in the cell remaining in the erased state <highlight><bold>33</bold></highlight>, the cell is programmed from that state to the highest most state <highlight><bold>36</bold></highlight>, as shown by the upper arrow <cross-reference target="DRAWINGS">FIG. 10B</cross-reference>. If the cell has been programmed into the state <highlight><bold>34</bold></highlight>, however, as a result of the first programming pass, the cell is further programmed in the second pass from that state to the state <highlight><bold>35</bold></highlight>, as shown by the lower arrow of <cross-reference target="DRAWINGS">FIG. 10B</cross-reference>. The result of the second pass is to program the cell into the state designated to store a &ldquo;0&rdquo; from the upper page without changing the result of the first pass programming. </paragraph>
<paragraph id="P-0068" lvl="0"><number>&lsqb;0068&rsqb;</number> Of course, if the memory is operated with more than four states, there will be a number of distributions within the defined voltage threshold window of the memory cells that is equal to the number of states. Further, although specific bit patterns have been assigned to each of the distributions, different bit patterns may be so assigned, in which case the states between which programming occurs can be different than those shown in <cross-reference target="DRAWINGS">FIGS. 10A and 10B</cross-reference>. A few such variations are discussed in the Toshiba patents previously referenced in the Background. </paragraph>
<paragraph id="P-0069" lvl="0"><number>&lsqb;0069&rsqb;</number> Normally, the cells being programmed in parallel are alternate ones along a word line. <cross-reference target="DRAWINGS">FIG. 11</cross-reference> illustrates three memory cells <highlight><bold>41</bold></highlight>, <highlight><bold>42</bold></highlight> and <highlight><bold>43</bold></highlight> of a much larger number of cells along one word line <highlight><bold>44</bold></highlight>. One set of alternate cells, including the cells <highlight><bold>41</bold></highlight> and <highlight><bold>43</bold></highlight>, store bits from logical pages 0 and 2 (&ldquo;even pages&rdquo;), while the other set of alternate cells, including the cell <highlight><bold>42</bold></highlight>, store bits from logical pages 1 and 3 (&ldquo;odd pages&rdquo;). This results in the programming of at least 4 pages of data in a single row of memory cells, in one complete programming cycle that is repeated in sequence for 4 pages of data at a time. </paragraph>
<paragraph id="P-0070" lvl="0"><number>&lsqb;0070&rsqb;</number> In the first steps of programming the memory cells of at least a portion of a row as described above with respect to <cross-reference target="DRAWINGS">FIGS. 10A and 10B</cross-reference>, a bit from the lower 0 page is programmed first into the individual first set of alternate cells and then a bit from the lower page 1 into the individual second set of alternate cells. After these steps, the &ldquo;11&rdquo; (also the erased state) and &ldquo;10&rdquo; programmed state distributions of both Pages 0,2 and Pages 1,3 exist as shown in solid lines in <cross-reference target="DRAWINGS">FIG. 11</cross-reference>. The bits from the upper page 2 are then programmed into the first set of alternate cells, followed by a final step of programming bits of the upper page 3 into the second set of alternate cells. Because of the Yupin effect discussed above, the apparent distributions of the &ldquo;11&rdquo; and &ldquo;10&rdquo; states become broader than the threshold distributions indicated by the solid lines that exist immediately after their programming, as shown by the broadening dashed lines. This is because the initial programming of data of the lower pages 0 and 1 is done in an environment where no adjacent floating gates contain the higher charge levels that represent the &ldquo;00&rdquo; and &ldquo;01&rdquo; states. The broadening of the apparent initial distributions occurs when adjacent cells are programmed to these higher threshold level states. Further, the higher states &ldquo;00&rdquo; and &ldquo;01&rdquo; of Pages 0,2 also suffer this apparent broadening effect since adjacent floating gates are written with data from page 3 to increase their charge levels to the &ldquo;00&rdquo; and &ldquo;01&rdquo; states of the odd pages. </paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> The effect of this apparent broadening is to place a limit on the number of states in which the memory may be operated, and to create other operational limitations. It requires maintaining a sufficiently large margin between the state distributions so that the broader apparent distributions can be clearly distinguished during data read operations. Only the last two states programmed for Pages 1,3, as shown in <cross-reference target="DRAWINGS">FIG. 11</cross-reference> without the dashed threshold level spreading having occurred, are unaffected by the Yupin effect, since the charge levels of the adjacent floating gates are not changed thereafter. As illustrated in <cross-reference target="DRAWINGS">FIG. 10</cross-reference>B, the &ldquo;00&rdquo; and &ldquo;01&rdquo; states of the memory cells storing bits from Pages 1,3 of <cross-reference target="DRAWINGS">FIG. 11</cross-reference> are programmed last. For each of the other six states of the cells storing bits from Pages 0,2 and 1,3, however, there is subsequent programming of adjacent cells that affects the extent of their apparent threshold voltage distributions because of the field coupling between the floating gates. </paragraph>
<paragraph id="P-0072" lvl="7"><number>&lsqb;0072&rsqb;</number> Examples of New Programming Techniques </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 12</cross-reference> illustrates the effect of two improvements in the programming techniques described above with respect to FIGS. <highlight><bold>9</bold></highlight>-<highlight><bold>11</bold></highlight>. First, the order in which the pages are programmed is altered so that the first two pages of data bits that are programmed are written into the first alternate memory cells in a row, followed by writing the next two pages of data bits into the second alternate cells. This has the effect of eliminating two additional programmed states from the Yupin effect. Secondly, the initial state distributions are narrowed (compacted) so that the remaining apparent spreading by the Yupin effect still leaves the breadth of the effective distributions small, preferably no wider than the actual distributions first programmed. Each of these improvements may beneficially be implemented alone, or they may be used together. The example of <cross-reference target="DRAWINGS">FIG. 12</cross-reference> shows them being used together. </paragraph>
<paragraph id="P-0074" lvl="0"><number>&lsqb;0074&rsqb;</number> With the same data pages designated for the first and second groups of alternate memory cells being programmed as in <cross-reference target="DRAWINGS">FIG. 11</cross-reference>, the first improvement shown in <cross-reference target="DRAWINGS">FIG. 12</cross-reference> is the sequential writing of data from both pages 0 and 2 into the first group of cells, followed by writing data from both pages 1 and 3 into the second group of cells. That is, instead of alternately writing four pages of data into the first and second groups of alternate cells, as is done in the example of <cross-reference target="DRAWINGS">FIG. 11</cross-reference>, the first group is programmed with both pages of data before the second group is programmed with any data. The second group of alternate memory cells is then programmed with the third and fourth pages of data. The result is the elimination of the Yupin effect with respect to the state &ldquo;10&rdquo; of the memory cells storing Pages 1,3, as illustrated. This is because there is no increase in the charge level of floating gates of the immediately adjacent first group of alternate memory cells (storing Pages 0,2) after the second set of cells has been programmed with data Pages 1,3. All three of the programmed states of Pages 1,3 are then free of the Yupin effect, thus reducing the probability of an incorrect reading of the stored Pages 1,3 of data. </paragraph>
<paragraph id="P-0075" lvl="0"><number>&lsqb;0075&rsqb;</number> But because the second alternate set of memory cells is programmed with data Pages 1,3 after the first set of cells has been programmed with data Pages 0,2, the storage states of the first set are subject to the Yupin effect. In order to overcome this, the threshold voltage distributions of the first set of cells are compacted. A distribution <highlight><bold>51</bold></highlight> results from the initial programming of the data page 0, in accordance with <cross-reference target="DRAWINGS">FIG. 10A</cross-reference>. Before the data page 2 is programmed, however, that distribution is re-programmed to reduce the width of the distribution, as indicated by the curve <highlight><bold>52</bold></highlight>. After the programming of all four pages is complete, the Yupin effect causes the apparent spread of the &ldquo;10&rdquo; state threshold distribution to expand to that indicated by the curve <highlight><bold>53</bold></highlight>. The apparent distribution <highlight><bold>53</bold></highlight> is preferably controlled to be equal to or less than that of the initial distribution <highlight><bold>51</bold></highlight>. </paragraph>
<paragraph id="P-0076" lvl="0"><number>&lsqb;0076&rsqb;</number> The same process is performed when programming data page 2 into one of the programmed states &ldquo;00&rdquo; and &ldquo;01&rdquo;, which is carried out after data page 0 is programmed and compacted. The data are first written into the first group of alternate cells, compacted and then effectively spread by the Yupin effect from the later programming of the adjacent second group of alternate cells. </paragraph>
<paragraph id="P-0077" lvl="0"><number>&lsqb;0077&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 13</cross-reference> illustrates the steps performed to accomplish each of the two compactions of state distributions that are shown in <cross-reference target="DRAWINGS">FIG. 12</cross-reference> to occur. The state is first programmed with data against a first verify level <highlight><bold>61</bold></highlight>. That is, after each programming voltage pulse applied to the cells being programmed into that state, those cells are read by applying appropriate voltage conditions to them to determine whether the threshold voltage levels of the individual cells have reached or exceeded the level <highlight><bold>61</bold></highlight>. If so, programming stops. If not, an additional programming pulse is applied and the state read again. The result is a population of memory cells programmed into the given state that have a voltage threshold distribution indicated by the curve <highlight><bold>62</bold></highlight>. The width of the distribution <highlight><bold>62</bold></highlight> is controlled by the magnitude of the programming pulses applied, primarily a change of voltage between pulses, as previously described. </paragraph>
<paragraph id="P-0078" lvl="0"><number>&lsqb;0078&rsqb;</number> In order to narrow that distribution, after the programming of all the cells in parallel into that state has been completed, their states are read by using a threshold level <highlight><bold>63</bold></highlight> that is lower than the level <highlight><bold>61</bold></highlight>. This distinguishes cells programmed into other states by reading only those programmed into the one state of interest. Alternately, the data can be obtained from a register if available. A second programming operation (second pass) of those cells into that state then occurs by using a threshold voltage verify level <highlight><bold>64</bold></highlight> that is higher than the first verify level <highlight><bold>61</bold></highlight> and positioned within the distribution <highlight><bold>62</bold></highlight>. The effect of this second programming operation is to re-program those cells with a programmed threshold level that is less than the level <highlight><bold>64</bold></highlight> to a level that is greater than the verify level <highlight><bold>64</bold></highlight>, as indicated by a distribution <highlight><bold>65</bold></highlight>. The actual threshold level distribution <highlight><bold>65</bold></highlight> is, it can be noted from <cross-reference target="DRAWINGS">FIG. 13</cross-reference>, narrower that the original distribution <highlight><bold>62</bold></highlight>. After other adjacent cells are programmed by increasing their stored charge levels, the apparent distribution then widens due to the Yupin effect, as indicated by the distribution <highlight><bold>66</bold></highlight>. The width of this apparent distribution <highlight><bold>66</bold></highlight> is narrower that that which would occur if the second programming pass is not made, by an amount approximately equal to the difference between the verify levels <highlight><bold>61</bold></highlight> and <highlight><bold>64</bold></highlight>. </paragraph>
<paragraph id="P-0079" lvl="0"><number>&lsqb;0079&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 14A and 14B</cross-reference> illustrate a modification of the programming method illustrated in respective <cross-reference target="DRAWINGS">FIGS. 9A and 9B</cross-reference> that includes the second programming pass that was described with respect to <cross-reference target="DRAWINGS">FIG. 13</cross-reference>. The use of the second programming pass (2ndPassWrite) procedure is shown, as well as different verify levels for the first pass (<highlight><bold>61</bold></highlight>) and for the second pass (<highlight><bold>64</bold></highlight>). The change of the threshold voltage of the fastest-program memory cell is represented by the white squares of <cross-reference target="DRAWINGS">FIG. 14</cross-reference>B, the slowest by the black squares. The first programming pass (1stPassWrite) is similar to existing programming procedures, but a relatively low verify level <highlight><bold>61</bold></highlight> is used. The verify level <highlight><bold>64</bold></highlight> used for the second programming pass can be the same as the verify level now used. </paragraph>
<paragraph id="P-0080" lvl="0"><number>&lsqb;0080&rsqb;</number> When the threshold voltage moves from below the first pass verify level <highlight><bold>61</bold></highlight> as the result of one programming pulse, the shift of the threshold voltage is equal to the &Dgr;Vpgm step size of 0.2V, in this example. Therefore, the threshold voltages are controlled within a distribution <highlight><bold>62</bold></highlight> having a 0.2V-width, which is the same as that of the current techniques, but the distribution is positioned lower than that resulting from current techniques because of the lower verify level <highlight><bold>61</bold></highlight>. </paragraph>
<paragraph id="P-0081" lvl="0"><number>&lsqb;0081&rsqb;</number> After the 1stPassWrite is completed and before the 2ndPassWrite is begun, the memory cells that have threshold voltages higher than the verify level <highlight><bold>61</bold></highlight> for the 1stPassWrite and lower than the verify level <highlight><bold>64</bold></highlight> for the 2ndPassWrite are targets for the 2ndPassWrite. If the fastest-program memory cell reaches the verify level <highlight><bold>61</bold></highlight> for the 1stPassWrite after a 13.8V-pluse, for example, the starting Vpgm level of the 2ndPassWrite is set at 13.4V or less than 13.4V, thereby decreasing the threshold voltage shift below 0.2V. In a specific example, the starting programming voltage Vpgm level of the 2ndPassWrite is set at 13.4V, that of the 1stPassWrite at 12V. When the threshold voltage of a cell passes from below the verify level <highlight><bold>64</bold></highlight> to above it as the result of one programming pulse of the 2ndPassWrite, the shift of the threshold voltage is maintained less than 0.05V. Therefore, the distribution of threshold voltages of the target memory cells are controlled within a 0.05V-width, which is much tighter than that currently obtained. Therefore, if the verify level <highlight><bold>61</bold></highlight> for the 1stPassWrite is at least 0.15V lower than that the verify level <highlight><bold>64</bold></highlight> for the 2ndPassWrite, the total width of the threshold voltage distribution is 0.05V. </paragraph>
<paragraph id="P-0082" lvl="0"><number>&lsqb;0082&rsqb;</number> The maximum Vpgm level of the 2ndPassWrite is 0.2V higher than that of the 1stPassWrite in the worst case, in this specific example, because of the 0.15V-higher verify level used in the second pass. In addition, since the starting Vpgm in the 2ndPassWrite can be much higher than that in the 1stPassWrite, the time length of the 2ndPassWrite is always shorter than that of the 1stPassWrite. So, it can be seen that the cost in performance resulting from reducing the threshold voltage distribution width from 0.2V to 0.05V by this two programming pass technique is less than a doubling of the programming time. In an existing programming technique that obtains the same narrow programming distribution width by using a 0.05V &Dgr;Vpgm step size, on the other hand, the programming time is prolonged by a factor of 4 from the case where the width is 0.2V. The two programming pass technique obtains programming times that are over twice as fast as the existing technique in order to obtain the same threshold voltage distribution. </paragraph>
<paragraph id="P-0083" lvl="0"><number>&lsqb;0083&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 15A and 15B</cross-reference> correspond to respective <cross-reference target="DRAWINGS">FIGS. 14A and 14B</cross-reference> in showing a modification thereof, wherein the &Dgr;Vpgm step size of the first programming pass is made larger, in order to shorten the programming time, while that of the second programming pass remains the same to define a narrow distribution width. The &Dgr;Vpgm step size of the 1stPassWrite is raised from 0.2V to 0.4V, in this specific example. The verify level for the 1stPassWrite is decreased 0.2V, and the difference between the verify levels for 1stPassWrite and for 2ndPassWrite is expanded 0.2V to at least 0.35V. The expansion of 0.2V is equal to the difference between the &Dgr;Vpgm step sizes (0.4V-0.2V). The starting levels of the programming voltage Vpgm for the 1stPassWrite and the 2ndPassWrite are the same as in the 0.2V-step Vpgm case of <cross-reference target="DRAWINGS">FIG. 14A</cross-reference>. The duration of the 1stPassWrite is cut by about one-half, thereby reducing the program time by more than 25% from that in the 0.2V-step Vpgm case of <cross-reference target="DRAWINGS">FIGS. 14A and 14B</cross-reference>. </paragraph>
<paragraph id="P-0084" lvl="0"><number>&lsqb;0084&rsqb;</number> In each of <cross-reference target="DRAWINGS">FIGS. 14A and 15A</cross-reference>, the initial few programming pulses of 1stPassWrite may alternatively be generated without the necessity of time between them (not shown) for reading and verifying the level programmed in the target memory cells. This is because the target cells are seldom programmed to their desired threshold levels on the first few pulses. This may also be done with the first few pulses of the 2ndPassWrite. The result is a further decrease in the programming time. </paragraph>
<paragraph id="P-0085" lvl="0"><number>&lsqb;0085&rsqb;</number> The specific embodiments described above with respect to FIGS. <highlight><bold>12</bold></highlight>-<highlight><bold>15</bold></highlight> compact a programmed distribution in a reprogramming step immediately after the initial programming, before proceeding to program the adjacent cells and thus before the initially programmed states are distorted by the Yupin effect. In the specific embodiments described below with respect to FIGS. <highlight><bold>16</bold></highlight>-<highlight><bold>18</bold></highlight>, the distribution compacting reprogramming step occurs at a later stage, after all the states have been initially programmed and thus after there a distortion of the threshold level distributions exists because of the Yupin effect. </paragraph>
<paragraph id="P-0086" lvl="0"><number>&lsqb;0086&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 16, a</cross-reference> programming technique is illustrated wherein Pages 0,2 are first programmed into the first group of alternate storage elements along a row, followed by programming Pages 1,3 into the second group of alternate storage elements along the same row. Because one group is fully programmed with data from both of its pages before the other group of storage elements is programmed, there is no apparent broadening of the state distributions of the last to be programmed pages, in this case Pages 1,3, due to the Yupin effect. There is, however, such apparent broadening of the state distributions of the first programmed pages, namely Pages 0,2, because of the capacitive coupling between the adjacent alternating storage elements of the first and second groups along the selected word line. One way to correct for the apparent distribution shift of Pages 0,2 is to reprogram the first group of storage elements with the same data in a normal manner, with the same verify level being used. This results in shifting the state distributions of Pages 0,2 since their reprogramming is performed under the influence of the charge levels of adjacent storage elements. The new reprogrammed distributions then correct for the Yupin effect on the initially programmed data, Pages 0,2 in this case. </paragraph>
<paragraph id="P-0087" lvl="0"><number>&lsqb;0087&rsqb;</number> However, it is usually desirable to compact the state distributions being reprogrammed at the same time. There is no performance degradation by doing so since the main step in compaction is reprogramming with a different verify level. This has already been explained with reference to <cross-reference target="DRAWINGS">FIG. 13</cross-reference>, where the compacting reprogramming occurs before the adjacent storage elements are programmed that then affect the compacted state distributions. In the case of the programming sequence illustrated in <cross-reference target="DRAWINGS">FIG. 16</cross-reference>, however, the compacting reprogramming occurs after the adjacent storage elements have been programmed. </paragraph>
<paragraph id="P-0088" lvl="0"><number>&lsqb;0088&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 17</cross-reference> illustrates the compacting reprogramming of the state distributions for the data Pages 0,2, in the programming sequence of <cross-reference target="DRAWINGS">FIG. 17</cross-reference>. After the initial programming of Pages 0,2 with a verify level <highlight><bold>71</bold></highlight>, and before programming pages 1,3, the distribution of each state appears as indicated by a curve <highlight><bold>72</bold></highlight>. After the programming of Pages 1,3, however, this distribution appears to be broader, as indicated by the curve <highlight><bold>75</bold></highlight>. Upon reading cells in this state with a read level <highlight><bold>73</bold></highlight> and reprogramming them with a verify level <highlight><bold>74</bold></highlight>, an apparent distribution indicated by a curve <highlight><bold>76</bold></highlight> is the result, while the actual distribution is indicated in a dotted line <highlight><bold>77</bold></highlight>. The programming and reprogramming pulses applied are similar to those shown in <cross-reference target="DRAWINGS">FIG. 14A</cross-reference>. The desired compaction is shown to have occurred by the apparent distribution <highlight><bold>76</bold></highlight> being narrower than the apparent distribution <highlight><bold>75</bold></highlight>. </paragraph>
<paragraph id="P-0089" lvl="0"><number>&lsqb;0089&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 18 and 19</cross-reference> illustrate the same programming sequence and reprogramming steps as respective <cross-reference target="DRAWINGS">FIGS. 16 and 17</cross-reference>, except that the initial programming is performed with programming voltage pulses (1stPassWrite) that increase 0.4V per pulse while the reprogramming voltage pulses (2ndPassWrite) increase 0.2V per pulse, in the same manner as shown in <cross-reference target="DRAWINGS">FIG. 15A</cross-reference>. This higher &Dgr;Vpgm on the initial programming pass shortens the time necessary to complete the programming and reprogramming process. </paragraph>
<paragraph id="P-0090" lvl="0"><number>&lsqb;0090&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 20</cross-reference> illustrates another possible programming technique that uses the various aspects of the present invention. The method includes that described with respect to <cross-reference target="DRAWINGS">FIGS. 12 and 13</cross-reference>, followed by additional steps of reprogramming the initial data Pages 0,2 a second time. The second reprogramming occurs after the other data Pages 1,3 have been programmed, and need not necessarily include compaction of the state distributions but can. </paragraph>
<paragraph id="P-0091" lvl="0"><number>&lsqb;0091&rsqb;</number> Although exemplary embodiments of the first two aspects of the present invention set forth in the Summary have been described for a flash EEPROM system having a NAND memory cell array architecture, it will be recognized that these and other aspects of the present invention can be applied to any other flash memory architecture (such as a flash EEPROM system having a NOR memory cell architecture) or other type of nonvolatile memory where there is some coupling between storage elements that affects an apparent distribution of stored levels representing the same memory state, and it is desired to minimize that effect. </paragraph>
<paragraph id="P-0092" lvl="7"><number>&lsqb;0092&rsqb;</number> Exemplary Programming Algorithms </paragraph>
<paragraph id="P-0093" lvl="0"><number>&lsqb;0093&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 21</cross-reference> shows an example algorithm for programming the even columns of the lower page according to the technique described with respect to <cross-reference target="DRAWINGS">FIGS. 12, 13</cross-reference> and <highlight><bold>14</bold></highlight>. The algorithm can be divided into three parts. The first is a part surrounded by a broken line (S<highlight><bold>1</bold></highlight> to S<highlight><bold>4</bold></highlight>). This part shows procedures of the interface. At first (S<highlight><bold>1</bold></highlight>), &ldquo;data load&rdquo; command is issued by the flash controller and input to the data input/output buffer (<highlight><bold>6</bold></highlight>). The input data are recognized as the command and latched in the state machine (<highlight><bold>8</bold></highlight>), because a command latch signal not illustrated is input to the command interface (<highlight><bold>7</bold></highlight>) at this time. Next (S<highlight><bold>2</bold></highlight>), address data designating the page address is input to the data input/output buffer (<highlight><bold>6</bold></highlight>) from the controller, and then latched. The input data are recognized as the page address and latched in the state machine (<highlight><bold>8</bold></highlight>), because an address latch signal not illustrated is input to the command interface (<highlight><bold>7</bold></highlight>) at this time. Continuously (S<highlight><bold>3</bold></highlight>), 532B-program-data are input to the data input/output buffer (<highlight><bold>6</bold></highlight>). The input data are latched in the data storage 1 (DS<highlight><bold>1</bold></highlight>), because the &ldquo;data load&rdquo; command has been latched at this time. At the end (S<highlight><bold>4</bold></highlight>), &ldquo;program&rdquo; command is issued by the flash controller and input to the data input/output buffer (<highlight><bold>6</bold></highlight>). The input data are recognized as the command and latched in the state machine (<highlight><bold>8</bold></highlight>), because the command latch signal is input to the command interface (<highlight><bold>7</bold></highlight>) at this time. Triggered by the &ldquo;program&rdquo; command, the data latched in the data storage 1 (DS<highlight><bold>1</bold></highlight>) are automatically programmed (S<highlight><bold>5</bold></highlight> to S<highlight><bold>20</bold></highlight>) into the selected memory cells (M) controlled by the state machine (<highlight><bold>8</bold></highlight>). </paragraph>
<paragraph id="P-0094" lvl="0"><number>&lsqb;0094&rsqb;</number> The second part of the algorithm is the 1stPassWrite of the steps of S<highlight><bold>5</bold></highlight> to S<highlight><bold>10</bold></highlight>. At first, the starting Vpgm is set at 12V and a program counter embedded in the state machine (<highlight><bold>8</bold></highlight>) is initialized at 0 (S<highlight><bold>5</bold></highlight>). Next, the first program pulse is applied to the selected word line, for example WL<highlight><bold>2</bold></highlight> as shown in the table I (S<highlight><bold>6</bold></highlight>). If &ldquo;0&rdquo;-data is latched in the data storage 1 (DS<highlight><bold>1</bold></highlight>), corresponding bit line (BL) is grounded (&ldquo;program promotion&rdquo; in the table I). On the other hand, if &ldquo;1&rdquo;-data is latched in the data storage 1 (DS<highlight><bold>1</bold></highlight>), corresponding bit line (BL) is connected to Vdd (&ldquo;program inhibition&rdquo; in the table I). </paragraph>
<paragraph id="P-0095" lvl="0"><number>&lsqb;0095&rsqb;</number> After the program, the states of the selected memory cells are verified. In order to verify, the verify 10 for 1stPass is carried out (S<highlight><bold>7</bold></highlight>). In this operation, it is detected whether the threshold voltage has reached the verify level for 1stPass of 0.2V as shown in the table I. If it is detected that the threshold voltage has reached, the &ldquo;0&rdquo;-data latched in DS<highlight><bold>1</bold></highlight> is changed to &ldquo;1&rdquo;-data. If it is detected that the threshold voltage has not reached, the &ldquo;0&rdquo;-data latched in DS<highlight><bold>1</bold></highlight> is maintained. Already existing &ldquo;1&rdquo;-data is also maintained. In this manner, since &ldquo;0&rdquo;-data are changed to &ldquo;1&rdquo;-data one after another and &ldquo;1&rdquo;-data are maintained independent of the states of the memory cells, at last all of the data latched in the data storage DS<highlight><bold>1</bold></highlight> become &ldquo;1&rdquo;-data. It means that all of the memory cells have been programmed successfully judging from the verify level for 1stPass. </paragraph>
<paragraph id="P-0096" lvl="0"><number>&lsqb;0096&rsqb;</number> After the verify operation, it is checked whether all of the data latched in the data storage DS<highlight><bold>1</bold></highlight> have become &ldquo;1&rdquo;-data (S<highlight><bold>8</bold></highlight>). If they have become &ldquo;1&rdquo;-data, the 1stPassWrite is terminated and the 2ndPassWrite starts. If they haven&apos;t become &ldquo;1&rdquo;-data, the algorithm goes to a step S<highlight><bold>9</bold></highlight>. </paragraph>
<paragraph id="P-0097" lvl="0"><number>&lsqb;0097&rsqb;</number> In the step S<highlight><bold>9</bold></highlight>, a count value that the program counter has is checked. If the count value is smaller than 20, the Vpgm level is increased 0.2V and the count value progresses by 1 (S<highlight><bold>10</bold></highlight>), and then the algorithm returns to the step S<highlight><bold>6</bold></highlight> of the program. If the count value is not smaller than 20, a status data in the state machine is set at &ldquo;FAIL&rdquo;, and then the algorithm is terminated (S<highlight><bold>11</bold></highlight>). </paragraph>
<paragraph id="P-0098" lvl="0"><number>&lsqb;0098&rsqb;</number> The third part of the algorithm is the 2ndPassWrite (S<highlight><bold>12</bold></highlight> to S<highlight><bold>20</bold></highlight>). At first, the read 10 for 2ndPass is carried out (S<highlight><bold>12</bold></highlight>). In this operation, the memory cells, that have the threshold voltage higher than 0V, are extracted, and then &ldquo;0&rdquo;-data is set into the corresponding data storages 1 (DS<highlight><bold>1</bold></highlight>). &ldquo;1&rdquo;-data is set into each of remaining data storages 1 (DS<highlight><bold>1</bold></highlight>). </paragraph>
<paragraph id="P-0099" lvl="0"><number>&lsqb;0099&rsqb;</number> Next, the verify 10 for 2ndPass is carried out (S<highlight><bold>13</bold></highlight>). In this operation, the memory cells, that have the threshold voltage higher than 0V and lower than 0.4V, are extracted by using the verify level for 2stPass of 0.4V and the data already stored in the data storages 1 (DS<highlight><bold>1</bold></highlight>). It is detected whether the threshold voltage has reached the verify level for 2stPass of 0.4V as shown in the table I. If it is detected that the threshold voltage has reached, the &ldquo;0&rdquo;-data latched in DS<highlight><bold>1</bold></highlight> is changed to &ldquo;1&rdquo;-data. If it is detected that the threshold voltage has not reached, the &ldquo;0&rdquo;-data latched in the data storage 1 (DS<highlight><bold>1</bold></highlight>) is maintained. Already existing &ldquo;1&rdquo;-data is also maintained. </paragraph>
<paragraph id="P-0100" lvl="0"><number>&lsqb;0100&rsqb;</number> After the verify 10 for 2ndPass (S<highlight><bold>13</bold></highlight>), the starting Vpgm is reset at 13.4V and the program counter is re-initialized at 0 (S<highlight><bold>14</bold></highlight>). Next, the first program pulse of 13.4V is applied to the selected word line, as shown in the table I (S<highlight><bold>15</bold></highlight>). If &ldquo;0&rdquo;-data is latched in the data storage 1 (DS<highlight><bold>1</bold></highlight>), corresponding bit line (BL) is grounded (&ldquo;program promotion&rdquo; in the table I). On the other hand, if &ldquo;1&rdquo;-data is latched in the data storage 1 (DS<highlight><bold>1</bold></highlight>), corresponding bit line (BL) is connected to Vdd (&ldquo;program inhibition&rdquo; in the table I). </paragraph>
<paragraph id="P-0101" lvl="0"><number>&lsqb;0101&rsqb;</number> After the program (S<highlight><bold>15</bold></highlight>), the states of the selected memory cells are verified. In order to verify, the verify 10 for 2ndPass is carried out (S<highlight><bold>16</bold></highlight>). In this operation, it is detected whether the threshold voltage has reached the verify level for 2ndPass of 0.4V as shown in the table I. If it is detected that the threshold voltage has reached, the &ldquo;0&rdquo;-data latched in DS<highlight><bold>1</bold></highlight> is changed to &ldquo;1&rdquo;-data. If it is detected that the threshold voltage has not reached, the &ldquo;0&rdquo;-data latched in DS<highlight><bold>1</bold></highlight> is maintained. Already existing &ldquo;1&rdquo;-data is also maintained. In this manner, since &ldquo;0&rdquo;-data are changed to &ldquo;1&rdquo;-data one after another and &ldquo;1&rdquo;-data are maintained independent of the states of the memory cells, at last all of the data latched in the data storage DS<highlight><bold>1</bold></highlight> become &ldquo;1&rdquo;-data. It means that all of the memory cells have been programmed successfully. </paragraph>
<paragraph id="P-0102" lvl="0"><number>&lsqb;0102&rsqb;</number> After the verify operation (S<highlight><bold>16</bold></highlight>), it is checked whether all of the data latched in the data storage DS<highlight><bold>1</bold></highlight> have become &ldquo;1&rdquo;-data (S<highlight><bold>17</bold></highlight>). If they have become &ldquo;1&rdquo;-data, the 2ndPassWrite is terminated and then whole program algorithm is terminated setting the status data at &ldquo;PASS&rdquo; (S<highlight><bold>20</bold></highlight>). If they haven&apos;t become &ldquo;1&rdquo;-data, the algorithm goes to a step S<highlight><bold>18</bold></highlight>. </paragraph>
<paragraph id="P-0103" lvl="0"><number>&lsqb;0103&rsqb;</number> In the step S<highlight><bold>18</bold></highlight>, the count value that the program counter has is checked. If the count value is smaller than 13, the Vpgm level is increased 0.2V and the count value progresses by 1 (S<highlight><bold>19</bold></highlight>), and then the algorithm returns to the step S<highlight><bold>15</bold></highlight> of the program. If the count value is not smaller than 13, the status data is set at &ldquo;FAIL&rdquo;, and then the algorithm is terminated (S<highlight><bold>11</bold></highlight>). </paragraph>
<paragraph id="P-0104" lvl="0"><number>&lsqb;0104&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 22</cross-reference> shows an example program algorithm for programming the even columns of the upper page according to the method illustrated in <cross-reference target="DRAWINGS">FIGS. 12, 13</cross-reference> and <highlight><bold>14</bold></highlight>. The algorithm can be divided into three parts. The first is a part surrounded by a broken line (S<highlight><bold>1</bold></highlight> to S<highlight><bold>4</bold></highlight>). This part is the same as the part of the steps of S<highlight><bold>1</bold></highlight> to S<highlight><bold>4</bold></highlight> shown in <cross-reference target="DRAWINGS">FIG. 21</cross-reference>. </paragraph>
<paragraph id="P-0105" lvl="0"><number>&lsqb;0105&rsqb;</number> The second part of the algorithm is the 1stPassWrite of the steps of S<highlight><bold>5</bold></highlight> to S<highlight><bold>13</bold></highlight>. At first, the read 10 for 1stPass is carried out (S<highlight><bold>5</bold></highlight>). In this operation, the memory cells, that have the threshold voltage higher than 0V, are extracted, and then &ldquo;0&rdquo;-data is set into respective one of the corresponding data storages 2 (DS<highlight><bold>2</bold></highlight>). &ldquo;1&rdquo;-data is set into each of remaining data storages 2 (DS<highlight><bold>2</bold></highlight>). The starting Vpgm is set at 14V and the program counter is initialized at 0 (S<highlight><bold>6</bold></highlight>). Next, the first program pulse is applied to the selected word line, for example WL<highlight><bold>2</bold></highlight> as shown in the table I (S<highlight><bold>7</bold></highlight>). If &ldquo;0&rdquo;-data is latched in the data storage 1 (DS<highlight><bold>1</bold></highlight>), corresponding bit line (BL) is grounded (&ldquo;program promotion&rdquo; in the table I). On the other hand, if &ldquo;1&rdquo;-data is latched in the data storage 1 (DS<highlight><bold>1</bold></highlight>), corresponding bit line (BL) is connected to Vdd (&ldquo;program inhibition&rdquo; in the table I). </paragraph>
<paragraph id="P-0106" lvl="0"><number>&lsqb;0106&rsqb;</number> After the program, the states of the selected memory cells are verified. In order to verify, the verify 01 is carried out (S<highlight><bold>8</bold></highlight>) in the first place. In this operation, it is detected whether the threshold voltage has reached the verify level 2.4V as shown in the table I. If it is detected that the threshold voltage has reached, the &ldquo;0&rdquo;-data latched in DS<highlight><bold>1</bold></highlight> is changed to &ldquo;1&rdquo;-data. If it is detected that the threshold voltage has not reached, the &ldquo;0&rdquo;data latched in DS<highlight><bold>1</bold></highlight> is maintained. Already existing &ldquo;1&rdquo;-data is also maintained. In the second place, the verify 00 for 1stPass is carried out (S<highlight><bold>9</bold></highlight>). In this operation, it is detected whether the threshold voltage has reached the verify level 1.2V as shown in the table I. If it is detected that the threshold voltage has reached and if the stored data in the corresponding data storage 2 (DS<highlight><bold>2</bold></highlight>) is &ldquo;0&rdquo;-data, the &ldquo;0&rdquo;-data latched in DS<highlight><bold>1</bold></highlight> is changed to &ldquo;1&rdquo;-data. The &ldquo;0&rdquo;-data stored in the data storage 1 (DS<highlight><bold>1</bold></highlight>) is maintained in the case that the associated data storage 2 (DS<highlight><bold>2</bold></highlight>) has the &ldquo;1&rdquo;-data, independent of the detected result. If it is detected that the threshold voltage has not reached, the &ldquo;0&rdquo;-data latched in DS<highlight><bold>1</bold></highlight> is maintained. Already existing &ldquo;1&rdquo;-data is also maintained. </paragraph>
<paragraph id="P-0107" lvl="0"><number>&lsqb;0107&rsqb;</number> In this manner, since &ldquo;0&rdquo;-data are changed to &ldquo;1&rdquo;-data one after another and &ldquo;1&rdquo;-data are maintained independent of the states of the memory cells, at last all of the data latched in the data storage DS<highlight><bold>1</bold></highlight> become &ldquo;1&rdquo;-data. It means that all of the memory cells have been programmed successfully judging from the verify level of the &ldquo;0&rdquo;-state and the verify level for 1stPass of the &ldquo;00&rdquo;-state. </paragraph>
<paragraph id="P-0108" lvl="0"><number>&lsqb;0108&rsqb;</number> After the verify operation, it is checked whether all of the data latched in the data storage DS<highlight><bold>1</bold></highlight> have become &ldquo;1&rdquo;-data (S<highlight><bold>10</bold></highlight>). If they have become &ldquo;1&rdquo;-data, the 1stPassWrite is terminated and the 2ndPassWrite starts. If they haven&apos;t become &ldquo;1&rdquo;-data, the algorithm goes to a step S<highlight><bold>11</bold></highlight>. </paragraph>
<paragraph id="P-0109" lvl="0"><number>&lsqb;0109&rsqb;</number> In the step S<highlight><bold>11</bold></highlight>, the count value that the program counter has is checked. If the count value is smaller than 20, the Vpgm level is increased 0.2V and the count value progresses by 1 (S<highlight><bold>12</bold></highlight>), and then the algorithm returns to the step S<highlight><bold>7</bold></highlight> of the program. If the count value is not smaller than 20, the status data in the state machine is set at &ldquo;FAIL&rdquo;, and then the algorithm is terminated (S<highlight><bold>13</bold></highlight>). </paragraph>
<paragraph id="P-0110" lvl="0"><number>&lsqb;0110&rsqb;</number> The third part of the algorithm is the 2ndPassWrite (S<highlight><bold>14</bold></highlight> to S<highlight><bold>22</bold></highlight>). At first, the read 00 for 2ndPass is carried out (S<highlight><bold>14</bold></highlight>). In this operation, the memory cells, that have the threshold voltage higher than 1V, are extracted, and then &ldquo;0&rdquo;-data is set into respective one of the corresponding data storages 1 (DS<highlight><bold>1</bold></highlight>). &ldquo;1&rdquo;-data is set into each of remaining data storages 1 (DS<highlight><bold>1</bold></highlight>). </paragraph>
<paragraph id="P-0111" lvl="0"><number>&lsqb;0111&rsqb;</number> Next, the verify 00 for 2ndPass is carried out (S<highlight><bold>15</bold></highlight>). In this operation, the memory cells, that have the threshold voltage higher than 1V and lower than 1.4V, are extracted by using the verify level for 2stPass of 1.4V and the data already stored in the data storages 1 (DS<highlight><bold>1</bold></highlight>). It is detected whether the threshold voltage has reached the verify level for 2stPass of 1.4V as shown in the table I. If it is detected that the threshold voltage has reached, the &ldquo;0&rdquo;-data latched in DS<highlight><bold>1</bold></highlight> is changed to &ldquo;1&rdquo;-data. If it is detected that the threshold voltage has not reached, the &ldquo;0&rdquo;-data latched in the data storage 1 (DS<highlight><bold>1</bold></highlight>) is maintained. Already existing &ldquo;1&rdquo;-data is also maintained. </paragraph>
<paragraph id="P-0112" lvl="0"><number>&lsqb;0112&rsqb;</number> After the verify 00 for 2ndPass (S<highlight><bold>15</bold></highlight>), the starting Vpgm is reset at 14.4V and the program counter is re-initialized at 0 (S<highlight><bold>16</bold></highlight>). Next, the first program pulse of 14.4V is applied to the selected word line, as shown in the table I (S<highlight><bold>17</bold></highlight>). If &ldquo;0&rdquo;-data is latched in the data storage 1 (DS<highlight><bold>1</bold></highlight>), corresponding bit line (BL) is grounded (&ldquo;program promotion&rdquo; in the table I). On the other hand, if &ldquo;1&rdquo;-data is latched in the data storage 1 (DS<highlight><bold>1</bold></highlight>), corresponding bit line (BL) is connected to Vdd (&ldquo;program inhibition&rdquo; in the table I). </paragraph>
<paragraph id="P-0113" lvl="0"><number>&lsqb;0113&rsqb;</number> After the program (S<highlight><bold>17</bold></highlight>), the states of the selected memory cells are verified. In order to verify, the verify 00 for 2ndPass is carried out (S<highlight><bold>18</bold></highlight>). In this operation, it is detected whether the threshold voltage has reached the verify level for 2ndPass of 1.4V as shown in the table I. If it is detected that the threshold voltage has reached, the &ldquo;0&rdquo;-data latched in DS<highlight><bold>1</bold></highlight> is changed to &ldquo;1&rdquo;-data. If it is detected that the threshold voltage has not reached, the &ldquo;0&rdquo;-data latched in DS<highlight><bold>1</bold></highlight> is maintained. Already existing &ldquo;1&rdquo;-data is also maintained. In this manner, since &ldquo;0&rdquo;-data are changed to &ldquo;1&rdquo;-data one after another and &ldquo;1&rdquo;-data are maintained independent of the states of the memory cells, at last all of the data latched in the data storage DS<highlight><bold>1</bold></highlight> become &ldquo;1&rdquo;-data. It means that all of the memory cells have been programmed successfully. </paragraph>
<paragraph id="P-0114" lvl="0"><number>&lsqb;0114&rsqb;</number> After the verify operation (S<highlight><bold>18</bold></highlight>), it is checked whether all of the data latched in the data storage DS<highlight><bold>1</bold></highlight> have become &ldquo;1&rdquo;-data (S<highlight><bold>19</bold></highlight>). If they have become &ldquo;1&rdquo;-data, the 2ndPassWrite is terminated and then whole program algorithm is terminated setting the status data at &ldquo;PASS&rdquo; (S<highlight><bold>22</bold></highlight>). If they haven&apos;t become &ldquo;1&rdquo;-data, the algorithm goes to a step S<highlight><bold>20</bold></highlight>. </paragraph>
<paragraph id="P-0115" lvl="0"><number>&lsqb;0115&rsqb;</number> In the step S<highlight><bold>20</bold></highlight>, the count value that the program counter has is checked. If the count value is smaller than 13, the Vpgm level is increased 0.2V and the count value progresses by 1 (S<highlight><bold>21</bold></highlight>), and then the algorithm returns to the step S<highlight><bold>17</bold></highlight> of the program. If the count value is not smaller than 13, the status data is set at &ldquo;FAIL&rdquo;, and then the algorithm is terminated (S<highlight><bold>13</bold></highlight>). </paragraph>
<paragraph id="P-0116" lvl="0"><number>&lsqb;0116&rsqb;</number> In the algorithm of <cross-reference target="DRAWINGS">FIG. 22</cross-reference>, the 2ndPassWrite on the memory cells to be programmed to &ldquo;01&rdquo;-state is avoided, because the 2ndPassWrite for &ldquo;01&rdquo;-state requires the maximum Vpgm again and it results in an unnecessary program disturb. However, it can be easily done according to the present invention, if necessary. </paragraph>
<paragraph id="P-0117" lvl="0"><number>&lsqb;0117&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 23</cross-reference> shows an example program algorithm to carry out the method illustrated in <cross-reference target="DRAWINGS">FIGS. 12, 19</cross-reference> and <highlight><bold>15</bold></highlight> for programming the even columns with the lower page of data. This algorithm is similar to that shown in <cross-reference target="DRAWINGS">FIG. 21</cross-reference>. The differences are the Vpgm step size of the 1stPassWrite (S<highlight><bold>10</bold></highlight>) and the related maximum count value of the program counter in the 1stPassWrite (S<highlight><bold>9</bold></highlight>). The Vpgm step size is increased from 0.2V to 0.4V to accelerate the 1stPassWrite. </paragraph>
<paragraph id="P-0118" lvl="0"><number>&lsqb;0118&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 24</cross-reference> shows an example program algorithm to carry out the method illustrated in <cross-reference target="DRAWINGS">FIG. 12, 19</cross-reference> and <highlight><bold>15</bold></highlight> for programming the even columns with the upper page of data. This algorithm is similar to that shown in <cross-reference target="DRAWINGS">FIG. 22</cross-reference>. The differences are the Vpgm step size of the 1stPassWrite (S<highlight><bold>12</bold></highlight>) and the related maximum count value of the program counter in the 1stPassWrite (S<highlight><bold>11</bold></highlight>). The Vpgm step size is increased from 0.2V to 0.4V to accelerate the 1stPassWrite. </paragraph>
<paragraph id="P-0119" lvl="0"><number>&lsqb;0119&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 25 and 26</cross-reference> show example program algorithms for, when combined with the program algorithms of <cross-reference target="DRAWINGS">FIGS. 21 and 22</cross-reference>, respectively, carry out the method illustrated in <cross-reference target="DRAWINGS">FIGS. 12, 13</cross-reference> and <highlight><bold>14</bold></highlight>. The algorithm of <cross-reference target="DRAWINGS">FIG. 25</cross-reference> shows programming the odd columns without the 2ndPassWrite that is employed in the algorithm shown in <cross-reference target="DRAWINGS">FIG. 21</cross-reference> to program the even columns. The verify level of the verify 10 for 1stPass is changed from 0.2V to 0.4V in order to set the distribution more than 0.4V as set the distribution more than 0.4V through the 2ndPassWrite. <cross-reference target="DRAWINGS">FIG. 26</cross-reference> shows programming the odd columns without the 2ndPassWrite that is employed in the algorithm shown in <cross-reference target="DRAWINGS">FIG. 22</cross-reference> to program even columns. The verify level of the verify 00 for 1stPass is changed from 1.2V to 1.4V in order to set the distribution more than 1.4V as set the distribution more than 1.4V through the 2ndPassWrite. The combination of algorithms illustrated in <cross-reference target="DRAWINGS">FIGS. 21, 22</cross-reference>, <highlight><bold>25</bold></highlight>, and <highlight><bold>26</bold></highlight> compensate for the Yupin effect. As a result, the program throughput is improved. </paragraph>
<paragraph id="P-0120" lvl="0"><number>&lsqb;0120&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 27 and 28</cross-reference> show example algorithms for, when combined with the program algorithms shown in <cross-reference target="DRAWINGS">FIGS. 23 and 24</cross-reference>, carry out the method of <cross-reference target="DRAWINGS">FIGS. 12, 19</cross-reference> and <highlight><bold>15</bold></highlight>. <cross-reference target="DRAWINGS">FIG. 27</cross-reference> shows programming the odd columns without the 2ndPassWrite that is employed in the algorithm shown in <cross-reference target="DRAWINGS">FIG. 23</cross-reference> to program the even columns. The verify level of the verify 10 for 1stPass is changed from 0.2V to 0.4V in order to set the distribution more than 0.4V as set the distribution more than 0.4V through the 2ndPassWrite. <cross-reference target="DRAWINGS">FIG. 28</cross-reference> shows programming the odd columns without the 2ndPassWrite that is employed in the algorithm shown in <cross-reference target="DRAWINGS">FIG. 24</cross-reference> to program the even columns. The verify level of the verify 00 for 1stPass is changed from 1.2V to 1.4V in order to set the distribution more than 1.4V as set the distribution more than 1.4V through the 2ndPassWrite. </paragraph>
<paragraph id="P-0121" lvl="0"><number>&lsqb;0121&rsqb;</number> The combination of the algorithms illustrated in <cross-reference target="DRAWINGS">FIGS. 23, 24</cross-reference>, <highlight><bold>27</bold></highlight> and <highlight><bold>28</bold></highlight> compensate for the Yupin effect. As a result, the program throughout is greatly improved. </paragraph>
<paragraph id="P-0122" lvl="0"><number>&lsqb;0122&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 29</cross-reference> shows an example program sequence for implementing the method described with respect to <cross-reference target="DRAWINGS">FIGS. 12, 13</cross-reference> and <highlight><bold>14</bold></highlight>. In each block, the data programming is carried out in order of the page address from the lower page of the even bit lines of the word line WL<highlight><bold>0</bold></highlight> to the upper page of the odd bit lines of the word line WL<highlight><bold>3</bold></highlight>. This sequence is generated taking into account the Yupin effect. </paragraph>
<paragraph id="P-0123" lvl="0"><number>&lsqb;0123&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 30</cross-reference> shows an example read algorithm for reading the lower page of data that has been compacted according to the method of <cross-reference target="DRAWINGS">FIGS. 16 and 17</cross-reference>. A part surrounded by a broken line (S<highlight><bold>1</bold></highlight> and S<highlight><bold>2</bold></highlight>) shows procedures of the interface. At first (S<highlight><bold>1</bold></highlight>), &ldquo;data read&rdquo; command is issued by the flash controller and input to the data input/output buffer (<highlight><bold>6</bold></highlight>). The input data are recognized as the command and latched in the state machine (<highlight><bold>8</bold></highlight>), because the command latch signal not illustrated is input to the command interface (<highlight><bold>7</bold></highlight>) at this time. Next (S<highlight><bold>2</bold></highlight>), the address data designating the page address is input to the data input/output buffer (<highlight><bold>6</bold></highlight>) from the controller, and then latched. The input data are recognized as the page address and latched in the state machine (<highlight><bold>8</bold></highlight>), because the address latch signal not illustrated is input to the command interface (<highlight><bold>7</bold></highlight>) at this time. Triggered by the address data, the data stored in the selected memory cells (M) are automatically read out (S<highlight><bold>4</bold></highlight> and S<highlight><bold>5</bold></highlight>) controlled by the state machine (<highlight><bold>8</bold></highlight>). </paragraph>
<paragraph id="P-0124" lvl="0"><number>&lsqb;0124&rsqb;</number> In the read 01, the memory cells, that have the threshold voltage higher than 2V, are extracted, and then &ldquo;1&rdquo;-data is set into respective one of the corresponding data storages 2 (DS<highlight><bold>2</bold></highlight>). &ldquo;0&rdquo;-data is set into each of remaining data storages 2 (DS<highlight><bold>2</bold></highlight>). Next, the read 10 is carried out. In this operation, the memory cells, that have the threshold voltage lower than 0V or higher than 2V, are extracted. If it is detected that the threshold voltage is lower than 0V or the data storage 2 (DS<highlight><bold>2</bold></highlight>) is storing the &ldquo;1&rdquo;-data, the &ldquo;1&rdquo;-data is set into the data storage 1 (DS<highlight><bold>1</bold></highlight>), otherwise &ldquo;0&rdquo;. </paragraph>
<paragraph id="P-0125" lvl="0"><number>&lsqb;0125&rsqb;</number> The stored data in the data storage 1 (DS<highlight><bold>1</bold></highlight>) are output via the data input/output buffer (<highlight><bold>6</bold></highlight>) to the external in sync with a readout signal (not illustrated) input to the command interface (<highlight><bold>7</bold></highlight>). </paragraph>
<paragraph id="P-0126" lvl="0"><number>&lsqb;0126&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 31</cross-reference> shows an example read algorithm for reading the upper page of data that has been compacted according to the method of <cross-reference target="DRAWINGS">FIGS. 16 and 17</cross-reference>. A part surrounded by a broken line (S<highlight><bold>1</bold></highlight> and S<highlight><bold>2</bold></highlight>) is the same as that shown in <cross-reference target="DRAWINGS">FIG. 30</cross-reference>. In the read 00, the memory cells, that have the threshold voltage higher than 1V, are extracted, and then &ldquo;0&rdquo;-data is set into respective one of the corresponding data storages 1 (DS<highlight><bold>1</bold></highlight>). &ldquo;1&rdquo;-data is set into each of remaining data storages 1 (DS<highlight><bold>1</bold></highlight>). The stored data in the data storage 1 (DS<highlight><bold>1</bold></highlight>) are output via the data input/output buffer (<highlight><bold>6</bold></highlight>) to the external in sync with the readout signal. </paragraph>
<paragraph id="P-0127" lvl="0"><number>&lsqb;0127&rsqb;</number> Although the various aspects of the present invention have been described with respect to specific embodiments, it will be understood that the invention is protected within the full scope of the appended claims. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method of operating a non-volatile memory system wherein values stored in some of storage elements of an array of memory elements affect values read from others of the storage elements because of at least electric field coupling between storage elements, comprising: 
<claim-text>writing into a first group of storage elements a first set of stored values that correspond to a first set of data, </claim-text>
<claim-text>thereafter writing into a second group of storage elements different from the first group a second set of stored values that correspond to a second set of data, wherein at least some of the stored second set of values affect values read from at least some of the first group of storage elements because of at least field coupling between them, and </claim-text>
<claim-text>altering the first set of stored values written into the first group of storage elements in order to counteract an effect of the second set of stored values on the values read from said at least some of the first group of storage elements because of at least field coupling between them, thereby to facilitate accurate reading of the first set of data from the first group of storage elements. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the characteristic of the first set of stored values that is affected by the second set of stored values includes broadening an apparent distribution of those of the stored first set of values that correspond to particular states of the first set of data, and wherein altering the first set of stored values includes compacting the distribution of those of the stored first set of values that correspond to particular states of the first set of data. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, wherein compacting the distribution occurs after writing the second set of stored values. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference>, additionally comprising, prior to compacting the distribution of the stored first set of values, reading the first set of data from the first group of storage elements. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, wherein compacting the distribution occurs before writing the second set of stored values. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method of any one of claims <highlight><bold>1</bold></highlight>-<highlight><bold>5</bold></highlight>, wherein the storage elements are electrically floating gates, and wherein the stored values are charge levels stored on the floating gates that affect conduction through memory cell transistors of which the floating gates are a part. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference>, wherein more than two stored values are defined for individual ones of the floating gates in order to store more than one bit of data on the individual floating gates. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the non-volatile memory system in which the operating method is carried out includes an array of flash electrically erasable and programmable read only memory (EEPROM) cells having storage elements in the form of at least one floating gate per cell. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference>, wherein the non-volatile memory system in which the operating method is carried out includes memory cells having two floating gates per cell. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference>, wherein the non-volatile memory system in which the operating method is carried out includes memory cells connected in a NAND arrangement. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. A method of storing data in a non-volatile array of storage elements individually having a storage window divided into a plurality of defined ranges of storage levels representative of more than one bit of data and which are separated from one another, comprising: 
<claim-text>programming data into a first plurality of storage elements, </claim-text>
<claim-text>thereafter programming data into a second plurality of storage elements, </claim-text>
<claim-text>thereafter reading data programmed into the first plurality of storage elements, and </claim-text>
<claim-text>thereafter reprogramming the first plurality of storage elements with the read data, whereby the reprogramming is accomplished without having to retain a copy of the data initially programmed into the first plurality of storage elements. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. A method of storing data in a non-volatile array of storage elements individually having a storage window divided into a plurality of defined ranges of storage levels representative of more than one bit of data and which are separated from one another but where values read from storage elements are affected by values stored by adjacent storage elements because of field coupling between the storage elements, and wherein the individual storage elements are programmed by incrementally changing the storage levels thereof until one of the storage level ranges is reached that corresponds to the data being stored therein, comprising: 
<claim-text>programming data into a plurality of the storage elements by incrementally changing the storage levels of individual storage elements until one of a first set of reference storage levels corresponding to the data being stored is reached or exceeded, thereby to store the data with a distribution of storage levels among the plurality of storage elements within the defined ranges having widths resulting from incrementally changing the storage levels, and </claim-text>
<claim-text>thereafter reprogramming the storage levels in one portion of individual ones of said distributions into another non-overlapping portion thereof, thereby to reduce the extents of the storage level distributions within the individual defined ranges of storage levels and to increase the separation between the individual defined ranges of storage levels in order to allow for the effects of field coupling between adjacent storage elements. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, wherein reprogramming storage levels in one portion of the individual distributions into another portion thereof includes incrementally changing the storage levels of individual storage elements until one of a second set of reference storage levels corresponding to the data being stored is reached or exceeded, the second set of reference storage levels individually being displaced from corresponding ones of the first set of reference storage levels within corresponding distributions. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference>, wherein an amount of the incremental change of storage levels during programming is greater than that during reprogramming. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, wherein the non-volatile array of storage elements in which the method is carried out includes an array of memory cells having storage elements in the form of at least one floating gate per cell. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference>, wherein the non-volatile storage elements in which the operating method is carried out includes memory cells having two floating gates per cell. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference>, wherein the non-volatile storage elements in which the operating method is carried out includes memory cells connected in a NAND arrangement. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. A method of storing data in a non-volatile array of storage elements individually having a storage window divided into a plurality of defined ranges of storage levels representative of more than one bit of data and which are separated from one another, and wherein the individual storage elements are programmed by incrementally changing the storage levels thereof until one of the storage level ranges is reached that corresponds to the data being stored therein, comprising: 
<claim-text>programming data into a plurality of the storage elements by incrementally changing the storage levels of individual storage elements until one of a first set of reference storage levels corresponding to the data being stored is reached or exceeded, thereby to store the data with distributions of storage levels among the plurality of storage elements within defined ranges having widths resulting from incrementally changing the storage levels, and </claim-text>
<claim-text>thereafter reprogramming those of the storage elements having storage levels in one portion of individual ones of said distributions by incrementally changing the storage levels of those individual storage elements until programmed into another non-overlapping portion of their respective distributions, the amount of incremental change during programming being greater than the incremental change of storage levels during reprogramming. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. A method of storing data in a non-volatile array of storage elements individually having a storage window divided into a plurality of defined ranges of storage levels representative of more than one bit of data and which are separated from one another, and wherein the individual storage elements are programmed by incrementally changing the storage levels thereof until one of the storage level ranges is reached that corresponds to the data being stored therein, comprising: 
<claim-text>programming data into a first plurality of the storage elements by incrementally changing the storage levels of individual storage elements until one of a first set of reference storage levels corresponding to the data being stored is reached or exceeded, thereby to store the data with distributions of storage levels among the plurality of storage elements within defined ranges having widths resulting from incrementally changing the storage levels, </claim-text>
<claim-text>thereafter programming data into a second plurality of storage elements, </claim-text>
<claim-text>thereafter reading data programmed into the first plurality of storage elements, and </claim-text>
<claim-text>thereafter reprogramming those of the first plurality of storage elements having storage levels in one portion of individual ones of said distributions with the read data by incrementally changing the storage levels of those individual storage elements until programmed into another non-overlapping portion of their respective distributions, whereby the reprogramming is accomplished without having to retain a copy of the data initially programmed into the first plurality of storage elements. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. A method of programming at least first and second groups of individual storage elements of a non-volatile memory with two or more data bits in at least two programming steps, wherein coupling exists between adjacent ones of the first and second groups of storage elements that affects bit proportional levels read therefrom, comprising: 
<claim-text>programming the first group of storage elements with all of their said two or more data bits before programming the second group of storage elements, and </claim-text>
<claim-text>thereafter, programming the second group of storage elements with all of their said two or more data bits. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 20</dependent-claim-reference>, additionally comprising: 
<claim-text>reprogramming the first group of storage elements with all of their said two or more bits. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference>, wherein reprogramming the first group of storage elements includes compacting the bit proportional levels for the individual data bits stored of the first group of storage elements. </claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 22</dependent-claim-reference>, wherein reprogramming the first group of storage elements takes place before programming the second group of storage elements. </claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference>, wherein reprogramming the first group of storage elements takes place after programming the second group of storage elements. </claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. The method of any one of claims <highlight><bold>20</bold></highlight>-<highlight><bold>24</bold></highlight>, wherein the storage elements are electrically floating gates, and wherein the bit proportional levels are charge levels stored on the floating gates that affect conduction through memory cell transistors of which the floating gates are a part. </claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 20</dependent-claim-reference>, wherein the non-volatile memory in which the operating method is carried out includes an array of flash electrically erasable and programmable read only memory (EEPROM) cells having storage elements in the form of at least one floating gate per cell. </claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 26</dependent-claim-reference>, wherein the non-volatile memory system in which the operating method is carried out includes memory cells having exactly two floating gates per cell. </claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 26</dependent-claim-reference>, wherein the non-volatile memory system in which the operating method is carried out includes memory cells connected in a NAND arrangement. </claim-text>
</claim>
<claim id="CLM-00029">
<claim-text><highlight><bold>29</bold></highlight>. In a memory array including a memory cell, a method of programming the memory cell to a given state, the method comprising first, second and third program procedures, 
<claim-text>1) the first program procedure including the steps of: 
<claim-text>a) applying a first program voltage to the memory cell; </claim-text>
<claim-text>b) generating a first verify flag by determining whether the memory cell has reached a preliminary state; and </claim-text>
<claim-text>c) increasing the first program voltage with a first increasing rate if the first verify flag indicates that the memory cell has not reached to the preliminary state, otherwise removing the first program voltage from the memory cell, </claim-text>
</claim-text>
<claim-text>2) the second program procedure determining whether the memory cell has reached the given state, </claim-text>
<claim-text>3) the third program procedure, which is exerted on the memory cell if the memory cell has been determined not to have reached the given state, including the steps of: 
<claim-text>d) applying a second program voltage to the memory cell; </claim-text>
<claim-text>e) generating a second verify flag by determining whether the memory cell has reached the given state; and </claim-text>
<claim-text>f) increasing the second program voltage with a second increasing rate if the second verify flag indicates that the memory cell has not reached to the given state, otherwise removing the second program voltage from the memory cell. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00030">
<claim-text><highlight><bold>30</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 29</dependent-claim-reference>, wherein said first increasing rate is equal to the second increasing rate. </claim-text>
</claim>
<claim id="CLM-00031">
<claim-text><highlight><bold>31</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 29</dependent-claim-reference>, wherein said first increasing rate is higher than the second increasing rate. </claim-text>
</claim>
<claim id="CLM-00032">
<claim-text><highlight><bold>32</bold></highlight>. The method of any one of claims <highlight><bold>29</bold></highlight>-<highlight><bold>31</bold></highlight>, wherein a starting level of the first program voltage is lower than that of the second program voltage. </claim-text>
</claim>
<claim id="CLM-00033">
<claim-text><highlight><bold>33</bold></highlight>. In a memory array including a memory cell, a method of programming the memory cell to a given state, the method comprising first, second and third program procedures, 
<claim-text>1) the first program procedure including the steps of: 
<claim-text>a) applying a first program voltage to the memory cell; </claim-text>
<claim-text>b) generating a fist verify flag by determining whether the memory cell has reached a preliminary state; and </claim-text>
<claim-text>c) increasing the first program voltage with a first increasing rate if the first verify flag indicates that the memory cell has not reached to the preliminary state, otherwise removing the first program voltage from the memory cell, </claim-text>
</claim-text>
<claim-text>2) the second program procedure determining whether the memory cell has remained within a specified state not included in the given state, </claim-text>
<claim-text>3) the third program procedure, which is exerted on the memory cell if the memory cell has remained within the specified state, including the steps of: 
<claim-text>d) applying a second program voltage to the memory cell; </claim-text>
<claim-text>e) generating a second verify flag by determining whether the memory cell has reached the given state; and </claim-text>
<claim-text>f) increasing the second program voltage with a second increasing rate if the second verify flag indicates that the memory cell has not reached to the given state, otherwise removing the second program voltage from the memory cell. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00034">
<claim-text><highlight><bold>34</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00033">claim 33</dependent-claim-reference>, wherein said first increasing rate is equal to the second increasing rate. </claim-text>
</claim>
<claim id="CLM-00035">
<claim-text><highlight><bold>35</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00033">claim 33</dependent-claim-reference>, wherein said first increasing rate is higher than the second increasing rate. </claim-text>
</claim>
<claim id="CLM-00036">
<claim-text><highlight><bold>36</bold></highlight>. The method of any one of claims <highlight><bold>33</bold></highlight>-<highlight><bold>35</bold></highlight>, wherein a starting level of the first program voltage is lower than that of the second program voltage. </claim-text>
</claim>
<claim id="CLM-00037">
<claim-text><highlight><bold>37</bold></highlight>. In a memory array including a memory cell, a method of programming the memory cell to a given state, the method comprising first, second and third program procedures, 
<claim-text>1) the first program procedure including the steps of: 
<claim-text>a) applying a first program voltage to the memory cell; </claim-text>
<claim-text>b) generating a fist verify flag by determining whether the memory cell has reached a preliminary state; and </claim-text>
<claim-text>c) continuing to apply the first program voltage to the memory cell if the first verify flag indicates that the memory cell has not reached to the preliminary state, otherwise removing the first program voltage from the memory cell, </claim-text>
</claim-text>
<claim-text>2) the second program procedure determining whether the memory cell has reached the given state, </claim-text>
<claim-text>3) the third program procedure, which is exerted on the memory cell if the memory cell has been determined not to have reached the given state, including the steps of: 
<claim-text>d) applying a second program voltage to the memory cell; </claim-text>
<claim-text>e) generating a second verify flag by determining whether the memory cell has reached the given state; and </claim-text>
<claim-text>f) continuing to apply the second program voltage to the memory cell if the second verify flag indicates that the memory cell has not reached to the given state, otherwise removing the second program voltage from the memory cell. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00038">
<claim-text><highlight><bold>38</bold></highlight>. In a memory array including a memory cell, a method of programming the memory cell to a given state, the method comprising first, second and third program procedures, 
<claim-text>1) the first program procedure including the steps of: 
<claim-text>a) applying a first program voltage to the memory cell; </claim-text>
<claim-text>b) generating a fist verify flag by determining whether the memory cell has reached a preliminary state; and </claim-text>
<claim-text>c) continuing to apply the first program voltage to the memory cell if the first verify flag indicates that the memory cell has not reached to the preliminary state, otherwise removing the first program voltage from the memory cell, </claim-text>
</claim-text>
<claim-text>2) the second program procedure determining whether the memory cell has remained within a specified state not included in the given state, </claim-text>
<claim-text>3) the third program procedure, which is exerted on the memory cell if the memory cell has remained within the specified state, including the steps of: 
<claim-text>d) applying a second program voltage to the memory cell; </claim-text>
<claim-text>e) generating a second verify flag by determining whether the memory cell has reached the given state; and </claim-text>
<claim-text>f) continuing the second program voltage to the memory cell if the second verify flag indicates that the memory cell has not reached to the given state, otherwise removing the second program voltage from the memory cell. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00039">
<claim-text><highlight><bold>39</bold></highlight>. In a memory array including first and second memory cells, a method of programming the first and second memory cells to a given state, the second memory cell being programmed after programming the first memory cell, the method comprising first, second, third and fourth program procedures, 
<claim-text>1) the first program procedure including the steps of: 
<claim-text>a) applying a first program voltage to the first memory cell; </claim-text>
<claim-text>b) generating a fist verify flag by determining whether the first memory cell has reached a preliminary state; and </claim-text>
<claim-text>c) increasing the first program voltage with a first increasing rate if the first verify flag indicates that the first memory cell has not reached to the preliminary state, otherwise removing the first program voltage from the first memory cell, </claim-text>
</claim-text>
<claim-text>2) the second program procedure determining whether the first memory cell has reached the given state, </claim-text>
<claim-text>3) the third program procedure, which is exerted on the first memory cell if the first memory cell has been determined not to have reached the given state, including the steps of: 
<claim-text>d) applying a second program voltage to the first memory cell; </claim-text>
<claim-text>e) generating a second verify flag by determining whether the first memory cell has reached the given state; and </claim-text>
<claim-text>f) increasing the second program voltage with a second increasing rate if the second verify flag indicates that the first memory cell has not reached to the given state, otherwise removing the second program voltage from the first memory cell, </claim-text>
</claim-text>
<claim-text>4) the fourth program procedure, which is exerted on the second memory cell after the first, second and third program procedures, including the steps of: 
<claim-text>g) applying a third program voltage to the second memory cell; </claim-text>
<claim-text>h) generating a third verify flag by determining whether the second memory cell has reached the given state; and </claim-text>
<claim-text>i) increasing the third program voltage with a third increasing rate if the third verify flag indicates that the second memory cell has not reached to the given state, otherwise removing the third program voltage from the second memory cell. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00040">
<claim-text><highlight><bold>40</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00033">claim 39</dependent-claim-reference>, wherein a starting level of the second program voltage is higher than that of the third program voltage. </claim-text>
</claim>
<claim id="CLM-00041">
<claim-text><highlight><bold>41</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00033">claim 39</dependent-claim-reference>, wherein said first, second and third increasing rates are the same. </claim-text>
</claim>
<claim id="CLM-00042">
<claim-text><highlight><bold>42</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00033">claim 39</dependent-claim-reference>, wherein said second increasing rate is higher than the first increasing rate, and the first increasing rate is equal to the third increasing rate. </claim-text>
</claim>
<claim id="CLM-00043">
<claim-text><highlight><bold>43</bold></highlight>. The method of any one of claims <highlight><bold>39</bold></highlight>-<highlight><bold>42</bold></highlight>, wherein a starting level of the first program voltage is lower than that of the second program voltage, and is equal to that of the third program voltage. </claim-text>
</claim>
<claim id="CLM-00044">
<claim-text><highlight><bold>44</bold></highlight>. In a memory array including first and second memory cells, a method of programming the first and second memory cells to a given state, the second memory cell being programmed after programming the first memory cell, the method comprising first, second, third and fourth program procedures, 
<claim-text>1) the first program procedure including the steps of: 
<claim-text>a) applying a first program voltage to the first memory cell; </claim-text>
<claim-text>b) generating a fist verify flag by determining whether the first memory cell has reached a preliminary state; and </claim-text>
<claim-text>c) continuing to apply the first program voltage to the first memory cell if the first verify flag indicates that the first memory cell has not reached to the preliminary state, otherwise removing the first program voltage from the first memory cell, </claim-text>
</claim-text>
<claim-text>2) the second program procedure determining whether the first memory cell has reached the given state, </claim-text>
<claim-text>3) the third program procedure, which is exerted on the first memory cell if the first memory cell has been determined not to have reached the given state, including the steps of: 
<claim-text>d) applying a second program voltage to the first memory cell; </claim-text>
<claim-text>e) generating a second verify flag by determining whether the first memory cell has reached the given state; and </claim-text>
<claim-text>f) continuing to apply the second program voltage to the first memory cell if the second verify flag indicates that the first memory cell has not reached to the given state, otherwise removing the second program voltage from the first memory cell, </claim-text>
</claim-text>
<claim-text>4) the fourth program procedure, which is exerted on the second memory cell after the first, second and third program procedures, including the steps of: 
<claim-text>g) applying a third program voltage to the second memory cell; </claim-text>
<claim-text>h) generating a third verify flag by determining whether the second memory cell has reached the given state; and </claim-text>
<claim-text>i) continuing to apply the third program voltage to the second memory cell if the third verify flag indicates that the second memory cell has not reached to the given state, otherwise removing the third program voltage from the second memory cell.</claim-text>
</claim-text>
</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>1</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030002348A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030002348A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030002348A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030002348A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030002348A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030002348A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030002348A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030002348A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030002348A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00009">
<image id="EMI-D00009" file="US20030002348A1-20030102-D00009.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00010">
<image id="EMI-D00010" file="US20030002348A1-20030102-D00010.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00011">
<image id="EMI-D00011" file="US20030002348A1-20030102-D00011.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00012">
<image id="EMI-D00012" file="US20030002348A1-20030102-D00012.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00013">
<image id="EMI-D00013" file="US20030002348A1-20030102-D00013.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00014">
<image id="EMI-D00014" file="US20030002348A1-20030102-D00014.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00015">
<image id="EMI-D00015" file="US20030002348A1-20030102-D00015.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00016">
<image id="EMI-D00016" file="US20030002348A1-20030102-D00016.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00017">
<image id="EMI-D00017" file="US20030002348A1-20030102-D00017.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00018">
<image id="EMI-D00018" file="US20030002348A1-20030102-D00018.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00019">
<image id="EMI-D00019" file="US20030002348A1-20030102-D00019.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00020">
<image id="EMI-D00020" file="US20030002348A1-20030102-D00020.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
