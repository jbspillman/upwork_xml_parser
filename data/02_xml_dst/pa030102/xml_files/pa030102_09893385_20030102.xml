<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005415A1-20030102-D00000.TIF SYSTEM "US20030005415A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005415A1-20030102-D00001.TIF SYSTEM "US20030005415A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005415A1-20030102-D00002.TIF SYSTEM "US20030005415A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005415A1-20030102-D00003.TIF SYSTEM "US20030005415A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005415A1-20030102-D00004.TIF SYSTEM "US20030005415A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005415A1-20030102-D00005.TIF SYSTEM "US20030005415A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030005415A1-20030102-D00006.TIF SYSTEM "US20030005415A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030005415A1-20030102-D00007.TIF SYSTEM "US20030005415A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030005415A1-20030102-D00008.TIF SYSTEM "US20030005415A1-20030102-D00008.TIF" NDATA TIF>
<!ENTITY US20030005415A1-20030102-D00009.TIF SYSTEM "US20030005415A1-20030102-D00009.TIF" NDATA TIF>
<!ENTITY US20030005415A1-20030102-D00010.TIF SYSTEM "US20030005415A1-20030102-D00010.TIF" NDATA TIF>
<!ENTITY US20030005415A1-20030102-D00011.TIF SYSTEM "US20030005415A1-20030102-D00011.TIF" NDATA TIF>
<!ENTITY US20030005415A1-20030102-D00012.TIF SYSTEM "US20030005415A1-20030102-D00012.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005415</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09893385</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010627</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F009/44</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>717</class>
<subclass>129000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Low impact breakpoint for multi-user debugging</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Cary</given-name>
<middle-name>Lee</middle-name>
<family-name>Bates</family-name>
</name>
<residence>
<residence-us>
<city>Rochester</city>
<state>MN</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>William</given-name>
<middle-name>Jon</middle-name>
<family-name>Schmidt</family-name>
</name>
<residence>
<residence-us>
<city>Rochester</city>
<state>MN</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<assignee>
<organization-name>International Business Machines Corporation</organization-name>
<address>
<city>Armonk</city>
<state>NY</state>
<postalcode>10504</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
<assignee-type>02</assignee-type>
</assignee>
<correspondence-address>
<name-1>Gero G. McClellan</name-1>
<name-2>Thomason, Moser &amp; Patterson, L.L.P.</name-2>
<address>
<address-1>3040 Post Oak Boulevard, Suite 1500</address-1>
<city>Houston</city>
<state>TX</state>
<postalcode>77056-6582</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">Method and system for a software debugger tool. Breakpoints are submitted, as breakpoint data, by a user. A breakpoint manager stores the breakpoint data and inserts the breakpoints into the software program code. The breakpoint manager gains control of the program when a breakpoint is processed associated with a particular job. After the breakpoint manager completes an interrupt routine to process the breakpoint, using instructions stored in the breakpoint data, the method removes breakpoints associated with the particular job. When control is to be returned to the program, only those breakpoints that are found to be useful are set. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> 1. Field of the Invention </paragraph>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> This invention relates to software programming development and more particularly to a software debugging system for managing breakpoints. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> 2. Description of the Related Art </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> A programmer develops a software program by producing and entering source code into files using a text editor program. The computer then creates an executable program by translating the source code listing into machine code. The machine code is the rudimentary language understood by a computer. Illustratively, the foregoing software development process is accomplished by running a series of programs. These programs typically include a compiler for translating the source code into machine code and a linker to link the machine code together to form a program. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> When developing computer software, it is necessary to perform a function termed &ldquo;debugging&rdquo;. Debugging involves testing and evaluating the software to find and correct any errors and improper logic operation. An effective debugger program is necessary for rapid and efficient development of software. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> A conventional debugging system comprises a combination of computer hardware and debugger software that executes a user&apos;s program in a controlled manner. Debugging aids a user in identifying and correcting mistakes in an authored program by allowing the program to be executed in small segments. This approach is enabled primarily by two operations: step functions and breakpoints. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> A &ldquo;step&rdquo; function permits a computer programmer to process instructions (also known as &ldquo;statements&rdquo;) in a computer program one-by-one, and see the results upon completion of each instruction. While the step operation provides a programmer with a large amount of information about a program during its execution, stepping through hundreds or thousands of program instructions can be extremely tedious and time consuming, and may require a programmer to step through many program instructions that are known to be error-free before a set of instructions to be analyzed are executed. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> To address this difficulty, conventional debuggers utilize a breakpoint operation, which permits a computer programmer to identify, with a &ldquo;breakpoint&rdquo;, a precise instruction for which it is desired to halt execution of a computer program during execution. As a result, when a computer program is executed by a debugger, the program executes in a normal fashion until a breakpoint is reached, and then stops execution and displays the results of the computer program to the programmer for analysis. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> Some conventional debuggers support unconditional breakpoints where the execution of the program is always halted upon reaching the breakpoint. While other debuggers support conditional breakpoints that halt the execution of a program only when a predetermined value is obtained when the breakpoint is encountered. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> Typically, step operations and breakpoints are used together to simplify the debugging process. Specifically, a common debugging operation is to set a breakpoint at the beginning of a desired set of instructions to be analyzed, and then begin executing the program. Once the breakpoint is reached, the program is halted, and the programmer then steps through the desired set of instructions line by line using the step operation. Consequently, a programmer is able to quickly isolate and analyze a particular set of instructions without having to step through irrelevant portions of a computer program. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> One significant drawback to conventional breakpoint debugging methods is that some instructions in a computer program are executed often which may result in needless halting of the program. This problem is more pronounced in highly modular languages, such as object-oriented programming (OOP) languages, where a single general-purpose portion of a computer program might be executed in many different situations. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> With an OOP language, a program is constructed from a number of &ldquo;objects,&rdquo; each of which includes data and/or one or more sets of instructions (often referred to as &ldquo;routines&rdquo; or &ldquo;methods&rdquo;) that define specific operations that can be performed on the data. A large number of objects may be used to build a computer program, with each object interacting with other objects in the computer program to perform desired operations. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> Some general purpose objects in a computer program may support basic operations, e.g., displaying information to a user, printing information on a printer, storing or retrieving information from a database, etc. These types of objects, in particular, may have routines that are called by many different objects. Thus, placing a conventional breakpoint in a routine of such an object may result in hundreds of unwanted stoppages prior to occurrence of a desired stoppage. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> Multi-user computer systems, such as mainframe computers, minicomputers, and networked computers, allow a plurality of processes, submitted by various users, to execute. These processes utilize some of the same processing hardware, program code or software objects, and data. This utilization of the same objects is especially true for a single level store system, such as an IBM eServer iSeries 400 computer. To achieve efficiencies, a single level store system will load a single copy of program code or instructions into memory, allowing multiple processes to utilize these instructions. By contrast, some other systems generally allow each process to access program code, allocating independent resources for loading this code into memory. Consequently, inserting a breakpoint into the instructions on a single level store system can mean that more than one process hits the breakpoint, burdening the processor. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> The problem of unnecessary program stoppage is further compounded in multi-user systems because more than one user may be executing the same program at the same time. Other users on the system encounter delays because the system must process additional steps required when needlessly encountering a breakpoint. In order to accommodate the multi-user environment, it is generally known to implement a breakpoint as an interrupt in the computer program. Execution of the computer code thus has a software jump or a hardware interrupt to a breakpoint handling code which differentiates between users. The breakpoint handling code determines whether execution should be halted by seeing if the process setting the breakpoint also hits the breakpoint and whether any conditions are satisfied. Execution continues at the point of the breakpoint for processes not associated with the breakpoint by masking the breakpoint. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> Regardless of the reason, when processes needlessly encounter breakpoints, overall system degradation can occur. Furthermore, when a computer system is executing slowly, due to system degradation, it is often difficult to debug timing-related faults. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> Therefore, there is a need for a debugging system and method for processing breakpoints that does not unduly degrade the performance of a computer system. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> The present invention generally provides an apparatus, program product, and a method for debugging computer programs that addresses the problems associated with the management of breakpoints, particularly in multi-user environments. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> In one embodiment a method of debugging a program in a computer system comprises automatically removing at least a portion of all breakpoints associated with a particular job from the program when a debugger gets control of the program for the particular job. In another embodiment a computer readable medium contains a program which when executed performs the foregoing method. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> In another embodiment, a method of debugging a program in a computer system comprises, upon a debugger getting control of the program for a particular job, determining whether at least one useful breakpoint exists in the program for the particular job and if so, removing from the program all breakpoints associated with the particular job except the at least one useful breakpoint. Prior to returning control to the program from the debugger, it is determined whether at least one of the removed breakpoints is useful; and if so, the at least one of the removed breakpoints is reestablished. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> In still another embodiment a method of debugging a program in a multi-user computer system comprises, during a time when execution of the program is halted, removing all breakpoints associated with a particular job from the program; executing a task to identify each useful breakpoint located in the program, wherein a useful breakpoint is one which may be encountered upon resuming execution of the program; and if the task is completed before execution of the program is resumed, inserting each useful breakpoint into its original location in the program. In another embodiment a computer readable medium contains a program which when executed performs the foregoing method.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> So that the manner in which the above recited features, advantages and objects of the present invention are attained and can be understood in detail, a more particular description of the invention, briefly summarized above, may be had by reference to the embodiments thereof which are illustrated in the appended drawings. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> It is to be noted, however, that the appended drawings illustrate only typical embodiments of this invention and are therefore not to be considered limiting of its scope, for the invention may admit to other equally effective embodiments. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a block diagram of a computer system consistent with the invention. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a block diagram of an exemplary software environment for the computer system of <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a diagram illustrating the establishment and handling of a breakpoint. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a depiction of the Control Flow Graph (CFG) and other related information stored with a program. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a detailed depiction of a node within a call flow graph. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is a data structure representing a breakpoint operation count. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> is a block diagram that illustrates an example of a call graph. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> is a flow diagram illustrating the operation of a breakpoint manager. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference> is a flow diagram of the establish breakpoint message routine referenced in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10</cross-reference> is a flow diagram of the compute breakpoint memory address routine referenced in <cross-reference target="DRAWINGS">FIG. 9</cross-reference>. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 11</cross-reference> is a data structure depiction of breakpoint information referenced in <cross-reference target="DRAWINGS">FIG. 10</cross-reference>. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 12</cross-reference> is a data structure depiction of program information referenced in <cross-reference target="DRAWINGS">FIG. 10</cross-reference>. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 13</cross-reference> is a flow diagram of the breakpoint analysis routine referenced in <cross-reference target="DRAWINGS">FIG. 8</cross-reference>. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 14</cross-reference> is a flow diagram of the process initial statements routine referenced in <cross-reference target="DRAWINGS">FIG. 13</cross-reference>. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 15</cross-reference> is a flow diagram of the Multigraph Test routine referenced in <cross-reference target="DRAWINGS">FIG. 14</cross-reference>, and <cross-reference target="DRAWINGS">FIG. 16</cross-reference>. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 16</cross-reference> is a flow diagram of the Traverse CFG routine referenced in <cross-reference target="DRAWINGS">FIG. 14</cross-reference>. </paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT </heading>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> The present invention provides a system and method for breakpoint management in a software debugger program. More particularly, embodiments are provided that remove breakpoints that are currently not useful to a user and restore some or all of the removed breakpoints when they again become useful, thereby alleviating system degradation from excessive breakpoint interruptions. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> In one embodiment, a breakpoint is &ldquo;useful&rdquo; if the program being debugged is in a state where it may encounter the breakpoint. If a breakpoint cannot be encountered due to the current state of the program then the breakpoint is not useful. In general, a &ldquo;state&rdquo; is defined by whether the program or the debugger has control. The debugger gains control of the program when a breakpoint is hit or another debugger operation such as a &ldquo;step&rdquo; operation completes and causes program execution to be halted. The program has control during execution of the program. For the purposes of this application, the aspects of a program&apos;s state which are relevant are the state of the program&apos;s execution and, if not currently being executed, the position at which the program is halted referred to as the stopped position). In addition, execution of the program includes execution of any thread or number of threads. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> In one embodiment, all breakpoints are removed from a program when a debugger has control. Immediately before the debugger relinquishes control and allows the execution to resume, all useful breakpoints are reestablished. In this case, &ldquo;all useful breakpoints&rdquo; may include all breakpoints or some portion of all breakpoints. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> In another embodiment, a breakpoint analysis task identifies useful breakpoints while a debugger has control relative to a future state when the program again has control. In this case, a breakpoint is not useful if it cannot be encountered during subsequent execution from the current stopped position. This can occur if the breakpoint in question is set in a part of the program being debugged that will not be executed again, or if the execution path to the breakpoint is blocked by another breakpoint. In this regard, the determination of whether a break point may be encountered can be performed for a particular thread or threads. For example, if a user resumes execution of a first thread but holds the execution of a second thread, then all breakpoints which may be encountered by the first thread are considered useful while all breakpoints specific to the second thread are considered not useful. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> In another embodiment, each breakpoint is cross-referenced to a specific process or job. When a debugger gains control of the process, and program execution is halted, the debugger removes all breakpoints cross-referenced to the current process or job. While the program is under the debugger&apos;s control, a set of useful breakpoints based on the current stopped position is determined. These useful breakpoints are reestablished when the debugger gives up control of the program. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> In one embodiment, a Control Flow Graph (or CFG) is used to advantage to determine useful breakpoints. A CFG is a data structure known in the art representing the structure of the program being debugged. The CFG is traversed and all breakpoints that may possibly be encountered from the current stopped position without going past an existing breakpoint are noted. These breakpoints are the current useful breakpoints, and will be reestablished just before the debugger relinquishes control and allows program execution to continue. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> Although not required, one embodiment is described in the general context of computer-executable instructions, such as program modules, being executed by a computer, such as a personal computer, for example. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. In general, the routines executed to implement the embodiments of the invention, whether implemented as part of an operating system or a specific application, component, program, object, module or sequence of instructions will be referred to herein as &ldquo;computer programs,&rdquo; or simply &ldquo;programs.&rdquo; The computer programs typically comprise one or more instructions that are resident at various times in various memory and storage devices in a computer, and that, when read and executed by one or more processors in a computer, cause that computer to perform the steps necessary to execute steps or elements embodying the various aspects of the invention. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> The program modules that define the functions of the present embodiments may be placed on a signal-bearing medium. The signal bearing media, include, but are not limited to, (i) information permanently stored on non-writable storage media, (e.g., read-only memory devices within a computer such as CD-ROM disks readable by a CD-ROM drive); (ii) alterable information stored on writable storage media (e.g., floppy disks within a diskette drive or hard-disk drive); or (iii) information conveyed to a computer by a communications medium, such as through a computer or telephone network, including wireless communications. The latter embodiment specifically includes information downloaded from the Internet and other networks. Such signal-bearing media, when carrying computer-readable instructions that direct the functions of the present invention, represent embodiments of the present invention. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> Moreover, those skilled in the art will appreciate that embodiments may be practiced with other computer system configurations including hand-held devices, multiprocessor systems, microprocessor-based or programmable consumer electronics, minicomputers, mainframe computers and the like. The embodiment may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote memory storage devices. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> shows one embodiment of a computer <highlight><bold>100</bold></highlight>. For purposes of the invention, computer system <highlight><bold>100</bold></highlight> may represent practically any type of computer, computer system or other programmable electronic device, including a client computer, a server computer, a portable computer, an embedded controller, etc. The computer system <highlight><bold>100</bold></highlight> may be a stand alone device or networked into a larger system. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> The computer <highlight><bold>100</bold></highlight> is shown for a multi-user-programming environment that includes at least one processor <highlight><bold>114</bold></highlight> to obtain instructions and data via bus <highlight><bold>116</bold></highlight> from main memory <highlight><bold>118</bold></highlight>. Illustratively, the processor <highlight><bold>114</bold></highlight> is any processor configured to support the methods described herein. The main memory <highlight><bold>118</bold></highlight> includes host data <highlight><bold>120</bold></highlight>, an operating system <highlight><bold>122</bold></highlight>, a computer program <highlight><bold>124</bold></highlight>, a programming environment <highlight><bold>126</bold></highlight>, and a breakpoint manager <highlight><bold>128</bold></highlight>. As an illustration, the main memory <highlight><bold>118</bold></highlight> could be one or a combination of memory devices, including random access memory (RAM), non-volatile or backup memory such as programmable or flash memory or read-only memory (ROM). The main memory <highlight><bold>118</bold></highlight> may be physically located in another part of the computer <highlight><bold>100</bold></highlight>. The programming environment <highlight><bold>126</bold></highlight> provides a means to debug the computer program <highlight><bold>124</bold></highlight> by providing tools for locating, analyzing and correcting faults. One such tool for use in debugging a program is the breakpoint manager <highlight><bold>128</bold></highlight>. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> Illustratively, the computer also includes a mass storage interface <highlight><bold>132</bold></highlight> coupled to a direct access storage device <highlight><bold>134</bold></highlight>, a terminal interface <highlight><bold>136</bold></highlight> coupled to a terminal <highlight><bold>138</bold></highlight>, and a network interface <highlight><bold>140</bold></highlight> coupled to a plurality of networked devices <highlight><bold>142</bold></highlight>. As an illustration, the terminal <highlight><bold>138</bold></highlight> and networked devices <highlight><bold>142</bold></highlight> are desktop or PC-based computers, workstations, network terminals, or other networked computer systems. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> illustrates a multi-user environment for the breakpoint manager <highlight><bold>128</bold></highlight> in computer <highlight><bold>100</bold></highlight>. Although this illustration only shows two users, a plurality of users may invoke the breakpoint manager <highlight><bold>128</bold></highlight>. A first user <highlight><bold>202</bold></highlight> coupled to a first command processor <highlight><bold>206</bold></highlight> and a second user <highlight><bold>204</bold></highlight> coupled to a second command processor <highlight><bold>208</bold></highlight> are shown associated with the breakpoint manager <highlight><bold>128</bold></highlight>. The first user <highlight><bold>202</bold></highlight> provides instructions to the first command processor <highlight><bold>206</bold></highlight> to execute or run a process using computer program <highlight><bold>124</bold></highlight>. Before executing the computer program <highlight><bold>124</bold></highlight>, the first command processor <highlight><bold>206</bold></highlight> may generate an establish-breakpoint message <highlight><bold>210</bold></highlight> to be incorporated into the program code of the computer program <highlight><bold>124</bold></highlight>. The establish breakpoint message <highlight><bold>210</bold></highlight> is then received by the breakpoint manager <highlight><bold>128</bold></highlight>. In this manner, the users may establish any number of breakpoints. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> The breakpoint manager <highlight><bold>128</bold></highlight> stores breakpoint data <highlight><bold>212</bold></highlight> and implements the breakpoint by modifying the computer program <highlight><bold>124</bold></highlight>. As an illustration, the computer program <highlight><bold>124</bold></highlight> is modified by inserting a software branch instruction, an interrupt or an invalid instruction into the program. The computer program <highlight><bold>124</bold></highlight> executes until a breakpoint is encountered. When a breakpoint is encountered, the interrupt handler <highlight><bold>214</bold></highlight> executes breakpoint processing instructions stored as the breakpoint data <highlight><bold>212</bold></highlight>. The interrupt handler <highlight><bold>214</bold></highlight> interacts with the breakpoint manager <highlight><bold>128</bold></highlight> to ensure correct processing with respect to the first user <highlight><bold>202</bold></highlight> and the second user <highlight><bold>204</bold></highlight>. As an illustration, processing includes altering the breakpoint data <highlight><bold>212</bold></highlight> and computer program <highlight><bold>124</bold></highlight> to delete a breakpoint by the breakpoint manager <highlight><bold>128</bold></highlight>. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> also shows a Useful Breakpoint Set <highlight><bold>218</bold></highlight>. The Useful Breakpoint Set <highlight><bold>218</bold></highlight> is a data structure to which breakpoints are selectively stored when program execution is halted by a user. In one embodiment, only those breakpoints associated with the user halting the program and which may actually be encountered during subsequent execution are placed into the Useful Breakpoint Set <highlight><bold>218</bold></highlight>. These breakpoints are then reestablished when the program <highlight><bold>124</bold></highlight> regains control from the debugger and resumes execution. In another embodiment, useful breakpoints are determined according to user behavior. For example, if a user consistently ignores a breakpoint (i.e., spends no time examining the state of the program when the breakpoint is hit), then the breakpoint is not useful. Persons skilled in the art will appreciate other embodiments for determining useful breakpoints, all of which are within the scope of the present invention. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> illustrates one embodiment of the structure of the breakpoint data <highlight><bold>212</bold></highlight>. The first and second command processors, <highlight><bold>206</bold></highlight>, <highlight><bold>208</bold></highlight>, respectively create a plurality of job records illustrated as JOB1 <highlight><bold>302</bold></highlight><highlight><subscript>1</subscript></highlight>, JOB2 <highlight><bold>302</bold></highlight><highlight><subscript>2</subscript></highlight>, and JOBZ <highlight><bold>302</bold></highlight><highlight><subscript>N</subscript></highlight>. As illustrated with reference to JOB1 <highlight><bold>302</bold></highlight><highlight><subscript>1</subscript></highlight>, each job record comprises a user identification (ID) <highlight><bold>304</bold></highlight> (illustrated as USER 1 in JOB1 <highlight><bold>302</bold></highlight><highlight><subscript>1</subscript></highlight>), a job identifier <highlight><bold>308</bold></highlight> (illustrated as JOB-ID 1 in JOB1 <highlight><bold>302</bold></highlight><highlight><subscript>1</subscript></highlight>), job information <highlight><bold>310</bold></highlight>, and breakpoints <highlight><bold>312</bold></highlight>. A breakpoint list <highlight><bold>314</bold></highlight> is created from the plurality of job records that is to be utilized by the breakpoint manager <highlight><bold>128</bold></highlight> and the interrupt handler <highlight><bold>214</bold></highlight>. The breakpoint list <highlight><bold>314</bold></highlight> comprises a list of active breakpoints (i.e., breakpoints <highlight><bold>312</bold></highlight>) referenced to the respective job identifiers. The breakpoint list <highlight><bold>314</bold></highlight> references a plurality of breakpoint information tables <highlight><bold>318</bold></highlight>. Specifically, a first breakpoint <highlight><bold>316</bold></highlight> associated with JOB ID 1 points to a first breakpoint information table <highlight><bold>320</bold></highlight>. Breakpoint information table <highlight><bold>320</bold></highlight> includes the breakpoint memory address <highlight><bold>322</bold></highlight> where the breakpoint resides in the main memory <highlight><bold>118</bold></highlight> and the original opcode <highlight><bold>324</bold></highlight> that was replaced by the breakpoint instruction. This original opcode <highlight><bold>324</bold></highlight> is used to return the computer program <highlight><bold>124</bold></highlight> to its original state when a breakpoint is removed and also to allow the breakpoint to be masked from other jobs. The breakpoint information table further includes the breakpoint type <highlight><bold>326</bold></highlight>. A breakpoint can be either a normal breakpoint that can be encountered in any thread of the job in which the breakpoint was set or a thread specific breakpoint that can only be encountered in a specific thread. The condition <highlight><bold>328</bold></highlight> defines if a conditional breakpoint requires specific processing. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> illustrates one embodiment of a control flow graph <highlight><bold>419</bold></highlight> (CFG). Within program <highlight><bold>124</bold></highlight>, the CFG <highlight><bold>419</bold></highlight> and related information is anchored by (pointed to or referenced by) a module list <highlight><bold>400</bold></highlight>. As known in the art, each module is a separate compilation unit. These units start out in a form commonly known as a source file. Source files can be written in one of many computer languages, such as but not limited to C, C&plus;&plus;, or ADA. These source files are then converted to object by a program called a compiler. The compiler processes the source file through a process known in the art as compilation and produces output commonly known as an object file. The object files are then linked together to produce program <highlight><bold>124</bold></highlight>. The compiler also constructs the CFG <highlight><bold>419</bold></highlight> for later use by a breakpoint analysis routine <highlight><bold>1300</bold></highlight> (described below) according to embodiments of the invention. </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> The Module list <highlight><bold>400</bold></highlight> contains a plurality of one or more module records <highlight><bold>403</bold></highlight>, <highlight><bold>404</bold></highlight>, and <highlight><bold>405</bold></highlight>. One record is provided for each object file or module used to build the program <highlight><bold>124</bold></highlight>. Because each module can contain multiple routines (procedures or methods), each module record refers to a routine list <highlight><bold>410</bold></highlight>. The routine list <highlight><bold>410</bold></highlight> contains a plurality of records, one for each routine in the module. Each record <highlight><bold>414</bold></highlight>, through <highlight><bold>415</bold></highlight> in the routine list contains the name of the routine, and a reference to the CFG constructed for that routine. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> CFG <highlight><bold>419</bold></highlight> comprises a start node <highlight><bold>420</bold></highlight> and an end node <highlight><bold>436</bold></highlight>, and intermediary nodes <highlight><bold>421</bold></highlight>, <highlight><bold>430</bold></highlight>, <highlight><bold>431</bold></highlight>, and <highlight><bold>432</bold></highlight>, which are known in the art as basic blocks. A basic block is a sequence of consecutive statements in which flow of control enters at the beginning and leaves at the end without halt or the possibility of branching except at the end. Call statements do not break a basic block and may be contained within a basic block. These basic blocks are linked by arcs <highlight><bold>440</bold></highlight>, <highlight><bold>441</bold></highlight>, <highlight><bold>442</bold></highlight>, <highlight><bold>443</bold></highlight>, and <highlight><bold>444</bold></highlight>, which specify possible program control flow between the blocks. An arc is a link connecting nodes and points to the next sequential node in the program. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> Block <highlight><bold>421</bold></highlight> is representative of the structure of all the basic block nodes within CFG <highlight><bold>419</bold></highlight>. Basic Block <highlight><bold>421</bold></highlight> contains a list of statements <highlight><bold>423</bold></highlight> that are the statements within program <highlight><bold>124</bold></highlight>, module <highlight><bold>403</bold></highlight>, and routine <highlight><bold>415</bold></highlight>, that reside in block <highlight><bold>421</bold></highlight>. List <highlight><bold>423</bold></highlight> contains statements <highlight><bold>10</bold></highlight>, <highlight><bold>11</bold></highlight>, <highlight><bold>12</bold></highlight>,<highlight><bold>13</bold></highlight>, <highlight><bold>14</bold></highlight>. In the event that a statement contains a call to another routine, such as with statement <highlight><bold>11</bold></highlight>, statement list <highlight><bold>423</bold></highlight> also contains the name of the routine that is called at that statement, e.g., routine A in the case of statement <highlight><bold>11</bold></highlight>. Those skilled in the art will realize that in the case of an object-oriented polymorphic call, multiple routines could be targeted. Thus, multiple routine names may be included in a field associated with a particular statement. </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> illustrates a single node <highlight><bold>500</bold></highlight> in a call flow graph. Illustratively, node <highlight><bold>500</bold></highlight> comprises a routine name <highlight><bold>502</bold></highlight>, a breakpoint count <highlight><bold>504</bold></highlight>, a breakpoint field <highlight><bold>506</bold></highlight>, a found value <highlight><bold>507</bold></highlight>, breakpoint operation <highlight><bold>508</bold></highlight>, first call site <highlight><bold>511</bold></highlight> and next call site <highlight><bold>512</bold></highlight>. The routine name <highlight><bold>502</bold></highlight> identifies the name of the routine that this node represents in the call graph. The breakpoint count <highlight><bold>504</bold></highlight> is the number of breakpoints that are currently set within the routine. Field <highlight><bold>506</bold></highlight> contains two subfields that are used to determine if further traversal of the call graph is needed. The found value <highlight><bold>507</bold></highlight> is the result that was found the last time this node was processed. If the value &ldquo;yes&rdquo; was stored in found value <highlight><bold>507</bold></highlight>, that indicates that a breakpoint was encountered in the call graph below this point, or that this node has not previously been processed. The value &ldquo;no&rdquo; stored in found value <highlight><bold>507</bold></highlight> indicates that no breakpoint was found. Breakpoint Operation <highlight><bold>508</bold></highlight> is the number contained in Operation Count <highlight><bold>600</bold></highlight> (described below) the last time this node was processed. List <highlight><bold>510</bold></highlight> is a list of all call sites within routine name <highlight><bold>502</bold></highlight>. Fields <highlight><bold>511</bold></highlight> and <highlight><bold>512</bold></highlight> are fields for two discrete call sites within routine <highlight><bold>502</bold></highlight>. Though in the example in <cross-reference target="DRAWINGS">FIG. 5</cross-reference> each of the call sites (<highlight><bold>511</bold></highlight> and <highlight><bold>512</bold></highlight>) are shown to be a single link those skilled in the art will appreciate that if the call is a polymorphic method call, (i.e. the call depends on the value of the object against which the method is invoked) there may be multiple arcs from a single call site to different routines. Also, in the case the call uses a function pointer as its target, the compiler may supply an arc to each procedure that has had its address taken. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> illustrates one embodiment of the operation count <highlight><bold>600</bold></highlight>. The operation count <highlight><bold>600</bold></highlight> is an integer value that is incremented every time a breakpoint is added or removed during a debug session. The operation count <highlight><bold>600</bold></highlight> is referenced to determine if the prior processing is still valid. </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> illustrates a block diagram of a call graph <highlight><bold>700</bold></highlight> otherwise known in the art as a call multi-graph. The call graph contains one node for every procedure in the computer program <highlight><bold>124</bold></highlight>, where each node is configured as node <highlight><bold>500</bold></highlight> described above. Illustratively, three nodes <highlight><bold>702</bold></highlight>, <highlight><bold>704</bold></highlight> and <highlight><bold>706</bold></highlight> are shown. Each call site within the call graph <highlight><bold>700</bold></highlight> has an entry contained in list <highlight><bold>510</bold></highlight>. The call graph is created when the object files created by the compiler are linked together. In this illustration, routine B calls routine A and routine C. The breakpoint count <highlight><bold>504</bold></highlight>B for routine B and the breakpoint count <highlight><bold>504</bold></highlight>C for routine C indicate that neither routine has a breakpoint set in those routines. The breakpoint count <highlight><bold>504</bold></highlight>A for routine A is set to 1 indicating that there is a single breakpoint set somewhere in the routine. The breakpoint operation <highlight><bold>508</bold></highlight>A-C is set to the value <highlight><bold>828</bold></highlight> in each of the routines to identify the value stored in the operation count <highlight><bold>600</bold></highlight> the last time these routines were processed by a multi-graph test. A multi-graph test will be discussed below with reference to <cross-reference target="DRAWINGS">FIG. 15</cross-reference>. </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> One embodiment illustrating the operation of the breakpoint manager <highlight><bold>128</bold></highlight> is shown as a breakpoint manager routine <highlight><bold>800</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 8</cross-reference>. The routine <highlight><bold>800</bold></highlight> is illustrated as an event-driven routine for the breakpoint manager <highlight><bold>128</bold></highlight>. In an event-driven system, the breakpoint manager routine <highlight><bold>800</bold></highlight> waits for various events. In response to an event, the breakpoint manager routine <highlight><bold>800</bold></highlight> executes predetermined program code to handle the event. Once the event has been handled, the breakpoint manager routine <highlight><bold>800</bold></highlight> returns to a state of waiting for additional events. </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> It should be appreciated that routine <highlight><bold>800</bold></highlight> is but one suitable implementation of a breakpoint manager <highlight><bold>128</bold></highlight> consistent with the invention. Other implementations may use, for example, a procedural model. In general, the implementation of a programming environment <highlight><bold>126</bold></highlight> or other computer program consistent with the invention may utilize any known programming model, and it will be appreciated that such an implementation would be well within the capabilities of one of ordinary skill in the art having benefit of the disclosure presented herein. </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> The method <highlight><bold>800</bold></highlight> is entered at step <highlight><bold>8020</bold></highlight> where the breakpoint manager <highlight><bold>128</bold></highlight> receives an event. At step <highlight><bold>804</bold></highlight>, the method queries if the event is an establish breakpoint message. If so, the method proceeds to step <highlight><bold>806</bold></highlight> where a new breakpoint is set. At step <highlight><bold>808</bold></highlight>, the breakpoint count <highlight><bold>508</bold></highlight> in the call graph node <highlight><bold>500</bold></highlight> for appropriate routine is incremented. At step <highlight><bold>810</bold></highlight>, the operational count <highlight><bold>600</bold></highlight> is incremented. When the operational count <highlight><bold>600</bold></highlight> is incremented, this indicates that the breakpoint configuration has changed and that any on-going break point analysis previously done will need to be re-computed. Thus, at step <highlight><bold>812</bold></highlight>, any on-going breakpoint analysis task is stopped since the existence of a new breakpoint set in step <highlight><bold>806</bold></highlight> can affect the results of the analysis. At step <highlight><bold>828</bold></highlight>, the breakpoint analysis task is restarted. </paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> If step <highlight><bold>804</bold></highlight> is answered in the negative, the method <highlight><bold>800</bold></highlight> proceeds to step <highlight><bold>816</bold></highlight>. At step <highlight><bold>816</bold></highlight>, the method queries if the breakpoint should be removed (e.g., in response to an explicit user request). If answered affirmatively, the method proceeds to step <highlight><bold>818</bold></highlight> where the breakpoint entry is removed and the original opcode <highlight><bold>324</bold></highlight> (operational code) is restored. At step <highlight><bold>820</bold></highlight>, the breakpoint count in the call graph node is decremented. The method then proceeds to step <highlight><bold>810</bold></highlight>. </paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> If step <highlight><bold>816</bold></highlight> was answered in the negative, the method <highlight><bold>800</bold></highlight> proceeds to step <highlight><bold>822</bold></highlight> where the method <highlight><bold>800</bold></highlight> queries if a breakpoint hit was received. If so, the method proceeds to step <highlight><bold>824</bold></highlight> where the method queries if the breakpoint is for the current job (process). This is done by accessing the breakpoint list <highlight><bold>314</bold></highlight>. If the breakpoint is not for the current job (process), the method <highlight><bold>800</bold></highlight> returns to step <highlight><bold>802</bold></highlight>, thereby masking the breakpoint from the current job (process). If the breakpoint is for the current job (process), the breakpoint is allowed to halt execution of the program and all of the breakpoints associated only with the current job are removed at step <highlight><bold>826</bold></highlight>. This occurs because breakpoints are not useful when the program is halted. The method then proceeds to step <highlight><bold>828</bold></highlight> where the breakpoint analysis task is started. The breakpoint analysis task runs in the background to determine the breakpoints that are now useful given the current stopped position of each active routine in each thread. At step <highlight><bold>830</bold></highlight>, a normal breakpoint hit message is sent to the user associated with the process. The method <highlight><bold>800</bold></highlight> then returns to step <highlight><bold>802</bold></highlight> to wait for another event. </paragraph>
<paragraph id="P-0068" lvl="0"><number>&lsqb;0068&rsqb;</number> If step <highlight><bold>822</bold></highlight> was answered negatively, the method <highlight><bold>800</bold></highlight> proceeds to step <highlight><bold>834</bold></highlight> where the method <highlight><bold>800</bold></highlight> queries if the event was a resume program message. If not, the method <highlight><bold>800</bold></highlight> performs other breakpoint functions at step <highlight><bold>836</bold></highlight>, such as viewing currently set breakpoints, and then returns to step <highlight><bold>802</bold></highlight> to wait for another event. </paragraph>
<paragraph id="P-0069" lvl="0"><number>&lsqb;0069&rsqb;</number> If at step <highlight><bold>834</bold></highlight> the event was a resume program message, the method <highlight><bold>800</bold></highlight> proceeds to step <highlight><bold>838</bold></highlight> where the method <highlight><bold>800</bold></highlight> queries if the analysis task is finished. If so, only breakpoints found useful are re-established at step <highlight><bold>840</bold></highlight> and the program is resumed at step <highlight><bold>844</bold></highlight>. If step <highlight><bold>838</bold></highlight> is answered negatively, all breakpoints for the job are re-established and the analysis task is terminated at step <highlight><bold>842</bold></highlight>. The program then resumes at step <highlight><bold>844</bold></highlight>. In either case, resuming the program at <highlight><bold>844</bold></highlight> involves emulating the saved opcode that was replaced when the breakpoint was set. The method then proceeds to step <highlight><bold>802</bold></highlight> to wait for another event. </paragraph>
<paragraph id="P-0070" lvl="0"><number>&lsqb;0070&rsqb;</number> In another embodiment, all breakpoints are indiscriminately reestablished when control returns to the program. That is, all breakpoints are removed from the program when the debugger gets control and all breakpoints are re-established when the debugger returns control to the program. This approach provides the advantages of simplicity and low-cost because no break point analysis is needed. </paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> Persons skilled in the art will readily recognize other embodiments for removing and/or re-establishing breakpoints, all of which are within the scope of the present invention. </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> Referring now to <cross-reference target="DRAWINGS">FIG. 9</cross-reference>, an establish breakpoint message method <highlight><bold>900</bold></highlight> is illustrated. Method <highlight><bold>900</bold></highlight> is one embodiment of step <highlight><bold>806</bold></highlight> which is invoked when step <highlight><bold>804</bold></highlight> is answered affirmatively. At step <highlight><bold>904</bold></highlight>, the job identifier <highlight><bold>316</bold></highlight> is retrieved. At step <highlight><bold>906</bold></highlight>, the breakpoint manager adds an entry to the breakpoint list <highlight><bold>314</bold></highlight>. The breakpoint address in memory is then computed in step <highlight><bold>908</bold></highlight> and the returned breakpoint address location is saved in the information table <highlight><bold>320</bold></highlight> at step <highlight><bold>910</bold></highlight>. At step <highlight><bold>912</bold></highlight>, the breakpoint is set by substituting the current instruction or OpCode <highlight><bold>324</bold></highlight> (operations code) with the breakpoint in memory <highlight><bold>118</bold></highlight>. At step <highlight><bold>914</bold></highlight>, a completion message is returned to the command processor <highlight><bold>206</bold></highlight>. </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10</cross-reference> illustrates a method <highlight><bold>1000</bold></highlight> for computing a breakpoint address shown as step <highlight><bold>908</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 9</cross-reference>. At step <highlight><bold>1004</bold></highlight>, breakpoint information is retrieved. The information illustratively may reside in a data structure containing a program ID, a statement number or other data identifying where the breakpoint is to be inserted. One such data structure is described below with reference to <cross-reference target="DRAWINGS">FIG. 11</cross-reference>. Program information is retrieved at step <highlight><bold>1006</bold></highlight>. One embodiment of a data structure containing the program information is described below with reference to <cross-reference target="DRAWINGS">FIG. 12</cross-reference>. At step <highlight><bold>1008</bold></highlight>, the breakpoint statement is located in memory <highlight><bold>118</bold></highlight>. Then the address of the breakpoint in memory <highlight><bold>118</bold></highlight> is returned at step <highlight><bold>1010</bold></highlight>. </paragraph>
<paragraph id="P-0074" lvl="0"><number>&lsqb;0074&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 11</cross-reference> shows one embodiment of a data structure <highlight><bold>1100</bold></highlight> containing the breakpoint information retrieved at step <highlight><bold>1004</bold></highlight> of method <highlight><bold>1000</bold></highlight>. As an illustration, the breakpoint information comprises a program ID <highlight><bold>1102</bold></highlight> identifying the software program <highlight><bold>124</bold></highlight> and the fine number <highlight><bold>1104</bold></highlight> in the software program <highlight><bold>124</bold></highlight> where the breakpoint is to be inserted. </paragraph>
<paragraph id="P-0075" lvl="0"><number>&lsqb;0075&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 12</cross-reference> illustrates one embodiment of a data structure <highlight><bold>1200</bold></highlight> illustrating the program information retrieved at step <highlight><bold>1006</bold></highlight> of method <highlight><bold>1000</bold></highlight>. As an illustration, the program information comprises a program ID <highlight><bold>1202</bold></highlight> identifying the software program <highlight><bold>124</bold></highlight>, the statement numbers <highlight><bold>1204</bold></highlight> and a map <highlight><bold>1206</bold></highlight> of the memory addresses of statement numbers. </paragraph>
<paragraph id="P-0076" lvl="0"><number>&lsqb;0076&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 13</cross-reference> illustrates one embodiment of a breakpoint analysis <highlight><bold>1300</bold></highlight>. The breakpoint analysis <highlight><bold>1300</bold></highlight> collects the set of useful breakpoints based on the stopped position of the various threads and active routines of the program. In one embodiment, the breakpoint analysis <highlight><bold>1300</bold></highlight> is executed as a background process or thread. While it is advantageous to run analysis <highlight><bold>1300</bold></highlight> as a background task, those skilled in the art will appreciate other methods in which runtime <highlight><bold>1300</bold></highlight> is not executed simultaneously with the breakpoint manager <highlight><bold>128</bold></highlight> without deviating from the scope of this inventions. </paragraph>
<paragraph id="P-0077" lvl="0"><number>&lsqb;0077&rsqb;</number> If the analysis is not completed by the time execution of the program resumes, then all breakpoints are assumed to be useful and all breakpoints are reestablished. In the case of a client based debugger, which debugs code and resides on a server system, by use of a cooperating routine on the server known in the art as a debug engine, it is contemplated that the breakpoint analysis <highlight><bold>1300</bold></highlight> could run on the server while the user of the client debugger is analyzing the data associated with the current stopped position. </paragraph>
<paragraph id="P-0078" lvl="0"><number>&lsqb;0078&rsqb;</number> The breakpoint analysis <highlight><bold>1300</bold></highlight> starts execution at step <highlight><bold>1302</bold></highlight> and first clears all the breakpoints from the useful breakpoint set <highlight><bold>218</bold></highlight>. Then at step <highlight><bold>1304</bold></highlight> the breakpoint analysis <highlight><bold>1300</bold></highlight> begins its analysis by determining which breakpoints are reachable from the stopped positions within the active procedures of each thread. For every thread of execution in the process being debugged, control proceeds to step <highlight><bold>1306</bold></highlight> which resets a visited mark (e.g., by incrementing a counter representing the value that indicates a node has been visited for this thread). The visited mark allows the analysis to examine the same nodes of the control flow graph for more than one thread. This is necessary because thread specific breakpoints may affect statements that are reachable. A thread specific breakpoint is one that can only be hit by the thread that set it. If the analysis for an earlier thread encounters a breakpoint specific to that thread then that analysis will proceed no further, but if analysis for a subsequent thread reaches that point in the CFG it will be unaffected by the thread specific breakpoint and be allowed to continue. </paragraph>
<paragraph id="P-0079" lvl="0"><number>&lsqb;0079&rsqb;</number> From step <highlight><bold>1306</bold></highlight> control proceeds to step <highlight><bold>1308</bold></highlight> which examines the call stack for the thread. For each routine on the call stack found to be debuggable, step <highlight><bold>1310</bold></highlight> is invoked to determine the useful breakpoints given the current stopped position in this particular routine. Control then proceeds to decision step <highlight><bold>1312</bold></highlight> which is answered affirmatively when a call to a routine has been encountered for which the debugger is unable to find a CFG. In this case, the debugger does not know which routines may be called within this thread by this unknown routine and must assume that any routine may have been called. If decision step <highlight><bold>1312</bold></highlight> is answered negatively, control will be directed back to step <highlight><bold>1308</bold></highlight> where the next debuggable entry in the thread&apos;s call stack will be processed. </paragraph>
<paragraph id="P-0080" lvl="0"><number>&lsqb;0080&rsqb;</number> Referring again to decision step <highlight><bold>1312</bold></highlight>, if there was a routine for which no control flow information could be found, control proceeds to step <highlight><bold>1314</bold></highlight> which visits every routine in routine list <highlight><bold>410</bold></highlight> of every module in module list <highlight><bold>400</bold></highlight>, such that any routine that is part of program <highlight><bold>124</bold></highlight> will be included. For each of these, step <highlight><bold>1316</bold></highlight> will process their CFG not from the current stopped position, but from the beginning of the control flow graph since it is unknown if the routine for which no control flow information is available may have called one of these routines. Illustratively, there are multiple methods that can be applied within the scope of the invention, which include, recognizing the library routines by name and ignoring them, or supplying minimal control flow information with them. Those skilled in the art will appreciate that the runtime library routines are routines that are not created by the user, but supplied with the operating system and as such will not be compiled with debug data, and may not contain a CFG. The majority of library routines will not transfer control back to the user code until after they complete and return. There are, therefore, no breakpoints that can be missed by not following the breakpoints&apos; true control flow. There are many ways in which these runtime library routines can be handled that will not cause the debugger to later have to make such pessimistic assumptions about what routines may have been called. One solution would be simply to know the name of each of these routines and special case them. Another solution would be to provide a minimal control flow graph for each library routine. </paragraph>
<paragraph id="P-0081" lvl="0"><number>&lsqb;0081&rsqb;</number> In other embodiments, the analysis at step <highlight><bold>1314</bold></highlight> may not be performed. Instead, the method will simply terminate if a routine is called and control flow information is not available, resulting in flagging all breakpoints as useful. Illustratively, calls through function pointers usually cannot be resolved at compile time, and thus it must be assumed that any routine with its address taken may have been called. </paragraph>
<paragraph id="P-0082" lvl="0"><number>&lsqb;0082&rsqb;</number> Once the loop entered at step <highlight><bold>1314</bold></highlight> is completed, processing returns to step <highlight><bold>1308</bold></highlight>. Once the loop entered at step <highlight><bold>1308</bold></highlight> is completed, processing returns to step <highlight><bold>1304</bold></highlight>. Once the loop entered at step <highlight><bold>1304</bold></highlight> is completed, the analysis <highlight><bold>1300</bold></highlight> exits and processing returns to <cross-reference target="DRAWINGS">FIG. 8</cross-reference>. </paragraph>
<paragraph id="P-0083" lvl="0"><number>&lsqb;0083&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 14</cross-reference> illustrates one embodiment of a Process Initial Statements routine <highlight><bold>1400</bold></highlight> which is entered from steps <highlight><bold>1310</bold></highlight> and <highlight><bold>1316</bold></highlight>. The Process Initial Statements routine <highlight><bold>1400</bold></highlight> will process the statements starting with the current stopped position within the basic block and proceeding, statement by statement, to the end of the basic block where a Traverse CFG routine (described below with respect to <cross-reference target="DRAWINGS">FIG. 16</cross-reference>) will take over and handle the remaining basic blocks. Step <highlight><bold>1402</bold></highlight> finds which statement for the current procedure maps to the current stopped position. More than one routine in a given thread may have a valid stopped position. In the case of the routine that hit a breakpoint, the stopped position will be at the point of the breakpoint, but the procedure that called the routine that hit the breakpoint also has a valid stopped position. That stopped position is at the point where the called routine hit the breakpoint. As a further illustration, any procedure that is currently active within the thread (i.e. has an entry on the call stack) will have a valid stopped position. </paragraph>
<paragraph id="P-0084" lvl="0"><number>&lsqb;0084&rsqb;</number> The routine then proceeds to step <highlight><bold>1404</bold></highlight> which answers affirmatively if there is an unconditional breakpoint at the current statement that will activate if encountered by the current thread. If step <highlight><bold>1404</bold></highlight> is answered affirmatively, then program execution reaching this point would stop at this breakpoint, and would not proceed further down this path of the CFG. Accordingly, at step <highlight><bold>1408</bold></highlight> the breakpoint is added to the useful breakpoints set <highlight><bold>218</bold></highlight>, because the breakpoint was encountered. At step <highlight><bold>1410</bold></highlight>, the routine <highlight><bold>1400</bold></highlight> returns because program control cannot reach any breakpoints beyond the current statement. Conditional breakpoints are not handled at this point because they may or may not activate if program control reaches them based on the condition that they evaluate. Those skilled in the art will appreciate that in some cases additional analysis could be done which could determine that some conditional breakpoint will actually fire the next time program control reaches them. In this case, such breakpoints could be handled by step <highlight><bold>1404</bold></highlight> answering affirmatively. </paragraph>
<paragraph id="P-0085" lvl="0"><number>&lsqb;0085&rsqb;</number> If at step <highlight><bold>1404</bold></highlight> the answer is in negative, then control proceeds to step <highlight><bold>1412</bold></highlight> that tests to see if a call statement is present within the current statement. If so, the step <highlight><bold>1412</bold></highlight> will answer affirmatively. In this case, program control will flow into the called procedure, so routine <highlight><bold>1400</bold></highlight> must attempt to follow it. To this end, control proceeds to step <highlight><bold>1414</bold></highlight> where routine <highlight><bold>1400</bold></highlight> determines if the debugger has access to a Control Flow Graph for the procedure called. The debugger is unable to follow control into this procedure if it can not obtain a CFG for the procedure. If control proceeds to a part of the program that the debugger does not have control flow information about, the debugger will have to make some pessimistic assumptions about what routines may have been called. </paragraph>
<paragraph id="P-0086" lvl="0"><number>&lsqb;0086&rsqb;</number> Referring again to <highlight><bold>1414</bold></highlight> if a CFG cannot be found, control will proceed to step <highlight><bold>1420</bold></highlight>. If a CFG is found for the current routine, then control proceeds to <highlight><bold>1416</bold></highlight> where a Multigraph Test routine is called. An illustrative Multigraph Test routine is described below with reference to <cross-reference target="DRAWINGS">FIG. 15</cross-reference>. The purpose of Multigraph Test routine is to quickly determine if there is any possibility at all of hitting a breakpoint from this program call. The call to routine <highlight><bold>1416</bold></highlight> can be omitted at the expense of performance, with the routine <highlight><bold>1400</bold></highlight> proceeding as if a breakpoint hit was possible. If it is determined at step <highlight><bold>1416</bold></highlight> that a breakpoint hit is possible, the Multigraph Test routine returns &ldquo;breakpoint found&rdquo; and proceeds to step <highlight><bold>1418</bold></highlight> which processes the control flow graph for the routine to be called at this statement by program <highlight><bold>124</bold></highlight>. In one embodiment, control then proceeds to step <highlight><bold>1420</bold></highlight>. However, it some cases it may have been conclusively determined at step <highlight><bold>1418</bold></highlight> that a breakpoint can be encountered from the present state of the program. In this case, a logic path <highlight><bold>1419</bold></highlight> is taken to return at step <highlight><bold>1410</bold></highlight>. </paragraph>
<paragraph id="P-0087" lvl="0"><number>&lsqb;0087&rsqb;</number> If at step <highlight><bold>1416</bold></highlight> a breakpoint cannot be found, then there is no reason to perform the finer resolution analysis done at step <highlight><bold>1418</bold></highlight>, since no useful breakpoint will be found. Therefore, control proceeds to step <highlight><bold>1420</bold></highlight>. </paragraph>
<paragraph id="P-0088" lvl="0"><number>&lsqb;0088&rsqb;</number> Step <highlight><bold>1420</bold></highlight> determines if there are more statements in the basic block. If so, control proceeds to step <highlight><bold>1422</bold></highlight> which sets the current statement to be the next statement in the basic step and then control proceed back to step <highlight><bold>1404</bold></highlight> where the previously described sequence is repeated for this next statement. </paragraph>
<paragraph id="P-0089" lvl="0"><number>&lsqb;0089&rsqb;</number> If at step <highlight><bold>1420</bold></highlight> it is determined that there are no statements left in the basic block, then at step <highlight><bold>1420</bold></highlight>, the routine will loop through each of the nodes in the CFG for which there is an arc to from the current node, and call a Traverse CFG routine to process each of them. An embodiment of the Traverse CFG routine is described below with reference to <cross-reference target="DRAWINGS">FIG. 16</cross-reference>. After each of these nodes has been processed control proceeds to step <highlight><bold>1428</bold></highlight> which causes control to return to <cross-reference target="DRAWINGS">FIG. 13</cross-reference>. </paragraph>
<paragraph id="P-0090" lvl="0"><number>&lsqb;0090&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 15</cross-reference> illustrates one embodiment of a multi-graph test <highlight><bold>1500</bold></highlight>. This multi-graph test <highlight><bold>1500</bold></highlight> processes nodes in the call graph <highlight><bold>700</bold></highlight> (described with reference to <cross-reference target="DRAWINGS">FIG. 7</cross-reference>) to determine if it is even possible to hit a breakpoint because of calling a particular procedure. The multi-graph test <highlight><bold>1500</bold></highlight> starts with a node in the call graph that represents the routine to be called by computer program <highlight><bold>124</bold></highlight>. At step <highlight><bold>1502</bold></highlight> the node is checked to see if it has already been processed while the program breakpoints were still in their current configuration. It does this by comparing the Breakpoint Operation <highlight><bold>508</bold></highlight>, to the Operation Count <highlight><bold>600</bold></highlight> and if the two are equal then the breakpoint configuration has not changed since no breakpoints have been added or removed since this node was last processed. If the Breakpoint Operation <highlight><bold>508</bold></highlight> of the current node and Operation Count <highlight><bold>600</bold></highlight> are equal, control flows to step <highlight><bold>1504</bold></highlight>. At step <highlight><bold>1504</bold></highlight>, the found value <highlight><bold>507</bold></highlight> is checked for the current node. Step <highlight><bold>1504</bold></highlight> is answered negatively if the found value <highlight><bold>507</bold></highlight> is &ldquo;No&rdquo;, and is answered affirmatively if the found value <highlight><bold>507</bold></highlight> is &ldquo;Yes&rdquo;. If the found value <highlight><bold>507</bold></highlight> is &ldquo;No&rdquo;, control proceeds to step <highlight><bold>1506</bold></highlight> which returns an indication that the breakpoint is not found and can not be hit as a result a call to this routine. If the found value <highlight><bold>507</bold></highlight> is &ldquo;Yes&rdquo;, an indication is returned (at step <highlight><bold>1508</bold></highlight>) that a breakpoint can possibly be hit. </paragraph>
<paragraph id="P-0091" lvl="0"><number>&lsqb;0091&rsqb;</number> Referring again to step <highlight><bold>1502</bold></highlight>, if the Breakpoint Operation <highlight><bold>508</bold></highlight> and Operation Count <highlight><bold>600</bold></highlight> do not match, then the breakpoint configuration may have changed since breakpoints have been added or removed. In this case step <highlight><bold>1502</bold></highlight> answers negatively and control proceeds to step <highlight><bold>1510</bold></highlight>. At step <highlight><bold>1510</bold></highlight>, it is determined if there are breakpoints in the routine associated with the current node of the call graph. If a breakpoint is set, then the Breakpoint Count <highlight><bold>504</bold></highlight> will be found to be greater than zero and control will proceed to step <highlight><bold>1512</bold></highlight> which will update field Breakpoint Operation <highlight><bold>508</bold></highlight> with the current value of Operation Count <highlight><bold>600</bold></highlight> thus marking the node as currently processed. At step <highlight><bold>1514</bold></highlight>, found value <highlight><bold>507</bold></highlight> is set to &ldquo;Yes&rdquo; since a breakpoint may be hit, because there is a breakpoint within this routine. Control then proceeds to step <highlight><bold>1508</bold></highlight> which returns an indication that a breakpoint may be hit. </paragraph>
<paragraph id="P-0092" lvl="0"><number>&lsqb;0092&rsqb;</number> Referring again to step <highlight><bold>1510</bold></highlight>, if the breakpoint count is equal to zero then there is not a breakpoint set in the current routine, control will then proceed to step <highlight><bold>1516</bold></highlight>. Steps <highlight><bold>1516</bold></highlight> and <highlight><bold>1518</bold></highlight> have the purpose of marking a node in the call graph as visited, thus preventing an endless loop. Step <highlight><bold>1516</bold></highlight> updates field <highlight><bold>508</bold></highlight> with the current value of the Operation Count <highlight><bold>600</bold></highlight>. The step <highlight><bold>1518</bold></highlight> sets the value of Found field <highlight><bold>507</bold></highlight> to be &ldquo;No&rdquo; so that if this node is again encountered at step <highlight><bold>1522</bold></highlight> (described below) it will not take the Breakpoint found case and return, but simply continue to step <highlight><bold>1520</bold></highlight> and process the next routine. After step <highlight><bold>1518</bold></highlight>, control proceeds to step <highlight><bold>1520</bold></highlight>, which loops though each entry in list <highlight><bold>510</bold></highlight> for the current node in the call graph. For each entry, decision step <highlight><bold>1522</bold></highlight> is invoked whereby the multigraph test is called recursively. If it is determined that a breakpoint cannot be hit, control proceeds back to <highlight><bold>1520</bold></highlight> to try the next routine. On the other hand, if step <highlight><bold>1522</bold></highlight> determines that a breakpoint can be hit, then control proceeds to step <highlight><bold>1512</bold></highlight>. Once all of the entries in list <highlight><bold>510</bold></highlight> have been processed at step <highlight><bold>1520</bold></highlight>, control proceeds to step <highlight><bold>1524</bold></highlight> which marks the node as processed by setting Breakpoint Operation field <highlight><bold>508</bold></highlight> equal to Operation Count <highlight><bold>600</bold></highlight>. The method <highlight><bold>1500</bold></highlight> then proceeds to step <highlight><bold>1526</bold></highlight> which sets the found value <highlight><bold>507</bold></highlight> to &ldquo;No&rdquo; because the breakpoint could not be found. The method <highlight><bold>1500</bold></highlight> then proceeds to step <highlight><bold>1506</bold></highlight> which returns an indication as such. </paragraph>
<paragraph id="P-0093" lvl="0"><number>&lsqb;0093&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 16</cross-reference> illustrates a Traverse CFG <highlight><bold>1600</bold></highlight> routine which is called at steps <highlight><bold>1418</bold></highlight> and <highlight><bold>1426</bold></highlight> of routine <highlight><bold>1400</bold></highlight>. Routine <highlight><bold>1600</bold></highlight> first asks at step <highlight><bold>1602</bold></highlight> if the current node of the control flow graph has been visited since the visited indicator was reset at step <highlight><bold>1306</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 13</cross-reference>. If so, then step <highlight><bold>1602</bold></highlight> answers affirmatively and the routine <highlight><bold>1600</bold></highlight> returns at <highlight><bold>1604</bold></highlight>. If the node has not been visited, then control proceeds to step <highlight><bold>1606</bold></highlight> where the node is marked with the current visited indicator. Decision step <highlight><bold>1608</bold></highlight> determines if there is a call to another routine within the block. If so, control proceeds to step <highlight><bold>1610</bold></highlight>. At step <highlight><bold>1610</bold></highlight>, each statement in the block is examined until an unconditional breakpoint is encountered, or the end of the basic block is reached. For each statement that contains a call statement, control is passed to step <highlight><bold>1612</bold></highlight>. Step <highlight><bold>1612</bold></highlight> determines if a control flow graph can be located for the routine called. If not, control must return to step <highlight><bold>1610</bold></highlight> and later processing (starting at step <highlight><bold>1312</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 13</cross-reference>) will have to make pessimistic assumptions. If the CFG for the routine is found, then step <highlight><bold>1614</bold></highlight> determines if it is possible to hit a breakpoint as a result of this call, and if so control proceeds to step <highlight><bold>1616</bold></highlight> to process the CFG for the current routine. If step <highlight><bold>1614</bold></highlight> had determined it was not possible to hit a breakpoint as a result of calling the routine called at this statement, then control would proceed back to step <highlight><bold>1610</bold></highlight> to proceed to the next routine. Once all the routine calls in the block have been processed, or if at step <highlight><bold>1608</bold></highlight> no routine calls were found within the basic block, then control would proceed to decision step <highlight><bold>1618</bold></highlight>. Step <highlight><bold>1618</bold></highlight> determines if there is an unconditional breakpoint that can activate for the current thread set in the basic block. If there is, then decision step <highlight><bold>1618</bold></highlight> answers affirmatively, and control proceeds to step <highlight><bold>1620</bold></highlight>. Step <highlight><bold>1620</bold></highlight> adds the first unconditional breakpoint found in the step to the useful breakpoint set <highlight><bold>218</bold></highlight>. Although not indicated in <cross-reference target="DRAWINGS">FIG. 16</cross-reference>, if any conditional breakpoints are found prior to this step, they too will be added to the useful breakpoint set. Control then proceeds to step <highlight><bold>1622</bold></highlight> to return since program control cannot proceed past the breakpoint found. </paragraph>
<paragraph id="P-0094" lvl="0"><number>&lsqb;0094&rsqb;</number> If no unconditional breakpoint was located at step <highlight><bold>1618</bold></highlight> then control proceeds to step <highlight><bold>1624</bold></highlight> to ask if a conditional breakpoint is present. If so, then all the conditional breakpoints present in the block are added to the Useful Breakpoint Set <highlight><bold>218</bold></highlight>. After step <highlight><bold>1626</bold></highlight>, or if step <highlight><bold>1624</bold></highlight> is answered in the negative, control proceeds to step <highlight><bold>1628</bold></highlight> which loops through every node in the CFG for which there is an arc from this current node. For each of these nodes, control is transferred to step <highlight><bold>1630</bold></highlight> that processes each node. When all the nodes have been processed, the routine <highlight><bold>1600</bold></highlight> proceeds to step <highlight><bold>1632</bold></highlight> which returns control to <cross-reference target="DRAWINGS">FIG. 14</cross-reference>. </paragraph>
<paragraph id="P-0095" lvl="0"><number>&lsqb;0095&rsqb;</number> While the foregoing is directed to embodiments of the present invention, other and further embodiments of the invention may be devised without departing from the basic scope thereof, and the scope thereof is determined by the claims that follow. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method of debugging a program in a computer system, comprising automatically removing at least a portion of all breakpoints associated with a particular job from the program when a debugger gets control of the program for the particular job. </claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the portion is removed during a time when execution of the program is halted. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising upon returning control from the debugger to the program, automatically reestablishing at least one useful breakpoint from the removed breakpoints. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference>, wherein the at least one useful breakpoint is determined by executing a task to identify each unexecuted breakpoint located in an unexecuted portion of the program. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference>, wherein the at least one useful breakpoint is determined by analyzing a behavior of a user responsible for setting the at least one useful breakpoint. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference>, wherein the at least one useful breakpoint may be encountered by a thread which is allowed to execute when control is returned from the debugger to the program. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference>, wherein upon returning control from the debugger to the program at least one thread is prevented from continuing execution and wherein any breakpoints which may have been encountered only by the at least one thread during continuing execution are considered useless and are not reestablished. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. A method of debugging a program in a computer system, comprising: 
<claim-text>upon a debugger getting control of the program for a particular job, determining whether at least one useful breakpoint exists in the program for the particular job; </claim-text>
<claim-text>if so, removing from the program all breakpoints associated with the particular job except the at least one useful breakpoint; </claim-text>
<claim-text>prior to returning control to the program from the debugger, determining whether at least one of the removed breakpoints is useful; and </claim-text>
<claim-text>if so, reestablishing the at least one of the removed breakpoints. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference>, wherein at least one of (i) determining whether at least one useful breakpoint exists in the program for the particular job and (ii) determining whether at least one of the removed breakpoints is useful comprises executing a task to identify at least one breakpoint which may be encountered upon resuming execution of the program. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference>, wherein at least one of the at least one useful breakpoint and the at least one of the removed breakpoints is determined by analyzing a behavior of a user responsible for setting the respective breakpoint. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference>, further comprising returning control to the program. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. A method of debugging a program in a multi-user computer system, comprising: 
<claim-text>during a time when execution of the program is halted, removing all breakpoints associated with a particular job from the program; </claim-text>
<claim-text>executing a task to identify each useful breakpoint located in the program, wherein a useful breakpoint is one which may be encountered upon resuming execution of the program; and </claim-text>
<claim-text>if the task is completed before execution of the program is resumed, inserting each useful breakpoint into its original location in the program. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, wherein the multi-user computer system is a single level store computer. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, wherein the task is restarted in an event of removing and establishing at least one breakpoint. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, further comprising inserting all removed breakpoints in the program if the task is not completed when execution of the program is resumed. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, wherein the task is executed in response to hitting a breakpoint and wherein the task is restarted in an event of removing and establishing at least one breakpoint. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, wherein executing the task comprises at least one of traversing a control flow graph of the program and traversing a call graph of the program. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, wherein executing the task comprises: 
<claim-text>determining whether a call to a routine is made from a current routine at which execution halted; and </claim-text>
<claim-text>if so, determining whether at least one of the routine and a called routine called from the routine contains a breakpoint; </claim-text>
<claim-text>if so, adding the breakpoint to a useful breakpoint set. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 18</dependent-claim-reference>, wherein determining whether at least one of the routine and the called routine contains a breakpoint comprises: 
<claim-text>accessing a value in a call graph node of the routine, wherein the value is indicative of whether the at least one of the routine and the called routine contains the breakpoint; </claim-text>
<claim-text>if the value indicates a presence of the breakpoint, traversing each node of a control flow graph, beginning with a node containing the routine. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference>, wherein the task is performed for each routine of each thread of execution of the program. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. A computer readable medium, comprising a program which, when executed by a processor in a multi-user system performs operations, comprising automatically removing at least a portion of all breakpoints associated with a particular job from the program when a debugger gets control of the program for the particular job. </claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The computer readable medium of <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference>, wherein the portion is removed during a time when execution of the program is halted. </claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The computer readable medium of <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference>, further comprising upon returning control from the debugger to the program, automatically reestablishing at least one useful breakpoint from the removed breakpoints. </claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The computer readable medium of <dependent-claim-reference depends_on="CLM-00022">claim 23</dependent-claim-reference>, wherein the at least one useful breakpoint is determined by executing a task to identify each unexecuted breakpoint located in an unexecuted portion of the program. </claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. The computer readable medium of <dependent-claim-reference depends_on="CLM-00022">claim 23</dependent-claim-reference>, wherein the at least one useful breakpoint is determined by analyzing a behavior of a user responsible for setting the at least one useful breakpoint. </claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. The computer readable medium of <dependent-claim-reference depends_on="CLM-00022">claim 23</dependent-claim-reference>, wherein the at least one useful breakpoint may be encountered by a thread which is allowed to execute when control is returned from the debugger to the program. </claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. The computer readable medium of <dependent-claim-reference depends_on="CLM-00022">claim 23</dependent-claim-reference>, wherein upon returning control from the debugger to the program at least one thread is prevented from continuing execution and wherein any breakpoints which may have been encountered only by the at least one thread during continuing execution are considered useless and are not reestablished. </claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. A computer readable medium, comprising a program which, when executed by a processor in a multi-user system performs operations, comprising: 
<claim-text>during a time when execution of the program is halted, removing all breakpoints associated with a particular job from the program; </claim-text>
<claim-text>executing a task to identify each useful breakpoint located in the program, wherein a useful breakpoint is one which may be encountered upon resuming execution of the program; and </claim-text>
<claim-text>if the task is completed before execution of the program is resumed, inserting each useful breakpoint into its original location in the program. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00029">
<claim-text><highlight><bold>29</bold></highlight>. The computer readable medium of <dependent-claim-reference depends_on="CLM-00022">claim 28</dependent-claim-reference>, wherein the multi-user computer system is a single level store computer. </claim-text>
</claim>
<claim id="CLM-00030">
<claim-text><highlight><bold>30</bold></highlight>. The computer readable medium of <dependent-claim-reference depends_on="CLM-00022">claim 28</dependent-claim-reference>, wherein the task is restarted in an event of removing and establishing at least one breakpoint. </claim-text>
</claim>
<claim id="CLM-00031">
<claim-text><highlight><bold>31</bold></highlight>. The computer readable medium of <dependent-claim-reference depends_on="CLM-00022">claim 28</dependent-claim-reference>, further comprising inserting all removed breakpoints in the program if the task is not completed when execution of the program is resumed. </claim-text>
</claim>
<claim id="CLM-00032">
<claim-text><highlight><bold>32</bold></highlight>. The computer readable medium of <dependent-claim-reference depends_on="CLM-00022">claim 28</dependent-claim-reference>, wherein the task is executed in response to hitting a breakpoint and wherein the task is restarted in an event of removing and establishing at least one breakpoint. </claim-text>
</claim>
<claim id="CLM-00033">
<claim-text><highlight><bold>33</bold></highlight>. The computer readable medium of <dependent-claim-reference depends_on="CLM-00022">claim 28</dependent-claim-reference>, wherein executing the task comprises at least one of traversing a control flow graph of the program and traversing a call graph of the program. </claim-text>
</claim>
<claim id="CLM-00034">
<claim-text><highlight><bold>34</bold></highlight>. The computer readable medium of <dependent-claim-reference depends_on="CLM-00022">claim 28</dependent-claim-reference>, wherein executing the task comprises: 
<claim-text>determining whether a call to a routine is made from a current routine at which execution halted; and </claim-text>
<claim-text>if so, determining whether at least one of the routine and a called routine called from the routine contains a breakpoint; </claim-text>
<claim-text>if so, adding the breakpoint to a useful breakpoint set. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00035">
<claim-text><highlight><bold>35</bold></highlight>. The computer readable medium of <dependent-claim-reference depends_on="CLM-00033">claim 34</dependent-claim-reference>, wherein determining whether at least one of the routine and the called routine contains a breakpoint comprises: 
<claim-text>accessing a value in a call graph node of the routine, wherein the value is indicative of whether the at least one of the routine and the called routine contains the breakpoint; </claim-text>
<claim-text>if the value indicates a presence of the breakpoint, traversing each node of a control flow graph, beginning with a node containing the routine. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00036">
<claim-text><highlight><bold>36</bold></highlight>. The computer readable medium of <dependent-claim-reference depends_on="CLM-00033">claim 35</dependent-claim-reference>, wherein the task is performed for each routine of each thread of execution of the program. </claim-text>
</claim>
<claim id="CLM-00037">
<claim-text><highlight><bold>37</bold></highlight>. The computer readable medium of <dependent-claim-reference depends_on="CLM-00022">claim 28</dependent-claim-reference>, wherein executing the task comprises, for each routine of each thread of execution of the program: 
<claim-text>determining whether a current statement at which execution halted contains an unconditional breakpoint; and </claim-text>
<claim-text>if so, adding the unconditional breakpoint to a useful breakpoint set. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00038">
<claim-text><highlight><bold>38</bold></highlight>. The computer readable medium of <dependent-claim-reference depends_on="CLM-00033">claim 37</dependent-claim-reference>, further comprising, if the current statement at which execution halted does not contain an unconditional breakpoint: 
<claim-text>determining whether a call to another routine is made; and </claim-text>
<claim-text>if so, determining whether at least one of the another routine and a called routine called from the another routine contains a breakpoint; </claim-text>
<claim-text>if so, adding the breakpoint to the useful breakpoint set. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00039">
<claim-text><highlight><bold>39</bold></highlight>. The computer readable medium of <dependent-claim-reference depends_on="CLM-00033">claim 38</dependent-claim-reference>, wherein determining whether the at least one of the another routine and the called routine contains the breakpoint comprises accessing a call graph node of at least the another routine.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>2</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005415A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005415A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005415A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005415A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005415A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005415A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030005415A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030005415A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030005415A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00009">
<image id="EMI-D00009" file="US20030005415A1-20030102-D00009.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00010">
<image id="EMI-D00010" file="US20030005415A1-20030102-D00010.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00011">
<image id="EMI-D00011" file="US20030005415A1-20030102-D00011.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00012">
<image id="EMI-D00012" file="US20030005415A1-20030102-D00012.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
