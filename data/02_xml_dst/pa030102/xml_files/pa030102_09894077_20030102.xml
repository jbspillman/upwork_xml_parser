<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005354A1-20030102-D00000.TIF SYSTEM "US20030005354A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005354A1-20030102-D00001.TIF SYSTEM "US20030005354A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005354A1-20030102-D00002.TIF SYSTEM "US20030005354A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005354A1-20030102-D00003.TIF SYSTEM "US20030005354A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005354A1-20030102-D00004.TIF SYSTEM "US20030005354A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005354A1-20030102-D00005.TIF SYSTEM "US20030005354A1-20030102-D00005.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005354</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09894077</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010628</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>H04L001/22</ipc>
</classification-ipc-primary>
<classification-ipc-secondary>
<ipc>G06F011/08</ipc>
</classification-ipc-secondary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>714</class>
<subclass>007000</subclass>
</uspc>
</classification-us-primary>
<classification-us-secondary>
<uspc>
<class>714</class>
<subclass>006000</subclass>
</uspc>
</classification-us-secondary>
</classification-us>
<title-of-invention>System and method for servicing requests to a storage array</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Dean</given-name>
<middle-name>Alan</middle-name>
<family-name>Kalman</family-name>
</name>
<residence>
<residence-us>
<city>Cary</city>
<state>NC</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
</inventors>
<assignee>
<organization-name>International Business Machines Corporation</organization-name>
<assignee-type>02</assignee-type>
</assignee>
<correspondence-address>
<name-1>BRACEWELL &amp; PATTERSON, L.L.P.</name-1>
<name-2></name-2>
<address>
<address-1>P.O. BOX 969</address-1>
<city>AUSTIN</city>
<state>TX</state>
<postalcode>78767-0969</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">According to the method of the present invention, if a data read request to an unavailable particular storage medium is received from a system processor, a request servicing circuit of an adapter reconstructs the request data from data and parity data stored on other storage media in the array. However, if a data write request to an unavailable storage medium is received from the system processor, the actual data related to the data write request is stored in a temporary memory location, and the data write request is logged in a non-volatile memory. There is no built-in data redundancy in a first preferred embodiment of the present invention; thus, modified data is lost in the event of the failure of another storage medium during the update of the selected storage medium. However, a second preferred embodiment of the present invention incorporates a spare storage medium that preserves the modified data if another storage medium fails. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> 1. Technical Field </paragraph>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> The present invention relates in general to data processing systems, and more particularly, data storage within data processing systems. Still more particularly, the present invention relates to a system and method for handling data requests within data processing systems. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> 2. Description of the Related Art </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> In modern computer systems, users frequently access common data stored in a redundant array of inexpensive disks (RAID) of a central networked computer. Redundancy is employed so that if a hard disk of the RAID fails, the data stored on the failed hard disk can be rebuilt utilizing data and parity data stored on the other hard disks of the RAID while the failed hard disk is taken off-line and repaired. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> Hard disks within a RAID frequently are subject to numerous accesses ranging from relatively short data writes or reads to relatively lengthy updates of the configuration of the hard disk. During access to a disk, one or more users of the computer system may be unable to access the data on the disk. Such users typically wait until the hard disk completes the previous process until their data access requests can be fulfilled. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> An example of a lengthy hard disk update that would restrict user access to data is a firmware update. Firmware updates may be required, for example, to resolve incompatibilities between components (e.g., hard disks) or to correct errors in the firmware that are not detected until after the release of the firmware. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> An update to the firmware of a conventional hard disk cannot be performed when the drive is on-line. Because of this limitation, hard disk firmware updates are performed in a controlled operating system environment with the selected hard disk set to an off-line mode to prevent access to the hard disk. Utilizing a single threaded environment (e.g., disk operating system, or DOS) allows a hard disk firmware update application to assume control of the computer system and prevent other applications from accessing the hard disk during the firmware update. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> Because many computer systems and networks employ multi-threaded operating systems (e.g., Windows NT), to perform a firmware update, an administrator typically shuts down the multi-threaded operating system, takes the computer system off-line, boots DOS, runs the hard disk update software, and waits for the update to complete. During the firmware update, the RAID is taken off-line, which prevents other users from accessing the data stored on the RAID. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> Thus, it is often the case that users may request access to data stored on a hard disk that is unavailable due to an update, repair, or another access. The present invention recognizes that a system and method for servicing a data request to an unavailable hard disk without waiting for the update, access, or repair to be completed, would improve the overall of a data processing system. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> To overcome the foregoing and additional limitations of the prior art, the present invention presents an improved system and method of servicing a data request to a storage media array. In accordance with a preferred embodiment of the present invention, the data processing system includes an adapter and a redundant array of inexpensive disks (RAID). The adapter includes an updating circuit and a request servicing circuit. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> According to the method of the present invention, if a data read request to an unavailable particular storage medium is received from a system processor, a request servicing circuit of an adapter reconstructs the request data from data and parity data stored on other storage media in the array. However, if a data write request to an unavailable storage medium is received from the system processor, the actual data related to the data write request is stored in a temporary memory location, and the data write request is logged in a non-volatile memory. There is no built-in data redundancy in a first preferred embodiment of the present invention; thus, modified data is lost in the event of the failure of another storage medium during the update of the selected storage medium. However, a second preferred embodiment of the present invention incorporates a spare storage medium that preserves the modified data if another storage medium fails. </paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> The novel features believed characteristic of the invention are set forth in the appended claims. The invention itself however, as well as a preferred mode of use, further objects and advantages thereof, will best be understood by reference to the following detailed description of an illustrative embodiment when read in conjunction with the accompanying drawings, wherein: </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> depicts a detailed block diagram of an exemplary data processing system, which may be utilized to implement the present invention; </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> illustrates a detailed block diagram of an adapter for a storage array in accordance with a preferred embodiment of the present invention; </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3A</cross-reference> depicts a high-level logic flowchart illustrating a first method for servicing a data request to a storage array according to a preferred embodiment of the present invention; </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3B</cross-reference> illustrates a table depicting a redundant array of inexpensive disks (RAID) implementing a first method of servicing a data request to a storage array according to a preferred embodiment of the present invention; </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4A</cross-reference> depicts a high-level logic flowchart illustrating a second method for servicing a data request to a storage array including a spare storage medium according to a preferred embodiment of the present invention; and </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4B</cross-reference> illustrates a table depicting a RAID implementing a second method of servicing a data request to a storage array according to a preferred embodiment of the present invention. </paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DESCRIPTION OF THE PREFERRED EMBODIMENT </heading>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> With reference now to the figures and in particular with reference to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, there is depicted a detailed block diagram of a data processing system <highlight><bold>10</bold></highlight> in which a preferred embodiment of the present invention may be implemented. As illustrated, data processing system <highlight><bold>10</bold></highlight> includes a system processor <highlight><bold>12</bold></highlight>, a system memory <highlight><bold>14</bold></highlight>, a user interface <highlight><bold>17</bold></highlight>, and a communications control unit <highlight><bold>19</bold></highlight>, all coupled via a system interconnect <highlight><bold>16</bold></highlight>. System processor <highlight><bold>12</bold></highlight>, which may be implemented as one or more processors, such as any generation of Pentium&trade; processor available from Intel Corporation in Santa Clara, Calif., executes software instructions to control the operation of data processing system <highlight><bold>10</bold></highlight>. System memory <highlight><bold>14</bold></highlight> provides storage for software and data and may include both read-only memory (ROM) and random access memory (RAM). </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> It should be readily apparent to those skilled in the art that system interconnect <highlight><bold>16</bold></highlight> may be implemented as a bus, a switch or any other type of coupling apparatus. User interface <highlight><bold>17</bold></highlight> provides an interface between data processing system <highlight><bold>10</bold></highlight> and peripherals employed by a user to interact with data processing system <highlight><bold>10</bold></highlight>. User interface <highlight><bold>17</bold></highlight> may include various adapters and drivers for controlling peripherals, such as keyboard <highlight><bold>28</bold></highlight>, display <highlight><bold>30</bold></highlight>, and mouse <highlight><bold>32</bold></highlight>. Communications control unit <highlight><bold>19</bold></highlight> provides an interface between data processing system <highlight><bold>10</bold></highlight> and an external network <highlight><bold>26</bold></highlight>, which may be a local area network (LAN) or a wide area network (WAN) such as the Internet. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> An adapter <highlight><bold>22</bold></highlight> controls access and updates to a storage media array <highlight><bold>23</bold></highlight> via an array interconnect <highlight><bold>25</bold></highlight> and is coupled to system processor <highlight><bold>12</bold></highlight> by a mezzanine interconnect <highlight><bold>18</bold></highlight>, which in a preferred embodiment of the present invention may be implemented as a peripheral component interconnect (PCI) bus. Array interconnect <highlight><bold>25</bold></highlight> can be implemented as a small computer system interface (SCSI) bus. It should be readily apparent to those skilled in the art that any interconnect system (e.g., integrated device electronics, or IDE) may be implemented to couple storage media array <highlight><bold>23</bold></highlight> to system processor <highlight><bold>12</bold></highlight>. Storage media array <highlight><bold>23</bold></highlight> can be implemented as a redundant array of inexpensive disks (RAID) <highlight><bold>24</bold></highlight><highlight><italic>a</italic></highlight>-<highlight><bold>24</bold></highlight><highlight><italic>n. </italic></highlight></paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> Referring now to <cross-reference target="DRAWINGS">FIG. 2, a</cross-reference> detailed block diagram is illustrated of an adapter <highlight><bold>22</bold></highlight> utilized by a data processing system <highlight><bold>10</bold></highlight>, as depicted in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, according to a preferred embodiment of the present invention. Adapter <highlight><bold>22</bold></highlight> coordinates updates and services data requests to storage media array <highlight><bold>23</bold></highlight> by system processor <highlight><bold>12</bold></highlight> or by other networked data processing systems coupled to data processing system <highlight><bold>10</bold></highlight>. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> As depicted, adapter <highlight><bold>22</bold></highlight> includes an adapter processor <highlight><bold>104</bold></highlight> that is implemented as an updating circuit for coordinating accesses and updates to storage media array <highlight><bold>23</bold></highlight>. Coupled to adapter processor <highlight><bold>104</bold></highlight> via an adapter interconnect <highlight><bold>102</bold></highlight> is an adapter processor memory <highlight><bold>106</bold></highlight>, which functions as a cache memory for adapter processor <highlight><bold>104</bold></highlight>. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> Further coupled to adapter processor <highlight><bold>104</bold></highlight> is non-volatile random access memory (NVRAM) <highlight><bold>108</bold></highlight>. During an update to a selected storage medium of storage media array <highlight><bold>23</bold></highlight>, adapter <highlight><bold>22</bold></highlight> receives a data write request from system processor <highlight><bold>12</bold></highlight>. NVRAM <highlight><bold>108</bold></highlight> logs the data write request as a &ldquo;dirty stripe&rdquo;, or a stripe of modified data. The actual data from the data write request are stored in another storage medium in the array. Requests for data during an update to the storage medium of storage media array <highlight><bold>23</bold></highlight> are handled by a request servicing circuit, implemented as an exclusive-OR (XOR) processor <highlight><bold>112</bold></highlight>, coupled by adapter interconnect <highlight><bold>102</bold></highlight>. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> Adapter <highlight><bold>22</bold></highlight> finally includes PCI/PCI bridge <highlight><bold>114</bold></highlight>, and small computer system interface (SCSI) channels <highlight><bold>116</bold></highlight> to facilitate data communication between system PCI bus <highlight><bold>18</bold></highlight> and SCSI bus <highlight><bold>25</bold></highlight>. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 3</cross-reference>A, there is illustrated a high-level logic flowchart depicting an exemplary method by which an adapter <highlight><bold>22</bold></highlight> services a request to access a storage media array <highlight><bold>23</bold></highlight> according to a first embodiment of the present invention. In <cross-reference target="DRAWINGS">FIG. 3</cross-reference>B, there is depicted a table that illustrates an exemplary RAID that stores data in stripes across three storage media. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> As depicted in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>A, the method begins at block <highlight><bold>200</bold></highlight> and then continues to an update loop including blocks <highlight><bold>202</bold></highlight>, <highlight><bold>204</bold></highlight>, and <highlight><bold>206</bold></highlight>. During the execution of the update loop, an adapter processor <highlight><bold>104</bold></highlight> (or other suitable updating circuit) selects a storage medium to update out of storage media array <highlight><bold>23</bold></highlight>, as shown in block <highlight><bold>202</bold></highlight>. In this example, adapter <highlight><bold>22</bold></highlight> selects storage medium <highlight><bold>2</bold></highlight> for updating, as depicted in <cross-reference target="DRAWINGS">FIG. 3B</cross-reference>. As illustrated in block <highlight><bold>204</bold></highlight>, adapter processor <highlight><bold>104</bold></highlight> sets the storage medium <highlight><bold>2</bold></highlight> to an off-line status, and begins relaying update data (e.g., updated firmware) to storage medium <highlight><bold>2</bold></highlight>, as depicted in block <highlight><bold>206</bold></highlight>. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> The process then enters a request servicing loop that includes blocks <highlight><bold>208</bold></highlight>, <highlight><bold>210</bold></highlight>, <highlight><bold>212</bold></highlight>, <highlight><bold>213</bold></highlight>, <highlight><bold>214</bold></highlight>, <highlight><bold>216</bold></highlight>, <highlight><bold>218</bold></highlight> and <highlight><bold>220</bold></highlight>. The request servicing loop illustrates the process of providing a user with requested data that is located on a selected, inaccessible storage medium. In this example, as depicted in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>B, storage medium <highlight><bold>2</bold></highlight> is inaccessible at this time because adapter <highlight><bold>22</bold></highlight> had been instructed by system processor <highlight><bold>12</bold></highlight> to perform an update to storage medium <highlight><bold>2</bold></highlight>. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> During the update of storage medium <highlight><bold>2</bold></highlight>, adapter <highlight><bold>22</bold></highlight> monitors for data requests to the selected storage medium, as shown in block <highlight><bold>208</bold></highlight>. If adapter <highlight><bold>22</bold></highlight> monitors a data request to the selected storage medium and the data request is a data read request (e.g., a data read request for data D<highlight><bold>1</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 3B</cross-reference>), as depicted in block <highlight><bold>210</bold></highlight>, the requested data D<highlight><bold>1</bold></highlight> are automatically reconstructed by a request servicing circuit, implemented as a XOR processor <highlight><bold>112</bold></highlight>, utilizing data D<highlight><bold>0</bold></highlight> and parity data P<highlight><bold>1</bold></highlight> stored in other storage media in the array, as shown in block <highlight><bold>212</bold></highlight>. The request servicing circuit provides the requested data to the requesting component, as depicted in block <highlight><bold>213</bold></highlight>. The process then returns from block <highlight><bold>213</bold></highlight> to block <highlight><bold>208</bold></highlight>. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> If the data request is not a data read request, the data request is assumed to be a data write request, as illustrated in block <highlight><bold>214</bold></highlight>. The data write request and the location of the data related to the data write request are logged within NVRAM <highlight><bold>108</bold></highlight>, and the actual data corresponding to the data write request are stored another storage medium in the array, as depicted in blocks <highlight><bold>216</bold></highlight> and <highlight><bold>218</bold></highlight>. The process then returns from block <highlight><bold>218</bold></highlight> to block <highlight><bold>208</bold></highlight>, where the process monitors for data requests to storage media <highlight><bold>2</bold></highlight>, as illustrated. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> If adapter <highlight><bold>22</bold></highlight> does not receive a data request to the selected storage medium, the process moves from block <highlight><bold>208</bold></highlight> to block <highlight><bold>220</bold></highlight>, which depicts a determination of whether or not the update of the selected storage medium is complete. If the update of the selected storage medium is not complete, the process returns from block <highlight><bold>220</bold></highlight> to block <highlight><bold>208</bold></highlight> where adapter <highlight><bold>22</bold></highlight> continues to monitor for a data request to the selected storage medium. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> If the update of the selected storage medium is complete, the process continues to block <highlight><bold>222</bold></highlight>, where each dirty stripe logged in NVRAM is rebuilt with data and parity data stored on other the storage media in the storage media array, and the new data stored in the temporary location in the other storage media. The selected storage medium is then set to an online status by adapter <highlight><bold>22</bold></highlight>, as depicted in block <highlight><bold>224</bold></highlight>. Finally, if there are remaining storage media to be updated, the process returns from block <highlight><bold>226</bold></highlight> to block <highlight><bold>202</bold></highlight>, where the process reenters the update loop. If there are no remaining storage media to be updated, the process ends, as shown in block <highlight><bold>228</bold></highlight>. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> One drawback to the method outlined by a preferred first embodiment of the present invention, as depicted in <cross-reference target="DRAWINGS">FIGS. 3A and 3B</cross-reference>, is the lack of redundancy in the system. If another storage medium (storage media <highlight><bold>1</bold></highlight> or <highlight><bold>3</bold></highlight>, as illustrated in <cross-reference target="DRAWINGS">FIG. 3B</cross-reference>) fails during the update of storage medium <highlight><bold>2</bold></highlight>, the entire storage media array <highlight><bold>23</bold></highlight> is taken off-line. The failed storage medium (storage media <highlight><bold>1</bold></highlight> or <highlight><bold>3</bold></highlight>) is repaired and then rebuilt utilizing data and parity data from the other two storage media. However, any modified data for storage medium <highlight><bold>2</bold></highlight> temporarily stored on the failed storage medium during the update are lost. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 4A, a</cross-reference> high-level logic flowchart depicting an exemplary method by which an adapter <highlight><bold>22</bold></highlight> services a request to access a storage media array according to a second embodiment of the present invention. Illustrated in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>B, there is depicted an exemplary RAID that stores data in stripes across four storage media. Included in storage media array <highlight><bold>23</bold></highlight> is a spare storage medium for storing data and write data requests during a selected storage medium update controlled by adapter <highlight><bold>22</bold></highlight>. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> As depicted, the method begins at block <highlight><bold>300</bold></highlight> and then continues to block <highlight><bold>302</bold></highlight>, which is illustrated as an update loop including blocks <highlight><bold>302</bold></highlight>, <highlight><bold>304</bold></highlight> and <highlight><bold>306</bold></highlight>. The update loop depicts the selection and update of a storage medium. During the execution of the update loop, an adapter processor <highlight><bold>104</bold></highlight>, implemented as an updating circuit, selects a storage medium to update out of a storage media array <highlight><bold>23</bold></highlight>, as shown in block <highlight><bold>302</bold></highlight>. In this example, according to <cross-reference target="DRAWINGS">FIG. 4</cross-reference>B, adapter <highlight><bold>22</bold></highlight> selects storage medium <highlight><bold>2</bold></highlight> for updating. As illustrated in block <highlight><bold>304</bold></highlight>, adapter processor <highlight><bold>104</bold></highlight> sets storage medium <highlight><bold>2</bold></highlight> to an off-line status, and begins relaying update data to storage medium <highlight><bold>2</bold></highlight>, as depicted in block <highlight><bold>306</bold></highlight>. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> The process then enters a request servicing loop that includes blocks <highlight><bold>308</bold></highlight>, <highlight><bold>310</bold></highlight>, <highlight><bold>312</bold></highlight>, <highlight><bold>313</bold></highlight>, <highlight><bold>314</bold></highlight>, <highlight><bold>316</bold></highlight>, <highlight><bold>318</bold></highlight> and <highlight><bold>320</bold></highlight>. The request servicing loop illustrates the process of providing a user with requested data that is located on a selected, inaccessible storage medium. The selected storage medium is inaccessible at this time because adapter <highlight><bold>22</bold></highlight> had been instructed by system processor <highlight><bold>12</bold></highlight> to perform an update on storage medium <highlight><bold>2</bold></highlight>. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> During the update of storage medium <highlight><bold>2</bold></highlight>, adapter <highlight><bold>22</bold></highlight> monitors for data requests to storage medium <highlight><bold>2</bold></highlight>, as shown in block <highlight><bold>308</bold></highlight>. For example, according to <cross-reference target="DRAWINGS">FIG. 4</cross-reference>B, if adapter <highlight><bold>22</bold></highlight> monitors a data request determined to be a data read request for data D<highlight><bold>1</bold></highlight> to storage medium <highlight><bold>2</bold></highlight>, as depicted in block <highlight><bold>310</bold></highlight>, the requested data D<highlight><bold>1</bold></highlight> is automatically reconstructed by XOR processor <highlight><bold>112</bold></highlight>, (or other request servicing circuit), from data D<highlight><bold>0</bold></highlight> and parity data P<highlight><bold>1</bold></highlight> stored in other storage media (e.g., storage media <highlight><bold>1</bold></highlight> and <highlight><bold>3</bold></highlight>) in the array, as shown in block <highlight><bold>312</bold></highlight>. The request servicing circuit provides the requested data to the requesting component, as depicted in block <highlight><bold>313</bold></highlight>. The process then returns from block <highlight><bold>313</bold></highlight> to block <highlight><bold>308</bold></highlight>. If the data request is not a data read request, the data request is assumed to be a data write request to storage medium <highlight><bold>2</bold></highlight>, as illustrated in block <highlight><bold>314</bold></highlight>. The data write request is logged within a NVRAM <highlight><bold>108</bold></highlight> and a spare storage medium <highlight><bold>4</bold></highlight>, as illustrated in block <highlight><bold>316</bold></highlight>. The actual data D<highlight><bold>1</bold></highlight> associated with the data write request is stored in the spare storage medium, as data D<highlight><bold>1</bold></highlight>&prime;, as depicted in block <highlight><bold>318</bold></highlight>. The process then returns to block <highlight><bold>308</bold></highlight> from block <highlight><bold>318</bold></highlight>. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> If adapter <highlight><bold>22</bold></highlight> does not receive a data request to the selected storage medium, the process moves to block <highlight><bold>320</bold></highlight>, which depicts a determination of whether or not the update to the selected storage medium is complete. If the update of storage medium <highlight><bold>2</bold></highlight> is complete, the process continues to block <highlight><bold>322</bold></highlight>, where each dirty stripe logged in NVRAM is rebuilt with data and parity data stored in the other storage media in the array and the new data stored in spare storage medium <highlight><bold>4</bold></highlight>; as illustrated, storage medium <highlight><bold>2</bold></highlight> is set to an online status by adapter <highlight><bold>22</bold></highlight>, as depicted in block <highlight><bold>324</bold></highlight>. Finally, if there are remaining storage media to be updated, the process returns from block <highlight><bold>326</bold></highlight> to block <highlight><bold>302</bold></highlight>, where the process reenters the update loop. If there are no remaining storage media to be updated, the process ends, as shown in block <highlight><bold>328</bold></highlight>. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> If the update of storage medium <highlight><bold>2</bold></highlight> is not complete, the process continues to block <highlight><bold>330</bold></highlight>, which illustrates adapter <highlight><bold>22</bold></highlight> checking if another storage medium of the array has failed. If another storage medium of the array has failed, storage media array <highlight><bold>23</bold></highlight> is set to off-line status by adapter <highlight><bold>22</bold></highlight>, as shown in block <highlight><bold>332</bold></highlight>. The update of storage medium <highlight><bold>2</bold></highlight> is completed, as depicted in block <highlight><bold>334</bold></highlight>, and storage medium <highlight><bold>2</bold></highlight> is rebuilt with data and parity data stored in other storage media, and new data stored in the spare storage medium <highlight><bold>4</bold></highlight>, as illustrated in block <highlight><bold>336</bold></highlight>. The process then continues to block <highlight><bold>324</bold></highlight>. If another storage medium of the array has not failed, the process returns from block <highlight><bold>330</bold></highlight> to block <highlight><bold>308</bold></highlight>. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> This second preferred embodiment of the present invention addresses the drawback of the first embodiment. As illustrated in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>B, spare storage medium <highlight><bold>4</bold></highlight> records the modified data to be transferred to storage medium <highlight><bold>2</bold></highlight> when the update is complete. Therefore, if one of the other storage media fails during the update of storage medium <highlight><bold>2</bold></highlight>, the modified data are preserved on spare storage medium <highlight><bold>4</bold></highlight>. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> As described above, an improved system and method of servicing a request to an array of storage media is presented. A data processing system, according to a preferred embodiment of the present invention includes a storage media array and an adapter to interface with the storage media array. If a data read request to a particular storage medium is received from a system processor, a request servicing circuit of the adapter reconstructs the request data from data and parity data stored on other storage media in the array. However, if a data write request to an unavailable storage medium is received from the system processor, the actual data related to the data write request are stored in a temporary memory location, and the data write request is logged in a non-volatile random access memory (NVRAM). There is no built-in data redundancy in a first preferred embodiment of the present invention; thus, modified data are lost in the event of the failure of another storage medium during the update of the selected storage medium. However, a second preferred embodiment of the present invention incorporates a spare storage medium that preserves the modified data if another storage medium fails. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> While the invention has been particularly shown and described with reference to a preferred embodiment, it will be understood by those skilled in the art that various changes in form and detail may be made therein without departing from the spirit and scope of the invention. For example, the data on a storage medium in a RAID utilizing the present invention may still be accessed by a user even if the storage medium is off-line due to required maintenance. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method of servicing a request to a redundant storage array including a plurality of storage media containing data and related parity data, said method comprising: 
<claim-text>receiving a data request for data stored by a selected storage medium among said plurality of storage media; and </claim-text>
<claim-text>in response to receiving said data request while an update to said selected storage medium is being performed, servicing said data request by reference to said data and said related parity data of other storage media among said plurality of storage media. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, said step of servicing further including: 
<claim-text>automatically reconstructing requested data utilizing said data and related parity data from said other storage media; and </claim-text>
<claim-text>outputting said reconstructed requested data. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, said step of automatically reconstructing further including: 
<claim-text>determining a type of said data request; and </claim-text>
<claim-text>automatically reconstructing requested data utilizing said data and said related parity data only in response to determining that said data request is a data read request. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference>, said step of determining further comprising: 
<claim-text>in response to determining that said data request is a data write request, logging said data write request; </claim-text>
<claim-text>storing new data for said data write request; </claim-text>
<claim-text>setting said particular storage medium to a rebuild status; </claim-text>
<claim-text>rebuilding said particular storage medium utilizing said data and related parity data from said other storage media; and </claim-text>
<claim-text>setting said particular storage medium to online status. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein said particular storage medium is a disk, and said redundant storage array is a redundant disk array and wherein: 
<claim-text>receiving a data request for data stored by a particular storage medium comprises receiving a data request for data stored by a particular disk of said redundant disk array. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. An adapter for use with a data processing system including a redundant storage array including a plurality of storage media containing data and related parity data, said adapter comprising: 
<claim-text>an updating circuit for receiving a data request for data stored by a selected storage medium among said plurality of storage media; and </claim-text>
<claim-text>a request servicing circuit, in response to receiving said data request while an update to said selected storage medium is being performed, for servicing said data request by reference to said data and said related parity data of other storage media among said plurality of storage media. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The adapter according to <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference>, wherein said updating circuit is an adapter a processor. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The adapter according to <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference>, wherein said request servicing circuit is an exclusive-OR (XOR) processor for automatically reconstructing requested data utilizing data and related parity data from other storage media during said updating, in response to a data request by said system processor, said XOR processor coupled to an adapter processor. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The adapter according to <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference>, further including: 
<claim-text>a non-volatile random access memory (NVRAM) for logging data write requests. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The adapter according to <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference>, further comprising: 
<claim-text>a storage location for temporarily storing write data for said selected storage media during said updating. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The adapter according to <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein said storage location is an adapter cache. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The adapter according to <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, wherein said adapter cache further includes: 
<claim-text>a battery-backup circuit, for preserving data stored on said adapter cache. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The adapter according the <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference>, wherein said data request is a data read request. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. A disk system comprising: 
<claim-text>an adapter according to claim <highlight><bold>6</bold></highlight>; and </claim-text>
<claim-text>a redundant storage array. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The adapter according to <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference>, wherein said redundant storage array is a redundant array of inexpensive disks (RAID). </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. A data processing system, comprising: 
<claim-text>a system processor; </claim-text>
<claim-text>a system memory coupled to said system processor; </claim-text>
<claim-text>a redundant storage array; and </claim-text>
<claim-text>an adapter including a redundant storage array including a plurality of storage media containing data and related parity data, said adapter further including: 
<claim-text>an updating circuit for receiving a data request for data stored by a selected storage medium among said plurality of storage media; and </claim-text>
<claim-text>a request servicing circuit, in response to receiving said data request while an update to said selected storage medium is being performed, for servicing said data request by reference to said data and said related parity data of other storage media among said plurality of storage media. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The data processing system according to <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, wherein said redundant storage array is a redundant array of inexpensive disks (RAID). </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The data processing system according to <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, wherein said redundant storage array stores data in stripes, wherein each said stripe further includes data and related parity data. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The data processing system according to <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, wherein said updating circuit is an adapter processor. </claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The data processing system according to <dependent-claim-reference depends_on="CLM-00011">claim 18</dependent-claim-reference>, wherein said request servicing circuit is an exclusive-OR (XOR) processor for automatically reconstructing requested data utilizing said data said related parity data from other storage media during said updating, in response to a data request by said system processor, said XOR processor coupled to said adapter processor. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The data processing system according to <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, wherein said adapter further comprising: 
<claim-text>a non-volatile random access memory (NVRAM) for logging all data write requests and data read-with-intent-to-write requests. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The data processing system according to <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, further including: 
<claim-text>a storage location for temporarily storing all write data for said selected storage media during said updating. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The data processing system according to <dependent-claim-reference depends_on="CLM-00022">claim 22</dependent-claim-reference>, wherein said storage location is a temporary space on other storage media of said redundant storage array. </claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The data processing system according to <dependent-claim-reference depends_on="CLM-00022">claim 22</dependent-claim-reference>, wherein said storage location is an adapter cache. </claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. The data processing system according to <dependent-claim-reference depends_on="CLM-00022">claim 24</dependent-claim-reference>, wherein said adapter further includes a battery backup circuit. </claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. A computer program product comprising: 
<claim-text>a computer-readable medium; </claim-text>
<claim-text>updating code encoded within said computer-readable medium for receiving a data request for data stored by a selected storage medium among a plurality of storage media; and </claim-text>
<claim-text>request servicing code encoded within said computer-readable medium, in response to receiving said data request while an update to said selected storage medium is being performed, for servicing said data request by reference to data and related parity data of other storage media among said plurality of storage media.</claim-text>
</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>2</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005354A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005354A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005354A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005354A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005354A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005354A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
