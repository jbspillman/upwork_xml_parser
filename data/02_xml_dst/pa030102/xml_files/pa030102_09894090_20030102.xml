<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030004945A1-20030102-D00000.TIF SYSTEM "US20030004945A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030004945A1-20030102-D00001.TIF SYSTEM "US20030004945A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030004945A1-20030102-D00002.TIF SYSTEM "US20030004945A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030004945A1-20030102-D00003.TIF SYSTEM "US20030004945A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030004945A1-20030102-D00004.TIF SYSTEM "US20030004945A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030004945A1-20030102-D00005.TIF SYSTEM "US20030004945A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030004945A1-20030102-D00006.TIF SYSTEM "US20030004945A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030004945A1-20030102-D00007.TIF SYSTEM "US20030004945A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030004945A1-20030102-D00008.TIF SYSTEM "US20030004945A1-20030102-D00008.TIF" NDATA TIF>
<!ENTITY US20030004945A1-20030102-D00009.TIF SYSTEM "US20030004945A1-20030102-D00009.TIF" NDATA TIF>
<!ENTITY US20030004945A1-20030102-D00010.TIF SYSTEM "US20030004945A1-20030102-D00010.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030004945</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09894090</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010628</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F007/00</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>707</class>
<subclass>008000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>System and method for avoiding deadlock situations due to pseudo-deleted entries</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>James</given-name>
<middle-name>Zu-Chia</middle-name>
<family-name>Teng</family-name>
</name>
<residence>
<residence-us>
<city>San Jose</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Namik</given-name>
<family-name>Hrle</family-name>
</name>
<residence>
<residence-non-us>
<city>Boeblingen</city>
<country-code>DE</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<assignee>
<organization-name>International Business Machines Corporation</organization-name>
<assignee-type>02</assignee-type>
</assignee>
<correspondence-address>
<name-1>Michael E. Hudzinski</name-1>
<name-2>FAY, SHARPE, FAGAN, MINNICH &amp; McKEE, LLP</name-2>
<address>
<address-1>Seventh Floor</address-1>
<address-2>1100 Superior Avenue</address-2>
<city>Cleveland</city>
<state>OH</state>
<postalcode>44110-2518</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">In a database management system (DBMS) (<highlight><bold>60</bold></highlight>) for a database application (<highlight><bold>10</bold></highlight>) including a database (<highlight><bold>12</bold></highlight>) having a table (<highlight><bold>14, 16, 18</bold></highlight>) and a unique key index (<highlight><bold>42</bold></highlight>) having indexes (<highlight><bold>44, 46, 48</bold></highlight>) therefor, the DBMS (<highlight><bold>60</bold></highlight>) includes a data manager (<highlight><bold>64</bold></highlight>), an index manager (<highlight><bold>66</bold></highlight>), a transaction manager (<highlight><bold>62</bold></highlight>), and a lock manager (<highlight><bold>68</bold></highlight>) which restricts access to the table by assigning locks to elements thereof. In order to avoid deadlock in the database application due to the pseudo-deleted entries, the lock categories include an X-lock and a Conditional S-lock, and have lock attributes including at least a Delete attribute for the X-lock. The Conditional S-lock is compatible (granted by the lock manager) with an X-lock whose Delete attribute is NOT SET, but is not compatible (granted) with an X-lock whose Delete attribute is SET. Each index entry includes a pseudo-delete flag which is SET by the index manager (<highlight><bold>66</bold></highlight>) to indicate deletion of the indexed row. Conditional upon locating a pseudo-deleted index key corresponding to a key to be added to the index, the index manager (<highlight><bold>66</bold></highlight>) requests a Conditional S-lock on the row indexed thereby, whereby the index manager (<highlight><bold>66</bold></highlight>) verifies the Delete transaction which set the pseudo-delete flag has committed. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> The present invention relates to the management of computer databases, and more particularly to a method for avoiding deadlock situations during index updates in a database application which uses a unique key index and the pseudo-deletion of index entries. </paragraph>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> Database applications are an important use of modem computer systems, and especially modem networked computer systems. Among other uses, computer databases store business data such as inventories, sales information, personnel information, and the like. One advantage of implementing a database on a networked computer system is to provide the ability for multiple users, often at multiple locations or access points, to work essentially simultaneously with a single shared database. For example, a retail store chain may use a single shared database which is accessed by the various individual store outlets. A first store may add newly acquired merchandise to the inventory table of a shared database. The inventory table is accessible to all the stores in the chain, and a second store in the chain may advantageously search the inventory table, locate the merchandise being held at the first store, and request a reallocation of some portion of this merchandise to the second store if sales information, perhaps recorded in a sales table of the same shared database, indicates that the merchandise may be more effectively retailed at the second store. Thus, the shared and networked database permits more efficient allocation and use of the shared resources of the retail store chain. Of course, similar benefits arise from the use of networked databases in conjunction with other types of distributed businesses, as well as in conjunction with geographically distributed organizations such as religious and political organizations. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> With reference to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, an exemplary database application <highlight><bold>10</bold></highlight> for management of a sporting goods retail organization is schematically shown in simplified form. A database <highlight><bold>12</bold></highlight> includes a plurality of table objects, namely an inventory table <highlight><bold>14</bold></highlight>, a sales table <highlight><bold>16</bold></highlight>, and a human resources table <highlight><bold>18</bold></highlight>. Each table contains a specific number of columns and some unordered rows, as shown for example in a more detailed schematic of the inventory table <highlight><bold>14</bold></highlight>&prime;. The detailed schematic of the inventory table <highlight><bold>14</bold></highlight>&prime; shows that it includes four data columns, namely a store (&ldquo;Store&rdquo;) column <highlight><bold>22</bold></highlight>, an item (&ldquo;Item&rdquo;) column <highlight><bold>24</bold></highlight>, a model (&ldquo;Model&rdquo;) column <highlight><bold>26</bold></highlight>, and a quantity (&ldquo;Qty&rdquo;) column <highlight><bold>28</bold></highlight>. Of course, other columns may be included such as a product manufacturer column, and the number and type of columns is typically different for each table object. The number and identity of columns in a table defines the structure of that table, and is not generally modifiable by ordinary database users, although a database administrator or other individual with high-level access privileges may be able to modify the table structure. Similarly, the number and identity of the tables are normally fixed for ordinary users, and are modifiable only by users with special access privileges. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> The data in each table typically consists of unordered rows formed according to the table column structure. Each row is indexed by a record index (RID) <highlight><bold>30</bold></highlight> as illustrated in the detailed schematic of the inventory table <highlight><bold>14</bold></highlight>&prime;. The rows are not typically arranged in any particular order. For example, in the exemplary inventory table <highlight><bold>14</bold></highlight>&prime; a blank row <highlight><bold>40</bold></highlight> with RID &equals;<highlight><bold>0014</bold></highlight> is interspersed among the rows containing data. Blank row <highlight><bold>40</bold></highlight> may have resulted from a deleted record at the record index RID&equals;0014. Users with ordinary access privileges typically have the ability to add, delete, or change rows of a table, typically within suitable predefined bounds. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> To provide organization of the database, a unique key index <highlight><bold>42</bold></highlight> is maintained, with separate indexes for each table. Thus, the unique key index <highlight><bold>42</bold></highlight> includes an inventory table index <highlight><bold>44</bold></highlight>, a sales table index <highlight><bold>46</bold></highlight>, and a human resources table index <highlight><bold>48</bold></highlight>. Each table index contains a specific number of columns and some rows, as shown for example in a more detailed schematic of the inventory table index <highlight><bold>44</bold></highlight>&prime;. The detailed schematic of the inventory table index <highlight><bold>44</bold></highlight>&prime; shows that it includes three columns, namely a store (&ldquo;Store&rdquo;) column <highlight><bold>52</bold></highlight>, a model (&ldquo;Model&rdquo;) column <highlight><bold>54</bold></highlight>, and a record index (&ldquo;RID&rdquo;) column <highlight><bold>56</bold></highlight>. In the example, each row of the inventory table index <highlight><bold>44</bold></highlight>&prime; corresponds to a row of the inventory table <highlight><bold>14</bold></highlight>&prime; but contains only the store and model information of that row, as well as the table row RID. Thus, the inventory table index <highlight><bold>44</bold></highlight> indexes the inventory table <highlight><bold>14</bold></highlight> using the store <highlight><bold>22</bold></highlight> and the model <highlight><bold>26</bold></highlight> columns of the inventory table <highlight><bold>14</bold></highlight>, and the table row RID serves as the pointer to the table row. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> The ordered column combination: (store <highlight><bold>22</bold></highlight>, model <highlight><bold>26</bold></highlight>) is often called the index key. To be considered a unique index key, the number and type of table columns defining the key must guarantee that each index row identifies a unique table row. Thus, inventory table index <highlight><bold>44</bold></highlight> could not use as an index key the ordered column combination: (store <highlight><bold>22</bold></highlight>, item <highlight><bold>24</bold></highlight>), as this is not a unique key (e.g., RID&equals;0012 and RID&equals;0015 both include store&equals;East and item&equals;skis). Of course, an index key is not limited to two columns, but may include as few or as many columns as is necessary to define a unique key. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> An important component of a database application, and particularly of a networked database application, is the database management system (DBMS) <highlight><bold>60</bold></highlight>. The DBMS controls the storage, retrieval, and modification of data in the database, ensures that retrieved data is current, and that data modifications do not compromise the integrity of the database. For example, the DBMS ensures that the unique key rule described above is obeyed whenever a table index is modified. For instance, the DBMS prevents entry of a new record in inventory table <highlight><bold>14</bold></highlight> at RID&equals;0014 with a store value of &ldquo;West&rdquo; and a model value of &ldquo;XS500&rdquo;, as this entry would conflict with the record at RID&equals;0010 which already has this key value. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> In the exemplary schematic of <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, the DBMS <highlight><bold>60</bold></highlight> includes four components: a transaction manager <highlight><bold>62</bold></highlight>, a data manager <highlight><bold>64</bold></highlight>, an index manager <highlight><bold>66</bold></highlight>, and a lock manager <highlight><bold>68</bold></highlight>. It is to be appreciated that the illustrated DBMS <highlight><bold>60</bold></highlight> is exemplary and highly simplified in contrast to an actual DBMS used with a commercial database. Commercial database DBMS may include additional components, such as components to store and manage the database history, to produce printed reports, and the like. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> In operation, the transaction manager <highlight><bold>62</bold></highlight> receives transaction requests. The transaction manager <highlight><bold>62</bold></highlight> assigns an identifier to the transaction, monitors the progress of each transaction, and is responsible for transaction completion, or for transaction failure recovery in the event that the transaction cannot be completed successfully. Typical transactions of particular interest herein include delete transactions and insert transactions, whereby records are deleted or inserted into a table object. However, it is to be appreciated that transactions may be more complex and may include composite transactions with multiple delete and/or insert elements, as well as record modification operations and the like. Single transactions can also interact with multiple table objects. For example, a transaction which records a sale by the South store of one model MD <highlight><bold>100</bold></highlight> ski would typically include updating of at least the sales table <highlight><bold>16</bold></highlight>, wherein the sale is recorded, and the inventory table <highlight><bold>14</bold></highlight>. The inventory table <highlight><bold>14</bold></highlight>&prime; update reduces the quantity column <highlight><bold>28</bold></highlight> value of row RID&equals;0013 from &ldquo;40&rdquo; to &ldquo;39&rdquo; to reflect the inventory reduction at the South store resulting from the sale of one model MD100 ski. The transaction manager <highlight><bold>62</bold></highlight> communicates with both the data manager <highlight><bold>64</bold></highlight> and the index manager <highlight><bold>66</bold></highlight>, which control modification of the database <highlight><bold>12</bold></highlight> and the unique key index <highlight><bold>42</bold></highlight>, respectively. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> The simplified DBMS <highlight><bold>60</bold></highlight> also includes a lock manager <highlight><bold>68</bold></highlight>. The lock manager <highlight><bold>68</bold></highlight> limits access to the database <highlight><bold>12</bold></highlight> by requiring that DBMS components obtain a lock on the target row or rows prior to accessing said rows. Lock types which are available include at least exclusive locks&mdash;&ldquo;X-locks&rdquo; and shared locks&mdash;&ldquo;S-locks&rdquo;. These locks may be placed on rows, tables, or other database elements depending upon the DBMS configuration. Typically, X-locks are granted to transactions which modify a row or rows (including insert and delete operations), gain access to the target tables through the lock manager <highlight><bold>68</bold></highlight> using an exclusive lock (&ldquo;X-lock&rdquo;) request. Transactions which only read the contents of a row or rows without modifying the contents gain access to the data using shared lock (&ldquo;S-lock&rdquo;) requests. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> The lock manager <highlight><bold>68</bold></highlight> ensures the integrity of the database <highlight><bold>12</bold></highlight> by issuing locks based upon lock compatibility to prevent multiple transactions from accessing the data simultaneously. For example, the lock manager will not grant more than one X-lock request for a single table row because concurrent X-locks on the same row could result in data inconsistencies as different data is written by the different transactions holding the X-locks. Thus, relative to table rows an X-lock is incompatible with another X-lock, so that after a first X-lock is placed on a first row, the lock manager denies requests for subsequent X-locks to that first row until the first X-lock is removed. However, two or more transaction requesting S-locks are typically compatible, as no inconsistency will result from two different processes that merely read a single record essentially simultaneously without modifying the record. The lock manager therefore typically grants a second S-lock to a row which already has one S-lock applied. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> The prior art teaches the use of lock managers to ensure the integrity of the database data. Concurrent transactions are prevented from corrupting the data through the issuance of locks based upon lock compatibility. However, prior art methods fail to prevent certain &ldquo;deadlock&rdquo; situations which may arise when essentially simultaneous transactions compete for lock request control over the same rows. In these cases, two different transactions may attempt to place locks on the same table rows, and the resulting interference results in both transactions competing for the data being suspended indefinitely causing a system deadlock. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> There is a need, therefore, to provide an improved database management system and method which overcomes these deadlock limitations. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> The present invention is typically implemented using one or more computer programs, each of which executes under the control of an operating system, such as OS/2, Windows, DOS, AIX, UNIX, MVS, etc., and causes a computer to perform the desired functions as described herein. Thus, using the present specification, the invention may be implemented as a machine, process, or article of manufacture by using standard programming and/or engineering techniques to produce software, firmware, hardware or any combination thereof. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> Generally, the computer programs and/or operating system are all tangibly embodied in a computer-readable device or media, such as memory, data storage devices, and/or data communications devices, thereby making a computer program product or article of manufacture according to the invention. As such, the terms &ldquo;article of manufacture&rdquo; and &ldquo;computer product&rdquo; as used herein are intended to encompass a computer program accessible from any computer readable device or media. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> Moreover, the computer programs and operating system are comprised of instructions which, when read and executed by a computer, cause the computer to perform the steps necessary to implement and/or use the present invention. Under control of the operating system, the computer programs may be loaded from the memory, data storage devices, and/or data communications devices into the memories of the computer for use during actual operations. Those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope of the present invention. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> In accordance with one aspect of the present invention, a database management system (DBMS) for managing a database application is disclosed. The database application includes a database having at least one table, and an index having at least one unique key table index corresponding to the at least one table. A data manager manages updates of the database. An index manager manages updates of the unique key table index. A transaction manager executes database transactions in cooperation with the index manager. A lock manager cooperates with the index manager and the data manager to restrict access to a first table element by assigning one or more locks thereto. These locks are selected from a plurality of lock types, including at least an exclusive X-lock that enables exclusive access, and an unconditional S-lock that enables shared access and is selectively assigned to a table element conditional upon the table element being without an X-lock assigned thereto. The lock types also have attributes associated therewith. The categories of said attributes include at least a Delete attribute indicative of a transaction holding the X-lock being a delete transaction. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> Preferably, the plurality of lock types further includes a Conditional S-lock that enables shared access and is assigned to a table element conditional upon the table element having no X-lock whose Delete attribute is &ldquo;SET&rdquo; or &ldquo;ON&rdquo; assigned thereto. Preferably, the associated unique key table index further includes a pseudo-delete flag corresponding to each key entry that is selectively set by the index manager to indicate deletion of the table row corresponding to the index key entry. The index manager is preferably adapted to execute a predefined set of steps conditional upon receiving a request to enter an index key entry and a corresponding new row RID in which the index key entry corresponds to an existing index key entry whose pseudo-delete flag is &ldquo;SET&rdquo; or &ldquo;ON&rdquo;. The set of steps include requesting a Conditional S-lock on the table row corresponding to the existing index key entry; and, conditional upon the Conditional S-lock being granted, updating the table index key entry with the new row RID, releasing the Conditional S-lock and resetting the pseudo-delete flag. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> Preferably, the index manager is further adapted execute an additional predefined set of steps conditional upon receiving a request to enter an index key entry and a corresponding new row RID in which the index key entry corresponds to an existing index key entry whose pseudo-delete flag is &ldquo;SET&rdquo; or &ldquo;ON&rdquo;. When the Conditional S-lock is denied, requesting an unconditional S-lock on the table row corresponding to the existing index key entry; and, upon granting of the unconditional S-lock, updating the table index key entry with the new row RID, releasing the unconditional S-lock and resetting the pseudo-delete flag. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> Preferably, the index manager is still further adapted to execute steps conditional upon receiving a request to enter an index key entry and a corresponding new row RID in which the index key entry corresponds to an existing index key entry whose pseudo-delete flag is not &ldquo;SET&rdquo;, &ldquo;RESET&rdquo;, or OFF&rdquo;. The steps include requesting an unconditional S-lock on the table row corresponding to the existing index key entry; and, upon granting of the unconditional S-lock, conditional upon the index key entry having its pseudo-delete flag &ldquo;SET&rdquo; or &ldquo;ON&rdquo;, updating the table index key entry with the new row RID, releasing the unconditional S-lock and resetting the pseudo-delete flag. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> In accordance with another aspect of the present invention, a database management method is disclosed for entering a key and a new row RID into a unique key table index of a database application that uses pseudo-deletion of table index entries. The unique key table index is searched for the key. Conditional upon locating a pseudo-deleted table index entry corresponding to the key during the searching step, a Conditional S-lock is requested on a table row indexed by the pseudo-deleted table index entry, and, conditional upon receiving an indication that the Conditional S-lock is granted, the table index entry is updated with the new row RID and resetting the pseudo-delete flag. Conditional upon not locating a table index entry corresponding to the key during the searching step, the table index is updated by adding the key and the new row RID. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> Preferably, the step of receiving an indication that the Conditional S-lock is granted includes the steps of: granting the Conditional S-lock conditional upon the table row indexed by the pseudo-deleted table index entry not having an X-lock assigned thereto; granting the Conditional S-lock conditional upon the table row indexed by the pseudo-deleted table index entry having an X-lock assigned thereto wherein said X-lock has a Delete attribute that is not set, reset, or off; and receiving an indication that the Conditional S-lock is granted conditional upon the granting of the Conditional S-lock. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> Preferably, the method further includes the steps, to be executed conditional upon receiving an indication that the Conditional S-lock is denied, of: requesting an unconditional S-lock on the table row indexed by the pseudo-deleted table index entry; and conditional upon receiving an indication that the unconditional S-lock is granted, updating the table index entry with the new row RID and resetting the pseudo-delete flag. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> The method preferably further including the steps, to be executed conditional upon locating a table index entry that is not pseudo-deleted during the searching step, of: requesting an unconditional S-lock on the table row indexed by the located table index entry; and, upon granting of the unconditional S-lock and conditional upon the located table index entry being pseudo-deleted, updating the table index entry with the new row RID and resetting the pseudo-delete flag. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> In accordance with yet another aspect of the present invention, an article of manufacture is disclosed, comprising a program storage medium readable by a computer and embodying one or more instructions executable by the computer to perform method steps for entering a key and a new row RID into a unique key table index of a database stored on a data store connected to the computer. The unique key table index is one which uses pseudo-deletion of table index entries. The performed method steps are as follows. The unique key table index is searched for the key. Conditional upon locating a pseudo-deleted table index entry corresponding to the key during the searching step, a Conditional S-lock is requested on a table row indexed by the pseudo-deleted table index entry, and, conditional upon receiving an indication that the Conditional S-lock is granted, the table index entry is updated with the new row RID and resetting the pseudo-delete flag. Conditional upon not locating a table index entry corresponding to the key during the searching step, the table index is updated by adding the key and the new row RID. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> Preferably, the step of receiving an indication that the Conditional S-lock is granted includes the steps of: granting the Conditional S-lock conditional upon the table row indexed by the pseudo-deleted table index entry not having an X-lock assigned thereto; granting the Conditional S-lock conditional upon the table row indexed by the pseudo-deleted table index entry having an X-lock assigned thereto wherein said X-lock has a Delete attribute that is not set, reset, or off; and receiving an indication that the Conditional S-lock is granted conditional upon the granting of the Conditional S-lock. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> Preferably, the method further includes the steps, to be executed conditional upon receiving an indication that the Conditional S-lock is denied, of: requesting an unconditional S-lock on the table row indexed by the pseudo-deleted table index entry; and conditional upon receiving an indication that the unconditional S-lock is granted, updating the table index entry with the new row RID and resetting the pseudo-delete flag. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> The method preferably further including the steps, to be executed conditional upon locating a table index entry that is not pseudo-deleted during the searching step, of: requesting an unconditional S-lock on the table row indexed by the located table index entry; and, upon granting of the unconditional S-lock and conditional upon the located table index entry being pseudo-deleted, updating the table index entry with the new row RID and resetting the pseudo-delete flag. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> One advantage of the present invention is that it prevents deadlock situations when essentially simultaneous transactions request incompatible locks on the same row or rows. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> Another advantage of the present invention is that it overcomes prior art limitations which arise from the use of pseudo-deleted index entries. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> Another advantage of the present invention is that it increases database efficiency by preventing deadlocks and corresponding time-outs. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> Still another advantage of the present invention is that it improves the efficiency and reliability of the index manager by providing an improved method and DBMS for updating the index in the presence of pseudo-deleted index entries. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> Still further advantages and benefits of the present invention will become apparent to those of ordinary skill in the art upon reading and understanding the following detailed description. </paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> The invention may take form in various components and arrangements of components, and in various steps and arrangements of steps. The drawings are only for the purposes of illustrating preferred embodiments and are not to be construed as limiting the invention. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a simplified schematic diagram of a database management system; </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> FIGS. <highlight><bold>2</bold></highlight>(A)-<highlight><bold>2</bold></highlight>(F) are a sequence of database tables to show a prior art database management method for deleting and inserting entries in a database table; </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> FIGS. <highlight><bold>3</bold></highlight>(A)-<highlight><bold>3</bold></highlight>(F) are a sequence of database tables to show a condition where the prior art database management method enters into a deadlock state; </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> FIGS. <highlight><bold>4</bold></highlight>(A)-<highlight><bold>4</bold></highlight>(F) are a sequence of database tables to show the same underlying data transaction sequence as FIGS. <highlight><bold>2</bold></highlight>(A)-<highlight><bold>2</bold></highlight>(F), but executed using a database management system and method in accordance with the present invention to avoid the deadlock state; </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> FIGS. <highlight><bold>5</bold></highlight>(A)-<highlight><bold>5</bold></highlight>(H) are a sequence of database tables to show the same underlying data transaction sequence as <cross-reference target="DRAWINGS">FIG. 3</cross-reference>, but executed using a database management system and method in accordance with the present invention, whereby the deadlock situation of <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is avoided; and </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> shows the preferred method by which the subject DBMS index manager processes index updates and index additions in accordance with the invention. </paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS </heading>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> The present invention improves prior art DBMS by overcoming a potential deadlock situation between two or more transactions. With particular reference to FIGS. <highlight><bold>2</bold></highlight>A-<highlight><bold>2</bold></highlight>F and <highlight><bold>3</bold></highlight>A-<highlight><bold>3</bold></highlight>F, the limitations of prior art DBMS will be shown. Subsequently, and with particular reference to FIGS. <highlight><bold>4</bold></highlight>A-<highlight><bold>4</bold></highlight>F and <highlight><bold>5</bold></highlight>A-<highlight><bold>5</bold></highlight>H, the improved DBMS will be described and shown to overcome the limitations of prior art DBMS. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 2</cross-reference>(A)-<highlight><bold>2</bold></highlight>(F), a simplified typical transaction sequence according to a prior art DBMS will be described to illustrate lock manager protection of data integrity. <cross-reference target="DRAWINGS">FIG. 2</cross-reference>(A) shows the initial state of the relevant portion of a data table <highlight><bold>200</bold></highlight> and its associated index table <highlight><bold>202</bold></highlight>, as well as an associated lock table <highlight><bold>204</bold></highlight>. The index table <highlight><bold>202</bold></highlight> is a unique key table that operates on a unique key (C1,C2). As seen in lock table <highlight><bold>204</bold></highlight>, at least information on the row identification (&ldquo;RID&rdquo;), the lock type (&ldquo;Lock&rdquo;), lock attributes (&ldquo;Attributes&rdquo;), and the transaction holding the lock (&ldquo;Transaction&rdquo;) are recorded therein. In <cross-reference target="DRAWINGS">FIG. 2</cross-reference>(A), however, no locks are yet assigned. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> With reference to <cross-reference target="DRAWINGS">FIG. 2</cross-reference>(B) and with continuing reference to <cross-reference target="DRAWINGS">FIG. 1, a</cross-reference> delete transaction is initiated by the transaction manager <highlight><bold>62</bold></highlight>. The delete transaction of the example instructs deletion of all rows for which C1&equals;A. It will be observed that rows RID&equals;000201 and RID&equals;000202 meet this criterion. As shown in the data table <highlight><bold>200</bold></highlight>, X-locks <highlight><bold>210</bold></highlight> are placed on rows RID&equals;000201 and RID&equals;000202 by the lock manager <highlight><bold>68</bold></highlight>, and corresponding information is written into the lock table <highlight><bold>204</bold></highlight>. Also, the index table <highlight><bold>202</bold></highlight> is updated by the index manager <highlight><bold>66</bold></highlight> to include an indication that the rows RID&equals;000201 and RID&equals;000202 are to be deleted, as indicated by a delete (&ldquo;D&rdquo;) flag <highlight><bold>212</bold></highlight> marking those index entries. Although the Delete C1&equals;A transaction has been initiated at the time shown in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>(B), it is not yet fully implemented, or &ldquo;committed&rdquo;. Therefore, the information contained in rows RID&equals;000201 and RID&equals;000202 has not yet been actually removed but only marked for removal. Such a delay between transaction initiation and the committing thereof is a common occurrence in typical DBMS&apos;s. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> The situation of <cross-reference target="DRAWINGS">FIG. 2</cross-reference>(B) may evolve, for example, if the &ldquo;Delete C1&equals;A&rdquo; transaction is an element of a composite transaction which also includes other transaction elements (not shown). In that case, an inability to carry out one or more other elements of the composite transaction would necessitate cancellation of the composite transaction including the Delete C1&equals;A element. In a composite transaction, therefore, all transaction elements are typically committed only after every element has obtained the necessary locks, so that successful completion of the entire transaction is assured before the composite transaction elements are committed. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 2</cross-reference>(C) and with continuing reference to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, the Delete C1&equals;A transaction remains uncommitted, while a second, typically unrelated transaction is initiated. By way of example, the second transaction is an Insert transaction. The transaction manager <highlight><bold>62</bold></highlight> via the data manager <highlight><bold>64</bold></highlight> obtains an X-lock <highlight><bold>220</bold></highlight> on row RID&equals;000204 of the data table <highlight><bold>200</bold></highlight> via the lock manager <highlight><bold>68</bold></highlight>, and inserts the data <highlight><bold>222</bold></highlight> into data table <highlight><bold>200</bold></highlight> via the data manager <highlight><bold>64</bold></highlight>. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 2</cross-reference>(D) and with continuing reference to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, the index manager <highlight><bold>66</bold></highlight> next attempts to update the index table <highlight><bold>202</bold></highlight> to reflect the inserted row <highlight><bold>222</bold></highlight>. The index manager <highlight><bold>66</bold></highlight> locates an entry with key C1,C2&equals;A,1 already in the index table <highlight><bold>202</bold></highlight> which points to data table row RID&equals;000201. However, this index entry is flagged for deletion <highlight><bold>212</bold></highlight>, i.e. it is pseudo-deleted. After the Delete C1&equals;A transaction has committed, the key C1,C2&equals;A,1 becomes available and the index manager <highlight><bold>66</bold></highlight> is free to update the index from RID&equals;000201 to RID&equals;000204. In typical database applications, the index entries corresponding to items which have been deleted (Delete transaction initiated and committed) remain in the index, flagged as pseudo-deleted, rather than being actually removed from the table index. Preserving pseudo-deleted index entries across commits has major performance benefits, as is well-known to those skilled in the art. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> The index manager therefore checks whether the deletion of row RID&equals;000201 has been committed by requesting a shared S-lock through the lock manager <highlight><bold>68</bold></highlight>. Because an S-lock is incompatible with an X-lock, the lock manager queues the S-lock request <highlight><bold>224</bold></highlight>. This action suspends the Insert transaction, thereby preserving data integrity by ensuring that the unique key rule that governs the unique key index <highlight><bold>202</bold></highlight> is obeyed. The incompatibility between an S-lock and an X-lock reflects uncertainty in the integrity of the information retrieved by the transaction requesting the S-lock in the presence of an X-lock belonging to an uncommitted transaction. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 2</cross-reference>(E) and with continuing reference to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, the Delete C1&equals;A transaction next commits. The data is deleted <highlight><bold>226</bold></highlight>, and the queued S-lock <highlight><bold>224</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 2</cross-reference>(D)) is granted, indicating that the exclusive X-locks held by the Delete C1&equals;A transaction have been released. After the shared S-lock <highlight><bold>224</bold></highlight> requested by the Insert transaction is granted, the index manager <highlight><bold>66</bold></highlight> replaces the row RID&equals;000201 in the unique key index table <highlight><bold>202</bold></highlight> with the row value RID&equals;000204 228 and resets the pseudo-delete flag <highlight><bold>230</bold></highlight>. The lock information in connection with the Insert transaction related to row RID&equals;000204 remains in the lock table <highlight><bold>204</bold></highlight>. It is to be appreciated that the index entries of the deleted items at row RID&equals;000202 remain only pseudo-deleted, i.e. flagged as deleted <highlight><bold>212</bold></highlight>, but remain in the unique key index table <highlight><bold>202</bold></highlight>. Such pseudo-deletion of index entries corresponding to deleted rows wherein the deleting has committed has major performance benefits, as is well-known to those skilled in the art and as was mentioned above. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 2</cross-reference>(F) and with continuing reference to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, the Insert transaction is shown committed and the X-lock on row RID&equals;000204 released. It will be appreciated from the operations depicted in FIGS. <highlight><bold>2</bold></highlight>(A)-<highlight><bold>2</bold></highlight>(F) that the lock manager has successfully prevented a potential compromise of data integrity by preventing the index manager from performing the index update of <cross-reference target="DRAWINGS">FIG. 2</cross-reference>(F) before the previous delete transaction commits and removes its X-lock from row RID&equals;<highlight><bold>000201</bold></highlight>. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> The prior art DBMS is seen to perform properly in the transaction sequence of FIGS. <highlight><bold>2</bold></highlight>(A)-<highlight><bold>2</bold></highlight>(F). With reference now to <cross-reference target="DRAWINGS">FIG. 3</cross-reference>(A)-<highlight><bold>3</bold></highlight>(F), however, a second transaction sequence according to the prior art DBMS will be described, to illustrate formation of a deadlock situation. <cross-reference target="DRAWINGS">FIG. 3</cross-reference>(A) shows the relevant portions of an initial data table <highlight><bold>300</bold></highlight> with four rows of data, an index table <highlight><bold>302</bold></highlight> corresponding thereto, and a lock table <highlight><bold>304</bold></highlight>. There are no locks depicted in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>(A). </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> With reference to <cross-reference target="DRAWINGS">FIG. 3</cross-reference>(B) and with continuing reference to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, two essentially simultaneous Delete transactions T1 and T2 are initiated. Transaction T1 instructs deletion of rows with C1&equals;A, and transaction T2 instructs deletion of rows with C1&equals;B. As all rows shown have C1&equals;A or C1&equals;B, the transaction manager <highlight><bold>62</bold></highlight> requests, via the data manager <highlight><bold>64</bold></highlight>, that X-locks <highlight><bold>310</bold></highlight> be placed on all four rows. The lock manager <highlight><bold>68</bold></highlight> grants the X-locks, and the X-lock parameters are recorded in the lock table <highlight><bold>304</bold></highlight> as shown. Additionally, the corresponding index entries are flagged as deleted <highlight><bold>312</bold></highlight> by the index manager <highlight><bold>66</bold></highlight>. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> With reference to <cross-reference target="DRAWINGS">FIG. 3</cross-reference>(C) and with continuing reference to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, delete transactions T1 and T2 commit. The data is deleted <highlight><bold>314</bold></highlight> from the data table <highlight><bold>300</bold></highlight> and the locks <highlight><bold>310</bold></highlight> are removed. Importantly, however, the index entries flagged for deletion <highlight><bold>312</bold></highlight> remain in the unique key index table <highlight><bold>302</bold></highlight>. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 3</cross-reference>(D) and with continuing reference to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, two new transactions T3 and T4 are initiated by the transaction manager <highlight><bold>62</bold></highlight> before the index entries flagged for deletion <highlight><bold>312</bold></highlight> are removed from the index table <highlight><bold>302</bold></highlight>. Transaction T3 is an Insert transaction that instructs insertion of a row C1,C2,C3,C4&equals;A,1,77,SFR. Transaction T4 is an Insert transaction that instructs insertion of a row C1,C2,C3,C4&equals;B,3,57,BKM. In this example, the two transactions are initiated essentially simultaneously. It will be recognized that the likelihood of such essentially simultaneous transaction initiation is increased as the size of the database increases, and as the number of database access points increases such as, for example, in a networked database. The data manager <highlight><bold>64</bold></highlight> searches for available rows in the data table <highlight><bold>300</bold></highlight>. The data manager <highlight><bold>64</bold></highlight> locates and locks <highlight><bold>316</bold></highlight> row RID&equals;000203, and writes the data of transaction T3 therein <highlight><bold>318</bold></highlight>. The data manager <highlight><bold>64</bold></highlight> also locates and locks <highlight><bold>320</bold></highlight> row RID&equals;000201, and writes the data of transaction T4 therein <highlight><bold>322</bold></highlight>. The lock parameters are recorded in the lock table <highlight><bold>304</bold></highlight> as shown. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 3</cross-reference>(E) and with continuing reference to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, the transaction manager <highlight><bold>62</bold></highlight> next instructs the index manager <highlight><bold>66</bold></highlight> to update the index table <highlight><bold>302</bold></highlight> to reflect the inserted entry <highlight><bold>318</bold></highlight> of transaction T<highlight><bold>3</bold></highlight>. The index manager <highlight><bold>66</bold></highlight> finds an entry with key C1,C2&equals;A,1 already in the unique key index table <highlight><bold>302</bold></highlight> which points to data table row RID&equals;000201. However, this index entry is flagged for deletion <highlight><bold>312</bold></highlight>, i.e. it is pseudo-deleted. If the Delete transaction has committed, then the key C1,C2&equals;A,1 is available and the index manager <highlight><bold>66</bold></highlight> is free to update the index. The index manager therefore requests an S-lock of row RID&equals;000201 through the lock manager <highlight><bold>68</bold></highlight> to determine whether the Delete transaction T1 has actually committed. The lock manager locates an X-lock <highlight><bold>320</bold></highlight>, which transaction T4 placed on row RID&equals;000201. Therefore, the S-lock request of transaction T3 is simply queued <highlight><bold>326</bold></highlight> in the lock table <highlight><bold>304</bold></highlight> as shown. This action suspends the transaction T3, which cannot continue until transaction T4 removes its X-lock <highlight><bold>320</bold></highlight>. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 3</cross-reference>(F) and with continuing reference to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, the transaction manager <highlight><bold>62</bold></highlight> now instructs the index manager <highlight><bold>66</bold></highlight> to update the index table <highlight><bold>302</bold></highlight> to reflect the inserted entry <highlight><bold>322</bold></highlight> of transaction T4. The index manager <highlight><bold>66</bold></highlight> finds an entry with key C1,C2&equals;B,3 already in the index table <highlight><bold>302</bold></highlight> which points to data table row RID&equals;000203. However, this index entry is flagged for deletion <highlight><bold>312</bold></highlight>, i.e. it is pseudo-deleted due to the action of the Delete transaction T2. If the Delete transaction T2 has actually committed, then the key C1,C2&equals;B,3 is available and the index manager <highlight><bold>66</bold></highlight> is free to update the index. The index manager therefore requests an S-lock through the lock manager <highlight><bold>68</bold></highlight> to determine if the Delete transaction T2 has committed. The lock manager locates the X-lock <highlight><bold>316</bold></highlight> which transaction T3 placed on row RID&equals;000203. Therefore, the S-lock request of transaction T4 is simply queued <highlight><bold>328</bold></highlight> in the lock table <highlight><bold>304</bold></highlight> as shown. This action suspends the transaction T4, which cannot continue until transaction T3 removes its X-lock <highlight><bold>316</bold></highlight>. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> Thus, at the time of <cross-reference target="DRAWINGS">FIG. 3</cross-reference>(F), a deadlock is reached. Transaction T3 cannot continue until transaction T4 removes its X-lock of RID&equals;000201, which however cannot continue until transaction T3 removes its X-lock of RID&equals;000203. In FIGS. <highlight><bold>3</bold></highlight>(E)-<highlight><bold>3</bold></highlight>(F), it was assumed that the S-lock of transaction T3 was requested before the S-lock of transaction T4. However, it will be appreciated that an equivalent deadlock situation would have been reached if the S-lock of transaction T4 had been requested first. The deadlock arises because the prior art DBMS effectively assumes that the X-lock encountered in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>(E) or <cross-reference target="DRAWINGS">FIG. 3</cross-reference>(F) is due to the Delete transaction having not yet committed, and is unable to recognize that the encountered X-lock is in fact due to a subsequent Insert transaction. </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> In the present invention, the deadlock which results from implementation of the transaction sequence of FIGS. <highlight><bold>3</bold></highlight>(A)-<highlight><bold>3</bold></highlight>(F) by prior art DBMS is overcome. The improved DBMS includes a new X-lock attribute, called a &ldquo;Delete&rdquo; attribute herein although any other suitable designation could be used. A Delete attribute flag or other indicia is set when the X-lock is granted to a Delete transaction. The improved DBMS also includes a new Conditional S-lock, whose compatibility and behavior relative to X-locks is as follows. The Conditional S-lock is not compatible with an X-lock whose Delete attribute flag is SET or ON. However, the Conditional S-lock is compatible with an X-lock whose Delete attribute flag is NOT SET or OFF. Essentially, the new Conditional S-lock is granted when the previous X-lock requester was not a delete operation. As will be described with reference to <cross-reference target="DRAWINGS">FIGS. 4 and 5</cross-reference>, the improved DBMS overcomes deadlock situations such as the deadlock situation depicted in FIGS. <highlight><bold>3</bold></highlight>(A)-<highlight><bold>3</bold></highlight>(F). </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> With reference first to FIGS. <highlight><bold>4</bold></highlight>(A)-<highlight><bold>4</bold></highlight>(F), a transaction sequence which is identical to that of FIGS. <highlight><bold>2</bold></highlight>(A)-<highlight><bold>2</bold></highlight>(F) is carried out using the improved DBMS. It will be seen that the behavior of the improved DBMS is identical to that of the prior art DBMS for this transaction sequence, and no deadlock occurs in either case. <cross-reference target="DRAWINGS">FIG. 4</cross-reference>(A) shows identical starting conditions to those of <cross-reference target="DRAWINGS">FIG. 2</cross-reference>(A), and includes a data table <highlight><bold>400</bold></highlight>, an index table <highlight><bold>402</bold></highlight>, and a lock table <highlight><bold>404</bold></highlight>. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> With reference next to <cross-reference target="DRAWINGS">FIG. 4</cross-reference>(B) and with continuing reference to <cross-reference target="DRAWINGS">FIG. 1, a</cross-reference> delete transaction &ldquo;Delete C1&equals;A&rdquo; is initiated by the transaction manager <highlight><bold>62</bold></highlight>. The delete transaction instructs deletion of all rows for which C1&equals;A. It will be observed that rows RID&equals;000201 and RID&equals;000202 meet this criterion. As shown in the data table <highlight><bold>400</bold></highlight>, exclusive X-locks <highlight><bold>410</bold></highlight> are placed on rows RID&equals;000201 and RID&equals;000202 by the lock manager <highlight><bold>68</bold></highlight>, and corresponding information is written into the lock table <highlight><bold>404</bold></highlight>. It will be particularly noted that, in the lock table <highlight><bold>404</bold></highlight>, the granted X-locks have the Delete attribute set <highlight><bold>450</bold></highlight>. In accordance with the preferred embodiment of the invention, the Delete attribute flag is set because these X-locks are associated with a Delete transaction. Also, the unique key index table <highlight><bold>402</bold></highlight> is updated by the index manager <highlight><bold>66</bold></highlight> to include an indication that the rows RID&equals;000201 and RID&equals;000202 are to be deleted, as indicated by the &ldquo;D&rdquo; flag <highlight><bold>412</bold></highlight> marking those index entries. Although the Delete C1&equals;A transaction has been initiated at the time shown in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>(B), it has not been committed. Therefore, the information contained in rows RID&equals;000201 and RID&equals;000202 has not yet been removed. </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> With reference next to <cross-reference target="DRAWINGS">FIG. 4</cross-reference>(C) and with continuing reference to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, while the Delete C1&equals;A transaction remains uncommitted, a second, typically unrelated transaction is initiated. The second transaction is an Insert transaction. Using the data manager <highlight><bold>64</bold></highlight>, the transaction manager <highlight><bold>62</bold></highlight> obtains an X-lock <highlight><bold>420</bold></highlight> on row RID&equals;000204 of the data table <highlight><bold>400</bold></highlight> via the lock manager <highlight><bold>68</bold></highlight>, and inserts the data <highlight><bold>422</bold></highlight> into data table <highlight><bold>400</bold></highlight> via the data manager <highlight><bold>64</bold></highlight>. It will be noticed that the X-lock <highlight><bold>420</bold></highlight> does not have the Delete attribute set <highlight><bold>452</bold></highlight>, since this X-lock was granted to an insert transaction. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 4</cross-reference>(D) and with continuing reference to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, the index manager <highlight><bold>66</bold></highlight> now attempts to update the unique key index table <highlight><bold>402</bold></highlight> to reflect the inserted row <highlight><bold>422</bold></highlight>. The index manager <highlight><bold>66</bold></highlight> finds an entry with key C1,C2&equals;A,1 already in the index table <highlight><bold>402</bold></highlight> which points to data table row RID&equals;000201. However, this index entry is flagged for deletion <highlight><bold>412</bold></highlight>, i.e. it is pseudo-deleted. If the Delete C1&equals;A transaction has actually committed, then the key C1,C2&equals;A,1 is available and the index manager <highlight><bold>66</bold></highlight> is free to update the index. </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> The index manager therefore checks whether the deletion of row RID&equals;000201 has been committed by requesting a Conditional S-lock through the lock manager <highlight><bold>68</bold></highlight>. However, the requested Conditional S-lock is incompatible with an X-lock with the Delete attribute SET and the request for the Conditional S-lock will be denied. Therefore, the lock manager <highlight><bold>68</bold></highlight> follows up this denied Conditional S-lock with a request for a normal (unconditional) S-lock on the same row. The normal (unconditional) S-lock request is also incompatible with the existing X-lock on row RID&equals;000201 and is queued <highlight><bold>424</bold></highlight> as shown. This queuing is appropriate since the Delete C1&equals;A transaction has in fact not yet committed. The queuing of the normal (unconditional) S-lock request suspends the insert transaction, thereby ensuring that the unique key rule is obeyed. </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 4</cross-reference>(E) and with continuing reference to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, the Delete C1&equals;A transaction commits. The data is deleted <highlight><bold>426</bold></highlight>, and the queued normal (unconditional) S-lock <highlight><bold>424</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 4</cross-reference>(D)) is granted, indicating that the exclusive X-locks held by the Delete C1&equals;A transaction have been released. After the queued S-lock <highlight><bold>424</bold></highlight> requested by the Insert transaction is granted, the index manager <highlight><bold>66</bold></highlight> replaces the row RID&equals;000201 in the index table <highlight><bold>402</bold></highlight> with the new row value RID&equals;000204 <highlight><bold>428</bold></highlight>, releases the S-lock on RID&equals;000201, and resets the pseudo-delete flag <highlight><bold>430</bold></highlight>. The Insert transaction related to row RID&equals;000204 remains in the lock table <highlight><bold>204</bold></highlight>. The index entries of the deleted items at row RID&equals;000202 remain only pseudo-deleted, i.e. flagged as deleted <highlight><bold>412</bold></highlight>, but remain in the unique key index table <highlight><bold>402</bold></highlight>. </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> With reference next to <cross-reference target="DRAWINGS">FIG. 4</cross-reference>(F) and with continuing reference to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, the Insert transaction is shown committed and the X-lock on row RID&equals;000204 released, and the lock table <highlight><bold>404</bold></highlight> is completely cleared. </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> It will be appreciated from the operations depicted in FIGS. <highlight><bold>4</bold></highlight>(A)-<highlight><bold>4</bold></highlight>(F) are similar to the operations depicted in FIGS. <highlight><bold>2</bold></highlight>(A)-<highlight><bold>2</bold></highlight>(F), except that: (i) when the delete transaction requests an X-lock, the Delete attribute is SET; and (ii) a Conditional S-lock is initially requested, which however is rejected as incompatible with an X-lock with the delete attribute ON. The denied Conditional S-lock is followed up by a normal (unconditional) S-lock, so that the sequence step shown in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>(D) is essentially similar to the sequence step shown in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>(D). In neither case does a deadlock occur, and in both cases a potential compromise of data integrity is prevented. </paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 5</cross-reference>(A)-<highlight><bold>5</bold></highlight>(H), the transaction sequence of FIGS. <highlight><bold>3</bold></highlight>(A)-<highlight><bold>3</bold></highlight>(F) is repeated, but using the improved DBMS of the preferred embodiment of the present invention. It will be seen that, unlike the case of FIGS. <highlight><bold>3</bold></highlight>(A)-<highlight><bold>3</bold></highlight>(F) involving the prior art DBMS, the improved DBMS overcomes the deadlock situation and properly implements the insert operations. <cross-reference target="DRAWINGS">FIG. 5</cross-reference>(A) shows identical starting conditions to those of <cross-reference target="DRAWINGS">FIG. 3</cross-reference>(A), and includes a data table <highlight><bold>500</bold></highlight>, a unique key index table <highlight><bold>502</bold></highlight>, and a lock table <highlight><bold>504</bold></highlight>. </paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> With reference to <cross-reference target="DRAWINGS">FIG. 5</cross-reference>(B) and with continuing reference to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, two essentially simultaneous Delete transactions T1 and T2 are initiated. Transaction T1 instructs deletion of rows with C1&equals;A, and transaction T2 instructs deletion of rows with C1&equals;B. As all rows shown have C1&equals;A or C1&equals;B, the transaction manager <highlight><bold>62</bold></highlight> requests via the data manager <highlight><bold>64</bold></highlight> that X-locks <highlight><bold>510</bold></highlight> be placed on all four rows. The lock manager <highlight><bold>68</bold></highlight> grants the X-locks, and the X-lock parameters are recorded in the lock table <highlight><bold>504</bold></highlight> as shown. It will be particularly noted that, in the lock table <highlight><bold>504</bold></highlight>, the X-locks granted have the Delete attribute flag SET <highlight><bold>550</bold></highlight>, which is appropriate as these X-locks are associated with Delete transactions. Additionally, the corresponding index entries are flagged as deleted <highlight><bold>512</bold></highlight> by the index manager <highlight><bold>66</bold></highlight>. </paragraph>
<paragraph id="P-0068" lvl="0"><number>&lsqb;0068&rsqb;</number> With reference to <cross-reference target="DRAWINGS">FIG. 5</cross-reference>(C) and with continuing reference to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, delete transactions T1 and T2 commit. The data is deleted <highlight><bold>514</bold></highlight> from the data table <highlight><bold>500</bold></highlight> and the locks <highlight><bold>510</bold></highlight> are removed. Importantly, the index entries are merely flagged for deletion <highlight><bold>512</bold></highlight> but remain in the index <highlight><bold>502</bold></highlight>. It will be appreciated that FIGS. <highlight><bold>5</bold></highlight>(A)-<highlight><bold>5</bold></highlight>(C) are essentially similar to FIGS. <highlight><bold>3</bold></highlight>(A)-<highlight><bold>3</bold></highlight>(C), but with the additional setting of the Delete attribute <highlight><bold>550</bold></highlight> in the lock table <highlight><bold>504</bold></highlight>. Because no additional lock requests were made on these rows while the X-locks of the Delete transactions T1 and T2 were in effect, this difference is of no consequence to this point. </paragraph>
<paragraph id="P-0069" lvl="0"><number>&lsqb;0069&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 5</cross-reference>(D) and with continuing reference to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, two new transactions T3 and T4 are initiated by the transaction manager <highlight><bold>62</bold></highlight>. Transaction T3 is an Insert transaction that instructs insertion of a row C1,C2,C3,C4&equals;A,1,77,SFR. Transaction T4 is an Insert transaction that instructs insertion of a row C1,C2,C3,C4&equals;B,3,57,BKM. The two transactions are initiated essentially simultaneously. The data manager <highlight><bold>64</bold></highlight> searches for available rows in the data table <highlight><bold>500</bold></highlight>, locates and locks <highlight><bold>516</bold></highlight> row RID&equals;000203, and writes the data of Insert transaction T3 therein <highlight><bold>518</bold></highlight>. The data manager <highlight><bold>64</bold></highlight> also locates and locks <highlight><bold>520</bold></highlight> row RID&equals;000201, and writes the data of Insert transaction T4 therein <highlight><bold>522</bold></highlight>. The lock parameters are recorded in the lock table <highlight><bold>504</bold></highlight> as shown. It will be noticed that the X-locks <highlight><bold>516</bold></highlight> and <highlight><bold>520</bold></highlight> do not have the Delete attribute flag set <highlight><bold>552</bold></highlight>, since these X-locks were granted to Insert transactions rather than to Delete transactions. </paragraph>
<paragraph id="P-0070" lvl="0"><number>&lsqb;0070&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 5</cross-reference>(E) and with continuing reference to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, the transaction manager <highlight><bold>62</bold></highlight> next instructs the index manager <highlight><bold>66</bold></highlight> to update the unique key index table <highlight><bold>502</bold></highlight> to reflect the inserted entry <highlight><bold>518</bold></highlight> of Insert transaction T3. The index manager <highlight><bold>66</bold></highlight> locates an entry with key C1,C2&equals;A,1 already in the index table <highlight><bold>502</bold></highlight> which points to data table row RID&equals;000201. However, this index entry is flagged for deletion <highlight><bold>512</bold></highlight>, (<cross-reference target="DRAWINGS">FIG. 5</cross-reference>(D)) i.e. it is pseudo-deleted. If the Delete transaction has committed, then the key C1,C2&equals;A,1 is available and the index manager <highlight><bold>66</bold></highlight> is free to update the index. </paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> The index manager therefore requests a Conditional S-lock of row RID&equals;000201 through the lock manager <highlight><bold>68</bold></highlight> to determine whether the Delete transaction has committed. The lock manager <highlight><bold>68</bold></highlight> locates an X-lock <highlight><bold>520</bold></highlight>, which transaction T<highlight><bold>4</bold></highlight> placed on row RID&equals;000201. However, because the requested Conditional S-lock is compatible with an X-lock with the Delete attribute flag NOT SET or OFF, the lock manager <highlight><bold>68</bold></highlight> grants the Conditional S-lock. This granting of the Conditional S-lock is appropriate because the Delete transaction T1 has committed. After the Conditional S-lock requested by Insert transaction T3 is granted, the index manager <highlight><bold>66</bold></highlight> updates the unique key index table <highlight><bold>502</bold></highlight> by changing the RID pointer of the C1,C2&equals;A,1 key from RID&equals;000201 to RID&equals;000203 <highlight><bold>556</bold></highlight>, releases the S-lock on RID&equals;000201, and resets its pseudo-delete flag <highlight><bold>558</bold></highlight>. </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> Thus, unlike the prior art case depicted in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>(E) wherein the S-lock was queued and transaction T3 suspended, here Insert transaction T3 is permitted to continue. Because the Conditional S-lock was granted, the lock manager <highlight><bold>66</bold></highlight> unambiguously determines that the Delete transaction which set the pseudo-delete flag of the C1,C2&equals;A,1 index key has already committed. Since the deletion of the previous C1,C2&equals;A,1 entry has committed, the Insert transaction T3 is free to update the index. </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> With reference next to <cross-reference target="DRAWINGS">FIG. 5</cross-reference>(F) and with continuing reference to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, Insert transaction T<highlight><bold>3</bold></highlight> is shown committed and the X-lock on row RID&equals;000203 released. Transaction T3 removes its X-lock on row RID&equals;000203 and only the X-lock on row RID&equals;000201 asserted by Insert transaction T4 remains in the lock table <highlight><bold>504</bold></highlight>. </paragraph>
<paragraph id="P-0074" lvl="0"><number>&lsqb;0074&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 5</cross-reference>(G) and with continuing reference to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, the transaction manager <highlight><bold>62</bold></highlight> now instructs the index manager <highlight><bold>66</bold></highlight> to update the unique key index table <highlight><bold>502</bold></highlight> to reflect the inserted entry <highlight><bold>522</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 5</cross-reference>(D)) of Insert transaction T4. The index manager <highlight><bold>66</bold></highlight> finds an entry with key C1,C2&equals;B,3 already in the index <highlight><bold>502</bold></highlight> which points to data table row RID&equals;000203. However, this index entry is flagged for deletion <highlight><bold>512</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 5</cross-reference>(F)), i.e. it is pseudo-deleted. If the delete transaction has committed, then the key C1,C2&equals;B,3 is available and the index manager <highlight><bold>66</bold></highlight> is free to update the index. </paragraph>
<paragraph id="P-0075" lvl="0"><number>&lsqb;0075&rsqb;</number> The index manager therefore requests a Conditional S-lock of row RID&equals;000203 through the lock manager <highlight><bold>68</bold></highlight> to find out if the delete transaction has committed. Finding no previous lock on RID&equals;000203, the lock manager grants the Conditional S-lock. After the Conditional S-lock requested by Insert transaction T4 is granted, the index manager <highlight><bold>66</bold></highlight> updates the unique key index table <highlight><bold>502</bold></highlight> by changing the RID pointer of the C1,C2&equals;B,3 key from RID&equals;000203 to RID&equals;000201 570, releasing the S-lock on RID&equals;000203, and resetting its pseudo-delete flag <highlight><bold>572</bold></highlight>. Thus, unlike the prior art case depicted in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>(F) wherein the S-lock was queued and Insert transaction T4 suspended thereby producing a deadlock situation, here the Insert transaction T4 is permitted to continue because by using the Conditional S-lock the lock manager unambiguously determines that the delete transaction which set the pseudo-delete flag of the C1,C2&equals;B,3 index key has already committed. Since the deletion of the previous C1,C2&equals;B,3 entry has committed, transaction T4 is free to update the index. </paragraph>
<paragraph id="P-0076" lvl="0"><number>&lsqb;0076&rsqb;</number> With reference next to <cross-reference target="DRAWINGS">FIG. 5</cross-reference>(H) and with continuing reference to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, Insert transaction T4 commits. Insert transaction T4 removes its X-lock on row RID&equals;000201, and the lock table <highlight><bold>504</bold></highlight> is cleared of all locks. </paragraph>
<paragraph id="P-0077" lvl="0"><number>&lsqb;0077&rsqb;</number> In the sequence depicted in FIGS. <highlight><bold>5</bold></highlight>(E)-<highlight><bold>5</bold></highlight>(H), it was assumed that the Conditional S-lock of transaction T3 was requested before the Conditional S-lock of transaction T4. However, it will be appreciated that had the lock request order been reversed, an equivalent result is obtained, namely that the two insert transactions T3 and T4 would have successfully completed without deadlock. It is therefore recognized that the improved DBMS of the invention overcomes the prior art limitations depicted in the example of FIGS. <highlight><bold>3</bold></highlight>(A)-<highlight><bold>3</bold></highlight>(F) for a unique key index. </paragraph>
<paragraph id="P-0078" lvl="0"><number>&lsqb;0078&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 6</cross-reference>, and with continuing reference to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, the preferred method <highlight><bold>600</bold></highlight> by which the improved DBMS index manager <highlight><bold>66</bold></highlight> processes updates to a unique key index in accordance with the present invention, is described. The index manager <highlight><bold>66</bold></highlight> receives instructions to add a key entry in a step <highlight><bold>602</bold></highlight>. The index manager <highlight><bold>66</bold></highlight> searches the unique key index <highlight><bold>42</bold></highlight> for an existing key in the relevant unique key index table in a step <highlight><bold>604</bold></highlight>. A decision <highlight><bold>606</bold></highlight> is made based on the results of the searching <highlight><bold>604</bold></highlight>. If the key does not already exist, then the index manager <highlight><bold>66</bold></highlight> creates a new key entry based on the received instructions in a step <highlight><bold>608</bold></highlight>, and reports success to the transaction manager <highlight><bold>64</bold></highlight> in a return step <highlight><bold>610</bold></highlight>. </paragraph>
<paragraph id="P-0079" lvl="0"><number>&lsqb;0079&rsqb;</number> If, however, the key does already exist in the index, the index manager next checks whether the existing key entry is pseudo-deleted in a decision step <highlight><bold>612</bold></highlight>. If the entry is not pseudo-deleted, the index manager <highlight><bold>66</bold></highlight> requests a normal (unconditional) S-lock on the key entry RID in a step <highlight><bold>614</bold></highlight>. After the S-lock is granted, the transaction manager checks if the entry still exists and is not pseudo-deleted in a decision step <highlight><bold>616</bold></highlight>. If the entry does exist and is not pseudo-deleted, then the index manager <highlight><bold>66</bold></highlight> reports failure in a step <highlight><bold>618</bold></highlight> to the transaction manager <highlight><bold>64</bold></highlight> in a return step <highlight><bold>614</bold></highlight>, because carrying out the key entry addition would violate the unique key rule. Otherwise, the index manager <highlight><bold>66</bold></highlight> updates the existing key entry on behalf of this insert transaction, releases the normal (unconditional) S-lock and resets the pseudo-delete flag in a step <highlight><bold>620</bold></highlight>, and reports success in a step <highlight><bold>622</bold></highlight>. </paragraph>
<paragraph id="P-0080" lvl="0"><number>&lsqb;0080&rsqb;</number> The steps <highlight><bold>614</bold></highlight> and <highlight><bold>616</bold></highlight> particularly cover the exemplary case of parallel inserts with the same key value by different transactions. The second insert transaction is directed to wait behind the first insert transaction in the step <highlight><bold>614</bold></highlight> (i.e., the S-lock of the second transaction is queued until the X-lock of the first transaction is released). If the first insert transaction did not commit, it will preferably mark the inserted key entry as pseudo-deleted before releasing its X-lock, thus enabling the decision step <highlight><bold>616</bold></highlight> to transfer control to the step <highlight><bold>620</bold></highlight> and thereby update the index key entry on behalf of the second insert transaction. </paragraph>
<paragraph id="P-0081" lvl="0"><number>&lsqb;0081&rsqb;</number> Returning back to the decision step <highlight><bold>612</bold></highlight> now, if the existing key entry is pseudo-deleted, then the index manager next determines whether the deletion transaction has actually committed. To make this determination, the index manager <highlight><bold>66</bold></highlight> retrieves the row RID pointer of the pseudo-deleted index entry in a step <highlight><bold>624</bold></highlight>, and requests a Conditional S-lock on that row from the lock manager <highlight><bold>68</bold></highlight> in a step <highlight><bold>626</bold></highlight>. Another decision point <highlight><bold>628</bold></highlight> is reached based upon whether or not the lock manager <highlight><bold>68</bold></highlight> grants the Conditional S-lock. </paragraph>
<paragraph id="P-0082" lvl="0"><number>&lsqb;0082&rsqb;</number> As discussed previously, the requested Conditional S-lock is compatible with an X-lock whose Delete attribute flag is NOT SET or OFF, but the requested Conditional S-lock is not compatible with an X-lock whose Delete attribute is SET or ON. The granting of the Conditional S-lock at step <highlight><bold>628</bold></highlight> therefore indicates that the delete transaction which set the pseudo-deletion flag of the index entry has already committed. Furthermore, this granting will not be improperly prevented by the X-lock of any intervening transaction which seeks to write to the row after the delete transaction has committed, because the X-lock of any intervening transaction would be a non-delete transaction and so the delete attribute of the X-lock would be off or not set. </paragraph>
<paragraph id="P-0083" lvl="0"><number>&lsqb;0083&rsqb;</number> Thus, if the Conditional S-lock is granted by the lock manager <highlight><bold>68</bold></highlight>, the index manager <highlight><bold>66</bold></highlight> updates the existing key entry with the new row RID, releases the Conditional S-lock, and resets (i.e., turn OFF) the pseudo-delete flag of the index key entry in the step <highlight><bold>620</bold></highlight>. The index manager <highlight><bold>66</bold></highlight> then reports success to the transaction manager <highlight><bold>62</bold></highlight> in the return step <highlight><bold>622</bold></highlight>. </paragraph>
<paragraph id="P-0084" lvl="0"><number>&lsqb;0084&rsqb;</number> If, however, the Conditional S-lock is not granted in step <highlight><bold>628</bold></highlight>, this indicates that the blocking X-lock is due to the Delete transaction which set the pseudo-delete flag and which has not yet committed. The index cannot be updated unless and until the Delete transaction commits. In a preferred embodiment, the lock manager <highlight><bold>68</bold></highlight> follows up a denied Conditional S-lock with a normal (unconditional) S-lock in a step <highlight><bold>630</bold></highlight>. The unconditional S-lock is also blocked by the X-lock of the uncommitted Delete transaction and is queued. Thereafter, a waiting period <highlight><bold>632</bold></highlight> terminates either when the Delete transaction commits and removes its X-lock so that the unconditional S-lock is granted, or when a predetermined timeout period elapses. At a decision point <highlight><bold>634</bold></highlight>, if the timeout has been reached and the unconditional S-lock remains queued, the index manager <highlight><bold>66</bold></highlight> reports failure to the transaction manager <highlight><bold>64</bold></highlight> in a return step <highlight><bold>636</bold></highlight>. </paragraph>
<paragraph id="P-0085" lvl="0"><number>&lsqb;0085&rsqb;</number> However, if the S-lock is granted at any time during the waiting period <highlight><bold>632</bold></highlight>, the index is updated, the normal (unconditional) S-lock is released and the pseudo-delete flag is reset in the step <highlight><bold>620</bold></highlight>, and the index manager <highlight><bold>66</bold></highlight> reports success in the step <highlight><bold>622</bold></highlight>. These steps are carried out when the unconditional S-lock is granted because the granting of the unconditional S-lock unambiguously indicates that the Delete operation has committed and removed its X-lock. </paragraph>
<paragraph id="P-0086" lvl="0"><number>&lsqb;0086&rsqb;</number> The invention has been described with reference to the preferred embodiments. Obviously, modifications and alterations will occur to others upon reading and understanding the preceding detailed description. It is intended that the invention be construed as including all such modifications and alterations insofar as they come within the scope of the appended claims or the equivalents thereof. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">Having thus described the preferred embodiments, the invention is now claimed to be: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A database management system (DBMS) for managing a database application, the database application including a database having at least one table, and an index having at least one unique key index table corresponding to the at least one table, the DBMS comprising: 
<claim-text>a data manager for managing updates of the database; </claim-text>
<claim-text>an index manager for managing updates of the unique key table index; </claim-text>
<claim-text>a transaction manager for executing database transactions in cooperation with the data manager and the index manager; and, </claim-text>
<claim-text>a lock manager cooperative with the index manager and the data manager for restricting access to a first table element of said at least one table by assigning one or more locks thereto, said locks being selected from a plurality of lock types including at least, 
<claim-text>an exclusive X-lock that enables exclusive access to the first table element, the exclusive X-lock including a Delete attribute associated therewith, a SET state of the Delete attribute being indicative of a transaction holding the X-lock being a delete transaction; and, </claim-text>
<claim-text>an unconditional S-lock that enables shared access to the first table element and is selectively assigned by the lock manager to the first table element only when the first table element is without an exclusive X-lock previously assigned thereto. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The DBMS as set forth in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein: 
<claim-text>the plurality of lock types further includes a Conditional S-lock that enables shared access to the first table element; and, </claim-text>
<claim-text>the lock manager selectively assigns the Conditional S-lock to the first table element only when the first table element is without an exclusive X-lock previously assigned thereto with the Delete attribute in a SET state. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The DBMS as set forth in <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, wherein: 
<claim-text>the unique key index table further includes a pseudo-delete flag corresponding to each key entry of the unique key index table; and, </claim-text>
<claim-text>the index manager selectively SETs the pseudo-delete flag to indicate deletion of a table row corresponding to the index key entry. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The DBMS as set forth in <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference>, wherein in response to receiving a request from the index manager to enter an index key entry and a corresponding new row identification RID in which the index key entry corresponds to an existing index key entry whose pseudo-delete flag SET, the index manager is operative to: 
<claim-text>request a Conditional S-lock on the table row corresponding to the existing index key en try; and, </claim-text>
<claim-text>conditional upon the Conditional S-lock on the table row corresponding to the existing index key entry being granted by the lock manager, update the table index key entry with the new row identification RID, release the Conditional S-lock on the table row corresponding to the existing index key entry, and reset the pseudo-delete flag to and OFF state. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The DBMS as set forth <dependent-claim-reference depends_on="CLM-00004">claim 4</dependent-claim-reference>, wherein in response to receiving a request from the index manager to enter an index key entry and a corresponding new row identification RID in which the index key entry corresponds to an existing index key entry whose pseudo-delete flag is SET, the index manager is adapted to: 
<claim-text>conditional upon the Conditional S-lock on the table row corresponding to the existing index key entry being denied by the lock manager, request an unconditional S-lock on the table row corresponding to the existing index key entry; and, </claim-text>
<claim-text>upon granting of the unconditional S-lock by the lock manager, update the table index key entry with the new row identification RID, release the unconditional S-lock, and reset the pseudo-delete flag. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The DBMS as set forth in <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference>, wherein in response to receiving a request from the index manager to enter an index key entry and a corresponding new row identification RID in which the index key entry corresponds to an existing index key entry whose pseudo-delete flag is NOT SET, RESET, or OFF, the index manager is operative to: 
<claim-text>request an unconditional S-lock on the table row corresponding to the existing index key entry; and, </claim-text>
<claim-text>upon granting of the unconditional S-lock on the table row corresponding to the existing index key entry by the lock manager and conditional upon the index key entry having its pseudo-delete flag SET, update the table index key entry with the new row identification RID, release the unconditional S-lock, and reset the pseudo-delete flag. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. A database management method for entering a key and a new row identification RID into a unique key table index of a database application that uses pseudo-deletion of table index entries, comprising: 
<claim-text>searching the unique key table index for the key; </claim-text>
<claim-text>when a pseudo-deleted table index entry corresponding to the key is located during the searching step: 
<claim-text>requesting a Conditional S-lock on a table row indexed by the pseudo-deleted table index entry; and, </claim-text>
<claim-text>conditional upon receiving an indication that the Conditional S-lock is granted, updating the table index entry with the new row identification RID and resetting the pseudo-delete flag; and, </claim-text>
</claim-text>
<claim-text>conditional upon not locating a table index entry corresponding to the key during the searching step, updating the table index by adding the key and the new row identification RID. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference>, wherein the step of receiving an indication that the Conditional S-lock is granted includes the steps of: 
<claim-text>granting the Conditional S-lock conditional upon the table row indexed by the pseudo-deleted table index entry not having an X-lock assigned thereto; </claim-text>
<claim-text>granting the Conditional S-lock conditional upon the table row indexed by the pseudo-deleted table index entry having an X-lock assigned thereto wherein said X-lock has a Delete attribute that is not set, reset, or off; and </claim-text>
<claim-text>receiving an indication that the Conditional S-lock is granted conditional upon the granting of the Conditional S-lock. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference>, further including the steps: 
<claim-text>conditional upon receiving an indication that the Conditional S-lock is denied: 
<claim-text>requesting an unconditional S-lock on the table row indexed by the pseudo-deleted table index entry; and </claim-text>
<claim-text>conditional upon receiving an indication that the unconditional S-lock is granted, updating the table index entry with the new row identification RID and resetting the pseudo-delete flag. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference>, further including the steps: 
<claim-text>conditional upon locating a table index entry that is not pseudo-deleted during the searching step: 
<claim-text>requesting an unconditional S-lock on the table row indexed by the located table index entry; and </claim-text>
<claim-text>upon granting of the unconditional S-lock and conditional upon the located table index entry being pseudo-deleted, updating the table index entry with the new row identification RID and resetting the pseudo-delete flag. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. An article of manufacture comprising a program storage medium readable by a computer and embodying one or more instructions executable by the computer to perform method steps for entering a key and a new row RID into a unique key table index of a database stored on a data store connected to the computer, the unique key table index using pseudo-deletion of table index entries, the method comprising the steps of: 
<claim-text>searching the unique key table index for the key; </claim-text>
<claim-text>conditional upon locating a pseudo-deleted table index entry corresponding to the key during the searching step: 
<claim-text>requesting a Conditional S-lock on a table row indexed by the pseudo-deleted table index entry, and </claim-text>
<claim-text>conditional upon receiving an indication that the Conditional S-lock is granted, updating the table index entry with the new row identification RID and resetting the pseudo-delete flag; and, </claim-text>
</claim-text>
<claim-text>conditional upon not locating a table index entry corresponding to the key during the searching step, updating the table index by adding the key and the new row identification RID. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The article of manufacture according to <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, wherein the step of receiving an indication that the Conditional S-lock is granted includes the steps of: 
<claim-text>granting the Conditional S-lock conditional upon the table row indexed by the pseudo-deleted table index entry not having an X-lock assigned thereto; </claim-text>
<claim-text>granting the Conditional S-lock conditional upon the table row indexed by the pseudo-deleted table index entry having an X-lock assigned thereto wherein said X-lock has a Delete attribute that is not set, reset, or off; and </claim-text>
<claim-text>receiving an indication that the Conditional S-lock is granted conditional upon the granting of the Conditional S-lock. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The article of manufacture according to <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, wherein the method further includes the steps, to be executed conditional upon receiving an indication that the Conditional S-lock is denied, of: 
<claim-text>requesting an unconditional S-lock on the table row indexed by the pseudo-deleted table index entry; and </claim-text>
<claim-text>conditional upon receiving an indication that the unconditional S-lock is granted, updating the table index entry with the new row identification RID and resetting the pseudo-delete flag. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The article of manufacture according to <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, wherein the method further includes the steps, to be executed conditional upon locating a table index entry that is not pseudo-deleted during the searching step, of: 
<claim-text>requesting an unconditional S-lock on the table row indexed by the located table index entry; and </claim-text>
<claim-text>upon granting of the unconditional S-lock and conditional upon the located table index entry being pseudo-deleted, updating the table index entry with the new row identification RID and resetting the pseudo-delete flag. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. A lock manager for use in a database management system (DBMS) managing a database application including a database having at least one table and cooperative with an index manager and a data manager for restricting access to a first table element of said at least one table by assigning one or more locks thereto including at least an exclusive X-lock that enables exclusive access to the first table element, the exclusive X-lock including a Delete attribute associated therewith, a SET state of the Delete attribute being indicative of a transaction holding the X-lock being a delete transaction. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The lock manager according to <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference>, wherein: 
<claim-text>the lock manager is adapted to restrict access to said first table element by assigning a Conditional S-lock that enables shared access to the first table element and is selectively assigned by the lock manager to the first table element only when the first table element is without an exclusive X-lock previously assigned thereto with the Delete attribute in a SET state. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The lock manager as set forth in <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, wherein: the unique key index table further includes a pseudo-delete flag corresponding to each key entry of the unique key index table; and, 
<claim-text>the index manager is operative to selectively SET the pseudo-delete flag to indicate deletion of a table row corresponding to the index key entry. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The lock manager as set forth in <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference>, wherein: 
<claim-text>in response to receiving a request from the transaction manager to enter an index key entry and a corresponding new row identification RID in which the index key entry corresponds to an existing index key entry whose pseudo-delete flag SET, the index manager is operative to request a Conditional S-lock on the table row corresponding to the existing index key entry; and, </claim-text>
<claim-text>the lock manager is operative to grant the Conditional S-lock on the table row corresponding to the existing index key entry being only when: 
<claim-text>the table row is without an exclusive X-lock assigned thereto, and the table row has an exclusive X-lock assigned thereto with the Delete attribute not in said SET state, to enable the index manager to update the table index key entry with the new row identification RID, release the Conditional S-lock on the table row corresponding to the existing index key entry, and reset the pseudo-delete flag to and OFF state.</claim-text>
</claim-text>
</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>1</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030004945A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030004945A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030004945A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030004945A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030004945A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030004945A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030004945A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030004945A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030004945A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00009">
<image id="EMI-D00009" file="US20030004945A1-20030102-D00009.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00010">
<image id="EMI-D00010" file="US20030004945A1-20030102-D00010.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
