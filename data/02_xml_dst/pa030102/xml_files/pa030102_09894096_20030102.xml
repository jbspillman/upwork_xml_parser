<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005169A1-20030102-D00000.TIF SYSTEM "US20030005169A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005169A1-20030102-D00001.TIF SYSTEM "US20030005169A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005169A1-20030102-D00002.TIF SYSTEM "US20030005169A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005169A1-20030102-D00003.TIF SYSTEM "US20030005169A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005169A1-20030102-D00004.TIF SYSTEM "US20030005169A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005169A1-20030102-D00005.TIF SYSTEM "US20030005169A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030005169A1-20030102-D00006.TIF SYSTEM "US20030005169A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030005169A1-20030102-D00007.TIF SYSTEM "US20030005169A1-20030102-D00007.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005169</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09894096</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010628</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F009/44</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>709</class>
<subclass>315000</subclass>
</uspc>
</classification-us-primary>
<classification-us-secondary>
<uspc>
<class>709</class>
<subclass>331000</subclass>
</uspc>
</classification-us-secondary>
</classification-us>
<title-of-invention>Method and system for maintaining forward and backward compatibility in flattened object streams</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Michael</given-name>
<middle-name>Albert</middle-name>
<family-name>Perks</family-name>
</name>
<residence>
<residence-us>
<city>Austin</city>
<state>TX</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Sean</given-name>
<middle-name>Michael</middle-name>
<family-name>Sundberg</family-name>
</name>
<residence>
<residence-us>
<city>Waco</city>
<state>TX</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<assignee>
<organization-name>INTERNATIONAL BUSINESS MACHINES CORPORATION</organization-name>
<address>
<city>ARMONK</city>
<state>NY</state>
</address>
<assignee-type>02</assignee-type>
</assignee>
<correspondence-address>
<name-1>Joseph R. Burwell</name-1>
<name-2>Law Office of Joseph R. Burwell</name-2>
<address>
<address-1>P.O. Box 28022</address-1>
<city>Austin</city>
<state>TX</state>
<postalcode>78755-8022</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A method, a system, an apparatus, and a computer program product are presented for object-oriented management of serializable objects. An object has a set of attributes and a class version number, which identifies the object as an instance of a specific version of a class. In addition, each attribute in the object has an attribute version number, which may represent a version of a class in which the associated attribute was initially declared within the class. The object may be serialized into a data stream, and the data stream has the class version number of the object, an attribute value for each attribute in the set of attributes, and an attribute version number for each attribute in the set of attributes. The data stream may also have a class identifier for the class of the object and an attribute count for the set of attributes into the data stream. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> 1. Field of the Invention </paragraph>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> The present invention relates to an improved data processing system and, in particular, to a method and apparatus for object-oriented input/output, data storage, or communication. Still more particularly, the present invention provides a method and apparatus for version management of serialized object streams. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> 2. Description of Related Art </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> While executing an object-oriented application, objects are created and then destroyed or otherwise freed; in a Java&trade; runtime environment, objects are eventually freed through garbage collection. In certain applications, rather than saving runtime data in persistent storage and then recreating objects, it is helpful to persist actual objects outside of the runtime environment. The object is then stored in persistent storage or communicated to another process or device. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> Using object serialization, an object can be persisted and then reused. Object serialization is the process of saving an object&apos;s state to a sequence of bytes as well as the process of rebuilding those bytes into a live object, although the latter is sometimes called &ldquo;deserialization&rdquo;. The complete state of an object can be written to an output stream, and at some later time, the object can be recreated by reading its serialized state from an input stream. Using a three-dimensional analogy for an object, a serialized object is often called a &ldquo;flattened&rdquo; object, while a recreated object is sometimes called an &ldquo;inflated&rdquo; object. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> Java&trade; provides default mechanisms for persisting objects. As long as an object implements the &ldquo;Serializable&rdquo; interface or has a class within its hierarchy that implements the interface, an object can be serialized; a Java&trade; class can specify which attributes are not to be serialized/deserialized using the special Java&trade; keyword &ldquo;transient&rdquo;. The &ldquo;Serializable&rdquo; interface does not define any methods but merely acts as a marker that indicates whether serialization is allowed on a given object. An object can by serialized by passing the object to the &ldquo;writeObject( )&rdquo; method of the &ldquo;ObjectOutputStream&rdquo; class, and the object can be recreated by calling the &ldquo;readObject( )&rdquo; method of the &ldquo;ObjectInputStream&rdquo; class. This serialization behavior can be customized to a certain extent by implementing the &ldquo;writeObject( )&rdquo; and &ldquo;readObject( )&rdquo; methods while still being able to rely on the default output and input mechanisms for writing and reading a flattened object. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> Instead of relying on the default mechanism, one can create a custom serialization mechanism by implementing the &ldquo;Externalizable&rdquo; interface, which defines only two methods, &ldquo;writeExternal( )&rdquo; and &ldquo;readExternal( )&rdquo;. By overriding these methods, one has complete control over the writing and reading of an object&apos;s state. When a class implements the &ldquo;Externalizable&rdquo; interface, the &ldquo;ObjectOutputStream&rdquo; and &ldquo;ObjectInputStream&rdquo; classes use that class&apos;s &ldquo;writeExternal( )&rdquo; and &ldquo;readExternal( )&rdquo; methods to write and read the object&apos;s state to and from a flattened object stream. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> One potential problem with serializing an object is that a flattened object might persist within a file for a long period of time. Meanwhile, classes may change over time such that multiple versions of a class are used while the flattened object remains in persistent storage. When an attempt is made to read the flattened object, an error could occur because the version of the class that is being used to read the flattened object is not compatible with the version of the class that was being used when the object was flattened. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> The Java&trade; environment contains some administrative support for detecting class versioning problems. When an object is serialized, information about an object&apos;s class is also serialized so that the correct class can be loaded when the object is deserialized. Generally, this information comprises the fully-qualified name of the class; in addition, all persistent-capable classes are given a version number. The version number of a class is stored in a field named &ldquo;serialVersionUID&rdquo;, and the version number is used to determine whether an object can be properly deserialized; if there is a version mismatch, the &ldquo;java.io.InvalidClassException&rdquo; will be thrown. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> If one needs to control class versioning, one can explicitly declare the &ldquo;serialVersionUID&rdquo; constant and ensure that it remains the same between compatible versions of a class; it should be assumed that one would not maintain the same &ldquo;serialVersionUID&rdquo; constant across changes to a class that break serialization compatibility. If a class does not define a &ldquo;serialVersionUID&rdquo; constant, then the &ldquo;ObjectOutputStream&rdquo; class automatically generates a unique version number for the class by applying a hashing algorithm to information related to the class, such as the class name, its interfaces, fields, and methods. Changes that break serialization compatibility can then be detected through the &ldquo;serialVersionUID&rdquo; constant. For example, if a non-private class method signature is changed in a new version of the class, then the automatically-computed unique version number would also change, and an exception would be thrown when an attempt was made to read a flattened object stream into an incompatible version of the object. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> Although the administrative support for detecting class versioning problems is helpful to some extent, it does not provide any mechanism for recovery from this incompatibility in class versions. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> Therefore, it would be advantageous to have a methodology for facilitating object serialization and deserialization such that forward and backward compatibility can be maintained for flattened objects across different versions of a class. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> A method, a system, an apparatus, and a computer program product are presented for object-oriented management of serializable objects. Within object-oriented programming languages, classes define a set of attributes and methods, which provide the state and behavior for instances of that class. For the purposes of this invention, the class would also define a class version number attribute that would serve to identify an object as an instance of a particular class version. In addition, each attribute in the set of attributes is associated with an attribute version number. The attribute version number represents the class version in which the associated attribute was first declared within the class. When an object is written to a data stream, all of the information contained within that object would be written. The information written to the stream would consist of a value identifying the object&apos;s class, the value of the class version attribute, a count of all of the non-transient attributes defined within the object, and every attribute along with its associated version number. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> At some subsequent point in time, the data stream representing a serialized object may be read. An object will be instantiated in accordance with the class identifier from the data stream, at which point the class version number of the instantiated object and the class version number of the serialized object may differ. Serialized attribute values from the data stream are stored within the instantiated object in accordance with the class version number and attribute version number relationships between the serialized object and the instantiated object. </paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> The novel features believed characteristic of the invention are set forth in the appended claims. The invention itself, further objectives, and advantages thereof, will be best understood by reference to the following detailed description when read in conjunction with the accompanying drawings, wherein: </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1A</cross-reference> depicts a typical distributed data processing system in which the present invention may be implemented; </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1B</cross-reference> depicts a typical computer architecture that may be used within a data processing system in which the present invention may be implemented; </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2A</cross-reference> is a diagram showing a simple Person class that might be found in the prior art; </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> FIGS. <highlight><bold>2</bold></highlight>B-<highlight><bold>2</bold></highlight>C are diagrams depicting the operation of a standard serialization mechanism on two versions of the Person class in which the same version of the class is used for both serialization and deserialization; </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> FIGS. <highlight><bold>3</bold></highlight>A-<highlight><bold>3</bold></highlight>B are diagrams depicting the operation of a standard serialization mechanism on two versions of the Person class in which a different version of the class is used for serialization and deserialization on the same object stream; </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> FIGS. <highlight><bold>4</bold></highlight>A-<highlight><bold>4</bold></highlight>D are diagrams depicting the operation of a custom serialization mechanism for versions of the exemplary Person class in accordance with the present invention; </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> depicts a simple object model with a set of classes for illustrating an object-oriented methodology that supports serialization and deserialization with version management in accordance with a preferred embodiment of the present invention; </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6A</cross-reference> is a flowchart depicting a serialization process in accordance with a preferred embodiment of the present invention; </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6B</cross-reference> is a flowchart depicting a deserialization process in accordance with a preferred embodiment of the present invention; and </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> FIGS. <highlight><bold>7</bold></highlight>A-<highlight><bold>7</bold></highlight>D are diagrams depicting evolving versions of the Person class in conjunction with serialized data streams and an attribute value list that may be used as a data structure to assist with interpreting the implicit ordering of a data stream in accordance with a preferred embodiment of the present invention. </paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF THE INVENTION </heading>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> The present invention is directed to a system and a methodology for facilitating object serialization and deserialization such that forward and backward compatibility can be maintained for flattened objects across different versions of a class. These flattened objects may be persisted in one or more files that are dispersed throughout a network, or the flattened objects may be communicated between devices within a network. As background, a typical organization of hardware and software components within a distributed data processing system is described prior to describing the present invention in more detail. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> With reference now to the figures, <cross-reference target="DRAWINGS">FIG. 1A</cross-reference> depicts a typical network of data processing systems, each of which may contain and/or operate the present invention. Distributed data processing system <highlight><bold>100</bold></highlight> contains network <highlight><bold>101</bold></highlight>, which is a medium that may be used to provide communications links between various devices and computers connected together within distributed data processing system <highlight><bold>100</bold></highlight>. Network <highlight><bold>101</bold></highlight> may include permanent connections, such as wire or fiber optic cables, or temporary connections made through telephone or wireless communications. In the depicted example, server <highlight><bold>102</bold></highlight> and server <highlight><bold>103</bold></highlight> are connected to network <highlight><bold>101</bold></highlight> along with storage unit <highlight><bold>104</bold></highlight>. In addition, clients <highlight><bold>105</bold></highlight>-<highlight><bold>107</bold></highlight> also are connected to network <highlight><bold>101</bold></highlight>. Clients <highlight><bold>105</bold></highlight>-<highlight><bold>107</bold></highlight> and servers <highlight><bold>102</bold></highlight>-<highlight><bold>103</bold></highlight> may be represented by a variety of computing devices, such as mainframes, personal computers, personal digital assistants (PDAs), etc. Distributed data processing system <highlight><bold>100</bold></highlight> may include additional servers, clients, routers, other devices, and peer-to-peer architectures that are not shown. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> In the depicted example, distributed data processing system <highlight><bold>100</bold></highlight> may include the Internet with network <highlight><bold>101</bold></highlight> representing a worldwide collection of networks and gateways that use various protocols to communicate with one another, such as Lightweight Directory Access Protocol (LDAP), Transport Control Protocol/Internet Protocol (TCP/IP), Hypertext Transport Protocol (HTTP), Wireless Application Protocol (WAP), etc. Of course, distributed data processing system <highlight><bold>100</bold></highlight> may also include a number of different types of networks, such as, for example, an intranet, a local area network (LAN), or a wide area network (WAN). For example, server <highlight><bold>102</bold></highlight> directly supports client <highlight><bold>109</bold></highlight> and network <highlight><bold>110</bold></highlight>, which incorporates wireless communication links. Network-enabled phone <highlight><bold>111</bold></highlight> connects to network <highlight><bold>110</bold></highlight> through wireless link <highlight><bold>112</bold></highlight>, and PDA <highlight><bold>113</bold></highlight> connects to network <highlight><bold>110</bold></highlight> through wireless link <highlight><bold>114</bold></highlight>. Phone <highlight><bold>111</bold></highlight> and PDA <highlight><bold>113</bold></highlight> can also directly transfer data between themselves across wireless link <highlight><bold>115</bold></highlight> using an appropriate technology, such as Bluetooth&trade; wireless technology, to create so-called personal area networks (PAN) or personal ad-hoc networks. In a similar manner, PDA <highlight><bold>113</bold></highlight> can transfer data to PDA <highlight><bold>107</bold></highlight> via wireless communication link <highlight><bold>116</bold></highlight>. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> The present invention could be implemented on a variety of hardware platforms; <cross-reference target="DRAWINGS">FIG. 1A</cross-reference> is intended as an example of a heterogeneous computing environment and not as an architectural limitation for the present invention. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 1B, a</cross-reference> diagram depicts a typical computer architecture of a data processing system, such as those shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>A, in which the present invention may be implemented. Data processing system <highlight><bold>120</bold></highlight> contains one or more central processing units (CPUs) <highlight><bold>122</bold></highlight> connected to internal system bus <highlight><bold>123</bold></highlight>, which interconnects random access memory (RAM) <highlight><bold>124</bold></highlight>, read-only memory <highlight><bold>126</bold></highlight>, and input/output adapter <highlight><bold>128</bold></highlight>, which supports various I/O devices, such as printer <highlight><bold>130</bold></highlight>, disk units <highlight><bold>132</bold></highlight>, or other devices not shown, such as a audio output system, etc. System bus <highlight><bold>123</bold></highlight> also connects communication adapter <highlight><bold>134</bold></highlight> that provides access to communication link <highlight><bold>136</bold></highlight>. User interface adapter <highlight><bold>148</bold></highlight> connects various user devices, such as keyboard <highlight><bold>140</bold></highlight> and mouse <highlight><bold>142</bold></highlight>, or other devices not shown, such as a touch screen, stylus, microphone, etc. Display adapter <highlight><bold>144</bold></highlight> connects system bus <highlight><bold>123</bold></highlight> to display device <highlight><bold>146</bold></highlight>. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> Those of ordinary skill in the art will appreciate that the hardware in <cross-reference target="DRAWINGS">FIG. 1B</cross-reference> may vary depending on the system implementation. For example, the system may have one or more processors, including a digital signal processor (DSP) and other types of special purpose processors, and one or more types of volatile and non-volatile memory. Other peripheral devices may be used in addition to or in place of the hardware depicted in <cross-reference target="DRAWINGS">FIG. 1B</cross-reference>. The depicted examples are not meant to imply architectural limitations with respect to the present invention. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> In addition to being able to be implemented on a variety of hardware platforms, the present invention may be implemented in a variety of software environments. A typical operating system may be used to control program execution within each data processing system. For example, one device may run a Unix&trade; operating system, while another device contains a simple Java&trade; runtime environment. A representative computer platform may include a browser, which is a well known software application for accessing hypertext documents in a variety of formats, such as graphic files, word processing files, Extensible Markup Language (XML), Hypertext Markup Language (HTML), Handheld Device Markup Language (HDML), Wireless Markup Language (WML), and various other formats and types of files. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> The present invention may be implemented on a variety of hardware and software platforms, as described above. More specifically, though, the present invention is directed to a system and a methodology for facilitating object serialization and deserialization such that forward and backward compatibility can be maintained for flattened objects across different versions of a class. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> For the purposes of this invention, Java&trade; is used as the programming language to describe the problem and present the preferred embodiment. However, this invention is not restricted to the Java&trade; programming language and could be implemented in any environment that serializes and deserializes object instances. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> In general, a serialization compatibility problem is created when an attribute is added to a class. The present invention solves certain serialization compatibility issues by associating a version number or identifier to each attribute. During serialization and deserialization, version numbers of each attribute are compared. For forward compatibility, i.e., when a newer class attempts to read older class data, the older class data is read in a manner that is determined by its version number while new attributes within the newer version are provided default values. For backward compatibility, i.e., when an older class attempts to read newer class data, newer attributes can be ignored. It should be noted that the examples discuss version numbers, but one of ordinary skill in the art would understand that various type of identifiers, including numbers, could also be used. The methodology is hereinafter described in more detail with respect to the remaining figures. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 2A, a</cross-reference> diagram shows a simple Person class that might be found in the prior art. <cross-reference target="DRAWINGS">FIG. 2A</cross-reference> contains a representation of two versions of the Person class. For the following examples, these two versions of the Person class will be used to demonstrate typical serialization and deserialization versus the manner in which the present invention performs serialization and deserialization. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> A preliminary Version 1 of the Person class <highlight><bold>202</bold></highlight> has a preliminary set of attributes <highlight><bold>204</bold></highlight>. A subsequent Version 2 of the Person class <highlight><bold>206</bold></highlight> has a modified set of attributes <highlight><bold>208</bold></highlight> that includes an additional attribute that has been added to the class definition, &ldquo;middleName&rdquo; attribute <highlight><bold>210</bold></highlight>. In <cross-reference target="DRAWINGS">FIG. 2</cross-reference>A, the attributes are shown without values. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> With reference now to FIGS. <highlight><bold>2</bold></highlight>B-<highlight><bold>2</bold></highlight>C, a set of diagrams show the operation of a standard serialization mechanism on two versions of the Person class in which the same version of the class is used for both serialization and deserialization. In FIGS. <highlight><bold>2</bold></highlight>B-<highlight><bold>2</bold></highlight>C, the attributes are associated with values, which represent the actual value given to the attributes of the class instance (or object). </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2B</cross-reference> shows object <highlight><bold>210</bold></highlight>, which is structured in accordance with Version 1 of the Person class. Object <highlight><bold>210</bold></highlight> undergoes serialization operation <highlight><bold>212</bold></highlight> to create flattened object data stream <highlight><bold>214</bold></highlight>. Data stream <highlight><bold>214</bold></highlight> then undergoes deserialization operation <highlight><bold>216</bold></highlight> to inflate object <highlight><bold>218</bold></highlight>, which can be seen to be a copy of the original object <highlight><bold>210</bold></highlight>. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> Data stream <highlight><bold>214</bold></highlight> is an abstraction of the actual destination of the serialized object and is not a byte-wise copy of an actual serialized object. The flattened object data stream can be formatted in many ways that may be dependent upon a variety of factors with respect to the runtime environments, the reading/writing applications, etc., that use the object data stream. Data stream <highlight><bold>214</bold></highlight> represents a file, a network connection through which the object is transmitted to another computer, or possibly a memory location where the object is held. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2C</cross-reference> shows object <highlight><bold>220</bold></highlight>, which is structured in accordance with Version 2 of the Person class. Object <highlight><bold>220</bold></highlight> undergoes serialization operation <highlight><bold>222</bold></highlight> to create flattened object data stream <highlight><bold>224</bold></highlight>. Data stream <highlight><bold>224</bold></highlight> then undergoes deserialization operation <highlight><bold>226</bold></highlight> to inflate object <highlight><bold>228</bold></highlight>, which can be seen to be a copy of the original object <highlight><bold>220</bold></highlight>. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> The simplest and most frequent scenario for serializing an object occurs when the version of the class that is read out of the stream is the same as the version that was written. This scenario, as it would appear using the standard serialization mechanism, is represented in FIGS. <highlight><bold>2</bold></highlight>B-<highlight><bold>2</bold></highlight>C. As the figures show, when the object is serialized, information that identifies the object&apos;s class and the value of the object&apos;s attributes are placed into the object stream. When the object is deserialized, the class identifier is read, and an object is instantiated in accordance with the identified class. The object is then initialized with the attribute values as they are read out of the stream. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> With reference now to FIGS. <highlight><bold>3</bold></highlight>A-<highlight><bold>3</bold></highlight>B, a set of diagrams show the operation of a standard serialization mechanism on two versions of the Person class in which a different version of the class is used for serialization and deserialization on the same object stream. While the standard serialization mechanism is very simple and straightforward, it has an inherent problem when confronted with operating on different versions of a class. FIGS. <highlight><bold>3</bold></highlight>A-<highlight><bold>3</bold></highlight>B display two scenarios in which default serialization operations result in an error. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3A</cross-reference> shows an instance of a newer version of a class that is written to the data stream and a back-level version that is available when the information is read out of the stream. This type of scenario might occur when an application on the receiving end of a serialization stream has not been updated with a modified version of a class. Object <highlight><bold>302</bold></highlight> is structured in accordance with Version 2 of the Person class and undergoes serialization operation <highlight><bold>304</bold></highlight> to create flattened object data stream <highlight><bold>306</bold></highlight>. However, when data stream <highlight><bold>306</bold></highlight> then undergoes deserialization operation <highlight><bold>308</bold></highlight> in an attempt to instantiate object <highlight><bold>310</bold></highlight>, which is structured in accordance with Version 1 of the Person class, an error would be detected, and the deserialization operation would not be completed. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3B</cross-reference> shows a similar situation in which an older version of the class is written to the data stream, and when the data is read out of the data stream, an attempt is made to instantiate an object in accordance with a more recent version of the object&apos;s class. This type of scenario might occur when an application on the writing or transmitting end of a serialization stream has not been updated with the most recent version of a class, yet the receiving application has been updated. Object <highlight><bold>322</bold></highlight> is structured in accordance with Version 1 of the Person class and undergoes serialization operation <highlight><bold>324</bold></highlight> to create flattened object data stream <highlight><bold>326</bold></highlight>. However, when data stream <highlight><bold>326</bold></highlight> then undergoes deserialization operation <highlight><bold>328</bold></highlight> in an attempt to instantiate object <highlight><bold>330</bold></highlight>, which is structured in accordance with Version 2 of the Person class, an error would be detected and the deserialization operation would not be completed. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> In both scenarios in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>A and <cross-reference target="DRAWINGS">FIG. 3</cross-reference>B, the serialization fails when the object data is read out of the data stream because the information contained within the data stream is structured differently than expected. While these scenarios do not occur in the usual operation of an application, they may occur at any time after updates are made to objects that are being serialized. Distributed applications, i.e., those applications in which a part of the application runs on one computer and another part runs elsewhere, are particularly susceptible to this serialization problem since most of their communication may comprise object streams. To remedy the situation, costly and time-consuming updates are required to the application on every system in order to avoid the serialization errors using the standard serialization mechanism. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> With reference now to FIGS. <highlight><bold>4</bold></highlight>A-<highlight><bold>4</bold></highlight>D, a set of diagrams show the operation of a custom serialization mechanism for versions of the exemplary Person class in accordance with the present invention. The custom serialization mechanism of the present invention corrects the versioning problems described above with respect to FIGS. <highlight><bold>3</bold></highlight>A-<highlight><bold>3</bold></highlight>B by associating additional information with attributes in the stream. FIGS. <highlight><bold>4</bold></highlight>A-<highlight><bold>4</bold></highlight>D displays the same scenarios as above except that the serialization mechanism of the present invention is used to flatten and inflate the objects. In addition to each class receiving a version number, as is performed in the prior art, each attribute is also given a version number to identify the class version in which the attribute first appeared. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> The values preceding the attributes in the data stream within parentheses are the version numbers. Again, the examples merely represent data streams and are not byte-wise copies of actual data streams. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> In the present invention, when an object is written to a flattened object data stream, attribute version numbers are also placed in the data stream in addition to the class version number. When the object is later read from the data stream, the attribute version number is compared to the current class version number of the newly created object and not to the class version number from the data stream. Only those attributes that are usable within the current class version are used for the new object. If the object that is instantiated when the class identifier is read from the stream is of a newer class version than the class version of the object that was serialized into the stream, then any new attributes are initialized to a default value. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4A</cross-reference> shows object <highlight><bold>402</bold></highlight>, which is structured in accordance with Version 1 of the Person class. Object <highlight><bold>402</bold></highlight> undergoes serialization operation <highlight><bold>404</bold></highlight> to create flattened object data stream <highlight><bold>406</bold></highlight>. At some later point in time, data stream <highlight><bold>406</bold></highlight> then undergoes deserialization operation <highlight><bold>408</bold></highlight> to inflate newly instantiated object <highlight><bold>410</bold></highlight>, which can be seen to be a copy of the original object <highlight><bold>402</bold></highlight>. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4B</cross-reference> shows object <highlight><bold>432</bold></highlight>, which is structured in accordance with Version 2 of the Person class. Object <highlight><bold>432</bold></highlight> undergoes serialization operation <highlight><bold>434</bold></highlight> to create flattened object data stream <highlight><bold>436</bold></highlight>. At some later point in time, data stream <highlight><bold>436</bold></highlight> then undergoes deserialization operation <highlight><bold>438</bold></highlight> to inflate newly instantiated object <highlight><bold>440</bold></highlight>, which can be seen to be a copy of the original object <highlight><bold>432</bold></highlight>. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4C</cross-reference> shows object <highlight><bold>452</bold></highlight>, which is structured in accordance with Version 2 of the Person class, which includes the &ldquo;middleName&rdquo; attribute that was introduced in Version 2 of the Person class but did not exist in Version 1 of the Person class. Object <highlight><bold>452</bold></highlight> undergoes serialization operation <highlight><bold>454</bold></highlight> to create flattened object data stream <highlight><bold>456</bold></highlight>. At some later point in time, data stream <highlight><bold>456</bold></highlight> then undergoes deserialization operation <highlight><bold>458</bold></highlight> in an attempt to read the attribute values into newly instantiated object <highlight><bold>460</bold></highlight>. However, the receiving/reading application has instantiated object <highlight><bold>460</bold></highlight> as an object of Version 1 of the Person class, whereas data stream <highlight><bold>456</bold></highlight> was created by flattening an object of Version 2 of the Person class. When the &ldquo;middleName&rdquo; attribute is encountered, its Version 2 tag is detected to be greater than the version of the object into which it is being read, and the attribute value is ignored with respect to object <highlight><bold>460</bold></highlight>. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> Although in the case of <cross-reference target="DRAWINGS">FIG. 4C</cross-reference> some information is lost, the receiving/reading application was not expecting the information, so from the perspective of that application, no information is lost. In addition, no error occurs upon detecting a version mismatch. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4D</cross-reference> shows object <highlight><bold>472</bold></highlight>, which is structured in accordance with Version 1 of the Person class, which does not include the &ldquo;middleName&rdquo; attribute because it was introduced in Version 2 of the Person class and did not exist in Version 1 of the Person class. Object <highlight><bold>472</bold></highlight> undergoes serialization operation <highlight><bold>474</bold></highlight> to create flattened object data stream <highlight><bold>476</bold></highlight>. At some later point in time, data stream <highlight><bold>476</bold></highlight> then undergoes deserialization operation <highlight><bold>478</bold></highlight> in an attempt to read the attribute values into newly instantiated object <highlight><bold>480</bold></highlight>. However, the receiving/reading application has instantiated object <highlight><bold>480</bold></highlight> as an object of Version 2 of the Person class, whereas data stream <highlight><bold>476</bold></highlight> was created by flattening an object of Version 1 of the Person class. The &ldquo;middleName&rdquo; attribute of object <highlight><bold>480</bold></highlight> is associated with a Version 2 tag, which is detected to be greater than the version of the object from which the data stream is being read, and the attribute value is given a default value. The deserialization object may then proceed to read attribute value from the data stream for the other attributes of object <highlight><bold>480</bold></highlight> without further interference. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> Although in the case of <cross-reference target="DRAWINGS">FIG. 4D</cross-reference> some information is not received that might be received in other scenarios, the receiving/reading application should be able to proceed because all attributes have a valid value. This situation should be tolerable because the attribute that received the default value did not exist in the previous version of the class; therefore, the attribute value should not be regarded as critical. In other words, if the first version of the class was acceptable, then subsequent versions of the class should be tolerable, and the application developer should keep such potential restrictions in mind when modifying class definitions. The present invention solves a problem that exists within the prior art because no error occurs upon detecting a version mismatch. If the application developer or user desires to be notified when a version mismatch is detected, then an error message of some form can be generated or logged. In addition, a dialog box could be presented if the application has a graphical user interface, and the user of the application might be given an option of proceeding or halting when a version mismatch is detected. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 5, a</cross-reference> simple object model depicts a set of classes for illustrating an object-oriented methodology for supporting serialization and deserialization with version management in accordance with a preferred embodiment of the present invention. In the preferred embodiment, each class is responsible for serializing and deserializing its own attributes. While most of this logic can be placed in a common superclass, the implementation classes must provide the logic pertaining to the specifics of their own attributes. </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> depicts a simple object model. Customer class <highlight><bold>502</bold></highlight> is a subclass of Person class <highlight><bold>504</bold></highlight>, which is a subclass of BaseObject class <highlight><bold>506</bold></highlight>. Each class defines a versionID attribute that contains the version identifier for the particular class. Each class then defines its instance attributes, i.e., the attributes that pertain to the business function of the class. Each instance attribute is paired with another attribute that represents the attribute&apos;s version information. The naming convention for the version attributes that has been used within this example is to append &ldquo;VersionID&rdquo; to the paired instance attribute&apos;s name. For example, the BaseObject class defines an instance attribute named &ldquo;databaseID&rdquo;; following the naming convention, the version attribute that is associated with attribute &ldquo;databaseID&rdquo; is named &ldquo;databaseIdVersionID&rdquo;. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> In the preferred embodiment of the present invention, each Java&trade; class implements the &ldquo;writeObject( )&rdquo; and &ldquo;readObject( )&rdquo; methods to perform the object serialization and deserialization. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> Within these methods, each class is responsible for writing and reading their attributes to and from a flattened object data stream. For example, from the class representation in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>, the Customer class writes and reads the contents of the &ldquo;customerNumber&rdquo; attribute to and from the data stream but does take any actions to serialize or deserialize the &ldquo;name&rdquo; and the &ldquo;databaseID&rdquo; attributes in the other classes. The serialization of the &ldquo;name&rdquo; and &ldquo;databaseID&rdquo; attributes is left to the classes in which those are defined, namely Person and BaseObject, respectively. </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> In accordance with standard Java&trade; serialization methodology, when an object is serialized, the &ldquo;writeObject( )&rdquo; method of the object&apos;s class would be invoked, which would receive the stream instance as an input argument so that the object&apos;s contents can be placed in the stream. However, with the present invention, when the &ldquo;writeObject( )&rdquo; method is called, as a first action, the method invokes the &ldquo;writeObject( )&rdquo; method of its superclass, which ensures that the superclass&apos; attributes are placed in the stream; all of the attributes of the superclass (or superclasses) are placed into the stream until the base class is reached. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> Next, the methodology described above with respect to FIGS. <highlight><bold>4</bold></highlight>A-<highlight><bold>4</bold></highlight>D is performed so that the object&apos;s attribute information is written to the stream. Every instance attribute written to the stream is an Object. No Java&trade; primitive data types are written to the stream so that every attribute in the stream can be handled generically. For example, assume that an instance of the Customer class is serialized to the flattened object data stream. After invoking the superclass &ldquo;writeObject( )&rdquo; method, which in this case would be the &ldquo;writeObject( )&rdquo; method for the Person class, which in turn would invoke the &ldquo;writeObject( )&rdquo; method of the BaseObject class, the &ldquo;writeObject( )&rdquo; method defined by the Customer class would: (1) write the value of the Customer class&apos; &ldquo;versionID&rdquo; object; (2) write the attribute count of the Customer class, which in this case is equal to one; (3) write the value of &ldquo;customerNumberVersionID&rdquo;; and (4) write the value of the &ldquo;customerNumber&rdquo; attribute. </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> When an object is deserialized, the &ldquo;readObject( )&rdquo; method would be invoked with a stream instance containing a flattened object data stream for the serialized object. Similar to the operations that occur during serialization, with the present invention, when the &ldquo;readObject( )&rdquo; method is called, as a first action, the method invokes the &ldquo;readObject( )&rdquo; method of its superclass, which insures that the superclass&apos; attributes are retrieved from the stream. </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> Next, the methodology described above with respect to FIGS. <highlight><bold>4</bold></highlight>A-<highlight><bold>4</bold></highlight>D for deserializing an object is performed so that the object&apos;s attribute information is read from the stream. Continuing with the example of using the Customer class, after invoking the &ldquo;readObject( )&rdquo; method on the superclass, which in this case would be the &ldquo;readObject( )&rdquo; method for the Person class, the Customer class&apos; &ldquo;versionID&rdquo; attribute and the attribute count would be read from the data stream. Based on the attribute count, each version attribute and instance attribute are read from the stream. Because the order in which the attributes have been written is known, i.e., there is an implicit ordering to manner in which the attributed values are placed into and read from the data stream, the values that are read from the stream can be mapped to the attributes defined by the class. </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 6A, a</cross-reference> flowchart depicts a serialization process in accordance with a preferred embodiment of the present invention. At some point in time, a &ldquo;writeObject( )&rdquo; method is invoked to serialize an object into a particular flattened object data stream, as described with respect to <cross-reference target="DRAWINGS">FIG. 5</cross-reference> above; it may be assumed that the &ldquo;writeObject( )&rdquo; method for the object&apos;s superclass has already been invoked, which would have invoked the &ldquo;writeObject( )&rdquo; method of its superclass and so on until the BaseObject class has been reached such that all of the attributes of the superclasses are placed into the stream. The serialization process begins by writing the class identifier into the data stream (step <highlight><bold>602</bold></highlight>), followed by writing the class version number (step <highlight><bold>604</bold></highlight>) and the number of attributes for the class into the data stream (step <highlight><bold>606</bold></highlight>). A loop is then entered in which each attribute of the class is processed. The next unwritten attribute of the class is determined (step <highlight><bold>608</bold></highlight>). The attribute&apos;s version number is written to the data stream (step <highlight><bold>610</bold></highlight>), and then the attribute&apos;s value is written to the data stream (step <highlight><bold>612</bold></highlight>). A determination is then made as to whether or not any unwritten attributes remain to be processed (step <highlight><bold>614</bold></highlight>). If so, then the process branches back to step <highlight><bold>608</bold></highlight> to process another unwritten attribute. Otherwise, if there are no unwritten attributes to be processed, then the serialization process is complete. </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 6B, a</cross-reference> flowchart depicts a deserialization process in accordance with a preferred embodiment of the present invention. At some point in time, a &ldquo;readObject( )&rdquo; method is invoked to deserialize an object from a particular flattened object data stream, as described with respect to <cross-reference target="DRAWINGS">FIG. 5</cross-reference> above. The deserialization process begins by reading the class identifier from the data stream (step <highlight><bold>622</bold></highlight>), after which an instance of the class is created using the class identifier (step <highlight><bold>624</bold></highlight>). The version number of the class of the flattened object is then read from the data stream (step <highlight><bold>626</bold></highlight>), which is used for subsequent comparisons. </paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> The number of attributes for the object is then read from the data stream (step <highlight><bold>628</bold></highlight>), which is then used as a control variable to loop through the remaining attributes in the data stream for the current object (steps <highlight><bold>630</bold></highlight>-<highlight><bold>638</bold></highlight>). It should be noted that the attribute count was not depicted in FIGS. <highlight><bold>4</bold></highlight>A-<highlight><bold>4</bold></highlight>D, and other equivalent indicators could be inserted into the data stream to control the demarcation of the attributes for the current object within the data stream. </paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> For each attribute, the attribute version number is read (step <highlight><bold>630</bold></highlight>), followed by the attribute value for the attribute (step <highlight><bold>632</bold></highlight>). A determination is then made as to whether the version number of the attribute is less than or equal to the version number of the class for the newly instantiated object (step <highlight><bold>634</bold></highlight>). If the version number of the attribute is indeed less than or equal to the version number of the newly instantiated object, then the attribute value that has been read from the data stream is added to the list of attribute values to be assigned to the attributes within the newly instantiated object (step <highlight><bold>636</bold></highlight>). If the version number of the attribute is greater than the version number of the class for the newly instantiated object, then the attribute may be ignored, and the loop continues. In either case, a determination is then made as to whether or not there are more attributes in the serialized data stream to be processed (step <highlight><bold>638</bold></highlight>). If so, then the process branches back to step <highlight><bold>630</bold></highlight>; otherwise, the process continues. </paragraph>
<paragraph id="P-0068" lvl="0"><number>&lsqb;0068&rsqb;</number> After the process has looped through all of the attributes in the data stream, then a determination is made as to whether or not the version number of the flattened object that was read from the data stream is less than the class for the newly instantiated object (step <highlight><bold>640</bold></highlight>). If not, then the process is complete; if so, then the process sets all of the newer attributes to a default attribute value (step <highlight><bold>642</bold></highlight>), which may require a controlled loop through a set of attributes, after which the process is complete. </paragraph>
<paragraph id="P-0069" lvl="0"><number>&lsqb;0069&rsqb;</number> As shown above, the present invention uses customized serialization and deserialization methods to control the input and output of attribute values to and from a serialized data stream. As mentioned briefly above, these customized methods use an implicit ordering to identify the attribute values in a preferred embodiment. Alternatively, the serialization and deserialization methods may input and output identifiers with the attribute values so that an implicit ordering is not required. By adding attribute identifiers into the stream, one increases the robustness and opportunity for checking for errors within the data stream, at the expense of increasing the size of the data stream. This is a trade-off that should be considered within the constraints of the system. </paragraph>
<paragraph id="P-0070" lvl="0"><number>&lsqb;0070&rsqb;</number> To ensure that an implicit ordering mechanism operates correctly, the serialization method and the deserialization method, e.g., &ldquo;writeObject( )&rdquo; and &ldquo;readObject( )&rdquo;, would read and write attribute values in the same order. </paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> In order to ensure that the implicit ordering mechanism operates in a straightforward manner, new attributes that are added to subsequent versions of a class could be represented within a serialized data stream by appending those values at the end of a data stream. In addition, when a software developer desires to discard an attribute from a class, the attribute is not entirely removed from all operations with respect to the data stream. Instead, an empty placeholder continues to be written and read from the data stream to ensure compatibility between differing versions of the serialization and deserialization methods that are using an implicit ordering mechanism. In this way, the data attributes are not truly removed from the class, but rather, those attributes cease to be utilized within the application. </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> For example, in the description of FIGS. <highlight><bold>4</bold></highlight>C-<highlight><bold>4</bold></highlight>D above, Version 1 of the Person class differed from Version 2 of the Person class with the inclusion of a &ldquo;middleName&rdquo; attribute in Version <highlight><bold>2</bold></highlight>, and this attribute was inserted into the data stream between other Version 1 attributes. If the present invention were to be implemented through the use of an implicit ordering mechanism, the &ldquo;middleName&rdquo; attribute would be appended at the end of the data stream. The implicit ordering mechanism is shown in more detail below with respect to the remaining figures. </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> With reference now to FIGS. <highlight><bold>7</bold></highlight>A-<highlight><bold>7</bold></highlight>D, a set of diagrams shows evolving versions of the Person class in conjunction with serialized data streams and an attribute value list that may be used as a data structure to assist with interpreting the implicit ordering of a data stream in accordance with a preferred embodiment of the present invention. Referring to <cross-reference target="DRAWINGS">FIG. 7</cross-reference>A, object <highlight><bold>702</bold></highlight> is structured in accordance with Version 1 of the Person class in a manner similar to object <highlight><bold>202</bold></highlight> shown in <cross-reference target="DRAWINGS">FIG. 2A</cross-reference>. Object <highlight><bold>702</bold></highlight> may represent a Version 1 Person object either prior to being flattened or after being inflated, while serialized data stream <highlight><bold>704</bold></highlight> represents the object after it has been flattened. </paragraph>
<paragraph id="P-0074" lvl="0"><number>&lsqb;0074&rsqb;</number> While either writing or reading object <highlight><bold>702</bold></highlight> from data stream <highlight><bold>704</bold></highlight>, the attributes for object <highlight><bold>702</bold></highlight> may be stored within attribute value list <highlight><bold>706</bold></highlight>, which may be implemented as a multidimensional array. Attribute value list <highlight><bold>706</bold></highlight> contains attribute values <highlight><bold>708</bold></highlight> and their associated version numbers <highlight><bold>710</bold></highlight>. Empty attributes <highlight><bold>712</bold></highlight> and unused version numbers <highlight><bold>714</bold></highlight> may or may not be used within an attribute value list. Version numbers <highlight><bold>710</bold></highlight> may be statically defined within the serialization and deserialization methods. </paragraph>
<paragraph id="P-0075" lvl="0"><number>&lsqb;0075&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 7</cross-reference>B, object <highlight><bold>722</bold></highlight> is structured in accordance with Version 2 of the Person class in a manner similar to object <highlight><bold>206</bold></highlight> shown in <cross-reference target="DRAWINGS">FIG. 2A</cross-reference>. Object <highlight><bold>722</bold></highlight> may represent a Version 2 Person object either prior to being flattened or after being inflated, while serialized data stream <highlight><bold>724</bold></highlight> represents the object after it has been flattened. </paragraph>
<paragraph id="P-0076" lvl="0"><number>&lsqb;0076&rsqb;</number> While either writing or reading object <highlight><bold>722</bold></highlight> from data stream <highlight><bold>724</bold></highlight>, the attributes for object <highlight><bold>722</bold></highlight> may be stored within attribute value list <highlight><bold>726</bold></highlight>. Attribute value list <highlight><bold>726</bold></highlight> contains attribute values <highlight><bold>728</bold></highlight> and their associated version numbers <highlight><bold>730</bold></highlight>. Version 2 of the Person class has added the &ldquo;middleName&rdquo; attribute, which is appended to the attribute value list. When changes are made to class to create a different version of the class, the software developer modifies the code for the serialization and deserialization methods in a manner such that the attribute values are stored and retrieved from the proper locations within the attribute value list. </paragraph>
<paragraph id="P-0077" lvl="0"><number>&lsqb;0077&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 7</cross-reference>C, object <highlight><bold>742</bold></highlight> is structured in accordance with Version <highlight><bold>3</bold></highlight> of the Person class. Object <highlight><bold>742</bold></highlight> may represent a Version <highlight><bold>3</bold></highlight> Person object either prior to being flattened or after being inflated, while serialized data stream <highlight><bold>744</bold></highlight> represents the object after it has been flattened. </paragraph>
<paragraph id="P-0078" lvl="0"><number>&lsqb;0078&rsqb;</number> While either writing or read object <highlight><bold>742</bold></highlight> from data stream <highlight><bold>744</bold></highlight>, the attributes for object <highlight><bold>742</bold></highlight> may be stored within attribute value list <highlight><bold>746</bold></highlight>. Attribute value list <highlight><bold>746</bold></highlight> contains attribute values <highlight><bold>748</bold></highlight> and their associated version numbers <highlight><bold>750</bold></highlight>. Version <highlight><bold>3</bold></highlight> of the Person class has added the &ldquo;bldg&rdquo; attribute to Version 2 of the Person class for specifying a building number, which is also appended to the attribute value list. As should be apparent, when new attributes are added to a class, they are stored within the data structure for the attribute value list such that an implicit ordering is maintained across versions of the class. </paragraph>
<paragraph id="P-0079" lvl="0"><number>&lsqb;0079&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 7</cross-reference>D, object <highlight><bold>762</bold></highlight> is structured in accordance with Version 4 of the Person class. Object <highlight><bold>762</bold></highlight> may represent a Version 4 Person object either prior to being flattened or after being inflated, while serialized data stream <highlight><bold>764</bold></highlight> represents the object after it has been flattened. </paragraph>
<paragraph id="P-0080" lvl="0"><number>&lsqb;0080&rsqb;</number> While either writing or read object <highlight><bold>762</bold></highlight> from data stream <highlight><bold>764</bold></highlight>, the attributes for object <highlight><bold>762</bold></highlight> may be stored within attribute value list <highlight><bold>766</bold></highlight>. Attribute value list <highlight><bold>766</bold></highlight> contains attribute values <highlight><bold>768</bold></highlight> and their associated version numbers <highlight><bold>770</bold></highlight>. Version 4 of the Person class no longer contains the &ldquo;middleName&rdquo; attribute of the Person class. As should be apparent, when attributes are deleted from a class, the data stream and the data structure for the attribute value list retain a placeholder for the removed attribute such that an implicit ordering is maintained across versions of the class. In this example, version number <highlight><bold>768</bold></highlight> has been set to zero as a flag that the attribute has been removed. </paragraph>
<paragraph id="P-0081" lvl="0"><number>&lsqb;0081&rsqb;</number> By retaining placeholders for removed attributes, an implicit ordering is maintaining across versions of a class, and the deserialization method can readily map attributes between different versions of objects when there is a mismatch between a flattened object and the newly instantiated object that is being inflated using the values from the flattened object&apos;s data stream. When necessary, attributes can be given default values. It should be apparent to one of ordinary skill in the art that temporary data structures, such as an object array, can be employed to implement the process described above. </paragraph>
<paragraph id="P-0082" lvl="0"><number>&lsqb;0082&rsqb;</number> The advantages of the present invention should be apparent in view of the detailed description of the invention that is provided above. In the prior art, an error would be thrown when a version mismatch was detected between the flattened and the inflated data objects. In contrast, the present invention associates version numbers or version identifiers with each attribute and places the attribute version numbers into a flattened object&apos;s data stream. When the object is later read from the data stream, the attribute version numbers can be used to determine the manner in which the attribute values should be processed. Only those attribute values that are appropriate for the current class version are used for the new object, while missing attribute values can be set to default values. Hence, the present invention does not return an error when version mismatches are detected. </paragraph>
<paragraph id="P-0083" lvl="0"><number>&lsqb;0083&rsqb;</number> It is important to note that while the present invention has been described in the context of a fully functioning data processing system, those of ordinary skill in the art will appreciate that some of the processes associated with the present invention are capable of being distributed in the form of instructions in a computer readable medium and a variety of other forms, regardless of the particular type of signal bearing media actually used to carry out the distribution. Examples of computer readable media include media such as EPROM, ROM, tape, paper, floppy disc, hard disk drive, RAM, and CD-ROMs and transmission-type media, such as digital and analog communications links. </paragraph>
<paragraph id="P-0084" lvl="0"><number>&lsqb;0084&rsqb;</number> The description of the present invention has been presented for purposes of illustration but is not intended to be exhaustive or limited to the disclosed embodiments. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiments were chosen to explain the principles of the invention and its practical applications and to enable others of ordinary skill in the art to understand the invention in order to implement various embodiments with various modifications as might be suited to other contemplated uses. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method for object-oriented management of serializable objects, the method comprising: 
<claim-text>identifying an object, wherein the object comprises a set of attributes; </claim-text>
<claim-text>associating a class version identifier with the object, wherein the class version identifier identifies the object as an instance of a specific version of a class; and </claim-text>
<claim-text>associating an attribute version identifier with an attribute in the set of attributes. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein an attribute version identifier represents a version of a class for an associated attribute in which the associated attribute was initially declared within the class. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> further comprising: 
<claim-text>writing a data stream representing an object serialization of the object, wherein the data stream comprises the class version identifier of the object, an attribute value for an attribute in the set of attributes, and an attribute version identifier for an attribute in the set of attributes. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference> further comprising: 
<claim-text>writing a class identifier for the class of the object into the data stream. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference> further comprising: 
<claim-text>writing an attribute count indicating a number of attributes from the set of attributes that were written into the data stream. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> further comprising: 
<claim-text>reading a data stream representing a serialized object, wherein the data stream comprises a serialized class version identifier, a set of serialized attribute values, and a set of serialized attribute version identifiers, wherein serialized attribute version identifiers in the set of serialized attribute version identifiers are paired with serialized attribute values in the set of serialized attribute values. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference> further comprising: 
<claim-text>reading a class identifier for the serialized object from the data stream; and </claim-text>
<claim-text>instantiating the object in accordance with the class identifier, wherein the class version identifier of the object and the serialized class version identifier of the serialized object may differ. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference> further comprising: 
<claim-text>reading an attribute count for the set of serialized attribute values from the data stream. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference> further comprising: 
<claim-text>mapping attributes between the object and the serialized object; and </claim-text>
<claim-text>storing serialized attribute values from the data stream in the object. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference> further comprising: 
<claim-text>in response to a determination that a serialized attribute version identifier is greater than or subsequent to the class version identifier of the object, refraining from storing in the object a serialized attribute value associated with the serialized attribute version identifier. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference> further comprising: 
<claim-text>in response to a determination that the class version identifier of the object is greater than or subsequent to the serialized class version identifier, storing default attribute values in the object for attributes in the object that are associated with an attribute version identifier that is greater than or subsequent to the serialized class version identifier. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. A method for providing backwards and forwards compatibility between different versions of serialized object data, the method comprising: 
<claim-text>identifying an object, wherein the object comprises a set of attributes, wherein each attribute in the set of attributes is associated with a version identifier, and wherein the object is an instance of a first version of a class; </claim-text>
<claim-text>writing a data stream representing serialization of the object&apos;s attributes and associated version identifiers; </claim-text>
<claim-text>reading a data stream representing a serialized object into a new object instance of a second version of a class; and </claim-text>
<claim-text>refraining from storing attributes from the data stream into the new object instance that are not represented in the new object instance while reading the data stream. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference> further comprising: 
<claim-text>specifying default values for attributes in the new object instance for which attribute values were not read from the data stream. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. A computer program product on a computer readable medium for use in a data processing system for object-oriented management of serializable objects, the computer program product comprising: 
<claim-text>instructions for identifying an object, wherein the object comprises a set of attributes; </claim-text>
<claim-text>instructions for associating a class version identifier with the object, wherein the class version identifier identifies the object as an instance of a specific version of a class; and </claim-text>
<claim-text>instructions for associating an attribute version identifier with an attribute in the set of attributes. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The computer program product of <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference> wherein an attribute version identifier represents a version of a class for an associated attribute in which the associated attribute was initially declared within the class. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The computer program product of <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference> further comprising: 
<claim-text>instructions for writing a data stream representing an object serialization of the object, wherein the data stream comprises the class version identifier of the object, an attribute value for an attribute in the set of attributes, and an attribute version identifier for an attribute in the set of attributes. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The computer program product of <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference> further comprising: 
<claim-text>instructions for writing a class identifier for the class of the object into the data stream. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The computer program product of <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference> further comprising: 
<claim-text>instructions for writing an attribute count indicating a number of attributes from the set of attributes that were written into the data stream. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The computer program product of <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference> further comprising: 
<claim-text>instructions for reading a data stream representing a serialized object, wherein the data stream comprises a serialized class version identifier, a set of serialized attribute values, and a set of serialized attribute version identifiers, wherein serialized attribute version identifiers in the set of serialized attribute version identifiers are paired with serialized attribute values in the set of serialized attribute values. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The computer program product of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference> further comprising: 
<claim-text>instructions for reading a class identifier for the serialized object from the data stream; and </claim-text>
<claim-text>instructions for instantiating the object in accordance with the class identifier, wherein the class version identifier of the object and the serialized class version identifier of the serialized object may differ. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The computer program product of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference> further comprising: 
<claim-text>instructions for reading an attribute count for the set of serialized attribute values from the data stream. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The computer program product of <dependent-claim-reference depends_on="CLM-00022">claim 20</dependent-claim-reference> further comprising: 
<claim-text>instructions for mapping attributes between the object and the serialized object; and </claim-text>
<claim-text>instructions for storing serialized attribute values from the data stream in the object. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The computer program product of <dependent-claim-reference depends_on="CLM-00022">claim 22</dependent-claim-reference> further comprising: 
<claim-text>instructions for refraining from storing in the object a serialized attribute value associated with the serialized attribute version identifier in response to a determination that a serialized attribute version identifier is greater than or subsequent to the class version identifier of the object. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The computer program product of <dependent-claim-reference depends_on="CLM-00022">claim 22</dependent-claim-reference> further comprising: 
<claim-text>instructions for storing default attribute values in the object for attributes in the object that are associated with an attribute version identifier that is greater than or subsequent to the serialized class version identifier in response to a determination that the class version identifier of the object is greater than or subsequent to the serialized class version identifier. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. A computer program product on a computer readable medium for use in a data processing system for providing backwards and forwards compatibility between different versions of serialized object data, the computer program product comprising: 
<claim-text>instructions for identifying an object, wherein the object comprises a set of attributes, wherein each attribute in the set of attributes is associated with a version identifier, and wherein the object is an instance of a first version of a class; </claim-text>
<claim-text>instructions for writing a data stream representing serialization of the object&apos;s attributes and associated version identifiers; </claim-text>
<claim-text>instructions for reading a data stream representing a serialized object into a new object instance of a second version of a class; and </claim-text>
<claim-text>instructions for refraining from storing attributes from the data stream into the new object instance that are not represented in the new object instance while reading the data stream. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. The computer program product of <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference> further comprising: 
<claim-text>instructions for specifying default values for attributes in the new object instance for which attribute values were not read from the data stream. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. An apparatus for object-oriented management of serializable objects, the apparatus comprising: 
<claim-text>means for identifying an object, wherein the object comprises a set of attributes; </claim-text>
<claim-text>means for associating a class version identifier with the object, wherein the class version identifier identifies the object as an instance of a specific version of a class; and </claim-text>
<claim-text>means for associating an attribute version identifier with an attribute in the set of attributes. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 27</dependent-claim-reference> further comprising: 
<claim-text>means for writing a data stream representing an object serialization of the object, wherein the data stream comprises the class version identifier of the object, an attribute value for an attribute in the set of attributes, and an attribute version identifier for an attribute in the set of attributes. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00029">
<claim-text><highlight><bold>29</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 27</dependent-claim-reference> further comprising: 
<claim-text>means for reading a data stream representing a serialized object, wherein the data stream comprises a serialized class version identifier, a set of serialized attribute values, and a set of serialized attribute version identifiers, wherein serialized attribute version identifiers in the set of serialized attribute version identifiers are paired with serialized attribute values in the set of serialized attribute values. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00030">
<claim-text><highlight><bold>30</bold></highlight>. An apparatus for providing backwards and forwards compatibility between different versions of serialized object data, the apparatus comprising: 
<claim-text>means for identifying an object, wherein the object comprises a set of attributes, wherein each attribute in the set of attributes is associated with a version identifier, and wherein the object is an instance of a first version of a class; </claim-text>
<claim-text>means for writing a data stream representing serialization of the object&apos;s attributes and associated version identifiers; </claim-text>
<claim-text>means for reading a data stream representing a serialized object into a new object instance of a second version of a class; and </claim-text>
<claim-text>means for refraining from storing attributes from the data stream into the new object instance that are not represented in the new object instance while reading the data stream.</claim-text>
</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>5</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005169A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005169A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005169A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005169A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005169A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005169A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030005169A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030005169A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
