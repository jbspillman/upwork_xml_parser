<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005099A1-20030102-D00000.TIF SYSTEM "US20030005099A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005099A1-20030102-D00001.TIF SYSTEM "US20030005099A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005099A1-20030102-D00002.TIF SYSTEM "US20030005099A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005099A1-20030102-D00003.TIF SYSTEM "US20030005099A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005099A1-20030102-D00004.TIF SYSTEM "US20030005099A1-20030102-D00004.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005099</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09894446</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010628</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F015/173</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>709</class>
<subclass>223000</subclass>
</uspc>
</classification-us-primary>
<classification-us-secondary>
<uspc>
<class>709</class>
<subclass>226000</subclass>
</uspc>
</classification-us-secondary>
<classification-us-secondary>
<uspc>
<class>709</class>
<subclass>315000</subclass>
</uspc>
</classification-us-secondary>
<classification-us-secondary>
<uspc>
<class>709</class>
<subclass>220000</subclass>
</uspc>
</classification-us-secondary>
</classification-us>
<title-of-invention>Event manager for a control management system</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Pleyer</given-name>
<family-name>Sven</family-name>
</name>
<residence>
<residence-us>
<city>Woodinville</city>
<state>WA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Baird</given-name>
<family-name>Andrew</family-name>
</name>
<residence>
<residence-us>
<city>Kirkland</city>
<state>WA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>BANNER &amp; WITCOFF LTD.,</name-1>
<name-2>ATTORNEYS FOR MICROSOFT</name-2>
<address>
<address-1>1001 G STREET , N.W.</address-1>
<address-2>ELEVENTH STREET</address-2>
<city>WASHINGTON</city>
<state>DC</state>
<postalcode>20001-4597</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">Disclosed is a method and apparatus for a control management system having a plurality of software controllable devices coupled to a network wherein each device has at least one property to be controlled and a plurality of clients for changing the properties of at least one device. Disclosed is an event manager that acts as an interface between the clients and the devices. The event manager maintains a persistence store of all the properties being controlled in the home control management system and the current values of the properties. When the client requests status information of the properties it controls, the event manager provides this information to the client thereby avoiding the need for the client to separately query each individual device. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">FIELD OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> The present invention relates generally to control management systems such as home automation systems, and, more particularly, to an event manager within such systems that provides property information and property change information of the devices being controlled via the control management system. </paragraph>
</section>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> In the past, environments having networked equipment were typically limited to commercial and industrial sites. Such equipment was typically complex and highly sophisticated computer controlled machines that utilized networks to coordinate manufacturing activities. Unlike the commercial and industrial setting, the typical consumer setting included devices and appliances that were fairly unsophisticated and that were operated by a user on a one-to-one basis. To achieve a specific function on the consumer device, the user had to physically interact with the device. For example, to turn on a coffee machine, the user had to press the ON button. Similarly, to change a channel on a TV, the user had to physically turn a knob on the TV set. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> Early advances in consumer devices and appliances were limited to remote control devices that, at first, were wired to the device, and eventually used infrared (IR) communications to transmit commands. The remote control devices, however, still forced the user to interact with their respective devices on a one-to-one basis. In addition, most hand-held remote control devices were proprietary, which required separate remote controllers for each consumer product. Further advancements included universal remote controllers that were capable of being programmed to control many devices consumer devices. Universal remote control devices were limited in that they were typically not able to control devices other than entertainment equipment. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> Lately, consumer appliances have become more sophisticated because of the decreased size and costs of computer-related components such as microprocessors. These new consumer devices include the so-called &ldquo;smart&rdquo; devices that, like the sophisticated commercial and industrial machinery, are capable of executing predefined tasks and capable of communicating over network infrastructures. An example of a system of smart devices is CEBus&reg;, which may utilize household powerlines to transport messages between compliant CEBus&reg; household devices. CEBus&reg; is implemented per EIA IS-60 for home automation. The CEBus&reg; system utilized controller and receptacle units to communicate and control CEBus&reg; compliant devices. The receptacle units are connected to a standard household receptacles and the command and control information is communicated over the powerlines. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> A further example of a system that is intended to network devices is Jini&trade;, which is based on Java&trade;. Jini&trade; uses Java Remote Method Invocation protocols to move code around a network of devices. Network services run on top of the Jini&trade; software architecture such that devices and applications may register with the network via a lookup service. Each device must register with the lookup service for other devices to discover them. Thus, each device is not aware of other devices on the network without first pointing to the lookup service. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> The above systems are limiting, however, because they all require the user interface to constantly poll the devices it is controlling to identify the status of the device. The communication link between the devices and the user interfaces, for interacting with and controlling the devices, is often slow, thereby exacerbating the problem. For the management system to work adequately, it must have each user interface accurately reflecting the status of each of the devices being controlled. Consider for example, a first user interface changing the light setting of a light in the master bedroom. A second user interface will not know that the light in the master bedroom has changed settings unless it actually polls the master bedroom light for its status. Accordingly, it is desirable that each user interface be updated as to the current state of each device being controlled as well as any changes that are made to the settings of each device. The user interface must then accurately display a single point of state of each of the devices being controlled. To accurately display device settings on the user interfaces, however, the communications between the devices and the user interfaces becomes impractically slow and inefficient when the communications link is a slower network infrastructure or when there are a large number of devices being controlled. For example, consider an Internet-enabled user interface that communicates with devices through a web server, or even clients that have low CPU power, such as a handheld device or a cell phone. Having to poll for individual properties of multiple devices via this slower network therefore becomes a time consuming process. Further, with each user interface requiring updated status information for each device, the communications traffic becomes relatively high. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> Another limitation with the above prior art systems is that the user interfaces do not provide any meaningful organization of the devices being controlled. Accordingly, it becomes difficult for the user to control desired devices in any meaningful way, for example, by room. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> Yet another limitation is that many user interfaces such as handheld computing devices or cell phones lack the necessary interface with the devices and therefore are not enabled to communicate directly with the devices. For example, many software controllable devices utilize a Component Object Model (COM) or a Distributed Component Object Model (DCOM) interface. Many user interfaces are not COM- or DCOM-enabled. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> In view of the above, there is a need for a system that efficiently provides to user interfaces setting information of the devices being controlled. There is also a need to aggregate devices in the home, including their properties, and to categorize them by location and type. There is also a need to allow UI clients to request specific information to keeps traffic between all the devices and the IU clients to a minimum. The present invention provides a solution to address these and other limitations and shortcomings of the prior art. </paragraph>
</section>
<section>
<heading lvl="1">BRIEF SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> The present invention is a method and apparatus for an event manager that provides an efficient communication medium for a client to obtain status information for the various devices that the client controls. The event manager is middleware that acts as an interface between the devices and the clients. The event manager maintains an organized list of device properties to be controlled and a record of the current state of the device properties. The event manager also maintains a record of the properties to which each client has subscribed, and a time stamp of when each property was last changed. The client maintains a time stamp of when it last polled the event manager for device property information. Thus, when the client next polls the event manager, it provides the event manager with the time stamp. The event manager then identifies those properties that have changed since that given timestamp, and returns the collected information back to the client. The client updates its local information cache as well as its local timestamp with the latest timestamp provided within the returned information. Next time the client polls the event manager, it will then use this latest timestamp to request new updates. The client thereby may readily obtain status information for the various device properties that it controls. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> As discussed, the event manager also provides a more efficient method for communicating with the user interface client. While the event manager communicates with the devices using COM and/or DCOM to obtain information regarding changes to property values, the event manager communicates with the clients using common programming languages including, for example and without limitation, eXtensible Markup Language (XML). Clients may efficiently obtain device property information without requiring frequent time-consuming polling of individual device properties. Moreover, the event manager allows even non-COM enabled clients to obtain device status information. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> These as well as other novel advantages, details, embodiments, features and objects of the present invention will be apparent to those skilled in the art from following the detailed description of the invention, the attached claims and accompanying drawings, listed herein, which are useful in explaining the invention.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> In the following text and drawings, wherein similar reference numerals denote similar elements throughout the several views thereof, the present invention is explained with reference to illustrative embodiments, in which: </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a schematic block diagram of the various components of a general-purpose computing device for use with the present invention. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is an exemplary environment in which aspects of the present invention may be incorporated. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a block diagram illustrating the functional relationship between devices, clients and the event manager in accordance with a preferred embodiment of the present invention. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a schematic diagram illustrating the various containers that may be found in the Persistence Store in accordance with a preferred embodiment of the present invention.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF THE INVENTION </heading>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> In a preferred embodiment, the present invention takes the form of an event manager software object for a networked system of smart devices. The event manager interfaces between clients and the software controllable devices. The event manager maintains a Persistence Store, which is generally defined as a database or file that maintains a list of device properties as well as the values of these properties and a time stamp of when these properties last changed values. This allows clients to readily obtain status information regarding various properties. Each software controllable device has an associated control object (CO) that carries out communication, and accepts and issues control messages. The control object allows the event manager to remotely control or query a physical device for which the specific control object has responsibility and also maintains logical and physical connections and control of the device. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> Although not required, the invention will be described in the general context of computer-executable instructions, such as program modules. Generally, program modules include routines, programs, objects, scripts, components, data structures, and the like that perform particular tasks or implement particular abstract data types. The present invention provides for a software system that may be implemented on any network infrastructure such that networked devices may be remotely controlled by, for example, a general-purpose computer, or a system whereby the networked devices may share information with and about each other. The present invention provides and accepts common command, control, and communication through the network while retaining the ability of each device to operate autonomously. In a distributed computing environment, program modules may be located in both local and remote memory storage devices. </paragraph>
<paragraph id="P-0020" lvl="7"><number>&lsqb;0020&rsqb;</number> 1. General Computing Environment </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> and the following discussion are intended to provide a brief general description of a suitable computing environment in which the invention may be implemented. Various elements of the system of the present invention may implement some or all the features and components of the computing environment of <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. For example, clients or devices may take on the form of a general-purpose computer or may be a simplified version of the same such as a computing device. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a schematic block diagram of a general-purpose computer <highlight><bold>100</bold></highlight> for use with the present invention. Those skilled in the art will appreciate, however, that any computing device may be implemented including, for example, a hand-held computing device, a multiprocessor system, a microprocessor-based or programmable consumer electronic device, a network personal computer (PC), a minicomputer, a mainframe computer, and the like. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> The conventional personal computer <highlight><bold>100</bold></highlight> generally includes a processing unit <highlight><bold>110</bold></highlight>, a system memory <highlight><bold>120</bold></highlight>, and a system bus <highlight><bold>130</bold></highlight> that couples various system components including the system memory to the processing unit <highlight><bold>110</bold></highlight>. The system bus <highlight><bold>130</bold></highlight> may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. The system memory includes read only memory (ROM) <highlight><bold>140</bold></highlight> and random access memory (RAM) <highlight><bold>150</bold></highlight>A. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> A basic input/output system <highlight><bold>160</bold></highlight> (BIOS), containing the basic routines that help to transfer information between elements within the personal computer <highlight><bold>100</bold></highlight>, such as during start-up, is stored in ROM <highlight><bold>140</bold></highlight>. The personal computer <highlight><bold>100</bold></highlight> further includes a hard disk drive <highlight><bold>170</bold></highlight> for reading from and writing to a hard disk, not shown, a magnetic disk drive <highlight><bold>180</bold></highlight> for reading from or writing to a removable magnetic disk <highlight><bold>190</bold></highlight>, and an optical disk drive <highlight><bold>191</bold></highlight> for reading from or writing to a removable optical disk <highlight><bold>192</bold></highlight> such as a CD ROM or other optical media. The hard disk drive <highlight><bold>170</bold></highlight>, magnetic disk drive <highlight><bold>180</bold></highlight>, and optical disk drive <highlight><bold>191</bold></highlight> are connected to the system bus <highlight><bold>130</bold></highlight> by a hard disk drive interface <highlight><bold>192</bold></highlight>, a magnetic disk drive interface <highlight><bold>193</bold></highlight>, and an optical disk drive interface <highlight><bold>194</bold></highlight>, respectively. The drives and their associated computer-readable media provide nonvolatile storage of computer readable instructions, data structures, program modules and other data for the personal computer <highlight><bold>100</bold></highlight>. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> Although the exemplary environment described herein employs a hard disk, a removable magnetic disk <highlight><bold>190</bold></highlight> and a removable optical disk <highlight><bold>192</bold></highlight>, it should be appreciated by those skilled in the art that other types of computer readable media which can store data that is accessible by a computer, such as magnetic cassettes, flash memory cards, digital video disks, Bernoulli cartridges, random access memories (RAMs), read only memories (ROMs), and the like, may also be used in the exemplary operating environment. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> A number of program modules may be stored on the hard disk, magnetic disk <highlight><bold>190</bold></highlight>, optical disk <highlight><bold>192</bold></highlight>, ROM <highlight><bold>140</bold></highlight> or RAM <highlight><bold>150</bold></highlight>A, including an operating system <highlight><bold>195</bold></highlight>, one or more application programs <highlight><bold>196</bold></highlight>, other program modules <highlight><bold>197</bold></highlight>, and program data <highlight><bold>198</bold></highlight>. A user may enter commands and information into the personal computer <highlight><bold>100</bold></highlight> through input devices such as a keyboard <highlight><bold>101</bold></highlight> and pointing device <highlight><bold>102</bold></highlight>. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit <highlight><bold>110</bold></highlight> through a serial port interface <highlight><bold>106</bold></highlight> that is coupled to the system bus, but may be connected by other interfaces, such as a parallel port, game port or a universal serial bus (USB). A monitor <highlight><bold>107</bold></highlight> or other type of display device is also connected to the system bus <highlight><bold>130</bold></highlight> via an interface, such as a video adapter <highlight><bold>108</bold></highlight>. In addition to the monitor, personal computers typically include other peripheral output devices (not shown), such as speakers and printers. Preferably, any implementation of the present invention is designed to be operable in a least case scenario only by touch, and does not always require the use of a keyboard or mouse. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> The personal computer <highlight><bold>100</bold></highlight> may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer <highlight><bold>109</bold></highlight>. The remote computer <highlight><bold>109</bold></highlight> may be another personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the personal computer <highlight><bold>100</bold></highlight>, although only a memory storage device <highlight><bold>111</bold></highlight> has been illustrated in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. The logical connections depicted in <cross-reference target="DRAWINGS">FIG. 1</cross-reference> include a local area network (LAN) <highlight><bold>112</bold></highlight> and a wide area network (WAN) <highlight><bold>113</bold></highlight>. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> When used in a LAN networking environment, the personal computer <highlight><bold>100</bold></highlight> is connected to the local network <highlight><bold>112</bold></highlight> through a network interface or adapter <highlight><bold>114</bold></highlight>. When used in a WAN networking environment, the personal computer <highlight><bold>100</bold></highlight> typically includes a modem <highlight><bold>115</bold></highlight> or other means for establishing a communications over the wide area network <highlight><bold>113</bold></highlight>, such as the Internet. The modem <highlight><bold>115</bold></highlight>, which may be internal or external, is connected to the system bus <highlight><bold>130</bold></highlight> via the serial port interface <highlight><bold>106</bold></highlight>. In a networked environment, program modules depicted relative to the personal computer <highlight><bold>100</bold></highlight>, or portions thereof, may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> Those skilled in the art will appreciate that the invention may be practiced with any number of computer system configurations including, but not limited to, distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote memory storage devices. </paragraph>
<paragraph id="P-0030" lvl="7"><number>&lsqb;0030&rsqb;</number> 2. Network Environment Employing a Control Management System </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> As noted, computer <highlight><bold>100</bold></highlight> described above can be deployed as part of a computer network within which the system of the present invention may be implemented. In general, the above description applies to both server computers and client computers deployed in a network environment. As will become evident, the above description may also apply, in part, to appliances and devices attached to the network that have the ability to accept and execute software instructions. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> illustrates on such exemplary network environment in which the present invention may be employed. Particularly, <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a schematic block diagram of a home area network environment employing a home automation system. The present invention may be implemented within an automation system in, for example, a household, an office, a commercial or industrial environment, or other similar environment. The automation system generally includes a network environment, software controllable devices <highlight><bold>205</bold></highlight> coupled to the network <highlight><bold>236</bold></highlight>, and software controlling clients <highlight><bold>210</bold></highlight> coupled to the network <highlight><bold>236</bold></highlight>. Each of these elements is described further herein. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> As illustrated in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, the devices <highlight><bold>205</bold></highlight> and clients <highlight><bold>210</bold></highlight> are connected to a network medium <highlight><bold>236</bold></highlight>. In a preferred embodiment, the physical transport of the medium <highlight><bold>236</bold></highlight> is an Ethernet utilizing a Transport Control Protocol and an Internet Protocol (TCP/IP) as a common network layer with the devices <highlight><bold>205</bold></highlight> being identified by IP addresses. Those skilled in the art will appreciate, however, that the present invention is not limited to any particular physical network technology and may include fiber optic, X.10, and serial communications. Similarly, the present invention may utilize protocols other than TCP/IP. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> The clients <highlight><bold>210</bold></highlight> are generally User Interface (UI) components that allow a user to interact with and remotely control the software controllable devices <highlight><bold>205</bold></highlight> via software instructions. Such clients <highlight><bold>210</bold></highlight> are general-purpose computing devices including, for example without limitation, a personal computer such as a notebook (laptop) computer <highlight><bold>49</bold></highlight>, a hand-held computing device <highlight><bold>63</bold></highlight>, a desktop PC/server <highlight><bold>20</bold></highlight>, remote control devices, wall switches, voice user interfaces, iris scanners, and the like. Although not required, the notebook computer <highlight><bold>49</bold></highlight> preferably operates utilizing WINDOWS&reg; 95/98 or WINDOWS NT&reg; 4.0 Workstation (or higher) brand operating systems. Again, although not required, the hand-held computing device <highlight><bold>63</bold></highlight> preferably operates running WINDOWS&reg; CE 2.0 (or higher) brand operating system. The PC/Server <highlight><bold>20</bold></highlight> preferably runs the WINDOWS NT&reg; 4.0 Workstation or Server (or higher) brand operating system. The general purpose computing devices <highlight><bold>20</bold></highlight>, <highlight><bold>49</bold></highlight> and <highlight><bold>63</bold></highlight> may also act as or &ldquo;consumer presentation displays&rdquo; (CPD) <highlight><bold>230</bold></highlight>, <highlight><bold>232</bold></highlight> and <highlight><bold>234</bold></highlight> to provide a coherent and transparent interface to users across all network media <highlight><bold>236</bold></highlight> and topologies. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> The devices <highlight><bold>205</bold></highlight> are generally electronics, appliances, furniture, and fixtures capable of accepting and executing software instructions via an associated control object CO (discussed below). Devices <highlight><bold>205</bold></highlight> may include a whole range of household, office, and commercial or industrial products including, for example and without limitation, audio/video equipment, lights, blinds, window screens, window and door locks, thermostats, motion sensors, and the like. As illustrated in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, devices <highlight><bold>205</bold></highlight> include, for example and without limitation, a game device <highlight><bold>212</bold></highlight>, a video device (VCR) <highlight><bold>214</bold></highlight>, a telephone <highlight><bold>216</bold></highlight>, a smart AC outlet <highlight><bold>218</bold></highlight>, an answering machine <highlight><bold>220</bold></highlight>, and a television <highlight><bold>222</bold></highlight>, which may be connected to the network <highlight><bold>236</bold></highlight>. Those skilled in the art will appreciate that the devices <highlight><bold>212</bold></highlight>-<highlight><bold>222</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 2</cross-reference> are merely illustrative and that other consumer devices, small office machines, and security devices may also be connected to the network <highlight><bold>236</bold></highlight>. In a household, there may be hundreds of distinct devices for use with the present invention. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> Although not shown in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, each device <highlight><bold>205</bold></highlight> preferably includes a microprocessor or a microcontroller and a read-only memory containing an embedded operating system (e.g., WINDOWS&reg; CE 2.0 (or higher)). The embedded operating system and/or an application running on the operating system serves to control the functions of the device <highlight><bold>205</bold></highlight>. The methods provided by control objects (discussed below) may be executed by the operating system or the software application. It is preferable that the operating system of the device <highlight><bold>205</bold></highlight> includes application programming interfaces (APIs) to enable each device&apos;s attendant control object to control the device <highlight><bold>205</bold></highlight> based on the information contained within the control object. APIs are generally routines, protocols, and/or tools for building software applications by providing the building blocks that a programmer may use to develop an application. Programs using a common API will have similar interfaces. Such as a structure would allow device manufacturers to use the control object CO, application software, and/or the device operating system to implement functions that would be appropriate for the manufacturer&apos;s specific device or service (e.g., providing play and record functions within a VCR). </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> Each device <highlight><bold>205</bold></highlight> has associated properties that provide the functionality of the device <highlight><bold>205</bold></highlight>. For example, a device <highlight><bold>205</bold></highlight> such as a light fixture may have two properties: (1) on/off; and (2) intensity. Clients <highlight><bold>210</bold></highlight> may thereby control both properties of the light fixture, namely they may turn on or turn off the light fixture, or they may adjust the intensity of the light. As illustrated by the above example, properties for devices <highlight><bold>205</bold></highlight> may have binary values (e.g., on or off) or they may have a range of values (e.g., to set the intensity level). </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> In accordance with the present invention, each of the above consumer devices <highlight><bold>212</bold></highlight>-<highlight><bold>222</bold></highlight> is represented by a control object C<highlight><bold>01</bold></highlight>-C<highlight><bold>06</bold></highlight>, also known as a software service provider or a device driver. As defined herein, control objects C<highlight><bold>01</bold></highlight>-C<highlight><bold>06</bold></highlight> are polymorphic software objects designed to logically represent physical attributes of associated devices <highlight><bold>212</bold></highlight>-<highlight><bold>222</bold></highlight> to provide for local and/or remote control of the device <highlight><bold>205</bold></highlight>. For example, the control objects CO may be ActiveX or OLE controls. The control object CO also is adapted to bind to any designed physical transport mechanism for communication with other control objects or control programs. For example, the control objects CO allow the event manager <highlight><bold>250</bold></highlight> to communicate with the device <highlight><bold>205</bold></highlight> to query properties of the device <highlight><bold>205</bold></highlight> as well to issue commands to the device <highlight><bold>205</bold></highlight>. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> For example, the control object CO may be embodied as a Component Object Model (COM) or a Distributed Component Object Model (DCOM) object that exists within the operating system (e.g., WINDOWS&reg; 95/98, WINDOWS NT&reg;, WINDOWS&reg; CE) that calls transport Dynamic Link Libraries (DLLs) through well known medium neutral application programming interfaces (APIs) to communicate via the network medium <highlight><bold>236</bold></highlight>. COM and DCOM are generally models for binary code that enables programmers to develop objects that can be accessed by any COM-compliant application. The data and events to be communicated by the control object CO are embodied as callbacks and function (method) returns. Typically, the control object CO will load, activate, deactivate, and pass data to and from the transport. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> The control object CO is software typically located within the device <highlight><bold>205</bold></highlight> itself although the control object CO may reside in any number of locations in the network, including for example, within the computer where the API resides, near the device <highlight><bold>205</bold></highlight>, or within an Event Manager <highlight><bold>250</bold></highlight> (discussed below). In the latter embodiments, the control object CO may be coupled to the device <highlight><bold>205</bold></highlight> via any known connection including, for example and without limitation, RS-232 interface, Universal Serial Bus (USB), Ethernet, Infrared (IR), Radio Frequency (RF), wireless network, etc. As one example, the control management system of the present invention may be implemented in a control object CO architecture similar to that described in U.S. patent application Ser. No. 09/339,649, entitled &ldquo;Control Object and User Interface for Controlling Networked Devices,&rdquo; filed on Jun. 24, 1999. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> The methods provided by the control objects CO (discussed below) may be executed by the operating system or the software application. It is preferable that the operating system of the devices <highlight><bold>205</bold></highlight> include application programming interfaces (APIs) to enable each device&apos;s attendant control object CO to control the device <highlight><bold>205</bold></highlight> based on the information contained within the control object CO. Such as structure would allow device manufacturers to use the control object CO, application software, and/or the device operating system to implement functions that would be appropriate for the manufacturer&apos;s specific device or service (e.g., providing play and record functions within the VCR <highlight><bold>214</bold></highlight>). </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> The system of the present invention also includes an event manager <highlight><bold>250</bold></highlight>. The event manager <highlight><bold>250</bold></highlight> is generally middleware that manages communication between multiple user devices <highlight><bold>205</bold></highlight> and a coherent user interface. The event manager <highlight><bold>250</bold></highlight> is describe in further detail herein. </paragraph>
<paragraph id="P-0043" lvl="7"><number>&lsqb;0043&rsqb;</number> 3. Event Manager <highlight><bold>250</bold></highlight> </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> As illustrated in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>, the event manager <highlight><bold>250</bold></highlight> is a software object that acts as an interface between the client <highlight><bold>210</bold></highlight> and the software controllable devices <highlight><bold>205</bold></highlight> and extracts the complexities of the various devices <highlight><bold>205</bold></highlight>. The event manager <highlight><bold>250</bold></highlight> maintains a Persistence Store <highlight><bold>255</bold></highlight>, which keeps a list of device properties as well as the values of these properties and a time stamp of when these properties last changed values. This allows clients <highlight><bold>210</bold></highlight> to readily obtain status information regarding various properties. When the client issues a property change request to the event manager <highlight><bold>250</bold></highlight> to change one or a group of properties, the event manager <highlight><bold>250</bold></highlight> forwards the property change request to the appropriate software controllable devices <highlight><bold>205</bold></highlight> (or control object CO). Once a device <highlight><bold>205</bold></highlight> (or control object CO) receives a property change request, the device <highlight><bold>205</bold></highlight> (or control object CO) determines whether to accept or reject the new property value(s). In the event that the device <highlight><bold>205</bold></highlight> (or control object CO) accepts the property change event, the event manager <highlight><bold>250</bold></highlight> updates its Persistence Store <highlight><bold>255</bold></highlight> with the new property value. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> Since a property may be changed by any number of clients <highlight><bold>210</bold></highlight> or even manually by the user, it becomes desirable to for a client <highlight><bold>210</bold></highlight> to readily learn the status of one or more properties of any given device <highlight><bold>205</bold></highlight>. The event manager <highlight><bold>250</bold></highlight> thereby serves as a source for clients <highlight><bold>210</bold></highlight> to readily obtain status information for the various device properties. When a new client <highlight><bold>210</bold></highlight> starts-up, it contacts the event manager <highlight><bold>250</bold></highlight> and subscribes to the various properties that the client <highlight><bold>210</bold></highlight> controls and retrieves the property values for each of the subscribed properties. The client <highlight><bold>210</bold></highlight> subsequently polls the event manager <highlight><bold>250</bold></highlight> to receive updates to any possible changes to the subscribed properties since the previous query. The client <highlight><bold>210</bold></highlight> thereby remains synchronized with all property changes for the properties that it controls. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> As discussed above, the control object CO exposes the properties of its associated device <highlight><bold>205</bold></highlight>. For example, the control object CO for a CD player device may have exposed properties such as Power, Mode, Track Number, and CD Number. As another example, the control object CO for a TV device may have exposed properties such as power, Input Mode (e.g., video <highlight><bold>1</bold></highlight> or video <highlight><bold>2</bold></highlight>), and Channel. The event manager <highlight><bold>250</bold></highlight> stores and organizes these properties and a meaningful way that can be readily accessed by the clients <highlight><bold>210</bold></highlight>. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> As illustrated in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, the event manager <highlight><bold>250</bold></highlight> exposes a Persistence Store container <highlight><bold>1405</bold></highlight> that tabulates and stores a comprehensive listing of each control object CO and the various parameters of each control object CO. The parameters identified in the Persistence Store <highlight><bold>255</bold></highlight> for each control object CO include, for example, an identification (ID) of the control object CO, a name of the control object CO, a location of the associated device <highlight><bold>205</bold></highlight> (e.g., by room), an exposed properties listing of the associated device <highlight><bold>205</bold></highlight>, and a property descriptor. The exposed properties listing identifies the properties exposed by the control object CO for the associated device <highlight><bold>205</bold></highlight>. The property descriptor parameter provides a description of each of the various exposed properties identified in the exposed properties listing. Accordingly, the Persistence Store <highlight><bold>255</bold></highlight> provides a wealth of information about the various devices <highlight><bold>205</bold></highlight> in the networked environment. In a preferred embodiment, the proper descriptor is an XML block that enumerates the various exposed properties and describes the types and ranges of values that the exposed properties may have. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> As shown in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, the event manager <highlight><bold>250</bold></highlight> allows clients <highlight><bold>210</bold></highlight> to create additional, custom containers having pointers to the control objects COs in the Persistence Store container <highlight><bold>405</bold></highlight>. By using the custom containers, the various control objects COs may be organized in an organized or predefined manner, for example, by room. This allows clients <highlight><bold>210</bold></highlight> to control specific devices <highlight><bold>205</bold></highlight> in the specific room. In the example of <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, Custom Containers <highlight><bold>410</bold></highlight> and <highlight><bold>415</bold></highlight> respectively represent the dining room and the living room. Other rooms may include, for example, the porch, the foyer, the office, the bedrooms, the bathrooms, the kitchen, the den, the family room, the loft, etc. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> In the example of organizing the control objects COs by room, the Persistence Store <highlight><bold>255</bold></highlight> may have nodes each corresponding to a room (plus additional attributes that correspond to that room number&mdash;e.g., private, location, etc.). Each room node has one or more entities having a name that identifies the device <highlight><bold>205</bold></highlight> (light, CD, DVD, etc.), the control object CO associated with the device <highlight><bold>205</bold></highlight>, the properties of device <highlight><bold>205</bold></highlight>, and the possible values for each property. Each node maps to the devices <highlight><bold>205</bold></highlight> that you would find in any particular room. Similarly, within each room node, the entities may be divided into sub-nodes that further groups the entities (e.g., countertop light). </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> The custom containers may be used to allow clients <highlight><bold>210</bold></highlight> to create &ldquo;scenes.&rdquo; For example, a reading scene, would turn off all lights and turn on the reading light, with the CD player set to a specific track of a specific album, close the blinds. The client <highlight><bold>210</bold></highlight> may thereby create this scene by controlling the various devices <highlight><bold>205</bold></highlight> accordingly. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> As discussed, pointers in the custom containers point to the control objects COs for devices <highlight><bold>205</bold></highlight> that are located in these respective rooms. When a new device <highlight><bold>205</bold></highlight> is added, its associated control object CO is added to the Persistence Store <highlight><bold>255</bold></highlight> with one of the parameters identifying the room in which the device <highlight><bold>205</bold></highlight> resides. The custom container for that room may then create another pointer for that new control object CO. In alternative embodiments, the custom containers may organize the control object CO by device type or device class. Accordingly, the custom containers provide a mechanism by which the control objects COs may be organized or categorized in a sensible manner. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> Clients <highlight><bold>210</bold></highlight> coupled to the event manager <highlight><bold>250</bold></highlight> may subscribe to the event manager <highlight><bold>250</bold></highlight> for property change events for those respective device properties that the client <highlight><bold>210</bold></highlight> controls. Accordingly, each client <highlight><bold>210</bold></highlight> may obtain information about only those device properties that it controls and need not obtain other unnecessary information. For each device property, the event manager <highlight><bold>250</bold></highlight> maintains a list of the clients <highlight><bold>210</bold></highlight> that require notification in the event that the device property changes value. The client <highlight><bold>210</bold></highlight> essentially subscribes to the properties for which it wishes to receive updates. Accordingly, when a property for a device <highlight><bold>205</bold></highlight> changes, the event manager <highlight><bold>250</bold></highlight> identifies the clients <highlight><bold>210</bold></highlight> that have subscribed to that property and forwards the change information to those clients <highlight><bold>210</bold></highlight> the next time the client <highlight><bold>210</bold></highlight> polls the event manager <highlight><bold>250</bold></highlight> for an update. In particular, the event manager <highlight><bold>250</bold></highlight> provides to the subscribed client <highlight><bold>210</bold></highlight> the new value of the device property that was changed. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> In a preferred embodiment, the event manager <highlight><bold>250</bold></highlight> provides only property value information for the properties that changed values since the last query by the client <highlight><bold>210</bold></highlight>. This may be achieved by use of time stamps. Each property within the custom container has associated with it a time stamp indicating when the property last changed values. Accordingly, when a property value is changed, the event manager <highlight><bold>250</bold></highlight> stores not only the new property value but also a time stamp of when that property value was changed. This allows clients <highlight><bold>210</bold></highlight> to ask the event manager <highlight><bold>250</bold></highlight> what has changed since the last time it polled the event manager <highlight><bold>250</bold></highlight>. In particular, the client maintains a time stamp of when it last polled the event manager for device property information. Thus, when the client next polls the event manager, it provides the event manager with the time stamp. The event manager <highlight><bold>250</bold></highlight> then walks through the list of properties subscribed by the client <highlight><bold>210</bold></highlight> and identifies the time stamps that are newer than those from the previous inquiry made by the client <highlight><bold>210</bold></highlight>. The event manager <highlight><bold>250</bold></highlight> filters out all the properties that have not changed values and provides to the client <highlight><bold>210</bold></highlight> only those property values that have changed. Upon receiving the updated property change information, the client <highlight><bold>210</bold></highlight> then updates its local information cache as well as its local time stamp with the latest time stamp provided with the returned information. Next time the client polls the event manager, it will then use this latest time stamp to request new updates. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> In an alternative embodiment, rather than waiting for the client <highlight><bold>210</bold></highlight> to query the event manager <highlight><bold>250</bold></highlight> for property changes (client &ldquo;pulling&rdquo; the information), the event manager <highlight><bold>250</bold></highlight> may periodically provide property change information to the subscribed client <highlight><bold>210</bold></highlight> (event manager &ldquo;pushing&rdquo; the information). Alternatively, any time a property changes values, the event manager <highlight><bold>250</bold></highlight> forwards the updated property value information to each subscribed client <highlight><bold>210</bold></highlight>. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> Advantageously, the event manager <highlight><bold>250</bold></highlight> provides a more convenient and efficient interface for interacting with clients <highlight><bold>210</bold></highlight>. Rather than the client <highlight><bold>210</bold></highlight> having to communicate directly to each of the control objects COs for the properties that it controls to request this information, the client <highlight><bold>210</bold></highlight> can obtain relevant property status information directly from the event manager <highlight><bold>250</bold></highlight>. The client <highlight><bold>210</bold></highlight> thereby avoids the steps of having to make a protocol request for the property and engage in handshaking with the control object CO, which can take an unacceptably long time for the client <highlight><bold>210</bold></highlight> to get the desired property information. Moreover, a client <highlight><bold>210</bold></highlight> having to do this for a long list of properties for various devices <highlight><bold>205</bold></highlight> would certainly take an unacceptably long time, a disadvantage that the present invention overcomes. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> Another advantage of the event manager <highlight><bold>250</bold></highlight> is that clients that are not COM-enabled may control devices <highlight><bold>205</bold></highlight> under the system of the present invention. Advantageously, clients do not require COM-enabled components to enable connectivity with the system. This allows future clients, to control various devices <highlight><bold>205</bold></highlight> of the system without requiring client-specific software. </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> Yet another advantage of the present system is that clients <highlight><bold>210</bold></highlight> do not require constant connection to the system. Rather, the clients <highlight><bold>210</bold></highlight> merely query the event manager <highlight><bold>250</bold></highlight> for property status information. Thus, if any DCOM-enabled client <highlight><bold>210</bold></highlight> loses connection to the system, it does not have to log back on, re-do the connection, and re-subscribe the to properties that it seeks. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> It will be apparent to those skilled in the art that the foregoing examples have been provided merely for the purpose of explanation and are in no way to be construed as limiting of the present invention. While the invention has been described with reference to preferred embodiments, it is understood that the words that have been used herein are words of description and illustration, rather than words of limitations. For example, while the devices <highlight><bold>212</bold></highlight>-<highlight><bold>222</bold></highlight> have been illustrated as a game device, a video device, a telephone, a smart AC outlet, an answering machine, and a television, other devices may be controlled include, but not limited to personal computers, security systems, dishwashers, etc. In addition, other operating systems than the Microsoft WINDOWS&reg; family may be provided with the appropriate APIs to implement the features of the invention. Further, although the invention has been described herein with reference to particulars disclosed herein; rather, the invention extends to all functionally equivalent structures, methods and uses, such as are within the scope of the appended claims. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">We claim: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A control management system for software controllable devices comprising in combination: 
<claim-text>(a) a communication network; </claim-text>
<claim-text>(b) a plurality of software controllable devices coupled to the network wherein each software controllable device has at least one property to be controlled and wherein each software controllable device has an associated control object that exposes the properties of the device to be controlled; </claim-text>
<claim-text>(c) at least one client operatively coupled to the network and having a user interface, the client being capable of changing a value of the property of at least one device via the network; and </claim-text>
<claim-text>(d) an event manager coupled to the network and having stored the property values of each device and the properties to which the client subscribed, </claim-text>
<claim-text>wherein the event manager when polled by the client provides the client with an update of any changes to the properties to which the client has subscribed. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The control management system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the event manager has a persistence store container identifying each control object of the devices to be controlled. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The control management system of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, wherein each control object in the persistence store has associated parameters selected from the group consisting of an identification of the control object, a name of the control object, a location of the associated device, an exposed properties listing of the associated device, and a property descriptor. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The control management system of <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference>, wherein the property descriptor enumerates the exposed properties of the control object. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The control management system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the event manager has a custom container identifying each control object based on locations of each of the associated plurality of software controllable devices. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The control management system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein each property stored in the event manager has an associated time stamp indicating when the property last changed value. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The control management system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the event manager has a client time stamp indicating when the client last queried the event manager to property change information. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The control management system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the client subscribes to at least one controllable property that the client can control and wherein the event manager associates the controllable property with the client. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The control management system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein the event manager module has computer-executable instructions for performing the steps of: (i) receiving a request from a client for status information regarding at least one property of a device wherein the request provides a time stamp information for the client; (ii) comparing the time stamp information for the client and the time stamp corresponding to the property that the client requests; and (iii) if the time stamp information for the client is earlier than the time stamp corresponding to the property that the client requests, providing the property value information to the client. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The control management system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the client communicates with the event manager via eXtensible Markup Language (XML). </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The control management system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the software controllable devices communicate with the event manager via a component object model (COM). </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The control management system of <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, wherein the client is not COM-enabled. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The control management system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the software controllable devices communicate with the event manager via a Distributed Component Object Model (DCOM). </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The control management system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the devices are selected from the group consisting of electronics, appliances, furniture, and fixtures. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. An event manager for use with a networked control management system comprising in combination: 
<claim-text>(a) a first interface for communicating with at least one client; </claim-text>
<claim-text>(b) a second interface for communicating with at least one control object representative of a software controllable device; and </claim-text>
<claim-text>(c) a persistence store having stored therein a listing of the control objects in the control management system, wherein each control object in the listing identifies each property to be controlled, wherein each property has a property value and a time stamp of when the property value was last changed. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The event manager of <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference>, wherein the persistence store has subscription information of the properties to which a client has subscribed and wherein the event manager further comprises: 
<claim-text>(d) computer-executable instructions for performing the steps of: (i) in response to receiving a request for status information, identifying those subscribed properties that changed property values since a previous request from the client; and (ii) providing updated property value information to the client for those subscribed properties that changed values since the previous request. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. A method of providing updates to a client relating to a plurality of software controllable devices in a networked management system comprising the steps of: 
<claim-text>(a) maintaining a list of device properties wherein each property has an associated time stamp indicative of when the device property was last changed; </claim-text>
<claim-text>(b) maintaining subscription information indicative of the device properties to which the client has subscribed, forming a subscribed device properties; </claim-text>
<claim-text>(c) receiving a request from the client for status information; </claim-text>
<claim-text>(d) identifying those subscribed device properties that changed property values since a previous request from the client; and </claim-text>
<claim-text>(e) providing updated property value information to the client for those properties that changed values since the previous request. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. A computer-readable medium having computer-executable instructions for performing the steps recited in <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference>. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. A method for providing a client information about at least one device, wherein the device and the client are part of a networked management system, the method comprising the steps of: 
<claim-text>(a) storing, in a central memory coupled to the network, property information for the device; </claim-text>
<claim-text>(b) receiving change information from the network indicating that a property of the device has changed; </claim-text>
<claim-text>(c) storing, in the central memory, the change information relating to the property of the device; </claim-text>
<claim-text>(d) storing, in the central memory, a property time stamp corresponding to the change information indicating when the property of the device changed; </claim-text>
<claim-text>(e) receiving a request for status information from a client regarding the property, wherein the client has a client time stamp that is earlier than the property time stamp; and </claim-text>
<claim-text>(f) providing the change information to the client via the network, </claim-text>
<claim-text>wherein the client has accurate information regarding the device to be controlled. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. A computer-readable medium having computer-executable instructions for performing the steps recited in <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference>. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. In a network comprising a plurality of clients, a plurality of software controllable devices, and a computer-readable storage medium, a distributed system for controlling the devices, comprising in combination: 
<claim-text>(a) at least one control object residing in the computer-readable medium accessible to a software controllable device and exposing controllable properties for the respective device, the control object accepting and issuing messages to and from the respective device; </claim-text>
<claim-text>(b) an event manager module residing in the computer-readable medium accepting and issuing messages to the control object and storing the exposed controllable properties and property values of the devices; and </claim-text>
<claim-text>(c) a user interface residing in the client adapted to receive property value information from the event manager, and accept and issue control messages to and from the event manager, </claim-text>
<claim-text>wherein the event manager serves as an interface for the client to issue commands to the software controllable devices and to receive updates of any changes to the properties values. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The distributed system of <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference>, wherein the event manager has a persistence store container identifying each control object of the devices to be controlled. </claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The distributed system of <dependent-claim-reference depends_on="CLM-00022">claim 22</dependent-claim-reference>, wherein each control object in the persistence store has associated parameters selected from the group consisting of an identification of the control object, a name of the control object, a location of the associated device, an exposed properties listing of the associated device, and a property descriptor. </claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The distributed system of <dependent-claim-reference depends_on="CLM-00022">claim 23</dependent-claim-reference>, wherein the proper descriptor enumerates the exposed properties of the control object. </claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. The distributed system of <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference>, wherein the event manager has a custom container identifying each control object based on locations of the associated devices. </claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. The distributed system of <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference>, wherein each property stored in the event manager has an associated time stamp indicating when the property last changed value. </claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. The distributed system of <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference>, wherein the event manager has a client time stamp indicating when the client last queried the event manager to property change information. </claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. The distributed system of <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference>, wherein the client subscribes to at least one controllable property that the client can control and wherein the event manager associates the controllable property with the client. </claim-text>
</claim>
<claim id="CLM-00029">
<claim-text><highlight><bold>29</bold></highlight>. The distributed system of <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference> wherein the event manager module has computer-executable instructions for performing the steps of: (i) receiving a request from a client for status information regarding at least one property of a device wherein the request provides a time stamp information for the client; (ii) comparing the time stamp information for the client and the time stamp corresponding to the property that the client requests; and (iii) if the time stamp information for the client is earlier than the time stamp corresponding to the property that the client requests, providing the property value information to the client. </claim-text>
</claim>
<claim id="CLM-00030">
<claim-text><highlight><bold>30</bold></highlight>. The distributed system of <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference>, wherein the client communicates with the event manager via eXtensible Markup Language (XML). </claim-text>
</claim>
<claim id="CLM-00031">
<claim-text><highlight><bold>31</bold></highlight>. The distributed system of <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference>, wherein the software controllable devices communicate with the event manager via a component object model (COM). </claim-text>
</claim>
<claim id="CLM-00032">
<claim-text><highlight><bold>32</bold></highlight>. The distributed system of <dependent-claim-reference depends_on="CLM-00033">claim 31</dependent-claim-reference>, wherein the client is not COM-enabled. </claim-text>
</claim>
<claim id="CLM-00033">
<claim-text><highlight><bold>33</bold></highlight>. The distributed system of <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference>, wherein the software controllable devices communicate with the event manager via a Distributed Component Object Model (DCOM). </claim-text>
</claim>
<claim id="CLM-00034">
<claim-text><highlight><bold>34</bold></highlight>. The distributed system of <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference>, wherein the devices are selected from the group consisting of electronics, appliances, furniture, and fixtures.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>1</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005099A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005099A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005099A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005099A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005099A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
