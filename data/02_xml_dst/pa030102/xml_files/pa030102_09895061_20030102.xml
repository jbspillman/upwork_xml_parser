<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005279A1-20030102-D00000.TIF SYSTEM "US20030005279A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005279A1-20030102-D00001.TIF SYSTEM "US20030005279A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005279A1-20030102-D00002.TIF SYSTEM "US20030005279A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005279A1-20030102-D00003.TIF SYSTEM "US20030005279A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005279A1-20030102-D00004.TIF SYSTEM "US20030005279A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005279A1-20030102-D00005.TIF SYSTEM "US20030005279A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030005279A1-20030102-D00006.TIF SYSTEM "US20030005279A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030005279A1-20030102-D00007.TIF SYSTEM "US20030005279A1-20030102-D00007.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005279</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09895061</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010629</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>H04L009/00</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>713</class>
<subclass>150000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Synchronizing the exchange of cryptography information between kernel drivers</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Moshe</given-name>
<family-name>Valenci</family-name>
</name>
<residence>
<residence-us>
<city>Givat-Zeev</city>
<state>IL</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Linden</given-name>
<family-name>Minnick</family-name>
</name>
<residence>
<residence-us>
<city>Hillsboro</city>
<state>OR</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>BLAKELY SOKOLOFF TAYLOR &amp; ZAFMAN</name-1>
<name-2></name-2>
<address>
<address-1>12400 WILSHIRE BOULEVARD, SEVENTH FLOOR</address-1>
<city>LOS ANGELES</city>
<state>CA</state>
<postalcode>90025</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">Methods and apparatuses for synchronizing the exchange of cryptography information between kernel drivers. A high level application in an electronic system passes a pointer to a base driver. The pointer is a unique identifier for cryptography information, such as a Security Association (SA), that the base driver uses to populate a cryptography information table for performing cryptography operations on secure traffic data packets. If the network interface device and/or its associated driver are reset, the pointer is used to repopulate the cryptography information table with specific cryptography information needed to perform cryptography operations on the data packets. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">FIELD OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> The invention relates to processing of cryptography information. More specifically, the invention relates to techniques for passing security association information between kernel drivers. </paragraph>
</section>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> Data transferred over a network can be encrypted to protect its confidentiality and integrity. Because many different encryption methods are used, data packets contain an index into a table of structures containing cryptography (crypto) information necessary to indicate to the receiving system how to decrypt the data. The crypto information can be contained in a data structure called a security association (SA). Network interface devices in the transmitting and receiving systems perform crypto operations (e.g., encryption, decryption, authentication) on the data packets based on the crypto information in the SA. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> A device driver directs how the network interface devices will perform crypto operations. The device driver stores in system memory a table of crypto information necessary for the network interface devices to perform crypto operations on data packets. The information may also be stored in tables on the devices. These tables can include, for example, unique identifiers for the cryptography data structures, cryptography keys, source addresses, destination addresses, network protocol types, and other information related to crypto operations. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> One technique for populating a table of crypto information is for a high level application such as an operating system (OS) to control the process. With this technique, the high level application is responsible for maintaining consistency of the security state between the upper system layers (e.g., OS, high level applications) and the lower system layers (e.g., base drivers, hardware devices) that perform crypto operations. The high level application manages a unique handle that the driver creates for each data structure of crypto information which is passed to the intermediate security layer and/or base driver. All operations on data packets by the intermediate security layer driver and/or network interface device drivers and/or network interface devices references crypto information with the handle. If, for some reason, the network interface device and/or its associated driver is reset, the data in the crypto information tables is lost and the handles must be discarded. The high level application is then responsible for passing the crypto information to the base driver again so that it can repopulate the crypto information tables. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> Some operating systems, for example, Windows&reg; 2000 and Windows&reg; XP, both available from Microsoft Corporation, guarantee that the crypto information tables are populated. Thus, if a network interface device and/or its associated device driver is reset, the operating system will pass the crypto information to the base drivers in order to allow the repopulation of the tables contained by the network interface device and/or its associated driver. One shortfall of such a technique is an inefficient use of resources because the entire table is repopulated, even though some of the information may not be used in the future. Another shortfall occurs with dynamic installation or removal of a network interface device; crypto information can be lost, or a device may be unable to acquire the proper security state. Another shortfall is that attempts to store crypto information in a network interface device and its associated driver during reset often fails, which requires repeated tries to store the information and/or failure to store the information. </paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> The invention is illustrated by way of example, and not by way of limitation, in the figures of the accompanying drawings in which like reference numerals refer to similar elements. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is one embodiment of a block diagram of an electronic system. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is one embodiment of a block diagram of an electronic system coupled to a network through a network interface. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is one embodiment of a block diagram of an intermediate driver agent. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is one embodiment of a block diagram of a base driver agent. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is one embodiment of a block diagram of a data packet. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is one embodiment of a flow diagram for transmission of a data packet from an electronic system implementing a layered security driver. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> is one embodiment of a flow diagram for reception of a data packet by an electronic system implementing a layered security driver. </paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION </heading>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> Methods and apparatuses for passing cryptography information between kernel drivers are described. In the following description, for purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the invention. It will be apparent, however, to one skilled in the art that the invention can be practiced without these specific details. In other instances, structures and devices are shown in block diagram form in order to avoid obscuring the invention. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> Reference in the specification to &ldquo;one embodiment&rdquo; or &ldquo;an embodiment&rdquo; means that a particular feature, structure or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Thus, the appearances of the phrase &ldquo;in one embodiment&rdquo; appearing in various places throughout the specification are not necessarily all referring to the same embodiment. Likewise, the appearances of the phrase &ldquo;in another embodiment,&rdquo; or &ldquo;in an alternate embodiment&rdquo; appearing in various places throughout the specification are not all necessarily all referring to the same embodiment. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> Briefly, techniques for passing cryptography (crypto) information, such as Security Associations (SAs), necessary to perform crypto operations (e.g., encryption, decryption, authentication) on secure traffic data packets between kernel drivers are described. For example, a Security Association (SA) is a data structure of crypto information used in the Internet Protocol (IP) Security (Ipsec) standard, IP Security Internet Engineering Task Force (IETF) Request for Comments (RFC) 2401, published November 1998, that is passed between layers of an electronic system implementing IPsec. A pointer to the crypto information is created and passed to a base driver. The base driver uses the pointer to populate a crypto information table to enable a network interface device to perform crypto operations on the data packets. In one embodiment, if the network interface device and/or its associated driver are reset, the pointer is used to repopulate the crypto information table as needed with the specific data structures of crypto information needed to perform crypto operations on the data packets. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> Security status information is indicated from a base driver to an intermediate driver. The intermediate driver uses the security status information to determine whether processing should be performed on the packet. In one embodiment, the security status information indicates that crypto information necessary to process a data packet was missing. In one embodiment, the intermediate driver then passes the missing crypto information to the base driver. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is one embodiment of an electronic system. Electronic system <highlight><bold>100</bold></highlight> may be, for example, a computer, a Personal Digital Assistant (PDA), a set top box, or any other electronic system. System <highlight><bold>100</bold></highlight> includes bus <highlight><bold>101</bold></highlight> or other communication device to communicate information, and processor <highlight><bold>102</bold></highlight> coupled with bus <highlight><bold>101</bold></highlight> to process information and to execute instructions. System <highlight><bold>100</bold></highlight> further includes memory <highlight><bold>103</bold></highlight>, coupled to bus <highlight><bold>101</bold></highlight> to store information and instructions to be executed by processor <highlight><bold>102</bold></highlight>. Memory <highlight><bold>103</bold></highlight> may also be used to store temporary variables or other intermediate information during execution of instructions by processor <highlight><bold>102</bold></highlight>. Memory <highlight><bold>103</bold></highlight> may include random access memory (RAM), read-only memory (ROM), flash, or other static or dynamic storage media. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> User interfaces <highlight><bold>104</bold></highlight> are coupled to bus <highlight><bold>101</bold></highlight> too allow interaction with a user. User interfaces <highlight><bold>104</bold></highlight> can be, for example, input devices (e.g., mouse, keyboard, touchpad, etc.) and/or output devices (e.g., cathode ray tube (CRT) monitor, liquid crystal display (LCD), etc.). Mass storage <highlight><bold>105</bold></highlight> can be coupled to system <highlight><bold>100</bold></highlight> to provide instructions to memory <highlight><bold>103</bold></highlight>. Mass storage <highlight><bold>105</bold></highlight> can be, for example, a magnetic disk or optical disc and its corresponding drive, a memory card, or another device capable of storing machine-readable instructions. Network interfaces <highlight><bold>106</bold></highlight> can be coupled to bus <highlight><bold>101</bold></highlight> to enable system <highlight><bold>100</bold></highlight> to communicate with other electronic systems via a network. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> Driver agent <highlight><bold>107</bold></highlight> maybe coupled to system <highlight><bold>100</bold></highlight> to perform driver features in hardware. Driver agent <highlight><bold>107</bold></highlight> may be an Application Specific Integrated Circuit (ASIC), a special function controller or processor, a Field Programmable Gate Array (FPGA), or other hardware device to perform the functions of a driver. Driver agent <highlight><bold>107</bold></highlight> is not a necessary part of system <highlight><bold>100</bold></highlight>. In one embodiment, system <highlight><bold>100</bold></highlight> may contain a driver agent that provides system control over network interfaces <highlight><bold>106</bold></highlight>, for example, a Network Interface Card (NIC) driver controlling a NIC. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> Network interfaces <highlight><bold>106</bold></highlight> couples electronic system <highlight><bold>100</bold></highlight> to other electronic systems over a network. In one embodiment, non-secure traffic streams are transmitted and/or received by system <highlight><bold>100</bold></highlight> through network interfaces <highlight><bold>106</bold></highlight>. Similarly, secure traffic streams can be transmitted and/or received by system <highlight><bold>100</bold></highlight> through network interfaces <highlight><bold>106</bold></highlight>. Transmitting secure traffic streams requires that crypto operations be performed on data packets to authenticate and/or encrypt data before being transmitted. Receiving secure traffic streams requires that crypto operations be performed on data packets to authenticate and/or decrypt data after being received. The crypto operations can be performed by network interfaces <highlight><bold>106</bold></highlight>. For example, a driver agent can direct network interfaces <highlight><bold>106</bold></highlight> decrypt a received data packet. The driver agent can be driver agent <highlight><bold>107</bold></highlight> or a software driver agent incorporated from a series of machine-readable instructions stored within memory <highlight><bold>103</bold></highlight>. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> Instructions can be provided to memory <highlight><bold>103</bold></highlight> from a storage device, such as magnetic disk, CD-ROM, DVD, via a remote connection (e.g., over a network), etc. In alternative embodiments, hard-wired circuitry can be used in place of or in combination with software instructions to enable system <highlight><bold>100</bold></highlight> to transfer crypto information from an intermediate driver agent to a base driver agent as described below. Thus, the electronic system depicted above is not limited to any specific combination of hardware circuitry and software structure. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> Instructions can be provided to memory <highlight><bold>103</bold></highlight> from a form of machine-accessible medium. A machine-accessible medium includes any mechanism that provides (i.e., stores and/or transmits) information in a form readable by a machine (e.g., a computer). For example, a machine-accessible medium includes read only memory (ROM); random access memory (RAM); magnetic disk storage media; optical storage media; flash memory devices; electrical, optical, acoustical or other form of propagated signals (e.g., carrier waves, infrared signals, digital signals); etc. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is one embodiment of a block diagram of an electronic system coupled to a network through a network interface. In one embodiment, Network Interface (NI) <highlight><bold>210</bold></highlight> is a communication interface that enables system <highlight><bold>200</bold></highlight> to communicate to other electronic systems coupled to network <highlight><bold>220</bold></highlight>. For example, NI <highlight><bold>210</bold></highlight> can be a NIC. In one embodiment, data packets are received from network <highlight><bold>220</bold></highlight> into NI <highlight><bold>210</bold></highlight>. Similarly, data packets can be transmitted to network <highlight><bold>220</bold></highlight> from NI <highlight><bold>210</bold></highlight>. In one embodiment, cache <highlight><bold>211</bold></highlight> contains a table of crypto information necessary to perform crypto operations on the packets. For example, NI <highlight><bold>210</bold></highlight> can use data stored in cache <highlight><bold>211</bold></highlight> to decrypt a packet after it receives the packet. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> Memory <highlight><bold>103</bold></highlight> contains operating system (OS) <highlight><bold>231</bold></highlight> which directs operations of system <highlight><bold>200</bold></highlight>. In one embodiment, OS <highlight><bold>231</bold></highlight> is the highest layer of control of system <highlight><bold>200</bold></highlight>. Intermediate driver agent <highlight><bold>233</bold></highlight> and base driver agent <highlight><bold>235</bold></highlight> are lower layers of system control. In one embodiment, OS <highlight><bold>231</bold></highlight> delivers crypto information to intermediate driver agent <highlight><bold>233</bold></highlight>. In another embodiment, applications <highlight><bold>232</bold></highlight> can contain agents of a higher layer of control than intermediate driver agent <highlight><bold>233</bold></highlight> and deliver crypto information to intermediate driver agent <highlight><bold>233</bold></highlight>. Applications <highlight><bold>232</bold></highlight> can also contain other programs (e.g., word processor(s), electronic mail (e-mail) programs). </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> Although referred to herein as delivering and/or passing crypto information between an intermediate driver agent and a base driver agent, delivering and/or passing crypto information as described can be practiced by other system layers. For example, an OS may deliver crypto information to a base driver agent. In another example, a base driver agent may pass information to a high level application. In general, system layers applications and/or system elements that control the flow of operations in an electronic system, from a low level layer, such as network hardware, to a high level layer, such as an OS. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> In one embodiment, memory <highlight><bold>103</bold></highlight> contains security association tables <highlight><bold>233</bold></highlight> and <highlight><bold>236</bold></highlight>, which are data structures of SAs. Memory <highlight><bold>103</bold></highlight> may contain other tables of crypto information like SA table <highlight><bold>234</bold></highlight> and SA table <highlight><bold>236</bold></highlight>, which are examples of tables of crypto information. Memory <highlight><bold>103</bold></highlight> can also contain intermediate driver agent <highlight><bold>233</bold></highlight> and/or base driver agent <highlight><bold>235</bold></highlight>. In one embodiment, intermediate driver agent <highlight><bold>233</bold></highlight> creates pointers to crypto information in SA table <highlight><bold>234</bold></highlight>. In one embodiment, intermediate driver agent <highlight><bold>233</bold></highlight> creates handles for the crypto information data structures that are unique identifiers for the SAs. The pointers can be used to access the data structures of crypto information, including the unique identifiers. Intermediate driver agent <highlight><bold>233</bold></highlight> passes the pointers to base driver agent <highlight><bold>235</bold></highlight>. For example, a packet created for transmission by the upper system layers is passed by intermediate driver agent <highlight><bold>233</bold></highlight> to base driver agent <highlight><bold>235</bold></highlight> with a pointer to the memory location of the SA associated with the data packet. Base driver agent <highlight><bold>235</bold></highlight> can then use the pointer access the crypto information in SA table <highlight><bold>234</bold></highlight>. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> Base driver agent <highlight><bold>235</bold></highlight> maintains SA table <highlight><bold>236</bold></highlight> for directing the processing of secure traffic data streams. In one embodiment, base driver agent <highlight><bold>235</bold></highlight> uses the pointer to populate SA table <highlight><bold>236</bold></highlight>. For example, base driver agent <highlight><bold>235</bold></highlight> uses the pointer to access SA table <highlight><bold>234</bold></highlight> to repopulate SA table <highlight><bold>236</bold></highlight> with SAs if the information in the table is lost. For example, the data in SA table <highlight><bold>236</bold></highlight> is lost if NI <highlight><bold>210</bold></highlight> is reset. In one embodiment, base driver agent <highlight><bold>235</bold></highlight> uses the pointer to populate cache <highlight><bold>211</bold></highlight> if the data in cache <highlight><bold>211</bold></highlight> is lost, such as if NI <highlight><bold>210</bold></highlight> or its associated base driver agent is reset. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> In one embodiment, base driver agent <highlight><bold>235</bold></highlight> uses the pointer to obtain crypto information from SA table <highlight><bold>234</bold></highlight> if the data necessary to perform crypto operations on a data packet is missing from SA table <highlight><bold>236</bold></highlight>. For example, an NI device may be dynamically added to system <highlight><bold>200</bold></highlight> whose base driver agent may be unable to acquire the proper security state. In another example, an NI device may be dynamically removed from system <highlight><bold>200</bold></highlight>. In another example, a base driver agent may be dynamically removed from system <highlight><bold>200</bold></highlight>. If the information necessary to process data packets from secure traffic streams is not found in SA table <highlight><bold>236</bold></highlight>, the information can be obtained with the pointer. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> In one embodiment, base driver agent <highlight><bold>235</bold></highlight> uses the pointer associated with a packet to access crypto information necessary to perform crypto operations on data packets from SA table <highlight><bold>234</bold></highlight> if adding a data structure of crypto information to SA table <highlight><bold>236</bold></highlight> fails. For example, in an IPsec implementation, adding SAs during reset often fails. Tracking when a network interface device or its associated driver is ready to receive the data structures of crypto information is difficult. In prior art, if the data in SA table <highlight><bold>236</bold></highlight> is lost, missing, or unable to be added, the NI device will be unable to process data packets. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is one embodiment of a block diagram of an intermediate driver agent. Control logic <highlight><bold>310</bold></highlight> directs the flow of operation of driver agent <highlight><bold>300</bold></highlight>. In one embodiment, control logic <highlight><bold>310</bold></highlight> is a series of software instructions to perform logic operations. In another embodiment, control logic <highlight><bold>310</bold></highlight> can be implemented by hardware control logic, or a combination of hardware-based control logic and software instructions. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> System interfaces <highlight><bold>340</bold></highlight> provide a communications interface between intermediate driver agent <highlight><bold>300</bold></highlight> and an electronic system. For example, intermediate driver agent <highlight><bold>300</bold></highlight> can be part of a computer system and system interfaces <highlight><bold>340</bold></highlight> provide a communications interface between intermediate driver agent <highlight><bold>300</bold></highlight> and the computer system via a system bus. Thus, control logic <highlight><bold>310</bold></highlight> can receive a series of instructions from application software external to intermediate driver agent <highlight><bold>300</bold></highlight>. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> Intermediate driver agent <highlight><bold>300</bold></highlight> is not limited to being local to an electronic system. For example, system interfaces <highlight><bold>340</bold></highlight> may provide a communications interface between intermediate driver agent <highlight><bold>300</bold></highlight> and an electronic system through a network. In one embodiment, intermediate driver agent <highlight><bold>300</bold></highlight> may contain applications <highlight><bold>320</bold></highlight> to provide internal instructions to control logic <highlight><bold>310</bold></highlight>. Applications <highlight><bold>320</bold></highlight> are not necessary to the function of intermediate driver agent <highlight><bold>300</bold></highlight>. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> Packet classification feature <highlight><bold>351</bold></highlight> enables intermediate driver agent <highlight><bold>300</bold></highlight> to match a data packet with its corresponding crypto information from a table of crypto information so that the data packet can be processed correctly. For example, packet classification feature <highlight><bold>351</bold></highlight> can enable intermediate driver agent <highlight><bold>300</bold></highlight> to direct a base driver agent which SA to use to encrypt a data packet prior to transmission of the data packet. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> Packet transfer feature <highlight><bold>352</bold></highlight> enables intermediate driver agent <highlight><bold>300</bold></highlight> to transfer data packets to/from other system layers. For example, intermediate driver agent driver agent <highlight><bold>300</bold></highlight> can pass a data packet to be transmitted to a base driver agent. In another example, a high-level system layer such as an OS can create a data packet for transmission and pass the packet down to intermediate driver agent <highlight><bold>300</bold></highlight>. Similarly, a base driver agent can pass a packet of ingress data up to intermediate driver agent <highlight><bold>300</bold></highlight>. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> Pointer feature <highlight><bold>353</bold></highlight> enables driver agent <highlight><bold>300</bold></highlight> to create a pointer to memory location of crypto information. For example, pointer feature <highlight><bold>353</bold></highlight> enables intermediate driver agent <highlight><bold>300</bold></highlight> to create a pointer to the memory location of crypto information, such as data in an SA table. The pointer can be passed to a base driver agent and used to access a unique identifier for the crypto information stored with the information in a crypto information table. The base driver agent can then use the pointer to access crypto information necessary to perform crypto operations on data packets. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> Packet classification feature <highlight><bold>351</bold></highlight>, packet transfer feature <highlight><bold>352</bold></highlight>, and pointer feature <highlight><bold>353</bold></highlight> can exist independently of and/or be external to intermediate driver agent <highlight><bold>300</bold></highlight>. Thus, driver engine <highlight><bold>350</bold></highlight> may exist as a more complex or less complex embodiment, containing some, all, or additional features to those represented in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>. In one embodiment, intermediate driver agent <highlight><bold>300</bold></highlight> is part of a layered security driver. For example, intermediate driver agent <highlight><bold>300</bold></highlight> can be an Advanced Networking Services (ANS) driver as part of a Bump In The Stack (BITS) or Bump In The Wire (BITW) layered security driver implementation. On transmit, a Transmission Control Protocol/Internet Protocol (TCP/IP) stack may pass a data packet to an ANS driver, which then classifies the packet with its crypto information, and then passes the packet down the line for encryption and transmission. On receive, an NI device driver passes a received data packet to an ANS driver, which can then process the packet and/or pass it up to a TCP/IP stack. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is one embodiment of a block diagram of a base driver agent. Control logic <highlight><bold>410</bold></highlight> directs the flow of operation of base driver agent <highlight><bold>400</bold></highlight>. In one embodiment, control logic <highlight><bold>410</bold></highlight> is a series of software instructions to perform logic operations. In another embodiment, control logic <highlight><bold>410</bold></highlight> can be implemented by hardware control logic, or a combination of hardware-based control logic and software instructions. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> System interfaces <highlight><bold>440</bold></highlight> provide a communications interface between base driver agent <highlight><bold>400</bold></highlight> and an electronic system. For example, base driver agent <highlight><bold>400</bold></highlight> can be part of a computer system and system interfaces <highlight><bold>440</bold></highlight> provide a communications interface between base driver agent <highlight><bold>400</bold></highlight> and the computer system via a system bus. Thus, control logic <highlight><bold>410</bold></highlight> can receive a series of instructions from application software external to base driver agent <highlight><bold>400</bold></highlight>. Base driver agent <highlight><bold>400</bold></highlight> is not limited to being local to an electronic system. For example, system interfaces <highlight><bold>440</bold></highlight> may provide a communications interface between base driver agent <highlight><bold>400</bold></highlight> and an electronic system through a network. In one embodiment, base driver agent <highlight><bold>400</bold></highlight> contains applications <highlight><bold>420</bold></highlight> to provide internal instructions to control logic <highlight><bold>410</bold></highlight>. Applications <highlight><bold>420</bold></highlight> are not necessary to the function of base driver agent <highlight><bold>400</bold></highlight>. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> Dereferencing feature <highlight><bold>451</bold></highlight> enables base driver agent <highlight><bold>400</bold></highlight> to utilize a pointer to acquire information referenced by the pointer. For example, dereferencing feature <highlight><bold>451</bold></highlight> enables base driver agent <highlight><bold>400</bold></highlight> to dereference a pointer to information in a table of crypto information passed by a higher layer driver agent to acquire the SA information necessary to direct processing of a data packet. In another example, dereferencing feature <highlight><bold>451</bold></highlight> enables base driver agent <highlight><bold>400</bold></highlight> to access the SA information necessary to populate a table of crypto information maintained by base driver agent <highlight><bold>400</bold></highlight>. In another example, dereferencing feature <highlight><bold>451</bold></highlight> enables base driver agent <highlight><bold>400</bold></highlight> to use a pointer passed by a higher layer to a memory location in a table of crypto information to acquire the information necessary to populate a cache on a network interface device. This enables population of the table and/or the cache to be performed independently of the OS in the electronic system. Dereferencing can be performed in any manner known in the art. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> Packet transfer feature <highlight><bold>452</bold></highlight> enables base driver agent <highlight><bold>400</bold></highlight> to transfer data packets to/from other system layers. For example, an NI device associated with base driver agent <highlight><bold>400</bold></highlight> can receive a data packet which base driver agent <highlight><bold>400</bold></highlight> passes up to an intermediate driver agent. The NI device could be connected to the Internet and receive a data packet from a secure traffic stream that base driver agent <highlight><bold>400</bold></highlight> passes up to a higher layer of a security driver. In another example, a higher-level system layer, such as an intermediate driver agent, can pass a data packet down to base driver agent <highlight><bold>400</bold></highlight> to be transmitted over a network. Thus, base driver agent <highlight><bold>400</bold></highlight> could be a NIC driver and an ANS driver could pass it a data packet to be transmitted over a secure traffic network stream. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> Populating feature <highlight><bold>453</bold></highlight> enables base driver agent <highlight><bold>400</bold></highlight> to populate a crypto information table with data. For example, if an NI device associated with base driver agent <highlight><bold>400</bold></highlight> was reset, causing the data in its crypto information table to be lost, populating feature <highlight><bold>453</bold></highlight> enables base driver agent <highlight><bold>400</bold></highlight> to restore the data in the table. The table could be a table of SAs maintained by base driver agent <highlight><bold>400</bold></highlight>, or optionally a cache of SAs on a NIC. The information in the table or tables that base driver agent <highlight><bold>400</bold></highlight> populates enables the NIC to perform hardware offload processing on data packets. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> Packet status feature <highlight><bold>454</bold></highlight> enables base driver agent <highlight><bold>400</bold></highlight> to indicate to system upper layers the status of the processing of a data packet. For example, a packet may be from a non-secure source, and packet status feature <highlight><bold>454</bold></highlight> could indicate that the packet was processed without needing offload processing. In another example, packet status feature <highlight><bold>454</bold></highlight> may indicate that a packet was processed successfully in hardware. In another example, packet status feature <highlight><bold>454</bold></highlight> may indicate that a packet was processed, but that the packet failed authentication. In another example, packet status feature <highlight><bold>454</bold></highlight> may indicate that the crypto information needed to process the packet was missing. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> Dereferencing feature <highlight><bold>451</bold></highlight>, packet transfer feature <highlight><bold>452</bold></highlight>, populating feature <highlight><bold>453</bold></highlight>, and packet status feature <highlight><bold>454</bold></highlight> can exist independently of and/or be external to driver agent <highlight><bold>400</bold></highlight>. Thus, driver engine <highlight><bold>450</bold></highlight> may exist as a more complex or less complex embodiment, containing some, all, or additional features to those represented in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>. In one embodiment, base driver agent <highlight><bold>400</bold></highlight> is part of a layered security driver. For example, base driver agent <highlight><bold>400</bold></highlight> can be a NIC driver in a BITS/BITW layered security driver implementation. On transmit, an ANS driver may pass a data packet down to the NIC driver, which then passes the packet to the NIC for transmission. On receive, a NIC driver directs how the NIC receives data packets, including directing hardware offload processing. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is one embodiment of a block diagram of a data packet. In one embodiment, data packet <highlight><bold>501</bold></highlight> is embodied in traffic stream <highlight><bold>500</bold></highlight>. For example, traffic stream <highlight><bold>500</bold></highlight> can be a secure traffic stream used by multiple networked electronic systems to communicate. For example, traffic stream <highlight><bold>500</bold></highlight> may be a network traffic stream between two electronic systems using the IPsec encryption standard to transfer secure information over the Internet. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> In one embodiment, data packet <highlight><bold>501</bold></highlight> consists of header <highlight><bold>510</bold></highlight>, cryptography information <highlight><bold>520</bold></highlight>, and data <highlight><bold>530</bold></highlight>. In one embodiment, cryptography information <highlight><bold>520</bold></highlight> consists of network protocol <highlight><bold>521</bold></highlight>, security parameter index <highlight><bold>522</bold></highlight>, source identifier <highlight><bold>523</bold></highlight>, and destination identifier <highlight><bold>524</bold></highlight>. Network protocol <highlight><bold>521</bold></highlight>, security parameter index <highlight><bold>522</bold></highlight>, source identifier <highlight><bold>523</bold></highlight>, and destination identifier <highlight><bold>524</bold></highlight> can exist independently of and be external to cryptography information <highlight><bold>520</bold></highlight>. Thus, cryptography information may be more or less complex, consisting of some, all, or additional elements to those depicted in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> In one embodiment, cryptography information <highlight><bold>520</bold></highlight> is necessary for an electronic system to process data packet <highlight><bold>501</bold></highlight>. For example, an electronic system receiving data packet <highlight><bold>501</bold></highlight> using IPsec will locate cryptography information <highlight><bold>520</bold></highlight> to authenticate the packet and determine how to decrypt data <highlight><bold>530</bold></highlight>. Similarly, an electronic system transmitting data packet <highlight><bold>501</bold></highlight> using IPsec will use cryptography information <highlight><bold>520</bold></highlight> to encrypt the data prior to transmission. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is one embodiment of a flow diagram for transmission of a data packet from an electronic system implementing a layered security driver. Data packet <highlight><bold>600</bold></highlight> is generated by high level application process <highlight><bold>610</bold></highlight> and prepared for transmission. For example, high level application process can be a TCP/IP stack. Generation and preparation of data packet <highlight><bold>600</bold></highlight> can include, for example, creating bit patterns to represent a data communication, and bit patterns to represent security information necessary to perform crypto operations on data packet <highlight><bold>600</bold></highlight>. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> Data packet <highlight><bold>600</bold></highlight> is passed to intermediate driver agent <highlight><bold>620</bold></highlight>. Intermediate driver agent <highlight><bold>620</bold></highlight> can be, for example, an ANS driver as part of a BITS/BITW layered security driver implementation. In one embodiment, intermediate driver agent <highlight><bold>620</bold></highlight> maintains SA table <highlight><bold>621</bold></highlight>, which is a table of SAs that contains all the information necessary to perform crypto operations on data packet <highlight><bold>600</bold></highlight>. Although <cross-reference target="DRAWINGS">FIG. 6</cross-reference> depicts data structures of crypto information as containing SAs, SA table <highlight><bold>621</bold></highlight> and SA table <highlight><bold>631</bold></highlight> are only example embodiments of data structures of crypto information, and are not limited to containing crypto information data structures that are SAs. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> Intermediate driver agent <highlight><bold>620</bold></highlight> provides memory management for SA table <highlight><bold>621</bold></highlight>, but SA table <highlight><bold>621</bold></highlight> does not necessarily reside in intermediate driver agent <highlight><bold>620</bold></highlight>. In one embodiment, intermediate driver agent <highlight><bold>620</bold></highlight> includes packet classifier <highlight><bold>622</bold></highlight>, which associates data packet <highlight><bold>600</bold></highlight> with an SA for hardware offload processing. The SA corresponds to data in SA table <highlight><bold>621</bold></highlight>. For example, a system TCP/IP stack may create a data packet to transmit as part of an IPsec traffic exchange. When the packet is passed to a BITS/BITW security driver, an ANS driver will associate it with an SA from an SA table in memory maintained by the ANS driver. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> Data packet <highlight><bold>600</bold></highlight> is passed to base driver agent <highlight><bold>630</bold></highlight>. Base driver agent <highlight><bold>630</bold></highlight> can be, for example, a NIC driver. In one embodiment, intermediate driver agent <highlight><bold>620</bold></highlight> passes *SA info <highlight><bold>632</bold></highlight> with data packet <highlight><bold>600</bold></highlight>, *SA info <highlight><bold>632</bold></highlight> being a pointer to information in SA table <highlight><bold>621</bold></highlight> corresponding to the SA associated with data packet <highlight><bold>600</bold></highlight>. Pointer *SA info <highlight><bold>632</bold></highlight> is created by intermediate driver agent <highlight><bold>620</bold></highlight>. Base driver agent <highlight><bold>630</bold></highlight> accesses SA table <highlight><bold>621</bold></highlight> through *SA info <highlight><bold>632</bold></highlight> created by intermediate driver agent <highlight><bold>620</bold></highlight>. Creating and passing pointer *SA info <highlight><bold>632</bold></highlight> may be accomplished by any manner known in the art. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> A pointer is a reference to actual data, typically the address of a location in memory. A pointer can be created by any function for most data structures or data residing in fixed memory locations. A handle is a reference to actual data that is managed by an electronic system OS. The handle can be treated as another system resource, the OS preventing conflicting memory access by multiple functions. Thus, a handle differs from a pointer in that the handle is controlled by the OS, whereas a pointer can be created and controlled by any function. Because *SA info <highlight><bold>632</bold></highlight> is a pointer rather than a handle, base driver agent <highlight><bold>630</bold></highlight> can access the information in SA table <highlight><bold>621</bold></highlight> simply by dereferencing *SA info <highlight><bold>632</bold></highlight>. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> Base driver agent also contains SA table <highlight><bold>631</bold></highlight>, which is a table of SAs that contain all the information necessary to perform crypto operations on data packet <highlight><bold>600</bold></highlight>. Base driver agent <highlight><bold>630</bold></highlight> provides memory management for SA table <highlight><bold>631</bold></highlight>, but SA table <highlight><bold>631</bold></highlight> does not necessarily reside in base driver agent <highlight><bold>630</bold></highlight>. In one embodiment, base driver agent <highlight><bold>630</bold></highlight> uses pointer to *SA info <highlight><bold>632</bold></highlight> to populate SA table <highlight><bold>631</bold></highlight>. For example, if the NI device associated with base driver agent <highlight><bold>630</bold></highlight> was reset, causing the information in SA table <highlight><bold>631</bold></highlight> to be lost, base driver agent <highlight><bold>630</bold></highlight> could use pointer *SA info <highlight><bold>632</bold></highlight> to acquire the specific SA information necessary to perform crypto operations on data packet <highlight><bold>600</bold></highlight> to repopulate the table with that information. Base driver agent <highlight><bold>630</bold></highlight> can also use *SA info <highlight><bold>632</bold></highlight> to acquire the SA information necessary to process data packet <highlight><bold>600</bold></highlight>. For example, if base driver agent <highlight><bold>630</bold></highlight> was reset, the information in SA table <highlight><bold>631</bold></highlight> would be lost, and the SA necessary to process data packet <highlight><bold>600</bold></highlight> could be acquired using *SA info <highlight><bold>632</bold></highlight>. In another example, if NI <highlight><bold>640</bold></highlight> was dynamically installed and was unable to acquire the correct SA state, base driver agent <highlight><bold>630</bold></highlight> could use *SA info <highlight><bold>632</bold></highlight> to acquire the SA information necessary to perform crypto operations. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> Data packet <highlight><bold>600</bold></highlight> is passed to NI <highlight><bold>640</bold></highlight> by base driver agent <highlight><bold>630</bold></highlight>. In one embodiment, NI <highlight><bold>640</bold></highlight> has SA cache <highlight><bold>641</bold></highlight> that contains SA information. In one embodiment, NI <highlight><bold>640</bold></highlight> processes data packet <highlight><bold>600</bold></highlight> with crypto information received from base driver agent <highlight><bold>630</bold></highlight>. NI <highlight><bold>640</bold></highlight> can then transmit data packet <highlight><bold>600</bold></highlight> over a network (not depicted in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>). For example, a data packet can be transmitted over the Internet on a secure traffic stream using IPsec. Some operating systems, for example, Windows&reg; 2000 and Windows&reg; XP, both available from Microsoft Corporation, guarantee that the SA tables are populated. This means that if SA table <highlight><bold>631</bold></highlight> loses it data, to maintain consistency with SA table <highlight><bold>621</bold></highlight> and the OS, the entire cache must be repopulated with data guaranteed by the OS to be in the tables, whether or not the data will be used in the future to perform crypto operations. One advantage to the intermediate driver agent <highlight><bold>620</bold></highlight> passing a pointer to base driver agent <highlight><bold>630</bold></highlight>, is that if SA table <highlight><bold>631</bold></highlight> loses its data, the table can be repopulated as SAs are needed. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> is one embodiment of a flow diagram for reception of a data packet by an electronic system implementing a layered security driver. Data packet <highlight><bold>700</bold></highlight> is received by NI <highlight><bold>710</bold></highlight> from a network (not depicted in <cross-reference target="DRAWINGS">FIG. 7</cross-reference>). For example, data packet <highlight><bold>700</bold></highlight> can be part of a secure network stream from the Internet using IPsec. In one embodiment, NI <highlight><bold>710</bold></highlight> checks data packet <highlight><bold>700</bold></highlight> for its crypto information to determine how to perform crypto operations on data packet <highlight><bold>700</bold></highlight>, such as authentication or decryption. If the crypto information associated with data packet <highlight><bold>700</bold></highlight> is in SA cache <highlight><bold>711</bold></highlight>, NI <highlight><bold>710</bold></highlight> will extract crypto info <highlight><bold>712</bold></highlight>. Although <cross-reference target="DRAWINGS">FIG. 7</cross-reference> depicts data structures of crypto information as containing SAs, SA cache <highlight><bold>711</bold></highlight>, SA table <highlight><bold>721</bold></highlight>, and SA table <highlight><bold>731</bold></highlight> are only example embodiments of data structures of crypto information, and are not limited to containing crypto information data structures that are SAs. In one embodiment, NI <highlight><bold>710</bold></highlight> uses crypto info <highlight><bold>712</bold></highlight> to perform hardware offload processing on data packet <highlight><bold>700</bold></highlight> prior to passing the received data packet <highlight><bold>700</bold></highlight> to base driver agent <highlight><bold>720</bold></highlight>. In another embodiment, the SA necessary for performing crypto operations is not in cache <highlight><bold>711</bold></highlight>, and NI <highlight><bold>710</bold></highlight> passes data packet <highlight><bold>700</bold></highlight> to base driver agent <highlight><bold>720</bold></highlight> without processing the packet. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> Base driver agent <highlight><bold>720</bold></highlight> can be, for example, a NIC driver. In one embodiment, base driver agent <highlight><bold>720</bold></highlight> contains SA table <highlight><bold>721</bold></highlight>, which is a table of SAs that contain all the information necessary to perform cryptography operations on data packet <highlight><bold>700</bold></highlight>. Base driver agent <highlight><bold>720</bold></highlight> provides memory management for SA table <highlight><bold>721</bold></highlight>, but SA table <highlight><bold>721</bold></highlight> does not necessarily reside in base driver agent <highlight><bold>720</bold></highlight>. In one embodiment, base driver agent <highlight><bold>720</bold></highlight> checks SA table <highlight><bold>720</bold></highlight> for the SA associated with data packet <highlight><bold>700</bold></highlight>. If it is not found, it can, for example, create a message indicating that the SA for that secure traffic stream is missing. </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> In one embodiment, base driver agent <highlight><bold>720</bold></highlight> creates SA status <highlight><bold>721</bold></highlight>, which is status information about the processing of data packet <highlight><bold>700</bold></highlight>. In one embodiment, SA status <highlight><bold>722</bold></highlight> indicates one of four predetermined messages regarding the processing of data packet <highlight><bold>700</bold></highlight>. For example, SA status <highlight><bold>722</bold></highlight> may indicate that the packet was processed successfully without requiring hardware offloading. In another example, SA status <highlight><bold>722</bold></highlight> may indicate that the packet was processed successfully by hardware. In another example, SA status <highlight><bold>722</bold></highlight> may indicate that the packet was processed, but that the packet failed to pass authentication. In another example, SA status <highlight><bold>722</bold></highlight> may indicate that the packet could not be processed because there was a missing SA. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> Base driver agent <highlight><bold>720</bold></highlight> passes data packet <highlight><bold>700</bold></highlight> up to intermediate driver agent <highlight><bold>730</bold></highlight>. In one embodiment, intermediate driver agent <highlight><bold>730</bold></highlight> contains packet classifier <highlight><bold>732</bold></highlight>. In one embodiment, intermediate driver agent <highlight><bold>730</bold></highlight> contains SA table <highlight><bold>731</bold></highlight>. Packet classifier <highlight><bold>732</bold></highlight> checks data packet <highlight><bold>700</bold></highlight> for its SA information and matches it to a corresponding SA in SA table <highlight><bold>731</bold></highlight>. In one embodiment, intermediate driver agent <highlight><bold>730</bold></highlight> uses the information in SA status <highlight><bold>722</bold></highlight> passed by base driver agent <highlight><bold>720</bold></highlight> to make decisions regarding the processing of data packet <highlight><bold>700</bold></highlight>. For example, if the message of SA status <highlight><bold>722</bold></highlight> is that the data packet was processed successfully, or that it was processed but failed to pass authentication, no more processing will be performed on data packet <highlight><bold>700</bold></highlight>, and it can be indicated by driver agent <highlight><bold>730</bold></highlight> to the upper layers. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> In another example, if the message of SA status <highlight><bold>722</bold></highlight> is that the data packet could not be processed because the SA was missing, intermediate driver agent <highlight><bold>730</bold></highlight> directs the processing of data packet <highlight><bold>700</bold></highlight>. For example, intermediate driver agent <highlight><bold>730</bold></highlight> may direct the processing of data packet <highlight><bold>700</bold></highlight> by software processing methods known in the art. In another example, intermediate driver agent <highlight><bold>730</bold></highlight> may direct the processing of data packet <highlight><bold>700</bold></highlight> by hardware processing methods known in the art. Intermediate driver agent <highlight><bold>730</bold></highlight> may also choose to add the SA for data packet <highlight><bold>700</bold></highlight> to SA table <highlight><bold>721</bold></highlight> and/or SA cache <highlight><bold>711</bold></highlight> so that future data packets using that SA can be processed with hardware. </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> In one embodiment, intermediate driver agent <highlight><bold>730</bold></highlight> indicates data packet <highlight><bold>700</bold></highlight> to system upper layers. For example, intermediate driver agent <highlight><bold>730</bold></highlight> may be an ANS driver that is the top layer of a BITS/BITW security driver implementation. Thus, intermediate driver agent <highlight><bold>730</bold></highlight> may pass data packet <highlight><bold>700</bold></highlight> to a system upper layer as conventional in known BITS/BITW implementations. In one embodiment, data packet <highlight><bold>700</bold></highlight> is passed to high level application process <highlight><bold>740</bold></highlight>. High level application process <highlight><bold>740</bold></highlight> can be, for example, a TCP/IP stack. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method comprising: 
<claim-text>associating cryptography information with a data packet to be used to perform cryptography operations on the data packet; </claim-text>
<claim-text>storing the cryptography information in memory; </claim-text>
<claim-text>generating a pointer to a memory location for the cryptography information; </claim-text>
<claim-text>passing the pointer to the cryptography information from a first system layer to a second system layer; </claim-text>
<claim-text>accessing the cryptography information not stored in the second system layer using the pointer; </claim-text>
<claim-text>performing cryptography operations on the data packet; and </claim-text>
<claim-text>transmitting the data packet. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein the first system layer comprises an intermediate driver agent. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein the second system layer comprises a base driver agent. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein the cryptography information comprises one or more of: a unique identifier, a network protocol associated with the data packet, a security parameter index, cryptographic keys, a source identifier, and a destination identifier. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein the cryptography information comprises a security association. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein the pointer is used to cache the cryptography information on network hardware. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein accessing the cryptography information not stored in the second system layer is performed by the second system layer to populate a cryptography information table. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference> wherein the population of the cryptography information table is performed when cryptography information for the data packet is needed for network hardware to perform cryptography operations on the data packet. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. A method comprising: 
<claim-text>receiving a data packet; </claim-text>
<claim-text>associating cryptography information with the data packet, the cryptography information to be used to perform cryptography operations on the data packet; </claim-text>
<claim-text>generating a message indicating that the cryptography information necessary to perform cryptography operations on the data packet is not stored in a cryptography information table; and </claim-text>
<claim-text>passing the message from a first system layer to a second system layer. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference> wherein the first system layer comprises a base driver agent. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference> wherein the second system layer comprises an intermediate driver agent. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference> wherein the cryptography information comprises one or more of: a unique identifier, a network protocol associated with the data packet, a security parameter index, cryptographic keys, a source identifier, and a destination identifier. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference> wherein the cryptography information comprises a security association. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference> further comprising the second system layer passing cryptography information to the first system layer to populate the cryptography information table. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference> wherein the second system layer passing cryptography information to populate the cryptography information table occurs only as the cryptography information is needed to perform cryptography operations on a data packet. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference> wherein passing the message causes the second system layer to determine which of multiple methods of data packet processing should be used to process the data packet. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. An article comprising a machine-accessible medium to provide machine-readable instructions that, when executed, cause one or more electronic systems to: 
<claim-text>associate cryptography information with a data packet to be used to perform cryptography operations on the data packet; </claim-text>
<claim-text>store the cryptography information in memory; </claim-text>
<claim-text>generate a pointer to a memory location for the cryptography information; </claim-text>
<claim-text>pass the pointer to the cryptography information from a first system layer to a second system layer; </claim-text>
<claim-text>access the cryptography information not stored in the second system layer using the pointer; </claim-text>
<claim-text>perform cryptography operations on the data packet; and </claim-text>
<claim-text>transmit the data packet. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The article of <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference> wherein the pointer is used to cache the cryptography information on network hardware. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The article of <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference> wherein accessing the cryptography information not stored in the second system layer is performed by the second system layer to populate a cryptography information table. </claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The article of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference> wherein the population of the cryptography information table is performed when cryptography information for the data packet is needed for network hardware to perform cryptography operations on the data packet. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. An article comprising a machine-accessible medium to provide machine-readable instructions that, when executed, cause one or more electronic systems to: 
<claim-text>receive a data packet; </claim-text>
<claim-text>associate cryptography information with the data packet, the cryptography information to be used to perform cryptography operations on the data packet; </claim-text>
<claim-text>generate a message indicating that the cryptography information necessary to perform cryptography operations on the data packet is not stored in a cryptography information table; and </claim-text>
<claim-text>pass the message from a first system layer to a second system layer. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The article of <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference> further comprising the second system layer passing cryptography information to the first system layer to populate the cryptography information table. </claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The article of <dependent-claim-reference depends_on="CLM-00022">claim 22</dependent-claim-reference> wherein the second system layer passing cryptography information to populate the cryptography information table occurs only as the cryptography information is needed to perform cryptography operation on the data packet. </claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The article of <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference> wherein passing the message causes the second system layer to determine which of multiple methods of data packet processing should be used to process the data packet. </claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. An electronic data signal embodied in a data communications medium shared among a plurality of network devices comprising sequences of instructions that, when executed, cause one or more electronic systems to: 
<claim-text>associate cryptography information with a data packet to be used to perform cryptography operations on the data packet; </claim-text>
<claim-text>store the cryptography information in memory; </claim-text>
<claim-text>generate a pointer to a memory location for the cryptography information; </claim-text>
<claim-text>pass the pointer to the cryptography information from a first system layer to a second system layer; </claim-text>
<claim-text>access the cryptography information not stored in the second system layer using the pointer; </claim-text>
<claim-text>perform cryptography operations on the data packet; and </claim-text>
<claim-text>transmit the data packet. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. The electronic data signal of <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference> wherein the pointer is used to cache the cryptography information on network hardware. </claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. The electronic data signal of <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference> wherein accessing the cryptography information not stored in the second driver agent is performed by the second system layer to populate a cryptography information table. </claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. The electronic data signal of <dependent-claim-reference depends_on="CLM-00022">claim 27</dependent-claim-reference> wherein the population of the cryptography information table is performed when cryptography information for the data packet is needed for network hardware to perform cryptography operations on the data packet. </claim-text>
</claim>
<claim id="CLM-00029">
<claim-text><highlight><bold>29</bold></highlight>. An electronic data signal embodied in a data communications medium shared among a plurality of network devices comprising sequences of instructions that, when executed, cause one or more electronic systems to: 
<claim-text>receive a data packet; </claim-text>
<claim-text>associate cryptography information with the data packet, the cryptography information to be used to perform cryptography operations on the data packet; </claim-text>
<claim-text>generate a message indicating that the cryptography information necessary to perform cryptography operations on the data packet is not stored in a cryptography information table; and </claim-text>
<claim-text>pass the message from a first system layer to a second system layer. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00030">
<claim-text><highlight><bold>30</bold></highlight>. The electronic data signal of <dependent-claim-reference depends_on="CLM-00022">claim 29</dependent-claim-reference> further comprising the second system layer passing cryptography information to the first system layer to populate the cryptography information table. </claim-text>
</claim>
<claim id="CLM-00031">
<claim-text><highlight><bold>31</bold></highlight>. The electronic data signal of <dependent-claim-reference depends_on="CLM-00033">claim 30</dependent-claim-reference> wherein the second system layer passing cryptography information to populate the cryptography information table occurs only as the cryptography information is needed to perform cryptography operations on a data packet. </claim-text>
</claim>
<claim id="CLM-00032">
<claim-text><highlight><bold>32</bold></highlight>. The electronic data signal of <dependent-claim-reference depends_on="CLM-00022">claim 29</dependent-claim-reference> wherein passing the message causes the second system layer to determine which of multiple methods of data packet processing should be used to process the data packet. </claim-text>
</claim>
<claim id="CLM-00033">
<claim-text><highlight><bold>33</bold></highlight>. An apparatus comprising a first system layer coupled to a second system layer, the first system layer to store cryptography information in memory, and to generate and to pass to the second system layer a pointer to cryptography information stored in memory, the cryptography information necessary to perform cryptography operations on a data packet, the second system layer to access the cryptography information not stored in the second system layer using the pointer. </claim-text>
</claim>
<claim id="CLM-00034">
<claim-text><highlight><bold>34</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00033">claim 33</dependent-claim-reference> wherein the first system layer comprises an intermediate driver agent. </claim-text>
</claim>
<claim id="CLM-00035">
<claim-text><highlight><bold>35</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00033">claim 33</dependent-claim-reference> wherein the second system layer comprises a base driver agent. </claim-text>
</claim>
<claim id="CLM-00036">
<claim-text><highlight><bold>36</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00033">claim 33</dependent-claim-reference> wherein the pointer is used to cache the cryptography information on network hardware. </claim-text>
</claim>
<claim id="CLM-00037">
<claim-text><highlight><bold>37</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00033">claim 33</dependent-claim-reference> wherein accessing the cryptography information not stored in the second system layer is performed by the second system layer to populate a cryptography information table. </claim-text>
</claim>
<claim id="CLM-00038">
<claim-text><highlight><bold>38</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00033">claim 37</dependent-claim-reference> wherein the population of the cryptography information table is performed when cryptography information for the data packet is needed for network hardware to perform cryptography operations on the data packet. </claim-text>
</claim>
<claim id="CLM-00039">
<claim-text><highlight><bold>39</bold></highlight>. An apparatus comprising a first system layer coupled to a second system layer, the first system layer to generate a message indicating that cryptography information necessary to perform cryptography operations on a data packet is not stored in a cryptography information table, and to pass to the second system layer the message. </claim-text>
</claim>
<claim id="CLM-00040">
<claim-text><highlight><bold>40</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00033">claim 39</dependent-claim-reference> wherein the first system layer comprises a base driver agent. </claim-text>
</claim>
<claim id="CLM-00041">
<claim-text><highlight><bold>41</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00033">claim 39</dependent-claim-reference> wherein the second system layer comprises an intermediate driver agent. </claim-text>
</claim>
<claim id="CLM-00042">
<claim-text><highlight><bold>42</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00033">claim 39</dependent-claim-reference> further comprising the second system layer passing cryptography information to the first system layer to populate the cryptography information table. </claim-text>
</claim>
<claim id="CLM-00043">
<claim-text><highlight><bold>43</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00044">claim 42</dependent-claim-reference> wherein the second system layer passing cryptography information to populate the cryptography information table occurs only as the cryptography information is needed to perform cryptography operations on the data packet. </claim-text>
</claim>
<claim id="CLM-00044">
<claim-text><highlight><bold>44</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00033">claim 39</dependent-claim-reference> wherein passing the message causes the second system layer to determine which of multiple methods of data packet processing should be used to process the data packet.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>6</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005279A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005279A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005279A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005279A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005279A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005279A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030005279A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030005279A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
