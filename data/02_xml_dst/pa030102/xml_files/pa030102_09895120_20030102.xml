<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005178A1-20030102-D00000.TIF SYSTEM "US20030005178A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005178A1-20030102-D00001.TIF SYSTEM "US20030005178A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005178A1-20030102-D00002.TIF SYSTEM "US20030005178A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005178A1-20030102-D00003.TIF SYSTEM "US20030005178A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005178A1-20030102-D00004.TIF SYSTEM "US20030005178A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005178A1-20030102-D00005.TIF SYSTEM "US20030005178A1-20030102-D00005.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005178</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09895120</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010629</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F015/16</ipc>
</classification-ipc-primary>
<classification-ipc-secondary>
<ipc>H04L009/00</ipc>
</classification-ipc-secondary>
<classification-ipc-secondary>
<ipc>G06F009/00</ipc>
</classification-ipc-secondary>
<classification-ipc-secondary>
<ipc>G06F009/46</ipc>
</classification-ipc-secondary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>709</class>
<subclass>328000</subclass>
</uspc>
</classification-us-primary>
<classification-us-secondary>
<uspc>
<class>709</class>
<subclass>229000</subclass>
</uspc>
</classification-us-secondary>
<classification-us-secondary>
<uspc>
<class>713</class>
<subclass>168000</subclass>
</uspc>
</classification-us-secondary>
</classification-us>
<title-of-invention>Secure shell protocol access control</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>David</given-name>
<middle-name>Kurt</middle-name>
<family-name>Hemsath</family-name>
</name>
<residence>
<residence-us>
<city>Round Rock</city>
<state>TX</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
</inventors>
<assignee>
<organization-name>International Business Machines Corporation</organization-name>
<address>
<city>Armonk</city>
<state>NY</state>
</address>
<assignee-type>02</assignee-type>
</assignee>
<correspondence-address>
<name-1>Robert H. Frantz</name-1>
<name-2></name-2>
<address>
<address-1>P.O. Box 23324</address-1>
<city>Oklahoma City</city>
<state>OK</state>
<postalcode>73123-2334</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">An enhanced Secure Shell (SSH) protocol having fine-grained access security policy management and enforcement. Via an authorization application programming interface (aznAPI), remote user protocol connections and sessions may be added to the protected object space of a policy management system so that a system administrator may set permissions to access or use a particular secured system resource for each user, and by groups of users. Thus, when a user accesses the system by Secure Shell, rather than having full, unlimited use and access to system resources once authenticated, the user is granted permission to access only the system resources allowed in the security policy or policies. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> 1. Field of the Invention </paragraph>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> This invention relates to the arts of remote access to secure computer resources, and especially to the arts of remote secure administration of networked computer systems. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> 2. Description of the Related Art </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> Prior to the advent of the Secure Shell (SSH) protocol, specific UNIX system commands were available to be used by remote employees and users of networked computers, such as &ldquo;rlogin&rdquo; instead of &ldquo;login&rdquo;. As such, there existed a collection of special versions of standard UNIX TCP/IP commands which could be executed remotely, whether it was Telnet, Login, or FTP, etc. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> Subsequently, user authentification was added to these remote capabilities, as well as some level of encryption of the data communicated across an unsecured computer network between a remote user and a UNIX server. Authentication is the process of determining that a user attempting to remotely gain access to a system is actually the user he or she claims to be. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> The SSH is a well-known program and a protocol for secure remote login and other secure network services over an unsecured network for UNIX-based networked computer systems. It has application in intranet environments, such as university computer systems, and it is anticipated that SSH will be more widely used for providing broadband, such as cable modems and xDSL, for Internet users to access to their systems and applications within their intranet environment. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> Further, the growth in the number of corporate employees who &ldquo;telecommute&rdquo; part-time or full-time is a significant fraction of the global work force, today. SSH provides a nearly-transparent method of providing a secure connection to user applications. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> As shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, an SSH client (<highlight><bold>15</bold></highlight>) computer communicates to an SSH server (<highlight><bold>16</bold></highlight>) computer through an SSH protocol stack. The SSH client (<highlight><bold>15</bold></highlight>) and SSH Server (<highlight><bold>16</bold></highlight>) typically are based upon well-known computer platforms (<highlight><bold>17</bold></highlight>) such as personal computers or workstations, which each typically have a microprocessor, memory, an operating system, user input/output devices (keyboard, mouse, display, etc.), hard disk drives, and a network interface to a computer network (dial-up modem, local area network, etc.). In the case of SSH usage, the SSH server is typically provided with a UNIX-like operating system, such as IBM&apos;s AIX &lsqb;TM&rsqb;, Hewlett-Packard&apos;s HP-UX &lsqb;TM&rsqb;, or Linux. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> There are many implementations of SSH available in the industry, some having minimal features, and others being more feature rich. In general, though, they all share the same stack structure in order to gain some level of compatibility with each other. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> The SSH protocol stack consists of three major components. The Transport Layer Protocol (<highlight><bold>11</bold></highlight>) provides server authentication, confidentiality and integrity. In this &ldquo;layer&rdquo; of the stack, the two systems first negotiate which version of SSH will be used for communications (A), then a form or type of cryptography is selected which both client and server can support (B). If these steps are successful, a session key is established on the SSH Server (<highlight><bold>16</bold></highlight>). The Transport Layer (<highlight><bold>11</bold></highlight>) typically runs over a transmission control protocol/Internet protocol (&ldquo;TCP/IP&rdquo;) connection (<highlight><bold>10</bold></highlight>), but might also be used over any other reliable, connection-oriented data stream. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> Next, the User Authentication Protocol (<highlight><bold>12</bold></highlight>) layers negotiate (D) an authentication model for use, followed by actual authentication (E) of the remote user&apos;s identity. Upon successful authentication completion, the User Authentication Protocol layer establishes a protected tunnel for the Connection Protocol to use. The User Authentication Protocol supports public key, password and host-based client authentication methods. However, these are just three instances of possible client authentication methods that are built on this protocol&apos;s authentication framework. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> Third, the SSH Connection Protocol (<highlight><bold>13</bold></highlight>) then multiplexes the authenticated, protected tunnel into multiple logical channels for use by a plurality of application programs running on the SSH Server and SSH Client. The Connection Protocol (<highlight><bold>13</bold></highlight>) runs over the User Authentication Protocol (<highlight><bold>12</bold></highlight>), as shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> Above this entire stack may run the client-side application program or programs (<highlight><bold>14</bold></highlight>), such as Shell, Telnet, FTP, etc. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> The programs implementing the SSH protocol are not standardized, but they are provided by various vendors and OpenSource providers. Typically, a SSH program is built on top of the SSH protocol. The SSH protocol is currently described by four Internet drafts from the Internet Engineering Task Force (IETF), including &ldquo;SSH Protocol Architecture&rdquo;, &ldquo;SSH Transport Layer Protocol&rdquo;, &ldquo;SSH Authentication Protocol&rdquo;, and &ldquo;SSH Connection Protocol&rdquo;. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> The SSH Connection Protocol standards describe, but do not define, how the SSH Server side of this protocol must enforce whether or not to accept a client&apos;s request for a new logical channel over which to run an application program, such as Telnet. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> Therefore, security policy management and enforcement is implemented differently by each SSH provider. Each implementation typically has its own management interface, semantics, etc. For example, some implementations of the server side of the SSH Connection protocol only provide a &ldquo;binary policy,&rdquo; i.e. an authenticated user can request any number of logical channels and use all applications available through the SSH connection once the client has been authenticated. In such a situation, there is no application-specific or other criteria-specific access control provided. When a client has gained authorization, he or she effectively has access to all secured system resources. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> This can be undesirable in many situations where it is desirable to grant access to a remote client to only a portion of the total secured system resources. Therefore, there is a need in the art for a robust policy management and enforcement service for the Secure Shell protocol which provides fine-grained, user-specific access to secured system resources. </paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> The following detailed description when taken in conjunction with the figures presented herein provide a complete disclosure of the invention. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> illustrates the layered organization of the well-known Secure Shell protocol stack, interactions between the stack layers, and the process of authentication of a user. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> sets forth details of the enhanced Secure Shell protocol stack. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> illustrates the data flow between processes of the Secure Shell server according to the preferred embodiment. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> discloses the logical process of creating an associated set of user credentials and session key/ID. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> discloses the logical process of determining whether or not to allocate a new logical channel based upon fine-grained access security policy. </paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> The invention provides a fine-grained access security policy management and enforcement service for the well-known Secure Shell protocol by improving a SSH server protocol stack to include extensions to interface to an authorization service via an authorization application programming interface aznAPI. The enhanced SSH server protocol stack may interface to a standard, unmodified SSH client protocol stack, while providing improved authorization access according to a detailed security policy. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> Following normal SSH transport layer negotiations, session key establishment, and user authentication layer operations, the SSH server stack creates a set of user credentials using an authorization service, and associates the credentials with the session key. Then, whenever a request for a new logical channel is received from the authenticated client, the server&apos;s SSH Connection layer determines whether or not to allow the logical channel based upon the results of a query to the authorization service. The authorization service maintains a policy database of allow users and permissions, preferably in a centralized location for ease of administration. </paragraph>
</section>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF THE INVENTION </heading>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> The present invention is preferably implemented in conjunction with a suitable network security management server such as Tivoli&apos;s Policy Director &lsqb;TM&rsqb; product, running on a suitable operating system, such as HP-UX &lsqb;TM&rsqb;, Solaris &lsqb;TM&rsqb;, UNIX, or IBM&apos;s AIX &lsqb;TM&rsqb;. Any suitable networked computer server platform, such as a personal computer, may be employed in the invention. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> It will, however, be recognized by those skilled in the art, that the authorization process disclosed herein may be realized individually, or as an improvement to other authorization processes on other server platforms. As such, the following detailed disclosure is given with respect to the preferred embodiment associated with the Policy Director &lsqb;TM&rsqb; product, which should not be viewed as a limitation or requirement of the present invention. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> Further according to the preferred embodiment, an authorization service which is accessible via the Open Group Technical Standard Authorization API (aznAPI) is employed as the authorization service, although alternate proprietary or non-standard authorization services could be employed as well. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> Turning to <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, this invention is realized through two extensions to the existing SSH Protocol. The first extension is the addition of an aznAPI-based authentication method (<highlight><bold>20</bold></highlight>) to the SSH User Authentication Protocol (<highlight><bold>12</bold></highlight>&prime;) on the SSH Server (<highlight><bold>16</bold></highlight>&prime;). The second extension is the provision of an aznAPI-based Access Decision Function (ADF) (<highlight><bold>21</bold></highlight>) in the server side of the SSH Connection (<highlight><bold>13</bold></highlight>&prime;) protocol. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> One advantage of this method is that the SSH User Authentication protocol remains unchanged for the client side, which avoids the need to distribute new software to many client computers. All the changes to the standard SSH stack are made to the server-side software, where it is easily controlled and administered by a system administrator. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> During session creation, many of the initial steps are unchanged from the well-known SSH process. First, the SSH transport layers (<highlight><bold>11</bold></highlight>) negotiate (A) a compatible SSH version to use, negotiate (B) a cryptography technology to use, and a session key is established and stored (C) in the server&apos;s cache (<highlight><bold>26</bold></highlight>). </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> Following the typical negotiation and cryptography selection steps (A, B, and C), the enhanced server-side SSH User Authentication service (<highlight><bold>12</bold></highlight>&prime;) negotiates (E) which authentication model to use, such as password or public key infrastructure (PKI), and normal user authentication is completed (F). </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> Turning to <cross-reference target="DRAWINGS">FIG. 3</cross-reference>, the data flow relationships between the enhanced server-side SSH processes are shown in more detail. Rather than immediately allowing the SSH connection layers to proceed with establishing multiplexed logical channels into the secured tunnel, the enhanced server-side SSH User Authentication service (<highlight><bold>12</bold></highlight>&prime;) maps the user&apos;s identity (e.g., username, domain name, host name, etc.) to a canonical identity useful for submitting to the authorization service via the aznAPI (<highlight><bold>25</bold></highlight>). This mapped ID is submitted (G) to an Authentication Service (<highlight><bold>30</bold></highlight>), preferably via the standard aznAPI, which checks it against a user registry (<highlight><bold>22</bold></highlight>). The Authorization Service (<highlight><bold>30</bold></highlight>) returns (H) a credential binding the client&apos;s identity to a set of privileges. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> According to the preferred embodiment, the user registry (<highlight><bold>22</bold></highlight>) is preferably the same one used for all aznAPI applications on the server, although there could be many more than just the SSH extensions, and thus represents another improvement over typical SSH implementations by consolidating SSH users into a single, centralized user registry. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> Next, the credential is cached (I) by the enhanced SSH User Authentication service (<highlight><bold>12</bold></highlight>&prime;) where it is associated (J) with the session key/identity established earlier by the SSH Transport service (<highlight><bold>11</bold></highlight>). </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> Subsequently, when an application program or a user of the SSH client requests a new logical channel to be established, the enhanced server SSH Connection service (<highlight><bold>13</bold></highlight>&prime;) posts (K) a logical channel request including the session key/ID to the new Authorization Decision Function (ADF) (<highlight><bold>21</bold></highlight>). </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> The ADF (<highlight><bold>21</bold></highlight>) uses the session key/ID to retrieve (L) the associated credential from cache (<highlight><bold>26</bold></highlight>), and submits them in a action request to an Authorization Service (<highlight><bold>13</bold></highlight>), preferably via the aznAPI (<highlight><bold>25</bold></highlight>). </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> The Authorization Service (<highlight><bold>31</bold></highlight>) evaluates the action request and credentials in view of a security policy database containing a list of allowed or permitted actions for each user and user group, and returns a recommendation (<highlight><bold>0</bold></highlight>) for approval or rejection of the request. In turn, the ADF (<highlight><bold>21</bold></highlight>) provides the SSH Connection service (<highlight><bold>13</bold></highlight>&prime;) with an &ldquo;OK&rdquo; or &ldquo;Not OK&rdquo; response. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> Finally, if the logical channel is approved, the SSH Connection layer (<highlight><bold>13</bold></highlight>&prime;) creates or allocates the new channel, otherwise, the channel is not created. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> Turning to <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, the logical process of establishing the user credential is shown in detail. First, a session key/ID is created (<highlight><bold>41</bold></highlight>) and stored (<highlight><bold>42</bold></highlight>) in server cache or memory. The user ID is then mapped (<highlight><bold>43</bold></highlight>) to a format compatible with the Authentication Service employed, and a set of credentials are created (<highlight><bold>44</bold></highlight>) by an Authorization Service. Finally, the credentials are stored in server cache and associated (<highlight><bold>45</bold></highlight>) with the session key/ID. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> shows the logical process of determining whether or not to approve a request for allocation of a new logical channel based on a fine-grained access security policy. When a request for a new logical channel is received (<highlight><bold>51</bold></highlight>) from a client, the session key/ID is used to retrieve (<highlight><bold>52</bold></highlight>) the associated credential from server memory or cache. Then, the credential is passed (<highlight><bold>53</bold></highlight>) to an Authorization Service, preferably via the aznAPI. The Authorization Service consults the security policy repository, and a recommendation (<highlight><bold>54</bold></highlight>) is made to approve or disapprove the request for a new logical channel. Then, the logical channel is either established or disallowed (<highlight><bold>55</bold></highlight>). </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> According to the preferred embodiment, the Authorization Service and Authentication Service employed to realize the invention are those services of the aforementioned Policy Director &lsqb;TM&rsqb;. However, alternate authorization and authentication service products could be employed. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> The policy management function of the preferred embodiment allows for each protected object, such as a particular server application program or resource, to have an entry in an Access Control List (ACL) in the policy database. Many policy management systems have similar capabilities, and access control lists are well-known in the art. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> Each entry in an ACL is attached to a protected object. For example, an ACL entry such as: </paragraph>
<paragraph lvl="0"><in-line-formula>user b_smith --------r--C </in-line-formula></paragraph>
<paragraph id="P-0045" lvl="2"><number>&lsqb;0045&rsqb;</number> might indicate that the user having user ID of &ldquo;b_smith&rdquo; is permitted to read a particular system file, as indicated by the permission &ldquo;r&rdquo;. Also, the permission &ldquo;C&rdquo; might indicate that the user has the privilege to connect to a particular application program. An ACL may be kept in individual data objects, text files, or database records, depending on the implementation of the policy management system. Through these mechanisms, the policy management system can evaluate specific requests for specific actions to specific protected objects, thus allowing for &ldquo;fine-grained&rdquo; access control of the protected objects. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> As the preferred embodiment uses the open aznAPI to interface to a policy management system, it is of little consequence exactly how the policy management system stores ACL, but is only important that it support the API and provide the fine-grained access control in order to meet the objectives of the present invention. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> As such, this invention provides a standards-based and standards-compatible method for SSH implementors to provide fine-grained application-level and channel-level access control, while concurrently enabling SSH to be managed as part of a larger set of aznAPI-based applications within the protected object space of a networked server system. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> The foregoing description has been set forth with particular details relating to the preferred embodiment. It will be recognized by those skilled in the art that many departures from the disclosed preferred embodiment, such as implementation of the method as a &ldquo;stand alone&rdquo; process, or inclusion of the method with alternate server software, operating systems or computing platforms, may be made without departing from the spirit and scope of the invention. Therefore, the scope of the present invention should be determined by the following claims. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method of providing fine-grained access for remote clients to secured resources of a computer system, said computer system having a user registry and an access control policy repository, said method comprising the steps of: 
<claim-text>caching a session key and ID; </claim-text>
<claim-text>generating a set of user credentials binding a user ID to a set of privileges; </claim-text>
<claim-text>associating said credentials with said cached session key and ID; and </claim-text>
<claim-text>performing a security policy approval responsive to a request allocation of a logical channel, said approval considering permissions set in said access control policy repository in comparison to said cached session key, ID and associated credentials. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method as set forth in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein said step of caching a session key and ID is performed from a transport layer of a communications protocol stack. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method as set forth in <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference> wherein said performance from a transport layer of a communications protocol stack is performed from a Secure Shell transport layer. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method as set forth in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein said step of associating said credentials with said cached session key and ID is performed from a user authentication layer of a communications protocol stack. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method as set forth in <dependent-claim-reference depends_on="CLM-00004">claim 4</dependent-claim-reference> wherein said performance from a user authentication layer of a communications protocol stack is performed from a Secure Shell user authentication layer of a communications protocol stack. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method as set forth in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein said step of performing a security policy approval is performed from a connection layer of a communications protocol stack. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The method as set forth <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference> wherein said performance of a security policy approval is performed from a Secure Shell connection layer of a communications protocol stack. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The method as set forth in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein said step of generating a set of user credentials binding a user ID to a set of privileges is performed via a standard Authorization Application Programming Interface. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The method as set forth in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein said step of performing a security policy approval is performed via a standard Authorization Application Programming Interface. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. A computer readable medium encoded with software for providing fine-grained access for remote clients to secured resources of a computer system, said computer system having a user registry and an access control policy repository, said software when executed causing the computer system to perform the steps of: 
<claim-text>caching a session key and ID; </claim-text>
<claim-text>generating a set of user credentials binding a user ID to a set of privileges; </claim-text>
<claim-text>associating said credentials with said cached session key and ID; and </claim-text>
<claim-text>performing a security policy approval responsive to a request allocation of a logical channel, said approval considering permissions set in said access control policy repository in comparison to said cached session key, ID and associated credentials. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The computer readable medium as set forth in <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference> wherein said software for caching a session key and ID is executable from a transport layer of a communications protocol stack. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The computer readable medium as set forth in <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference> wherein said software is executable from a Secure Shell transport layer. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The computer readable medium as set forth in <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference> wherein said software for associating said credentials with said cached session key and ID is executable from a user authentication layer of a communications protocol stack. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The computer readable medium as set forth in <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference> wherein said software is executable from a Secure Shell user authentication layer of a communications protocol stack. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The computer readable medium as set forth in <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference> wherein said software for performing a security policy approval is executable from a connection layer of a communications protocol stack. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The computer readable medium as set forth <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference> wherein said software is executable from a Secure Shell connection layer of a communications protocol stack. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The computer readable medium as set forth in <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference> wherein said software for generating a set of user credentials which bind a user ID to a set of privileges is executable via a standard Authorization Application Programming Interface. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The computer readable medium as set forth in <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference> wherein said software for performing a security policy approval is executable via a standard Authorization Application Programming Interface. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. A system for providing fine-grained access for remote clients to secured resources of a computer, said computer having a user registry and an access control policy repository, said system comprising: 
<claim-text>a session key and ID in a cache; </claim-text>
<claim-text>a set of user credentials binding a user ID to a set of privileges associated with session key and ID; and </claim-text>
<claim-text>a security policy approval service which, responsive to a request allocation of a logical channel, is adapted to consider a permissions set in said access control policy repository in comparison to said cached session key, ID and associated credentials. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The system as set forth in <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference> wherein said session key and ID is modifiable from transport layer of a communications protocol stack. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The system as set forth in <dependent-claim-reference depends_on="CLM-00022">claim 20</dependent-claim-reference> wherein said transport layer of a communications protocol stack is a Secure Shell transport layer service. </claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The system as set forth in <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference> wherein said credential association with a session key/ID is adapted to be created by a user authentication layer of a communications protocol stack. </claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The system as set forth in <dependent-claim-reference depends_on="CLM-00022">claim 22</dependent-claim-reference> wherein said authentication layer of a communications protocol stack is a Secure Shell user authentication layer service of a communications protocol stack. </claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The system as set forth in <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference> wherein said security policy approval service is accessible from a connection layer of a communications protocol stack. </claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. The system as set forth <dependent-claim-reference depends_on="CLM-00022">claim 24</dependent-claim-reference> wherein said security policy approval service is a Secure Shell connection layer service. </claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. The system as set forth in <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference> wherein said user credentials a credentials created via a standard Authorization Application Programming Interface. </claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. The system as set forth in <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference> wherein said security policy approval service is accessible via a standard Authorization Application Programming Interface. </claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. A protocol stack communications subsystem in a computer system, said computer system having a user registry and an access control policy repository, said subsystem comprising: 
<claim-text>a session key and ID stored in a computer cache; </claim-text>
<claim-text>a set of user credentials which bind a user ID to a set of privileges; </claim-text>
<claim-text>a credential associated with said cached session key and ID; and </claim-text>
<claim-text>a security policy approval service adapted to consider a permissions set in said access control policy repository in comparison to said cached session key, ID and associated credential, responsive to a request allocation of a logical channel. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00029">
<claim-text><highlight><bold>29</bold></highlight>. The protocol stack communications subsystem as set forth in <dependent-claim-reference depends_on="CLM-00022">claim 28</dependent-claim-reference> wherein said subsystem further comprises a transport layer service which is adapted to create and deposit said session key and ID into computer cache. </claim-text>
</claim>
<claim id="CLM-00030">
<claim-text><highlight><bold>30</bold></highlight>. The protocol stack communications subsystem as set forth in <dependent-claim-reference depends_on="CLM-00022">claim 29</dependent-claim-reference> wherein said transport layer services is a Secure Shell protocol transport layer. </claim-text>
</claim>
<claim id="CLM-00031">
<claim-text><highlight><bold>31</bold></highlight>. The protocol stack communications subsystem as set forth in <dependent-claim-reference depends_on="CLM-00022">claim 28</dependent-claim-reference> further comprising a user authentication layer service which is adapted to obtain a credential from an authentication service, and to associate said credential with said cached session key and ID. </claim-text>
</claim>
<claim id="CLM-00032">
<claim-text><highlight><bold>32</bold></highlight>. The protocol stack communications subsystem as set forth in <dependent-claim-reference depends_on="CLM-00033">claim 31</dependent-claim-reference> wherein said user authentication layer service is a Secure Shell protocol user authentication layer service. </claim-text>
</claim>
<claim id="CLM-00033">
<claim-text><highlight><bold>33</bold></highlight>. The protocol stack communications subsystem as set forth in <dependent-claim-reference depends_on="CLM-00022">claim 28</dependent-claim-reference> further comprising a connection layer service adapted to obtain an policy approval decision from an authorization service. </claim-text>
</claim>
<claim id="CLM-00034">
<claim-text><highlight><bold>34</bold></highlight>. The protocol stack communications subsystem as set forth in <dependent-claim-reference depends_on="CLM-00033">claim 33</dependent-claim-reference> wherein said connection layer service is a Secure Shell protocol connection layer service.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>2</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005178A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005178A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005178A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005178A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005178A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005178A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
