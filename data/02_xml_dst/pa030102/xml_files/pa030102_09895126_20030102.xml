<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005182A1-20030102-D00000.TIF SYSTEM "US20030005182A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005182A1-20030102-D00001.TIF SYSTEM "US20030005182A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005182A1-20030102-D00002.TIF SYSTEM "US20030005182A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005182A1-20030102-D00003.TIF SYSTEM "US20030005182A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005182A1-20030102-D00004.TIF SYSTEM "US20030005182A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005182A1-20030102-D00005.TIF SYSTEM "US20030005182A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030005182A1-20030102-D00006.TIF SYSTEM "US20030005182A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030005182A1-20030102-D00007.TIF SYSTEM "US20030005182A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030005182A1-20030102-D00008.TIF SYSTEM "US20030005182A1-20030102-D00008.TIF" NDATA TIF>
<!ENTITY US20030005182A1-20030102-D00009.TIF SYSTEM "US20030005182A1-20030102-D00009.TIF" NDATA TIF>
<!ENTITY US20030005182A1-20030102-D00010.TIF SYSTEM "US20030005182A1-20030102-D00010.TIF" NDATA TIF>
<!ENTITY US20030005182A1-20030102-D00011.TIF SYSTEM "US20030005182A1-20030102-D00011.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005182</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09895126</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010629</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F003/00</ipc>
</classification-ipc-primary>
<classification-ipc-secondary>
<ipc>G06F003/02</ipc>
</classification-ipc-secondary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>710</class>
<subclass>001000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Method and apparatus for period promotion avoidance for hubs</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Brian</given-name>
<middle-name>A.</middle-name>
<family-name>Leete</family-name>
</name>
<residence>
<residence-us>
<city>Beaverton</city>
<state>OR</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>John</given-name>
<middle-name>I.</middle-name>
<family-name>Garney</family-name>
</name>
<residence>
<residence-us>
<city>Portland</city>
<state>OR</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>BLAKELY SOKOLOFF TAYLOR &amp; ZAFMAN</name-1>
<name-2></name-2>
<address>
<address-1>12400 WILSHIRE BOULEVARD, SEVENTH FLOOR</address-1>
<city>LOS ANGELES</city>
<state>CA</state>
<postalcode>90025</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A device is presented including a host controller capable of attaching a quantity of queue heads to a frame list. The quantity of queue heads are attached to the frame list before any transaction descriptors. Further presented is a method including determining whether a queue head has less than or equal to a predetermined packet size and whether a period is one of greater than and equal to a predetermined schedule window. The method includes storing contents of a current entry in a frame list in a next pointer in the queue head. Also replacing the current entry in the frame list with a pointer to a new queue head. Many queue heads are directly coupled to the frame list. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> 1. Field of the Invention </paragraph>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> This invention relates to universal serial bus (USB) environments, and more particularly to a method and apparatus to improve performance of an enhanced host controller interface (EHCI) for USB devices. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> 2. Description of the Related Art </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> In many of today&apos;s processors and systems, such as personal computer (PC) systems, there exist USB ports for connecting various USB devices. Many USB devices are frequently used by PC users. For example, USB devices may be printers, compact disc read-only memory (CD-ROM) drives, CDROM writer (CDRW) drives, digital versatile disc (DVD) drives, cameras, pointing devices (e.g., computer mouse), keyboards, joy-sticks, hard-drives, speakers, etc. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> Different standards of USB technology have different bandwidths. For example, Universal Serial Bus Specification, revision 1.1, Sep. 23, 1998 (USB 1.1) devices are capable of operating at 12 Mbits/second (Mbps), and Universal Serial Bus Specification, revision 2.0, Apr. 27, 2000 (USB <highlight><bold>2</bold></highlight>.<highlight><bold>0</bold></highlight>; also known as high-speed USB) devices are capable of operating at 480 Mbps. USB 2.0 defines a multiple speed-signaling environment where a single high-speed bus may support one or more USB 1.1 classic busses through a USB 2.0 hub (Transaction Translator). In this environment, system software (the Host Controller Driver) must allocate and manage the bandwidth of USB 1.1 classic busses. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> The Enhanced Host Controller Interface (EHCI) specification for a Universal Serial Bus, revision 0.95, Nov. 10, 2000, describes the register-level interface for a Host Controller (HC) for USB 2.0. In the USB EHCI specification, a single data structure known as the interrupt queue head is defined. The interrupt queue head represents and manages traffic to interrupt endpoints behind a given transaction translator (TT). A timed event, known as period promotion, may consume up to 255&times; the typical bandwidth of interrupt queue heads. Therefore, period promotion consumes a large portion of bandwidth in a USB 2.0 system. Thus, period promotion is very costly in a USB 2.0 system in terms of bandwidth usage.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> The invention is illustrated by way of example and not by way of limitation in the figures of the accompanying drawings in which like references indicate similar elements. It should be noted that references to &ldquo;an&rdquo; or &ldquo;one&rdquo; embodiment in this disclosure are not necessarily to the same embodiment, and such references mean at least one. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> illustrates a Universal Serial Bus (USB) system. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> illustrates a USB host controller. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> illustrates an enhanced host controller interface (EHCI). </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> illustrates a queue head structure layout. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> illustrates a periodic schedule. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference>A-B illustrates a structure of a isochronous transfer descriptor (iTD). </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> illustrates a structure of a split-transaction isochronous transfer descriptor (siTD). </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> illustrates an embodiment of the invention having queue heads coupled directly to a frame list. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference> illustrates a block diagram of an embodiment of the invention having queue heads coupled directly to a frame list during initialization. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10</cross-reference> illustrates a block diagram of an embodiment of the invention having queue heads coupled directly to a frame list after initialization.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF THE INVENTION </heading>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> The invention generally relates to an apparatus and method to improve bandwidth usage of Universal Serial Bus (USB) devices. Referring to the figures, exemplary embodiments of the invention will now be described. The exemplary embodiments are provided to illustrate the invention and should not be construed as limiting the scope of the invention. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> A typical USB host system is composed of a number of hardware and software layers. <cross-reference target="DRAWINGS">FIG. 1</cross-reference> illustrates a block diagram of typical building block layers in a USB 2.0 system. System <highlight><bold>100</bold></highlight> is comprised of client driver software <highlight><bold>110</bold></highlight>, universal bus driver (USBD) <highlight><bold>120</bold></highlight>, companion host controller (HC) driver <highlight><bold>130</bold></highlight>, companion HC <highlight><bold>140</bold></highlight>, enhanced host controller driver (EHCD) <highlight><bold>150</bold></highlight>, universal host controller (UHC) <highlight><bold>160</bold></highlight> and USB device <highlight><bold>170</bold></highlight>. In system <highlight><bold>100</bold></highlight>, system software consists of client driver software <highlight><bold>110</bold></highlight>, USBD <highlight><bold>120</bold></highlight>, companion HC driver <highlight><bold>130</bold></highlight>, and EHCD <highlight><bold>150</bold></highlight>. In system <highlight><bold>100</bold></highlight> the hardware comprises companion HC <highlight><bold>140</bold></highlight>, UHC <highlight><bold>160</bold></highlight>, and USB device <highlight><bold>170</bold></highlight>. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> Client driver software <highlight><bold>110</bold></highlight> typically executes on the host PC corresponding to a particular USB device. Client driver software <highlight><bold>110</bold></highlight> is typically part of the operating system (OS) or may be provided with a USB device. USBD <highlight><bold>120</bold></highlight> is a system bus driver that abstracts the details of the particular HC driver for a particular OS. Companion HC driver <highlight><bold>130</bold></highlight> is typically a UHC interface (UHCI) driver or an open HCI (OHCI) driver for USB. The HC driver provides a software layer between specific HC hardware and the USBD. Companion HC <highlight><bold>140</bold></highlight>, is typically UHCI or OHCI standards. Companion HC <highlight><bold>140</bold></highlight> is the specific hardware implementation of the HC. There is one HC specification for USB 2.0 functionality, and two specifications for full-and low-speed HCs. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> illustrates typical USB 2.0 HC <highlight><bold>200</bold></highlight>. A USB 2.0 HC includes one high-speed mode HC and zero (0) or more USB 1.1 HCs. USB 2.0 HC <highlight><bold>200</bold></highlight> comprises companion USB HC and high-speed mode (enhanced interface) HC <highlight><bold>160</bold></highlight>. Companion HC <highlight><bold>140</bold></highlight> comprises HC control logic/data buffering <highlight><bold>210</bold></highlight> (including port <highlight><bold>1</bold></highlight> through port N). High-speed mode HC <highlight><bold>160</bold></highlight> comprises enhanced HC control logic/enhanced data buffering <highlight><bold>220</bold></highlight> (including port <highlight><bold>1</bold></highlight> through port N). Also included in USB 2.0 HC <highlight><bold>200</bold></highlight> is port routing logic <highlight><bold>230</bold></highlight> (including port <highlight><bold>1</bold></highlight> through port N). </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> illustrates the general architecture of enhanced host controller interface (EHCI) <highlight><bold>300</bold></highlight>. EHCI <highlight><bold>300</bold></highlight> comprises three interface spaces: peripheral component interconnect (PCI) configuration <highlight><bold>310</bold></highlight>, register <highlight><bold>320</bold></highlight>, and schedule interface <highlight><bold>330</bold></highlight>. PCI configuration <highlight><bold>310</bold></highlight> includes PCI registers used for system component enumeration and PCI power management. PCI configuration registers in PCI configuration <highlight><bold>310</bold></highlight> comprise PCI class code <highlight><bold>311</bold></highlight>, USB base address <highlight><bold>312</bold></highlight>, and PCI power management interface <highlight><bold>313</bold></highlight>. Register <highlight><bold>320</bold></highlight> comprises memory based input/output (I/O) registers. Memory based I/O registers are comprised of capability registers <highlight><bold>321</bold></highlight> and operational registers <highlight><bold>322</bold></highlight>. Register <highlight><bold>320</bold></highlight> must be implemented as memory-mapped I/O. Schedule interface <highlight><bold>330</bold></highlight> is typically memory allocated and managed by the HC driver for the periodic and asynchronous schedules. EHCI <highlight><bold>300</bold></highlight> allows software to enable or disable each schedule. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> illustrates a typical structure layout of a queue head. Queue head horizontal link pointer (QHLP) <highlight><bold>410</bold></highlight> comprises four fields. QHLP field <highlight><bold>411</bold></highlight> contains the address of the next data object to be processed in the horizontal list and corresponds to memory address signals &lsqb;<highlight><bold>31</bold></highlight>:<highlight><bold>5</bold></highlight>&rsqb;, respectively. Field <highlight><bold>412</bold></highlight> is reserved, and bits <highlight><bold>4</bold></highlight>:<highlight><bold>3</bold></highlight> must be written as Os. Field <highlight><bold>413</bold></highlight> comprising bits <highlight><bold>2</bold></highlight>:<highlight><bold>1</bold></highlight>, indicates to the hardware whether the item referenced by the link pointer is a isochronous transaction descriptor (iTD), split transaction isochronous transaction descriptor (siTD) or a queue head. Field <highlight><bold>413</bold></highlight> allows the HC to perform the proper type of processing on the item after it is fetched. Field <highlight><bold>14</bold></highlight>, bit <highlight><bold>0</bold></highlight>, is the terminate field. If the queue head is in the context of the periodic list, a set (1) bit in field <highlight><bold>414</bold></highlight> indicates to the HC that this is the end of the periodic list. This bit, however, is ignored by the HC when the queue head is in the asynchronous schedule. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> Field <highlight><bold>420</bold></highlight> illustrates queue head DWord<highlight><bold>1</bold></highlight>, and field <highlight><bold>430</bold></highlight> illustrates end point characteristics comprising queue head DWord<highlight><bold>2</bold></highlight>. Field <highlight><bold>421</bold></highlight> is the not acknowledged or negative acknowledged (Nak) count re-load field. Field <highlight><bold>421</bold></highlight> contains a value, which is used by the HC to reload Nak counter field. Field <highlight><bold>433</bold></highlight> illustrates a control end-point flag. Field <highlight><bold>423</bold></highlight> represents the maximum packet length. The maximum packet length directly corresponds to the maximum packet size of the associated endpoint. The maximum value of field <highlight><bold>423</bold></highlight> is 0&times;400 (1024). </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> Field <highlight><bold>424</bold></highlight> illustrates head of reclamation list flag. Field <highlight><bold>424</bold></highlight> is set by system software to mark a queue head as being the head of the reclamation list. Field <highlight><bold>425</bold></highlight> illustrates data toggle control. Field <highlight><bold>425</bold></highlight> specifies where the HC should get the initial data toggle on an overlay transition. Field <highlight><bold>426</bold></highlight> illustrates endpoint speed. Field <highlight><bold>426</bold></highlight> is the speed of the associated endpoint. Field <highlight><bold>427</bold></highlight> illustrates the endpoint number. Field <highlight><bold>427</bold></highlight> selects the particular endpoint number on the device serving as the data source or sink. Field <highlight><bold>428</bold></highlight> is a reserved bit. Field <highlight><bold>429</bold></highlight> illustrates the device address. Field <highlight><bold>429</bold></highlight> selects the specific device serving as the data source or sink. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> Field <highlight><bold>431</bold></highlight> illustrates the high-bandwidth pipe multiplier. Field <highlight><bold>431</bold></highlight> is a multiplier used to key the HC as the number of successive packets the HC may submit to the endpoint in the current execution. The HC makes the simplified assumption that software properly initializes this field. Field <highlight><bold>432</bold></highlight> illustrates the port number. Field <highlight><bold>432</bold></highlight> is ignored by the HC unless field <highlight><bold>426</bold></highlight> indicates a full-speed or low-speed device. The value is the port number identifier on the USB 2.0 hub, below which the full- or low-speed device associated with this endpoint is attached. This information is used in the split-transaction protocol. Field <highlight><bold>433</bold></highlight> illustrates the hub address. Field <highlight><bold>433</bold></highlight> is ignored by the HC unless field <highlight><bold>426</bold></highlight> indicates a full- or low-speed device. The value is the USB device address of the USB 2.0 hub below which the full- or low-speed device associated with this endpoint is attached. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> Field <highlight><bold>434</bold></highlight> illustrates the split-completion mask. Field <highlight><bold>434</bold></highlight> is ignored by the HC unless field <highlight><bold>426</bold></highlight> indicates the device is a low- or full-speed device and this queue head is in the periodic list. Field <highlight><bold>434</bold></highlight> is used to determine during which micro-frames the HC should execute a complete-split transaction. When the criteria for using this field are met, a zero value in this field has undefined behavior. Field <highlight><bold>435</bold></highlight> illustrates the interrupt schedule mask. Field <highlight><bold>435</bold></highlight> is used for all endpoint speeds. When the queue head is on the asynchronous schedule, software should set this field to a zero. A non-zero value in this field indicates an interrupt endpoint. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> Field <highlight><bold>440</bold></highlight> illustrates the current queue transaction descriptor link pointer. Field <highlight><bold>440</bold></highlight> contains the address of the current transaction being processed in this queue and corresponds to memory address signals &lsqb;<highlight><bold>31</bold></highlight>:<highlight><bold>5</bold></highlight>&rsqb;, respectively. Field <highlight><bold>441</bold></highlight> is reserved for future use. Field <highlight><bold>442</bold></highlight> illustrates the next qTD pointer. Field <highlight><bold>443</bold></highlight> illustrates the alternate next qTD pointer. Fields <highlight><bold>450</bold></highlight> through <highlight><bold>454</bold></highlight> illustrate buffer pointer pages 0-4, respectively. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> illustrates an example of a periodic schedule. The periodic schedule is used to manage all isochronous and interrupt transfer streams. The base of the periodic schedule is periodic frame list <highlight><bold>510</bold></highlight>. Software links schedule data structures to periodic frame list <highlight><bold>510</bold></highlight> to produce a graph of scheduled data structures. The graph represents the appropriate sequence of transactions on the USB. Periodic schedule <highlight><bold>500</bold></highlight> also illustrates isochronous transfers, (using iTDs and siTDs) with a period of one, linked directly to periodic frame list <highlight><bold>510</bold></highlight>. Interrupt transfers (are managed with queue heads) and isochronous streams, with periods other than one, are linked following the period-one iTD/siTDs. Interrupt queue heads <highlight><bold>530</bold></highlight> are linked into periodic frame list <highlight><bold>510</bold></highlight> ordered by poll rate. Longer poll rates are linked first (e.g. closest to periodic frame list <highlight><bold>510</bold></highlight>), followed by shorter poll rates, with queue heads with a poll rate of one (1), on the very end. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference>A-B illustrates the structure of an iTD. The structure illustrated in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>A-B is used only for high-speed isochronous endpoints. All other transfer types should use queue structures. Link pointer <highlight><bold>605</bold></highlight> is a pointer to the next schedule data structure (iTD, siTD, or queue head. Field <highlight><bold>606</bold></highlight> is reserved. Field <highlight><bold>606</bold></highlight> indicates to the HC whether the item referenced is a iTD, siTD, or a queue head. By informing the HC of the type of data structure, the HC can perform the proper type of processing on the item after it is fetched. Field <highlight><bold>611</bold></highlight> records the status of the transaction executed by the HC for the particular slot. Field <highlight><bold>612</bold></highlight> is the transaction length (i.e. number of data bytes) the HC will send during the transaction. Field <highlight><bold>613</bold></highlight> is the interrupt on complete (IOC) bit. If the IOC bit is set to a one (&ldquo;1&rdquo;), it specifies that when the transaction completes, the HC should issue an interrupt at the next interrupt threshold. Field <highlight><bold>614</bold></highlight> is the page select. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> The page select field <highlight><bold>614</bold></highlight> are set by software to indicate which of the buffer page pointers the offset field <highlight><bold>615</bold></highlight> in the particular slot should be concatenated to produce the beginning memory address for the particular transaction. Offset field <highlight><bold>615</bold></highlight> is a value that is an offset, expressed in bytes, from the beginning of a buffer. Offset field <highlight><bold>615</bold></highlight> is concatenated onto the buffer page pointer indicated in the page select field <highlight><bold>614</bold></highlight> to produce the beginning buffer address for the particular transaction. Buffer page pointer list <highlight><bold>620</bold></highlight> provides <highlight><bold>7</bold></highlight> page pointers to support the expression of eight (&ldquo;8&rdquo;) isochronous transfers. The seven pointers allow for three (&ldquo;3&rdquo;) transactions * 1024 (maximum packet size)* eight (&ldquo;8&rdquo;) transaction records (24,576 bytes) to be moved with this data structure, regardless of the alignment offset of the first page. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> illustrates a siTD. All full-speed isochronous transfers through transaction translators (TTs) are managed using the siTD data structure. Field <highlight><bold>710</bold></highlight> is the next link pointer. Field <highlight><bold>710</bold></highlight> contains the address of the next data object to be processed in the periodic list and corresponds to memory address signals &lsqb;<highlight><bold>31</bold></highlight>:<highlight><bold>5</bold></highlight>&rsqb;, respectively. Field <highlight><bold>715</bold></highlight> is the QH/(s)iTD select. Field <highlight><bold>715</bold></highlight> indicates to the HC whether the item referenced is a iTD/siTD or QH. Field <highlight><bold>716</bold></highlight> is the terminate field. Field <highlight><bold>717</bold></highlight> is reserved. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> Field <highlight><bold>720</bold></highlight> is the direction, that is input or output. Field <highlight><bold>720</bold></highlight> encodes whether the full-speed transaction is IN or OUT. Field <highlight><bold>721</bold></highlight> is the port number of the recipient TT. Field <highlight><bold>722</bold></highlight> is reserved. Field <highlight><bold>723</bold></highlight> is the device address of the TT&apos;s hub. Field <highlight><bold>724</bold></highlight> is reserved. Field <highlight><bold>725</bold></highlight> is a four-bit field that selects the particular endpoint number on the device serving as the data source or sink. Field <highlight><bold>726</bold></highlight> is reserved. Field <highlight><bold>727</bold></highlight> selects the specific device serving as the data source or sink. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> Field <highlight><bold>730</bold></highlight> is reserved. Field <highlight><bold>731</bold></highlight>, the split completion mask, and field <highlight><bold>732</bold></highlight>, the split start mask, are used to determine during which micro-frames the HC should execute complete-split transactions. Field <highlight><bold>740</bold></highlight> is the interrupt on complete field. When field <highlight><bold>740</bold></highlight> is set to a one (1), the HC will assert a hardware interrupt at the next interrupt threshold when the HC determines that the split transaction has completed. When field <highlight><bold>740</bold></highlight> is set to a zero (0), the HC will not assert an interrupt when the HC determines that the split transaction has completed. Field <highlight><bold>741</bold></highlight> is sued to indicate which data page pointer should be concatenated with field <highlight><bold>751</bold></highlight> (discussed below) to construct a data buffer pointer. Field <highlight><bold>742</bold></highlight> is reserved. Field <highlight><bold>743</bold></highlight> is initialized to the total number of bytes expected in the transfer (maximum value is 1023). Field <highlight><bold>743</bold></highlight> is used by the HC to record which split-completes have been executed. Field <highlight><bold>744</bold></highlight> records the status of the transaction executed by the HC for this slot. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> Field <highlight><bold>750</bold></highlight> is the buffer pointer list for page 0. Field <highlight><bold>751</bold></highlight> is the current offset field. In field <highlight><bold>751</bold></highlight>, the twelve least significant bits of the Page 0 pointer is the current byte offset for the current page pointer. Field <highlight><bold>760</bold></highlight> is the buffer pointer list for Page 1. Field <highlight><bold>761</bold></highlight> is reserved. Field <highlight><bold>762</bold></highlight> is the transaction position. Field <highlight><bold>762</bold></highlight> is used with field <highlight><bold>763</bold></highlight> to determine whether to send all, first, middle, or last with each outbound transaction payload. Field <highlight><bold>763</bold></highlight> is initialized by software with the number of OUT start-splits the transfer requires. Field <highlight><bold>770</bold></highlight> is the siTD back pointer. Field <highlight><bold>770</bold></highlight> is a physical memory pointer to an siTD. Field <highlight><bold>771</bold></highlight> is reserved. Field <highlight><bold>772</bold></highlight> is a terminate field. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> illustrates a resulting frame list of an embodiment of the invention that couples interrupt queue heads directly to the HC frame list, but before any siTDs in a USB 2.0 system. Note that embodiments of the invention can be used with future USB systems where queue heads are typically not directly coupled to the frame list before siTDs. One should note that the <cross-reference target="DRAWINGS">FIG. 8</cross-reference> is an example with only eight (&ldquo;8&rdquo;) elements in the frame list, but the invention is not limited to eight (&ldquo;8&rdquo;) elements. In this embodiment of the invention, interrupt queue heads <highlight><bold>810</bold></highlight> are not part of the standard interrupt tree. An example of a standard interrupt tree can be seen in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 5</cross-reference>, it can be seen that iTDs <highlight><bold>520</bold></highlight> are directly coupled to periodic frame list <highlight><bold>510</bold></highlight>. In <cross-reference target="DRAWINGS">FIG. 5</cross-reference>, interrupt queue heads <highlight><bold>530</bold></highlight> are part of the interrupt tree. In this embodiment of the invention, by coupling interrupt queue heads <highlight><bold>810</bold></highlight> directly to frame list <highlight><bold>820</bold></highlight>, where the coupled interrupt queue heads are coupled before split iTDs <highlight><bold>830</bold></highlight>, interrupt queue heads <highlight><bold>810</bold></highlight> are not subject to period promotion. In this embodiment of the invention, the HC Driver maximizes the number of devices using periodic (isochronous and interrupt) endpoints that can be connected to a TT. By preventing period promotion, this embodiment of the invention uses less of the available bandwidth on a USB 2.0 system. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference> illustrates a block diagram of an embodiment of the invention having process <highlight><bold>900</bold></highlight> that couples queue heads directly to a frame list during initialization. Block <highlight><bold>910</bold></highlight> determines whether a queue head max packet size is less than or equal to a predetermined size (such as one (&ldquo;1&rdquo;) byte) and that the period is greater or equal to a predetermined schedule window (dependent on number of data structures, such as iTD and siTD). In one embodiment of the invention, block <highlight><bold>910</bold></highlight> also determines whether the queue head is full speed or not. Note that the queue heads can be of any sufficiently small maximum packet size that allows sufficient bandwidth to remain for a maximum sized (1023 bytes per frame) full speed isochronous transfer. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> If block <highlight><bold>910</bold></highlight> determines that a queue head max packet size is not equal to or less than a predetermined size and/or that the period is not greater or equal to a predetermined schedule window, then process <highlight><bold>900</bold></highlight> continues with block <highlight><bold>950</bold></highlight>. Block <highlight><bold>950</bold></highlight> places the queue head in the interrupt tree. Process <highlight><bold>900</bold></highlight> then continues to block <highlight><bold>940</bold></highlight>. Process <highlight><bold>900</bold></highlight> continues with block <highlight><bold>940</bold></highlight> that determines whether initialization is complete or not (i.e., all queue heads are processed). If block <highlight><bold>940</bold></highlight> determines that all queue heads are not processed, then process <highlight><bold>900</bold></highlight> continues with block <highlight><bold>910</bold></highlight>. If block <highlight><bold>940</bold></highlight> determines that all queue heads are processed, process <highlight><bold>900</bold></highlight> completes. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> If block <highlight><bold>910</bold></highlight> determines that a queue head max packet size is less than or equal to a predetermined size and that the period is greater or equal to a predetermined schedule window, then process <highlight><bold>900</bold></highlight> continues with block <highlight><bold>920</bold></highlight>. Block <highlight><bold>920</bold></highlight> initializes the next pointer in the queue head to contain the contents of the current entry in the frame list. Process <highlight><bold>900</bold></highlight> continues with block <highlight><bold>930</bold></highlight> that replaces the current entry in the frame list with a pointer to a new queue head. Process <highlight><bold>900</bold></highlight> then continues with block <highlight><bold>940</bold></highlight>. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10</cross-reference> illustrates a block diagram of an embodiment of the invention having process <highlight><bold>1000</bold></highlight> that couples queue heads directly to a frame list after initialization of the interrupt tree. Block <highlight><bold>1010</bold></highlight> determines whether a queue head maximum packet size is less than or equal to a predetermined size (such as one (&ldquo;1&rdquo;) byte) and that the period is greater or equal to a predetermined schedule window (dependent on number of data structures, such as iTD and siTD). In one embodiment of the invention, block <highlight><bold>1010</bold></highlight> also determines whether the queue head is full speed or not. Note that the queue heads can be of any sufficiently small maximum packet size that allows sufficient bandwidth to remain for a maximum sized (1023 bytes per frame) full speed isochronous transfer. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> If block <highlight><bold>1010</bold></highlight> determines that a queue head max packet size is not less than or equal to a predetermined size and/or that the period is not greater or equal to a predetermined schedule window, then process <highlight><bold>1000</bold></highlight> continues with block <highlight><bold>1050</bold></highlight>. Block <highlight><bold>1050</bold></highlight> determines whether more queue heads exist in the interrupt tree. If block <highlight><bold>1050</bold></highlight> determines that more queue heads exist in the interrupt tree, process <highlight><bold>1000</bold></highlight> continues with block <highlight><bold>1010</bold></highlight>. If block <highlight><bold>1050</bold></highlight> determines that there are not any more queue heads in the interrupt tree, process <highlight><bold>1000</bold></highlight> is complete. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> If block <highlight><bold>1010</bold></highlight> determines that a queue head max packet size is less than or equal to a predetermined size and that the period is greater or equal to a predetermined schedule window, then process <highlight><bold>1000</bold></highlight> continues with block <highlight><bold>1020</bold></highlight>. Block <highlight><bold>1020</bold></highlight> initializes the next pointer in the queue head to contain the contents of the current entry (queue head, iTD, siTD) in the frame list. Process <highlight><bold>1000</bold></highlight> continues with block <highlight><bold>1030</bold></highlight> that replaces the next pointer of the queue head to point to the current entry in the frame list. Process <highlight><bold>1000</bold></highlight> then continues with block <highlight><bold>1040</bold></highlight>. Block <highlight><bold>1040</bold></highlight> replaces the current entry in the frame list with a pointer to a new queue head. Process <highlight><bold>1000</bold></highlight> then continues with block <highlight><bold>1050</bold></highlight>. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> The above embodiments can also be stored on a device or machine-readable medium and be read by a machine to perform instructions. The machine-readable medium includes any mechanism that provides (i.e., stores and/or transmits) information in a form readable by a machine (e.g., a computer). For example, a machine-readable medium includes read only memory (ROM); random access memory (RAM); magnetic disk storage media; optical storage media; flash memory devices; electrical, optical, acoustical or other form of propagated signals (e.g., carrier waves, infrared signals, digital signals, etc.). The device or machine-readable medium may include a solid state memory device and/or a rotating magnetic or optical disk. The device or machine-readable medium may be distributed when partitions of instructions have been separated into different machines, such as across an interconnection of computers. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> While certain exemplary embodiments have been described and shown in the accompanying drawings, it is to be understood that such embodiments are merely illustrative of and not restrictive on the broad invention, and that this invention not be limited to the specific constructions and arrangements shown and described, since various other modifications may occur to those ordinarily skilled in the art. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. An apparatus comprising: 
<claim-text>a host controller capable of coupling a plurality of queue heads to a frame list, </claim-text>
<claim-text>wherein the plurality of queue heads are coupled to the frame list before any transaction descriptors. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further including a host controller driver. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the plurality of queue heads are coupled to the frame list before any transaction descriptors during initialization of the host controller. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the plurality of queue heads are coupled to the frame list before any transaction descriptors after initialization of the host controller. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the transaction descriptors are split-isochronous transaction descriptors. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. A method comprising: 
<claim-text>determining whether a queue head has one of less than a predetermined packet size and equal to the predetermined packet size and whether a period is one of greater than and equal to a predetermined schedule window; </claim-text>
<claim-text>storing contents of a current entry in a frame list in a next pointer in the queue head; and </claim-text>
<claim-text>replacing the current entry in the frame list with a pointer to a new queue head, </claim-text>
<claim-text>wherein a plurality of queue heads are directly coupled to the frame list. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference>, wherein the predetermined packet size is one byte. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference>, wherein the predetermined schedule window is determined during initialization of a host controller. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference>, wherein the host controller is coupled to a host controller driver. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference>, wherein the plurality of queue heads are directly coupled to the frame list before any split-isochronous transaction descriptors. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference>, wherein the plurality of queue heads are directly coupled to the frame list during initialization of a host controller. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. An apparatus comprising a machine-readable medium containing instructions which, when executed by a machine, cause the machine to perform operations comprising: 
<claim-text>determining whether a queue head has one of less than a predetermined packet size and equal to the predetermined packet size and whether a period is one of greater than and equal to a predetermined schedule window; </claim-text>
<claim-text>storing contents of a current entry in a frame list in a next pointer in the queue head; and </claim-text>
<claim-text>replacing the current entry in the frame list with a pointer to a new queue head, </claim-text>
<claim-text>wherein a plurality of queue heads are directly coupled to the frame list. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, wherein the predetermined packet size is one byte. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, wherein the predetermined schedule window is determined during initialization of a host controller. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, wherein the host controller is coupled to a host controller driver. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, wherein the plurality of queue heads are directly coupled to the frame list before any split-isochronous transaction descriptors. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, wherein the plurality of queue heads are directly coupled to the frame list during initialization of a host controller. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. A method comprising: 
<claim-text>determining whether a queue head has one of less than a predetermined packet size and equal to the predetermined packet size and whether a period is one of greater than and equal to a predetermined schedule window; </claim-text>
<claim-text>storing contents of a current entry in a frame list in a next pointer in the queue head; and </claim-text>
<claim-text>replacing the current entry in the frame list with a pointer to a new queue head, </claim-text>
<claim-text>wherein a plurality of queue heads are directly coupled to the frame list. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 18</dependent-claim-reference>, wherein the predetermined packet size is one byte. </claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 18</dependent-claim-reference>, wherein the predetermined schedule window is determined during initialization of a host controller. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 18</dependent-claim-reference>, wherein the host controller is coupled to a host controller driver. </claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 18</dependent-claim-reference>, wherein the plurality of queue heads are directly coupled to the frame list before any split-isochronous transaction descriptors. </claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 18</dependent-claim-reference>, wherein the plurality of queue heads are directly coupled to the frame list after initialization of a host controller. </claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. An apparatus comprising a machine-readable medium containing instructions which, when executed by a machine, cause the machine to perform operations comprising: 
<claim-text>determining whether a queue head has one of less than a predetermined packet size and equal to the predetermined packet size and whether a period is one of greater than and equal to a predetermined schedule window; </claim-text>
<claim-text>storing contents of a current entry in a frame list in a next pointer in the queue head; and </claim-text>
<claim-text>replacing the current entry in the frame list with a pointer to a new queue head, </claim-text>
<claim-text>wherein a plurality of queue heads are directly coupled to the frame list. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 24</dependent-claim-reference>, wherein the predetermined packet size is one byte. </claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 24</dependent-claim-reference>, wherein the predetermined schedule window is determined during initialization of a host controller. </claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 24</dependent-claim-reference>, wherein the host controller is coupled to a host controller driver. </claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 24</dependent-claim-reference>, wherein the plurality of queue heads are directly coupled to the frame list before any split-isochronous transaction descriptors. </claim-text>
</claim>
<claim id="CLM-00029">
<claim-text><highlight><bold>29</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 28</dependent-claim-reference>, wherein the plurality of queue heads are directly coupled to the frame list after initialization of a host controller.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>1</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005182A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005182A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005182A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005182A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005182A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005182A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030005182A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030005182A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030005182A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00009">
<image id="EMI-D00009" file="US20030005182A1-20030102-D00009.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00010">
<image id="EMI-D00010" file="US20030005182A1-20030102-D00010.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00011">
<image id="EMI-D00011" file="US20030005182A1-20030102-D00011.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
