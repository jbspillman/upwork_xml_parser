<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030001847A1-20030102-D00000.TIF SYSTEM "US20030001847A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030001847A1-20030102-D00001.TIF SYSTEM "US20030001847A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030001847A1-20030102-D00002.TIF SYSTEM "US20030001847A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030001847A1-20030102-D00003.TIF SYSTEM "US20030001847A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030001847A1-20030102-D00004.TIF SYSTEM "US20030001847A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030001847A1-20030102-D00005.TIF SYSTEM "US20030001847A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030001847A1-20030102-D00006.TIF SYSTEM "US20030001847A1-20030102-D00006.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030001847</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09895529</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010629</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06T001/00</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>345</class>
<subclass>501000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Apparatus, method and system with a graphics-rendering engine having a time allocator</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Peter</given-name>
<middle-name>L.</middle-name>
<family-name>Doyle</family-name>
</name>
<residence>
<residence-us>
<city>EI Dorado Hills</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Aditya</given-name>
<family-name>Sreenivas</family-name>
</name>
<residence>
<residence-us>
<city>EI Dorado Hills</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>Thomas S. Ferrill</name-1>
<name-2>BLAKELY, SOKOLOFF, TAYLOR &amp; ZAFMAN LLP</name-2>
<address>
<address-1>Seventh Floor</address-1>
<address-2>12400 Wilshire Boulevard</address-2>
<city>Los Angeles</city>
<state>CA</state>
<postalcode>90025-1026</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A method, apparatus, and system to concurrently render independent images for display on one or more display devices. In an embodiment, a graphics-rendering engine concurrently renders independent images for display on multiple display devices. A time allocator arbitrates the concurrent use of the graphics-rendering engine between each independent image being rendered. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">FIELD OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> This invention generally relates to rendering multiple images. More particularly this invention relates to rendering multiple images on one or more display devices. </paragraph>
</section>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> Image rendering is the conversion of a high-level object-based description into a graphical image for display on some display device. For example, an act of image rendering occurs during the conversion of a mathematical model of a three-dimensional object or scene into a bitmap image. Another example of image rendering is converting an HTML document into an image for display on a computer monitor. Typically, a hardware device referred to as a graphics-rendering engine accelerates these graphics processing tasks. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> Multiple images may be commonly viewed on a computer monitor when surfing the Internet. For example, a web page and two banner ads super imposed over the web page may be displayed on a computer monitor when surfing the Internet. The graphics-rendering engine typically renders all of the instructions associated with the first image, such as the web page. After completing processing the instructions for the first image, the graphics-rendering engine starts processing the instructions associated with the second image, such as one of the banner ads. However, in general, the graphics-rendering engine must finish rendering the instructions associated with the first image before starting to process the instructions associated with the second image. Thus, if the graphics-rendering engine processes instructions faster than the graphics application program generates instructions, then the graphics-rendering engine remains idle during that period of time. Also, if the image instructions call for a real world event to occur prior to executing the next instruction, then the graphics-rendering engine remains idle during that period of time. Typically, a graphics-rendering engine services instruction streams sequentially. Thus, the instructions associated with the first instruction stream were processed before the graphics-rendering engine started processing instructions associated with a second instruction stream. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> Another example could be the rendering of two independent images in a three dimension environment. A single display screen displays a first window that contains the 3D image and a second window that contains the displayed image of a controlling 2D graphic user interface. As noted, in previous technologies, the instructions for the image in the first window were processed before the graphics-rendering engine started processing instructions the image in the second window. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> Previous technologies have displayed multiple images on multiple devices. Typically, two or more graphics-rendering engines exist to process the instructions associated with the multiple images. Each graphics-rendering engine services a single display device. However, in practice, multiple graphics-rendering engines occupy more physical space, consume more power, and cost more to produce than a single graphics-rendering engine. Thus, reducing the number of graphics-rendering engines is beneficial. Moreover, previous technologies attempting to render different images on the same display screen with two or more graphics-rendering engines encountered grave arbitration conflicts. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> Each graphics-rendering engine is controlled via a set of rendering state variables. These state variables are known collectively as the rendering context. The rendering state variables control specific aspects of the graphics rendering process, such as object color, texture, texture application modes, etc. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> A specific rendering context exists with each image as that image is being rendered. Previous technologies use an inefficient method to set the rendering context associated with an image. The graphics driver program receives instructions from the application programs and sends the instruction streams containing the instructions, including the state variable settings currently associated with the image, to the graphics-rendering engine. The graphics-rendering engine processes these rendering context instructions prior to executing the other rendering instructions. When a graphics-rendering engine switches between processing instructions associated with a first image and instructions associated with a second image, then the graphics application programs needs to send the rendering context instructions and the graphics-rendering engine needs to process those rendering context instructions. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> Previously, the rendering context associated with a graphics-rendering engine was modified only via the software-generated instruction stream, and was not directly accessible from the host CPU. Changing from a first rendering context, such as the current rendering context, to a second rendering context, such as a new rendering context, therefore required the application software to generate instructions to specify the state variable settings for the second rendering context. Given that the first rendering context could not be read, application software was required to maintain a shadow copy of the first rendering context in order to restore that first rendering context at some later point. </paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> The drawings refer to the invention in which: </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> illustrates a block diagram of an embodiment of a graphics device that renders one or more images using a single graphics-rendering engine to display the one or more images on multiple display devices; </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> illustrates a block diagram of an embodiment of a computer system containing a central processing unit (CPU), a cache, a memory, display devices, and a graphics device having an embodiment of an instruction transport and an embodiment of a graphics context manager; </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> illustrates a block diagram of an embodiment of a ring buffer memory area; </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> illustrates a block diagram of an embodiment of a time allocator to allocate the use of the graphics-rendering engine between each independent image being rendered; </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> and <cross-reference target="DRAWINGS">FIG. 6</cross-reference> illustrate a flow diagram of an embodiment of a process for rendering multiple images on multiple display devices using a single graphic-rendering engine. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> While the invention is subject to various modifications and alternative forms, specific embodiments thereof have been shown by way of example in the drawings and will herein be described in detail. The invention should be understood to not be limited to the particular forms disclosed, but on the contrary, the intention is to cover all modifications, equivalents, and alternatives falling within the spirit and scope of the invention. </paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DISCUSSION </heading>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> In the following description, numerous specific details are set forth, such as examples of specific instructions, named components, connections, etc. in order to provide a thorough understanding of the present invention. It will be apparent, however, to one skilled in the art that the present invention may be practiced without these specific details. In other instances, well known components or methods have not been described in detail but rather in a block diagram in order to avoid unnecessarily obscuring the present invention. Thus, the specific details set forth are merely exemplary. The specific details may be varied from and still be contemplated to be within the spirit and scope of the present invention. The term coupled is defined as meaning connected either directly or indirectly. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> In general, a graphics-rendering engine concurrently renders independent images for display on multiple display devices. An instruction transport delivers instructions for the two or more independent images to the graphics-rendering engine. A time allocator arbitrates the concurrent use of the graphics-rendering engine between each independent image being rendered. A graphics context manager restores a rendering context associated with a first independent image from an established memory location to the graphics-rendering engine. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> illustrates a block diagram of an embodiment of a graphics device that renders one or more images using a graphics-rendering engine to display the one or more images on multiple display devices. Referring to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, the graphics device <highlight><bold>100</bold></highlight> contains a graphics-rendering engine <highlight><bold>102</bold></highlight>, one or more instruction transports <highlight><bold>104</bold></highlight>, a context manager <highlight><bold>106</bold></highlight>, a time allocator <highlight><bold>108</bold></highlight>, and one or more display devices, such as the first display device <highlight><bold>110</bold></highlight> and the second display device <highlight><bold>112</bold></highlight>. In an embodiment, the graphics device <highlight><bold>100</bold></highlight> contains a single graphics-rendering engine <highlight><bold>102</bold></highlight>. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> The graphics-rendering engine <highlight><bold>102</bold></highlight> generates independent images to be displayed on either a single display device or multiple display devices. Thus, for example, two independent images may be displayed on the same display device or the two independent images may each be displayed on separate display devices. The instructions for each independent image come from a separate instruction stream <highlight><bold>114</bold></highlight> or from a single instruction stream <highlight><bold>114</bold></highlight> containing instructions from multiple graphic application programs. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> Each independent image may be concurrently rendered as compared to prior art technology displaying a web page with banner ads through a browser application or sequentially rendering a first instruction stream associated with a two dimensional image and then rendering a second instruction stream associated with a three dimension image. Generally, the prior art technology completely renders the image instructions associated with the first image contained in the first window, such as the banner ad, and then completely renders the instructions for the second image contained in the second window, such as the web page. Typically, the prior technology, the graphics-rendering engine does not concurrently operate on the instructions for each independent image. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> The time allocator <highlight><bold>108</bold></highlight> arbitrates the use of the graphics-rendering engine <highlight><bold>102</bold></highlight> between each independent image being rendered. A graphics context manager <highlight><bold>106</bold></highlight> stores the context associated with each independent image being rendered in a memory device (not shown). Various graphic&apos;s applications running on the processor or running on a browser running on the processor insert image rendering instructions into the instruction stream <highlight><bold>114</bold></highlight>. An instruction transport <highlight><bold>104</bold></highlight> delivers the instructions from an instruction stream <highlight><bold>114</bold></highlight> to the graphic-rendering engine <highlight><bold>102</bold></highlight> or processing. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> The graphics-rendering engine <highlight><bold>102</bold></highlight> works with the graphics context manager <highlight><bold>106</bold></highlight>, time allocator <highlight><bold>108</bold></highlight>, and one or more instruction transports <highlight><bold>104</bold></highlight> to make efficient use of the graphics-rendering engine <highlight><bold>102</bold></highlight>. Each graphics application supplying instructions to the instruction stream <highlight><bold>114</bold></highlight> may be generating image s and operating at different rates of speed. For example, a streaming live video application usually operates at much faster image generation rate than a word processing application. The graphics-rendering engine <highlight><bold>102</bold></highlight> may concurrently render instructions associated with two or more images to minimize the time the graphics-rendering engine <highlight><bold>102</bold></highlight> remains, idle. Also, in previous technologies if the instruction for a first image called for a real word event to occur prior to executing the next instruction, then the graphics-rendering engine <highlight><bold>102</bold></highlight> remained idle during that period of time. However, the graphics-rendering engine <highlight><bold>102</bold></highlight> may concurrently render instructions from multiple images in order to reduce the idle time for the graphics-rendering engine <highlight><bold>102</bold></highlight>. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> The graphics-rendering engine <highlight><bold>102</bold></highlight> may save the current rendering context associated with a first image and load a new rendering context associated with a second image from established memory location (not shown). In an embodiment, the established memory location used to store a rendering context may be referred to as a logical context (not shown). The graphics-rendering device <highlight><bold>100</bold></highlight>, when required to switch rendering contexts, may (1) write the current rendering context from the rendering state variables into a first established memory location in memory, (2) read the new rendering context from a second established memory location in memory, and (3) load the rendering state variables with the information from the new rendering context. In an embodiment, an established memory location in the context manger <highlight><bold>106</bold></highlight> is associated with each graphics application that is generating an independent image. In an embodiment, a separate instruction transport <highlight><bold>104</bold></highlight> is associated with each display device <highlight><bold>110</bold></highlight>, <highlight><bold>112</bold></highlight> to store the independent set of image rendering instructions to be processed for that particular display device <highlight><bold>110</bold></highlight>, <highlight><bold>112</bold></highlight>. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> illustrates a block diagram of an embodiment of a computer system containing a central processing unit (CPU), a cache, a memory, display devices, and a graphics device having an embodiment of an instruction transport and an embodiment of a graphics context manager. The graphics device <highlight><bold>200</bold></highlight> contains multiple ring buffer registers <highlight><bold>204</bold></highlight>, <highlight><bold>206</bold></highlight>, a ring buffer direct memory access engine (RB DMA ENG) <highlight><bold>212</bold></highlight>, a graphics-rendering engine <highlight><bold>214</bold></highlight>, and context identification registers (CID) <highlight><bold>222</bold></highlight>, <highlight><bold>224</bold></highlight>. Multiple ring buffer memory areas <highlight><bold>208</bold></highlight>, <highlight><bold>210</bold></highlight>, multiple established memory locations <highlight><bold>216</bold></highlight>, <highlight><bold>218</bold></highlight>, <highlight><bold>220</bold></highlight> and multiple display devices <highlight><bold>228</bold></highlight>, <highlight><bold>23</bold></highlight>(<highlight><bold>0</bold></highlight> are associated with the graphics device <highlight><bold>200</bold></highlight>. In an embodiment, an instruction transport includes multiple ring buffer registers <highlight><bold>204</bold></highlight>, <highlight><bold>206</bold></highlight>, multiple ring buffer memory areas <highlight><bold>208</bold></highlight>, <highlight><bold>210</bold></highlight> and a direct memory access engine <highlight><bold>212</bold></highlight>. In an embodiment, a context manager consists of context identification registers (CID) <highlight><bold>222</bold></highlight>, <highlight><bold>224</bold></highlight>, an active context identification register (Active CID) <highlight><bold>226</bold></highlight>, and multiple established memory locations <highlight><bold>216</bold></highlight>, <highlight><bold>218</bold></highlight>, <highlight><bold>220</bold></highlight>. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> illustrates a block diagram of an embodiment of a ring buffer memory area. As noted above, an embodiment of the instruction transport contains one or more ring buffer registers <highlight><bold>310</bold></highlight> and one or more ring buffer memory areas <highlight><bold>300</bold></highlight> through which software-generated instructions can be passed to the graphics-rendering engine (not shown). A ring buffer memory area <highlight><bold>300</bold></highlight> holds the actual image rendering instructions from a graphics application (not shown). The ring buffer register <highlight><bold>310</bold></highlight> defines the start and length of the ring buffer memory area <highlight><bold>300</bold></highlight>, and includes two &ldquo;offsets&rdquo;, a head <highlight><bold>304</bold></highlight> and tail <highlight><bold>302</bold></highlight>, into the ring buffer memory area <highlight><bold>300</bold></highlight>. The tail offset <highlight><bold>302</bold></highlight> informs the graphics-rendering engine of the presence of valid instructions that must be executed. The head offset <highlight><bold>304</bold></highlight> is incremented by the graphics-rendering engine as those instructions are parsed and executed. Instructions can wrap around from the bottom of the ring buffer memory area <highlight><bold>300</bold></highlight> back to the top of the ring buffer memory area <highlight><bold>300</bold></highlight>. In an embodiment, the ring buffer memory area <highlight><bold>300</bold></highlight> stores an instruction to point to the location of a batch buffer (not shown). The batch buffer contains a separate list of image rendering instructions that may be stored in a discrete memory area to provide extra instruction storage capacity. In an embodiment, the batch buffer stores an independent sequence of instructions that can be invoked from an instruction stream. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> Referring back to <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, each ring buffer register <highlight><bold>204</bold></highlight>, <highlight><bold>206</bold></highlight> may have multiple fields within the register. The fields contained within an embodiment of a ring buffer register, such as the first ring buffer register <highlight><bold>204</bold></highlight>, may be a ring buffer valid field (V) <highlight><bold>232</bold></highlight>, a start address field (S) <highlight><bold>234</bold></highlight>, a buffer length field (L) <highlight><bold>235</bold></highlight>, a head offset field (H) <highlight><bold>236</bold></highlight>, a head wrap count field (W) <highlight><bold>233</bold></highlight>, a tail offset field (T) <highlight><bold>237</bold></highlight>, an automatic report head enable field (R) <highlight><bold>238</bold></highlight>, a time slice field (TS) <highlight><bold>239</bold></highlight> and other similar fields. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> The ring buffer valid field <highlight><bold>232</bold></highlight> controls whether this particular ring buffer register is included in the arbitration process for sharing the graphics-rendering engine <highlight><bold>214</bold></highlight>. The start address field <highlight><bold>234</bold></highlight> points to the start of a contiguous memory region comprising the ring buffer memory area <highlight><bold>208</bold></highlight>, <highlight><bold>210</bold></highlight>. A ring buffer memory area <highlight><bold>208</bold></highlight>, <highlight><bold>210</bold></highlight> located in either the system memory <highlight><bold>232</bold></highlight> or a dedicated memory. The buffer length field <highlight><bold>235</bold></highlight> specifies the size in bytes of the allocated ring buffer memory area <highlight><bold>208</bold></highlight>, <highlight><bold>210</bold></highlight>. In an embodiment, the ring buffer length field <highlight><bold>235</bold></highlight> defines the largest amount of data that can be submitted at any one time to a ring buffer memory area <highlight><bold>208</bold></highlight>, <highlight><bold>210</bold></highlight>. In an embodiment, the ring buffer memory area <highlight><bold>208</bold></highlight>, <highlight><bold>210</bold></highlight> may contain image rendering instructions and pointers to one or more batch buffers <highlight><bold>240</bold></highlight>, thereby, making a virtually limitless memory area to contain instructions. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> The head offset field <highlight><bold>236</bold></highlight> points to the memory offset from start address <highlight><bold>234</bold></highlight> of the next instruction that the graphics-rendering engine <highlight><bold>214</bold></highlight> will parse. For example the head offset <highlight><bold>236</bold></highlight> may point to one memory unit past the last instruction parsed. The graphics-rendering engine <highlight><bold>214</bold></highlight> updates the head offset field <highlight><bold>236</bold></highlight> as instructions are parsed. Once the head offset <highlight><bold>236</bold></highlight> reaches the value of the tail offset <highlight><bold>237</bold></highlight>, i.e. the offsets are equal, then the graphics-rendering engine <highlight><bold>214</bold></highlight> considers the ring buffer memory area <highlight><bold>208</bold></highlight>, <highlight><bold>210</bold></highlight> empty and removes the corresponding ring buffer register <highlight><bold>204</bold></highlight>, <highlight><bold>206</bold></highlight> from the arbitration process for sharing the graphics-rendering engine <highlight><bold>214</bold></highlight> as long as that condition remains. Thus, an indication exists that the instruction stream for that particular display device should be removed from the central process. Also, included in the ring buffer registers <highlight><bold>204</bold></highlight>, <highlight><bold>206</bold></highlight> is an automatic report head enable fieldthat enables the head pointer value and the head wrap count field <highlight><bold>233</bold></highlight> to be written to cacheable memory for more efficient flow control algorithms. For example, flow control algorithms during polling the head offset <highlight><bold>236</bold></highlight> to ascertain progress. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> The ring buffer memory area <highlight><bold>208</bold></highlight>, <highlight><bold>210</bold></highlight>, may wrap instructions from the end of the memory area to the start of the memory area. The head wrap count field <highlight><bold>233</bold></highlight> is incremented by the graphics-rendering engine <highlight><bold>214</bold></highlight> every time the head offset <highlight><bold>236</bold></highlight> wraps around back to the start address <highlight><bold>234</bold></highlight> of the ring buffer memory area <highlight><bold>208</bold></highlight>, <highlight><bold>210</bold></highlight>. In an embodiment, the head wrap count field <highlight><bold>233</bold></highlight> is included in the DWord written in the &ldquo;report head&rdquo; process. The graphics device <highlight><bold>200</bold></highlight> can use the head wrap count field <highlight><bold>233</bold></highlight> to track the instruction parsing progress as if the ring buffer memory area <highlight><bold>208</bold></highlight>, <highlight><bold>210</bold></highlight> has a &ldquo;virtual&rdquo; length much greater than the size of the actual physical buffer. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> The tail offset field <highlight><bold>237</bold></highlight> points to a location in the ring buffer memory area <highlight><bold>208</bold></highlight>, <highlight><bold>210</bold></highlight> that is offset a specific distance from start address <highlight><bold>234</bold></highlight>. The tail-offset field <highlight><bold>237</bold></highlight> may point to the next memory unit of instruction data that graphics application software can use to store additional image rendering instructions to be later executed.. For example, the tail offset field <highlight><bold>237</bold></highlight> points one memory unit <highlight><bold>232</bold></highlight> past the last instruction submitted to the graphics-rendering engine <highlight><bold>214</bold></highlight> for execution. The instructions submitted can wrap around from the end of the ring buffer memory area <highlight><bold>208</bold></highlight>, <highlight><bold>210</bold></highlight> back to the top, in which case the tail offset <highlight><bold>237</bold></highlight> written will be less than the previous value. The &ldquo;empty&rdquo; condition of a ring buffer memory area <highlight><bold>208</bold></highlight>, <highlight><bold>21</bold></highlight>.<highlight><bold>0</bold></highlight> may be defined as &ldquo;head offset field <highlight><bold>236</bold></highlight> equals the tail offset field <highlight><bold>237</bold></highlight>.&rdquo;</paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> The automatic report head enable field <highlight><bold>238</bold></highlight> allows graphics application software or operating software to request to have the head offset field <highlight><bold>236</bold></highlight> and head wrap count field <highlight><bold>233</bold></highlight> contents to be written to a specific, (CPU-snooped system memory location on a periodic basis. Auto-reports can be programmed to occur each time the head offset field <highlight><bold>236</bold></highlight> advances by a programmed amount. The auto-report mechanism allows software to use the head offset field <highlight><bold>236</bold></highlight> head wrap count field <highlight><bold>233</bold></highlight> to determine the amount of free space in the ring buffer. Thus, the head offset field <highlight><bold>236</bold></highlight> may be periodically reported to the system memory to provide a fairly up-to-date, head offset field <highlight><bold>236</bold></highlight> value automatically, without having to explicitly obtain a head pointer value via an instruction. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> Each display device <highlight><bold>228</bold></highlight>, <highlight><bold>230</bold></highlight> may have a separate instruction transport associated with that individual display device. As illustrated in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, the first ring buffer register <highlight><bold>204</bold></highlight> and the first ring buffer memory area <highlight><bold>208</bold></highlight> are associated with the first display device <highlight><bold>228</bold></highlight>. The second ring buffer register <highlight><bold>206</bold></highlight> and the second ring buffer memory area <highlight><bold>210</bold></highlight> are associated with the second display device <highlight><bold>230</bold></highlight>. Thus, in this example, the first ring buffer register <highlight><bold>204</bold></highlight> and first ring buffer memory <highlight><bold>208</bold></highlight> area provide the instructions for the rendering of the independent image to be displayed on the first display device <highlight><bold>228</bold></highlight>. In an embodiment, the first ring buffer register <highlight><bold>204</bold></highlight> and first ring buffer memory area <highlight><bold>208</bold></highlight> may be associated with the second display device <highlight><bold>230</bold></highlight>. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> Multiple instruction transports allow different priorities to be assigned to each instruction transport. For example, lower priority instruction transports can be used for interruptible background rendering tasks. Likewise, a higher priority instruction transport can be used to service asynchronous events, such as video frame capture. Also, by allocating a first instruction transport to service one display device, such as the first display <highlight><bold>228</bold></highlight>, and a second instruction transport to service another display device, such as the second display device <highlight><bold>230</bold></highlight>, the graphics device <highlight><bold>200</bold></highlight> can support separate instruction streams per display device. Further, the graphics device <highlight><bold>200</bold></highlight> can support separately controlled instruction streams per display device. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> As noted above, each instruction transport may include a direct memory access engine <highlight><bold>212</bold></highlight>. The direct memory access engine <highlight><bold>212</bold></highlight> fetches instructions from a particular instruction transport and delivers these instructions to the graphics-rendering engine <highlight><bold>214</bold></highlight>. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> The graphics-rendering engine <highlight><bold>214</bold></highlight> reads image instructions from the instruction transport via the direct memory access engine <highlight><bold>212</bold></highlight> and executes these image instructions. The graphics-rendering engine <highlight><bold>214</bold></highlight> detects the presence of instructions within the ring buffer memory areas <highlight><bold>208</bold></highlight>, <highlight><bold>210</bold></highlight> via the difference between head offset field <highlight><bold>236</bold></highlight> and tail offset field <highlight><bold>237</bold></highlight> in the ring buffer register <highlight><bold>204</bold></highlight>, <highlight><bold>206</bold></highlight>. The graphics-rendering engine <highlight><bold>214</bold></highlight> interprets and decodes the common &ldquo;Header&rdquo; field of instructions in order to determine what information the instruction contains and therefore how to further execute the instruction. This interpretation and decoding of instructions is commonly referred to as parsing. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> In an embodiment, the graphics-rendering engine <highlight><bold>214</bold></highlight> decodes specific instructions from the instruction stream <highlight><bold>242</bold></highlight> to find out to find out what information the instruction contains (e.g., a state variable change <highlight><bold>246</bold></highlight> to apply or a primitive <highlight><bold>248</bold></highlight> to be rendered). The graphics-rendering engine <highlight><bold>214</bold></highlight> then executes the instruction accordingly. The execution of state variable change instruction <highlight><bold>246</bold></highlight> causes a specific change to the current rendering context. The execution of a primitive instruction <highlight><bold>248</bold></highlight> causes modification of the appropriate image information in memory <highlight><bold>256</bold></highlight>, <highlight><bold>258</bold></highlight> (i.e., the image is rendered). The graphics-rendering engine <highlight><bold>214</bold></highlight> then stores the image information in memory locations corresponding to each display device <highlight><bold>228</bold></highlight>, <highlight><bold>230</bold></highlight>, such the first display image <highlight><bold>256</bold></highlight> and the second display image <highlight><bold>258</bold></highlight>. In an embodiment, the information for the first display image <highlight><bold>256</bold></highlight> and the information for the second display image <highlight><bold>258</bold></highlight> are stored in a local memory dedicated to both the first display device <highlight><bold>228</bold></highlight> and the second display device <highlight><bold>230</bold></highlight>. In an embodiment, the instructions <highlight><bold>1</bold></highlight>for the first display image <highlight><bold>256</bold></highlight> and the instructions for the second display image <highlight><bold>258</bold></highlight> are stored in the system memory <highlight><bold>232</bold></highlight>. The graphics-rendering engine <highlight><bold>214</bold></highlight> reads the rendered image information from memory and present the rendered image information to the associated display device on a periodic basis. The display device, such as the first display device <highlight><bold>228</bold></highlight>, then illustrates the actual images on a display based upon this information. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> In an embodiment, the graphics applications supply instructions into the instruction stream <highlight><bold>242</bold></highlight>. As noted, these instructions may be stored in a ring buffer memory area <highlight><bold>208</bold></highlight>, <highlight><bold>210</bold></highlight> which is usually associated with a particular display device <highlight><bold>228</bold></highlight>, <highlight><bold>230</bold></highlight>. In an embodiment, some of the types of instructions found in the instruction stream <highlight><bold>242</bold></highlight> may be a state variable change <highlight><bold>246</bold></highlight>, a primitive <highlight><bold>248</bold></highlight>, and a set context commands <highlight><bold>250</bold></highlight>, <highlight><bold>252</bold></highlight>. A primitive instruction <highlight><bold>248</bold></highlight> directs the graphics-rendering engine <highlight><bold>214</bold></highlight> as to the shapes to draw and the location and dimensions to attribute to those shapes. The state variable change instruction <highlight><bold>246</bold></highlight> directs the graphics-rendering engine <highlight><bold>214</bold></highlight> to modify the current values of the set of rendering state variables stored in the hardware graphics context circuit <highlight><bold>244</bold></highlight> when rendering an image. In an embodiment, the set context command (Set CXT &num;) <highlight><bold>250</bold></highlight>, <highlight><bold>252</bold></highlight> may cause the; graphics-rendering engine <highlight><bold>214</bold></highlight> to save the current rendering context to an established memory location, such as the first established memory location <highlight><bold>216</bold></highlight>, and restore the new rendering context from a new established memory location, such as a second established memory location <highlight><bold>218</bold></highlight>. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> Each established memory location, such as the first established memory location <highlight><bold>216</bold></highlight>, stores the rendering context of an image being rendered by the graphics-rendering engine <highlight><bold>214</bold></highlight>. Likewise, each established memory location <highlight><bold>216</bold></highlight> <highlight><bold>218</bold></highlight>, <highlight><bold>220</bold></highlight> may store the settings of the rendering state variables to be employed when rendering the associated independent image. In an embodiment, the existence of multiple established memory locations <highlight><bold>216</bold></highlight>, <highlight><bold>218</bold></highlight>, <highlight><bold>220</bold></highlight> allows the graphic-rendering engine <highlight><bold>214</bold></highlight> to keep track of the rendering context associated with each image being rendered. An embodiment of a context manager contains multiple established memory locations <highlight><bold>216</bold></highlight>, <highlight><bold>218</bold></highlight>, <highlight><bold>220</bold></highlight> and context identification registers <highlight><bold>222</bold></highlight>, <highlight><bold>224</bold></highlight>, <highlight><bold>226</bold></highlight> in order to manage the concurrent rendering of multiple images. An embodiment of a context manager coordinates with a graphics display controller circuit (GDC) <highlight><bold>270</bold></highlight> to support displaying images on multiple display devices <highlight><bold>228</bold></highlight>, <highlight><bold>230</bold></highlight> as well as displaying multiple images on the same display device, such as the first display device <highlight><bold>228</bold></highlight>. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> The settings of numerous hardware state variables in the hardware graphics context circuit <highlight><bold>244</bold></highlight> control the graphics operations, such as rendering, in the graphics device <highlight><bold>200</bold></highlight>. The state variables may include global state variables and context state variables. Global state variables are common to all contexts (e.g., logical address mapping resources, etc.) and are therefore considered outside the scope of any specific rendering context. However, each rendering context associated with a specific graphics application does contain a separate set of context state variables. In an embodiment, these rendering contexts associated with a specific graphics application may be stored in established memory locations on active on-chip memory or in multiple established memory locations <highlight><bold>216</bold></highlight>, <highlight><bold>218</bold></highlight>, <highlight><bold>220</bold></highlight> in system memory <highlight><bold>232</bold></highlight>. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> As noted, the multiple established memory locations <highlight><bold>216</bold></highlight>, <highlight><bold>218</bold></highlight>, <highlight><bold>220</bold></highlight> support the graphics-rendering engine <highlight><bold>214</bold></highlight> by storing in a memory <highlight><bold>232</bold></highlight> and restoring from the memory <highlight><bold>232</bold></highlight> the rendering context associated with the independent image being rendered by the graphics-rendering image. In an embodiment, a second set context instruction from the instruction stream <highlight><bold>242</bold></highlight>, such as set context-A0 <highlight><bold>250</bold></highlight>, directs the graphics-rendering engine <highlight><bold>214</bold></highlight> to send the current rendering context for the image being rendered to an established memory location, such as the first established memory location <highlight><bold>216</bold></highlight>, for storage. At the same time, the second established memory location <highlight><bold>218</bold></highlight> associated with the graphics application generating the second image receives a signal from the graphics-rendering engine <highlight><bold>214</bold></highlight> to restore the rendering context associated with a second image being concurrently rendered by the graphics-rendering engine <highlight><bold>214</bold></highlight>. In an embodiment, the addition of a context cache <highlight><bold>260</bold></highlight> located on the device reduces the memory bandwidth and time required to swap contexts. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> The context manager also consists of context identification registers (CID) <highlight><bold>222</bold></highlight>, <highlight><bold>224</bold></highlight>, and an active context identification register <highlight><bold>226</bold></highlight>. Context identification registers <highlight><bold>222</bold></highlight>, <highlight><bold>224</bold></highlight> associate with a particular ring buffer register <highlight><bold>204</bold></highlight>, <highlight><bold>206</bold></highlight> and thus a particular display image memory location <highlight><bold>256</bold></highlight>, <highlight><bold>258</bold></highlight>. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> In an embodiment, the active context identification register <highlight><bold>226</bold></highlight> tracks the context identification register <highlight><bold>222</bold></highlight>, <highlight><bold>224</bold></highlight> value contained within the currently active ring buffer register <highlight><bold>204</bold></highlight>,<highlight><bold>206</bold></highlight>. The tracked context identification register, such as the first context identification register <highlight><bold>222</bold></highlight>, establishes which particular established memory location <highlight><bold>216</bold></highlight>, <highlight><bold>218</bold></highlight>, <highlight><bold>220</bold></highlight> is associated with the image currently being rendered by the graphics rendering engine. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> In an embodiment, each context identification register <highlight><bold>222</bold></highlight>, <highlight><bold>224</bold></highlight>, contains an established memory location address and a set of context qualifier bits. The context qualifier bits control whether portions of the rendering context either do or do not have to be saved/restored upon context switch. In an embodiment, each context identification register <highlight><bold>222</bold></highlight>, <highlight><bold>224</bold></highlight>, implements context qualifier bits such as, a &ldquo;Texture Palette Save Disable&rdquo; context qualifier bit and a &ldquo;Texture Palette Restore Disable&rdquo; context qualifier bit. In an embodiment, these context qualifier bits aid in the swapping of context between two dimensional and three dimensional images, where the three dimensional images may require a current Texture Palette to be maintained (i.e., saved and restored as part of the rendering context) while the two dimensional images may not. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> Established memory locations <highlight><bold>216</bold></highlight>, <highlight><bold>218</bold></highlight>, <highlight><bold>220</bold></highlight> are referenced via the established memory location address of the corresponding context identification register <highlight><bold>222</bold></highlight>, <highlight><bold>224</bold></highlight>. The actual size of an established memory location <highlight><bold>216</bold></highlight>, <highlight><bold>218</bold></highlight>, <highlight><bold>220</bold></highlight> is the amount of data stored/restored during a context switch and depends on whether the rendering context includes a texture palette. In an embodiment, a context identification register <highlight><bold>222</bold></highlight>, <highlight><bold>224</bold></highlight> may contain two additional registers to specify the respective established memory location <highlight><bold>216</bold></highlight>, <highlight><bold>218</bold></highlight>, <highlight><bold>220</bold></highlight> size in memory <highlight><bold>232</bold></highlight>. In an embodiment, a particular context identification register <highlight><bold>222</bold></highlight>, <highlight><bold>224</bold></highlight> is made the active register during the processing of a &ldquo;set_context&rdquo; instruction <highlight><bold>250</bold></highlight>, <highlight><bold>252</bold></highlight> from the instruction stream <highlight><bold>242</bold></highlight> being stored in the corresponding ring buffer memory area <highlight><bold>208</bold></highlight>, <highlight><bold>210</bold></highlight>. In an embodiment, the set_context instruction <highlight><bold>250</bold></highlight>, <highlight><bold>252</bold></highlight> provides a new context identification value (local context address&plus;palette save disable bits) to be loaded into the context identification register <highlight><bold>222</bold></highlight>, <highlight><bold>224</bold></highlight>. The set_context instruction <highlight><bold>250</bold></highlight>, <highlight><bold>252</bold></highlight> also contains a restore inhibit bit used to optionally inhibit the restoration of the new context. In an embodiment, the restore inhibit bit may be used during context initialization to avoid the loading of uninitialized context data from memory <highlight><bold>232</bold></highlight>. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> The active context identification register <highlight><bold>226</bold></highlight> contains the context identification values of the active ring buffer register, such as the first ring buffer register <highlight><bold>204</bold></highlight>. As part of the execution of the set_context instruction <highlight><bold>250</bold></highlight>, <highlight><bold>252</bold></highlight>, the established memory location address fields from the active context identification register <highlight><bold>226</bold></highlight> and set_context instruction are compared. If they differ or the active context identification register <highlight><bold>226</bold></highlight> is uninitialized, a context switch operation occurs. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> In an embodiment, during the context switch operation, if a restore inhibit instruction field is not set, a context restore operation may be performed. Here, the address value for an established memory location, such as the first established memory location <highlight><bold>216</bold></highlight> is used to load the active context identification register <highlight><bold>226</bold></highlight>. Note, that the context qualifier fields of the instruction may further condition the restoration of portions of the rendering context. For example, the texture palette may or may not be restored. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> The HW GFX CXT <highlight><bold>244</bold></highlight> causes the load of the new context from the appropriate established memory location, as well as the loading of the active context identification register with the value from the set context instruction <highlight><bold>250</bold></highlight>, <highlight><bold>252</bold></highlight>. At this point, the corresponding ring buffer register <highlight><bold>204</bold></highlight>, <highlight><bold>206</bold></highlight> and ring buffer memory area <highlight><bold>208</bold></highlight>, <highlight><bold>210</bold></highlight> have switched the active context to the new established memory location <highlight><bold>216</bold></highlight>, <highlight><bold>218</bold></highlight>, <highlight><bold>220</bold></highlight>. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> As noted previously, each graphics application may be generating image instructions at different rates of speed. Equally true is that each display device <highlight><bold>228</bold></highlight>, <highlight><bold>230</bold></highlight> may refresh the display and its associated image at different rates of speed. In an embodiment, the content manager and the instruction transport support the seamless switching between different instruction streams, switching between different display devices <highlight><bold>228</bold></highlight>, <highlight><bold>252</bold></highlight>, and switching between rendering contexts associated with different graphics applications within the same instruction stream <highlight><bold>242</bold></highlight>. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> illustrates a block diagram of an embodiment of a time allocator to allocate the use of the graphics-rendering engine between each independent image being rendered. In an embodiment, the time allocator <highlight><bold>400</bold></highlight> contains an arbitration and switching module <highlight><bold>410</bold></highlight>, a timer register <highlight><bold>412</bold></highlight>, a unit register <highlight><bold>414</bold></highlight>, a unit-time counter <highlight><bold>416</bold></highlight> and a time slice counter <highlight><bold>418</bold></highlight>. In an embodiment, the time allocator <highlight><bold>400</bold></highlight> provides an elapsed time criteria and fairness use criteria to allocate the use of the single graphic-rendering engine <highlight><bold>411</bold></highlight>. In an embodiment, the time allocator <highlight><bold>400</bold></highlight> may allocate the use of the graphics-rendering engine <highlight><bold>411</bold></highlight> to render independent images between either multiple display devices (not shown), multiple graphic application programs each having its own instruction stream <highlight><bold>413</bold></highlight>, and multiple graphics application programs within a single instruction stream <highlight><bold>413</bold></highlight>. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> Each ring buffer register, such as the first ring buffer register <highlight><bold>402</bold></highlight> and the second ring buffer register <highlight><bold>404</bold></highlight>, may be time sliced or the ring buffer register may be non-time-sliced, such as the third ring buffer register <highlight><bold>406</bold></highlight>. As will be described later, each non-time sliced register may be used for hi-priority graphic images, such as live video, to temporarily monopolize the use of the graphics-rendering engine <highlight><bold>411</bold></highlight>. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> Each time-sliced ring buffer register <highlight><bold>402</bold></highlight>, <highlight><bold>404</bold></highlight> has associated with it a TIME_SLICE register <highlight><bold>420</bold></highlight>, <highlight><bold>422</bold></highlight> that specifies the desired duration of instruction execution to be performed before indicating that a switch to another time-sliced ring buffer should be checked. In an embodiment, a time slice field <highlight><bold>420</bold></highlight>, <highlight><bold>422</bold></highlight> in the ring buffer register <highlight><bold>402</bold></highlight>, <highlight><bold>404</bold></highlight> exists to specify a percent of use of the graphics-rendering engine <highlight><bold>411</bold></highlight> that should be accorded to this particular ring buffer register <highlight><bold>402</bold></highlight>, <highlight><bold>404</bold></highlight>. The time slice field <highlight><bold>420</bold></highlight>, <highlight><bold>422</bold></highlight> may also specify the minimum absolute time use of the graphics-rendering engine <highlight><bold>411</bold></highlight> that should be accorded to this ring buffer register <highlight><bold>402</bold></highlight>, <highlight><bold>404</bold></highlight>. In an embodiment, the desired duration of instruction execution may be programmed in time units. In an embodiment, the driver software <highlight><bold>424</bold></highlight> may write these time unit values into each time slice field <highlight><bold>420</bold></highlight>, <highlight><bold>422</bold></highlight>. Thus, the driver software <highlight><bold>424</bold></highlight> is able to control both the absolute and relative time devoted to each time-sliced ring buffer register <highlight><bold>420</bold></highlight>, <highlight><bold>422</bold></highlight>. The CPU <highlight><bold>440</bold></highlight> accesses the driver software <highlight><bold>424</bold></highlight> from a memory, such as memory <highlight><bold>442</bold></highlight>, </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> The unit register <highlight><bold>414</bold></highlight> provides a forward-compatible unit-time time quanta to be used by driver software <highlight><bold>424</bold></highlight>. Establishing a unit-time quanta is important where the actual time reference of the device may vary between configurations and/or implementations. In an embodiment, the unit register <highlight><bold>414</bold></highlight> uses the graphic device&apos;s <highlight><bold>400</bold></highlight> core clock period as the actual time reference. The unit register <highlight><bold>414</bold></highlight> may be programmed via the BIOS firmware <highlight><bold>426</bold></highlight> for the graphic device <highlight><bold>400</bold></highlight>. The other time slice parameters may be defined relative to this unit-time quanta established by the unit register <highlight><bold>414</bold></highlight>. Each unit-time quota defined by unit register <highlight><bold>414</bold></highlight> may be, for example one unit-time equals fifty microseconds or one unit-time equals forty clock cycles. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> The unit register <highlight><bold>414</bold></highlight> also contains a time-slice enable bit (T) <highlight><bold>428</bold></highlight> to turn ring buffer time slicing on or off. In an embodiment, when the time-slice enable bit <highlight><bold>428</bold></highlight> of the unit register <highlight><bold>414</bold></highlight> is clear, fixed ring buffer priorities are in effect. In an embodiment, when the time-slice enable bit <highlight><bold>428</bold></highlight> is set, arbitration between the time sliced ring buffer registers <highlight><bold>401</bold></highlight>, <highlight><bold>404</bold></highlight> is controlled via the time slice fields <highlight><bold>420</bold></highlight>, <highlight><bold>422</bold></highlight>. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> A timer register <highlight><bold>412</bold></highlight> implements the time slice timing control. When the time-slice enable bit <highlight><bold>428</bold></highlight> is set, the time register <highlight><bold>412</bold></highlight> reads the value in units written into the time slice fields <highlight><bold>420</bold></highlight>, <highlight><bold>422</bold></highlight> portion of each ring buffer registers <highlight><bold>402</bold></highlight>, <highlight><bold>404</bold></highlight>. In this mode, the activation or resumption of an instruction-stream <highlight><bold>413</bold></highlight> supplying instructions to a specific ring buffer memory area, such as the first ring buffer memory area <highlight><bold>430</bold></highlight>, causes the timer countdown field (TC) <highlight><bold>434</bold></highlight> to be initialized with the content value in the time slice register <highlight><bold>420</bold></highlight>, <highlight><bold>422</bold></highlight> portion of that specific ring buffer, such as the first ring buffer register <highlight><bold>420</bold></highlight>. The timer countdown field <highlight><bold>434</bold></highlight> decrements every time-unit while the execution of the instructions from the ring buffer memory area continues. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> The time slice counter <highlight><bold>418</bold></highlight> decrements the timer countdown field <highlight><bold>434</bold></highlight> every time unit. The unit time counter <highlight><bold>416</bold></highlight> monitors and counts every core clock cycle. The unit time counter <highlight><bold>416</bold></highlight> sends a signal to the time slice counter <highlight><bold>418</bold></highlight> to decrement the timer countdown field <highlight><bold>434</bold></highlight> based upon the established unit time quota defined by unit register <highlight><bold>414</bold></highlight>. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> In an embodiment, if the following two conditions exist then the graphics-rendering engine <highlight><bold>411</bold></highlight> receives an instruction from the arbitration and switching module <highlight><bold>410</bold></highlight> to stop rendering the instructions from a ring buffer memory area and start rendering instructions from another ring buffer memory area. The two conditions are if the timer countdown field <highlight><bold>434</bold></highlight> becomes zero, and pending instructions exist in the other ring buffer memory area. The graphics-rendering engine <highlight><bold>411</bold></highlight> then switches to executing the other ring buffer memory area, such as the second ring buffer memory area <highlight><bold>432</bold></highlight>, which causes the timer countdown field <highlight><bold>434</bold></highlight> to be reinitialized with the contents in time slice field <highlight><bold>422</bold></highlight> in the second ring buffer register <highlight><bold>404</bold></highlight>. The switch occurs at the next instruction arbitration point. </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> However, if there are no pending instructions in the other ring buffer memory areas, such as the first ring buffer memory area <highlight><bold>430</bold></highlight>, when the timer countdown field <highlight><bold>434</bold></highlight> becomes zero, then execution of the instruction in the current ring buffer memory area continues. In an embodiment, the execution of the instructions in the current ring buffer memory area continues indefinitely until when the other ring buffer register communicates the presence of instructions. In an embodiment, a ring buffer register, such as the first ring buffer register <highlight><bold>402</bold></highlight> indicates the presence of instructions to execute when the value in the head offset field <highlight><bold>415</bold></highlight> differs form the value of the tail offset value <highlight><bold>417</bold></highlight>. In an embodiment, the presence of the new instructions is communicated to the arbitration and switching module <highlight><bold>410</bold></highlight>. The arbitration and switching module continues the execution of the instructions in the current ring buffer memory area for the value specified in the time slice field <highlight><bold>402</bold></highlight>, <highlight><bold>422</bold></highlight> and then switches to executing the new instructions. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> The active context identification register communicates to the graphics-rendering engine <highlight><bold>411</bold></highlight> via the arbitration and switching module <highlight><bold>410</bold></highlight> the context identification register values of the active ring buffer register (not shown). </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> Several mechanisms can interrupt the arbitration process for use of the graphics-rendering engine <highlight><bold>411</bold></highlight> between two ring buffer registers having pending instructions stored in their respective ring buffer memory areas. As noted above, a non-time slicing high priority ring buffer, such as the third ring buffer register <highlight><bold>406</bold></highlight>, may communicate to the arbitration and switching module <highlight><bold>410</bold></highlight> to suspend the timer countdown <highlight><bold>434</bold></highlight> and rendering of instructions for the currently active time-sliced ring buffer register. This suspension is only temporary until the graphics rendering engine <highlight><bold>411</bold></highlight> finishes rendering the current instructions associated with the non-time sliced ring buffers. </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> The instruction stream <highlight><bold>413</bold></highlight> from the graphics application software may contain instructions to temporarily interrupt the arbitrated use of the graphics-rendering engine <highlight><bold>411</bold></highlight>. For example, a &ldquo;load register&rdquo; instruction <highlight><bold>423</bold></highlight> may interrupt the arbitration use of the graphics rendering engine <highlight><bold>411</bold></highlight> between two time-sliced ring buffer registers <highlight><bold>402</bold></highlight>, <highlight><bold>422</bold></highlight> having pending instructions stored in their respective ring buffer memory areas <highlight><bold>430</bold></highlight>, <highlight><bold>432</bold></highlight>. The software can use the &ldquo;load register&rdquo; instruction <highlight><bold>423</bold></highlight> to clear the timer countdown field <highlight><bold>434</bold></highlight> and, thus, effectively make the active ring buffer register give up the remainder of its time slice period if pending instructions exist in another ring buffer memory area. For example, the &ldquo;load register&rdquo; instruction <highlight><bold>423</bold></highlight> may be used when the time for the instructions being executed is not anticipated to exceed either the specified percent of use or the absolute minimum time accorded to the ring buffer register <highlight><bold>402</bold></highlight>, <highlight><bold>422</bold></highlight>. In an embodiment, if the instructions associated with a first stream do not take up the entire time slice period, then the arbitration and switching module <highlight><bold>410</bold></highlight> automatically switches to another a ring buffer memory area containing pending instructions. Also, for example, the &ldquo;load register&rdquo; instruction <highlight><bold>423</bold></highlight> may be used prior to an extremely time-consuming instruction or non-interruptable sequence of instruction to allow the pending instructions for a second application to be processed before the graphics rendering engine <highlight><bold>411</bold></highlight> operates on this particular sequence of instructions. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> As noted, if there are no other ring buffer memory areas <highlight><bold>430</bold></highlight>, <highlight><bold>432</bold></highlight> with instructions ready to execute, the execution of instructions continues past the &ldquo;load register&rdquo; instruction <highlight><bold>423</bold></highlight>. If another ring buffer memory area <highlight><bold>430</bold></highlight>, <highlight><bold>432</bold></highlight> does have instructions to execute, after the execution of the other ring buffer&apos;s instructions, then the graphics rendering engine <highlight><bold>411</bold></highlight> immediately switches back to the original ring buffer&apos;s instructions without waiting through a timer countdown <highlight><bold>434</bold></highlight>. </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> The instruction stream <highlight><bold>413</bold></highlight> may also contain a &ldquo;wait for event&rdquo; instruction <highlight><bold>425</bold></highlight>. The &ldquo;wait for event&rdquo; instruction <highlight><bold>425</bold></highlight> may be used to pause execution of instructions from this particular instruction-stream <highlight><bold>413</bold></highlight> until a certain condition exists or event happens. If execution of &ldquo;wait for event&rdquo; instruction <highlight><bold>425</bold></highlight> results in a pause, other time-sliced ring buffer registers <highlight><bold>402</bold></highlight>, <highlight><bold>404</bold></highlight> are allowed to have the graphics-rendering engine process their associated instructions, even before the remainder of the paused ring buffer&apos;s time slice period is expired. For example, a &ldquo;wait for event&rdquo; instruction <highlight><bold>425</bold></highlight> may be used to wait for a video capture event. The display device must use those instructions to display the image when going from the top vertical position on the display screen to the low vertical position on the display screen. Thus, the graphics-rendering engine <highlight><bold>411</bold></highlight> has rendered all of the instructions for the complete image on the display screen and can not render any more instructions for that display device until transition period expires from the top vertical position to the low vertical position. During the time the graphics device <highlight><bold>400</bold></highlight> is waiting for such an event to occur, a &ldquo;wait for event&rdquo; instruction <highlight><bold>425</bold></highlight> permits the graphics-rendering engine <highlight><bold>411</bold></highlight> to re-enable the processing of another time-sliced ring buffer memory area associated with a different display device while waiting for that asynchronous event to occur for the current display device. An asynchronous event is an event that is not occurring at regular interval, or coordinated in time, such as a video capture event. In an embodiment, the asynchronous event occurs either randomly or at an interval unrelated to the instruction stream execution. For example, a display device&apos;s vertical blank event, an asynchronous event, actually occurs at a regular interval in real world time (i.e., 60 Hz), but is asynchronous to the irregular service time associated with the instruction stream <highlight><bold>413</bold></highlight> execution. </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> and <cross-reference target="DRAWINGS">FIG. 6</cross-reference> illustrate a flow diagram of an embodiment of a process for rendering multiple images on multiple display devices using a single graphic-rendering engine. An instruction stream originates the process when the instruction stream carries instructions from one or more graphics applications to an instruction transport. </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> In block <highlight><bold>505</bold></highlight>, a first ring buffer memory area defined by a ring buffer register receives instructions from multiple graphics application programs or via a single graphics application program. The location and size of the first ring buffer memory area may be defined by programmable content contained in a first ring buffer register. The instruction transport may contain one or more ring buffer memory areas or similar memory areas. The instruction transport may contain one or more ring buffer registers or similar devices. </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> In block <highlight><bold>510</bold></highlight>, the driver stores the instructions representing the image in the first ring buffer memory area. In an embodiment, the Tail Offset field in the corresponding ring buffer register is changed by the driver to indicate the presence of these pending instructions contained in the first ring buffer memory area. The first ring buffer register communicates the presence of instructions to be executed to the graphics rendering engine and the arbitration and switching module. </paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> In block <highlight><bold>515</bold></highlight>, the instruction transport uses a DMA engine to fetch the instructions from the first ring buffer memory for the graphics-rendering engine. The arbitration and switching module sets the first ring buffer memory as the memory the graphics-rendering engine is processing instructions from. </paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> In block <highlight><bold>520</bold></highlight>, the graphics context manager sets the current rendering context associated with the first ring buffer register. </paragraph>
<paragraph id="P-0068" lvl="0"><number>&lsqb;0068&rsqb;</number> In block <highlight><bold>525</bold></highlight>, in an embodiment, if the first (current) image that being processed by the graphics-rendering engine has a rendering context different than the second (next) image to be processed next then the following happens. The graphics context manager stores the rendering context associated with the first image and restores the context associated with the second image to the graphics-rendering engine. The graphics context manager stores and restores state variable values representing a rendering context associated with an image from a particular graphics application in a second memory area, such as an established memory location. The second memory area may be defined by programmable content contained in a second register, such as a context identification register. </paragraph>
<paragraph id="P-0069" lvl="0"><number>&lsqb;0069&rsqb;</number> In block <highlight><bold>530</bold></highlight>, the graphics-rendering engine executes the instructions from the ring buffer memory area associated with a first display device, such as the first ring buffer memory area, and makes the appropriate modifications to the first image display memory area. . Based upon the time allocator, the graphics-rendering engine may then start executing instructions from a second ring buffer memory area associated with a second display device. In an embodiment, the graphics-rendering engine may start executing instructions from a second graphics application contained within the same instruction stream supplying the first ring buffer memory area. Thus, the graphics-rendering engine may alternate between the processing of instructions associated with a first independent image and instructions associated with a second independent image by switching. The graphics-rendering engine may switch between processing instructions from different ring buffer memory areas or by processing instructions from two different graphics applications within the same instruction stream. Note, the graphics-rendering engine need not wait to completely process all of the instructions associated with the first independent image before starting to process instructions associated with the second independent image. </paragraph>
<paragraph id="P-0070" lvl="0"><number>&lsqb;0070&rsqb;</number> In block <highlight><bold>535</bold></highlight>, the time allocator may load balance use of the graphic rendering engine between the instructions associated with first independent image and the second independent image. In an embodiment, the time allocator may load balance use of the graphics-rendering engine between the instructions associated with two or more independent images. In an embodiment, the time allocator balances the use of the graphics rendering engine based upon an percentage determined for each image and an absolute minimum time of usage of the graphics-rendering engine determined for each image. The time allocator may also balance the use of the graphics-rendering engine between high priority images demanding immediate use of the graphics-rendering engine and images sharing the percentage of use and absolute minimum time use of the graphics-rendering engine. </paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> In block <highlight><bold>540</bold></highlight>, the time allocator may establish a time-unit quantum in the timing circuit compatible with devices operating at a different core frequency. Note, these blocks are not indicative of any set sequential order of performance. For example, block <highlight><bold>540</bold></highlight> may occur before block <highlight><bold>505</bold></highlight>. </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> In block <highlight><bold>545</bold></highlight>, the time allocator may yield time designated for instructions associated with a first image to use the graphics-rendering engine over to instructions associated with a second image via a software instruction from the graphics device driver. </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> In block <highlight><bold>550</bold></highlight>, the time allocator may permit the graphics-rendering engine to process instructions associated with a second image while waiting for an image-rendering event to occur to a first image via a software instruction from a graphics application. </paragraph>
<paragraph id="P-0074" lvl="0"><number>&lsqb;0074&rsqb;</number> In block <highlight><bold>555</bold></highlight>, the graphic device concurrently displays images on one or more display devices. </paragraph>
<paragraph id="P-0075" lvl="0"><number>&lsqb;0075&rsqb;</number> In block <highlight><bold>570</bold></highlight>, the graphics device continues this process started in block <highlight><bold>505</bold></highlight>. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. An apparatus, comprising: 
<claim-text>a graphics-rendering engine to concurrently render two or more independent images for display on multiple display devices; and </claim-text>
<claim-text>a time allocator to arbitrate the use of the graphics-rendering engine between the two or more independent images. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the time allocator comprises: 
<claim-text>a plurality of registers including a first register, the first register having a plurality of fields including a first field to determine whether the first register participates in an arbitration process to use the graphics rendering engine and a second field to point to a memory location containing instructions from a first instruction stream. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, wherein the time allocator further comprising: 
<claim-text>A first module to establish a programmable elapsed period of time to use the graphics-rendering engine. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference>, wherein the time allocator further comprises: 
<claim-text>a first circuit to generate a signal to check if a second register should be allowed to use the graphics-rendering engine after the first register uses the graphics-rendering engine for the programmable elapsed period of time. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, wherein the time allocator further comprises: 
<claim-text>a first module to direct the graphics-rendering engine to process instructions associated with a first independent image, the instructions stored in a first memory area, the first memory area having an address defined by information contained within the plurality of the fields. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference>, wherein the first memory area has a start and an end, the first memory area may wrap-around instructions from the end of the first memory area to the start of the first memory area. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference>, wherein the first module comprises: 
<claim-text>a second circuit to track which register in the plurality of registers is currently being serviced by the graphics-rendering engine; and </claim-text>
<claim-text>a third circuit to manage the use of the graphics-rendering engine between a second register which does not participate in the arbitration process and the first register and a third register which participate in the arbitration process. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference>, wherein the first module comprises: 
<claim-text>a first circuit to track the period of elapsed time that a particular register uses the graphics-rendering engine,. and </claim-text>
<claim-text>a second circuit to convert the programmable elapsed period of time into an equivalent number of clock cycles. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the time allocator comprises; 
<claim-text>a first circuit to permit a graphics device instruction from a graphics application to direct the graphics-rendering engine to process instructions associated with a second independent image while waiting for an asynchronous event to occur for a first independent image. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the time allocator comprises: 
<claim-text>a first circuit to implement a software instruction from a graphics application, the software instruction to yield time allotted for instructions associated with a first independent image to use the graphics-rendering engine over to instructions associated with a second independent image. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising: 
<claim-text>a first display device and a second display device. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising: 
<claim-text>a graphics context manager to restore information from a memory to the graphics-rendering engine, the information describing a rendering context associated witha first independent image to be rendered by the graphics-rendering engine, the first independent image being included in the two or more independent images. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising: 
<claim-text>a first memory area to receive instructions for one or more independent images included in the two or more independent images, and </claim-text>
<claim-text>a second memory area to receive instructions for one or more independent images included in the two or more independent images. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising; 
<claim-text>One or more instruction transports to deliver instructions for the two or more independent images to the graphics-rendering engine, the one or more instruction transports including a first instruction transport. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference>, wherein each instruction transport is associated with a particular display device. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference>, wherein the first instruction transport comprises: 
<claim-text>an instruction memory area; </claim-text>
<claim-text>a first register to define a start and an end to the instruction memory area; and </claim-text>
<claim-text>a memory access engine to fetch and deliver the instructions from the instruction memory area to the graphics-rendering engine. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference>, wherein the instruction transport further comprises: 
<claim-text>a third memory area to store an independent sequence of instructions that can be invoked from an instruction stream. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, wherein the first register contains a first field to instruct the graphics device to write content contained in a second field to a snooped memory location on a periodic basis in order to automatically report an amount of free space available in the instruction memory area. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. A method, comprising: 
<claim-text>using a single graphics-rendering engine to execute instructions associated with a first instruction-stream; </claim-text>
<claim-text>concurrently rendering a first independent image via instructions associated with the first instruction-stream and a second independent image via instructions associated with a second instruction-stream by using the single graphics-rendering engine; and </claim-text>
<claim-text>arbitrating the use of the single graphics-rendering engine between the instructions associated with the first instruction-stream and the instructions associated with the second instruction-stream. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference>, further comprising: 
<claim-text>allocating the concurrent use of the single graphics-rendering engine between the instructions associated with the first instruction-stream and the instructions associated with the second instruction-stream by using a timing mechanism. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference>, further comprising: 
<claim-text>restoring information from a first memory address to the graphics-rendering engine, the information describing a first rendering context associated with the first independent image to be rendered by the single graphics-rendering engine, and storing the information describing a second rendering context associated with the second independent image to a second memory address, the second independent image being rendered by the single graphics-rendering engine. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference>, further comprising: 
<claim-text>displaying one or more images on the multiple display devices. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. A method, comprising: 
<claim-text>concurrently rendering independent images for display on multiple display devices with a graphics-rendering engine; </claim-text>
<claim-text>allocating time use of the graphics-rendering engine between each independent image being rendered; and </claim-text>
<claim-text>storing in a memory area and restoring from the memory area a first rendering context associated with a first independent image. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 23</dependent-claim-reference>, further comprising: 
<claim-text>determining whether a first register associated with a first independent image participates in an arbitration process to use the graphics-rendering engine. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 24</dependent-claim-reference>, further comprising: 
<claim-text>permitting, via a software instruction from a graphics application, the graphics-rendering engine to process instructions associated with a second image while waiting for an asynchronous event to occur to a first image. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 24</dependent-claim-reference>, further comprising: 
<claim-text>yielding time allotted to use the graphics-rendering engine for instructions associated with the first independent image over to instructions associated with a second independent image via a software instruction from a graphics application. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 23</dependent-claim-reference>, further comprising: 
<claim-text>defining the memory area by programmable content contained in a first register, the memory area dedicated to storing the instructions associated with a first instruction stream. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 23</dependent-claim-reference>, further comprising: 
<claim-text>establishing a time unit quanta in the timing circuit compatible with a first device operating at a first core frequency and compatible with a second device operating at a second core frequency, the first core frequency being different that the second core frequency. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00029">
<claim-text><highlight><bold>29</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 23</dependent-claim-reference>, further comprising: 
<claim-text>establishing a time unit quanta in the timing circuit compatible with a first device operating at first frequency and compatible with the first device operating at a second frequency. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00030">
<claim-text><highlight><bold>30</bold></highlight>. A system, comprising: 
<claim-text>a central processing unit; </claim-text>
<claim-text>a graphics device, the central processing unit coupled to the graphics device, the graphics device containing a graphics-rendering engine to concurrently render two or more independent images for display on multiple display devices, and </claim-text>
<claim-text>a time allocator to arbitrate the use of the graphics-rendering engine between the two or more independent images. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00031">
<claim-text><highlight><bold>31</bold></highlight>. The system of claim <highlight><bold>30</bold></highlight>, wherein the time allocator comprises: 
<claim-text>a plurality of registers including a first register, the first register having a plurality of fields, a first field to determine whether the first register participates in an arbitration process to use the graphics rendering engine, a second field to point to a memory location containing instructions from a first instruction stream. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00032">
<claim-text><highlight><bold>32</bold></highlight>. The system of claim <highlight><bold>31</bold></highlight>, wherein the time allocator further comprises: 
<claim-text>a first module to establish a programmable elapsed period of time to use the graphics-rendering engine.</claim-text>
</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>1</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030001847A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030001847A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030001847A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030001847A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030001847A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030001847A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030001847A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
