<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030004703A1-20030102-D00000.TIF SYSTEM "US20030004703A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030004703A1-20030102-D00001.TIF SYSTEM "US20030004703A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030004703A1-20030102-D00002.TIF SYSTEM "US20030004703A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030004703A1-20030102-D00003.TIF SYSTEM "US20030004703A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030004703A1-20030102-D00004.TIF SYSTEM "US20030004703A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030004703A1-20030102-D00005.TIF SYSTEM "US20030004703A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030004703A1-20030102-D00006.TIF SYSTEM "US20030004703A1-20030102-D00006.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030004703</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09895751</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010628</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F017/20</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>704</class>
<subclass>008000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Method and system for localizing a markup language document</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Arvind</given-name>
<family-name>Prabhakar</family-name>
</name>
<residence>
<residence-us>
<city>Mountain View</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Lawrence</given-name>
<family-name>White</family-name>
</name>
<residence>
<residence-us>
<city>Redwood City</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Kenneth</given-name>
<family-name>Ebbs</family-name>
</name>
<residence>
<residence-us>
<city>Los Altos</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>Wagner Murabito &amp; Hao LLP</name-1>
<name-2></name-2>
<address>
<address-1>Two North Market Street Third /Floor</address-1>
<city>San Jose</city>
<state>CA</state>
<postalcode>95113</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">Briefly, in accordance with one embodiment of the invention, a computer-implemented method for localizing a markup language document includes: identifying at least one token within a document and identifying a localizable string within the token. Creating a first file including a translation of the localizable string and a second file including the non-localizable data from the document. The first file and second file are then merged. </paragraph>
<paragraph id="A-0002" lvl="0">Briefly, in accordance with another embodiment of the invention, an article includes: a computer-readable medium including program instructions executable to: identify at least one token within the document and identify a localizable string within the token. Create a first file including a translation of at least one localizable string and a second file including non-localizable data from the document. The first file and second file are then merged. </paragraph>
<paragraph id="A-0003" lvl="0">Briefly, in accordance with still another embodiment of the invention, a first computer system including a processor and a memory storing program instructions. The processor is operable to execute the program instructions to: identify at least one token within the document and identify a localizable string within the token. Create a first file including a translation of at least one localizable string and a second file including non-localizable data from the document. The first file and second file are then merged. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">TECHNICAL FIELD </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> The present invention relates generally to data translation and more particularly to automating and customizing localization of markup language documents. </paragraph>
</section>
<section>
<heading lvl="1">BACKGROUND </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> When the development of electronic networks were mainly in the United States, there was little need for cultural-specific software components and translations. However, with the growth in the use of electronic networks, such as the Internet, the number of people attempting to distribute non-English content has grown substantially. As a result, the ability to provide localized content has become an important source of competitive advantage for companies competing in the global market place. In fact, any delays in providing a compatible version can potentially reduce market share in a certain country. It is therefore of critical importance to localize software quickly and in the most economical and efficient manner. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> Localization is the process of developing cultural-specific software components and translations that can be accessed by internationalized software at run time. For example, localization may involve the translation of embedded text into a target language as well as adapting software text and code to accommodate the customs and conventions of a new locale. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> Several software localization methods are known in the prior art. Some of these methods include several drawbacks that may be addressed by the present invention. For example, in some of these prior methods, localization is limited to translation of basic computer programs where all resource information (e.g., localizable strings) is separately stored in files, such as a resource dynamic link library (DLL), an executable binary file (.exe), or a plain ASCII text file. The executable object code, on the other hand, is located in at least one different and completely separate DLL. During the localization effort these prior methods, therefore, only require change in an identifiable resource file. Because markup language documents do not have a similar type of structure leading to rigid localization guidelines, the localization effort becomes more difficult. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> Specifically, in markup language documents such as Hypertext Markup Language (HTML), Extensible Markup Language (XML), and Java Server Pages&trade; (JSP), for example, a single definition of what is considered localizable is completely non-existent or, alternatively, extremely vague. Even assuming rules exist for one type of markup language document (e.g., HTML) such rules may not apply to other types of markup language documents (e.g., JSP or XML documents). Therefore, these prior localization methods, if used to localize markup language documents, would provide extremely detrimental results, if any at all, as well as be subject to significant translation errors resulting in loss of quality, time, and capital. Furthermore, these prior methods are extremely error prone, time consuming, redundant, and require exhaustive repetitiveness. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY </heading>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> Accordingly, a method and system for automating and customizing the localization of a markup language document while providing cost-savings, accuracy, flexibility, and efficiency is desired. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> Briefly, in accordance with one embodiment of the invention, a computer-implemented method for localizing a markup language document includes: identifying at least one token within a document and identifying a localizable string within the token. Creating a first file including a translation of the localizable string and a second file including the non-localizable data from the document. The first file and second file are then merged. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> Briefly, in accordance with another embodiment of the invention, an article includes: a computer-readable medium including program instructions executable to: identify at least one token within the document and identify a localizable string within the token. Create a first file including a translation of at least one localizable string and a second file including non-localizable data from the document. The first file and second file are then merged. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> Briefly, in accordance with still another embodiment of the invention, a first computer system including a processor and a memory storing program instructions. The processor is operable to execute the program instructions to: identify at least one token within the document and identify a localizable string within the token. Create a first file including a translation of at least one localizable string and a second file including non-localizable data from the document. The first file and second file are then merged.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> The subject matter regarded as the invention is particularly pointed out and distinctly claimed in the concluding portion of the specification. The invention, however, both as to organization and method of operation, may best be understood by reference to the following detailed description, when read with the accompanying drawings, in which: </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a flow chart of a system for localizing a computer program according to one embodiment of the present invention. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a flow chart including a sub-system for localizing a computer program according to one embodiment of the present invention. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a flow chart including another sub-system for localizing a computer program according to one embodiment of the present invention. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a flow chart including still another sub-system for localizing a computer program according to one embodiment of the present invention. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a flow chart including an implementation of a system for localizing a computer program in a computer-readable medium according to one embodiment of the present invention. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is a block diagram of a computer system in which the present invention may be embodied.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION </heading>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> In the following detailed description, numerous specific details are set forth in order to provide a thorough understanding of the invention. However, it will be understood by those skilled in the relevant art that the present invention may be practiced without these specific details. In other instances, well-known methods, procedures, and components have not been described in detail so as not to obscure the present invention. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> As previously described, localization is the process of adapting a product or computer program for a specific region or country, which is often referred to as a locale. Typically, localization is used for translating user interfaces and the supporting documentation of a product or computer program. A successfully localized product or computer program is one the appears to have been developed within the local culture. As a result, when developing products or computer programs designed for multiple locales, it is beneficial for developers and software localization teams to have a tool, such as the present invention, to aid in the localization effort. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> illustrates a flow chart diagram of the localization effort involved in the translation from one locale to another locale in accordance with one embodiment of the present invention. As shown in block <highlight><bold>110</bold></highlight>, a markup language document generally includes a sequence of characters or other symbols that are inserted at certain places in a text or word processing file to indicate how the file should look when it is printed or displayed or to describe the document&apos;s logical structure. Markup language documents can include documents such as Hypertext Markup Language (HTML), Extensible Markup Language (XML), and Java Server Pages&trade; (JSP), for example. In <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, block <highlight><bold>110</bold></highlight> illustrates a markup language document, that is localized by identifying at least one token within the markup language document, as shown in block <highlight><bold>120</bold></highlight>. A token is at least one string made up of one or more characters that follow a recognizable pattern, such as a set of strings that have been parsed from a larger set of strings given a set of predefined classification rules. Using these pre-defined classification rules, token factories, in a parent-child framework for example, identify tokens. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> For example, the pre-defined classification rules used by token factories to identify tokens can be based upon whether a string of characters, upon screening, is bounded or unbounded. A bounded string of characters refers to a string of characters that begin with an outermost delimiter &ldquo;&lt;&rdquo; and end with a corresponding outermost delimiter &ldquo;&gt;&rdquo;. As a result, any string of characters within delimiters that are within the outermost matching delimiters (e.g., nested delimiters) are not bounded. For example, in the string &ldquo;&lt;abc&equals;def ghi &equals;&lt;jkl&gt;mno &equals;pqr&gt;&rdquo; the string &ldquo;&lt;jkl&gt;&rdquo; does not qualify as bounded. Additionally, any nested delimiter must have a corresponding delimiter unless such delimiter is exempted (e.g., escaped) under a markup language construct rule (e.g., when the delimiter is within a comment). Examples of bounded strings include the following: </paragraph>
<paragraph id="P-0021" lvl="2"><number>&lsqb;0021&rsqb;</number> &lt;html&gt;</paragraph>
<paragraph id="P-0022" lvl="2"><number>&lsqb;0022&rsqb;</number> &lt;meta http-equiv&equals;&ldquo;Content-Type&rdquo; content&equals;&ldquo;text/html; charset&equals;iso-8859-1&rdquo;&gt;</paragraph>
<paragraph id="P-0023" lvl="2"><number>&lsqb;0023&rsqb;</number> &lt;meta name&equals;&ldquo;GENERATOR&rdquo; content&equals;&ldquo;Mozilla/4.75 &lsqb;en&rsqb; (Windows NT 5.0; U) &lsqb;Netscape&rsqb;&rdquo;&gt;</paragraph>
<paragraph id="P-0024" lvl="2"><number>&lsqb;0024&rsqb;</number> &lt;TD ALIGN&equals;RIGHT&gt;</paragraph>
<paragraph id="P-0025" lvl="2"><number>&lsqb;0025&rsqb;</number> &lt;x:HTML map&equals;&ldquo;com.iplanet.ecommerce.vortex.oms.display.JspTagMapping&rdquo;&gt;</paragraph>
<paragraph id="P-0026" lvl="2"><number>&lsqb;0026&rsqb;</number> &lt;%&commat; include file&equals;&ldquo;../include/OMSInclusionHeader.jsp&rdquo;%&gt;</paragraph>
<paragraph id="P-0027" lvl="2"><number>&lsqb;0027&rsqb;</number> &lt;% </paragraph>
<paragraph id="P-0028" lvl="3"><number>&lsqb;0028&rsqb;</number> String&lsqb; &rsqb; data&equals;bean.getStringValues(STATUS_DATA); </paragraph>
<paragraph id="P-0029" lvl="3"><number>&lsqb;0029&rsqb;</number> String&lsqb; &rsqb; values&equals;bean.getStringValues(STATUS_VALUES); </paragraph>
<paragraph id="P-0030" lvl="3"><number>&lsqb;0030&rsqb;</number> String&lsqb; &rsqb; selected&equals;bean.getStringValues(STATUS_SELECTED); </paragraph>
<paragraph id="P-0031" lvl="3"><number>&lsqb;0031&rsqb;</number> for (int i&equals;0; i&lt;data.length; i&plus;&plus;) </paragraph>
<paragraph id="P-0032" lvl="2"><number>&lsqb;0032&rsqb;</number> %&gE;</paragraph>
<paragraph id="P-0033" lvl="2"><number>&lsqb;0033&rsqb;</number> &lt;%&equals;bean.getStringValue(FILTER_BY DESC)%&gt;</paragraph>
<paragraph id="P-0034" lvl="2"><number>&lsqb;0034&rsqb;</number> &lt;A HREF&equals;&ldquo;&lt;%&equals;ordLinks&lsqb;i&rsqb;%&gt;&rdquo;&gt;</paragraph>
<paragraph id="P-0035" lvl="2"><number>&lsqb;0035&rsqb;</number> &lt;IMG SRC&equals;&ldquo;&lt;%&equals;&rdquo;/&commat; IMM_DOCROOT&commat;/images/buttons/&rdquo;&plus;FILE_PREFIX &plus;&ldquo;left.gif&rdquo;%&gt;&ldquo;BORDER&equals;&ldquo;0&rdquo;&gt;</paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> Alternatively, an unbounded string of characters refers to a string of characters that are not bounded. Specifically, in one embodiment, an unbounded string of characters refers to a string of characters that (a) begins either (i) at the first character of a markup language or (ii) immediately preceding a delimiter meeting the definition of a corresponding outermost delimiter &ldquo;&gt;&rdquo; of a bounded string of characters, and (b) ends either (i) at the last character of a markup language document or (ii) immediately preceding a delimiter meeting the definition of an outermost delimiter &ldquo;&lt;&rdquo; of a bounded string of characters. Additionally, there are instances when certain delimiters are exempted (e.g., escaped) under a markup language construct rule. For example, in the string&mdash;abcd &ldquo;&lt;efgh&gt;&rdquo; ijkl &mdash;, since the delimiters are within double quotes, these delimiters are exempted and the entire string is thus unbounded. Examples of unbounded strings include the following: </paragraph>
<paragraph id="P-0037" lvl="2"><number>&lsqb;0037&rsqb;</number> Profile Name:&amp;nbsp; </paragraph>
<paragraph id="P-0038" lvl="2"><number>&lsqb;0038&rsqb;</number> Welcome &ldquo;&lt;%&equals;getUserName( )%&gt;&rdquo; to our homepage </paragraph>
<paragraph id="P-0039" lvl="2"><number>&lsqb;0039&rsqb;</number> OMS: View Orders </paragraph>
<paragraph id="P-0040" lvl="2"><number>&lsqb;0040&rsqb;</number> Created Date:&amp;nbsp; </paragraph>
<paragraph id="P-0041" lvl="2"><number>&lsqb;0041&rsqb;</number> &amp;copy;Sun Microsystems, Inc. 2001 </paragraph>
<paragraph id="P-0042" lvl="2"><number>&lsqb;0042&rsqb;</number> Syntax:&amp;It;%&equals;bean.getDateValue(DF_CREEATION_DATE,SIMPLE_DATE_FORMAT_YEAR)% &amp;gt; </paragraph>
<paragraph id="P-0043" lvl="2"><number>&lsqb;0043&rsqb;</number> Syntax:&amp;It;A HREF&equals;&ldquo;javascript:BSSCPopup(&lsquo;Buyer.htm&rsquo;); </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> As stated previously, pre-defined classification rules, such as those above, are used by token factories to identify tokens. For example, a token consisting of various numeric strings may have been initially screened by a parent token factory using certain general pre-defined classification rules and further screened by a child token factory using more specific pre-defined classification rules, and so on. In this instance, the exemplary token may include strings, such as: </paragraph>
<paragraph id="P-0045" lvl="2"><number>&lsqb;0045&rsqb;</number> &ldquo;233 2343 2343&rdquo;</paragraph>
<paragraph id="P-0046" lvl="2"><number>&lsqb;0046&rsqb;</number> &ldquo;8.000034340e-19&rdquo;</paragraph>
<paragraph id="P-0047" lvl="2"><number>&lsqb;0047&rsqb;</number> &ldquo;234 &frac12;&rdquo;</paragraph>
<paragraph id="P-0048" lvl="7"><number>&lsqb;0048&rsqb;</number> To identify this exemplary token, a parent token factory utilized pre-defined classification rules, such as those described above with respect to unbounded strings, resulting in the identification of an &ldquo;unbounded&rdquo; token. This &ldquo;unbounded&rdquo; token is passed to a child token factory for either assignment, as described below, or further classification. In this particular instance, the &ldquo;unbounded&rdquo; token can be further classified by the child token factory, according to more specific pre-defined classification rules, as an &ldquo;unbounded numeric&rdquo; token. The specific pre-defined classification rules used to do so, for example, could have included the rules: (a) collect strings that consist only of numbers and/or white spaces and/or (b) collect stings that contain the characters &ldquo;.&rdquo;, &ldquo;e&rdquo;, &ldquo;&plus;&rdquo;, &ldquo;&plus;&rdquo;, and/or &ldquo;&minus;&rdquo;. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> After identification of at least one token is complete, the strings that require actual translation within the token are distinguished. This is accomplished by identifying at least one localizable string within the token, as shown in block <highlight><bold>130</bold></highlight>, based on pre-defined localization rules. Pre-defined localization rules can, for example, be managed and implemented by a token handler that specializes in parsing a given type of string (e.g., a bounded HTML string) to identify the exact portions of the string that may require translation. In one embodiment, a token handler is flexible in nature and allows for any rules and semantics to be added at any time by enhancing or modifying a token handler or with additional token handlers. The process of using the token handler begins, using one or more token factories to identify a particular token, as described above. In this example, the following strings comprise several exemplary &ldquo;bounded&rdquo; tokens: </paragraph>
<paragraph id="P-0050" lvl="2"><number>&lsqb;0050&rsqb;</number> &lt;a href&equals;&ldquo;xyz&rdquo;&gt;</paragraph>
<paragraph id="P-0051" lvl="2"><number>&lsqb;0051&rsqb;</number> &lt;a href&equals;&ldquo;zdf&rdquo; onMouseOver&equals;&ldquo;javascript:status(&lsquo;show this message&rsquo;)&rdquo;&gt;</paragraph>
<paragraph id="P-0052" lvl="2"><number>&lsqb;0052&rsqb;</number> &lt;a name&equals;&ldquo;someone&rdquo; value&equals;&ldquo;somevalue&rdquo; href&equals;&ldquo;dfdf&rdquo;&gt;</paragraph>
<paragraph id="P-0053" lvl="7"><number>&lsqb;0053&rsqb;</number> To identify these &ldquo;bounded&rdquo; tokens, a parent token factory utilizes a classification rule such as that described above regarding bounded strings. From this point, the &ldquo;bounded&rdquo; tokens are sent to a child token factory which determines whether such tokens should be passed to an all-purpose token handler or be further classified and passed to a specific token handler(s). In this particular instance, these &ldquo;bounded&rdquo; tokens can be further classified by the child token factory, according to more specific pre-defined classification rules, as a &ldquo;a-type bounded&rdquo; tokens. In order to now identify a localizable string(s) within any of the &ldquo;a-type bounded&rdquo; tokens, a token handler specific to these and similar types of tokens will parse each &ldquo;a-type bounded&rdquo; token, using predefined localization rules, to identify the exact portions of the strings, if any, that require translation. The pre-defined localization rules can include, for example, a rule or rules such as: (a) do not localize this type of token; (b) always localize the attribute name; (c) always localize everything that appears in double quotes; (d) always localize everything that appears in double quotes other than the strings that begin with &ldquo;javascript:&rdquo;; (e) always localize everything that appears in double quotes other than the strings that being with &ldquo;javascript:&rdquo; that should be parsed separately to identify any alert, confirm, or status messages which should be localized; and/or (f) if the identified string is made up of spaces, numbers, or special characters, do not localize. This flexible construct allows rules for identifying localizable strings that can range from extremely simple to extremely complex. Furthermore, modules such as hooks can further be provided to modify or extend the behavior of these token handlers. A hook is a place and usually an interface provided in packaged code that allows a programmer to insert customized programming. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> In one embodiment, it should also be understood that in the case a localizable string is not identified within a particular token or markup language document, the process immediately continues to the next token or markup language document, if any, to complete the localization effort for a set or group of tokens or markup language documents. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> In another embodiment control over, or interaction with, the identification of localizable strings within a token may be desired by a user. Interaction by a user is desired in cases of parsing complex tokens, such as multi-line JSP scriplet tokens, because it is extremely difficult and inefficient to create pre-defined localization rules that apply in every instance and situation. In other words, there may be ambiguous situations where the applicability of a localization rule is indeterminate or unclear to the token handler. As shown in block <highlight><bold>235</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, to remedy this ambiguous situation, the token handler will prompt the user to verify or confirm whether a particular string, or portions of a string, should be identified for localization. If confirmed by the user, the string is extracted from the markup language document for translation. If not confirmed by the user, the string is not extracted from the markup language document. In the event interaction is not desired (e.g., when localizing a large volume of documents at one time), the token handler identifies localizable strings based solely on the pre-defined localizable rules without prompting the user for confirmation or instruction. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> Referring back to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, once a localizable string within a token has been identified, the next steps include creating a first file (e.g., property file) including a translation of at least one localizable string, as shown in block <highlight><bold>140</bold></highlight>, as well as creating a second file (e.g., template file) including non-localizable data from the markup language document, as shown in block <highlight><bold>150</bold></highlight>. The first file, therefore, includes a list of translated localizable strings exacted from the markup language document in a readable format and indexed in an order corresponding to the place holder strings in the second file. The second file, therefore, includes of all the original markup language, or other similar constructs, with the exception of the identified localizable strings being replaced by indexed place holder strings. </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> Upon creation of the appropriate files, as shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, merging the first file and second file, as illustrated in block <highlight><bold>160</bold></highlight>, generates a localized markup language document, as shown in-block <highlight><bold>170</bold></highlight>, for the intended locale. Merging occurs when each string from the first file is combined with each corresponding indexed place holder string or &ldquo;slot&rdquo; in the second file left by the previous extraction of each localizable string. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> In an alternative embodiment, as shown in <cross-reference target="DRAWINGS">FIG. 3, a</cross-reference> third file (e.g., property file) including at least one original (non-translated) localizable string from a token within the markup language document is created, as shown in block <highlight><bold>355</bold></highlight>, based on identification by the token handler, as described above. The third file, therefore, includes a list of localizable strings extracted from the markup language document in a readable format and indexed in an order that corresponds to the place holder strings in the second file. This third file can further aid the localization effort. For example, the third file can aid localization by saving the original localizable string should no translation be available in the dictionary module. This will be explained in more detail below. Although the dictionary module contains translations between two languages in a language neutral manner, as described below, there may be instances where a particular translation is not available in the dictionary module because it was not initially anticipated, known, or intended to be included. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> As stated previously, the third file includes an original localizable string from the markup language document prior to translation. In cases where there is no available translation of a particular string for combination with the corresponding slot in the second file, the slot in the second file is combined with the corresponding original localizable string from the third file. As a result, merging of the first file and second file and third file, as shown in block <highlight><bold>360</bold></highlight> occurs. This may be desired, for example, when a user must localize a voluminous markup language document. In this circumstance, interaction, as explained above, may not be desired due to the potentially large quantity of confirmations, and thus time, that may be required. This non-interaction results in a token handler making localization decisions without input from a user and may result in the unintended localization of a string. For example, a particular localization rule may guide a token handler to identify a string, such as &ldquo;&lt;z d:rr&rdquo; to be localized from English to Japanese. Since such a string is made up of characters intended for execution by a computer, no localization of this string may be necessary or desired. Accordingly, in the dictionary module, there may not be an available translation for combination with the corresponding slot in the second file. The slot in the second file, therefore, is combined with the corresponding original localizable string from the third file. In this manner, the original string &ldquo;&lt;z d:rr&rdquo; is preserved and the code integrity within the markup language document is sustained. </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> This same effect can also be achieved with interaction by the user. Specifically, it can be achieved when, in ambiguous token handler situations, a user is prompted for confirmation of the identification of a localizable string and the user decides not to confirm that particular localization. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> As stated previously, translations are based on the dictionary module. The dictionary module contains pre-existing dictionary translations (e.g., &ldquo;hello&rdquo; in English is equivalent to &ldquo;bonjur&rdquo; in French and vice versa) and is preferably language neutral and XML based. Language neutrality allows for dynamic, two-way translations rather than only one-way translations. For example, language neutrality allows for translations from English to Japanese as well as from Japanese to English. The dictionary module further allows for the recordation of manual translations done by a user when localizing a document from one language to another. Specifically, as shown in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, if a particular translation is in question or unavailable within the dictionary module, a user may manually view the first file to validate a translation(s) provided by the dictionary module and/or edit or add appropriate user-supplied translation(s), as shown in block <highlight><bold>457</bold></highlight>. As a result, translations may contain a dictionary translation and/or user-supplied translation. Furthermore, during merging of the first file and second file the user-supplied translation is recorded, in a persistent store for example, within the dictionary module for use in future localization efforts, as shown in block <highlight><bold>465</bold></highlight>. Upon recordation, the user-supplied translation becomes a pre-existing dictionary translation for use in later runs. Accordingly, the dictionary module increases accuracy as well as the productivity of localization efforts. </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> It is further to be understood that in one embodiment, the process flow and features described above, could be accomplished entirely in a computer-readable medium without the use or need for separate files. Accordingly, <cross-reference target="DRAWINGS">FIG. 5</cross-reference> illustrates a flow chart diagram of the localization effort performed entirely in memory (e.g., a computer-readable medium) and involving localization from one locale to another locale. Specifically, blocks <highlight><bold>110</bold></highlight>-<highlight><bold>130</bold></highlight> represent the same process flow as previously described. However, block <highlight><bold>535</bold></highlight> illustrates extracting the-localizable string from the markup language document and block <highlight><bold>555</bold></highlight> illustrates extracting the non-localizable data from the markup language document. Rather than creating separate files, as described previously, the extracted strings are stored in a computer-readable medium. In between block <highlight><bold>535</bold></highlight> and block <highlight><bold>555</bold></highlight> is block <highlight><bold>545</bold></highlight> which shows the translation of at least one extracted localizable string from block <highlight><bold>535</bold></highlight>. This translated extracted localizable string is likewise stored in a computer-readable medium and can be viewed, edited, modified, and added to directly from the computer-readable medium. The next block in the process flow is block <highlight><bold>565</bold></highlight> where merging of the extracted non-localizable data with at least one of the translated extracted localizable string and the extracted localizable string takes place. Merging can also occur in a computer-readable medium, the result and output of which is a localized markup language document, as shown in block <highlight><bold>170</bold></highlight>. Here, either the translated extracted localizable string and/or the extracted localizable string is merged with the extracted non-localizable data based on interaction and translation factors, as described previously. All previous embodiments as described above can likewise be applied to this embodiment. </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> shows a hardware block diagram of a computer system <highlight><bold>600</bold></highlight> in which an embodiment of the invention may be implemented. Computer system <highlight><bold>600</bold></highlight> includes a bus <highlight><bold>602</bold></highlight> or other communication mechanism for communicating information, and a processor <highlight><bold>604</bold></highlight> coupled with bus <highlight><bold>602</bold></highlight> for processing information. Computer system <highlight><bold>600</bold></highlight> also includes a main memory <highlight><bold>606</bold></highlight>, such as random access memory (RAM) or other dynamic storage device, coupled to bus <highlight><bold>602</bold></highlight> for storing information and instructions by processor <highlight><bold>604</bold></highlight>. Main memory <highlight><bold>606</bold></highlight> may also be further used to store temporary variables or other intermediate information during execution of instructions by processor <highlight><bold>604</bold></highlight>. Computer system <highlight><bold>600</bold></highlight> further includes a read only memory (ROM) <highlight><bold>608</bold></highlight> or other static storage device coupled to bus <highlight><bold>602</bold></highlight> for storing static information and instructions for processor <highlight><bold>602</bold></highlight>. A storage device <highlight><bold>610</bold></highlight>, such as a magnetic or optical disk, is provided and coupled to bus <highlight><bold>602</bold></highlight> for storing information and instructions. </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> Computer system <highlight><bold>600</bold></highlight> may be coupled via bus <highlight><bold>602</bold></highlight> to a display <highlight><bold>612</bold></highlight>, such as a cathode ray tube (CRT), for displaying information to a computer user. An input device <highlight><bold>614</bold></highlight>, including alphanumeric and other keys, is coupled to bus <highlight><bold>602</bold></highlight> for communicating information and command selections to processor <highlight><bold>604</bold></highlight>. Another type of user input device is cursor control <highlight><bold>412</bold></highlight>, such as a mouse, a trackball, or cursor direction keys for communicating direction information and command selections to processor <highlight><bold>604</bold></highlight> and for controlling cursor movement on display <highlight><bold>612</bold></highlight>. This input device typically has two degrees of freedom in two axes, a first axis (e.g., x) and a second axis (e.g., y), that allows the device to specify positions in a plane. </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> According to one embodiment, the functionality of the present invention is provided by computer system <highlight><bold>600</bold></highlight> in response to processor <highlight><bold>604</bold></highlight> executing one or more sequences of one or more instructions contained in main memory <highlight><bold>606</bold></highlight>. Such instructions may be read into main memory <highlight><bold>606</bold></highlight> from another computer-readable medium, such as storage device <highlight><bold>610</bold></highlight>. Execution of the sequences of instructions contained in main memory <highlight><bold>606</bold></highlight> causes processor <highlight><bold>604</bold></highlight> to perform the process steps described herein. In alternative embodiments, hard-wired circuitry may be used in place of or in combination with software instructions to implement the invention. Thus, embodiments of the invention are not limited to any specific combination of hardware circuitry and software. </paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> The term &ldquo;computer-readable medium&rdquo; as used herein refers to any medium that participates in providing instructions to processor <highlight><bold>604</bold></highlight> for execution. Such a medium may take many forms, including but not limited to, non-volatile media, volatile media, and transmission media. Non-volatile media includes, for example, optical or magnetic disks, such as storage device <highlight><bold>610</bold></highlight>. Volatile media includes dynamic memory, such as main memory <highlight><bold>606</bold></highlight>. Transmission data includes coaxial cables, copper wire and fiber optics, including the wires that comprise bus <highlight><bold>602</bold></highlight>. Transmission media can also take the form of acoustic or electromagnetic waves, such as those generated during radio-wave, infra-red, and optical data communications. </paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> Common forms of computer-readable media include, for example, a floppy disk, a flexible disk, hard disk, magnetic tape, or any other magnetic medium, a CD-ROM, any other optical medium, punchcards, papertape, any other physical medium with patterns of holes, a RAM, a PROM, and EPROM, a FLASH-EPROM, any other memory chip or cartridge, a carrier wave as described hereinafter, or any other medium from which a computer can read. </paragraph>
<paragraph id="P-0068" lvl="0"><number>&lsqb;0068&rsqb;</number> Various forms of computer-readable media may be involved in carrying one or more sequences of instructions to processor <highlight><bold>604</bold></highlight> for execution. For example, the instructions may initially be carried on a magnetic disk of a remote computer. The remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system <highlight><bold>600</bold></highlight> can receive the data on the telephone line and use an infra-red transmitter to convert the data to an infra-red signal. An infra-red detector can receive the data carried in the infra-red signal and appropriate circuitry can place the data on bus <highlight><bold>602</bold></highlight>. Bus <highlight><bold>604</bold></highlight> carries the data to main memory <highlight><bold>606</bold></highlight>, for which processor <highlight><bold>604</bold></highlight> retrieves and executes the instructions. The instructions received by main memory <highlight><bold>606</bold></highlight> may optionally be stored on storage device <highlight><bold>610</bold></highlight> either before or after execution by processor <highlight><bold>604</bold></highlight>. </paragraph>
<paragraph id="P-0069" lvl="0"><number>&lsqb;0069&rsqb;</number> Computer system <highlight><bold>600</bold></highlight> also includes a communication interface <highlight><bold>618</bold></highlight> coupled to bus <highlight><bold>602</bold></highlight>. Communication interface <highlight><bold>618</bold></highlight> provides a two-way data communication coupling to a network link <highlight><bold>620</bold></highlight> that is connected to a local network <highlight><bold>622</bold></highlight>. For example, communication interface <highlight><bold>618</bold></highlight> may be an integrated services digital network (ISDN) card or a modem to provide a data communication connection to a corresponding type of telephone line. As another example, communication interface <highlight><bold>618</bold></highlight> may be a local area network (LAN) card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation, communication interface <highlight><bold>618</bold></highlight> sends and receives electrical, electromagnetic or optical signals that carry digital data streams representing various types of information. </paragraph>
<paragraph id="P-0070" lvl="0"><number>&lsqb;0070&rsqb;</number> Network link <highlight><bold>620</bold></highlight> typically provides data communication through one or more networks to other data devices. For example, network link <highlight><bold>620</bold></highlight> may provide a connection through local network <highlight><bold>622</bold></highlight> to a host computer <highlight><bold>624</bold></highlight> or to data equipment operated by an Internet Service Provider (ISP) <highlight><bold>626</bold></highlight>. ISP <highlight><bold>626</bold></highlight> in turn provides data communication services through the world wide packet data communication network now commonly referred to as the &ldquo;Internet&rdquo; <highlight><bold>628</bold></highlight>. Local network <highlight><bold>622</bold></highlight> and Internet <highlight><bold>628</bold></highlight> both use electrical, electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link <highlight><bold>620</bold></highlight> and through communication interface <highlight><bold>618</bold></highlight>, which carry the digital data to and from computer system <highlight><bold>600</bold></highlight>, are exemplary forms of carrier waves transporting the information. </paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> Computer system <highlight><bold>600</bold></highlight> can send messages and receive data, including program code, through the network(s), network link <highlight><bold>620</bold></highlight> and communication interface <highlight><bold>618</bold></highlight>. In the Internet example, a server <highlight><bold>630</bold></highlight> might transmit a requested code for an application program through Internet <highlight><bold>628</bold></highlight>, ISP <highlight><bold>626</bold></highlight>, local network <highlight><bold>622</bold></highlight> and communication interface <highlight><bold>618</bold></highlight>. The received code may be executed by processor <highlight><bold>604</bold></highlight> as it is received, and/or stored in storage device <highlight><bold>610</bold></highlight>, or other non-volatile storage for later execution. In this manner, computer system <highlight><bold>600</bold></highlight> may obtain application code in the form of a carrier wave. </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> At this point, it should be noted that although the invention has been described with reference to a specific embodiment, it should not be construed to be so limited. Various modifications may be made by those of ordinary skill in the art with the benefit of this disclosure without departing from the spirit of the invention. Thus, the invention should not be limited by the specific embodiments used to illustrate it but only by the scope of the appended claims. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A computer-implemented method for localizing a markup language document, comprising: 
<claim-text>identifying at least one token within said document; </claim-text>
<claim-text>identifying a localizable string within said token; </claim-text>
<claim-text>creating a first file including a translation of at least one said localizable string; </claim-text>
<claim-text>creating a second file including non-localizable data from said document; and </claim-text>
<claim-text>merging said first file and said second file. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> further comprising, prompting a user for confirmation of said identifying at least one localizable string </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> further comprising, creating a third file including at least one said localizable string. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference> wherein said merging includes merging said third file. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> further comprising, editing said first file to provide a user-supplied translation. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference> wherein said merging further includes recording said user-supplied translation within said first file into a dictionary module. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein said translation includes at least one of a dictionary translation and a user-supplied translation. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein said identifying at least one token includes screening a string of characters within said document to determine whether said string of characters is at least one of bounded and unbounded. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein said localizable string includes at least one of data and executable code. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. A computer-readable medium comprising program instructions executable to: 
<claim-text>identify at least one token within said document; </claim-text>
<claim-text>identify a localizable string within said token; </claim-text>
<claim-text>create a first file including a translation of at least one said localizable string; </claim-text>
<claim-text>create a second file including non-localizable data from said document; and </claim-text>
<claim-text>merge said first file and said second file. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, further comprising program instructions executable to prompt a user for confirmation of said identify at least one localizable string. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, further comprising program instructions executable to create a third file including at least one said localizable string. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, wherein said merge includes merging said third file. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, further comprising program instructions executable to edit said first file to provide a user-supplied translation. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference>, where in said merging further includes recording said user-supplied translation within said first file into a dictionary module. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein said translation includes at least one of a dictionary translation and a user-supplied translation. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein said identifying at least one token includes screening a string of characters within said document to determine whether said string of characters is at least one of bounded and unbounded. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein said localizable string includes at least one of data and executable code. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. A first computer system comprising: 
<claim-text>a processor; </claim-text>
<claim-text>a memory storing program instructions; </claim-text>
<claim-text>wherein the processor is operable to execute the program instructions to: 
<claim-text>identify at least one token within said document; </claim-text>
<claim-text>identify a localizable string within said token; </claim-text>
<claim-text>create a first file including a translation of at least one said localizable string; </claim-text>
<claim-text>create a second file including non-localizable data from said document; and </claim-text>
<claim-text>merge said first file with said second file. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference>, further comprising program instructions executable to prompt a user for confirmation of said identify at least one localizable string. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference>, further comprising program instructions executable to create a third file including at least one said localizable string. </claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference>, wherein said merge includes merging said third file. </claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference> further comprising program instructions executable to edit said first file to provide a user-supplied translation. </claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00022">claim 23</dependent-claim-reference>, wherein said merging further includes recording said user-supplied translation within said first file into a dictionary module. </claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference>, wherein said translation includes at least one of a dictionary translation and a user-supplied translation. </claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference> wherein said identifying at least one token includes screening a string of characters within said document to determine whether said string of characters is at least one of bounded and unbounded. </claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference>, wherein said localizable string includes at least one of data and executable code. </claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. A computer-implemented method for localizing a markup language document, comprising: 
<claim-text>identifying at least one token within said document; </claim-text>
<claim-text>identifying a localizable string within said token; </claim-text>
<claim-text>extracting said localizable string from said document; </claim-text>
<claim-text>translating at least one said extracted localizable string; </claim-text>
<claim-text>extracting non-localizable data from said document; and </claim-text>
<claim-text>merging said extracted non-localizable data with at least one of said translated extracted localizable string and said extracted localizable string. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00029">
<claim-text><highlight><bold>29</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 28</dependent-claim-reference> further comprising, prompting a user for confirmation of said identifying a localizable string. </claim-text>
</claim>
<claim id="CLM-00030">
<claim-text><highlight><bold>30</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 28</dependent-claim-reference> further comprising, editing said translated extracted localizable string to provide a user-supplied translation. </claim-text>
</claim>
<claim id="CLM-00031">
<claim-text><highlight><bold>31</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00033">claim 30</dependent-claim-reference> wherein said merging further includes recording said user-supplied translation within a dictionary module. </claim-text>
</claim>
<claim id="CLM-00032">
<claim-text><highlight><bold>32</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 28</dependent-claim-reference> wherein said translating utilizes at least one of a dictionary translation and a user-supplied translation. </claim-text>
</claim>
<claim id="CLM-00033">
<claim-text><highlight><bold>33</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 28</dependent-claim-reference> wherein said identifying at least one token includes screening a string of characters within said document to determine whether said string of characters is at least one of bounded and unbounded. </claim-text>
</claim>
<claim id="CLM-00034">
<claim-text><highlight><bold>34</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 28</dependent-claim-reference> wherein said localizable string includes at least one of data and executable code. </claim-text>
</claim>
<claim id="CLM-00035">
<claim-text><highlight><bold>35</bold></highlight>. A computer-readable medium comprising program instructions executable to: 
<claim-text>identify at least one token within said document; </claim-text>
<claim-text>identify a localizable string within said token; </claim-text>
<claim-text>extract said localizable string from said document; </claim-text>
<claim-text>translate at least one said extracted localizable string; </claim-text>
<claim-text>extract non-localizable data from said document; and </claim-text>
<claim-text>merge said extracted non-localizable data with at least one of said translated extracted localizable string and said extracted localizable string. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00036">
<claim-text><highlight><bold>36</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00033">claim 35</dependent-claim-reference> further comprising program instructions executable to prompt a user for confirmation of said identify a localizable string. </claim-text>
</claim>
<claim id="CLM-00037">
<claim-text><highlight><bold>37</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00033">claim 35</dependent-claim-reference> further comprising program instructions executable to edit said translated extracted localizable string to provide a user-supplied translation. </claim-text>
</claim>
<claim id="CLM-00038">
<claim-text><highlight><bold>38</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00033">claim 37</dependent-claim-reference> wherein said merge further includes recording said user-supplied translation within a dictionary module. </claim-text>
</claim>
<claim id="CLM-00039">
<claim-text><highlight><bold>39</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00033">claim 35</dependent-claim-reference> wherein said translate utilizes at least one of a dictionary translation and a user-supplied translation. </claim-text>
</claim>
<claim id="CLM-00040">
<claim-text><highlight><bold>40</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00033">claim 35</dependent-claim-reference> wherein said identifying at least one token includes screening a string of characters within said document to determine whether said string of characters is at least one of bounded and unbounded. </claim-text>
</claim>
<claim id="CLM-00041">
<claim-text><highlight><bold>41</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00033">claim 35</dependent-claim-reference> wherein said localizable string includes at least one of data and executable code. </claim-text>
</claim>
<claim id="CLM-00042">
<claim-text><highlight><bold>42</bold></highlight>. A first computer system comprising: 
<claim-text>a processor; </claim-text>
<claim-text>a memory storing program instructions; </claim-text>
<claim-text>wherein the processor is operable to execute the program instructions to: 
<claim-text>identify at least one token within said document; </claim-text>
<claim-text>identify a localizable string within said token; </claim-text>
<claim-text>extract said localizable string from said document; </claim-text>
<claim-text>translate at least one said extracted localizable string; </claim-text>
<claim-text>extract non-localizable data from said document; and </claim-text>
<claim-text>merge said extracted non-localizable data with at least one of said translated extracted localizable string and said extracted localizable string. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00043">
<claim-text><highlight><bold>43</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00044">claim 42</dependent-claim-reference> further comprising program instructions executable to prompt a user for confirmation of said identify a localizable string. </claim-text>
</claim>
<claim id="CLM-00044">
<claim-text><highlight><bold>44</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00044">claim 42</dependent-claim-reference> further comprising program instructions executable to edit said translated extracted localizable string to provide a user-supplied translation. </claim-text>
</claim>
<claim id="CLM-00045">
<claim-text><highlight><bold>45</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00044">claim 44</dependent-claim-reference> wherein said merge further includes recording said user-supplied translation within a dictionary module. </claim-text>
</claim>
<claim id="CLM-00046">
<claim-text><highlight><bold>46</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00044">claim 42</dependent-claim-reference> wherein said translate utilizes at least one of a dictionary translation and a user-supplied translation. </claim-text>
</claim>
<claim id="CLM-00047">
<claim-text><highlight><bold>47</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00044">claim 42</dependent-claim-reference> wherein said identifying at least one token includes screening a string of characters within said document to determine whether said string of characters is at least one of bounded and unbounded. </claim-text>
</claim>
<claim id="CLM-00048">
<claim-text><highlight><bold>48</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00044">claim 42</dependent-claim-reference> wherein said localizable string includes at least one of data and executable code.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>1</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030004703A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030004703A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030004703A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030004703A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030004703A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030004703A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030004703A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
