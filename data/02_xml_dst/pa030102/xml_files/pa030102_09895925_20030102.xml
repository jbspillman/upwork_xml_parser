<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005276A1-20030102-D00000.TIF SYSTEM "US20030005276A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005276A1-20030102-D00001.TIF SYSTEM "US20030005276A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005276A1-20030102-D00002.TIF SYSTEM "US20030005276A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005276A1-20030102-D00003.TIF SYSTEM "US20030005276A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005276A1-20030102-D00004.TIF SYSTEM "US20030005276A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005276A1-20030102-D00005.TIF SYSTEM "US20030005276A1-20030102-D00005.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005276</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09895925</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010628</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F015/177</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>713</class>
<subclass>002000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Method and system for booting of a target device in a network environment based on automatic client discovery and scan</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Steven</given-name>
<middle-name>M.</middle-name>
<family-name>French</family-name>
</name>
<residence>
<residence-us>
<city>Austin</city>
<state>TX</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Javier</given-name>
<middle-name>A.</middle-name>
<family-name>Guajardo</family-name>
<name-suffix>JR.</name-suffix>
</name>
<residence>
<residence-us>
<city>Austin</city>
<state>TX</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Chakkalamattam</given-name>
<middle-name>J.</middle-name>
<family-name>Paul</family-name>
</name>
<residence>
<residence-us>
<city>Austin</city>
<state>TX</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Marc-Arthur</given-name>
<family-name>Pierre-Louis</family-name>
</name>
<residence>
<residence-us>
<city>Round Rock</city>
<state>TX</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Bradford</given-name>
<middle-name>A.</middle-name>
<family-name>Stern</family-name>
</name>
<residence>
<residence-us>
<city>Austin</city>
<state>TX</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<assignee>
<organization-name>IBM CORPORATION</organization-name>
<assignee-type>02</assignee-type>
</assignee>
<correspondence-address>
<name-1>Frank C. Nicholas</name-1>
<name-2>CARDINAL LAW GROUP</name-2>
<address>
<address-1>Suite 2000</address-1>
<address-2>1603 Orrington Avenue</address-2>
<city>Evanston</city>
<state>IL</state>
<postalcode>60201</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A method of booting a plurality of target devices in communication with a network based on at least one target device definition is provided. A server in communication with the plurality of target devices receives a request for a boot file from at least one target device. A boot server in communication with the plurality of target devices is contacted. The boot server determines if the target device is defined. If the target device is not defined, the target device definition for the target device is created at the boot server. A bootstrap is executed at the target device, the bootstrap corresponding to the target definition. Systems and programs for using the method are also provided. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> 1. Field Of The Invention </paragraph>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> The present invention relates to the remote booting of target client computing devices (&ldquo;clients&rdquo;) where the software that makes the clients fully operational for an end-user is obtained through a computer communications network (&ldquo;a network&rdquo;). This software is obtained during the boot process through the client&apos;s network interface from server computing devices (&ldquo;boot servers&rdquo;) that are repositories of that software. In particular, the present invention relates to the situation where clients that are composed of different sets of hardware components are introduced onto the network. Each unique set of client hardware components may require a unique set of software (i.e. a unique &ldquo;client software definition&rdquo;) to be transferred from the boot server to the client in order to boot the client successfully. The present invention provides a means for automatically constructing such a client software definition when clients are introduced onto the network. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> 2. Description Of The Related Art </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> A boot process on a client (or any computing device) is defined as a sequence of program instructions that begins automatically when the client is powered-on or reset and completes when an end-user software environment is operational on the client. The initial instructions that are executed in a boot process are fixed in the nonvolatile read-only memory (&ldquo;ROM&rdquo;) of the hardware of the client so that they are always available to the client, even if it was previously shut off. As the boot process progresses, program instructions are located on a source outside of the client&apos;s ROM and copied, or loaded, into the client&apos;s volatile memory, also referred to as dynamic or random access memory (&ldquo;RAM&rdquo;). These instructions in RAM, referred to as software, are lost whenever the client is shut off or reset and therefore must be restored from an outside source during the boot process. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> Once this software has been loaded into RAM, client execution is transferred from ROM memory to this software in RAM. This software continues the boot process by iteratively locating and loading additional software into the client&apos;s RAM as required until the end-user software environment is complete and operational. Typically, this end-user software environment contains an operating system (&ldquo;OS&rdquo;) that does the general operation of the hardware of the client. This end-user software environment may also contain additional system programs to operate specialty hardware on the client and application programs that perform the end-user operations on the client as defined by the enterprise that owns the client. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> Some clients are configured with ROM that contains instructions that direct the boot process to obtain software through the client&apos;s network interface. This is distinguished from the instructions contained in the ROM of &ldquo;stand-alone&rdquo; clients that direct the boot process to obtain the software to establish the end-user software environment only from nonvolatile media repositories contained in devices that are directly attached to the client, such as diskettes, hard disks, and CD-ROMs. A remote boot process allows end-user software environments to be created, located and maintained in a repository on a centrally located boot server. This represents a significant savings of administrative effort when compared with having to perform the same activities at each separate client location. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> The instructions that direct the boot process to the network interface may be included in the client&apos;s Basic Input-Output System (&ldquo;BIOS&rdquo;) ROM that contains the initial instructions to be executed after the client is started or reset. The instructions that direct the boot process in the network interface may also be contained in a separate, or &ldquo;option&rdquo; ROM attached to the network interface. The client&apos;s BIOS ROM can be configured to transfer client execution to the option ROM after the initial boot instructions in the BIOS ROM have completed. This network interface and its option ROM may be integrated into the client&apos;s main system board (&ldquo;motherboard&rdquo;) or placed on a separate hardware communications adapter that is connected to the client&apos;s motherboard. Another alternative remote boot configuration is to have the BIOS ROM load and transfer execution to software in RAM that emulates the instructions of a remote boot option ROM. Such remote boot emulation software can be obtained from media of a local device, such as a diskette, and permits clients to be remote booted even when their network interface hardware cannot contain an option ROM for that purpose. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> Once the remote boot instructions in the BIOS ROM, option ROM, or remote boot emulation software begin to execute, they must initialize the network interface hardware so that it can send and receive signals on the network to which it is attached. This is accomplished through a series of well-known directives to that hardware. Then, the remote boot instructions must initiate and support network protocols that permit the client to announce itself to potential boot servers on the network as a client that requires a remote boot. These network protocols must also permit the client and a boot server to determine each other&apos;s network addresses so that they can direct network communications to each other. Finally, these network protocols must assure the accurate delivery of software and other information through the network between the boot server and the client. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> Two sets of network protocols have become widely used for remote booting of clients on networks today. One set is called Remote Program Load or Remote Initial Program Load (&ldquo;RPL&rdquo; or &ldquo;RIPL&rdquo;). This older set of network protocols is associated with Local Area Networks (&ldquo;LANs&rdquo;) and is primarily used when the boot servers and the remote boot clients are attached to the same LAN. Generally, this requires that the boot servers and the remote boot clients be physically located close to each other. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> A RPL client initiates the network boot process by transmitting a special broadcast frame on the LAN that indicates the unique media access control (&ldquo;MAC&rdquo;) identifier of the client&apos;s network interface hardware as its source and indicates that the client requires a RPL boot. As a broadcast, this special frame contains a unique, well-known destination MAC identifier that indicates that any other computing device (&ldquo;host&rdquo;) attached to the LAN can receive the frame. This includes any hosts that are boot servers. This broadcast frame with its well-known destination MAC identifier frees the remote boot client from the &ldquo;chicken and egg&rdquo; problem of having to initially know the destination MAC identifier of a particular boot server to get the remote boot process started. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> A boot server responds to the receipt of this broadcast frame by looking up the remote boot client&apos;s MAC identifier as a key to a record that describes the required software for the client. This record is contained in a file that lists the records of all potential remote boot clients that the boot server may service. This record indicates the name of a file on a loading device (for instance a hard disk) attached to the boot server that contains an initial network bootstrap program (an &ldquo;initial NBP&rdquo;) that is to operate on the client. The RPL map file record also contains other configuration data about the client to aid in remote booting the client. The file containing the initial NBP is loaded from the loading device and transmitted on the LAN to the client as a frame or series of frames that indicate the client&apos;s MAC address as the destination. The RPL process re-directs the loaded initial NBP file to the boot server&apos;s network interface for transmission to the client instead of writing it to the boot server&apos;s own RAM. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> Once it is transferred to the client, this initial NBP becomes the first software loaded into the client&apos;s RAM. RPL also provides a means for running this initial NBP on the client. This initial NBP initializes and restarts the client&apos;s network interface. It also retains the MAC identifier of the boot server as a destination for possible later requests. The initial NBP may be a complete end-user software environment, or a program that requests other files from the boot server in order to assemble an end-user software environment on the client. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> The other, newer set of network protocols are built upon the underlying Internet Protocol (IP) that forms the basis for the Internet and other Telecommunications Control Protocol/Internet Protocol (&ldquo;TCP/IP&rdquo;) wide area networks (&ldquo;WANs&rdquo;). As the name &ldquo;wide area network&rdquo; implies, this set of protocols permits boot servers and remote boot clients to be physically located far from each other. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> An early protocol used for remote boot in IP networks is the &ldquo;Bootstrap Protocol&rdquo; (&ldquo;BOOTP&rdquo;). BOOTP generally requires that the boot server and the remote boot clients be located on the same IP address sub-network, and as such gives little additional capability over RPL. BOOTP also requires that each remote boot client be pre-listed in a table on the boot server and assigned a fixed IP address in order to permit it to be booted. The client initiates the BOOTP protocol by broadcasting a BOOTP Request packet that indicates the MAC identifier of the client as the source and indicates an IP broadcast address as the destination. Again, this solves the &ldquo;chicken and egg&rdquo; problem in a manner similar to RPL so that the client does not initially need to know the address of a boot server, except that the broadcast address used is an IP address, not a MAC identifier. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> When a boot server receives the BOOTP Request packet, it looks for a record with the client&apos;s MAC identifier in its table of clients. If the boot server finds a record for that MAC identifier in the table, the boot server sends a BOOTP Response packet to the client that contains the IP address that is assigned to the client and the name of a file containing an initial NBP that is to be requested by the client. This information is maintained in the client&apos;s record on the boot server. The BOOTP Response packet also contains the IP address of the boot server. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> When the client receives the BOOTP Response packet, the program instructions in the client&apos;s ROM saves the client&apos;s assigned IP address, the IP address of the boot server, and the name of the initial NBP file. The program instructions in the client&apos;s ROM then send a Trivial File Transport Protocol (TFTP) Request packet to the IP address of the boot server that requests the file containing the initial NBP. The boot server responds by sending TFTP Data packet(s) that contain the initial NBP. The initial NBP is written into the client&apos;s RAM. Once the initial NBP is received, the client&apos;s ROM transfers the client&apos;s execution to the initial NBP. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> A newer set of IP protocols, collectively called the Preboot Execution Environment (&ldquo;PXE&rdquo;) as described by Intel&reg; Corporation in the <highlight><italic>Preboot Execution Environment </italic></highlight>(<highlight><italic>PXE</italic></highlight>) <highlight><italic>Specification Version </italic></highlight>2.1, has been developed to provide more flexibility than is available with BOOTP. PXE uses a follow-on protocol to BOOTP called the Dynamic Host Configuration Protocol (&ldquo;DHCP&rdquo;) that permits much more flexibility and capability in configuring clients (hosts) on the network. This includes the dynamic assignment of IP addresses to clients that may or may not have been pre-listed on the boot server or any other server. PXE also defines other protocols based on extensions permitted in the format of DHCP network messages that can be used to identify the architecture of a remote boot client, to indicate to boot servers that the client is PXE enabled, and to direct the client to the address of a boot server that could be located anywhere in the world. PXE permits each of the following services used to remote boot a client to exist on a separate server machine, permitting greater server configuration flexibility to support client remote boot as well as other client and user support activities simultaneously: </paragraph>
<paragraph id="P-0018" lvl="2"><number>&lsqb;0018&rsqb;</number> The DHCP service that assigns an IP address to a client. </paragraph>
<paragraph id="P-0019" lvl="2"><number>&lsqb;0019&rsqb;</number> The Proxy DHCP service that directs the client to a BINL or Boot service. </paragraph>
<paragraph id="P-0020" lvl="2"><number>&lsqb;0020&rsqb;</number> The Binary Image Negotiation Layer (BINL) or Boot service that directs the client to a boot server operating a TFTP service, and that provides the name of the initial NBP file to request. </paragraph>
<paragraph id="P-0021" lvl="2"><number>&lsqb;0021&rsqb;</number> The TFTP service that delivers the initial NBP file to the client. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> PXE also defines a set of remote boot support criteria that must be present in the BIOS ROM, option ROM, or option ROM emulation software of the client, including an application program interface (&ldquo;API&rdquo;) that permits the initial software loaded into the client&apos;s RAM to make requests for additional software and data to permit the remote boot process to complete. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> The RPL, BOOTP, or PXE remote boot process described above may do more than load software into the client&apos;s RAM, depending on the end-user software environment that is defined for the client. More software may be required than can be placed simultaneously in the client&apos;s RAM so that some of it has to be stored on nonvolatile local media (such as a hard disk) so that it can be retrieved when it is needed. It may be desirable for the client to store some, or all, of the end-user software environment to nonvolatile local media (such as a hard disk) so that the client will later have the ability to be booted locally. In such cases, some, or all, of the user software environment is &ldquo;remote installed&rdquo; on the client in addition to being remote booted on the client. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> An important feature of the RPL, BOOTP, or PXE remote boot process is that the specifications of these processes do not place limits on the function of the initial NBP or any of the other software that is remote booted or remote installed to the target client. This permits that software to perform functions in addition to remote boot or remote install of a previously defined client software environment. One possibility is that such software may be used to discover and scan information about the hardware configuration of the client and report it back to the boot server. The boot server could then use this information to create or update the client software definition so that it matches the hardware configuration of the client before it is transferred to the client. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> Present implementations of the remote boot or remote install processes described above require that the client software environment(s) be completely defined prior to the initiation of the remote boot of each client. A number of variations of this are available: </paragraph>
<paragraph id="P-0026" lvl="2"><number>&lsqb;0026&rsqb;</number> A single default client software environment may be defined for all remote boot clients. This may work if all clients have the same hardware configuration, but may not work as well when there are a variety of such clients connected to the network. </paragraph>
<paragraph id="P-0027" lvl="2"><number>&lsqb;0027&rsqb;</number> A limited set of alternate default client software environments may be defined. A selection menu is provided to the end-user of the client so that one of the default client software environments may be selected. This provides a limited selection of client software environments that may not reflect entire variety of clients connected to the network. Also, this method requires user intervention to complete the client remote boot process, and the user may not select the appropriate software environment for the client. </paragraph>
<paragraph id="P-0028" lvl="2"><number>&lsqb;0028&rsqb;</number> The system administrator may define a specific software environment for each client. The administrator must assume or require perfect knowledge of each target client&apos;s hardware configuration. This may be quite difficult, particularly for networks that implement PXE where the clients may be widely scattered. Also, this set of specific software environments is difficult to maintain if the set of remote boot clients changes frequently and/or the hardware configurations of individual clients can change frequently. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> These present implementations of the remote boot or remote install processes also make it difficult to implement system-wide policies governing the software environments of clients. For instance, such a policy might be to install Microsoft&reg; Windows NT&trade; on all machines of a first type (e.g., all IBM&reg; PC 300PL systems with more than 64 MB RAM), Microsoft Windows 2000&trade;on all machines of a second type (e.g., all desktops with more than 128 MB RAM), and Microsoft Windows&trade; 98 on all machines of a third type (e.g., all laptops). Additionally, it may be difficult to install a large number of machines efficiently without user or administrator intervention. For example, in the above scenario, a system administrator might be reduced to manually defining each target device by MAC address to the management system in order to achieve the described system-wide policy. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> It would be desirable therefore to provide a method of remote booting a target client in a network environment that permits the client software environment of each individual client to be created, selected, or updated at client remote boot time based on client discovery and hardware inventory scan that is performed on the client as part of that remote boot process. The results of the client and hardware inventory scan could be reported back to the server, where those results are used as input to the client software environment definition process. This would result in the appropriate client software environment for the client as defined by the client&apos;s hardware and/or any system policies governing that hardware. This appropriate client software environment would then be transferred to the client during the remainder of the client remote boot process. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> One aspect of the present invention provides a method of booting a plurality of target devices in communication with a network based on at least one target device definition. A request for a boot file from at least one target device is received. A boot server in communication with the plurality of target devices is contacted. The boot server may determine if the target device is defined. If the target device is not defined, the target device definition for the target device is created at the boot server. A bootstrap is executed at the target device, the bootstrap corresponding to the target device definition. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> The target device may be scanned for at least one hardware configuration. The target device may be scanned for at least one software configuration. An architecture of the target device may be determined. At least one network policy for the target device may be determined. The target device definition may be created based on one or a combination of: the hardware configuration, the software configuration, the architecture and the network policy. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> At least one request for a configuration file may be received from the target device. The configuration file may be transferred to the target device. The target device definition may be stored. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> Another aspect of the present invention provides a method of booting a target device in communication with a network based on at least one target device definition. A boot server in communication with the network may determine if the target device has an associated target-device specific configuration file. If the device does not have the associated target-device specific configuration file, an architecture-based configuration file is transferred to the target device. A boot report is received from the target device. At least one network policy-based configuration file is transferred to the target device. The target device definition is created based on the architecture-based configuration file, the boot report and the network policy-based configuration file. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> The boot report may be based on a hardware scan or software scan of the target device. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> Receipt of the boot report may be acknowledged at the boot server. At least one request for an additional architecture-based configuration file may be received from the target device. The additional architecture-based configuration file may be transferred to the target device. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> The target device definition may be stored. The target device may be rebooted based on the target device definition. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> Another aspect of the present invention provides computer program product in a computer usable medium for booting a plurality of target devices in communication with a network based on at least one target device definition. The program comprises means for determining, at a boot server in communication with the network, if the target device has an associated target device specific configuration file. If the device does not have the associated target-device specific configuration file, the program comprises means for transferring an architecture-based configuration file to the target device, means for receiving, at the boot server, a boot report from the target device, means for transferring at least one network policy-based configuration file to the target device; and means for creating the target device definition based on the architecture-based configuration file, the boot report and the network policy-based configuration file. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> The program may also comprise means for creating the boot report based on a hardware scan or a software scan of the target device. The program may also comprise means for acknowledging receipt of the boot report at the boot server. The program may also comprise means for receiving at least one request for an additional architecture-based configuration file from the target device. The program may also comprise means for transferring the additional architecture-based configuration file to the target device. The program may also comprise means for storing the target device definition. The program may also comprise means for re-booting the target device based on the target device definition. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> Another aspect of the present invention provides a system for booting a plurality of target devices in communication with a network based on at least one target device definition. The system comprises means for determining, at a boot server in communication with the network, if the target device has an associated target-device specific configuration file. If the device does not have the associated target-device specific configuration file, the system comprises means for transferring an architecture-based configuration file to the target device, means for receiving, at the boot server, a boot report from the target device, means for transferring at least one network policy-based configuration file to the target device; and means for creating the target device definition based on the architecture-based configuration file, the boot report and the network policy-based configuration file. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> The system may also comprise means for creating the boot report based on a hardware scan or a software scan of the target device. The system may also comprise means for acknowledging receipt of the boot report at the boot server. The system may also comprise means for receiving at least one request for an additional architecture-based configuration file from the target device. The system may also comprise means for transferring the additional architecture-based configuration file to the target device. The system may also comprise means for storing the target device definition. The system may also comprise means for re-booting the target device based on the target device definition. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> Another aspect of the present invention provides a boot server for booting a plurality of target devices in communication with a network based on at least one target device definition. The boot server comprises means for determining if a target device has an associated target-device specific configuration file, means for transferring an architecture-based configuration file to the target device, means for receiving a boot report from the target device, means for transferring at least one network policy-based configuration file to the target device, and means for creating the target device definition based on the architecture-based configuration file, the boot report and the network policy-based configuration file. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> The foregoing, and other, features and advantages of the invention will become further apparent from the following detailed description of the presently preferred embodiments, read in conjunction with the accompanying drawings. The detailed description and drawings are merely illustrative of the invention rather than limiting, the scope of the invention being defined by the appended claims in equivalence thereof.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a schematic diagram of one embodiment of a network of data processing systems in accordance with the present invention; </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a block diagram of one embodiment of a data processing system in accordance with the present invention; </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a block diagram of another embodiment of a data processing system in accordance with the present invention; </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a flow diagram of one embodiment of a method of booting a target device in a network environment in accordance with the present invention; and </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a subroutine of the flow diagram of the embodiment of a method of booting a target device in a network environment shown in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>. </paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF THE PRESENTLY PREFERRED EMBODIMENTS </heading>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a schematic representation of a network of data processing systems in accordance with the present invention at <highlight><bold>100</bold></highlight>. Network data processing system <highlight><bold>100</bold></highlight> may be a network of computers in which the present invention may be implemented. Network data processing system <highlight><bold>100</bold></highlight> may contain a network. Network <highlight><bold>102</bold></highlight> may be any suitable medium used to provide communications links between various devices, such as computers, connected to or in communication with each other within network data processing system <highlight><bold>100</bold></highlight>. For example, network <highlight><bold>102</bold></highlight> may include connections, such as wire connections, wireless communication links or fiber optic cables. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> In the embodiment of <cross-reference target="DRAWINGS">FIG. 1, a</cross-reference> server <highlight><bold>104</bold></highlight> may be in communication with network <highlight><bold>102</bold></highlight>. Server <highlight><bold>104</bold></highlight> may provide data, such as boot files, operating system images and applications to network <highlight><bold>102</bold></highlight> and/or to other components in communication with network <highlight><bold>102</bold></highlight> as described below. System <highlight><bold>100</bold></highlight> may also include another server <highlight><bold>105</bold></highlight> which may be identical to or different from server <highlight><bold>104</bold></highlight>. Server <highlight><bold>105</bold></highlight> may also provide data, such as boot files, operating system images and applications to network <highlight><bold>102</bold></highlight> and/or to other components in communication with network <highlight><bold>102</bold></highlight> as described below. System <highlight><bold>100</bold></highlight> may also include additional servers (not shown). In one embodiment of the invention, one or more of servers <highlight><bold>104</bold></highlight>, <highlight><bold>105</bold></highlight> may be a DHCP/PXE Proxy Server. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> One or more storage units, such as storage unit <highlight><bold>106</bold></highlight> may also be in communication with server <highlight><bold>104</bold></highlight>, <highlight><bold>105</bold></highlight> and/or network <highlight><bold>102</bold></highlight>. Storage unit <highlight><bold>106</bold></highlight> may store data, such as boot files, operating system images and applications that may be processed or conveyed by server <highlight><bold>104</bold></highlight>. Storage unit <highlight><bold>106</bold></highlight> may also store data to be made available to or processed by network <highlight><bold>102</bold></highlight> and/or to other components in communication with network <highlight><bold>102</bold></highlight> as described below. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> In one embodiment of the invention, storage unit <highlight><bold>106</bold></highlight> may be, may include or may be in communication with an inventory database <highlight><bold>116</bold></highlight>. Alternatively, as seen in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, inventory database <highlight><bold>116</bold></highlight> may be in communication with one or more of servers <highlight><bold>104</bold></highlight>, <highlight><bold>106</bold></highlight>, <highlight><bold>107</bold></highlight>. This inventory database may comprise listings and related parameters of target devices in communication with network <highlight><bold>102</bold></highlight>. For example, inventory database <highlight><bold>116</bold></highlight> may include a list of target devices <highlight><bold>108</bold></highlight>, <highlight><bold>110</bold></highlight>, <highlight><bold>112</bold></highlight> and configuration files associated with each target device or hardware and software information related to each target device. In one embodiment of the invention, the inventory database <highlight><bold>116</bold></highlight> may include hardware related information. For example, inventory database <highlight><bold>116</bold></highlight> may include a device identifier for each target device and a corresponding serial number and/or model number for the target device. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> Storage unit <highlight><bold>106</bold></highlight> may be, may include or may be in communication with a policy database <highlight><bold>126</bold></highlight>. Alternatively, as seen in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, policy database <highlight><bold>126</bold></highlight> may be in communication with one or more of servers <highlight><bold>104</bold></highlight>, <highlight><bold>106</bold></highlight>, <highlight><bold>107</bold></highlight>. This policy database may comprise information describing policies to be implemented in network <highlight><bold>102</bold></highlight>. For example, policy database <highlight><bold>126</bold></highlight> may include a list of types of target devices and configuration requirements or options for each type of target device. Policy database <highlight><bold>126</bold></highlight> may also include, for example, a list of types of target devices and their default configurations depending on location in the network. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> In addition, target devices <highlight><bold>108</bold></highlight>, <highlight><bold>110</bold></highlight> and <highlight><bold>112</bold></highlight> are also in communication with network <highlight><bold>102</bold></highlight>. These target devices may be, for example, personal computers or network computers. Target devices <highlight><bold>108</bold></highlight>, <highlight><bold>110</bold></highlight>, <highlight><bold>112</bold></highlight> may serve as clients to server <highlight><bold>104</bold></highlight>. Network data processing system <highlight><bold>100</bold></highlight> may include additional servers, clients and other devices not shown. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> As seen in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, network data processing system <highlight><bold>100</bold></highlight> may be any suitable system of processing data. For example system <highlight><bold>100</bold></highlight> may be the Internet. Alternatively, network data processing system <highlight><bold>100</bold></highlight> may also be any suitable type of network such as, for example, an intranet, a local area network (LAN) or a wide area network (WAN). In one embodiment of the invention, network <highlight><bold>102</bold></highlight> represents a worldwide collection of networks and gateways that use the TCP/IP suite of protocols to communicate with one another. A backbone of high-speed data communication lines between major nodes or host computers allows communication between thousands of commercial, government, educational and other computer systems that route data and messages. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> The present invention may also provide a network environment, which may include a DHCP/PXE proxy server. For example, server <highlight><bold>104</bold></highlight> may be a DHCP/PXE proxy server. Alternatively, server <highlight><bold>105</bold></highlight> may be a DHCP/PXE proxy server. System <highlight><bold>100</bold></highlight> may also include one or more boot servers <highlight><bold>107</bold></highlight>. For example server <highlight><bold>104</bold></highlight> or server <highlight><bold>105</bold></highlight> may serve as a boot server <highlight><bold>107</bold></highlight>. These boot servers may be co-located on servers <highlight><bold>104</bold></highlight>, <highlight><bold>105</bold></highlight> with the DHCP/PXE proxy servers. In one embodiment of the invention, one or more target devices, such as devices <highlight><bold>108</bold></highlight>, <highlight><bold>110</bold></highlight>, <highlight><bold>112</bold></highlight>, may include pre-boot extensions that allow the devices to download OS information from a boot server <highlight><bold>107</bold></highlight>. </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> The present invention may also provide a network environment which may include one or more loading devices equipped with a remote loading feature and/or programs, such as, for example, a RPL function. For example, servers <highlight><bold>104</bold></highlight>, <highlight><bold>105</bold></highlight> may serve as a loading device. Alternatively, one or more of target devices <highlight><bold>108</bold></highlight>, <highlight><bold>110</bold></highlight>, <highlight><bold>112</bold></highlight> may be equipped with a remote loading feature and/or programs and may serve as loading devices to other target devices. For example, a target device <highlight><bold>108</bold></highlight>, <highlight><bold>110</bold></highlight>, <highlight><bold>112</bold></highlight> equipped with a bootstrap program and a loader program may send the bootstrap program to one or more other target devices that broadcast a load request. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> As described above, one embodiment of the present invention provides a network environment, which may include a boot server. For example, boot reservation server may be server <highlight><bold>104</bold></highlight>, <highlight><bold>105</bold></highlight> or may be located on server <highlight><bold>104</bold></highlight>, <highlight><bold>105</bold></highlight>. Alternatively, as seen in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, boot server may be a separate server as indicated at <highlight><bold>107</bold></highlight>. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> Boot server <highlight><bold>107</bold></highlight> may be any server capable of evaluating and/or managing network boot resources and/or parameters. For example, boot server <highlight><bold>107</bold></highlight> may be able to examine configuration files of target devices attached to the network and determine the OS of each target device. Boot server <highlight><bold>107</bold></highlight> may also be able to examine one or more inventory databases <highlight><bold>116</bold></highlight> of hardware scan information or other such configuration information corresponding to one or more target devices. Boot server <highlight><bold>107</bold></highlight> may also be able to examine other components of the network, such as loading devices or servers and evaluate the number of target devices requiring a specific OS that may be remotely booted from one or more loading devices or server. Boot server <highlight><bold>107</bold></highlight> may also be able to determine the total duration required for a boot to complete on one or more target devices. Boot server <highlight><bold>107</bold></highlight> may also be able to determine other suitable information about a given target device such as, for example, parameters or descriptions provided by the system administrator, to make such determinations. Boot server <highlight><bold>107</bold></highlight> may also be able to examine one or more policy databases <highlight><bold>126</bold></highlight> to determine which network policy may be applied to a given target device. Boot server <highlight><bold>107</bold></highlight> may be capable of dynamically determining or learning network boot resources and/or parameters. Boot server <highlight><bold>107</bold></highlight> may be capable of evaluating these parameters on a target device, a loading device or any other component of the network. For example, boot server <highlight><bold>107</bold></highlight> may be capable of detecting a given target device&apos;s hardware configuration and comparing the configuration to one or more databases of existing configurations to determine a target device-specific boot definition. </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> Boot server <highlight><bold>107</bold></highlight> may also be capable of automatically detecting a given target device and determining its configuration. Boot reservation server <highlight><bold>107</bold></highlight> may also be capable of automatically booting a given target device based on its determined configuration. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> Boot server <highlight><bold>107</bold></highlight> may accomplish this automatic booting and may determine a target device&apos;s configuration using any suitable means or combination of means known in the art. For example, boot server <highlight><bold>107</bold></highlight> may be equipped with or in communication with a PXE boot service. Such a PXE boot service, may be, for example, the boot service described in Intel (TM) PXE specification version 2.1. Alternatively any suitable PXE boot service may be used. In one embodiment of the invention, the PXE boot service may point to TFTP Service on the boot server <highlight><bold>107</bold></highlight>. The PXE boot service may also indicate the name of the initial Network Bootstrap Program (NBP) that a give target device is to request according to the indicated architecture type of the target device. </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> Boot server <highlight><bold>107</bold></highlight> may be equipped with or in communication with a TFTP Service, as is well known in the art. Alternatively, or in addition to a TFTP service, boot server <highlight><bold>107</bold></highlight> may also be equipped with a UDP (Universal Datagram Protocol) service as is well known in the art. In one embodiment of the invention, the PXE support provided by the PXE ROM code on the target device does not provide a means by which the target device can write its hardware and software scan results to the boot server using TFTP. The target device may then use UDP to do such &ldquo;writes&rdquo; to the boot server <highlight><bold>107</bold></highlight>. The UDP service may then receive the scan results and direct them to one or more software processes (one or more daemons) on the boot server <highlight><bold>107</bold></highlight>. The daemon may be used to process these scan results. Boot server <highlight><bold>107</bold></highlight> may also be equipped with any other communications services needed to support communications with target devices during or after the boot process. </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> Boot server <highlight><bold>107</bold></highlight> may also comprise or be able to access initial NBPs and/or other files corresponding to target device architectures that may be supported by network <highlight><bold>102</bold></highlight>. For example, at least one NBP may be included for each type of target device supported by network <highlight><bold>102</bold></highlight>. Each NBP may then be used for configuring any target device of a given type. Alternatively, these NPBs may be stored in any suitable storage location in communication with boot server <highlight><bold>107</bold></highlight>. For example, these NPBs may be stored in inventory database <highlight><bold>116</bold></highlight>. In some embodiments of the invention, the files corresponding to target device architectures may include all files needed to boot one or more undefined target devices. These files may also include files that can execute a scan of an undefined target device&apos;s installed hardware and software. In some embodiments of the invention, the files that are unique to each architecture type are organized into directories that are uniquely named so that target devices may use architecture-specific file path names to request them. An architecture-unique configuration file may also be included. The names of each architecture-unique configuration file may be known by each corresponding initial NBP. The configuration file may list other files needed to boot and scan a given target device. </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> Boot server <highlight><bold>107</bold></highlight> may also comprise or be able to access all files needed to complete the booting of already-defined target devices that may already be supported by network <highlight><bold>102</bold></highlight>. For example, at least one NBP may be included for each target device that has already been defined in accordance with the present invention. Each NBP and any corresponding configuration files may then be used for configuring an already defined target device. Alternatively, these files may be stored in any suitable storage location in communication with boot server <highlight><bold>107</bold></highlight>. For example, these NPBs may be stored in inventory database <highlight><bold>116</bold></highlight>. In one embodiment of the invention, no matter where the files are stored, files that are unique to each target client are organized into directories named with a unique identifier identifying a given target device. Target device-specific or identifier specific file path names may then be used to request these files. In some embodiments of the invention, the target device-specific files may include target device-unique definition configuration file. This configuration file may include an identifier for the target device which is known by the target device&apos;s initial NBP. The configuration file may also list other files needed to boot the target device according to its definition. </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> Boot server <highlight><bold>107</bold></highlight> may also comprise or be in communication with one or more software processes (daemon) that monitor hardware and software scan data reported by one or more target devices. In some embodiments of the invention, this daemon may respond with specific instructions to a given target device. The daemon may also run processes to verify a given target device. In one embodiment of the invention, the daemon may create a boot definition from the scan data reported by the target device which may be used to define the target device. </paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> As described above, boot server <highlight><bold>107</bold></highlight> may also comprise or be in communication with one or more storage units or databases, <highlight><bold>106</bold></highlight>, <highlight><bold>116</bold></highlight>, <highlight><bold>126</bold></highlight>. In one embodiment of the invention, the database may be provided with tables that may be used by boot server <highlight><bold>107</bold></highlight> (or a daemon of boot server <highlight><bold>107</bold></highlight>) to map the installed hardware and software on the target device as reported by hardware and/or software scans. For example, the installed hardware and software may be mapped to appropriate files needed to create a client-specific complete boot definition. </paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> There may be more than a single instance of boot server <highlight><bold>107</bold></highlight> that is running a PXE Boot Service, and/or other services used to boot target devices. Moreover, it is contemplated that other network devices, such as gateways, routers, and servers, may redirect client boot service discover packets (and other protocol packets) originally directed to the IP address of the &ldquo;primary&rdquo; boot server <highlight><bold>107</bold></highlight> that has failed so that one or more &ldquo;backup&rdquo; boot servers may receive and process these packets. Thus, in some embodiments of the invention, the configuration of the local DHCP/PXE proxy servers may not be changed in the event that the &ldquo;primary&rdquo; boot server <highlight><bold>107</bold></highlight> fails. In some embodiments of the invention, the &ldquo;primary&rdquo; and &ldquo;back-up&rdquo; boot servers maintain or are able to access the definitions of one or more target devices. For example, definitions created on one boot server may be copied to the other boot servers. </paragraph>
<paragraph id="P-0068" lvl="0"><number>&lsqb;0068&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a block diagram of a data processing system in accordance with the present invention at <highlight><bold>200</bold></highlight>. In one embodiment of the invention, data processing system <highlight><bold>200</bold></highlight> may be implemented as one or more of the servers <highlight><bold>104</bold></highlight>, <highlight><bold>105</bold></highlight> shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. </paragraph>
<paragraph id="P-0069" lvl="0"><number>&lsqb;0069&rsqb;</number> Data processing system <highlight><bold>200</bold></highlight> may be a symmetric multiprocessors (SMP) system including a plurality of processors <highlight><bold>202</bold></highlight> and <highlight><bold>204</bold></highlight> connected to system bus <highlight><bold>206</bold></highlight>. Alternatively, a single processor system may be employed. Memory controller/cache <highlight><bold>208</bold></highlight> may also be connected to system bus <highlight><bold>206</bold></highlight>. Memory controller/cache <highlight><bold>208</bold></highlight> may provide an interface to local memory <highlight><bold>209</bold></highlight>. I/O bus bridge <highlight><bold>210</bold></highlight> may also be connected to system bus <highlight><bold>206</bold></highlight> and may provide an interface to I/O bus <highlight><bold>212</bold></highlight>. Memory controller/cache <highlight><bold>208</bold></highlight> and I/O bus bridge <highlight><bold>210</bold></highlight> may be integrated as depicted or may be separate components. </paragraph>
<paragraph id="P-0070" lvl="0"><number>&lsqb;0070&rsqb;</number> Peripheral component interconnect (PCI) bus bridge <highlight><bold>214</bold></highlight> connected to I/O bus <highlight><bold>212</bold></highlight> may provide an interface to PCI local bus <highlight><bold>216</bold></highlight>. One or more modems may be connected to PCI bus <highlight><bold>216</bold></highlight>. Typical PCI bus implementations will support four PCI expansion slots or add-in connectors. Modem <highlight><bold>218</bold></highlight> and network <highlight><bold>220</bold></highlight> may be connected to PCI local bus <highlight><bold>216</bold></highlight>. This connection may be through add-in boards. In one embodiment of the invention, modem <highlight><bold>218</bold></highlight> and accompanying connections provide communications links to target devices such as network computers. For example, such target devices may be those described above at <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. </paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> Additional PCI bus bridges <highlight><bold>222</bold></highlight> and <highlight><bold>224</bold></highlight> may provide interfaces for additional PCI buses <highlight><bold>226</bold></highlight> and <highlight><bold>228</bold></highlight>. Additional modems or network adapters may be supported from PCI buses <highlight><bold>226</bold></highlight> and <highlight><bold>228</bold></highlight>. For example, in one embodiment of the invention, PCI buses <highlight><bold>226</bold></highlight>, <highlight><bold>228</bold></highlight> may support a network adapter with a remote loading feature, such as the RPL feature, installed. In this manner, data processing system <highlight><bold>200</bold></highlight> may allow connections to multiple network computers. A memory-mapped graphics adapter <highlight><bold>230</bold></highlight> and hard disk <highlight><bold>232</bold></highlight> may also be connected to I/O bus <highlight><bold>212</bold></highlight> as depicted, either directly or indirectly. </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> The components depicted in <cross-reference target="DRAWINGS">FIG. 2</cross-reference> may be arranged as shown or in any suitable manner that allows data processing system <highlight><bold>200</bold></highlight> to function as desired. Additionally, other peripheral devices, such as optical disk drives and the like, may be used in addition to or in place of the components depicted. </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a block diagram of a data processing system in accordance with the present invention at <highlight><bold>300</bold></highlight>. Data processing system <highlight><bold>300</bold></highlight> may be, for example, one or more of the target devices <highlight><bold>108</bold></highlight>, <highlight><bold>110</bold></highlight>, <highlight><bold>112</bold></highlight> depicted in <cross-reference target="DRAWINGS">FIG. 1</cross-reference> and described above. In one embodiment of the invention, data processing system <highlight><bold>300</bold></highlight> is a target device on which the disk drives are optional. Alternatively, data processing system <highlight><bold>300</bold></highlight> may be a stand-alone system configured to be bootable without relying on a network communication interface. Alternatively, data processing system <highlight><bold>300</bold></highlight> may also comprise one or more network communication interfaces. Data processing system <highlight><bold>300</bold></highlight> may also be a personal digital assistant (PDA) device. Data processing system may also take the form of a notebook computer or handheld computer. Alternatively, data processing system <highlight><bold>300</bold></highlight> may be a kiosk or Web appliance. The processes of the present invention may also be applied to a multiprocessor data processing system. </paragraph>
<paragraph id="P-0074" lvl="0"><number>&lsqb;0074&rsqb;</number> Data processing system <highlight><bold>300</bold></highlight> may employ a peripheral component interconnect (PCI) local bus architecture. Although the depicted example employs a PCI bus, other bus architectures such as Accelerated Graphics Port (AGP) and Industry Standard Architecture (ISA) may be used. Processor <highlight><bold>302</bold></highlight> and main memory <highlight><bold>304</bold></highlight> may be connected to PCI local bus <highlight><bold>306</bold></highlight> via PCI bridge <highlight><bold>308</bold></highlight>. PCI bridge <highlight><bold>308</bold></highlight> may also include an integrated memory controller and cache memory for processor <highlight><bold>302</bold></highlight>. Additional connections to PCI local bus <highlight><bold>306</bold></highlight> may be made through direct component interconnection or through add-in boards. In one embodiment of the invention, local area network (LAN) adapter <highlight><bold>310</bold></highlight>, SCSI host bus adapter <highlight><bold>312</bold></highlight>, and expansion bus interface <highlight><bold>314</bold></highlight> are connected to PCI local bus <highlight><bold>306</bold></highlight> by direct component connection. In contrast, audio adapter <highlight><bold>316</bold></highlight>, graphics adapter <highlight><bold>318</bold></highlight> and audio/video adapter <highlight><bold>319</bold></highlight> are connected to PCI local bus <highlight><bold>306</bold></highlight> by add-in boards inserted into expansion slots. Expansion bus interface <highlight><bold>314</bold></highlight> may provide a connection for additional components such as, for example, a keyboard and mouse adapter <highlight><bold>320</bold></highlight>, a modem <highlight><bold>322</bold></highlight> and additional memory <highlight><bold>324</bold></highlight>. A small computer system interface (SCSI) host bus adapter <highlight><bold>312</bold></highlight> may provide a connection for additional components such as, for example, a hard disk drive <highlight><bold>326</bold></highlight>, a tape drive <highlight><bold>328</bold></highlight>, a CD-ROM drive <highlight><bold>330</bold></highlight> or a DVD <highlight><bold>332</bold></highlight>. PCI local bus <highlight><bold>306</bold></highlight> may be any suitable local bus implementation. Typical PCI local bus implementations support three or four PCI expansion slots or add-in connectors. </paragraph>
<paragraph id="P-0075" lvl="0"><number>&lsqb;0075&rsqb;</number> In one embodiment of the invention, an operating system (OS) may run on processor <highlight><bold>302</bold></highlight>. This OS may be used to coordinate and provide control of various components within data processing system <highlight><bold>300</bold></highlight>. The OS may be a commercially available operating system, such as, for example, Linux&trade;, OS/2 Warp 4, or Windows 2000&trade;. An object oriented programming system may be in communication with the OS and may run in conjunction with the OS. For example, the object-oriented programming system may provide calls to the OS from programs or applications executing on data processing system <highlight><bold>300</bold></highlight>. These programs or applications may be specific to the object-oriented programming system or may be programs or applications run by other programming systems. In one embodiment of the invention, the object-oriented programming system may be Java&trade;, a trademark of Sun Microsystems, Inc. </paragraph>
<paragraph id="P-0076" lvl="0"><number>&lsqb;0076&rsqb;</number> Instructions for the OS, the object-oriented operating system, and applications or programs may be located on storage devices such as, for example, hard disk drive <highlight><bold>326</bold></highlight>. These operating systems, applications and/or programs may be loaded into main memory <highlight><bold>304</bold></highlight> for execution by processor <highlight><bold>302</bold></highlight>. </paragraph>
<paragraph id="P-0077" lvl="0"><number>&lsqb;0077&rsqb;</number> In one embodiment of the invention, system <highlight><bold>300</bold></highlight> may include a suitable configuration file which may indicate boot parameters that may be evaluated to determine network boot resources as described above. </paragraph>
<paragraph id="P-0078" lvl="0"><number>&lsqb;0078&rsqb;</number> The components of system <highlight><bold>300</bold></highlight> depicted in <cross-reference target="DRAWINGS">FIG. 3</cross-reference> may be arranged as shown or in any suitable manner that allows data processing system <highlight><bold>300</bold></highlight> to function as desired. Other internal hardware or peripheral devices, such as flash ROM (or equivalent nonvolatile memory) or optical disk drives and the like, may be used in addition to or in place of the components depicted. For example, one embodiment of data processing system <highlight><bold>300</bold></highlight> may be configured with ROM and/or flash ROM in order to provide non-volatile memory for storing operating system files and/or user-generated data. Another embodiment of data processing system <highlight><bold>300</bold></highlight> may include network adapters suited to transmit or receive functions of a remote loading program and/or feature such as the RPL feature. </paragraph>
<paragraph id="P-0079" lvl="0"><number>&lsqb;0079&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> shows one embodiment of a method for booting a target device in accordance with the present invention at <highlight><bold>400</bold></highlight>. The target device may be, for example, one or more devices <highlight><bold>108</bold></highlight>, <highlight><bold>110</bold></highlight>, <highlight><bold>112</bold></highlight> depicted in <cross-reference target="DRAWINGS">FIG. 1</cross-reference> and described above. In the embodiment of <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, the method is described from the perspective of a boot server; equivalent steps from the perspective of a proxy server and the target device are also contemplated by the present invention. In one embodiment of the invention, the proxy server and the boot server may be the same server. </paragraph>
<paragraph id="P-0080" lvl="0"><number>&lsqb;0080&rsqb;</number> In some embodiments of the invention, the method of <cross-reference target="DRAWINGS">FIG. 4</cross-reference> may be accomplished automatically. For example, boot server <highlight><bold>107</bold></highlight> and its associated services may generate a target device definition automatically and/or may boot the target device automatically using information from the inventory database and/or the policy database. Alternatively, the method of <cross-reference target="DRAWINGS">FIG. 4</cross-reference> may be administered. For example, the target device definition being generated may be presented to an administrator for review in a step-by-step manner by an administrator as it is being created. Alternatively, a summary of the target device definition may be presented to the administrator for approval at an appropriate point during the process. In some embodiments of the invention, the target device definition may be approved by an administrator or user of network <highlight><bold>102</bold></highlight> before being implemented. </paragraph>
<paragraph id="P-0081" lvl="0"><number>&lsqb;0081&rsqb;</number> The methods of the present invention may be used with any target device that is able to receive an IP address and be directed to a boot server. For example, the embodiment of the method shown in <cross-reference target="DRAWINGS">FIG. 4</cross-reference> may begin when one or more target devices are directed to a boot server by the subroutine of <cross-reference target="DRAWINGS">FIG. 6</cross-reference>. Alternatively, the methods of the present invention may be used when one or more target devices send a request for a target device-specific configuration file as described, for example, below at step <highlight><bold>516</bold></highlight>. Alternatively, the method of <cross-reference target="DRAWINGS">FIG. 4</cross-reference> may be used to respond to any suitable request to determine a target device-specific boot definition, including a request from a boot server, a proxy server, a loading device or a target device as described above. </paragraph>
<paragraph id="P-0082" lvl="0"><number>&lsqb;0082&rsqb;</number> As seen at block <highlight><bold>400</bold></highlight>, boot server <highlight><bold>107</bold></highlight> may look for an initial target device-specific configuration file. In one embodiment of the invention, this target device-specific configuration file is indicated by or included in the target device definition. This target device-specification configuration file may be, for example, an initial NBP. The presence of such a target device-specific configuration file may indicate that the target device has already been defined at block <highlight><bold>404</bold></highlight>. If such a target device-specific configuration file is found, the method may proceed to block <highlight><bold>430</bold></highlight>. At block <highlight><bold>430</bold></highlight>, the target device-specific configuration file may be transferred to the target device. At block <highlight><bold>432</bold></highlight>, the boot server may receive one or more requests for additional boot files. These boot files may also be indicated by or included in the target device definition found at <highlight><bold>404</bold></highlight>. These boot files may be transferred to the target device as seen at <highlight><bold>434</bold></highlight>. The loop between blocks <highlight><bold>432</bold></highlight> and <highlight><bold>434</bold></highlight> may continue until the target device is booted. In one embodiment of the invention, the target device may be considered booted, when it is in a state where it can perform useful work for the end-user. </paragraph>
<paragraph id="P-0083" lvl="0"><number>&lsqb;0083&rsqb;</number> If, however, a target device-specific configuration file is not found at block <highlight><bold>400</bold></highlight>, it may be indicated at block <highlight><bold>404</bold></highlight> that the target device is not defined. This may be indicated for example, when the boot server receives a response from the target device indicating that the target device-specific configuration file was not found. This response may take the form of, for example, a TFTP error. </paragraph>
<paragraph id="P-0084" lvl="0"><number>&lsqb;0084&rsqb;</number> The method may then proceed to block <highlight><bold>406</bold></highlight> where the boot server may then receive a request from the target device for default instructions for the target device&apos;s architecture type. This may occur, for example, if the initial NBP on the target device infers that the target device is not defined. The request from the target device may take the form of a TFTP request for an architecture-unique scan configuration file for the architecture of the target device. &ldquo;Architecture&rdquo; may refer to the type of processor that is contained in a given target client. For example, IBM-compatible Personal Computers are based on the Intel and Intel-compatible processors (such as AMD processors), and these machines have what is called an &ldquo;Intel architecture&rdquo;. Other architectures include Apple Mac PCs, Palm Pilots, IBM RS/6000, etc. These architectures (and the processors that define them) may be incompatible with regard to the instructions that operate them. Therefore, each type of target client architecture would have to be supplied with its own Initial NBP and other programs in order to correctly operate on a given target client. The architecture of the client is indicated in the DHCP/PXE packets and the PXE Boot Discover packets sent from the client to the DHCP/PXE Server and the Boot Server. As described further below, these servers may be configured to process each client architecture separately to assure that the correct programs are delivered to a given target device. </paragraph>
<paragraph id="P-0085" lvl="0"><number>&lsqb;0085&rsqb;</number> At block <highlight><bold>408</bold></highlight>, the boot server may then transfer the architecture-unique scan configuration file to the target device. In one embodiment of the invention, the boot server may determine the appropriate architecture-unique file by referring to an inventory database which lists types of target devices and their corresponding architectures or architecture unique files. </paragraph>
<paragraph id="P-0086" lvl="0"><number>&lsqb;0086&rsqb;</number> At block <highlight><bold>410</bold></highlight>, the boot server may then receive one or more additional requests from the target device for one or more additional files required to boot and scan the target device with the architecture determined at <highlight><bold>408</bold></highlight>. These requests may take the form of, for example, TFTP requests. </paragraph>
<paragraph id="P-0087" lvl="0"><number>&lsqb;0087&rsqb;</number> At block <highlight><bold>412</bold></highlight>, the boot server may respond to these one or more requests with appropriate files for booting and scanning the target device. These responses may take the form of, for example, TFTP transfers of appropriate files. The loop between blocks <highlight><bold>410</bold></highlight> and <highlight><bold>412</bold></highlight> may continue until all appropriate files have been transferred to bring the target device to a condition in which hardware and software scans may be run on the target device. In one embodiment of the invention, this condition is not fully &ldquo;booted&rdquo; as described above, i.e., the target device cannot yet perform useful end work for the user although it is able to be scanned. For example, in some embodiments of the invention, blocks <highlight><bold>410</bold></highlight> and <highlight><bold>412</bold></highlight> may serve to provide a rudimentary environment on the target device so that one or more hardware and/or software scan programs may be run. This may be accomplished by an initial NBP which transfers the rudimentary environment and scan program(s) to the target device before passing control over to the target device. </paragraph>
<paragraph id="P-0088" lvl="0"><number>&lsqb;0088&rsqb;</number> At block <highlight><bold>414</bold></highlight>, the boot server or the server daemon may receive a boot report from the target device. In one embodiment of the invention, this report is received after the initial NBP on the target device transfers execution to scan code which scans the hardware and software installed on the target device. The boot report may comprise a report detailing the hardware and/or software scan results. The boot report may also be any suitable report to boot server <highlight><bold>107</bold></highlight> or server daemon that describes the hardware and software profile of the target device. The boot report may take the form of, for example, a UDP transfer of the scan results of the target device. </paragraph>
<paragraph id="P-0089" lvl="0"><number>&lsqb;0089&rsqb;</number> At block <highlight><bold>416</bold></highlight>, the boot server or the server daemon may acknowledge receipt of the boot report generated at block <highlight><bold>414</bold></highlight>. For example, the server daemon may perform a UDP transfer of acknowledgment of receipt of the target device&apos;s scan results. </paragraph>
<paragraph id="P-0090" lvl="0"><number>&lsqb;0090&rsqb;</number> At block <highlight><bold>418</bold></highlight>, the boot server or the server daemon may apply any additional target device-specific configurations or policies to the target device. For example, network wide policy for a given type of target device may indicate that a given hardware or software component on that type of target device must be enabled or disabled (e.g., if a given target device is a laptop, Microsoft(&trade;) Outlook(&trade;) must be installed on the target device, or all target devices with CD-ROM drives will have sound disabled.) The boot server may determine these additional target device-specific configurations or policies by reference to a policy database. Some of these additional target device-specific configurations may also be determined by a DMI scan that provides a list of additional plug-in devices that may be configured for use with one or more target devices. These target device-specific configurations or policies may be the same or additional target device-specific configurations or policies as those determined for the target device based on the inventory database. In one embodiment of the invention, the target device-specific configurations from the policy database or DMI scan override those of the inventory database. In another embodiment the target device-specific configurations from the policy database supplement those of the inventory database. </paragraph>
<paragraph id="P-0091" lvl="0"><number>&lsqb;0091&rsqb;</number> At block <highlight><bold>420</bold></highlight>, the target device definition may be stored, for example, in any suitable storage location as described above. </paragraph>
<paragraph id="P-0092" lvl="0"><number>&lsqb;0092&rsqb;</number> At block <highlight><bold>422</bold></highlight>, it may be indicated that the target device definition is completed. This may indicate, for example, that the target device is now defined. In one embodiment of the invention, a UDP transfer of a request for the target device to reboot may occur. This transfer may serve as an indication that the target device definition is completed. </paragraph>
<paragraph id="P-0093" lvl="0"><number>&lsqb;0093&rsqb;</number> At block <highlight><bold>424</bold></highlight>, a DHCP discover may request a release of the IP address originally assigned to the target device. If the target device has already been defined, the DHCP discover of block <highlight><bold>424</bold></highlight> may serve in a similar capacity as the DHCP discover of block <highlight><bold>502</bold></highlight> as described further below. At this time, the target device may reboot and PXE ROM code may operate on the target device during the steps described in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>. </paragraph>
<paragraph id="P-0094" lvl="0"><number>&lsqb;0094&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> shows one embodiment of a subroutine A in a method for booting a target device in accordance with the present invention. In the embodiment shown in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>, the target device may be a device containing a network interface that is enabled to support PXE and in which PXE ROM code starts operating on the target device when the target device initially begins to boot. In the embodiment of <cross-reference target="DRAWINGS">FIG. 5</cross-reference>, the method is described from the perspective of a proxy server attempting to boot the target device; equivalent steps from the perspective of a boot server and the target device are also contemplated by the present invention. In one embodiment of the invention, the proxy server attempting to boot the target device and the boot server may be the same server. The target device attempting to boot may be, for example, a target device that has been defined in accordance with the present invention. </paragraph>
<paragraph id="P-0095" lvl="0"><number>&lsqb;0095&rsqb;</number> At block <highlight><bold>502</bold></highlight>, the server may broadcast a DHCP discover or other similar request to one or more target devices. This server may be, for example a DHCP/PXE Proxy Server as described above. In the embodiment of <cross-reference target="DRAWINGS">FIG. 5</cross-reference>, the server contains a DHCP/PXE proxy service which is enabled to indicate a PXE Boot Service on boot server <highlight><bold>107</bold></highlight> as described above. The DHCP broadcast or DHCP discover may be a request for DHCP/PXE proxy offers. This discover broadcast may request an IP address from one or more target devices. The broadcast may also indicate whether or not a target device is PXE enabled. The broadcast may also indicate an architecture type for a given target device. The configuration of the DHCP/PXE Proxy server may be implemented on more than one machine as described above. The &ldquo;standard&rdquo; DHCP service (which offers IP addresses to clients) and the &ldquo;proxy&rdquo; DHCP service (which directs clients to a PXE Boot Server Discovery service) may be in separate locations. If the DHCP services are in separate locations, there may be two separate communications in accordance with the present invention: a &ldquo;standard&rdquo; DHCP offer which offers an IP address to the client, and a &ldquo;proxy&rdquo; DHCP offer which directs the client to a PXE Boot Server Discovery service. Moreover, any suitable configurations of the DHCP/PXE servers may be used in accordance with the present invention so long as the target device may receive an IP address and be directed to the boot server. For example, any of the configurations described in the Intel PXE Specification Version 2.1 may be used in accordance with the present invention. </paragraph>
<paragraph id="P-0096" lvl="0"><number>&lsqb;0096&rsqb;</number> Additionally, there may be more than one instance of a &ldquo;standard&rdquo; DHCP service, of a &ldquo;proxy&rdquo; DHCP service, and/or of a &ldquo;combined&rdquo; DHCP service (i.e. a DHCP service that does both by offering an IP address to the target device and directing the target device to a Boot Discovery service) within the range of the target device&apos;s DHCP Discover broadcast. This can be accomplished by placing the instances of these DHCP services on machines located in the same sub-network as the target device, and/or by configuring network gateways and routers to forward the client&apos;s DHCP Discover broadcasts to DHCP services on machines located in other sub-networks. </paragraph>
<paragraph id="P-0097" lvl="0"><number>&lsqb;0097&rsqb;</number> Having more than one instance of these DHCP services can provide redundancy in case any one instance of these DHCP services becomes unable to respond to a given target device. If the target device receives more than one &ldquo;standard&rdquo;, &ldquo;proxy&rdquo; or &ldquo;combined&rdquo; DHCP/PXE Proxy offer, it will select only one IP address for its use, and will select only one Central Boot Server IP address to be directed to. </paragraph>
<paragraph id="P-0098" lvl="0"><number>&lsqb;0098&rsqb;</number> At block <highlight><bold>504</bold></highlight>, one or more of servers <highlight><bold>104</bold></highlight>, <highlight><bold>105</bold></highlight> may make a DHCP/PXE Proxy Offer. This offer may serve to offer an IP address to one or more target devices. This offer may also communicate that a PXE boot service is available at the IP address of boot server <highlight><bold>107</bold></highlight>. </paragraph>
<paragraph id="P-0099" lvl="0"><number>&lsqb;0099&rsqb;</number> At block <highlight><bold>506</bold></highlight>, the server may receive a DHCP request from one or more target devices. This DHCP request may indicate that a given target device has requested or accepted the IP address offered to it. Such an acceptance may permit the target device to conduct all further point-to-point network-wide communications. </paragraph>
<paragraph id="P-0100" lvl="0"><number>&lsqb;0100&rsqb;</number> At block <highlight><bold>508</bold></highlight>, the server may acknowledge the request of block <highlight><bold>506</bold></highlight>. By acknowledging the request at block <highlight><bold>506</bold></highlight>, the server may thus be able to confirm that a given IP address has been assigned to a specific target device. </paragraph>
<paragraph id="P-0101" lvl="0"><number>&lsqb;0101&rsqb;</number> At block <highlight><bold>510</bold></highlight>, the server may conduct a boot service discover. In one embodiment of the invention, the server may request the IP address of a TFTP service that will enable the server to request an initial NBP. The server may also request the name of the initial NBP file to be requested via the TFTP service. At this time, the server may also indicate the architecture type of one or more of the target devices. In one embodiment of the invention, this architecture type is determined as described above at block <highlight><bold>502</bold></highlight> and then conveyed during the boot service discover at block <highlight><bold>510</bold></highlight>. </paragraph>
<paragraph id="P-0102" lvl="0"><number>&lsqb;0102&rsqb;</number> At block <highlight><bold>512</bold></highlight>, the server may receive a boot service acknowledgment from boot server <highlight><bold>107</bold></highlight>. This acknowledgment may indicate, for example, the IP address of boot server <highlight><bold>107</bold></highlight>. This acknowledgment may also indicate the file name of the initial NBP for a given target device&apos;s architecture type. </paragraph>
<paragraph id="P-0103" lvl="0"><number>&lsqb;0103&rsqb;</number> As seen at block <highlight><bold>514</bold></highlight>, the server may then receive a TFTP request from the target device. In one embodiment of the invention, the request is for an initial NBP file. The request may also be a request for a bootstrap, for example, a bootstrap associated with a particular OS. </paragraph>
<paragraph id="P-0104" lvl="0"><number>&lsqb;0104&rsqb;</number> As seen at block <highlight><bold>516</bold></highlight> a response may then be sent to the target device by the server or the boot server. For example, the server or boot server may conduct a TFTP transfer of the initial NBP to the target device as the response. In one embodiment of the invention, at this point, PXE ROM code may transfer execution from the server to the initial NBP which has now been transferred to the target device. </paragraph>
<paragraph id="P-0105" lvl="0"><number>&lsqb;0105&rsqb;</number> As seen at block <highlight><bold>518</bold></highlight>, the target device, or the initial NBP on the target device may now send a TFTP request for an initial target device-specific configuration file. This may be, for example a target device-specific boot definition. From block <highlight><bold>518</bold></highlight>, the subroutine described herein may proceed to the method described in <cross-reference target="DRAWINGS">FIG. 4</cross-reference> above. </paragraph>
<paragraph id="P-0106" lvl="0"><number>&lsqb;0106&rsqb;</number> Alternatively, if the target device has already been defined, the subroutine of <cross-reference target="DRAWINGS">FIG. 5</cross-reference> may return to block <highlight><bold>400</bold></highlight>, where boot server <highlight><bold>107</bold></highlight> may look for an initial target device-specific configuration file. If the target device has been defined, for example, by creating a client definition with the method of <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, this target device-specific configuration file is indicated by or included in the target device definition and the method may proceed to block <highlight><bold>430</bold></highlight>. At block <highlight><bold>430</bold></highlight>, the target device-specific configuration file may be transferred to the target device. At block <highlight><bold>432</bold></highlight>, the boot server may receive one or more requests for additional boot files. These boot files may also be indicated by or included in the target device definition found at <highlight><bold>404</bold></highlight>. These boot files may be transferred to the target device as seen at <highlight><bold>434</bold></highlight>. The loop between blocks <highlight><bold>432</bold></highlight> and <highlight><bold>434</bold></highlight> may continue until the target device is booted. In one embodiment of the invention, the target device may be considered booted, when it is in a state where it can perform useful work for the end-user. </paragraph>
<paragraph id="P-0107" lvl="0"><number>&lsqb;0107&rsqb;</number> While the present invention has been described in the context of a fully functioning data processing system, it will be appreciated that the processes described may be distributed in any other suitable context. For example, the processes described may take the form of a computer readable medium of instructions. The present invention applies equally regardless of the type of signal-bearing media actually used to carry out the distribution. Examples of computer readable media include recordable-type media, such as a floppy disk, a hard disk drive, a RAM, CD-ROMs, DVD-ROMS, and transmission-type media, such as digital and analog communications links, wired or wireless communications links using transmission forms such as, for example, radio frequency and light wave transmissions. The computer readable media may take the form of coded formats that are decoded for actual use in a particular data processing system. </paragraph>
<paragraph id="P-0108" lvl="0"><number>&lsqb;0108&rsqb;</number> It will be appreciated by those skilled in the art that while the invention has been described above in connection with particular embodiments and examples, the invention is not necessarily so limited, and that numerous other embodiments, examples, uses, modifications and departures from the embodiments, examples and uses are intended to be encompassed by the claims attached hereto. The entire disclosure of each patent and publication cited herein is incorporated by reference, as if each such patent or publication were individually incorporated by reference herein. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method of booting a plurality of target devices in communication with a network based on at least one target device definition, comprising: 
<claim-text>receiving, at a server in communication with the plurality of target devices, a request for a boot file from at least one target device; </claim-text>
<claim-text>contacting a boot server in communication with the plurality of target devices; </claim-text>
<claim-text>determining at the boot server if the target device is defined; </claim-text>
<claim-text>if the target device is not defined, creating, at the boot server, the target device definition for the target device; and </claim-text>
<claim-text>executing a bootstrap at the target device, the bootstrap corresponding to the target definition. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising: 
<claim-text>scanning the target device for at least one hardware configuration; and </claim-text>
<claim-text>creating the target device definition based on the hardware configuration. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising: 
<claim-text>scanning the target device for at least one software configuration; and </claim-text>
<claim-text>creating the target device definition based on the software configuration. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising: 
<claim-text>determining an architecture of the target device; and </claim-text>
<claim-text>creating the target device definition based on the architecture of the target device. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising: 
<claim-text>determining at least one network policy for the target device; and </claim-text>
<claim-text>creating the target device definition based on the network policy. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising: 
<claim-text>receiving at least one request for a configuration file from the target device. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference>, further comprising: 
<claim-text>transferring the configuration file to the target device. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising: 
<claim-text>storing the target device definition. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. A method of booting a target device in communication with a network based on at least one target device definition, comprising: 
<claim-text>determining, at a boot server in communication with the network, if the target device has an associated target-device specific configuration file; </claim-text>
<claim-text>if the device does not have the associated target-device specific configuration file, transferring an architecture-based configuration file to the target device; </claim-text>
<claim-text>receiving, at the boot server, a boot report from the target device; </claim-text>
<claim-text>transferring at least one network policy-based configuration file to the target device; and </claim-text>
<claim-text>creating the target device definition based on the architecture-based configuration file, the boot report and the network policy-based configuration file. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, further comprising: 
<claim-text>creating the boot report based on a hardware scan of the target device. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, further comprising: 
<claim-text>creating the boot report based on a software scan of the target device. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, further comprising: 
<claim-text>acknowledging receipt of the boot report at the boot server. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, further comprising: 
<claim-text>receiving at least one request for an additional architecture-based configuration file from the target device. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference>, further comprising: 
<claim-text>transferring the additional architecture-based configuration file to the target device. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, further comprising: 
<claim-text>storing the target device definition. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, further comprising: 
<claim-text>re-booting the target device based on the target device definition. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. Computer program product in a computer usable medium for booting a plurality of target devices in communication with a network based on at least one target device definition, comprising: 
<claim-text>means for determining, at a boot server in communication with the network, if the target device has an associated target-device specific configuration file; </claim-text>
<claim-text>if the device does not have the associated target-device specific configuration file, means for transferring an architecture-based configuration file to the target device; </claim-text>
<claim-text>means for receiving, at the boot server, a boot report from the target device; </claim-text>
<claim-text>means for transferring at least one network policy-based configuration file to the target device; and </claim-text>
<claim-text>means for creating the target device definition based on the architecture-based configuration file, the boot report and the network policy-based configuration file. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The program of <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference>, further comprising: 
<claim-text>means for creating the boot report based on a hardware scan of the target device. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The program of <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference>, further comprising: 
<claim-text>means for creating the boot report based on a software scan of the target device. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The program of <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference>, further comprising: 
<claim-text>means for acknowledging receipt of the boot report at the boot server. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The program of <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference>, further comprising: 
<claim-text>means for receiving at least one request for an additional architecture-based configuration file from the target device. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The program of <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference>, further comprising: 
<claim-text>means for transferring the additional architecture-based configuration file to the target device. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The program of <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference>, further comprising: 
<claim-text>means for storing the target device definition. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The program of <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference>, further comprising: 
<claim-text>means for re-booting the target device based on the target device definition. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. A system for booting a plurality of target devices in communication with a network based on at least one target device definition, comprising: 
<claim-text>means for determining, at a boot server in communication with the network, if the target device has an associated target-device specific configuration file; </claim-text>
<claim-text>if the device does not have the associated target-device specific configuration file, means for transferring an architecture-based configuration file to the target device; </claim-text>
<claim-text>means for receiving, at the boot server, a boot report from the target device; </claim-text>
<claim-text>means for transferring at least one network policy-based configuration file to the target device; and </claim-text>
<claim-text>means for creating the target device definition based on the architecture-based configuration file, the boot report and the network policy-based configuration file. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>, further comprising: 
<claim-text>means for creating the boot report based on a hardware scan of the target device. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>, further comprising: 
<claim-text>means for creating the boot report based on a software scan of the target device. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>, further comprising: 
<claim-text>means for acknowledging receipt of the boot report at the boot server. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00029">
<claim-text><highlight><bold>29</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>, further comprising: 
<claim-text>means for receiving at least one request for an additional architecture-based configuration file from the target device. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00030">
<claim-text><highlight><bold>30</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00022">claim 29</dependent-claim-reference>, further comprising: 
<claim-text>means for transferring the additional architecture-based configuration file to the target device. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00031">
<claim-text><highlight><bold>31</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>, further comprising: 
<claim-text>means for storing the target device definition. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00032">
<claim-text><highlight><bold>32</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>, further comprising: 
<claim-text>means for re-booting the target device based on the target device definition. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00033">
<claim-text><highlight><bold>33</bold></highlight>. A boot server for booting a plurality of target devices in communication with a network based on at least one target device definition, comprising: 
<claim-text>means for determining if a target device has an associated target-device specific configuration file; </claim-text>
<claim-text>means for transferring an architecture-based configuration file to the target device; </claim-text>
<claim-text>means for receiving a boot report from the target device; </claim-text>
<claim-text>means for transferring at least one network policy-based configuration file to the target device; and </claim-text>
<claim-text>means for creating the target device definition based on the architecture-based configuration file, the boot report and the network policy-based configuration file.</claim-text>
</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>4</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005276A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005276A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005276A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005276A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005276A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005276A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
