<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005273A1-20030102-D00000.TIF SYSTEM "US20030005273A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005273A1-20030102-D00001.TIF SYSTEM "US20030005273A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005273A1-20030102-D00002.TIF SYSTEM "US20030005273A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005273A1-20030102-D00003.TIF SYSTEM "US20030005273A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005273A1-20030102-D00004.TIF SYSTEM "US20030005273A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005273A1-20030102-D00005.TIF SYSTEM "US20030005273A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030005273A1-20030102-D00006.TIF SYSTEM "US20030005273A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030005273A1-20030102-D00007.TIF SYSTEM "US20030005273A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030005273A1-20030102-D00008.TIF SYSTEM "US20030005273A1-20030102-D00008.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005273</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09895936</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010629</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F015/177</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>713</class>
<subclass>001000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Initialization, reconfiguration, and shut down of a module function</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Krzysztof</given-name>
<middle-name>S.</middle-name>
<family-name>Perycz</family-name>
</name>
<residence>
<residence-non-us>
<city>Chmielno</city>
<country-code>PL</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Bohdan</given-name>
<middle-name>T.</middle-name>
<family-name>Iwanojko</family-name>
</name>
<residence>
<residence-non-us>
<city>Gdansk</city>
<country-code>PL</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Adam</given-name>
<family-name>Kaminski</family-name>
</name>
<residence>
<residence-non-us>
<city>Gdansk</city>
<country-code>PL</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Jaroslaw</given-name>
<family-name>Kogut</family-name>
</name>
<residence>
<residence-non-us>
<city>Gdansk</city>
<country-code>PL</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Mariusz</given-name>
<family-name>Oriol</family-name>
</name>
<residence>
<residence-non-us>
<city>Gdynia</city>
<country-code>PL</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Zbigniew</given-name>
<family-name>Przekop</family-name>
</name>
<residence>
<residence-non-us>
<city>Gdansk</city>
<country-code>PL</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>BLAKELY SOKOLOFF TAYLOR &amp; ZAFMAN</name-1>
<name-2></name-2>
<address>
<address-1>12400 WILSHIRE BOULEVARD, SEVENTH FLOOR</address-1>
<city>LOS ANGELES</city>
<state>CA</state>
<postalcode>90025</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">The present invention is in the field of embedded systems. More particularly, some embodiments initialize, reconfigure, and shut down a module function to provide a unified solution for software development. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">FIELD OF INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> The present invention is in the field of embedded systems software engineering. More particularly, the present invention provides a method, apparatus, system, and machine-readable medium to perform orderly initialization, reconfiguration, and shut down of a software module being a piece of an embedded system. </paragraph>
</section>
<section>
<heading lvl="1">BACKGROUND </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> Embedded systems are present in specialized computing devices, such as various turnkey products including, but not limited to, network components like nodes for switches, routers and gateways. Software building blocks of such embedded systems are known as modules. A module may implement some specific functionality. A module&apos;s behavior can be determined by a set of module configuration parameters. The parameters may be preserved in some form of non-volatile storage to be available after device power down/power up cycle. The saved parameters can be accessed and used to initialize modules during device start-up. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> An operator issuing configuration change requests via some form of management interface may change them later at run-time and save. Modules in a device may not be not totally independent&mdash;some modules may use services provided by other modules. Therefore, during initialization, reconfiguration and shutdown the modules have to be acted upon in a proper sequence, as implied by the aforementioned dependencies. For example, a routing protocol like Open Shortest Path First (OSPF) operating in an OSPF module, needs Internet Protocol (IP) stack operating in an IP stack module. Consequently, for initialization and reconfiguration, IP stack module parameters may be set before OSPF module parameters are set, so the IP stack module may become active before the OSPF module becomes active. During shutdown, an inverted sequence may be needed: the OSPF module can shut down first, followed by the IP stack module. In this way, OSPF may send packets informing other network devices that it is about to de-activate via the IP stack module. In consequence, other network nodes may adjust their topology databases without disrupting network operation, which may otherwise happen when a network node simply disappears without any warning. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> In embedded systems, the initialization and shutdown functions may be improperly structured, which results in lots of redundant coding and difficulties in reusing the code in different products. Initialization code can be combined with initial configuration routines, specifically coded to handle some format of registry or INI file, holding configuration parameters. When the format changes, the whole initialization code may have to be rewritten. Initialization and shutdown sequences may be hardcoded, so it is difficult to reuse the code on different products using different set of features (modules tend to be tightly coupled with such an arrangement). Initial configuration and run-time reconfiguration may be performed with a different code, which adds redundancy, increases testing complexity and can be generally error-prone. There is no general mechanism for ensuring a correct sequence of actions on initialization and shutdown.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF FIGURE DESCRIPTIONS </heading>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> The accompanying drawings, in which like references indicate similar elements, show: </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> depicts a high-level block diagram of a network system including an embedded system software application. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> depicts a node capable of changing a module function. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> depicts system initialization. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> depicts system shutdown. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> depicts configuration saving. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> depicts a flow chart to change a module function. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> depicts another flow chart to change a module function. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> depicts a machine-readable medium comprising instructions to change a module function. </paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF EMBODIMENTS </heading>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> The following is a detailed description of example embodiments of the invention depicted in the accompanying drawings. The example embodiments are in such detail as to clearly communicate the invention. However, the amount of detail offered is not intended to limit the anticipated variations of embodiments. The variations of embodiments anticipated for the present invention are too numerous to discuss individually so the detailed descriptions below are designed to make such embodiments obvious to a person of ordinary skill in the art. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> As described above, referring to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, an embedded systems software application typically comprises one or more modules <highlight><bold>160</bold></highlight> coupled together on one or more e.g., network devices <highlight><bold>130</bold></highlight> to provide the overall functionality of the application (and consequently of the network device(s)). A module is thus a configurable piece of embedded systems software implementing a specific functionality. In the proposed arrangement, the modules are typically loosely coupled such that they depend to some extent on each other but a missing or non-enabled related module will not cause a system crash or disruption but merely some degradation of overall functionality of the application. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> Further, according to an embodiment of the invention, a network embedded systems software application comprises one or more management applications clients <highlight><bold>120</bold></highlight> serving one or more management stations <highlight><bold>110</bold></highlight>. A management station is a device in the network from which the various network devices are controlled and configured using the management client(s) <highlight><bold>120</bold></highlight> and/or configuration manager <highlight><bold>140</bold></highlight> residing on such devices. Typically, a management station is a workstation on a network and comprises management application software. Such management application software may include Simple Network Management Protocol (SNMP) manager software and/or command-line interface (CLI) terminal software such as Hewlett Packard&apos;s OpenView software, Hyper Terminal available as part of the Microsoft Windows operating system software or telnet software. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> A management client <highlight><bold>120</bold></highlight> is a portion of the embedded software on a network device responsible for receiving configuration parameter change or read requests and/or monitored variable read requests from management application(s). The management client(s) passes such requests on for service by appropriate modules in the embedded software via the configuration manager. Typically the management client corresponds with or designed to specifically interoperate with the particular kind of management application used in the network system. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> A configuration manager <highlight><bold>140</bold></highlight> is embedded systems software responsible for relaying change or read requests from the management client(s) originated on the management station(s) to appropriate servicing modules within the embedded system. Such change or read requests are typically GET and SET operations performed on modules &ldquo;owning&rdquo; referenced configuration parameter(s) and/or monitored variable(s). </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> A network device may also comprise a Permanent Configuration Database <highlight><bold>150</bold></highlight> that includes all permanently stored parameters for the device; the parameters may be stored in any format, including, but not limited to, a command script, XML file, etc. The System Control Module <highlight><bold>170</bold></highlight> is responsible for execution and coordination of actions connected with device initialization, configuration, configuration saving and device shutdown (all aforementioned actions are described in detail later). </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> The embedded system of a network device <highlight><bold>130</bold></highlight> may built from modules such as management clients <highlight><bold>120</bold></highlight>, configuration manager <highlight><bold>140</bold></highlight>, modules <highlight><bold>160</bold></highlight>, and system control module <highlight><bold>170</bold></highlight>, these modules may be designed to be reusable, to minimize costs of software development effort. In some embodiments, a collection of these modules may be reused as whole or in a part to design a new (perhaps different) specialized computing device. The complexity of this task can depend also on a module framework design. A framework may facilitate construction of the target system from the building blocks and give high degree of software reusability from device to device. In particular, embedded system modules may facilitate: (1) orderly initialization, (2) orderly shutdown, and/or (3) orderly command script generation. Orderly Initialization can comprise coordination of modules&apos;activities because some modules always depend on other. Also, as a part of initialization, modules may be configured using permanently stored parameters (a.k.a. registry) and default values. This process can also be coordinated between modules. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> Orderly shutdown may make it possible to achieve so-called graceful shutdown, in which important volatile information may be either preserved (to be available after reboot) or communicated to other active cooperating devices (to react properly). Further, orderly command script generation, when having registry implemented as a console command script, may be important so when the script executes later during initialization, e.g., certain objects can be created before they receive some parameter values. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> Many embodiments may specify a structured modularization framework, eliminating or reducing redundant coding and the hardcoded initialization and shutdown sequencing. Some embodiments may also give permanent configuration database (a.k.a. registry or INI file) format independency, so changing the format may not introduce massive code modifications, further promoting code reusability. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> Referring now to <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, there is shown a node <highlight><bold>250</bold></highlight> capable of changing a module function. The node <highlight><bold>250</bold></highlight> may comprise a permanent configuration database (a.k.a. registry) <highlight><bold>210</bold></highlight>, a command line interpreter (CLI) <highlight><bold>220</bold></highlight>, a system control module <highlight><bold>230</bold></highlight>, an inter-module dependency tree <highlight><bold>240</bold></highlight>, a configuration manager <highlight><bold>270</bold></highlight>, a current configuration database <highlight><bold>260</bold></highlight>, and modules <highlight><bold>280</bold></highlight>, <highlight><bold>290</bold></highlight>, and <highlight><bold>295</bold></highlight>. The permanent configuration database <highlight><bold>210</bold></highlight> may be placed in a permanent data storage device such as a hard drive or a Flash memory and store configuration parameters for modules of node <highlight><bold>250</bold></highlight>. The CLI <highlight><bold>220</bold></highlight> may either be used to generate configuration change requests based on the permanent configuration database <highlight><bold>210</bold></highlight>.contents (on initialization), or to generate a configuration script based on the Current Configuration Database <highlight><bold>260</bold></highlight> to be subsequently placed in Permanent Configuration Database <highlight><bold>210</bold></highlight> (on configuration save). </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> The system controller, a system control module <highlight><bold>230</bold></highlight> in the present embodiment, can be a module responsible for controlling all other modules in an embedded system. The system control module <highlight><bold>230</bold></highlight> may be responsible for a proper system initialization and shutdown and also for ensuring a proper sequence of generated command script. The system control module <highlight><bold>230</bold></highlight> can build an inter-module dependency tree <highlight><bold>240</bold></highlight>, a database, in random access memory (RAM) based on information gathered from modules <highlight><bold>280</bold></highlight>, <highlight><bold>290</bold></highlight>, and <highlight><bold>295</bold></highlight>, which can register with the system control module <highlight><bold>230</bold></highlight> at the first step of their initialization. The system control module <highlight><bold>230</bold></highlight> may use this database to enforce a correct initialization sequence to modules <highlight><bold>280</bold></highlight>, <highlight><bold>290</bold></highlight>, and <highlight><bold>295</bold></highlight>. The inter-module dependency tree <highlight><bold>240</bold></highlight> may also be used during shut down of modules <highlight><bold>280</bold></highlight>, <highlight><bold>290</bold></highlight>, and <highlight><bold>295</bold></highlight> to perform the shut down in an opposite sequence as compared to initialization. The system control module <highlight><bold>230</bold></highlight> may also initiate initialization script generation by instructing the CLI <highlight><bold>220</bold></highlight> to generate commands corresponding to the parameters present in the Current Configuration Database <highlight><bold>260</bold></highlight>, and then store the resulting script in permanent configuration database <highlight><bold>210</bold></highlight>. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> shows an example of events during system initialization. After an loading an embedded system into a computing device, the system control module may be initialized. All other system modules may register <highlight><bold>310</bold></highlight> with system control module, giving their requirements on initialization, by specifying initialization steps and relationships to other modules. At this time, the modules may also register commands with CLI <highlight><bold>360</bold></highlight> and <highlight><bold>350</bold></highlight>. CLI may assign a phase identification (Id) to each command. The initialization steps may include e.g., a resource allocation step, an initialization of used libraries, and an initialization of management interface (CLI, SNMP, etc.). Further, the relationships can define dependencies to other system modules, e.g., IP stack has to be initialized before OSPF router software. Based on registration information, the system control module may determine an inter-module dependency tree <highlight><bold>320</bold></highlight>. The system control module may use the inter-module dependency tree <highlight><bold>320</bold></highlight> to complete initialization <highlight><bold>330</bold></highlight>, <highlight><bold>350</bold></highlight>, and <highlight><bold>360</bold></highlight>, perform device shutdown <highlight><bold>330</bold></highlight>, <highlight><bold>350</bold></highlight>, and <highlight><bold>360</bold></highlight>, and ensure a proper sequence of generated configuration script <highlight><bold>330</bold></highlight> and <highlight><bold>340</bold></highlight>. As the last step, each module configuration may be restored as a result of the following actions: (1) batch CLI session is started <highlight><bold>330</bold></highlight>; (2) a sequence of phase Ids may be taken for each module <highlight><bold>330</bold></highlight>; (3) from the command script <highlight><bold>340</bold></highlight>, the commands matching given phase Id can be executed <highlight><bold>350</bold></highlight>; (4) configuration manager can pass new parameters value to the current configuration database <highlight><bold>360</bold></highlight>, and (5) the new parameters are passed to owning modules <highlight><bold>360</bold></highlight>. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> shows example actions and elements involved in device shutdown. Using the inter-module dependency tree <highlight><bold>410</bold></highlight>, the system control module may determine a proper shutdown sequence for all modules within an embedded system and trigger self-destruction actions in the modules <highlight><bold>420</bold></highlight>. As a result of such action, each module may send notification(s) to any interested parties that its service is being terminated and then may release all used resources and stop. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> illustrates example configuration save actions and some involved embedded system elements. A system configuration may be changed at any time while a device is operating. This configuration change can be regarded as temporary, unless an operator explicitly saves it. If the configuration after altering is not saved, the new configuration will disappear during the next system reboot (and the device will start with a previously saved configuration). The &lsquo;temporary&rsquo; or &lsquo;current&rsquo; configuration is held in current configuration database (located in RAM); the saved or &lsquo;permanent&rsquo; configuration may be kept in permanent configuration database (located on a non-volatile storage, typically Flash memory or a hard disk). In order to optimize space on the non-volatile media, only those parameters, which are different from defaults, may be saved. The sequence of actions is as follows: the system control module may initiate the operation <highlight><bold>530</bold></highlight> and then: (1) CLI script generation session can start <highlight><bold>530</bold></highlight>; (2) for each module a sequence of phase Ids may be requested by CLI <highlight><bold>510</bold></highlight> and can be taken from the inter-module dependency tree <highlight><bold>520</bold></highlight>; (3) parameters matching given phase Id may be retrieved from the current configuration database <highlight><bold>550</bold></highlight> via configuration manager <highlight><bold>540</bold></highlight>; (4) a default parameter value may be taken from an owning module <highlight><bold>570</bold></highlight>; (5) an equivalent console command can be emitted (if the parameter differs from the default value) and saved <highlight><bold>560</bold></highlight> on permanent configuration database. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> Referring now to <cross-reference target="DRAWINGS">FIG. 6</cross-reference>, there is shown a flow chart to change a module function. The flow chart may comprise determining an inter-module dependency tree <highlight><bold>600</bold></highlight>, modifying a module function in accordance with the inter-module dependency tree <highlight><bold>620</bold></highlight>, associating a configuration parameter with an inter-module dependency in said inter-module dependency tree <highlight><bold>660</bold></highlight>, and storing a default value for the configuration parameter <highlight><bold>670</bold></highlight>. Determining an inter-module dependency tree <highlight><bold>600</bold></highlight> may initiate a transaction requesting information to a configuration manager of a node to obtain inter-module dependencies for modules within the node. In other embodiments, determining an inter-module dependency tree <highlight><bold>600</bold></highlight> can comprise modules registering with a system controller. In some nodes, a module handling servicing of configuration parameters for modules of the node may track information about inter-module dependencies and store the information in a MDL. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> Determining an inter-module dependency tree <highlight><bold>600</bold></highlight> can comprise associating a module command with an inter-module dependency <highlight><bold>605</bold></highlight>. Associating the module command with an inter-module dependency <highlight><bold>605</bold></highlight> may comprise associating a transaction to modify a configuration parameter of a module with a dependency on a configuration parameter of a second module. In some embodiments, associating a module command with an inter-module dependency <highlight><bold>605</bold></highlight> can comprise storing an association between the module command and the inter-module dependency in a permanent configuration database or storing the command or reference to the command in a data structure that may imply an association. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> Associating a module command with an inter-module dependency <highlight><bold>605</bold></highlight> can comprise determining a phase for a command of a module <highlight><bold>610</bold></highlight>. Determining a phase for a command of a module <highlight><bold>610</bold></highlight> may identify a sequence for the command in an initialization, reconfiguration, and/or shut down process and associate the phase with the command. Associating a phase with a command can determine commands that may be executed in parallel when a phase is associated with more than one command. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> Modifying a module function in accordance with the inter-module dependency tree <highlight><bold>620</bold></highlight> may initialize, reconfigure, or shut down a function in a module of a node in a manner that maintains global consistency. Maintaining global consistency can comprise modifying configuration parameters in a sequence such that configuration parameters of a module that depend upon configuration parameters of a second module are not inconsistent with the configuration parameters of the second module. Modifying a module function in accordance with the inter-module dependency tree <highlight><bold>620</bold></highlight> may comprise determining a command script based on a command association with an inter-module dependency <highlight><bold>625</bold></highlight>, associating a command of one module with a command of another module based upon an inter-module dependency <highlight><bold>630</bold></highlight>, initializing a module function <highlight><bold>640</bold></highlight>, reconfiguring a module function <highlight><bold>645</bold></highlight>, and shutting down a module function <highlight><bold>650</bold></highlight>. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> Determining a command script based on a command association with an inter-module dependency <highlight><bold>625</bold></highlight> may generate a command console script for a command of a module and associate that command console script with a phase. In some embodiments a command line interface may generate the command console script. Associating a command of one module with a command of another module based upon an inter-module dependency <highlight><bold>630</bold></highlight> may comprise associating a command of one module with a command of another module based upon a phase identification <highlight><bold>635</bold></highlight>. Associating a command of one module with a command of another module based upon a phase identification <highlight><bold>635</bold></highlight> may facilitate command console script generation for initialization, reconfiguration, and shut down processing. The phase identification may comprise a tag indicating the phase of initialization, reconfiguration and shut down as determined from an inter-module dependency tree. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> Initializing a module function <highlight><bold>640</bold></highlight> may configure a module to perform its primary function and can comprise initiating a transaction comprising a module command. In many embodiments, initializing a module function may comprise executing one or more command console scripts associated with a first phase identification then executing one or more command console scripts identified with subsequent phase identifications. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> Reconfiguring a module function <highlight><bold>645</bold></highlight> may comprise initiating the same command transactions in the same sequence as initializing a module function <highlight><bold>640</bold></highlight>. In some embodiments, reconfiguring a module function <highlight><bold>640</bold></highlight> can comprise executing command console script to initialize a module, or a portion thereof. Reconfiguring a module function <highlight><bold>645</bold></highlight> can change the operation of a function in a module. For example, the speed that a first node transmits packages to a second node may be increased by reconfiguring the routing module for the first node. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> Shutting down a module function <highlight><bold>650</bold></highlight> may issue a command to a module in a sequence based on a phase relationship of the command and a second command to shut down a routing protocol for a node and the routing protocol may not be available until it is initialized or reconfigured. Shutting down a module function <highlight><bold>650</bold></highlight> may comprise executing one or more command console scripts in an order based upon phase identifications that are opposite the order of phase identifications used for initializing a module function <highlight><bold>640</bold></highlight>. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> Associating a configuration parameter with an inter-module dependency in said inter-module dependency tree <highlight><bold>660</bold></highlight> may comprise storing a value for a configuration parameter of a function of a module in a permanent configuration database. For example, a configuration manager may receive a configuration parameter change request from a management workstation, effect the configuration parameter change request in the run time variables of a module, store the new configuration parameter values in a current configuration database, and transmit the new configuration parameters along with a reference to the function modified in a module to a permanent configuration database via a CLI. The CLI may store the new configuration parameters for the function in a permanent configuration database and associate that new configuration parameter with a command or command console script designed to modify the configuration parameter during initialization, reconfiguration and shut down of that module function. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> Storing a default value for the configuration parameter <highlight><bold>670</bold></highlight> may store a default value for a configuration parameter in the permanent configuration database. In some embodiments, the default value for the configuration parameter may be stored when command console scripts for that configuration parameter is stored in the permanent configuration database. Modules of the CLI may determine when a default value for a configuration parameter may be used. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> In alternate embodiments, the CLI may associate configuration parameters with phases for initialization, reconfiguration and shut down processes. In further embodiments, remote management workstations may forward configuration parameter change requests to the node and the reconfiguration code or command console script of the node can effect the modifications to the module function. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> Referring now to <cross-reference target="DRAWINGS">FIG. 7</cross-reference>, there is shown another flow chart to change a module function. The flow chart may comprise determining an inter-module dependency tree <highlight><bold>700</bold></highlight> and modifying a module function in accordance with the inter-module dependency tree <highlight><bold>720</bold></highlight>. Determining an inter-module dependency tree <highlight><bold>700</bold></highlight> may initiate transactions to determine inter-module dependencies of modules within the node. Determining an inter-module dependency tree <highlight><bold>700</bold></highlight> can comprise associating a module command with an inter-module dependency <highlight><bold>705</bold></highlight>. Associating a module command with an inter-module dependency <highlight><bold>705</bold></highlight> may place commands of modules in a structure indicating inter-module dependency. For instance, a first command may be received that has no command dependent upon it and it is placed in a first row. A second command may be received that command one is dependent upon so the second command may be placed in a second row. A third command may be received that has no dependencies upon it so the third command may be stored next to the first command in the first row. Finally, a fourth command may be received that the second command is dependent upon so the fourth command may be stored in a fourth row. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> Modifying a module function in accordance with the inter-module dependency tree <highlight><bold>720</bold></highlight> may modify configuration parameters for a module function by initiating module commands in a sequence based upon the inter-module dependency tree. Modifying a module function in accordance with the inter-module dependency tree <highlight><bold>720</bold></highlight> may comprise associating a command of one module with a command of another module based upon a phase identification <highlight><bold>725</bold></highlight>. For example, command one in a first row may be associated with tag <highlight><bold>10</bold></highlight>, command two in a second row may be associated with tag <highlight><bold>20</bold></highlight>, command three in the first row may be associated with tag <highlight><bold>10</bold></highlight>, and command four in the third row may be associated with tag <highlight><bold>20</bold></highlight>. When modifying a module function in accordance with the inter-module dependency tree <highlight><bold>720</bold></highlight> comprises initializing or reconfiguring using commands one through four, command one and three may be executed first, command two may be executed second, and command four may be executed third. On the other hand, when modifying a module function in accordance with the inter-module dependency tree <highlight><bold>720</bold></highlight> comprises shutting down the functions represented by commands one through four, command four may be executed first, command two may be executed second and commands three and one may be executed last. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> Determining a command script based on a command association with an inter-module dependency <highlight><bold>730</bold></highlight> may comprise auto-generating command script to initiate a transaction comprising a command in a sequence based upon the inter-module dependency and may comprise initiating a transaction to instruct a CLI to associate a command console script with a phase identification. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> Referring now to <cross-reference target="DRAWINGS">FIG. 8, a</cross-reference> machine-readable medium embodiment of the present invention is shown. A machine-readable medium includes any mechanism that provides (i.e. stores and or transmits) information in a form readable by a machine (e.g., a computer), that when executed by the machine, can perform the functions described herein. For example, a machine-readable medium may include read only memory (ROM); random access memory (RAM); magnetic disk storage media; optical storage media; flash memory devices; electrical, optical, acoustical or other form of propagated signals (e.g. carrier waves, infrared signals, digital signals, etc.); etc . . . Several embodiments of the present invention can comprise more than one machine-readable medium depending on the design of the machine. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> The machine-readable medium <highlight><bold>800</bold></highlight> may comprise instructions for determining an inter-module dependency tree <highlight><bold>810</bold></highlight> and modifying a module function in accordance with the inter-module dependency tree <highlight><bold>830</bold></highlight>. Determining an inter-module dependency tree <highlight><bold>810</bold></highlight> can comprise instructions for associating a module command with an inter-module dependency <highlight><bold>815</bold></highlight>. Associating a module command with an inter-module dependency <highlight><bold>815</bold></highlight> may comprise instructions to build one or more trees comprising each module command associated with a node. In some embodiments, One or more intermodule dependency trees may be created and may not be associated with each other. Many embodiments comprise a module dependency tree associated with each module registered with a system controller. In some embodiments, the lowest member or members of each tree are associated with a phase for initialization and reconfiguration and the highest member or members are associated with a phase for shut down. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> Modifying a module function in accordance with the inter-module dependency tree <highlight><bold>830</bold></highlight> may comprise instructions for initializing a module function <highlight><bold>835</bold></highlight>, reconfiguring a module function <highlight><bold>840</bold></highlight>, and shutting down a module function <highlight><bold>845</bold></highlight>. In some embodiments, instructions for initializing a module function <highlight><bold>835</bold></highlight> and reconfiguring a module function <highlight><bold>840</bold></highlight> can comprise the same or a portion of the same code or command console script. Initializing a module function <highlight><bold>835</bold></highlight> may comprise instructions to initialize module commands in a sequence beginning with the lowest member of an inter-module dependency tree. In alternative embodiments, initializing a module function <highlight><bold>835</bold></highlight> may comprise instructions for initiating one or more transactions based upon command console script or code and upon one or more trees of the inter-module dependency tree. Similarly, reconfiguring a module function <highlight><bold>840</bold></highlight> can comprise instructions for initiating transactions to modify configuration parameters of a function in a sequence based upon one or more trees in the inter-module dependency tree. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> Shutting down a module function <highlight><bold>845</bold></highlight> may remove a function of a node from service. In addition, a graceful shut down may initiate an alternative module to perform a similar function. For example, shutting down a module function <highlight><bold>845</bold></highlight> can comprise instructions for transmitting commands to a node to create a port, initiate a routing module, routing protocol module, and gateway protocol module as well as commands to shut down a gateway protocol module, routing protocol module, and routing module. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method, comprising: 
<claim-text>determining an inter-module dependency tree; and </claim-text>
<claim-text>modifying a module function in accordance with the inter-module dependency tree. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> further comprising associating a configuration parameter with an inter-module dependency in said inter-module dependency tree. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> further comprising storing a default value for a configuration parameter. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein said determining an inter-module dependency tree comprises associating a module command with an inter-module dependency. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00004">claim 4</dependent-claim-reference> wherein associating a module command with an inter-module dependency comprises determining a phase for a command of a module. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein said modifying a module function comprises determining a command script based on a command association with an inter-module dependency. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein said modifying a module function comprises associating a command of one module with a command of another module based upon an inter-module dependency. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference> wherein associating a command of one module with a command of another module comprises associating a command of one module with a command of another module based upon a phase identification. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein said modifying a module function comprises initializing a module function. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein said modifying a module function comprises reconfiguring a module function. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein said modifying a module function comprises shutting down a module function. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. An apparatus, comprising: 
<claim-text>a system controller; and </claim-text>
<claim-text>a configuration manager coupled to said system controller. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, further comprising a current configuration database coupled to said configuration manager. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, further comprising a permanent configuration database coupled to said configuration manager via a command line interface. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, wherein said system controller comprises circuitry to store an inter-module dependency tree. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, wherein said system controller comprises circuitry to modify a module function in accordance with an inter-module dependency tree. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, wherein said configuration manager comprises circuitry to receive a configuration parameter change request. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, wherein said configuration manager comprises circuitry to modify a module function in accordance with a configuration parameter change request. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. A system, comprising: 
<claim-text>a network component comprising a system controller coupled to a configuration manager; and </claim-text>
<claim-text>a station coupled to said network component. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference>, wherein said node further comprises an inter-module dependency-tree coupled to the system controller. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference>, wherein said node further comprises a permanent configuration parameter database coupled to the configuration manager via a command line interface. </claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference>, wherein said station comprises a server to forward a transaction via said network component. </claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference>, wherein said station comprises a management workstation to configure said network component. </claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. A machine-readable medium containing instructions, which when executed by a machine, cause said machine to perform operations, comprising: 
<claim-text>determining an inter-module dependency tree; and </claim-text>
<claim-text>modifying a module function in accordance with the inter-module dependency tree. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. The machine-readable medium of <dependent-claim-reference depends_on="CLM-00022">claim 24</dependent-claim-reference> wherein said determining an inter-module dependency tree comprises associating a module command with an inter-module dependency. </claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. The machine-readable medium of <dependent-claim-reference depends_on="CLM-00022">claim 24</dependent-claim-reference> wherein said modifying a module function comprises determining a command script based on a command association with an inter-module dependency. </claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. The machine-readable medium of <dependent-claim-reference depends_on="CLM-00022">claim 24</dependent-claim-reference> wherein said modifying a module function comprises associating a command of one module with a command of another module based upon an inter-module dependency. </claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. The machine-readable medium of <dependent-claim-reference depends_on="CLM-00022">claim 24</dependent-claim-reference> wherein said modifying a module function comprises initializing a module function. </claim-text>
</claim>
<claim id="CLM-00029">
<claim-text><highlight><bold>29</bold></highlight>. The machine-readable medium of <dependent-claim-reference depends_on="CLM-00022">claim 24</dependent-claim-reference> wherein said modifying a module function comprises reconfiguring a module function. </claim-text>
</claim>
<claim id="CLM-00030">
<claim-text><highlight><bold>30</bold></highlight>. The machine-readable medium of <dependent-claim-reference depends_on="CLM-00022">claim 24</dependent-claim-reference> wherein said modifying a module function comprises shutting down a module function.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>6</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005273A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005273A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005273A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005273A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005273A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005273A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030005273A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030005273A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030005273A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
