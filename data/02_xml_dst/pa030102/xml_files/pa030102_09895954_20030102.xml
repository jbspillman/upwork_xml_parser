<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005110A1-20030102-P00001.TIF SYSTEM "US20030005110A1-20030102-P00001.TIF" NDATA TIF>
<!ENTITY US20030005110A1-20030102-P00002.TIF SYSTEM "US20030005110A1-20030102-P00002.TIF" NDATA TIF>
<!ENTITY US20030005110A1-20030102-P00003.TIF SYSTEM "US20030005110A1-20030102-P00003.TIF" NDATA TIF>
<!ENTITY US20030005110A1-20030102-P00004.TIF SYSTEM "US20030005110A1-20030102-P00004.TIF" NDATA TIF>
<!ENTITY US20030005110A1-20030102-P00005.TIF SYSTEM "US20030005110A1-20030102-P00005.TIF" NDATA TIF>
<!ENTITY US20030005110A1-20030102-P00006.TIF SYSTEM "US20030005110A1-20030102-P00006.TIF" NDATA TIF>
<!ENTITY US20030005110A1-20030102-P00007.TIF SYSTEM "US20030005110A1-20030102-P00007.TIF" NDATA TIF>
<!ENTITY US20030005110A1-20030102-P00008.TIF SYSTEM "US20030005110A1-20030102-P00008.TIF" NDATA TIF>
<!ENTITY US20030005110A1-20030102-P00009.TIF SYSTEM "US20030005110A1-20030102-P00009.TIF" NDATA TIF>
<!ENTITY US20030005110A1-20030102-P00010.TIF SYSTEM "US20030005110A1-20030102-P00010.TIF" NDATA TIF>
<!ENTITY US20030005110A1-20030102-P00011.TIF SYSTEM "US20030005110A1-20030102-P00011.TIF" NDATA TIF>
<!ENTITY US20030005110A1-20030102-P00012.TIF SYSTEM "US20030005110A1-20030102-P00012.TIF" NDATA TIF>
<!ENTITY US20030005110A1-20030102-P00013.TIF SYSTEM "US20030005110A1-20030102-P00013.TIF" NDATA TIF>
<!ENTITY US20030005110A1-20030102-P00014.TIF SYSTEM "US20030005110A1-20030102-P00014.TIF" NDATA TIF>
<!ENTITY US20030005110A1-20030102-P00015.TIF SYSTEM "US20030005110A1-20030102-P00015.TIF" NDATA TIF>
<!ENTITY US20030005110A1-20030102-P00016.TIF SYSTEM "US20030005110A1-20030102-P00016.TIF" NDATA TIF>
<!ENTITY US20030005110A1-20030102-P00017.TIF SYSTEM "US20030005110A1-20030102-P00017.TIF" NDATA TIF>
<!ENTITY US20030005110A1-20030102-P00018.TIF SYSTEM "US20030005110A1-20030102-P00018.TIF" NDATA TIF>
<!ENTITY US20030005110A1-20030102-P00019.TIF SYSTEM "US20030005110A1-20030102-P00019.TIF" NDATA TIF>
<!ENTITY US20030005110A1-20030102-P00020.TIF SYSTEM "US20030005110A1-20030102-P00020.TIF" NDATA TIF>
<!ENTITY US20030005110A1-20030102-P00021.TIF SYSTEM "US20030005110A1-20030102-P00021.TIF" NDATA TIF>
<!ENTITY US20030005110A1-20030102-P00022.TIF SYSTEM "US20030005110A1-20030102-P00022.TIF" NDATA TIF>
<!ENTITY US20030005110A1-20030102-P00023.TIF SYSTEM "US20030005110A1-20030102-P00023.TIF" NDATA TIF>
<!ENTITY US20030005110A1-20030102-P00024.TIF SYSTEM "US20030005110A1-20030102-P00024.TIF" NDATA TIF>
<!ENTITY US20030005110A1-20030102-P00025.TIF SYSTEM "US20030005110A1-20030102-P00025.TIF" NDATA TIF>
<!ENTITY US20030005110A1-20030102-P00026.TIF SYSTEM "US20030005110A1-20030102-P00026.TIF" NDATA TIF>
<!ENTITY US20030005110A1-20030102-D00000.TIF SYSTEM "US20030005110A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005110A1-20030102-D00001.TIF SYSTEM "US20030005110A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005110A1-20030102-D00002.TIF SYSTEM "US20030005110A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005110A1-20030102-D00003.TIF SYSTEM "US20030005110A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005110A1-20030102-D00004.TIF SYSTEM "US20030005110A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005110A1-20030102-D00005.TIF SYSTEM "US20030005110A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030005110A1-20030102-D00006.TIF SYSTEM "US20030005110A1-20030102-D00006.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005110</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09895954</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010629</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F015/173</ipc>
</classification-ipc-primary>
<classification-ipc-secondary>
<ipc>G06F015/16</ipc>
</classification-ipc-secondary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>709</class>
<subclass>224000</subclass>
</uspc>
</classification-us-primary>
<classification-us-secondary>
<uspc>
<class>709</class>
<subclass>201000</subclass>
</uspc>
</classification-us-secondary>
</classification-us>
<title-of-invention>Multi-threaded system for activating a process using a script engine and publishing data descriptive of the status of the process</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Lyle</given-name>
<middle-name>S.</middle-name>
<family-name>Corbin</family-name>
</name>
<residence>
<residence-us>
<city>Bothell</city>
<state>WA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Joseph</given-name>
<middle-name>A.</middle-name>
<family-name>Porkka</family-name>
</name>
<residence>
<residence-us>
<city>Bellevue</city>
<state>WA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<assignee>
<organization-name>Microsoft Corporation</organization-name>
<address>
<city>Redmond</city>
<state>WA</state>
</address>
<assignee-type>02</assignee-type>
</assignee>
<correspondence-address>
<name-1>LEYDIG VOIT &amp; MAYER, LTD</name-1>
<name-2></name-2>
<address>
<address-1>TWO PRUDENTIAL PLAZA, SUITE 4900</address-1>
<address-2>180 NORTH STETSON AVENUE</address-2>
<city>CHICAGO</city>
<state>IL</state>
<postalcode>60601-6780</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">The invention relates to a method and system for accessing the status of a process executing either locally or remotely. The invention also involves a process management system that invokes an executable process, monitors it, and exchanges status information relative to the process with one or more connected machines. A local or remote application or machine invokes the process by communicating with the process management system over an established connection. The process management system invokes the requested action on the user&apos;s behalf by activating a script engine containing a sequence of executable commands and/or routines that initiate and enable the process. Status information related to the invoked action is consistently stored in a publicly accessible data structure as the process is in execution. Any machines that are connected with the process management system over the established connection can retrieve the data structure containing the process information. Because the method of invoking the process and retrieving the status information is not dependent upon the explicit mechanisms of the source code used to implement the process, the invention can be used in relation to any type of process. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">REFERENCE TO APPENDIX A </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> A portion of the disclosure of this patent document, particularly Appendix A: Primary Class Implementations for the Multi-threaded Process Management System, contains material subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document of the patent disclosure, as it appears in the U.S. Patent and Trademark Office patent files or records, but otherwise reserves all copyright rights whatsoever. </paragraph>
</section>
<section>
<heading lvl="1">TECHNICAL FIELD </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> In general, the invention relates to the retrieval of information descriptive of the status of a process, and more particularly, to network-based systems for accessing the information related to the status of any computer executable process executing either locally or remotely. </paragraph>
</section>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> Nowadays, almost all computing devices within the workplace are tied to a network. Many large and small companies alike employ a network to disseminate information throughout the organization. Typical uses of networks include linking multiple computers throughout the organization together, providing access to company wide information via a corporate intranet or the Internet, and connecting multiple computers to a specific printer or fax machine. The pervasive use of networks within the workplace can also be seen frequently within many households, where computers are commonly linked to a network, such as the Internet, to provide WEB access and e-mail messaging services. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> In networked computing environments such as those described above, it is often desirable for a user to determine the status of a process that was initiated by their computer, such as the status of a document sent to a remote printer. According to many conventional computing systems, the status of the print job can be easily determined and even viewed with a simple network printer status tool that monitors the printing process as it is in action. Many other types of processes can also be initiated and monitored via a network in a well-known and conventional manner, as long as the tool used to communicate the status information is written specifically for that process. In the example of the print job, to communicate print status, the tool performing this action is programmed specifically for this purpose. The same print status tool cannot communicate the status of other tasks such as the delivery of an e-mail message or the detection of a computer virus. Thus, the client that invoked the print job status tool cannot use the same tool to view the status of a separate and independent process. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> Because of this limitation, obtaining status information related to one or more independent processes requires a customized tool for each individual process. This requirement is undesirable, however, in situations where the overall process involves multiple independent sub-processes, such as in a distributed computing/networking environment. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> The distributed compilation of a large software program provides a good example of how related, yet independently executed processes or tasks can occur within a distributed computing environment. In this example, several developers, often from different groups within an organization, share the responsibility of successfully compiling a software application. This procedure requires that each developer compile their developed source code, and then they must merge their code with that of the other developers to yield a fully operational end product. In order to successfully accomplish this, each developer must be able to monitor any one of the distributed compile processes at any time (i.e., another developer&apos;s compile process). However, due to the limitations imposed by conventional monitoring systems, there is no easy way for developers to monitor the status of each independent process in execution. The developer is only able to obtain the status information relative to his or her own compile process. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> To overcome the limitations of conventional status information retrieval systems, a convenient means of determining the status of one or more independently executing processes is required. Also, a convenient means of retrieving status information related to the executable processes from any location is needed. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> The present invention fulfills these requirements by employing a multi-threaded process management system that maintains consistent status information related to an executable process, and facilitates the exchange of the information between machines over a network. The information is collected by the process management system throughout the execution of the process and stored in a retrievable data structure. Any machine having access to the network can communicate with the process management system, and subsequently retrieve the data structure containing the status information. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> Another feature of the invention allows a local or remote user to invoke a process by communicating with the process management system from over a network. The process management system invokes the requested action on the user&apos;s behalf by activating a script engine that interprets a sequence of executable script commands and/or routines that initiate and enable the process. The status information related to the invoked action is subsequently stored in a publicly accessible data structure as the process is in execution. Because the method of invoking the process and retrieving the process information is not dependent upon the process itself, the invention can be used in connection with any computer executable process. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> Additional features and advantages of the invention will be made apparent from the following detailed description of illustrative embodiments that proceeds with reference to the accompanying figures.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> While the appended claims set forth the features of the present invention with particularity, the invention, together with its objects and advantages, may be best understood from the following detailed description taken in conjunction with the accompanying drawings of which: </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a block diagram generally illustrating an exemplary computer system on which the present invention resides; </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a high-level block diagram illustrating the overall architecture of the invention; </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a simple flow chart illustrating the interaction between the user interface and the process management system to invoke an executable process; </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a flow chart illustrating the interaction between the user interface and the process management system to obtain status information related to an executable process distributed amongst a plurality of nodes over the network; </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a block diagram illustrating the basic components of the process management system and the interactivity between the various components; </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is a flow chart illustrating the overall process of communication between the user interface and the process management system.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF THE INVENTION </heading>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> Turning to the drawings, wherein like reference numerals refer to like elements, the invention is described hereinafter in the context of a computing environment. Although it is not required for practicing the invention, the invention is described as it is implemented by computer-executable instructions, such as program modules, that are executed by a PC (PC). Generally, program modules include routines, programs, objects, components, data structures and the like that perform particular tasks or implement particular abstract data types. In the illustrated embodiment described in detail herein, the various program modules or routines employed by the invention will be described according to the Microsoft Component Object Model (COM) and Distributed Component Object Model (DCOM). As is well known in the art, COM is an object oriented specification and software development methodology that allows independent program modules, or components, to connect and interact with relative ease. Likewise, DCOM extends the capabilities of COM by providing remote processing capability to COM object. However, while the invention will be described in the context of COM and DCOM embodiment, the invention is not meant to be limited to any specific architecture. The invention may be implemented according to other methodologies or protocols such as COBRA (Common Object Request Broker Architecture), SOM/DSOM (Distributed System Object Model), or the Java-based Remote Method Invocation (RMI) protocol. Moreover, languages/methodologies based on modular or object-oriented programming such as C/C&plus;&plus;, or those requiring procedural execution can also be used. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> Although the invention is described hereinafter in the context of a PC-based embodiment, other hardware environments may also make use of the invention. For example, the invention may be practiced in hand-held devices, multi-processor systems, microprocessor-based or programmable consumer electronics, network PCs, minicomputers, mainframe computers and the like. The invention is also well suited for use in distributed computing environments, where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote memory storage devices. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> While the invention may be incorporated into many types of computing environments as suggested above, the following detailed description of the invention is set forth in the context of an exemplary general-purpose computing device in the form of a conventional PC <highlight><bold>20</bold></highlight>. </paragraph>
</section>
<section>
<heading lvl="1">The Exemplary Computing Environment Computing Environment </heading>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> Before describing the invention in detail, the computing environment in which the invention operates is described hereinafter in connection with <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> The PC <highlight><bold>20</bold></highlight> includes a processing unit <highlight><bold>21</bold></highlight>, a system memory <highlight><bold>22</bold></highlight>, and a system bus <highlight><bold>23</bold></highlight> that couples various system components including the system memory to the processing unit <highlight><bold>21</bold></highlight>. The system bus <highlight><bold>23</bold></highlight> may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. The system memory includes read only memory (ROM) <highlight><bold>24</bold></highlight> and random access memory (RAM) <highlight><bold>25</bold></highlight>. A basic input/output system (BIOS) <highlight><bold>26</bold></highlight>, containing the basic routines that help to transfer information between elements within the PC <highlight><bold>20</bold></highlight>, such as during start-up, is stored in ROM <highlight><bold>24</bold></highlight>. The PC <highlight><bold>20</bold></highlight> further includes a hard disk drive <highlight><bold>27</bold></highlight> for reading from and writing to a hard disk <highlight><bold>60</bold></highlight>, a magnetic disk drive <highlight><bold>28</bold></highlight> for reading from or writing to a removable magnetic disk <highlight><bold>29</bold></highlight>, and an optical disk drive <highlight><bold>30</bold></highlight> for reading from or writing to a removable optical disk <highlight><bold>31</bold></highlight> such as a CD ROM or other optical media. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> The hard disk drive <highlight><bold>27</bold></highlight>, magnetic disk drive <highlight><bold>28</bold></highlight>, and optical disk drive <highlight><bold>30</bold></highlight> are connected to the system bus <highlight><bold>23</bold></highlight> by a hard disk drive interface <highlight><bold>32</bold></highlight>, a magnetic disk drive interface <highlight><bold>33</bold></highlight>, and an optical disk drive interface <highlight><bold>34</bold></highlight>, respectively. The drives and their associated computer-readable media provide nonvolatile storage of computer readable instructions, data structures, program modules and other data for the PC <highlight><bold>20</bold></highlight>. Although the exemplary environment described herein employs a hard disk <highlight><bold>60</bold></highlight>, a removable magnetic disk <highlight><bold>29</bold></highlight>, and a removable optical disk <highlight><bold>31</bold></highlight>, it will be appreciated by those skilled in the art that other types of computer readable media which can store data that is accessible by a computer, such as magnetic cassettes, flash memory cards, digital video disks, Bernoulli cartridges, random access memories, read only memories, and the like may also be used in the exemplary operating environment. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> A number of program modules may be stored on the hard disk <highlight><bold>60</bold></highlight>, magnetic disk <highlight><bold>29</bold></highlight>, optical disk <highlight><bold>31</bold></highlight>, ROM <highlight><bold>24</bold></highlight> or RAM <highlight><bold>25</bold></highlight>, including an operating system <highlight><bold>35</bold></highlight>, one or more applications programs <highlight><bold>36</bold></highlight>, other program modules <highlight><bold>37</bold></highlight>, and program data <highlight><bold>38</bold></highlight>. A user may enter commands and information into the PC <highlight><bold>20</bold></highlight> through input devices such as a keyboard <highlight><bold>40</bold></highlight> and a pointing device <highlight><bold>42</bold></highlight>. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit <highlight><bold>21</bold></highlight> through a serial port interface <highlight><bold>46</bold></highlight> that is coupled to the system bus, but may be connected by other interfaces, such as a parallel port, game port or a universal serial bus (USB). A monitor <highlight><bold>47</bold></highlight> or other type of display device is also connected to the system bus <highlight><bold>23</bold></highlight> via an interface, such as a video adapter <highlight><bold>48</bold></highlight>. In addition to the monitor, PCs typically include other peripheral output devices, not shown, such as speakers and printers. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> The PC <highlight><bold>20</bold></highlight> may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer <highlight><bold>49</bold></highlight>. The remote computer <highlight><bold>49</bold></highlight> may be another PC, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the PC <highlight><bold>20</bold></highlight>, although only a memory storage device <highlight><bold>50</bold></highlight> has been illustrated in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. The logical connections depicted in <cross-reference target="DRAWINGS">FIG. 1</cross-reference> include a local area network (LAN) <highlight><bold>51</bold></highlight> and a wide area network (WAN) <highlight><bold>52</bold></highlight>. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet. As will be discussed later on in greater detail with regards to the invention, the remote computer <highlight><bold>49</bold></highlight> is a primary node on which a process management system executes. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> When used in a LAN networking environment, the PC <highlight><bold>20</bold></highlight> is connected to the local network <highlight><bold>51</bold></highlight> through a network interface or adapter <highlight><bold>53</bold></highlight>. When used in a WAN networking environment, the PC <highlight><bold>20</bold></highlight> typically includes a modem <highlight><bold>54</bold></highlight> or other means for establishing communications over the WAN <highlight><bold>52</bold></highlight>. The modem <highlight><bold>54</bold></highlight>, which may be internal or external, is connected to the system bus <highlight><bold>23</bold></highlight> via the serial port interface <highlight><bold>46</bold></highlight>. In a networked environment, program modules depicted relative to the PC <highlight><bold>20</bold></highlight>, or portions thereof, may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> In the description that follows, the invention will be described with reference to acts and symbolic representations of operations that are performed by one or more computers, unless indicated otherwise. As such, it will be understood that such acts and operations, which are at times referred to as being computer-executed, include the manipulation by the processing unit of the computer of electrical signals representing data in a structured form. This manipulation transforms the data or maintains it at locations in the memory system of the computer, which reconfigures or otherwise alters the operation of the computer in a manner well understood by those skilled in the art. The data structures where data is maintained are physical locations of the memory that have particular properties defined by the format of the data. However, while the invention is being described in the foregoing context, it is not meant to be limiting as those of skill in the art will appreciate that various of the acts and operations described hereinafter may also be implemented in hardware. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> The present invention accesses status information that is generated by one or more nodes as a result of the execution of a computer-executable process. As described herein, the executable process is any computer-executable code, routines or sequence of instructions that enable a specific task or action to be invoked by a computer. This includes simple tasks, such as the transferring of a file, or more complex tasks such as performing a complete build of a software product or controlling an electromechanical process. According to the methods of the invention, the process is implemented according to a standard scripting language, such as those defined by the ECMAScript standard. This includes script languages such as Microsoft JScript and VBScript, or Netscape/AOL JavaScript. The script language, or code, is then parsed and executed by a script engine, which is a script language interpreter that resides on the node responsible for executing the process. Also, the status information related to the executable process can be any data or parameters that are generated by the script code that enables the process. This includes information such as the current state of the process, the characteristics of the computer system in which the process is being run, data objects, arrays and any other data that can be put into a script variable. Because the process is implemented as executable script code, the status information that is generated is dependent upon the customized design of the script itself. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> Turning to <cross-reference target="DRAWINGS">FIGS. 2 and 3</cross-reference>, a user interface <highlight><bold>100</bold></highlight>, executing on a personal computer such as that shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, is capable of communicating with a remote computer <highlight><bold>49</bold></highlight> over an established network connection <highlight><bold>51</bold></highlight>/<highlight><bold>52</bold></highlight>. The user interface <highlight><bold>100</bold></highlight> is best characterized as the portion of a computer application that displays useful information to the user. For instance, many Windows-based applications employ a graphical user interface having various menus, display objects and buttons that represent specific features of the application. In general, the user interface <highlight><bold>100</bold></highlight> contains text, graphical objects and/or instructions that allow the user of the computer <highlight><bold>20</bold></highlight> to perform various tasks. Virtually any computer-implemented process or application that renders the display of text or images to a monitor <highlight><bold>47</bold></highlight> for performing a task is a user interface, and falls within the scope of the invention. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> In the illustrated embodiment, the user interface <highlight><bold>100</bold></highlight> is a web page. The web page is generated by a web browser application <highlight><bold>102</bold></highlight>, which is capable of processing web-based content (including script code) received from over a network <highlight><bold>51</bold></highlight>/<highlight><bold>52</bold></highlight>, and displaying text and graphical information to the user from the monitor <highlight><bold>47</bold></highlight>. Embedded within the web page <highlight><bold>100</bold></highlight> is an Active X object, referred to as the RemoteMTScriptProxy object <highlight><bold>104</bold></highlight>(<highlight><italic>a</italic></highlight>), that employs Active Scripting technology. Active Scripting is a well-known technology that allows a script engine to be encapsulated into a COM object, such as an Active X object. The RemoteMTScriptProxy object <highlight><bold>104</bold></highlight>(<highlight><italic>a</italic></highlight>) enables script code contained within the web page <highlight><bold>100</bold></highlight> to communicate with other machines or objects remotely. In particular, the script code is written to perform remote processing tasks. One such task is to establish a connection with a remotely located primary node <highlight><bold>106</bold></highlight>, on which a process management system <highlight><bold>108</bold></highlight> resides. Another task is to invoke the execution or action of a process that is maintained by the process management system <highlight><bold>108</bold></highlight>. As discussed previously, the process is written in executable script code. In order to activate this code, which resides within a physical memory location on the primary node <highlight><bold>49</bold></highlight>, the user interface <highlight><bold>100</bold></highlight> must submit a request to the process management system <highlight><bold>108</bold></highlight> (event <highlight><bold>204</bold></highlight>). The user interface accomplishes this by accepting a command to activate the process as input (event <highlight><bold>200</bold></highlight>). The command is input into the user interface screen manually by a user of the Web browser <highlight><bold>102</bold></highlight>, such as by clicking an action button embedded within the user interface <highlight><bold>100</bold></highlight> with the mouse <highlight><bold>42</bold></highlight>. Clicking the action button results in the initiation of the script code contained within the web page <highlight><bold>100</bold></highlight>, which in turn activates the RemoteMTScriptProxy object <highlight><bold>104</bold></highlight>(<highlight><italic>a</italic></highlight>) to communicate with the primary node <highlight><bold>106</bold></highlight>. While not shown in FIGS. <highlight><bold>2</bold></highlight> or <highlight><bold>3</bold></highlight>, the command can also be entered from a command line entry field that implements the connectivity of the RemoteMTScriptProxy object <highlight><bold>104</bold></highlight>(<highlight><italic>a</italic></highlight>). Or, as another alternative, the command can be input without human intervention by a separate application or process that called the user interface. Any means by which the desired process or action to be invoked is specified to the user interface screen is acceptable. The input command also includes descriptive parameters that are necessary to properly execute the process. For instance, a command to execute a process for transferring a file from one location to another must include other descriptive parameters/information such as the name of the file to be transferred, its current location, and the desired location. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> The other task of the user interface is to establish a COM/DCOM connection with a process management system <highlight><bold>108</bold></highlight> executing on a primary node <highlight><bold>106</bold></highlight>. The process management system <highlight><bold>108</bold></highlight> performs numerous tasks, which include storing status information related to the executable process, managing multiple script threads, processes, and script engines <highlight><bold>114</bold></highlight>/<highlight><bold>116</bold></highlight>, and maintaining connections with one or more user interfaces <highlight><bold>100</bold></highlight> or remote machines <highlight><bold>122</bold></highlight>. The full architecture and operation of the process management system is discussed in greater detail hereinafter. The process management system provides a means by which any computer executable process can be implemented, accessed, and maintained within a distributed or non-distributed processing environment. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> With reference again to <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, once the user command is received by the user interface <highlight><bold>100</bold></highlight>, it is processed, and a connection with the process management system <highlight><bold>108</bold></highlight> is established by activating the script code contained within the web page <highlight><bold>100</bold></highlight> (event <highlight><bold>202</bold></highlight>). As is commonly known in the art, COM/DCOM allows remote and local applications to interact with each other and the operating system upon which they execute through collections of function calls known as interfaces. The established DCOM connection implements the IConnectedMachine interface <highlight><bold>110</bold></highlight>, which allows the user of the web page <highlight><bold>100</bold></highlight> to communicate with and access information directly from the process management system <highlight><bold>108</bold></highlight>. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> Once the IConnectedMachine interface <highlight><bold>110</bold></highlight> is created, the command received by the user interface <highlight><bold>100</bold></highlight> is transmitted to the process management system <highlight><bold>108</bold></highlight> (event <highlight><bold>204</bold></highlight>). As shown in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, the process management system implements a RemoteMTScriptStub object <highlight><bold>104</bold></highlight>(<highlight><italic>b</italic></highlight>). This is an instantiated version of the RemoteMTScriptProxy object <highlight><bold>104</bold></highlight>(<highlight><italic>a</italic></highlight>), and enables the remote communication abilities of DCOM. The command is received by the RemoteMTScriptStub <highlight><bold>104</bold></highlight>(<highlight><italic>b</italic></highlight>), which in turn activates the DLocalMTScriptEvents interface <highlight><bold>112</bold></highlight>. This interface activates one or more script engines <highlight><bold>114</bold></highlight>/<highlight><bold>116</bold></highlight> to execute the script code contained within memory <highlight><bold>50</bold></highlight> that corresponds to the command&mdash;the desired process (event <highlight><bold>206</bold></highlight>). </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> As the process is in execution, the script code communicates with the process management system via the IGlobalMTScript interface <highlight><bold>118</bold></highlight> (event <highlight><bold>210</bold></highlight>). This interface allows the scripts in execution by the process management system <highlight><bold>108</bold></highlight> to send status information about the process to the process management system. The status information is then stored within a data structure (not shown) that is maintained by the process management system (event <highlight><bold>212</bold></highlight>). The IGlobalMTScript interface <highlight><bold>118</bold></highlight> is also used by the scripts to notify the process management system <highlight><bold>108</bold></highlight> of events that occur during process execution, such as the occurrence of an error or the completion of the process. To further facilitate the exchange of information, any remote machines <highlight><bold>122</bold></highlight> connected to the process management system through the IConnectedMachine interface <highlight><bold>110</bold></highlight> will send event notifications via the DRemoteMTScriptEvents interface <highlight><bold>120</bold></highlight>. This is the primary interface that the connected machines <highlight><bold>122</bold></highlight> use to communicate with the process management system. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> A critical feature of the invention is the ability to allow one or more nodes to access the status information generated by the scripts in execution from over the network. Any machine having the appropriate access to the network upon which the primary node <highlight><bold>49</bold></highlight> is located, can access the process management system, and thus access the status information. Appropriate access refers to the ability of the machine to penetrate a network security infrastructure that may be in place within the network of the primary node <highlight><bold>49</bold></highlight>. Machines that are capable of connecting with the process management system <highlight><bold>108</bold></highlight> can poll it for data using a standard polling mechanism, or can explicitly request the data from a user interface <highlight><bold>100</bold></highlight>; and subsequently receive the data structure containing the status information. <cross-reference target="DRAWINGS">FIG. 2</cross-reference> and the flowchart of <cross-reference target="DRAWINGS">FIG. 4</cross-reference> further illustrate the interaction that takes place between the process management system <highlight><bold>108</bold></highlight>, and any connected nodes <highlight><bold>122</bold></highlight> and <highlight><bold>124</bold></highlight> to provide this ability. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> The machine boundaries <highlight><bold>130</bold></highlight> as shown in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, indicate the locality of the various nodes that are capable of connecting with the process management system through the IConnectedMachine interface <highlight><bold>110</bold></highlight>. In one instance, one or more user/client nodes <highlight><bold>124</bold></highlight> can connect with the process management system through a user interface <highlight><bold>100</bold></highlight> such as a web page. This method of accessing the process management system was discussed in foregoing paragraphs of the description. In another instance, one or more remote nodes <highlight><bold>122</bold></highlight> can connect to the process management system <highlight><bold>108</bold></highlight> on the primary node <highlight><bold>49</bold></highlight>. This method of accessing the process management system does not require a connection being established from that user interface <highlight><bold>100</bold></highlight>. Instead, the script code within memory <highlight><bold>50</bold></highlight> on the primary node is capable of formulating connections with other process management systems executing on one or more remote nodes <highlight><bold>122</bold></highlight>. The following paragraphs further describe this ability. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> Script code can be written to connect directly to COM/DCOM objects. Because of this ability, the script code that is executed by the process management system <highlight><bold>108</bold></highlight> on the primary node <highlight><bold>49</bold></highlight> can in turn connect to other process management systems executing on the one or more remote nodes <highlight><bold>122</bold></highlight> by formulating a DCOM connection, and implementing the IConnectedMachine interface <highlight><bold>110</bold></highlight>. The remote nodes have the same general internal architecture as that of the primary node <highlight><bold>49</bold></highlight>. Each has a process management system <highlight><bold>108</bold></highlight>, a local memory for accessing executable script code, and one or more script engines for processing and interpreting executable scripts. However, each node contains a different set of script code that performs a different task than that of the primary node, and contains different script engines for executing this code. Thus, the executable process can be executed solely by the primary node, as illustrated in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>, or can be distributed amongst a plurality of independent nodes over the network as illustrated in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> With reference to <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, the user/client nodes <highlight><bold>124</bold></highlight> that connect through the user interface <highlight><bold>100</bold></highlight> obtain status information related to the executable process by polling the process management system <highlight><bold>108</bold></highlight> on the primary node <highlight><bold>49</bold></highlight> (event <highlight><bold>300</bold></highlight>). Once this request for information is received by the process management system through the IConnectedMachine interface <highlight><bold>110</bold></highlight>, the process management system accesses the data structure that it maintains during the execution of the process (event <highlight><bold>302</bold></highlight>). As discussed previously, the script code in execution on the primary node updates this data structure consistently. Yet, when the process is distributed amongst a plurality of nodes, each of the nodes store status information generated by the scripts into its own data structure. Therefore, in order to return complete process information to the user, the process management system <highlight><bold>108</bold></highlight> on the primary node must be able to obtain status information from all of the nodes <highlight><bold>122</bold></highlight> that execute the overall process. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> To accomplish this, the process management system <highlight><bold>108</bold></highlight> consistently polls the one or more remote nodes <highlight><bold>122</bold></highlight> for updated information over the IConnectedMachine interface <highlight><bold>110</bold></highlight> (event <highlight><bold>304</bold></highlight>). Upon receiving the request, the one or more remote nodes pass the information stored within their respective data structures to the primary node. This information is then stored into the data structure on the primary node, and sent to the requesting user/client node <highlight><bold>124</bold></highlight> (events <highlight><bold>306</bold></highlight>-<highlight><bold>310</bold></highlight>). Because the scripts are able to formulate connections with other process management systems, data can be easily exchanged between a plurality of nodes within a distributed network. Each machine communicates with the next via the IConnectedMachine interface <highlight><bold>110</bold></highlight>, and event notifications are Fired to each machine using the DRemoteMTScriptEvents interface <highlight><bold>120</bold></highlight>. Furthermore, the connections enable the plurality of nodes to submit commands and/or requests to invoke the action of the executable process, thus increasing the ability of the nodes to work together to perform complex tasks. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> The flowchart of <cross-reference target="DRAWINGS">FIG. 6</cross-reference> summarizes the steps illustrated in <cross-reference target="DRAWINGS">FIGS. 3 and 4</cross-reference>, and shows the overall communication flow of the invention. Specifically, it shows the logical steps that are taken by the process management system and a user/client <highlight><bold>124</bold></highlight> or remote node <highlight><bold>122</bold></highlight>, to facilitate the exchange of status information. Moreover, it illustrates the sequence of steps that are taken by the user/client nodes <highlight><bold>124</bold></highlight> and/or remote nodes <highlight><bold>122</bold></highlight> to connect to the process management system and invoke the executable process. As shown, the process management system <highlight><bold>108</bold></highlight> responds to various requests and commands received from the user, and responds accordingly. Certain events are handled directly by the script code that implements the process, while other events are handled by the process management system itself. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> To promote a better understanding of the invention, a detailed description of the internal architecture of the process management system is described below. While the general description is in the context of specific class names, objects, and function calls implemented using COM/DCOM, the invention is not meant to be limited to the particular implementation disclosed herein. Those skilled in the art will recognize that the invention can be implemented according to various programming techniques and methodologies. The process management system will be discussed with reference to the block diagram of <cross-reference target="DRAWINGS">FIG. 5</cross-reference>. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> The process management system is a computer executable application that resides upon a primary node <highlight><bold>49</bold></highlight>, and is capable of executing multiple script threads. Scripting threads are simply threads that execute according to a scripting language, such as JavaScript, VBScript or PERL. Programmers often prefer to use scripting languages rather than compiled languages because scripting languages provide an easy means of executing source code that avoids many of the complexities of the operating system. For instance, scripts are interpreted and processed directly by a separate program called a script engine <highlight><bold>114</bold></highlight>/<highlight><bold>116</bold></highlight>, and so do not need to rely explicitly on the message passing facilities of the operating system in order to execute, as in some machine executable languages </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> One of the primary purposes of the process management system <highlight><bold>108</bold></highlight> is to provide a platform upon which any computer executable process can operate. To achieve this, the process to be executed cannot rely upon the process management system to interpret, compile or process the source code that defines the process. With this requirement in mind, a customized set of script code that is written to perform a specific task or procedure, is used to implement the process. The process management system <highlight><bold>108</bold></highlight> is only responsible for providing the means of activating the script code, monitoring it during its execution, and sharing status information generated by the script code. Thus, the process management system is not designed specifically for the particular executable process, but is instead a framework upon which any process can be executed. It does not execute the process (interpret the source code) directly, but simply hosts one or more script engines for interpreting executable scripts. Furthermore, the process management system does not require any process specific mechanisms to collect and retrieve status information. It simply implements interfaces that allow data to be exchanged without regard to the methods or functions of the source code that implements the process. For these reasons, the invention is suitable for executing any process. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> The process management system <highlight><bold>108</bold></highlight> is comprised of various inter-dependent components for performing various tasks. Because one of the primary functions of the process management system is to provide multi-threaded scripting behavior, a base thread-aware class provides the basic building blocks for the components of the process management system. This base class, named CThreadComm, provides all the basic behaviors of a script thread, including creation, initialization, cross-thread communication (both synchronous and asynchronous), and thread locking for cross-thread data access, Derivative classes of CThreadComm include, but are not limited to, CMTScript <highlight><bold>406</bold></highlight>, CMachine <highlight><bold>420</bold></highlight>, CProcessThread <highlight><bold>424</bold></highlight> and CScriptHost <highlight><bold>408</bold></highlight>. Each of the classes implements a different thread, or object, of execution within the process management system. This offers a distinct advantage over other scripting technologies, such as Windows Script Host, which does not support multi-threaded execution. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> Threads communicate to each other using mechanisms provided by CThreadComm. These mechanisms are similar to the way the Windows operating system handles window messages. For instance, CThreadComm implements a SendToThread( ) method that sends a synchronous message and waits for a response. If asynchronous notification is desired, then an object can use PostToThread( ). Both objects participating in the communication must derive from CThreadComm. Also, to further support multi-threaded operation within the process management system, each of the classes of CThreadComm provides different levels of functionality and threaded behavior. The definitions and coded based implementations of these classes are shown in Appendix A. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 5</cross-reference>, the various components that comprise the process management system are shown. The primary components are the script hosting module <highlight><bold>400</bold></highlight>, the process execution module <highlight><bold>402</bold></highlight>, the remote communication module <highlight><bold>404</bold></highlight>, and the CMTScript module <highlight><bold>406</bold></highlight>. A description of each of the components follows. </paragraph>
</section>
<section>
<heading lvl="1">Script Hosting Module </heading>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> The script hosting module <highlight><bold>400</bold></highlight> is the part of the process management system that manages the script engines <highlight><bold>114</bold></highlight> and multiple threads of script execution. It also provides behavior to the script engines that gives them extended capability. Some of this additional behavior includes the ability for the scripts in different threads to communicate, spawn new script threads, and other extended tasks beyond the normal capabilities of the script engine. The script hosting module contains three major components: 1) source code designed for managing and hosting one or more Active Script engines, 2) implementation of the IGlobalMTScript interface <highlight><bold>118</bold></highlight>, and 3) code that fires events into the appropriate script engines using the DLocalMTScriptEvents interface <highlight><bold>112</bold></highlight>. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> The process management system integrates with the script engine <highlight><bold>114</bold></highlight> via the CScriptHost class <highlight><bold>408</bold></highlight>. When this class is called, due to a request to execute script code, it takes a path to the script file that corresponds to the request. The process management system then instantiates the appropriate script engine <highlight><bold>114</bold></highlight> to enable the process. One of the requirements of Active Script engines is that they be provided a script site, which is simply an object on which function callbacks can be made. CScriptHost creates a CScriptSite class <highlight><bold>408</bold></highlight> and passes this object to the script engine. The process management system then loads the script file that corresponds to the desired process to be executed, and passes it to the script engine. The script engine parses the script file, executes global code, and returns. In most cases very little is done at this stage besides initializing global variables. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> The actual execution of meaningful code is not performed until the ScriptMaino event (an event defined by the process management system, not Active Scripting) is fired. This is because of the way in which the script engine operates. By convention, the script engine cannot be transitioned to the CONNECT (ready to execute) state until it has returned from the initial parsing of the script, and the engine must be in the CONNECT state for event firing to work. At this point the script engine is transitioned to the CONNECT state, which hooks up the DLocalMTScriptEvents interface (described below). Then the ScriptMain( ) event is fired, which is when the script performs all of its behavior. Once ScriptMain( ) returns, the script is considered finished and is shut down and deleted. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> The process management system has what is called a &ldquo;primary&rdquo; script (not shown). It is the only script for which the user tells the process management system its location. The primary script is automatically loaded by the process management system when it is initiated, and if a failure happens finding, loading, or parsing this script then the process management system reports the error and terminates. All other scripts are spawned by the primary script using methods on IGlobalMTScript <highlight><bold>118</bold></highlight>. Thus, requests to activate the executable process and other events are fired into the primary script first. The primary script then activates the specified script engine through the DLocaIMTScriptEvents interface <highlight><bold>112</bold></highlight> to begin process execution. Once this script is fully executed, ScriptMain( ) is returned to signal the termination of the process, and the script is deleted. However, unlike other scripts, the primary script does not terminate when it returns from ScriptMain( ). </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> If the primary script terminates (with an error, for example), then the process management system cannot continue and subsequently terminates. Script errors are reported by the script engine <highlight><bold>114</bold></highlight> to the process management system <highlight><bold>108</bold></highlight> via the script site <highlight><bold>410</bold></highlight>. Once a script error occurs, then that script can no longer execute and must be terminated. The process management system <highlight><bold>108</bold></highlight> gives the script a chance to clean things up and log the error by firing another method implemented by the process management system, OnScriptError( ), before terminating the script. The script can choose whether the error should be reported to the user. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> As discussed previously, the script hosting module <highlight><bold>400</bold></highlight> provides behavior to the script engines that gives them extended capability. While Active Script engines <highlight><bold>114</bold></highlight> allow users to write and execute script logic, more complex behavior such as launching other processes or threads is not provided by the script engine itself. For Active Scripting, this type of behavior must be provided by the process management system or by creating COM objects that can be used directly by the script engine. In the present invention, this extended behavior is provided by the process management system according to a global object property (not shown). Specifically, when an Active Script engine <highlight><bold>114</bold></highlight> encounters an identifier within the script code, such as a function name or variable that it cannot resolve, it will check with the global object to see if it can provide that function or variable. In this way, executable tasks or functions that are not generally capable of being performed by the script engine <highlight><bold>114</bold></highlight> can be performed. By using the global object, the process management system <highlight><bold>108</bold></highlight> is able to allow scripts to spawn other scripts, send email, synchronize with each other, launch processes, etc. The software developer can customize the functions or variables provided by the global object to fit their specific requirements. Also, the global object implements the IGlobalMTScript interface <highlight><bold>118</bold></highlight> to allow the process management system <highlight><bold>108</bold></highlight> and the script engine <highlight><bold>114</bold></highlight> to interact. </paragraph>
</section>
<section>
<heading lvl="1">Process Execution Module </heading>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> The process execution module <highlight><bold>402</bold></highlight> is the part of the script host that handles the execution and monitoring of local processes on the machine. Local processes can be any executable applications, functions, or the like that reside within the application program space <highlight><bold>36</bold></highlight> or a memory location <highlight><bold>50</bold></highlight> on the primary node <highlight><bold>49</bold></highlight>. Any of the scripts can launch a local process by calling the global object. The script specifies whether the process should be executed synchronously or asynchronously, whether its window should be minimized or not, whether to capture its output, etc. The process execution module spawns the local process, monitors it, and reports status information back to the script. This status information is kept around for some time after the process terminates. This allows the script to have access to the captured output and exit code of the process even after it has terminated. Once a dead process is purged, then attempts to obtain the exit code will fail with an invalid parameter error. </paragraph>
</section>
<section>
<heading lvl="1">Remote Communication Module </heading>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> Along with allowing multi-threaded scripts and rich execution of local processes, the third main goal of the process management system is to make it easy to obtain and share status information with other machines within a distributed network environment. To accomplish this, the process management system <highlight><bold>108</bold></highlight> registers DCOM objects on the machine that can be instantiated (communicated with) on other machines. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> When the process management system is run, it registers the RemoteMTScriptStub <highlight><bold>104</bold></highlight>(<highlight><italic>b</italic></highlight>) as a remotable object. This object implements IConnectedMachine <highlight><bold>110</bold></highlight> and has DRemoteMTScriptEvents <highlight><bold>120</bold></highlight> as an event interface. As a remotable object, other machines can instantiate the object and communicate to it over the network. As is commonly known in the art, DCOM allows the object to be communicated with as if it were on the primary node <highlight><bold>49</bold></highlight> even when it is on a remote node <highlight><bold>122</bold></highlight>/<highlight><bold>124</bold></highlight> (both local and remote communication are possible). Once the object is called, the remote node has full access to the IConnectedMachine <highlight><bold>110</bold></highlight> and DRemoteMTScriptEvents <highlight><bold>120</bold></highlight> communication interfaces. If the object is called from a user interface such as the HTML-based interface of <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, the RemoteMTScriptProxy object <highlight><bold>104</bold></highlight>(<highlight><italic>a</italic></highlight>) must be used to facilitate the communication interfaces. Those skilled in the art will recognize however, that other types of user interfaces can be used which do not require the usage of the RemoteMTScriptProxy object <highlight><bold>104</bold></highlight>(<highlight><italic>a/b</italic></highlight>). For example, a Win32 based user interface can be programmatically designed to facilitate the remote communication without the need for a proxy object. Nonetheless, the user interface <highlight><bold>100</bold></highlight> as shown in the illustrated embodiment is capable of processing Web-based content. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> IConnectedMachine <highlight><bold>110</bold></highlight> is the interface implemented by the Remote Communication Module <highlight><bold>404</bold></highlight> that allows remote nodes <highlight><bold>122</bold></highlight>/<highlight><bold>124</bold></highlight> to access the process management system. Through this interface, the remote machine can perform three tasks, which are 1) obtain information about the machine the process management system <highlight><bold>108</bold></highlight> is running on, 2) submit a request to activate an executable process to the primary script, and 3) retrieve the data structure that contains status information related to the executable process. The information about the process management system <highlight><bold>108</bold></highlight> includes the OS, platform, version, and any other system information that the connected machine may be interested in. As for the second task, a request to activate an executable process is submitted by the remote nodes <highlight><bold>122</bold></highlight>/<highlight><bold>124</bold></highlight> by calling the IConnectedMachine interface <highlight><bold>110</bold></highlight>, and passing the command to invoke the action to the primary script. The primary script then invokes the scripts and script engines <highlight><bold>114</bold></highlight> that correspond to the request. It is up to the scripts to determine how to interpret the command and take the appropriate action to fulfill the request. With regards to the third task, the remote nodes <highlight><bold>122</bold></highlight>/<highlight><bold>124</bold></highlight> retrieve the data structure by accessing the process management system <highlight><bold>108</bold></highlight> through IConnectedMachine <highlight><bold>110</bold></highlight>. As will be discussed later, the data structure that is sent can be a PublicData structure that contains complete status information, or a StatusValue data structure that contains information regarding a particular event. </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> As scripts are in execution, they can send information to any remote nodes <highlight><bold>122</bold></highlight>/<highlight><bold>124</bold></highlight> that are connected to the process management system <highlight><bold>108</bold></highlight> via IConnectedMachine. For example, the script can send a notification to a connected node to alert it that the data structure has changed, or that the executable process is complete. This can be done using the event interface DRemoteMTScriptEvents (not shown in <cross-reference target="DRAWINGS">FIG. 5</cross-reference> but in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>). The one or more remote nodes <highlight><bold>122</bold></highlight>/<highlight><bold>124</bold></highlight> wishing to receive notification of certain events give the process management system an event sink for DRemoteMTScriptEvents <highlight><bold>120</bold></highlight>. Then, the script in execution can call the global object to send a message to any connected machines. If no machines are connected, the message is discarded. </paragraph>
</section>
<section>
<heading lvl="1">CMTScript Module </heading>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> The CMTScript module <highlight><bold>406</bold></highlight> is the main glue that connects all of the other components of the process management system <highlight><bold>108</bold></highlight> together. It acts as a liaison between the remote communication module <highlight><bold>404</bold></highlight> and the script hosting module <highlight><bold>400</bold></highlight> so that they can send messages to each other. Requests received over the IConnectedMachine interface <highlight><bold>110</bold></highlight> from the one or more connected nodes <highlight><bold>122</bold></highlight>/<highlight><bold>124</bold></highlight> or from local processes <highlight><bold>418</bold></highlight> are passed from the remote communication module <highlight><bold>404</bold></highlight> to the script hosting module <highlight><bold>400</bold></highlight> using the methods of CMTScript. The script hosting module also delegates certain tasks to the CMTScript module <highlight><bold>406</bold></highlight> such as the launching of the primary script, the running of processes, and the storage of data that is generated by the scripts. The CMTScript module also keeps track of all current and recently executed scripts and processes that are spawned during process execution. Furthermore, the CMTScript module handles command-line parameters and the program registry, and stores/loads the default configuration for the process management system <highlight><bold>108</bold></highlight> (*.exe). </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> During process execution, the scripts generate status information related to the executable process. To ensure that this information is shared between nodes, the process management system <highlight><bold>108</bold></highlight> maintains a data structure that is accessible to the one or more nodes <highlight><bold>122</bold></highlight>/<highlight><bold>124</bold></highlight> connected with the process management system <highlight><bold>108</bold></highlight>. This data structure is called PublicData <highlight><bold>416</bold></highlight>, and is implemented by the CMTScript module <highlight><bold>406</bold></highlight>. Any data that a script puts into PublicData <highlight><bold>416</bold></highlight> is immediately accessible from a remote machine <highlight><bold>122</bold></highlight>/<highlight><bold>124</bold></highlight>. This feature essentially allows the scripts to &ldquo;publish&rdquo; information about the task they are performing, or store data that they have obtained from some other source, etc. This can be data such as the current state of the process (idle, busy, completed) or the type of process in execution (master, slave, standalone). Any data whatsoever can be put into the PublicData structure; it is up to the scripts to determine what gets placed there. PublicData is the data structure that is returned to the user interface <highlight><bold>100</bold></highlight> or the remote nodes <highlight><bold>122</bold></highlight> when the process management system is polled for status information. </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> The CMTScript module <highlight><bold>406</bold></highlight> also provides two other data structures to facilitate the exchange of information between nodes. These are the StatusValue <highlight><bold>412</bold></highlight> and PrivateData <highlight><bold>414</bold></highlight> data structures. StatusValue <highlight><bold>412</bold></highlight> is similar to the PublicData structure in that it is visible to the one or more connected nodes <highlight><bold>122</bold></highlight>/<highlight><bold>124</bold></highlight> via the IConnectedMachine interface <highlight><bold>110</bold></highlight>. However, the data is limited to only a maximum number of integer values n, where n is variable (by a software developer) according to the needs of the process management system. The advantage of the StatusValue <highlight><bold>412</bold></highlight> data structure is that it stores less information, and so can be retrieved by remote machines <highlight><bold>122</bold></highlight>/<highlight><bold>124</bold></highlight> much faster than the larger PublicData <highlight><bold>416</bold></highlight>. For example, a script may want to simply provide an indication as to whether or not an error has occurred in its processing. Rather than send the complete set of status information to the user/client <highlight><bold>124</bold></highlight> via PublicData <highlight><bold>416</bold></highlight>, the StatusValue data structure <highlight><bold>412</bold></highlight> can be sent/retrieved to indicate if an error happened (or perhaps show a count of errors). StatusValue provides a quick indication of an event that occurs during process execution, and can be quickly and efficiently retrieved by remote nodes. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> Any script thread can read from or write to either of these data structures mentioned above, and all other script threads will be able to see the changes. Thus, PublicData and Private data are accessible remotely by one or more nodes, and locally by script threads in execution on the machine. The PrivateData data structure <highlight><bold>414</bold></highlight> differs from PublicData <highlight><bold>416</bold></highlight> and StatusValue <highlight><bold>412</bold></highlight>, however, in that it is not accessible to the remote machines <highlight><bold>122</bold></highlight>/<highlight><bold>124</bold></highlight> via the IConnectedMachine interface <highlight><bold>110</bold></highlight>. Instead, PrivateData is accessible to only the script threads that are spawned during process execution. PrivateData can be used by the script threads to store information that relates to the execution of the process, such as temporary information that was retrieved from other machines, data regarding what commands have been sent from a remote machine <highlight><bold>122</bold></highlight>/<highlight><bold>124</bold></highlight>, or a list of remote machines <highlight><bold>122</bold></highlight>/<highlight><bold>124</bold></highlight> that are currently connected. The PrivateData data structure is useful for ensuring cross-thread communication between multiple script threads, particularly when the process is distributed amongst a plurality of nodes. </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> Overall, the present invention provides a means in which computer executable processes can be invoked and subsequently monitored by one or more nodes from over a network. The process is written in a scripting language that is executable by a script engine, and can be executed by a single primary node or distributed amongst a plurality of nodes tied to the network. By distributing the process amongst a plurality of nodes, the process is broken down further into a plurality of sub processes, where each sub process is independently executed by one of the plurality of nodes. This is desired in many situations to decrease the amount of time required to complete a full computer executable process by a single machine. Distribution of the process across multiple nodes also avoids the drainage of resources that occurs when a single machine is left to perform large scale computing tasks. The present invention provides an easy means by which the processes can be run independently, but monitored and executed dynamically from over the network. </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> Unlike conventional process monitoring systems, the process management system <highlight><bold>108</bold></highlight> operates independently of the executable process. In this respect, it operates regardless of the specific mechanisms, OS dependencies or methods of the programming language in which the process is implemented. Instead, it simply manages one or more script engines, which provide the ability to interpret and compile a process written in script. Another aspect of the invention is that the process management system <highlight><bold>108</bold></highlight> provides the necessary communication channels needed to exchange data generated by the scripts between nodes, interact with the scripts to store status information related to the executable process, and send notification of events to any connected machines. Still further, the present invention manages multiple scripts threads during the execution of the process, and provides mechanisms by which these script threads may communicate with each other, and other processes. These mechanisms are provided by a global object, which is an object that extends the capabilities of the scripting engines. This is necessary because some script engines (e.g. JScript) do not have any built in mechanisms to allow scripts to perform events that are extrinsic to the operation of the script code. Examples include the ability to call local processes, spawn new script threads, etc. Ultimately, the invention can be practiced in any situation where process execution and status information retrieval is to be accomplished from over a network. </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> All of the references cited herein, including patents, patent applications, and publications, are hereby incorporated in their entireties by reference. </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> In view of the many possible embodiments to which the principles of this invention may be applied, it should be recognized that the embodiment described herein with respect to the drawing figures is meant to be illustrative only and should not be taken as limiting the scope of invention. For example, those skilled in the art will recognize that the various components and mechanisms of the process management system as detailed in the figures can be implemented according to other programming methodologies, including but not limited to DSOM, COBRA, and RMI. Furthermore, those of skill in the art will recognize that the elements of the illustrated embodiment shown in software may be implemented in hardware and vice versa or that the illustrated embodiment can be modified in arrangement and detail without departing from the spirit of the invention. Therefore, the invention as described herein contemplates all such embodiments as may come within the scope of the following claims and equivalents thereof. 
<image file="US20030005110A1-20030102-P00001.TIF" id="EMI-00001"></image>
<image file="US20030005110A1-20030102-P00002.TIF" id="EMI-00002"></image>
<image file="US20030005110A1-20030102-P00003.TIF" id="EMI-00003"></image>
<image file="US20030005110A1-20030102-P00004.TIF" id="EMI-00004"></image>
<image file="US20030005110A1-20030102-P00005.TIF" id="EMI-00005"></image>
<image file="US20030005110A1-20030102-P00006.TIF" id="EMI-00006"></image>
<image file="US20030005110A1-20030102-P00007.TIF" id="EMI-00007"></image>
<image file="US20030005110A1-20030102-P00008.TIF" id="EMI-00008"></image>
<image file="US20030005110A1-20030102-P00009.TIF" id="EMI-00009"></image>
<image file="US20030005110A1-20030102-P00010.TIF" id="EMI-00010"></image>
<image file="US20030005110A1-20030102-P00011.TIF" id="EMI-00011"></image>
<image file="US20030005110A1-20030102-P00012.TIF" id="EMI-00012"></image>
<image file="US20030005110A1-20030102-P00013.TIF" id="EMI-00013"></image>
<image file="US20030005110A1-20030102-P00014.TIF" id="EMI-00014"></image>
<image file="US20030005110A1-20030102-P00015.TIF" id="EMI-00015"></image>
<image file="US20030005110A1-20030102-P00016.TIF" id="EMI-00016"></image>
<image file="US20030005110A1-20030102-P00017.TIF" id="EMI-00017"></image>
<image file="US20030005110A1-20030102-P00018.TIF" id="EMI-00018"></image>
<image file="US20030005110A1-20030102-P00019.TIF" id="EMI-00019"></image>
<image file="US20030005110A1-20030102-P00020.TIF" id="EMI-00020"></image>
<image file="US20030005110A1-20030102-P00021.TIF" id="EMI-00021"></image>
<image file="US20030005110A1-20030102-P00022.TIF" id="EMI-00022"></image>
<image file="US20030005110A1-20030102-P00023.TIF" id="EMI-00023"></image>
<image file="US20030005110A1-20030102-P00024.TIF" id="EMI-00024"></image>
<image file="US20030005110A1-20030102-P00025.TIF" id="EMI-00025"></image>
<image file="US20030005110A1-20030102-P00026.TIF" id="EMI-00026"></image>
</paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">We claim: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method for accessing status information related to a process that is executable by one or more nodes from over a network, the method comprising: 
<claim-text>retrieving status information related to an executable process by a process management system executing on a primary node; and </claim-text>
<claim-text>storing status information related to the executable process into a data structure, wherein the data structure is available to any node capable of accessing the process management system. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. A computer-readable medium having stored thereon computer-executable instructions for performing the method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising: invoking one or more script engines by the process management system to execute script code that performs the action of the executable process, wherein the process management system handles multiple script threads during the execution of the process. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference>, wherein the one or more script engines are maintained by a process management system that executes on the one or more nodes. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00004">claim 4</dependent-claim-reference>, wherein the one or more nodes include the primary node. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the step of retrieving includes polling the process management system on the one or more nodes to obtain status information related to the executable process. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference>, wherein the step of polling is performed by the process management system residing on the primary node over an established connection with the one or more nodes. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference>, wherein the one or more nodes include the primary node. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the step of retrieving includes receiving status information from the one or more nodes that are polled by the process management system. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, wherein the status information is generated by script code that is executed by one or more script engines that reside on the one or more nodes. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein the one or more nodes include the primary node. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the step of storing is performed by the process management system executing on the primary node. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the step of storing further includes: 
<claim-text>placing the status information relative to the executable process into a private data structure by the process management system on the primary node, wherein the data structure is accessible to only the script threads that are spawned during the execution of the process. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the step of storing further includes: 
<claim-text>placing the status information relative to the executable process into a status value data structure that is accessible to any node capable of accessing the process management system executing on the primary node. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, wherein the status value data structure comprises data for providing an indication of an event that occurs during the execution of the process. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising: establishing a connection between a process management system executing on the one or more nodes and the process management system residing on the primary node, wherein the connection is established by the script code in execution by the one or more script engines. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising: 
<claim-text>establishing a connection between one or more nodes and the process management system residing on the primary node, wherein the connection is established from a user interface executing on the one or more nodes; and </claim-text>
<claim-text>accessing the process management system from over the established connection by the user interface executing on the one or more nodes. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference>, wherein the step of establishing includes accepting a command as input by the user interface to establish a connection with the process management system executing on the primary node. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference>, wherein the step of accessing includes accepting a command as input by the user interface to invoke the action of the executable process by the process management system from over the established connection. </claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference>, wherein the step of accessing includes accepting a command as input by the user interface to poll the process management system for status information from over the established connection. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference>, wherein the user interface receives messages from the process management system over the established connection. </claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference>, wherein the messages contain information that is descriptive of the primary node. </claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference>, wherein the messages contain information that is descriptive of a particular event that occurs during the execution of the process. </claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference>, wherein the messages contain a data structure that is generated as a result of the execution of the script code by the one or more script engines to indicate the status of the executable process. </claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. A computer-readable medium having computer executable components comprising: 
<claim-text>a first component for hosting one or more script engines, and for managing script threads that are spawned during the execution of a process; </claim-text>
<claim-text>a second component for handling the execution and monitoring of local processes that are launched during the execution of script code by the one or more script engines; </claim-text>
<claim-text>a third component for: 
<claim-text>(i) receiving and accepting requests from one or more nodes to establish a connection over a network; </claim-text>
<claim-text>(ii) receiving commands from the one or more nodes from over an established connection to invoke the action of the executable process; </claim-text>
<claim-text>(iii) receiving commands from the one or more nodes from over the established connection to request for information that is descriptive of the primary node; and </claim-text>
<claim-text>(iv) sending messages to the one or more nodes from over the established connection in response to the requests and commands received from the one or more nodes. </claim-text>
</claim-text>
<claim-text>a fourth component for: 
<claim-text>(i) enabling messages to be passed between the first component and the third component; </claim-text>
<claim-text>(ii) launching the execution of a primary script file on behalf of the first component, wherein the primary script file spawns the execution of the one or more script engines in response to a request received over the established connection to invoke an executable process; </claim-text>
<claim-text>(iii) storing information related to one or more script threads and local processes in execution; and </claim-text>
<claim-text>(iv) storing status information relative to the executable process into a data structure that is accessible to the script threads. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>, wherein the first component further comprises: a primary script file for spawning the execution of any of the one or more script engines in response to a request to invoke the executable process, the request indicating a specific script file to execute.. </claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00022">claim 26</dependent-claim-reference>, wherein the primary script file is automatically loaded onto the primary node for execution when the process management system is initiated. </claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00022">claim 26</dependent-claim-reference>, wherein a failure to load the primary script file onto the primary node results in the first component indicating failure and terminating the established connection. </claim-text>
</claim>
<claim id="CLM-00029">
<claim-text><highlight><bold>29</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00022">claim 26</dependent-claim-reference>, wherein the request is made by one or more nodes over an established connection. </claim-text>
</claim>
<claim id="CLM-00030">
<claim-text><highlight><bold>30</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00022">claim 26</dependent-claim-reference>, wherein the request is made by a local process over an established connection. </claim-text>
</claim>
<claim id="CLM-00031">
<claim-text><highlight><bold>31</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>, wherein the one or more script engines hosted by the first component terminate the executable process when an execution error occurs. </claim-text>
</claim>
<claim id="CLM-00032">
<claim-text><highlight><bold>32</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>, wherein the first component further comprises: a global object for extending the behavior of the one or more script engines, the script engine obtaining an identifier from the global object to perform a specific task upon encountering the identifier during the execution of the script code and determining that it cannot be interpreted. </claim-text>
</claim>
<claim id="CLM-00033">
<claim-text><highlight><bold>33</bold></highlight>. The computer-readable medium of claim <highlight><bold>325</bold></highlight>, wherein the identifier is an executable script variable having instructions for performing a specific task. </claim-text>
</claim>
<claim id="CLM-00034">
<claim-text><highlight><bold>34</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00033">claim 32</dependent-claim-reference>, wherein the global object implements a communication channel between the first component and the one or more script engines to enable the one or more script engines to interact with the first component. </claim-text>
</claim>
<claim id="CLM-00035">
<claim-text><highlight><bold>35</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00033">claim 32</dependent-claim-reference>, wherein the global object implements a communication channel between the first component and the one or more script engines to enable the first component to interact with the one or more script engines. </claim-text>
</claim>
<claim id="CLM-00036">
<claim-text><highlight><bold>36</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>, wherein the second component launches local processes that are called by a script in execution using the global object, and reports the status information and data generated by the local processes back to the calling script. </claim-text>
</claim>
<claim id="CLM-00037">
<claim-text><highlight><bold>37</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>, wherein the fourth component receives information from the second component that is descriptive of the local processes in execution by the one or more script engines. </claim-text>
</claim>
<claim id="CLM-00038">
<claim-text><highlight><bold>38</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>, wherein the fourth component receives status information from the one or more script threads and stores the information into a public data structure that is accessible to the one or more nodes capable of establishing a connection with the first component. </claim-text>
</claim>
<claim id="CLM-00039">
<claim-text><highlight><bold>39</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>, wherein the fourth component receives status information from the one or more script threads and stores the information into a private data structure that is accessible to only the script threads in operation during process execution. </claim-text>
</claim>
<claim id="CLM-00040">
<claim-text><highlight><bold>40</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>, wherein the fourth component receives status information from the one or more script threads and stores the information into a status value data structure that is accessible to the one or more nodes capable of establishing a connection with the first component. </claim-text>
</claim>
<claim id="CLM-00041">
<claim-text><highlight><bold>41</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00044">claim 40</dependent-claim-reference>, wherein the status value data structure contains data for providing an indication of an event that occurs during the execution of the process. </claim-text>
</claim>
<claim id="CLM-00042">
<claim-text><highlight><bold>42</bold></highlight>. A system for accessing status information that is stored on a primary node, wherein the status information is related to a process that is executable by one or more nodes from over a network, the system comprising: 
<claim-text>one or more user interfaces for invoking the executable process and retrieving status information generated by one or more script engines in execution from over a network; </claim-text>
<claim-text>a multiple threaded process management system executing on a primary node for collecting and storing status information related to the executable process from the one or more nodes; </claim-text>
<claim-text>at least one script engine maintained by the process management system for accessing and executing script code; and </claim-text>
<claim-text>at least one database having stored therein script code for enabling the executable process, wherein the database is accessible by the at least one script engine. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00043">
<claim-text><highlight><bold>43</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00044">claim 42</dependent-claim-reference>, wherein the one or more user interfaces establish a connection over the network with the process management system executing on the primary node. </claim-text>
</claim>
<claim id="CLM-00044">
<claim-text><highlight><bold>44</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00044">claim 42</dependent-claim-reference>, wherein the one or more user interfaces are executed by one or more nodes tied to the network. </claim-text>
</claim>
<claim id="CLM-00045">
<claim-text><highlight><bold>45</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00044">claim 44</dependent-claim-reference>, wherein the one or more nodes include the primary node. </claim-text>
</claim>
<claim id="CLM-00046">
<claim-text><highlight><bold>46</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00044">claim 42</dependent-claim-reference>, wherein the one or more user interfaces accept as input commands to establish a connection with the process management system executing on the primary node. </claim-text>
</claim>
<claim id="CLM-00047">
<claim-text><highlight><bold>47</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00044">claim 42</dependent-claim-reference>, wherein the one or more user interfaces accept as input, commands to invoke the action of the executable process by the process management system, and sends, requests to invoke the action of the executable process to the process management system from over the established connection. </claim-text>
</claim>
<claim id="CLM-00048">
<claim-text><highlight><bold>48</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00044">claim 42</dependent-claim-reference>, wherein the one or more user interfaces accept as input commands to poll the process management system for status information, and sends requests to poll the process management system for status information from over the established connection. </claim-text>
</claim>
<claim id="CLM-00049">
<claim-text><highlight><bold>49</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00044">claim 42</dependent-claim-reference>, wherein the one or more user interfaces receive messages from the process management system over the established connection in response to the polling. </claim-text>
</claim>
<claim id="CLM-00050">
<claim-text><highlight><bold>50</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00044">claim 49</dependent-claim-reference>, wherein the messages contain information that is descriptive of the primary node. </claim-text>
</claim>
<claim id="CLM-00051">
<claim-text><highlight><bold>51</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00044">claim 49</dependent-claim-reference>, wherein the messages contain information that is descriptive of a particular event that occurs during the execution of the process. </claim-text>
</claim>
<claim id="CLM-00052">
<claim-text><highlight><bold>52</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00044">claim 49</dependent-claim-reference>, wherein the messages contain a data structure that is generated as a result of the execution of the script code by the one or more script engines to indicate the status of the executable process. </claim-text>
</claim>
<claim id="CLM-00053">
<claim-text><highlight><bold>53</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00044">claim 42</dependent-claim-reference>, wherein the process management system accepts connection requests from one or more user interfaces operating on one or more nodes from over the established connection. </claim-text>
</claim>
<claim id="CLM-00054">
<claim-text><highlight><bold>54</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00055">claim 53</dependent-claim-reference>, wherein the one or more nodes include the primary node. </claim-text>
</claim>
<claim id="CLM-00055">
<claim-text><highlight><bold>55</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00044">claim 42</dependent-claim-reference>, wherein the process management system receives requests to invoke, the action of the executable process from the one or more nodes connected to the process management system. </claim-text>
</claim>
<claim id="CLM-00056">
<claim-text><highlight><bold>56</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00044">claim 42</dependent-claim-reference>, wherein the process management system continuously polls the one or more nodes connected to the process management system to obtain status information related to the executable process. </claim-text>
</claim>
<claim id="CLM-00057">
<claim-text><highlight><bold>57</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00044">claim 42</dependent-claim-reference>, wherein the process management system stores the information into a public data structure that is accessible to the one or more nodes capable of establishing a connection with the first component. </claim-text>
</claim>
<claim id="CLM-00058">
<claim-text><highlight><bold>58</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00044">claim 42</dependent-claim-reference>, wherein the process management system stores the status information relative to the process into a private data structure that is accessible to only the script threads in operation during process execution. </claim-text>
</claim>
<claim id="CLM-00059">
<claim-text><highlight><bold>59</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00044">claim 42</dependent-claim-reference>, wherein the process management system stores the status information relative to the executable process into a status value data structure that is accessible to the one or more nodes having access to the status information. </claim-text>
</claim>
<claim id="CLM-00060">
<claim-text><highlight><bold>60</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00055">claim 59</dependent-claim-reference>, wherein the status value data structure contains data for providing an indication of a particular event that occurs during the execution of the process. </claim-text>
</claim>
<claim id="CLM-00061">
<claim-text><highlight><bold>61</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00044">claim 42</dependent-claim-reference>, wherein the process management system receives requests for status information relative to the executable process from the one or more nodes connected to the process management system. </claim-text>
</claim>
<claim id="CLM-00062">
<claim-text><highlight><bold>62</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00044">claim 42</dependent-claim-reference>, wherein the process management system sends the public data structure to the one or more nodes in response to the request. </claim-text>
</claim>
<claim id="CLM-00063">
<claim-text><highlight><bold>63</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00044">claim 42</dependent-claim-reference>, wherein the process management system sends the status value data structure to the one or more nodes in response to the request.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>4</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005110A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005110A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005110A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005110A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005110A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005110A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030005110A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
