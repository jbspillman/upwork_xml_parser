<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005021A1-20030102-D00000.TIF SYSTEM "US20030005021A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005021A1-20030102-D00001.TIF SYSTEM "US20030005021A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005021A1-20030102-D00002.TIF SYSTEM "US20030005021A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005021A1-20030102-D00003.TIF SYSTEM "US20030005021A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005021A1-20030102-D00004.TIF SYSTEM "US20030005021A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005021A1-20030102-D00005.TIF SYSTEM "US20030005021A1-20030102-D00005.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005021</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09895979</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010629</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F017/00</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>709</class>
<subclass>001000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Methods and apparatus in a logging system for the tracking of tasks solely based on function for data analysis</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Rajeeta</given-name>
<middle-name>Lalji</middle-name>
<family-name>Shah</family-name>
</name>
<residence>
<residence-us>
<city>Austin</city>
<state>TX</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Lorin</given-name>
<middle-name>Evan</middle-name>
<family-name>Ullmann</family-name>
</name>
<residence>
<residence-us>
<city>Austin</city>
<state>TX</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<assignee>
<organization-name>International Business Machines Corporation</organization-name>
<address>
<city>Aromonk</city>
<state>NY</state>
<country>
<country-code>US</country-code>
</country>
</address>
<assignee-type>02</assignee-type>
</assignee>
<correspondence-address>
<name-1>Duck W. Yee</name-1>
<name-2>Carstens, Yee &amp; Cahoon, LLP</name-2>
<address>
<address-1>P.O. Box 802334</address-1>
<city>Dallas</city>
<state>TX</state>
<postalcode>75380</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A method, system, and computer program product for the creation and logging of a taskID is provided. In one embodiment, a component initiates a task and requests a task identification (TaskID) from a log task manager. The taskID follows this task (which may flow across multiple components or ORBs) until completion. The TaskID is passed in the thread context in local methods and in the message context in remote method invocations. The taskID is then logged with message and trace data from each of the components through which the task flows that generate a trace or message log. </paragraph>
</subdoc-abstract>
<subdoc-description>
<cross-reference-to-related-applications>
<heading lvl="1">CROSS REFERENCE TO RELATED APPLICATIONS </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> The present application is related to co-pending U.S. patent application Ser. No. ______ (Client Docket No. AUS920010284US1) entitled &ldquo;METHOD AND APPARATUS FOR DYNAMIC CONFIGURABLE LOGGING OF ACTIVITIES IN A DISTRIBUTED COMPUTING SYSTEM&rdquo;, to co-pending U.S. patent application Ser. No. ______ (Client Docket No. AUS920010496US1) entitled &ldquo;METHODS AND APPARATUS IN INFORMATION MANAGEMENT SYSTEM PROVIDING ADDING DATA AND BOOKMARKS TO EXISTING INFORMATION LOGGED&rdquo;, to co-pending U.S. patent application Ser. No. ______ (Client Docket No. AUS920010533US1) entitled &ldquo;METHODS AND APPARATUS IN DISTRIBUTED REMOTE LOGGING SYSTEM FOR REMOTE ADHOC DATA ANALYSIS CUSTOMIZED WITH MULTILEVEL HIERARCHICAL LOGGER TREE&rdquo;, and to co-pending U.S. patent application Ser. No. ______ (Client Docket No. AUS920010549US1) entitled &ldquo;METHODS AND APPARATUS IN A LOGGING SYSTEM FOR THE ADAPTIVE HANDLER REPLACEMENT IN ORDER TO RECEIVE PRE-BOOT INFORMATION&rdquo; filed even date herewith. The content of the above mentioned commonly assigned, co-pending U.S. patent applications are hereby incorporated herein by reference for all purposes. </paragraph>
</cross-reference-to-related-applications>
<summary-of-invention>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> 1. Technical Field </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> The present invention relates generally to computer network environments, and more specifically to logging services in distributed, multilevel architectures. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> 2. Description of Related Art </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> Computers have come to epitomize modern life. Today, computers are used for much more than simply computing. For example, banking transactions are often conducted through automated teller machines (ATMs) connected via networks to central processing centers that keep track of transactions while computerized telephone switching systems manage the millions of calls generated each day. Furthermore, computers are integral to both peoples personal life as well as to their business life. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> As computers became more widespread in the workplace, new ways to harness their potential developed. Thus, with increasing use of computers for tasks other than simple computing has come an increase in complexity. Furthermore, as computers are increasingly networked together to provide even more functionality, that complexity is increased exponentially. To keep these networked computers operating and, therefore, ensure that ATM transactions, telephone calls, and business continue to operate smoothly, requires the work of administrators to monitor the systems and correct errors as they occur. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> One tool that aids administrators in keeping networks operational is logging. Logging is the process of recording system events so that those actions can be reviewed later. Thus, if an error occurs, that error may be logged with other information to allow an administrator to discover the source of the problem and correct it. However, in networked systems, things occurring in various components of the system must be correlated to determine the ultimate cause of a problem. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> Today data correlation is done using time-stamp to find related tasks flow with a single log. This works OK when the number of machine is small, the number of tasks is low or the interrelationship between tasks is low (messages look different to user). However, in installation with a thousand or more machines with at least that many administrators, a simple time stamp is not good enough for human data correlation. In addition, remote proxy calls (tasks that use components in two or more different Object Request Broker (ORB) machines) make this correlation more difficult because a single transaction can span numerous machines. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> Prior attempts to solve this problem have used the idea of using a thread identification (ID) in a native operating system (OS) to track a program&apos;s execution. Such prior attempts include a 1997 International Business Machine distributed thread mechanism and method. This system was thread based and related to ensuring that for a distributed transaction, all portions are completed which solved the problem of allocating threads and tracking all operations completed between client and server systems. Another prior attempt is described in U.S. Pat. No. 6,205,465 entitled &ldquo;Component extensible parallel execution of multiple threads assembled from program components specified with partial inter-component sequence information&rdquo; which used parallel processing enablement to schedule execution of multiple threads on separate processors. These methods work fine in a single thread execution model, but become unmanageable in multiple threads across multiple machines. In the case of single machines, it is known who spawned the additional threads, whereas in the remote ORB the origin of the task is unknown. Therefore, it would be desirable to have an improved method and system for logging events in large networks. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> The present invention provides a method, system, and computer program product for the creation and logging of a taskID. In one embodiment, a component initiates a task and requests a task identification (TaskID) from a log task manager. The taskID follows this task (which may flow across multiple components or ORBs) until completion. The TaskID is passed in the thread context in local methods and in the message context in remote method invocations. The taskID is then logged with message and trace data from each of the components through which the task flows that generate a trace or message log. </paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> The novel features believed characteristic of the invention are set forth in the appended claims. The invention itself, however, as well as a preferred mode of use, further objectives and advantages thereof, will best be understood by reference to the following detailed description of an illustrative embodiment when read in conjunction with the accompanying drawings, wherein: </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> depicts a pictorial representation of a network of data processing systems in which the present invention may be implemented; </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> depicts a block diagram of a data processing system that may be implemented as a server in accordance with a preferred embodiment of the present invention; </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> depicts a block diagram illustrating a data processing system is depicted in which the present invention may be implemented; </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> depicts a block diagram of a logging subsystem in accordance with the present invention; </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> depicts a block diagram illustrating the writing of a message using task IDs in accordance with the present invention; and </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> depicts a process flow and program function illustrating a method of reading a message with taskID in accordance with the present invention. </paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT </heading>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> With reference now to the figures, <cross-reference target="DRAWINGS">FIG. 1</cross-reference> depicts a pictorial representation of a network of data processing systems in which the present invention may be implemented. Network data processing system <highlight><bold>100</bold></highlight> is a network of computers in which the present invention may be implemented. Network data processing system <highlight><bold>100</bold></highlight> contains a network <highlight><bold>102</bold></highlight>, which is the medium used to provide communications links between various devices and computers connected together within network data processing system <highlight><bold>100</bold></highlight>. Network <highlight><bold>102</bold></highlight> may include connections, such as wire, wireless communication links, or fiber optic cables. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> In the depicted example, a plurality of servers <highlight><bold>103</bold></highlight>-<highlight><bold>104</bold></highlight> is connected to network <highlight><bold>102</bold></highlight> along with storage unit <highlight><bold>106</bold></highlight>. In addition, clients <highlight><bold>108</bold></highlight>, <highlight><bold>110</bold></highlight>, and <highlight><bold>112</bold></highlight> are connected to network <highlight><bold>102</bold></highlight>. These clients <highlight><bold>108</bold></highlight>, <highlight><bold>110</bold></highlight>, and <highlight><bold>112</bold></highlight> may be, for example, personal computers or network computers. In the depicted example, server <highlight><bold>104</bold></highlight> provides data, such as boot files, operating system images, and applications to clients <highlight><bold>108</bold></highlight>-<highlight><bold>112</bold></highlight>. Clients <highlight><bold>108</bold></highlight>, <highlight><bold>110</bold></highlight>, and <highlight><bold>112</bold></highlight> are clients to servers <highlight><bold>103</bold></highlight>-<highlight><bold>104</bold></highlight>. Network data processing system <highlight><bold>100</bold></highlight> may include additional servers, clients, and other devices not shown. In the depicted example, network data processing system <highlight><bold>100</bold></highlight> is the Internet with network <highlight><bold>102</bold></highlight> representing a worldwide collection of networks and gateways that use the TCP/IP suite of protocols to communicate with one another. At the heart of the Internet is a backbone of high-speed data communication lines between major nodes or host computers, consisting of thousands of commercial, government, educational and other computer systems that route data and messages. Of course, network data processing system <highlight><bold>100</bold></highlight> also may be implemented as a number of different types of networks, such as for example, an intranet, a local area network (LAN), or a wide area network (WAN). <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is intended as an example, and not as an architectural limitation for the present invention. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 2, a</cross-reference> block diagram of a data processing system that may be implemented as a server, such as servers <highlight><bold>103</bold></highlight>-<highlight><bold>104</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, is depicted in accordance with a preferred embodiment of the present invention. Data processing system <highlight><bold>200</bold></highlight> may be a symmetric multiprocessor (SMP) system including a plurality of processors <highlight><bold>202</bold></highlight> and <highlight><bold>204</bold></highlight> connected to system bus <highlight><bold>206</bold></highlight>. Alternatively, a single processor system may be employed. Also connected to system bus <highlight><bold>206</bold></highlight> is memory controller/cache <highlight><bold>208</bold></highlight>, which provides an interface to local memory <highlight><bold>209</bold></highlight>. I/O bus bridge <highlight><bold>210</bold></highlight> is connected to system bus <highlight><bold>206</bold></highlight> and provides an interface to I/O bus <highlight><bold>212</bold></highlight>. Memory controller/cache <highlight><bold>208</bold></highlight> and I/O bus bridge <highlight><bold>210</bold></highlight> may be integrated as depicted. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> Peripheral component interconnect (PCI) bus bridge <highlight><bold>214</bold></highlight> connected to I/O bus <highlight><bold>212</bold></highlight> provides an interface to PCI local bus <highlight><bold>216</bold></highlight>. A number of modems may be connected to PCI local bus <highlight><bold>216</bold></highlight>. Typical PCI bus implementations will support four PCI expansion slots or add-in connectors. Communications links to clients <highlight><bold>108</bold></highlight>-<highlight><bold>112</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 1</cross-reference> may be provided through modem <highlight><bold>218</bold></highlight> and network adapter <highlight><bold>220</bold></highlight> connected to PCI local bus <highlight><bold>216</bold></highlight> through add-in boards. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> Additional PCI bus bridges <highlight><bold>222</bold></highlight> and <highlight><bold>224</bold></highlight> provide interfaces for additional PCI local buses <highlight><bold>226</bold></highlight> and <highlight><bold>228</bold></highlight>, from which additional modems or network adapters may be supported. In this manner, data processing system <highlight><bold>200</bold></highlight> allows connections to multiple network computers. A memory-mapped graphics adapter <highlight><bold>230</bold></highlight> and hard disk <highlight><bold>232</bold></highlight> may also be connected to I/O bus <highlight><bold>212</bold></highlight> as depicted, either directly or indirectly. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> Those of ordinary skill in the art will appreciate that the hardware depicted in <cross-reference target="DRAWINGS">FIG. 2</cross-reference> may vary. For example, other peripheral devices, such as optical disk drives and the like, also may be used in addition to or in place of the hardware depicted. The depicted example is not meant to imply architectural limitations with respect to the present invention. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> The data processing system depicted in <cross-reference target="DRAWINGS">FIG. 2</cross-reference> may be, for example, an IBM e-Server pSeries system, a product of International Business Machines Corporation in Armonk, N.Y., running the Advanced Interactive Executive (AIX) operating system or LINUX operating system. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 3, a</cross-reference> block diagram illustrating a data processing system is depicted in which the present invention may be implemented. Data processing system <highlight><bold>300</bold></highlight> is an example of a client computer. Data processing system <highlight><bold>300</bold></highlight> employs a peripheral component interconnect (PCI) local bus architecture. Although the depicted example employs a PCI bus, other bus architectures such as Accelerated Graphics Port (AGP) and Industry Standard Architecture (ISA) may be used. Processor <highlight><bold>302</bold></highlight> and main memory <highlight><bold>304</bold></highlight> are connected to PCI local bus <highlight><bold>306</bold></highlight> through PCI bridge <highlight><bold>308</bold></highlight>. PCI bridge <highlight><bold>308</bold></highlight> also may include an integrated memory controller and cache memory for processor <highlight><bold>302</bold></highlight>. Additional connections to PCI local bus <highlight><bold>306</bold></highlight> may be made through direct component interconnection or through add-in boards. In the depicted example, local area network (LAN) adapter <highlight><bold>310</bold></highlight>, SCSI host bus adapter <highlight><bold>312</bold></highlight>, and expansion bus interface <highlight><bold>314</bold></highlight> are connected to PCI local bus <highlight><bold>306</bold></highlight> by direct component connection. In contrast, audio adapter <highlight><bold>316</bold></highlight>, graphics adapter <highlight><bold>318</bold></highlight>, and audio/video adapter <highlight><bold>319</bold></highlight> are connected to PCI local bus <highlight><bold>306</bold></highlight> by add-in boards inserted into expansion slots. Expansion bus interface <highlight><bold>314</bold></highlight> provides a connection for a keyboard and mouse adapter <highlight><bold>320</bold></highlight>, modem <highlight><bold>322</bold></highlight>, and additional memory <highlight><bold>324</bold></highlight>. Small computer system interface (SCSI) host bus adapter <highlight><bold>312</bold></highlight> provides a connection for hard disk drive <highlight><bold>326</bold></highlight>, tape drive <highlight><bold>328</bold></highlight>, and CD-ROM drive <highlight><bold>330</bold></highlight>. Typical PCI local bus implementations will support three or four PCI expansion slots or add-in connectors. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> An operating system runs on processor <highlight><bold>302</bold></highlight> and is used to coordinate and provide control of various components within data processing system <highlight><bold>300</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>. The operating system may be a commercially available operating system, such as Windows 2000, which is available from Microsoft Corporation. An object oriented programming system such as Java may run in conjunction with the operating system and provide calls to the operating system from Java programs or applications executing on data processing system <highlight><bold>300</bold></highlight>. &ldquo;Java&rdquo; is a trademark of Sun Microsystems, Inc. Instructions for the operating system, the object-oriented operating system, and applications or programs are located on storage devices, such as hard disk drive <highlight><bold>326</bold></highlight>, and may be loaded into main memory <highlight><bold>304</bold></highlight> for execution by processor <highlight><bold>302</bold></highlight>. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> Those of ordinary skill in the art will appreciate that the hardware in <cross-reference target="DRAWINGS">FIG. 3</cross-reference> may vary depending on the implementation. Other internal hardware or peripheral devices, such as flash ROM (or equivalent nonvolatile memory) or optical disk drives and the like, may be used in addition to or in place of the hardware depicted in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>. Also, the processes of the present invention may be applied to a multiprocessor data processing system. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> As another example, data processing system <highlight><bold>300</bold></highlight> may be a stand-alone system configured to be bootable without relying on some type of network communication interface, whether or not data processing system <highlight><bold>300</bold></highlight> comprises some type of network communication interface. As a further example, data processing system <highlight><bold>300</bold></highlight> may be a personal digital assistant (PDA) device, which is configured with ROM and/or flash ROM in order to provide non-volatile memory for storing operating system files and/or user-generated data. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> The depicted example in <cross-reference target="DRAWINGS">FIG. 3</cross-reference> and above-described examples are not meant to imply architectural limitations. For example, data processing system <highlight><bold>300</bold></highlight> also may be a notebook computer or hand held computer in addition to taking the form of a PDA. Data processing system <highlight><bold>300</bold></highlight> also may be a kiosk or a Web appliance. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> The present invention provides a logging system with distributed, multilevel architecture which allows remote control of logging elements. The present invention also allows the logging system to be used standalone or in a distributed environment. The logging system allows a system to produce large amounts of data for local consumption, as opposed to a small amount of data for storage in a central remote repository. Dual output is easily configured for an administrator wishing to see logs on the console, in multiple files and in a database for future queries. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> Furthermore, the present invention provides for the creation and logging of a taskID. This allows a component to initiate a task to use a task identification (TaskID) which follows this task (which may flow across multiple components or ORBs) until completion. The TaskID is passed in the thread context in local methods and in the message context in remote method invocations. The taskID is then logged with message and trace data from each of the components through which the task flows that generate a trace or message log. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 4, a</cross-reference> block diagram of a logging subsystem is depicted in accordance with the present invention. The logging subsystem <highlight><bold>400</bold></highlight> uses several objects to record system events. These objects include loggers <highlight><bold>415</bold></highlight>, logging handlers <highlight><bold>424</bold></highlight>, logging filters <highlight><bold>420</bold></highlight> (also referred to as masks), and logging formatters <highlight><bold>418</bold></highlight>. Log subsystem <highlight><bold>400</bold></highlight> also includes a Log Task manger (LTM) <highlight><bold>402</bold></highlight>, a logging console administrator graphical user interface (GUI) <highlight><bold>414</bold></highlight>, a logging manager <highlight><bold>422</bold></highlight>, logging output <highlight><bold>438</bold></highlight>, and mapper <highlight><bold>446</bold></highlight>. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> Loggers <highlight><bold>415</bold></highlight> are software objects that record events that occur while a component is operating. The Logging subsystem <highlight><bold>400</bold></highlight> supports two types of loggers <highlight><bold>415</bold></highlight>: message loggers <highlight><bold>416</bold></highlight> and trace Loggers <highlight><bold>417</bold></highlight>. Message loggers <highlight><bold>416</bold></highlight> are used to record textual messages from a component. These messages are internationalized for individual locales. Trace loggers <highlight><bold>417</bold></highlight> are used to capture information about the operating environment when component code fails to operate as intended. Support personnel use the information captured by trace loggers <highlight><bold>417</bold></highlight> to trace a problem to its source or to determine why an error occurred. Generally, this information is not enabled by default. Because trace messages are intended for support personnel, they are generally written to a file that can be viewed during a postmortem Examination. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> Mapper <highlight><bold>446</bold></highlight> maps (or associates) logs associated with a given taskID to a given user detectable action, such as, for example, the depressing of a particular button. Thus, if the logging information is presented to the user, it can be presented with a user friendly description associating logging information with actions. Therefore, a user can view logging information with a correlation to an event that is meaningful to the user rather than with a correlation to a taskID that may have no meaning to the user. The taskID can be used to filter logging data (both message and trace logging data) to obtain all messages associated with a task and present the logging data to a user such that all logging data associated with a particular task is available to the user regardless of the component, ORB, or node that generated the data. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> Handlers <highlight><bold>424</bold></highlight> are software objects that direct messages recorded by a logger to a logging output <highlight><bold>438</bold></highlight> destination. Messages can be directed to a file <highlight><bold>444</bold></highlight>, a database <highlight><bold>442</bold></highlight>, a console screen <highlight><bold>440</bold></highlight>, or to other destinations. One associates handlers <highlight><bold>424</bold></highlight> with loggers <highlight><bold>415</bold></highlight> to send information recorded by a logger <highlight><bold>415</bold></highlight> to the desired destination. The present invention provides the configuration definitions for the following types of handlers: </paragraph>
<paragraph id="P-0036" lvl="2"><number>&lsqb;0036&rsqb;</number> Console Handler <highlight><bold>426</bold></highlight> writes log records to a console. </paragraph>
<paragraph id="P-0037" lvl="2"><number>&lsqb;0037&rsqb;</number> File Handler <highlight><bold>428</bold></highlight> writes log records to a file. </paragraph>
<paragraph id="P-0038" lvl="2"><number>&lsqb;0038&rsqb;</number> Multifile Handler <highlight><bold>430</bold></highlight> writes log records to a rotating set of log files. </paragraph>
<paragraph id="P-0039" lvl="2"><number>&lsqb;0039&rsqb;</number> Serial File Handler <highlight><bold>432</bold></highlight> writes log records to files as serialized objects. </paragraph>
<paragraph id="P-0040" lvl="2"><number>&lsqb;0040&rsqb;</number> Database Handler <highlight><bold>434</bold></highlight> writes log records to a database. </paragraph>
<paragraph id="P-0041" lvl="2"><number>&lsqb;0041&rsqb;</number> Server Handler <highlight><bold>436</bold></highlight> sends log records in batch mode to a remote logging server for processing. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> Filters <highlight><bold>420</bold></highlight> can be applied to loggers, to handlers <highlight><bold>424</bold></highlight>, or to both loggers and handlers. When applied to a logger, the filter determines which types of message and trace records the logger <highlight><bold>415</bold></highlight> processes. When applied to a handler <highlight><bold>424</bold></highlight>, the filter <highlight><bold>420</bold></highlight> determines which types of message and trace records the handler <highlight><bold>424</bold></highlight> sends to a destination. Filters <highlight><bold>420</bold></highlight> work by comparing a log record type against a set of criteria, or a query, contained within the filter. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> Formatters <highlight><bold>418</bold></highlight> are software objects used to format the output of information contained in log records. In general, formatters <highlight><bold>418</bold></highlight> can be used to tailor things like date and time stamps to local conventions. A single formatter <highlight><bold>418</bold></highlight> can be used by multiple handlers <highlight><bold>424</bold></highlight>. Having numerous loggers <highlight><bold>416</bold></highlight>, handlers <highlight><bold>424</bold></highlight>, filters <highlight><bold>420</bold></highlight>, and formatters <highlight><bold>418</bold></highlight> can cause an undue amount of logging administration to perform. To reduce the administration burden, one can create &ldquo;groups&rdquo;. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> A group contains loggers, handlers, filters, or formatters that have common properties. By creating groups, a newly created logger, handler, filter, or formatter with unset properties can inherit values for those properties from the group. If a logger, handler, filter, or formatter belongs to a group and its properties are updated, all other loggers, handlers, filters or formatters in that group will also have that property updated. This eliminates the need for manually updating individual logger, handler, filter, or formatter properties. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> The logging manager <highlight><bold>422</bold></highlight> provides an interface to Object Request Brokers (ORBs) as well as configuration and other DKS services. (An ORB is software that handles the communication of messages from a requesting program &lcub;client&rcub; to the object as well as any return values from the object back to the calling program.) The logging console Graphical User Interface (GUI) provides an interface to allow an administrator to provide configuration information as well as to output messages to the administrator. The log task manager (LTM) <highlight><bold>402</bold></highlight> includes a unique task ID generator ORB identification (ID) <highlight><bold>404</bold></highlight>, a generic task transport (GTT) <highlight><bold>406</bold></highlight>, a configuration unit <highlight><bold>408</bold></highlight>, a mapper <highlight><bold>410</bold></highlight>, and a taskID console <highlight><bold>412</bold></highlight>. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> The function of LTM <highlight><bold>402</bold></highlight> is best explained by example, thus referring now to <cross-reference target="DRAWINGS">FIG. 5, a</cross-reference> block diagram illustrating the writing of a message using task IDs is depicted in accordance with the present invention. In the present example, three applications <highlight><bold>502</bold></highlight>-<highlight><bold>506</bold></highlight> are running in two ORBs (ORB<highlight><bold>1</bold></highlight> and ORB<highlight><bold>2</bold></highlight>). These applications and ORBs may be on a single data processing system or, more typically, may be on two or more different data processing systems networked together. Application <highlight><bold>1</bold></highlight> (App<highlight><bold>1</bold></highlight>) <highlight><bold>502</bold></highlight>, as depicted, is executing inside ORB<highlight><bold>1</bold></highlight> and decides to group several actions, events into a single task. However, in other embodiments, the App<highlight><bold>1</bold></highlight> <highlight><bold>502</bold></highlight> may be executing outside an ORB. The App<highlight><bold>1</bold></highlight> <highlight><bold>502</bold></highlight> may be, for example, Command Line Interface (CLI) or GUI components. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> App<highlight><bold>1</bold></highlight> <highlight><bold>502</bold></highlight> gets a TaskID from the UniqueTaskID Generator <highlight><bold>404</bold></highlight>. The unique TaskID generator <highlight><bold>404</bold></highlight> generates a unique number, for example 0001, for the TaskID for app<highlight><bold>1</bold></highlight> <highlight><bold>502</bold></highlight>. The unique TaskID generator <highlight><bold>404</bold></highlight> then determines whether the ORB is running. If yes, then the unique TaskID generator <highlight><bold>404</bold></highlight> retrieves the ID of ORB and combines the orbId and the TaskID. For example, if the ORB id is 3.7b6c076cfe890732.1.76a0d998c6a4863f, then the TaskID is 0001.3.7b6c076cfe890732.1.76a0d998c6a4863f. If the ORB is not running, then the unique Task ID generator <highlight><bold>404</bold></highlight> combines 0.0.0.0 and taskID to specify orb is not running. Thus, the task ID for app<highlight><bold>1</bold></highlight> <highlight><bold>502</bold></highlight> in this case is 0001.0.0.0.0. The unique TaskID generator then returns the taskID back to App<highlight><bold>1</bold></highlight> <highlight><bold>502</bold></highlight>. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> App<highlight><bold>1</bold></highlight> <highlight><bold>502</bold></highlight> then informs LTM <highlight><bold>402</bold></highlight> that the task is starting with a setTaskID method. This method attaches the taskId to the TaskIDTransport mechanism. In the present example, LocalThreadContext is used for a local execution of a thread in the Java object oriented programming language. This generic transport mechanism may be, for example, over the wire (remote proxy calls), specialized port hardware (to a debugger hardware analyzer), or through the use of some other protocol used for transporting data from point to point (e.g. http, PPPoE). App<highlight><bold>1</bold></highlight> <highlight><bold>502</bold></highlight> then gets a reference to LTM&apos;s Generic Task Transport (GTT) <highlight><bold>406</bold></highlight>. GTT <highlight><bold>406</bold></highlight> transfers TaskID from the thread context to the message context and back implicitly. App<highlight><bold>1</bold></highlight> <highlight><bold>502</bold></highlight> then calls GTT&apos;s <highlight><bold>406</bold></highlight> setTaskID ( ) method with the original taskID (taskID1&equals;123). GTT <highlight><bold>406</bold></highlight> attaches taskID to the Transport. In the present case, the taskID is attached to the LocalThreadTransport. The LocalThreadTransport extends the InheritableThreadLocal and places the TaskID on the local thread. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> Appl <highlight><bold>502</bold></highlight> calls M<highlight><bold>1</bold></highlight> API of App<highlight><bold>2</bold></highlight> <highlight><bold>504</bold></highlight>. Since App<highlight><bold>2</bold></highlight> <highlight><bold>504</bold></highlight> resides on a remote ORB, remote method invocation (RMI) is invoked by the ORB subsytem. Data that is to be sent over the wire is serialized into a byte language. The taskID is also serialized since it is part of the thread variables M<highlight><bold>1</bold></highlight>. App<highlight><bold>2</bold></highlight> <highlight><bold>504</bold></highlight> calls M<highlight><bold>2</bold></highlight> App<highlight><bold>3</bold></highlight> <highlight><bold>506</bold></highlight> and sends with the call M<highlight><bold>2</bold></highlight> the taskID<highlight><bold>1</bold></highlight> which was first obtained by App<highlight><bold>1</bold></highlight> <highlight><bold>502</bold></highlight>. App<highlight><bold>3</bold></highlight> <highlight><bold>506</bold></highlight> runs in a different ORB from App<highlight><bold>2</bold></highlight> <highlight><bold>504</bold></highlight>. App<highlight><bold>3</bold></highlight> <highlight><bold>506</bold></highlight> completes the task and returns M<highlight><bold>3</bold></highlight> results to App<highlight><bold>2</bold></highlight> <highlight><bold>504</bold></highlight> including in the return M<highlight><bold>3</bold></highlight> the taskID<highlight><bold>1</bold></highlight>. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> In this example, App<highlight><bold>2</bold></highlight> <highlight><bold>504</bold></highlight> throws M<highlight><bold>4</bold></highlight> an exception due to an error. Appl <highlight><bold>502</bold></highlight> catches this exception and wishes to log a message. Thus, Appl <highlight><bold>502</bold></highlight> gets messageLogger <highlight><bold>416</bold></highlight> from LoggingManager <highlight><bold>422</bold></highlight>. Based on configuration the Logging Manger <highlight><bold>422</bold></highlight> creates the correct handler: </paragraph>
<paragraph id="P-0051" lvl="2"><number>&lsqb;0051&rsqb;</number> if (console&equals;true) create Console Handler <highlight><bold>426</bold></highlight> </paragraph>
<paragraph id="P-0052" lvl="2"><number>&lsqb;0052&rsqb;</number> if (file&equals;true) create File Handler <highlight><bold>428</bold></highlight> </paragraph>
<paragraph id="P-0053" lvl="2"><number>&lsqb;0053&rsqb;</number> if (multitfile&equals;true) create Multifile Handler <highlight><bold>430</bold></highlight> </paragraph>
<paragraph id="P-0054" lvl="2"><number>&lsqb;0054&rsqb;</number> if (serialFile&equals;true) create Serial File Handler <highlight><bold>432</bold></highlight> </paragraph>
<paragraph id="P-0055" lvl="2"><number>&lsqb;0055&rsqb;</number> if (Database&equals;true) create DatabaseHandler <highlight><bold>434</bold></highlight> </paragraph>
<paragraph id="P-0056" lvl="2"><number>&lsqb;0056&rsqb;</number> if (server&equals;true) creates Server Handler <highlight><bold>436</bold></highlight> </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> App<highlight><bold>1</bold></highlight> <highlight><bold>502</bold></highlight> formats the data it wants to be logged and calls the logo method of the Message Logger <highlight><bold>416</bold></highlight>. MessageLogger <highlight><bold>416</bold></highlight> calls the LTM <highlight><bold>402</bold></highlight> to add the taskID information to the message. LTM <highlight><bold>402</bold></highlight> gets TaskID from the thread and returns the taskID to MessageLogger <highlight><bold>416</bold></highlight>. The MessageLogger <highlight><bold>416</bold></highlight> then creates a log record which includes this TaskID. MessageLogger <highlight><bold>416</bold></highlight> using preconfigured MessageHandler <highlight><bold>424</bold></highlight>, asks MessageHandler <highlight><bold>424</bold></highlight> to save this log record. MessageHandler <highlight><bold>424</bold></highlight> using the preconfigured MessageFilter <highlight><bold>420</bold></highlight>, determines what data should be saved. The taskID is always saved. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> The logging mechansism of the present invention allows for greater granularity in associating events to be logged than does prior art methods using the threadID since several different sets of tasks all of which may be performed on the same thread, may have different taskIDS. Thus, allowing the tracking of separately grouped events that would be grouped together if the threadID were used. The only requirement is that the tasks be serial tasks. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 6, a</cross-reference> process flow and program function illustrating a method of reading a message with taskID such as generated by the example in <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is depicted in accordance with the present invention. To begin an administrator chooses to view a message log in a logging viewer <highlight><bold>414</bold></highlight> (step <highlight><bold>602</bold></highlight>). The logging viewer <highlight><bold>414</bold></highlight> requests messages from the logging handler <highlight><bold>424</bold></highlight> (step <highlight><bold>604</bold></highlight>). The logging manager <highlight><bold>422</bold></highlight> gets the logging configuration to determine the correct formatter and filter as well as other items (step <highlight><bold>606</bold></highlight>). The logging viewer <highlight><bold>414</bold></highlight> then asks the logging handler <highlight><bold>424</bold></highlight> for the message record iterator (step <highlight><bold>608</bold></highlight>). The iterator is passed to the logging viewer <highlight><bold>414</bold></highlight> (step <highlight><bold>610</bold></highlight>) which then displays the data from each record to the administrator (step <highlight><bold>612</bold></highlight>). </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> Some advantages of the present invention include that it is not limited to tracking of RMI application methods which use remote proxies. Such a requirement is too restrictive since many method calls are not using CORBA or Voyager ORB to ORB code, but rather components that are local and require no ORB communication which are expensive. Additionally, the present invention provides ORB or non-ORB applications with the ability to track tasks via a distributed logging subsystem which can be run inside or outside of an ORB. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> The present invention includes automatic task based id generation for tracking tasks across multiple threads. Such tracking does not necessarily depend on thread implementation. However, the described embodiment uses the thread mechanism as a transport for the taskID. The present invention enables an application to decide which events are related using this taskID. Procedural implementations (highly serialized native code) with few threads or object oriented implementations with many threads can both benefit from the present invention. A middle ground between the amount of data correlation possible is defined by application rather than by attempting to track all threads which is an expensive performance hit (too much data correlation) or than by tracking none which results in too little correlation (highly serialized function). </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> The present invention enables data correlation. It allows for the ability to provide filters to the user representing tasks as executed across applications, services, components, ORBs thus presenting a smaller subset of logging data (trace or message) to the user Administrator. Furthermore, extraction of meaningful interrelated data from log files residing all distributed machines with the same name is provided as well as extracting meaningful, interrelated data from many rows of data in a single or multilevel logging database. Furthermore, the present invention enables data stored in different loggers (Trace versus Message) to be related based on the application&apos;s definition. Furthermore, in a preferred implementation, the present invention is implemented at JVM/application level rather than as OS specific native code used in a CORBA thread. </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> It is important to note that while the present invention has been described in the context of a fully functioning data processing system, those of ordinary skill in the art will appreciate that the processes of the present invention are capable of being distributed in the form of a computer readable medium of instructions and a variety of forms and that the present invention applies equally regardless of the particular type of signal bearing media actually used to carry out the distribution. Examples of computer readable media include recordable-type media, such as a floppy disk, a hard disk drive, a RAM, CD-ROMs, DVD-ROMs, and transmission-type media, such as digital and analog communications links, wired or wireless communications links using transmission forms, such as, for example, radio frequency and light wave transmissions. The computer readable media may take the form of coded formats that are decoded for actual use in a particular data processing system. </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> The description of the present invention has been presented for purposes of illustration and description, and is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiment was chosen and described in order to best explain the principles of the invention, the practical application, and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method for tracking tasks in a logging system, the method comprising: 
<claim-text>receiving, at log task manager, a request from an application program to assign a unique task identification to a related events identified by the application program; </claim-text>
<claim-text>generating, at a log task manager, the unique task identification; </claim-text>
<claim-text>attaching the unique task identification to a transport mechanism that passes information between components; </claim-text>
<claim-text>combining the task identification with logging information generated by one of the components; and </claim-text>
<claim-text>filtering a plurality of logging information entries based on the task identification to correlate logging information associated with the related events for presentation to a user. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein attaching the unique task identification to the transport mechanism comprises attaching the task identification to a local thread transport. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, further comprising: 
<claim-text>at the local thread transport, extending the inheritable thread local; and </claim-text>
<claim-text>at the local thread transport, placing the task identification on a local thread. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the transport mechanism utilizes a remote proxy call. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the transport mechanism utilizes port hardware. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the transport mechanism utilizes a point to point protocol. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the point to point protocol is a hypertext transfer protocol. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the transport mechanism utilizes a message context. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the unique task identification is a first unique task identification, the related events are first related serial events and further comprising: 
<claim-text>receiving, at the log task manager, a request from the application program for a second unique task identification assigned to second related serial events identified by the application program; and </claim-text>
<claim-text>attaching the second unique task identification to the transport mechanism. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising: 
<claim-text>mapping a taskID to a corresponding action; and </claim-text>
<claim-text>presenting logging information to a user based on the corresponding action. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. A computer program product in a computer readable media for use in a data processing system for tracking tasks in a logging system, the computer program product comprising: 
<claim-text>first instructions for receiving, at log task manager, a request from an application program to assign a unique task identification to a related events identified by the application program; </claim-text>
<claim-text>second instructions for generating, at a log task manager, the unique task identification; </claim-text>
<claim-text>third instructions for attaching the unique task identification to a transport mechanism that passes information between components; </claim-text>
<claim-text>fourth instructions for combining the task identification with logging information generated by one of the components; and </claim-text>
<claim-text>fifth instructions for filtering a plurality of logging information entries based on the task identification to correlate logging information associated with the related events for presentation to a user. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The computer program product as recited in <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, wherein attaching the unique task identification to the transport mechanism comprises attaching the task identification to a local thread transport. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The computer program product as recited in <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, further comprising: 
<claim-text>sixth instructions, at the local thread transport, for extending the inheritable thread local; and </claim-text>
<claim-text>seventh instruction, at the local thread transport, for placing the task identification on a local thread. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The computer program product as recited in <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, wherein the transport mechanism utilizes a remote proxy call. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The computer program product as recited in <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, wherein the transport mechanism utilizes port hardware. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The computer program product as recited in <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, wherein the transport mechanism utilizes a point to point protocol. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The computer program product as recited in <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, wherein the point to point protocol is a hypertext transfer protocol. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The computer program product as recited in <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, wherein the transport mechanism utilizes a message context. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The computer program product as recited in <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, wherein the unique task identification is a first unique task identification, the related events are first related serial events and further comprising: 
<claim-text>sixth instructions for receiving, at the log task manager, a request from the application program for a second unique task identification assigned to second related serial events identified by the application program; and </claim-text>
<claim-text>seventh instructions for attaching the second unique task identification to the transport mechanism. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The computer program product as recited in <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, further comprising: 
<claim-text>sixth instructions for mapping a taskID to a corresponding action; and </claim-text>
<claim-text>seventh instructions for presenting logging information to a user based on the corresponding action. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. A system for tracking tasks in a logging system, the computer program product comprising: 
<claim-text>a logging manager which receives request from an application program to assign a unique task identification to a related events identified by the application program; </claim-text>
<claim-text>a unique taskID generator which generates the unique task identification; </claim-text>
<claim-text>a task transport unit which attaches the unique task identification to a transport mechanism that passes information between components; </claim-text>
<claim-text>a logger which combines the task identification with logging information generated by one of the components; and </claim-text>
<claim-text>a filter which filters a plurality of logging information entries based on the task identification to correlate logging information associated with the related events for presentation to a user. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The computer program product as recited in <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, further comprising: 
<claim-text>a mapper which maps a taskID to a corresponding action; and </claim-text>
<claim-text>a presentation unit which presents logging information to a user based on the corresponding action.</claim-text>
</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>4</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005021A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005021A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005021A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005021A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005021A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005021A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
