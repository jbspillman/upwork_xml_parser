<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005117A1-20030102-D00000.TIF SYSTEM "US20030005117A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005117A1-20030102-D00001.TIF SYSTEM "US20030005117A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005117A1-20030102-D00002.TIF SYSTEM "US20030005117A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005117A1-20030102-D00003.TIF SYSTEM "US20030005117A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005117A1-20030102-D00004.TIF SYSTEM "US20030005117A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005117A1-20030102-D00005.TIF SYSTEM "US20030005117A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030005117A1-20030102-D00006.TIF SYSTEM "US20030005117A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030005117A1-20030102-D00007.TIF SYSTEM "US20030005117A1-20030102-D00007.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005117</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09896090</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010629</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F015/173</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>709</class>
<subclass>225000</subclass>
</uspc>
</classification-us-primary>
<classification-us-secondary>
<uspc>
<class>709</class>
<subclass>229000</subclass>
</uspc>
</classification-us-secondary>
</classification-us>
<title-of-invention>Pluggable authentication and access control for a messaging system</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Amy</given-name>
<middle-name>H.</middle-name>
<family-name>Kang</family-name>
</name>
<residence>
<residence-us>
<city>Mountain View</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>George</given-name>
<family-name>Tharakan</family-name>
</name>
<residence>
<residence-us>
<city>Sunnyvale</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Joseph</given-name>
<middle-name>F. Di</middle-name>
<family-name>Pol</family-name>
</name>
<residence>
<residence-us>
<city>Sunnyvale</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Christopher</given-name>
<middle-name>S.</middle-name>
<family-name>Kasso</family-name>
</name>
<residence>
<residence-us>
<city>Los Altos</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>Robert C. Kowert</name-1>
<name-2>Conley, Rose, &amp; Tayon, P.C.</name-2>
<address>
<address-1>P.O. Box 398</address-1>
<city>Austin</city>
<state>TX</state>
<postalcode>78767</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A system and method for providing pluggable authentication and access control in computer systems and services are described. The authentication and access control process may be categorized into three components: an authentication protocol, a user repository and an access control model. In one embodiment, the authentication and access control mechanism may be implemented as three pluggable modules: an authentication protocol handler module for the authenticator side, an authentication protocol handler for the side to be authenticated, and an access control context module on the authenticator side. The pluggable modules may be exchangeable to support a variety of authentication types, user repositories, and access control models. The authentication protocol handlers provide symmetrical methods to handle requests and responses in the authentication process that reflect the symmetrical nature of the authentication process. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> 1. Field of the Invention </paragraph>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> This invention relates to networked computer systems, and more particularly to a system and method for providing pluggable authentication and access control in computer systems and services. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> 2. Description of the Related Art </paragraph>
<paragraph id="P-0004" lvl="7"><number>&lsqb;0004&rsqb;</number> Enterprise Messaging Systems </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> Enterprise messaging systems may be developed using a messaging service such as JMS. An enterprise messaging system may be used to integrate distributed, loosely coupled applications/systems in a way that provides for dynamic topologies of cooperating systems/services. Enterprise messaging systems typically need to address common messaging related problems such as: </paragraph>
<paragraph id="P-0006" lvl="2"><number>&lsqb;0006&rsqb;</number> Guaranteed message delivery (e.g. persistence, durable interests, &ldquo;at least once&rdquo; and &ldquo;once and only once&rdquo; message delivery guarantees, transactions etc). </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> Messages from one component to another must not be lost due to network or system failure. This means the system must be able to guarantee that a message is successfully delivered. </paragraph>
<paragraph id="P-0008" lvl="2"><number>&lsqb;0008&rsqb;</number> Asynchronous delivery. For large numbers of components to be able to exchange messages simultaneously, and support high-density throughputs, the sending of a message cannot depend upon the readiness of the consumer to immediately receive it. If a consumer is busy or offline, the system must allow for a message to be sent and subsequently received when the consumer is ready. This is known as asynchronous message delivery, popularly known as store-and-forward messaging. </paragraph>
<paragraph id="P-0009" lvl="2"><number>&lsqb;0009&rsqb;</number> Various message delivery models (e.g. publish and subscribe or point-to-point). </paragraph>
<paragraph id="P-0010" lvl="2"><number>&lsqb;0010&rsqb;</number> Transport independence. </paragraph>
<paragraph id="P-0011" lvl="2"><number>&lsqb;0011&rsqb;</number> Security The messaging system may support basic security features: authentication of users, authorized access to messages and resources, and on-the-wire encryption. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> Leveraging an enterprise messaging system in developing business solutions allows developers to focus on their application/business logic rather than on implementing the underlying messaging layer. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> iPlanet E-Commerce Solutions&apos; iMQ (iplanet Message Queue), formerly offered by Sun Microsystems as JMQ (Java Message Queue) is an example of an enterprise messaging system. iMQ may use a &ldquo;hub and spoke&rdquo; architecture. Clients use an iMQ client library to exchange messages with an iMQ message service, which may be implemented using messaging servers (also referred to as &ldquo;brokers&rdquo;). iMQ may also be used in serverless message service environments (e.g. peer-to-peer environments). iMQ is Java Message Service (JMS)-compliant. JMS is an application program interface (API) from Sun Microsystems that supports messaging between computers in a network. JMS provides a standard interface (API) for messaging providers to implement, thus providing a common messaging interface for Java programs to use. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> In an enterprise messaging system, clients exchange messages with a messaging server using a message exchange protocol. The messaging server then may route the messages based upon properties of the messages. Typically, the message exchange protocol requires a direct, fully bidirectional reliable transport connection between the client and the messaging server, such as a TCP (Transport Control Protocol) or SSL (Secure Sockets Layer) connection. </paragraph>
<paragraph id="P-0015" lvl="7"><number>&lsqb;0015&rsqb;</number> NIS (Network Information System) </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> NIS (Network Information System) is a network naming and administration system for smaller networks that was developed by Sun Microsystems. NIS&plus; is a later version that provides additional security and other facilities. Using NIS, each host client or server computer in the system has knowledge about the entire system. A user at any host can get access to files or applications on any host in the network with a single user identification and password. NIS is intended for use on local area networks. NIS uses the client/server model and the Remote Procedure Call (RPC) interface for communication between hosts. NIS consists of a server, a library of client programs, and some administrative tools. NIS is often used with the Network File System (NFS). NIS is a UNIX-based program. </paragraph>
<paragraph id="P-0017" lvl="7"><number>&lsqb;0017&rsqb;</number> Lightweight Directory Access Protocol (LDAP) </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> LDAP (Lightweight Directory Access Protocol) is a software protocol for enabling the location of organizations, individuals, and other resources such as files and devices in a network, whether on the Internet or on a corporate intranet. In a network, a directory tells where in the network something is located. LDAP enables searching without knowledge of the domain name. LDAP directories can perform many of the same functions as a database, storing several thousand names of individuals or storing other important information. LDAP directories are typically designed to support fast access and searches. LDAP directories typically store data in a hierarchical structure. </paragraph>
<paragraph id="P-0019" lvl="7"><number>&lsqb;0019&rsqb;</number> MD5 </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> MD5 is a message digest algorithm that is used to verify data integrity through the creation of a 128-bit message digest from data input (which may be a message of any length) that is claimed to be as unique to that specific data as a fingerprint is to the specific individual. MD5, which was developed by Professor Ronald L. Rivest of MIT, is intended for use with digital signature applications, which require that large files must be compressed by a secure method before being encrypted with a secret key, under a public key cryptosystem. MD5 is currently a standard, Internet Engineering Task Force (IETF) Request for Comments (RFC) 1321. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> A system and method for providing pluggable authentication and access control in computer systems and services are described. These systems and services may include connection-based networked computer systems such as client-server systems, connectionless (e.g. session-based) computer systems, point-to-point systems, and messaging systems. A &ldquo;client&rdquo; may be any application running on one side of the network; a &ldquo;server&rdquo; typically provides services to the client application, running on the other side of the network. Authentication is the process of verifying someone&apos;s identity. Access control (authorization) relates to controlling access to protected resources in a system, i.e. determining who can access what protected resources. A pluggable authentication and access control mechanism may be provided that allows replacement of an authentication and/or access control module or modules at or after deployment of the system components. As an example, in a client-server system, the authentication and access control process may be categorized into three components: </paragraph>
<paragraph id="P-0022" lvl="2"><number>&lsqb;0022&rsqb;</number> An authentication protocol that defines how the client and server exchange and interpret authentication information. </paragraph>
<paragraph id="P-0023" lvl="2"><number>&lsqb;0023&rsqb;</number> A user repository for storing user and credential information. </paragraph>
<paragraph id="P-0024" lvl="2"><number>&lsqb;0024&rsqb;</number> An access control model that may define what resources are protected, the method or methods of protection, and where the authorization information is stored. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> Embodiments of an authentication and access control mechanism that provide pluggability for all three components are described. In one embodiment, the authentication protocol may be changed by plugging in a different authentication protocol handler module or modules. In one embodiment, the user repository may be changed without requiring the change of the authentication protocol handler module or modules. In one embodiment, the access control model may also be changed, for example based upon the user repository being used, by plugging in a different access control module or modules. This pluggability helps to make the authentication and access control mechanism adaptable to a wide variety of environments. The pluggable user repository interface provides customers with the ability to customize the user repository to their environment. The pluggable access control module allows access control information to be accessed from different storage types and locations, and also may allow different resource protection methods (e.g. group-based access control, role-based access control, IP-based access control, certificate-based access control, etc.) to be used. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> Embodiments of the authentication and access control mechanism may use pluggable modules to implement an authentication and access control mechanism that may provide flexibility in the implementation of the various components described above for different applications. The pluggable modules may be exchangeable to support a variety of authentication types, user repositories, and access control models. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> In one embodiment, the authentication and access control mechanism may be implemented as the following pluggable modules that each provides an Application Programming Interface (API): </paragraph>
<paragraph id="P-0028" lvl="2"><number>&lsqb;0028&rsqb;</number> A server-side authentication protocol handler module </paragraph>
<paragraph id="P-0029" lvl="2"><number>&lsqb;0029&rsqb;</number> A client-side authentication protocol handler module </paragraph>
<paragraph id="P-0030" lvl="2"><number>&lsqb;0030&rsqb;</number> A server-side access control context module Typically, access control may be used to protect resources on the server. In one embodiment, the client may need to authenticate one or more servers. In this embodiment, the client-side authentication protocol handler module may be used in authenticating servers to which a connection is to be established. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> It is noted that, even though embodiments herein may be described in respect to the client-server model, embodiments are contemplated that apply generally to any system or service where a first entity or node needs to authenticate one or more other entities or nodes that desire to connect to the first entity or node, and where the first entity or node, the connecting entity or both sides include resources to which access needs to be controlled. For example, embodiments are contemplated for connection-based, connectionless, and peer-to-peer systems and services. Thus, the pluggable modules may more generally be described as: </paragraph>
<paragraph id="P-0032" lvl="2"><number>&lsqb;0032&rsqb;</number> An authentication protocol handler module for the authenticator side. </paragraph>
<paragraph id="P-0033" lvl="2"><number>&lsqb;0033&rsqb;</number> An authentication protocol handler module for the side to be authenticated. </paragraph>
<paragraph id="P-0034" lvl="2"><number>&lsqb;0034&rsqb;</number> An access control module on the authenticator side. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> The authentication protocol handler modules may implement the authentication and user repository components of the authentication and access control process. The access control context module may implement the access control component of the authentication and access control process. Using the pluggable authentication and access control mechanism, clients may access servers implementing different authentication protocols and/or access control models simply by &ldquo;plugging in&rdquo; a client-side authentication protocol handler module appropriate for the server being accessed. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> At the beginning of connection establishment, the server and client may negotiate an authentication type through the underlying transport protocol. Then both sides may initialize an appropriate authentication protocol handler for the selected authentication type. The server-side authentication protocol handler initialization may include any initialization needed for the configured user repository. Then a challenge from the server may be sent to the client. The challenge may include initial authentication request data returned from the server-side authentication protocol handler initialization method. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> The client, upon receiving the challenge from the underlying transport protocol, may pass the authentication request data to the client-side authentication protocol handler. The client-side authentication protocol handler module may include a handle request method that may receive the request, process the request and generate response data (e.g. digested user name and password or some other identification and credentials). The client then may send the response data returned from the handle request method to the server. The server may pass the authentication response data to the server-side authentication protocol handler. The server-side authentication protocol handler may include a handle response method that may access the user repository to authenticate (verify) the client using the authentication response data. This request and response process may be repeated depending on the requirements of the authentication mechanism. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> If the server-side authentication protocol handler successfully authenticates the client using the user repository, the server may send a success reply to the client to inform the client that the authentication process is now complete. If the authentication fails, the server may send a failure reply to the client and the connection may be aborted. If the authentication process is successful, the server&apos;s security manager may retrieve an access control context module from the server-side authentication protocol handler. The access control context module may encapsulate the authenticated subject and any other information necessary for later access control use. The access control context module may then be initialized, which may involve loading the configured access control model. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> Once the client is successfully authenticated, the client may send a service request to the server through the underlying transport protocol. A service request may request access to a protected resource. The server&apos;s security manager may interface with the access control context module to check whether the authenticated client has the necessary permission(s) to access the protected resource. The access control context module, in turn, may interface with the access control model to determine the permission. In one embodiment, the access control context module may be used to load (plug in) different access control models. That is, the access control context module may be pluggable (the API and implementation) as well as the access control model. If necessary, in one embodiment, the access control model may need to query the user repository for additional information on the authenticated subject, for example group information in case of group based access control. If it is determined that access is permitted to the resource, the authenticated client is allowed to access the resource; otherwise access to the resource is denied to the client. </paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1A</cross-reference> illustrates a system implementing the authentication and access control mechanism according to one embodiment; </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1B</cross-reference> illustrates a system implementing the authentication and access control mechanism according to one embodiment; </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> illustrates a user repository <highlight><bold>120</bold></highlight> and its relation to an access control model <highlight><bold>130</bold></highlight> according to one embodiment; </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a flow diagram illustrating the use of the authentication and access control mechanism to authenticate a client <highlight><bold>100</bold></highlight> and provide access control for resources of a server <highlight><bold>110</bold></highlight> according to one embodiment; </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a flowchart illustrating a method of authenticating a client according to one embodiment; </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a flowchart illustrating a method of access control to server resources according to one embodiment; </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is a block diagram illustrating the security manager accessing the user repository and an access control properties file.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> While the invention is described herein by way of example for several embodiments and illustrative drawings, those skilled in the art will recognize that the invention is not limited to the embodiments or drawings described. It should be understood, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims. The headings used herein are for organizational purposes only and are not meant to be used to limit the scope of the description or the claims. As used throughout this application, the word &ldquo;may&rdquo; is used in a permissive sense (i.e., meaning having the potential to), rather than the mandatory sense (i.e., meaning must). Similarly, the words &ldquo;include&rdquo;, &ldquo;including&rdquo;, and &ldquo;includes&rdquo; mean including, but not limited to. </paragraph>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF EMBODIMENTS OF THE INVENTION </heading>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> A system and method for providing pluggable authentication and access control in computer systems and services are described. These systems may include connection-based networked computer systems and services such as client-server systems, connectionless systems, point-to-point systems, and messaging systems. One embodiment may be used in client-server systems, where typically clients may initiate connections with one or more servers. A &ldquo;client&rdquo; can be any application running on one side of the network; a &ldquo;server&rdquo; typically provides services to the client application, running on the other side of the network. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> Embodiments may be used in computer systems and services that support communications between entities in the computer systems or services in any of various transport protocols or combinations of transport protocols. Transport protocols that may be used may include, but are not limited to, TCP/IP, Hypertext Transport Protocol (HTTP), UDP (User Datagram Protocol), IrDA (Infrared Data Association), IBM&apos;s SNA (Systems Network Architecture), Novell&apos;s IPX (Internetwork Packet eXchange), and Bluetooth. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> Authentication is the process of verifying someone&apos;s identity. Access control (authorization) relates to controlling access to protected resources in a system, i.e. determining who can access what protected resources. A pluggable authentication and access control mechanism may be provided that allows replacement of an authentication and/or access control module or modules at or after deployment of the system components. For example, in a client/server system, the authentication and access control process may be categorized into three components: </paragraph>
<paragraph id="P-0051" lvl="2"><number>&lsqb;0051&rsqb;</number> Authentication Protocol&mdash;The authentication protocol provides a contract between a client and server, and may define how the client and server exchange and interpret authentication information, for example, server challenges, client responses, etc. The authentication protocol component also may control how the client and server exchange authentication information, e.g. an authentication mechanism, server challenges and client responses, etc. Typically, different authentication mechanisms require different authentication protocols. </paragraph>
<paragraph id="P-0052" lvl="2"><number>&lsqb;0052&rsqb;</number> User Repository&mdash;Where and how user and credential information (e.g. used in authentication) is stored. </paragraph>
<paragraph id="P-0053" lvl="2"><number>&lsqb;0053&rsqb;</number> Access Control Model&mdash;Once authenticated, a user may require authorization to access protected resources. The access control model may define what resources are protected, the method or methods of protection, and where the authorization information is stored. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> Embodiments of an authentication and access control mechanism that provide pluggability for all three components as described above are described. In one embodiment, the authentication protocol may be changed by plugging in a different authentication protocol handler module or modules. In one embodiment, the user repository may be changed without requiring the changing of the authentication protocol handler module or modules. In one embodiment, the access control model may also be changed, for example based upon the user repository being used, by plugging in a different access control module or modules. This pluggability may make the authentication and access control mechanism adaptable to a wide variety of environments. The pluggable user repository interface provides customers with the ability to customize the user repository to their environment. The pluggable access control module may allow access control information to be accessed from different storage types and locations, and also may allow different resource protection methods (e.g. group-based access control, role-based access control, IP-based access control, certificate-based access control, etc.) to be used. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> The choice of security mechanisms, including what authentication protocol used in a system, may depend on factors including, but not limited to, what user and credential information is stored in a user repository, how the information is stored, network transport being used, hardware location, time of day, user preference, etc. Different authentication mechanisms may use different protocols. For example, one server may expect a user name and/or password, another server may expect a certificate or key, and still another server may expect the user name, password or other information to be encoded/encrypted differently. Information (e.g., user name, group name, role, etc.) used by the access control model in determining who can access what resource may also depend on the user repository. For example, a role-based access control model may require a user repository that supports users and roles. If the user repository module is replaced by a different user repository module that supports only users and groups, then the role-based access control model may need to be replaced by a group-based access control model as well. Thus, the authentication and access control mechanism uses pluggable modules to implement an authentication and access control mechanism that may provide flexibility in the implementation of the various components described above for different applications. The pluggable modules may be exchangeable to support a variety of authentication types, user repositories, and access control models. Examples of different authentication types may include, but are not limited to: MD5-challenge, onetime passwords, Certificates, etc. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1A</cross-reference> illustrates a networked system implementing the authentication and access control mechanism according to one embodiment. A client <highlight><bold>100</bold></highlight> and a server <highlight><bold>110</bold></highlight> may participate in a client-server system. An access control model <highlight><bold>130</bold></highlight> may define access control for resources of server <highlight><bold>110</bold></highlight>. Client information may be maintained in a user repository <highlight><bold>120</bold></highlight>. Server <highlight><bold>110</bold></highlight> may include a security manager module <highlight><bold>114</bold></highlight> that may provide authentication services for users requesting connections to a broker and authorization services (access control) for authenticated users. </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> In one embodiment, the authentication and access control mechanism may be implemented as the following pluggable modules that each provides an Application Programming Interface (API): </paragraph>
<paragraph id="P-0058" lvl="2"><number>&lsqb;0058&rsqb;</number> A server-side authentication protocol handler module <highlight><bold>112</bold></highlight> </paragraph>
<paragraph id="P-0059" lvl="2"><number>&lsqb;0059&rsqb;</number> A client-side authentication protocol handler module <highlight><bold>102</bold></highlight> </paragraph>
<paragraph id="P-0060" lvl="2"><number>&lsqb;0060&rsqb;</number> A server-side access control context module <highlight><bold>140</bold></highlight> </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> The authentication protocol handler modules may implement the authentication and user repository components of the authentication and access control process. The access control context module <highlight><bold>140</bold></highlight> may implement the access control component of the authentication and access control process. Using the pluggable authentication and access control mechanism, clients <highlight><bold>100</bold></highlight> may access two or more servers <highlight><bold>110</bold></highlight> each implementing a different authentication protocols and/or access control models simply by &ldquo;plugging in&rdquo; a client-side authentication protocol handler module <highlight><bold>102</bold></highlight> appropriate for the server <highlight><bold>110</bold></highlight> being accessed. </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> Server <highlight><bold>110</bold></highlight> may be implemented on a single host machine or on two or more host machines. The user repository <highlight><bold>120</bold></highlight>, server-side authentication protocol handler module <highlight><bold>112</bold></highlight>, server-side access control context module <highlight><bold>140</bold></highlight>, access control model <highlight><bold>130</bold></highlight>, and security manager <highlight><bold>114</bold></highlight> may be implemented on the same host machine with the server <highlight><bold>110</bold></highlight>, or on different host machines. </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> In one embodiment, the client-side authentication protocol handler module <highlight><bold>102</bold></highlight> may include, but is not limited to, the following methods: </paragraph>
<paragraph id="P-0064" lvl="2"><number>&lsqb;0064&rsqb;</number> Get type method&mdash;returns the authentication type implemented by this authentication protocol handler module <highlight><bold>102</bold></highlight>. </paragraph>
<paragraph id="P-0065" lvl="2"><number>&lsqb;0065&rsqb;</number> Initialization method&mdash;called once before any handle request calls for the authentication process. This method may accept, but is not limited to, a user name, a password, and any other authentication properties needed. </paragraph>
<paragraph id="P-0066" lvl="2"><number>&lsqb;0066&rsqb;</number> Handle request method&mdash;May be called (by the client) to handle an authentication request received from the server. May accept, but is not limited to, the following input data: </paragraph>
<paragraph id="P-0067" lvl="2"><number>&lsqb;0067&rsqb;</number> the authentication request data. </paragraph>
<paragraph id="P-0068" lvl="2"><number>&lsqb;0068&rsqb;</number> a packet sequence number that may be used for correlation purposes. </paragraph>
<paragraph id="P-0069" lvl="2"><number>&lsqb;0069&rsqb;</number> The handle request method returns the response data. </paragraph>
<paragraph id="P-0070" lvl="2"><number>&lsqb;0070&rsqb;</number> A completion method called when the authentication process completes. May accept, but is not limited to, an input indicating the success or failure of the authentication process. </paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> In one embodiment, the server-side authentication protocol handler module <highlight><bold>112</bold></highlight> may include, but is not limited to, the following methods: </paragraph>
<paragraph id="P-0072" lvl="2"><number>&lsqb;0072&rsqb;</number> Get type method&mdash;returns the authentication type implemented by this authentication protocol handler module <highlight><bold>112</bold></highlight>. </paragraph>
<paragraph id="P-0073" lvl="2"><number>&lsqb;0073&rsqb;</number> Initialization method&mdash;called once before any handle response calls for the authentication process. This method may accept, but is not limited to, the following input data: </paragraph>
<paragraph id="P-0074" lvl="3"><number>&lsqb;0074&rsqb;</number> A sequence number that may be used as a start sequence number for this authentication process. </paragraph>
<paragraph id="P-0075" lvl="3"><number>&lsqb;0075&rsqb;</number> Server authentication properties. </paragraph>
<paragraph id="P-0076" lvl="3"><number>&lsqb;0076&rsqb;</number> Cache data, if any. </paragraph>
<paragraph id="P-0077" lvl="3"><number>&lsqb;0077&rsqb;</number> Information indicating if the cache data is stale </paragraph>
<paragraph id="P-0078" lvl="2"><number>&lsqb;0078&rsqb;</number> Handle response method&mdash;May be called (by the server) to handle an authentication response received from the client. May accept, but is not limited to, the following input data: </paragraph>
<paragraph id="P-0079" lvl="3"><number>&lsqb;0079&rsqb;</number> the authentication response data. </paragraph>
<paragraph id="P-0080" lvl="3"><number>&lsqb;0080&rsqb;</number> a packet sequence number that may be used for correlation purposes. The handle response method may return the next request data, if any, or may return an indication that there is no more request data. The handle response method may also return information indicating the success or failure of the authentication process. </paragraph>
<paragraph id="P-0081" lvl="2"><number>&lsqb;0081&rsqb;</number> Log out method&mdash;may be called when the connection closes. </paragraph>
<paragraph id="P-0082" lvl="2"><number>&lsqb;0082&rsqb;</number> Get access control context method&mdash;may be called when the authentication process successfully completes. This method returns the access control context object associated with the authenticated subject. </paragraph>
<paragraph id="P-0083" lvl="2"><number>&lsqb;0083&rsqb;</number> Get cache data method&mdash;this method may be called when the authentication process successfully completes. On the next connection authentication, this object may be passed to the initialization method when called. </paragraph>
<paragraph id="P-0084" lvl="0"><number>&lsqb;0084&rsqb;</number> In one embodiment directed at a messaging system such as JMS that uses connection/destination access control, the access control context module <highlight><bold>140</bold></highlight> may include, but is not limited to, the following methods: </paragraph>
<paragraph id="P-0085" lvl="2"><number>&lsqb;0085&rsqb;</number> Check connection permission method&mdash;checks connection permission based on the access control context. This method may accept, but is not limited to accepting, a connection type as an input. This method may return information or otherwise indicate (e.g. by throwing an exception) whether connection is allowed or denied. </paragraph>
<paragraph id="P-0086" lvl="2"><number>&lsqb;0086&rsqb;</number> Check destination permission method&mdash;this method checks permission for an operation on a destination based on the access control context. This method may accept, but is not limited to, the following input information: </paragraph>
<paragraph id="P-0087" lvl="3"><number>&lsqb;0087&rsqb;</number> The connection type. </paragraph>
<paragraph id="P-0088" lvl="3"><number>&lsqb;0088&rsqb;</number> The operation requested (e.g. &ldquo;produce&rdquo;, &ldquo;consume&rdquo;, &ldquo;browse&rdquo;, &ldquo;create&rdquo;). </paragraph>
<paragraph id="P-0089" lvl="3"><number>&lsqb;0089&rsqb;</number> The destination. </paragraph>
<paragraph id="P-0090" lvl="3"><number>&lsqb;0090&rsqb;</number> The destination type&mdash;e.g. queue or topic. </paragraph>
<paragraph id="P-0091" lvl="0"><number>&lsqb;0091&rsqb;</number> Client <highlight><bold>100</bold></highlight> may initiate a connection <highlight><bold>150</bold></highlight> with server <highlight><bold>110</bold></highlight>. The authentication protocol to be used between the client <highlight><bold>100</bold></highlight> and server <highlight><bold>110</bold></highlight> may then be determined. The client <highlight><bold>100</bold></highlight>, if necessary may then initialize the appropriate client-side authentication protocol handler module <highlight><bold>102</bold></highlight>. The server <highlight><bold>110</bold></highlight>, if necessary may also initialize a corresponding server-side authentication protocol handler module <highlight><bold>112</bold></highlight>. </paragraph>
<paragraph id="P-0092" lvl="0"><number>&lsqb;0092&rsqb;</number> After initializing the protocol handler modules, the server <highlight><bold>110</bold></highlight> may send a challenge to client <highlight><bold>100</bold></highlight>. The client <highlight><bold>100</bold></highlight> may pass the challenge to the client-side authentication protocol handler module <highlight><bold>102</bold></highlight>. The client-side authentication protocol handler module <highlight><bold>102</bold></highlight> may include a handle request method that may receive the authentication &ldquo;challenge&rdquo; from server <highlight><bold>110</bold></highlight> and respond to the challenge with the information required by the particular authentication protocol being used. The server may receive the response and pass the response to the server-side authentication protocol handler module <highlight><bold>112</bold></highlight>. </paragraph>
<paragraph id="P-0093" lvl="0"><number>&lsqb;0093&rsqb;</number> The server-side authentication protocol handler module <highlight><bold>112</bold></highlight> may include a handle response method that may receive the response message from the client <highlight><bold>100</bold></highlight> and may, in response to the message, send another request to the client <highlight><bold>100</bold></highlight>, authenticate the client <highlight><bold>100</bold></highlight>, or determine that the client <highlight><bold>100</bold></highlight> cannot be authenticated in accordance with the authentication protocol being used. Authentication may be determined by providing authentication information from the client <highlight><bold>100</bold></highlight> to the user repository <highlight><bold>120</bold></highlight> as indicated at <highlight><bold>152</bold></highlight>. If authentication is verified, then the user repository may return the authenticated subject to the server-side authentication protocol handler <highlight><bold>112</bold></highlight> as indicated at <highlight><bold>154</bold></highlight>. </paragraph>
<paragraph id="P-0094" lvl="0"><number>&lsqb;0094&rsqb;</number> The symmetrical nature of the handle request and handle response methods in the authentication protocol handler modules for the server and client sides reflects the symmetrical nature of the authentication request and response process. These methods work by exchanging data between the client and server rather than by using a callback method. Also, in one embodiment, the handle request and handle response methods are not dependent on the underlying transport protocol. Thus, the APIs provided by these modules may be easy to understand and to implement. Also, the APIs provided by the server and client authentication protocol handler modules may be generic, allowing the modules to be used in a variety of systems and services. </paragraph>
<paragraph id="P-0095" lvl="0"><number>&lsqb;0095&rsqb;</number> In one embodiment, authentication protocol handler modules may be provided that support non-symmetrical authentication mechanisms, for example, single sign-on across multiple applications. In one embodiment, handle request and handle response methods may be provided that may provide authentication through a third-party authentication server. </paragraph>
<paragraph id="P-0096" lvl="0"><number>&lsqb;0096&rsqb;</number> In one embodiment, the server-side authentication protocol handler implementation may take advantage of Secure Sockets Layer (SSL) client authentication (if using the SSL transport protocol) to bypass authentication, and/or may wrap the client SSL certificate in the access control context module to support certificate-based access control model. </paragraph>
<paragraph id="P-0097" lvl="0"><number>&lsqb;0097&rsqb;</number> In one embodiment, the handle request and handle response methods in the authentication protocol handler modules for the server and client sides may have a sequence number as an input argument to the method for correlation purposes. The sequence number may be the sequence number of the underlying transport protocol packet carrying the authentication data. In one embodiment, the sequence number may be embedded in the request/response data itself. In this embodiment, the client and server side protocol handlers may provide the sequence numbers. The sequence number may be used by the authentication protocol handler modules to correlate authentication requests and responses, for example, in situations when there are multiple requests and responses. </paragraph>
<paragraph id="P-0098" lvl="0"><number>&lsqb;0098&rsqb;</number> In one embodiment, since the authentication data, returned from or passed to the handle request and handle response methods in the authentication protocol handler modules for the server and client sides, is opaque to the underlying transport protocol, encryption/decryption may be applied to the authentication data. In one embodiment, the authentication protocol handler modules may apply encryption and decryption of data as required. </paragraph>
<paragraph id="P-0099" lvl="0"><number>&lsqb;0099&rsqb;</number> In one embodiment, once the authentication process successfully completes, the server security manager <highlight><bold>114</bold></highlight> may be directed by the server-side authentication protocol handler module <highlight><bold>112</bold></highlight> to an access control context module <highlight><bold>140</bold></highlight>. The access control context module <highlight><bold>140</bold></highlight> may be initialized, if necessary. In one embodiment, the server-side authentication protocol handler module <highlight><bold>112</bold></highlight> may include a method that may be called to get the access control context to be used in this implementation. In one embodiment, this method may return an access control context object. The access control context object may then be used to instantiate or locate the appropriate access control model <highlight><bold>130</bold></highlight>. The access control context module <highlight><bold>140</bold></highlight> may then be used by the security manager <highlight><bold>114</bold></highlight> in handling access requests to resources of server <highlight><bold>110</bold></highlight> by client <highlight><bold>100</bold></highlight>. In one embodiment, the authenticated subject and other related information may be encapsulated in the access control context module <highlight><bold>140</bold></highlight>, and thus the security manager <highlight><bold>114</bold></highlight> may not need to know how the authenticated subject is represented or stored at runtime. In one embodiment, an access control model <highlight><bold>130</bold></highlight> appropriate for the user repository <highlight><bold>120</bold></highlight> in use may be determined and loaded, if necessary. </paragraph>
<paragraph id="P-0100" lvl="0"><number>&lsqb;0100&rsqb;</number> In one embodiment, the server-side access control context module <highlight><bold>140</bold></highlight> does not restrict how an authenticated subject is represented. However, the implementation of the access control context module API may depend upon the access control model <highlight><bold>130</bold></highlight> being used. This document describes embodiments of an exemplary access control context module <highlight><bold>140</bold></highlight> and API for the access control model <highlight><bold>130</bold></highlight> of a messaging system such as a Java Message Service (JMS) system that uses the connection/destination concept in access control. In this model, connection refers to a client connection to a server. A client may publish/subscribe to messages at a destination (through a connection). There may be two types of destinations. First, messages may be placed in a queue, at some point another entity may extract the messages (at which point the messages may be deleted). Second, messages may be posted to a topic, and other entities may access the posted messages from the topic based on interest. </paragraph>
<paragraph id="P-0101" lvl="0"><number>&lsqb;0101&rsqb;</number> One embodiment of the exemplary access control context module <highlight><bold>140</bold></highlight> for a messaging system such as a JMS system may include a check connection permission method and a check destination permission method. The access control context module <highlight><bold>140</bold></highlight> may be operable to protect which clients are allowed to make a connection to a server and which clients may produce and/or consume messages to destinations (topics and/or queues). In one embodiment, the sending, consumption and browsing of messages at a destination, as well as the ability to create destinations, may be protected by the access control context module <highlight><bold>140</bold></highlight>. Both connections and destinations are protected as resources. Although the methods in the access control context module <highlight><bold>140</bold></highlight> as described herein are applicable to a messaging system such as the JMS system that uses the connection/destination concept, it is noted that embodiments of the system and method using other access control models are contemplated. </paragraph>
<paragraph id="P-0102" lvl="0"><number>&lsqb;0102&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1B</cross-reference> illustrates a networked system implementing the authentication and access control mechanism according to one embodiment. A client <highlight><bold>100</bold></highlight> and a server <highlight><bold>110</bold></highlight> may participate in a client-server system. Access control for resources of server <highlight><bold>110</bold></highlight> may be defined by an access control model <highlight><bold>130</bold></highlight>. Client information may be maintained in a user repository <highlight><bold>120</bold></highlight>. There may be a plurality of server-side pluggable authentication protocol handler modules (APH) <highlight><bold>112</bold></highlight> and corresponding client side pluggable authentication protocol handler modules (APH) <highlight><bold>102</bold></highlight>. Once an authentication type to be used between the client and server is determined, the client and server may each locate, load and initialize the appropriate protocol handler module as necessary. In this case, client-side authentication protocol handler <highlight><bold>102</bold></highlight>C and corresponding server-side authentication protocol handler <highlight><bold>112</bold></highlight>C are in use. </paragraph>
<paragraph id="P-0103" lvl="0"><number>&lsqb;0103&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1B</cross-reference> further illustrates the client-side authentication protocol handler modules <highlight><bold>102</bold></highlight> with client <highlight><bold>100</bold></highlight>, and the server-side authentication protocol handler modules <highlight><bold>112</bold></highlight> with server <highlight><bold>110</bold></highlight>. Note, however, that an authentication protocol handler module may actually reside on another system (e.g. another server or a peer in a peer-to-peer system) and may be downloaded to the client <highlight><bold>100</bold></highlight> or server <highlight><bold>110</bold></highlight> when required. For example, server <highlight><bold>110</bold></highlight> may store client-side authentication protocol handler modules <highlight><bold>102</bold></highlight>, and a copy of the appropriate module <highlight><bold>102</bold></highlight> may be provided to the client <highlight><bold>100</bold></highlight> during the connection process. </paragraph>
<paragraph id="P-0104" lvl="0"><number>&lsqb;0104&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> illustrates a user repository <highlight><bold>120</bold></highlight> and its relation to an access control model <highlight><bold>130</bold></highlight> according to one embodiment. User repository <highlight><bold>120</bold></highlight> may be implemented in a variety of ways, including, but not limited to, as an LDAP directory service, a database, a flat file, an NIS&plus; directory service, etc. The server-side authentication protocol handler module <highlight><bold>112</bold></highlight> may access the user repository during authentication of the client <highlight><bold>100</bold></highlight>. The access control model <highlight><bold>130</bold></highlight> and access control context module <highlight><bold>140</bold></highlight> may also need to access user information when handling access requests from the client <highlight><bold>100</bold></highlight>. In one embodiment, the access control information that the access control model uses may be kept in the same physical repository as the user repository <highlight><bold>120</bold></highlight>. In another embodiment, the access control information may be implemented in a separate physical repository from the user repository <highlight><bold>120</bold></highlight>. The access control information may be implemented in a data repository such as an LDAP directory service, a database such as an RDMS database, a flat file, etc. In yet another embodiment, portions of the access control information may be kept in different physical repositories. </paragraph>
<paragraph id="P-0105" lvl="0"><number>&lsqb;0105&rsqb;</number> As an example, a company may keep employee information in an LDAP server. Employee information may be kept on the LDAP server. The server-side authentication protocol handler module <highlight><bold>112</bold></highlight> may access the employee information during authentication to determine if a client is a valid employee. The access control context module <highlight><bold>140</bold></highlight> may access employee information from the LDAP server during access control of on-line company resources. Alternatively, the employee information necessary for access control may be kept in a flat file on a server separate from the LDAP server. </paragraph>
<paragraph id="P-0106" lvl="0"><number>&lsqb;0106&rsqb;</number> In one embodiment, the access control model and the user repository may use the same repository to store access control information for the access control model and user identity and credential information for authentication. In another embodiment, separate repositories may be used. For example, user authentication information may be stored in an LDAP directory and access control information may be stored in a flat file. In one embodiment where the access control information and authentication information are stored in different physical repositories, the access control model may access the user repository for certain user information in determining resource access permission. </paragraph>
<paragraph id="P-0107" lvl="0"><number>&lsqb;0107&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a flow diagram illustrating the use of the authentication and access control mechanism to authenticate a client <highlight><bold>100</bold></highlight> and provide access control for resources of a server <highlight><bold>110</bold></highlight> according to one embodiment. Note that, in one embodiment, communications between the client and the server during connection establishment, authentication, and access of resources may flow through the security manager <highlight><bold>114</bold></highlight>. At the beginning of connection establishment, the server <highlight><bold>110</bold></highlight> and client <highlight><bold>100</bold></highlight> may negotiate an authentication type through the underlining transport protocol. Then both sides may initialize an appropriate authentication protocol handler for the selected authentication type. The server-side authentication protocol handler initialization may include any initialization needed for the configured user repository. Then a challenge from the server <highlight><bold>110</bold></highlight> may be sent to the client <highlight><bold>100</bold></highlight>. The challenge may include initial authentication request data returned from the server-side authentication protocol handler (APH) <highlight><bold>112</bold></highlight> initialization method. </paragraph>
<paragraph id="P-0108" lvl="0"><number>&lsqb;0108&rsqb;</number> The client <highlight><bold>100</bold></highlight>, upon receiving the challenge from the underlying transport protocol, may pass the authentication request data to the client-side authentication protocol handler (APH) <highlight><bold>102</bold></highlight>. The client-side authentication protocol handler&apos;s handle request method may then process the request and generate response data (e.g. digested user name and password or some other identification and credentials). The client <highlight><bold>100</bold></highlight> then may send the response data returned from the handle request method to the server <highlight><bold>110</bold></highlight>. The server <highlight><bold>110</bold></highlight> then may pass the authentication response data to the server-side authentication protocol handler <highlight><bold>112</bold></highlight>. The server-side authentication protocol handler&apos;s handle response method may then access the user repository (UR) <highlight><bold>120</bold></highlight> to authenticate (verify) the client (e.g. the user name and password). This request and response process may be repeated depending on the requirements of the authentication mechanism. </paragraph>
<paragraph id="P-0109" lvl="0"><number>&lsqb;0109&rsqb;</number> If the server-side authentication protocol handler <highlight><bold>112</bold></highlight> successfully authenticates the client using the user repository <highlight><bold>120</bold></highlight>, the server <highlight><bold>110</bold></highlight> may send a success reply to the client <highlight><bold>100</bold></highlight> to inform the client <highlight><bold>100</bold></highlight> that the authentication process is now complete. If the authentication fails, the server <highlight><bold>110</bold></highlight> may send a failure reply to the client <highlight><bold>100</bold></highlight> and the connection may be aborted. If the authentication process is successful, the server&apos;s security manager <highlight><bold>114</bold></highlight> may retrieve an access control context module <highlight><bold>140</bold></highlight> from the server-side authentication protocol handler <highlight><bold>112</bold></highlight>. The access control context module (ACCM) <highlight><bold>140</bold></highlight> may encapsulate the authenticated subject and any other information necessary for later access control use. The access control context module <highlight><bold>140</bold></highlight> may then be initialized, which may involve loading the configured access control model (ACM) <highlight><bold>130</bold></highlight>. </paragraph>
<paragraph id="P-0110" lvl="0"><number>&lsqb;0110&rsqb;</number> Once the client <highlight><bold>100</bold></highlight> is successfully authenticated, the client may send service requests to the server <highlight><bold>110</bold></highlight> through the underlying transport protocol. A service request may request access to a protected resource (for example, in a JMS system, a destination). The server&apos;s security manager <highlight><bold>114</bold></highlight> may interface with the access control context module <highlight><bold>114</bold></highlight> to check whether the authenticated client <highlight><bold>100</bold></highlight> has the necessary permission to access the protected resource. The access control context module <highlight><bold>140</bold></highlight>, in turn, may interface with its associated access control model <highlight><bold>130</bold></highlight> to determine the permission. If necessary, in one embodiment, the access control model <highlight><bold>130</bold></highlight> may need to query the user repository <highlight><bold>120</bold></highlight> for additional information on the authenticated subject, for example group information in case of group based access control. If access is permitted to the resource, the authenticated client <highlight><bold>100</bold></highlight> is allowed to access the resource; otherwise access is denied. </paragraph>
<paragraph id="P-0111" lvl="0"><number>&lsqb;0111&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a flowchart illustrating a method of authenticating a client according to one embodiment. As indicated at <highlight><bold>400</bold></highlight>, a client may first send a connection request to a server. The type of authentication to be used by the server for the client may then be determined as indicated at <highlight><bold>402</bold></highlight>. In one embodiment, the server and client may negotiate to determine an appropriate authentication type. Once the authentication type is determined, a server-side authentication protocol handler for the authentication type may be located and plugged in as indicated at <highlight><bold>404</bold></highlight>. As indicated at <highlight><bold>406</bold></highlight>, a client-side authentication protocol handler for the authentication type may also be located and plugged in. In one embodiment, the server may provide the client-side authentication protocol handler to the client. The server then may send a challenge to the client as indicated at <highlight><bold>408</bold></highlight>. The client may pass the challenge to the client-side authentication protocol handler, which may generate a response to the challenge as indicated at <highlight><bold>410</bold></highlight>. In one embodiment, a handle request method of the client-side authentication protocol handler may generate the response. The response may include client information for use by the server in authenticating the client. </paragraph>
<paragraph id="P-0112" lvl="0"><number>&lsqb;0112&rsqb;</number> The server may receive the response from the client and pass the response to the server-side authentication protocol handler. The server-side authentication protocol handler may then examine the response to determine if the client is authentic as indicated at <highlight><bold>412</bold></highlight>. In one embodiment, the server-side authentication protocol handler may pass the response, or alternatively the client information from the response, to a user repository, which may compare the client information to information for one or more clients of the server kept in the user repository. In another embodiment, the server-side authentication protocol handler may itself compare the client information to information for one or more clients. The comparison may determine if the client is authentic (i.e. that the client information is authentic, and is consistent with client information in the user repository). Note that, in one embodiment, a series of requests and responses may be sent between the client and the server during the authentication process. At <highlight><bold>414</bold></highlight>, if the comparison determines the client is not authentic, the client is denied access to the server as indicated at <highlight><bold>416</bold></highlight>. At <highlight><bold>414</bold></highlight>, if the comparison determines the client is authentic, the client is granted access to the server. The server-side authentication protocol handler may then determine an access control model to be used as indicated at <highlight><bold>418</bold></highlight>. Once the access control model is determined, an access control context module for the determined access control model may be located or alternatively generated and plugged in as indicated at <highlight><bold>420</bold></highlight>. In one embodiment, the server-side authentication protocol handler may return an access control context module object to the security manager, and the access control context module then may determine (e.g. during initialization) an access control model to be used (i.e. plugged in) based on the configuration. </paragraph>
<paragraph id="P-0113" lvl="0"><number>&lsqb;0113&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a flowchart illustrating a method of access control to server resources according to one embodiment. After the client is authenticated, the access control model is determined, and the access control context module is initialized, the client may send to the server a request to access a resource of the server as indicated at <highlight><bold>500</bold></highlight>. The access control context module may receive the request to access the resource as indicated at <highlight><bold>502</bold></highlight>. The access control context module then may determine if the client has access permission to the resource as indicated at <highlight><bold>504</bold></highlight>. At <highlight><bold>506</bold></highlight>, if the client does not have access permission to the resource, then the server may inhibit the client from accessing the resource as indicated at <highlight><bold>508</bold></highlight>. At <highlight><bold>506</bold></highlight>, if the client does have access permission to the resource, then the server may allow client to access the resource as indicated at <highlight><bold>510</bold></highlight>. </paragraph>
<paragraph id="P-0114" lvl="0"><number>&lsqb;0114&rsqb;</number> The methods as described in <cross-reference target="DRAWINGS">FIGS. 3, 4</cross-reference> and <highlight><bold>5</bold></highlight> may be implemented in software, hardware, or a combination thereof. The order of method may be changed, and various steps may be added, reordered, combined, omitted, modified, etc. </paragraph>
<paragraph id="P-0115" lvl="7"><number>&lsqb;0115&rsqb;</number> Implementation in a JMS-Based Messaging Service </paragraph>
<paragraph id="P-0116" lvl="0"><number>&lsqb;0116&rsqb;</number> This section describes an exemplary implementation of one embodiment of the authentication and access control mechanism in an exemplary messaging system. This section is included for illustrative purposes and is not intended to be limiting. The exemplary messaging system is iPlanet E-Commerce Solutions&apos; iMQ (iPlanet Message Queue). iMQ provides authentication and authorization (access control) features, and also supports encryption capabilities. The authentication and authorization features depend upon a user repository: a file, directory, or database that contains information about the users of the messaging system&mdash;their names, passwords, and group memberships. The names and passwords are used to authenticate a user when a connection to a broker is requested. The user names and group memberships are used, in conjunction with an access control file, to authorize operations such as producing or consuming messages for destinations. iMQ administrators may populate an iMQ-provided user repository, or alternatively plug a pre-existing LDAP user repository into the iMQ Security Manager component. </paragraph>
<paragraph id="P-0117" lvl="0"><number>&lsqb;0117&rsqb;</number> iMQ security supports password-based authentication. When a client requests a connection to a broker, the client must submit a user name and password. The iMQ Security Manager <highlight><bold>114</bold></highlight> compares the name and password submitted by the client to those stored in the user repository <highlight><bold>120</bold></highlight> as illustrated in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>. Note that, in one embodiment, the security manager <highlight><bold>114</bold></highlight> may access the user repository <highlight><bold>120</bold></highlight> through a pluggable server-side authentication protocol handler module <highlight><bold>112</bold></highlight>. On transmitting the password from client to broker, the passwords may be encoded using either base64 encoding or message digest, MD5. The type of encoding used by each connection service may be separately configured, or alternatively the encoding may be set on a broker-wide basis. </paragraph>
<paragraph id="P-0118" lvl="0"><number>&lsqb;0118&rsqb;</number> Once the user of a client application has been authenticated, the user can be authorized to perform various iMQ-related activities. The iMQ Security Manager supports both user-based and group-based access control: depending on a user&apos;s name or the groups to which the user is assigned in the user repository <highlight><bold>120</bold></highlight>, that user has permission to perform certain iMQ operations. These access controls may be specified in an access control properties file <highlight><bold>150</bold></highlight> as illustrated in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>. When a user attempts to perform an operation, the Security Manager <highlight><bold>114</bold></highlight> checks the user&apos;s name and group membership (from the user repository <highlight><bold>120</bold></highlight>) against those specified for access to that operation (in the access control properties file <highlight><bold>150</bold></highlight>). The access control properties file may specify permissions for the following operations: </paragraph>
<paragraph id="P-0119" lvl="2"><number>&lsqb;0119&rsqb;</number> establishing a connection to an iMQ connection service with a broker </paragraph>
<paragraph id="P-0120" lvl="2"><number>&lsqb;0120&rsqb;</number> accessing destinations: creating a consumer, a producer, or a queue browser for any given destination or all destinations </paragraph>
<paragraph id="P-0121" lvl="2"><number>&lsqb;0121&rsqb;</number> auto-creating destinations </paragraph>
<paragraph id="P-0122" lvl="0"><number>&lsqb;0122&rsqb;</number> Note that, in one embodiment, the security manager <highlight><bold>114</bold></highlight> may access the user repository <highlight><bold>120</bold></highlight> through a pluggable authentication protocol handler <highlight><bold>112</bold></highlight>, and may also access the access control properties file <highlight><bold>150</bold></highlight> through a pluggable access control context module <highlight><bold>140</bold></highlight> and an access control model <highlight><bold>130</bold></highlight>. </paragraph>
<paragraph id="P-0123" lvl="0"><number>&lsqb;0123&rsqb;</number> In one embodiment, the default access control properties file <highlight><bold>150</bold></highlight> explicitly references only one group: admin. A user in the admin group has admin service connection permission. The admin service lets the user perform administrative functions such as creating destinations, and monitoring and controlling a broker. A user in any other defined group cannot, by default, get an admin service connection. </paragraph>
<paragraph id="P-0124" lvl="0"><number>&lsqb;0124&rsqb;</number> An iMQ administrator may define groups and associate users with those groups in a user repository. Then, by editing the access control properties file, the administrator may specify access to destinations by users and groups for the purpose of producing and consuming messages, or browsing messages in queue destinations. The administrator may make individual destinations or all destinations accessible only to specific users or groups. In addition, if the broker is configured to allow auto-creation of destinations, the administrator may control for whom the broker can auto-create destinations by editing the access control properties file. </paragraph>
<paragraph id="P-0125" lvl="0"><number>&lsqb;0125&rsqb;</number> Configurable properties for authentication and authorization in iMQ may include, but are not limited to: </paragraph>
<paragraph id="P-0126" lvl="2"><number>&lsqb;0126&rsqb;</number> authentication.type&mdash;Specifies whether password should be passed in base64 coding (basic) or as a MD5 digest (digest). Sets encoding for all connection services supported by a broker. Default: digest. </paragraph>
<paragraph id="P-0127" lvl="2"><number>&lsqb;0127&rsqb;</number> service_name.authentication.type&mdash;Specifies whether password should be passed in base64 coding (basic) or as a MD5 digest (digest). Sets encoding for named connection service, overriding any broker-wide setting. Default: inherited from the value to which authentication.type is set. </paragraph>
<paragraph id="P-0128" lvl="2"><number>&lsqb;0128&rsqb;</number> authentication.basic.user_repository&mdash;Specifies (for base64 coding) the type of user repository used for authentication, either file-based (file) or LDAP (ldap). Default: file. </paragraph>
<paragraph id="P-0129" lvl="2"><number>&lsqb;0129&rsqb;</number> authentication.client.response.timeout&mdash;Specifies the time (in seconds) the system will wait for a client to respond to an authentication request from the broker. Default: 180 seconds. </paragraph>
<paragraph id="P-0130" lvl="2"><number>&lsqb;0130&rsqb;</number> accesscontrol.enabled&mdash;Sets access control (true/false) for all connection services supported by a broker. Indicates whether system will check if an authenticated user has permission to use a connection service or to perform specific iMQ operations with respect to specific destinations, as specified in the access control properties file. Default: true. </paragraph>
<paragraph id="P-0131" lvl="2"><number>&lsqb;0131&rsqb;</number> service_name.accesscontrol.enabled&mdash;Sets access control (true/false) for named connection service, overriding broker-wide setting. Indicates whether system will check if an authenticated user has permission to use the named connection service or to perform specific iMQ operations with respect to specific destinations, as specified in the access control properties file. Default: inherits the setting of the property accesscontrol.enabled. </paragraph>
<paragraph id="P-0132" lvl="2"><number>&lsqb;0132&rsqb;</number> accesscontrol.file.filename&mdash;Specifies the name of an access control properties file for all connection services supported by a broker. The file name specifies a relative file path to a security directory. Default: accesscontrol.properties. </paragraph>
<paragraph id="P-0133" lvl="2"><number>&lsqb;0133&rsqb;</number> service_name.accesscontrol.file.filename&mdash;Specifies the name of an access control properties file for named connection service. The file name specifies a relative file path to a security directory. Default: inherits the setting specified by accesscontrol.file.filename. </paragraph>
<paragraph id="P-0134" lvl="0"><number>&lsqb;0134&rsqb;</number> Various embodiments may further include receiving, sending or storing instructions and/or data implemented in accordance with the foregoing description upon a carrier medium. Generally speaking, a carrier medium may include storage media or memory media such as magnetic or optical media, e.g., disk or CD-ROM, volatile or nonvolatile media such as RAM (e.g. SDRAM, DDR SDRAM, RDRAM, SRAM, etc.), ROM, etc. as well as transmission media or signals such as electrical, electromagnetic, or digital signals, conveyed via a communication medium such as network and/or a wireless link. </paragraph>
<paragraph id="P-0135" lvl="0"><number>&lsqb;0135&rsqb;</number> In summary, a system and method for providing pluggable authentication and access control in computer systems and services have been disclosed. It will be appreciated by those of ordinary skill having the benefit of this disclosure that the illustrative embodiments described above are capable of numerous variations without departing from the scope and spirit of the invention. Various modifications and changes may be made as would be obvious to a person skilled in the art having the benefit of this disclosure. It is intended that the following claims be interpreted to embrace all such modifications and changes and, accordingly, the specifications and drawings are to be regarded in an illustrative rather than a restrictive sense. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method comprising: 
<claim-text>determining an authentication type to be used between a first node and a second node in a networked computer system; </claim-text>
<claim-text>plugging in a first authentication protocol handler module on the first node for the determined authentication type, wherein the first authentication protocol handler module is configured for use in generating authentication information for the first node for sending to the second node; </claim-text>
<claim-text>plugging in a second authentication protocol handler module on the second node for the determined authentication type, wherein the second authentication protocol handler module is configured for use in determining if the first node is authentic using the first node authentication information; </claim-text>
<claim-text>determining an access control model to be used by the second node in controlling access to resources of the second node by the first node; and </claim-text>
<claim-text>plugging in an access control context module for the determined access control model on the second node, wherein the access control context module is configured for use in controlling access to resources of the second node by the first node using the access control model. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising loading the determined access control model. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the access control context module encapsulates information configured for use in controlling access to the resources of the second node by the first node. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the first authentication protocol handler module includes a handle request method, wherein the second authentication protocol handler module includes a handle response method, wherein the handle request method and handle response method are configured to exchange authentication information during an authentication process for the first node. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising: 
<claim-text>the second node sending a challenge to the first node, wherein the challenge is in accordance with the determined authentication type; </claim-text>
<claim-text>the first authentication protocol handler module generating response data in response to the challenge, wherein the response data includes information for use in authenticating the first node; </claim-text>
<claim-text>the first node sending the response data to the second node; and </claim-text>
<claim-text>the second authentication protocol handler module authenticating the first node using the received response data. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference>, wherein said authenticating the first node using the received response data comprises: 
<claim-text>the second authentication protocol handler module sending the received response data to a user repository, wherein the user repository comprises node information associated with one or more network nodes; and </claim-text>
<claim-text>the user repository comparing the response data to the node information to authenticate the first node. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising: 
<claim-text>authenticating the first node using the first authentication protocol handler module and the second authentication protocol handler module; </claim-text>
<claim-text>the authenticated first node sending to the second node a request for access to a resource of the second node; and </claim-text>
<claim-text>the access control context module determining if the first node has access permission to the resource in response to the request for access to the resource of the second node. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference>, further comprising: 
<claim-text>if said determining determines the first node has access permission to the resource, allowing the first node to access the resource; and </claim-text>
<claim-text>if said determining determines the first node does not have access permission to the resource, inhibiting the first node from accessing the resource. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, 
<claim-text>wherein the second authentication protocol handler module is further configured for use in generating authentication information for the second node for sending to the first node; and </claim-text>
<claim-text>wherein the first authentication protocol handler module is further configured for use in determining if the second node is authentic using the second node authentication information. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the networked computer system is a messaging-based system. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the networked computer system uses the Java Message Service (JMS) to support messaging between nodes in the network. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein networked computer system is a client-server system, wherein the first node is a client in the client-server system, and wherein the second node is a server in the client-server system. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the networked computer system is a peer-to-peer system, wherein the first node and the second node are peers in the peer-to-peer system. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. A method for authenticating nodes in a networked computer system, comprising: 
<claim-text>a first node initiating a connection to a second node in the networked computer system; </claim-text>
<claim-text>determining an authentication type to be used by the first node and the second node; </claim-text>
<claim-text>initializing a first authentication protocol handler on the first node for the determined authentication type; </claim-text>
<claim-text>initializing a second authentication protocol handler on the second node for the determined authentication type; </claim-text>
<claim-text>the second node sending a challenge to the first node, wherein the challenge is in accordance with the determined authentication type; </claim-text>
<claim-text>the first authentication protocol handler generating response data in response to the challenge, wherein the response data includes information for use in authenticating the first node; </claim-text>
<claim-text>the first node sending the response data to the second node; and </claim-text>
<claim-text>the second authentication protocol handler authenticating the first node using the received response data; </claim-text>
<claim-text>wherein the first authentication protocol handler and the second authentication protocol handler are pluggable modules configured to be replaced to support different authentication types. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference>, wherein said authenticating the first node using the received response data comprises: 
<claim-text>the second authentication protocol handler sending the received response data to a user repository, wherein the user repository comprises node information associated with one or more nodes; and </claim-text>
<claim-text>the user repository comparing the response data to the node information to authenticate the first node. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference>, further comprising, if the first node is successfully authenticated: 
<claim-text>determining an access control model to be used by the second node for the first node; and </claim-text>
<claim-text>initializing an access control context module for the determined access control model, wherein the access control context module is configured for use in controlling access to resources of the second node by the first node using the access control model. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, wherein the access control context module is a pluggable module configured to be replaced to support different access control models. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, wherein the access control context module is configured to support different pluggable access control models. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, further comprising loading the determined access control model. </claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, wherein the access control context module encapsulates information configured for use in controlling access to the resources of the second node by the first node. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, further comprising: 
<claim-text>the first node sending to the second node a request for access to a resource of the second node; </claim-text>
<claim-text>the access control context module determining if the first node has access permission to the resource; </claim-text>
<claim-text>if said determining determines the first node has access permission to the resource, allowing the first node to access the resource; and </claim-text>
<claim-text>if said determining determines the first node does not have access permission to the resource, inhibiting the first node from accessing the resource. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference>, wherein the networked computer system is a messaging-based system. </claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference>, wherein the networked computer system uses the Java Message Service (JMS) to support messaging between entities in the network. </claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference>, wherein networked computer system is a client-server system, wherein the first node is a client in the client-server system, and wherein the second node is a server in the client-server system. </claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference>, wherein the networked computer system is a peer-to-peer system, wherein the first node and the second node are peers in the peer-to-peer system. </claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. A method comprising: 
<claim-text>a second node determining an authentication type to be used by the second node to authenticate a first node in a networked computer system; </claim-text>
<claim-text>the second node plugging in a second authentication protocol handler module for the determined authentication type, wherein the second authentication protocol handler module is configured for use in determining if the first node is authentic using authentication information associated with the first node, wherein the first node authentication information is generated by a pluggable first authentication protocol handler module on the first node for the determined authentication type; </claim-text>
<claim-text>the second node determining an access control model to be used by the second node for the first node; and </claim-text>
<claim-text>the second node plugging in an access control context module for the determined access control model, wherein the access control context module is configured for use in controlling access to resources of the second node by the first node using the access control model. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00022">claim 26</dependent-claim-reference>, wherein the access control context module encapsulates information configured for use in controlling access to the resources of the second node by the first node. </claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00022">claim 26</dependent-claim-reference>, wherein the second authentication protocol handler module includes a handle response method, wherein the handle response method is configured to exchange authentication information with a corresponding a handle request method of the first authentication protocol handler module during an authentication process for the first node. </claim-text>
</claim>
<claim id="CLM-00029">
<claim-text><highlight><bold>29</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00022">claim 26</dependent-claim-reference>, further comprising: 
<claim-text>the second node sending a challenge to the first node, wherein the challenge is in accordance with the determined authentication type; </claim-text>
<claim-text>the second authentication protocol handler module receiving response data in response to the challenge, wherein the response data includes information for use in authenticating the first node, and wherein the response data is generated by the first authentication protocol handler module; and </claim-text>
<claim-text>the second authentication protocol handler module authenticating the first node using the received response data. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00030">
<claim-text><highlight><bold>30</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00022">claim 29</dependent-claim-reference>, wherein said authenticating the first node using the received response data comprises: 
<claim-text>the second authentication protocol handler module sending the received response data to a user repository, wherein the user repository comprises node information associated with one or more nodes; and </claim-text>
<claim-text>the user repository comparing the response data to the node information to authenticate the first node. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00031">
<claim-text><highlight><bold>31</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00022">claim 26</dependent-claim-reference>, further comprising: 
<claim-text>authenticating the first node; </claim-text>
<claim-text>the access control context module receiving a request for access to a resource of the second node from the authenticated first node; and </claim-text>
<claim-text>the access control context module determining if the first node has access permission to the resource in response to the request for access to the resource of the second node. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00032">
<claim-text><highlight><bold>32</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00033">claim 31</dependent-claim-reference>, further comprising: 
<claim-text>if said determining determines the first node has access permission to the resource, the second node allowing the first node to access the resource; and </claim-text>
<claim-text>if said determining determines the first node does not have access permission to the resource, the second node inhibiting the first node from accessing the resource. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00033">
<claim-text><highlight><bold>33</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00022">claim 26</dependent-claim-reference>, wherein the networked computer system is a messaging-based system. </claim-text>
</claim>
<claim id="CLM-00034">
<claim-text><highlight><bold>34</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00022">claim 26</dependent-claim-reference>, wherein the networked computer system uses the Java Message Service (JMS) to support messaging between entities in the network. </claim-text>
</claim>
<claim id="CLM-00035">
<claim-text><highlight><bold>35</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00022">claim 26</dependent-claim-reference>, wherein networked computer system is a client-server system, wherein the first node is a client in the client-server system, and wherein the second node is a server in the client-server system. </claim-text>
</claim>
<claim id="CLM-00036">
<claim-text><highlight><bold>36</bold></highlight>. The method as recited in <dependent-claim-reference depends_on="CLM-00022">claim 26</dependent-claim-reference>, wherein the networked computer system is a peer-to-peer system, wherein the first node and the second node are peers in the peer-to-peer system. </claim-text>
</claim>
<claim id="CLM-00037">
<claim-text><highlight><bold>37</bold></highlight>. A system comprising: 
<claim-text>a first node comprising a first memory, wherein the first memory comprises first program instructions executable within the first node to initiate a connection request to the second node; </claim-text>
<claim-text>a second node comprising a second memory, wherein the second memory comprises second program instructions; </claim-text>
<claim-text>wherein the second program instructions are executable within the second node to: 
<claim-text>determine an authentication type for use in authentication of the first node in response to the first program instructions initiating a connection request to the second node; </claim-text>
<claim-text>initialize a second authentication protocol handler module on the second node for the determined authentication type; </claim-text>
<claim-text>determine an access control model to be used by the second node; and </claim-text>
<claim-text>initialize an access control context module for the determined access control model, wherein the access control context module is configured for use in controlling access to resources of the second node by the first node using the access control model; </claim-text>
</claim-text>
<claim-text>wherein the first program instructions are further executable within the first node to initialize a first authentication protocol handler module on the first node for the determined authentication type; and </claim-text>
<claim-text>wherein the first authentication protocol handler module and the second authentication protocol handler module are pluggable modules configured to be replaced to support different authentication types. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00038">
<claim-text><highlight><bold>38</bold></highlight>. The system as recited in <dependent-claim-reference depends_on="CLM-00033">claim 37</dependent-claim-reference>, wherein the access control context module is a pluggable module configured to be replaced to support different access control models. </claim-text>
</claim>
<claim id="CLM-00039">
<claim-text><highlight><bold>39</bold></highlight>. The system as recited in <dependent-claim-reference depends_on="CLM-00033">claim 37</dependent-claim-reference>, wherein the access control context module is configured to support different pluggable access control models. </claim-text>
</claim>
<claim id="CLM-00040">
<claim-text><highlight><bold>40</bold></highlight>. The system as recited in <dependent-claim-reference depends_on="CLM-00033">claim 37</dependent-claim-reference>, wherein the access control context module encapsulates information configured for use in controlling access to the resources of the second node by the first node. </claim-text>
</claim>
<claim id="CLM-00041">
<claim-text><highlight><bold>41</bold></highlight>. The system as recited in <dependent-claim-reference depends_on="CLM-00033">claim 37</dependent-claim-reference>, wherein the second program instructions are further executable within the second node to: 
<claim-text>send a challenge to the first node, wherein the challenge is in accordance with the determined authentication type; </claim-text>
<claim-text>wherein the first authentication protocol handler module is executable within the first node to generate response data in response to the challenge, wherein the response data includes information for use in authenticating the first node; </claim-text>
<claim-text>wherein the first program instructions are further configured to send the response data generated by the first authentication protocol handler module to the second node; and </claim-text>
<claim-text>wherein the second authentication protocol handler module is executable within the second node to authenticate the first node using the received response data. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00042">
<claim-text><highlight><bold>42</bold></highlight>. The system as recited in <dependent-claim-reference depends_on="CLM-00044">claim 41</dependent-claim-reference>, wherein the second node further comprises a user repository comprising information associated with one or more nodes, and wherein, in said authenticating the first node using the received response data, the second authentication protocol handler module is further executable within the second node to compare the response data received from the first node to the node information in the user repository to authenticate the first node. </claim-text>
</claim>
<claim id="CLM-00043">
<claim-text><highlight><bold>43</bold></highlight>. The system as recited in <dependent-claim-reference depends_on="CLM-00033">claim 37</dependent-claim-reference>, 
<claim-text>wherein the second authentication protocol handler module is executable within the second node to exchange information with the first authentication protocol handler module executing within the first node to authenticate the first node; </claim-text>
<claim-text>wherein the first program instructions are further executable within the first node to send to the second node a request for access to a resource of the second node; and </claim-text>
<claim-text>wherein the access control context module is executable within the second node to determine if the first node has access permission to the resource in response to the request for access to the resource of the second node. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00044">
<claim-text><highlight><bold>44</bold></highlight>. The system as recited in <dependent-claim-reference depends_on="CLM-00044">claim 43</dependent-claim-reference>, wherein the second program instructions are further executable within the second node to: 
<claim-text>allow the first node to access the resource if said determining determines the first node has access permission to the resource; and </claim-text>
<claim-text>inhibit the first node from accessing the resource if said determining determines the first node does not have access permission to the resource. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00045">
<claim-text><highlight><bold>45</bold></highlight>. The system as recited in <dependent-claim-reference depends_on="CLM-00033">claim 37</dependent-claim-reference>, wherein the system is a messaging-based system. </claim-text>
</claim>
<claim id="CLM-00046">
<claim-text><highlight><bold>46</bold></highlight>. The system as recited in <dependent-claim-reference depends_on="CLM-00033">claim 37</dependent-claim-reference>, wherein system uses the Java Message Service (JMS) to support messaging between the first node and the second node. </claim-text>
</claim>
<claim id="CLM-00047">
<claim-text><highlight><bold>47</bold></highlight>. The system as recited in <dependent-claim-reference depends_on="CLM-00033">claim 37</dependent-claim-reference>, wherein the system is a client-server system, wherein the second node is a server node, wherein the second program instructions are further executable within the second node to implement a server, and wherein the first node is a client node, wherein the first program instructions are further executable within the first node to implement a client application. </claim-text>
</claim>
<claim id="CLM-00048">
<claim-text><highlight><bold>48</bold></highlight>. The system as recited in <dependent-claim-reference depends_on="CLM-00033">claim 37</dependent-claim-reference>, wherein the system is a peer-to-peer system, wherein the first node and the second node are peers in the peer-to-peer system. </claim-text>
</claim>
<claim id="CLM-00049">
<claim-text><highlight><bold>49</bold></highlight>. A system comprising: 
<claim-text>a first node comprising a first memory, wherein the first memory comprises first program instructions executable within the client node to implement a client application; </claim-text>
<claim-text>a second node comprising a second memory, wherein the second memory comprises second program instructions executable within the second node to implement a server; </claim-text>
<claim-text>wherein the server is executable within the server node to: 
<claim-text>receive a connection request from the client application; </claim-text>
<claim-text>determine an authentication type for use in authentication of the client application in response to the connection request; </claim-text>
<claim-text>plug in a server-side authentication protocol handler module for the determined authentication type; </claim-text>
</claim-text>
<claim-text>wherein the client application is executable within the client node to plug in a client-side authentication protocol handler module for the determined authentication type; </claim-text>
<claim-text>wherein the client-side authentication protocol handler module is executable within the client node to: 
<claim-text>receive a challenge from the server, wherein the challenge is in accordance with the determined authentication type; </claim-text>
<claim-text>generate response data in response to the received challenge, wherein the response data includes information for use in authenticating the client application; </claim-text>
</claim-text>
<claim-text>wherein the server-side authentication protocol handler module is executable within the server node to: 
<claim-text>receive the generated response data; and </claim-text>
<claim-text>authenticate the client application using the received response data. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00050">
<claim-text><highlight><bold>50</bold></highlight>. The system as recited in <dependent-claim-reference depends_on="CLM-00044">claim 49</dependent-claim-reference>, wherein the server node further comprises a user repository comprising client information associated with one or more clients, and wherein, in said authenticating the client application using the received response data, the server-side authentication protocol handler module is further executable within the server node to compare the received response data to the client information in the user repository to authenticate the client. </claim-text>
</claim>
<claim id="CLM-00051">
<claim-text><highlight><bold>51</bold></highlight>. The system as recited in <dependent-claim-reference depends_on="CLM-00044">claim 49</dependent-claim-reference>, wherein, if the client is successfully authenticated, the server is further executable within the server node to: 
<claim-text>determine an access control model to be used by the server for the client application; and </claim-text>
<claim-text>plug in an access control context module for the determined access control model, wherein the access control context module is configured for use by the server in controlling access to resources of the server by the client application. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00052">
<claim-text><highlight><bold>52</bold></highlight>. The system as recited in <dependent-claim-reference depends_on="CLM-00055">claim 51</dependent-claim-reference>, wherein the access control context module encapsulates information configured for use in controlling access to the resources of the server by the client. </claim-text>
</claim>
<claim id="CLM-00053">
<claim-text><highlight><bold>53</bold></highlight>. The system as recited in <dependent-claim-reference depends_on="CLM-00055">claim 51</dependent-claim-reference>, wherein the access control context module is executable within the server node to: 
<claim-text>receive a request for access to a resource of the server from the client application; </claim-text>
<claim-text>determine if the client application has access permission to the resource; </claim-text>
<claim-text>if said determining determines the client application has access permission to the resource, permitting the client application to access the resource; and </claim-text>
<claim-text>if said determining determines the client application does not have access permission to the resource, inhibiting the client application from accessing the resource. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00054">
<claim-text><highlight><bold>54</bold></highlight>. The system as recited in <dependent-claim-reference depends_on="CLM-00044">claim 49</dependent-claim-reference>, wherein the system is a messaging-based system. </claim-text>
</claim>
<claim id="CLM-00055">
<claim-text><highlight><bold>55</bold></highlight>. The system as recited in <dependent-claim-reference depends_on="CLM-00044">claim 49</dependent-claim-reference>, wherein the system uses the Java Message Service (JMS) to support messaging between entities in the system. </claim-text>
</claim>
<claim id="CLM-00056">
<claim-text><highlight><bold>56</bold></highlight>. A server system comprising: 
<claim-text>a memory, wherein the memory comprises program instructions executable within the server node to implement a server; </claim-text>
<claim-text>wherein the server is executable within the server node to: 
<claim-text>receive a connection request from a client application; </claim-text>
<claim-text>determine an authentication type for use in authentication of the client application in response to the connection request; </claim-text>
<claim-text>plug in a server-side authentication protocol handler module for the determined authentication type; and </claim-text>
<claim-text>send a challenge to the client application, wherein the challenge is in accordance with the determined authentication type; </claim-text>
</claim-text>
<claim-text>wherein the server-side authentication protocol handler module is executable within the server system to 
<claim-text>receive response data from the client application, wherein the response data was generated by a pluggable client-side authentication protocol handler module in response to the challenge, wherein the response data includes information for use in authenticating the client application; and </claim-text>
<claim-text>authenticate the client application using the received response data. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00057">
<claim-text><highlight><bold>57</bold></highlight>. The server system as recited in <dependent-claim-reference depends_on="CLM-00055">claim 56</dependent-claim-reference>, wherein the server system further comprises a user repository comprising client information associated with one or more clients of the server, and wherein, in said authenticating the client application using the received response data, the server-side authentication protocol handler module is further executable within the server system to compare the received response data to the client information in the user repository to authenticate the client. </claim-text>
</claim>
<claim id="CLM-00058">
<claim-text><highlight><bold>58</bold></highlight>. The server system as recited in <dependent-claim-reference depends_on="CLM-00055">claim 56</dependent-claim-reference>, wherein, if the client is successfully authenticated, the server is further executable within the server system to: 
<claim-text>determine an access control model to be used by the server for the client application; and </claim-text>
<claim-text>plug in an access control context module for the determined access control model, wherein the access control context module is configured for use by the server in controlling access to resources of the server by the client application. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00059">
<claim-text><highlight><bold>59</bold></highlight>. The server system as recited in <dependent-claim-reference depends_on="CLM-00055">claim 58</dependent-claim-reference>, wherein the access control context module encapsulates information configured for use in controlling access to the resources of the server by the client. </claim-text>
</claim>
<claim id="CLM-00060">
<claim-text><highlight><bold>60</bold></highlight>. The server system as recited in <dependent-claim-reference depends_on="CLM-00055">claim 58</dependent-claim-reference>, wherein the access control context module is executable within the server node to: 
<claim-text>receive a request for access to a resource of the server from the client application; </claim-text>
<claim-text>determine if the client application has access permission to the resource; </claim-text>
<claim-text>if said determining determines the client application has access permission to the resource, permitting the client application to access the resource; and </claim-text>
<claim-text>if said determining determines the client application does not have access permission to the resource, inhibiting the client application from accessing the resource. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00061">
<claim-text><highlight><bold>61</bold></highlight>. The server system as recited in <dependent-claim-reference depends_on="CLM-00055">claim 56</dependent-claim-reference>, wherein the server system is a messaging-based system. </claim-text>
</claim>
<claim id="CLM-00062">
<claim-text><highlight><bold>62</bold></highlight>. The server system as recited in <dependent-claim-reference depends_on="CLM-00055">claim 56</dependent-claim-reference>, wherein the server system uses the Java Message Service (JMS) to support messaging between entities in the system. </claim-text>
</claim>
<claim id="CLM-00063">
<claim-text><highlight><bold>63</bold></highlight>. A carrier medium comprising program instructions, wherein the program instructions are computer-executable to implement: 
<claim-text>a first node initiating a connection to a second node in a networked computer system; </claim-text>
<claim-text>determining an authentication type to be used by the first node and the second node; </claim-text>
<claim-text>initializing a first authentication protocol handler on the first node for the determined authentication type; </claim-text>
<claim-text>initializing a second authentication protocol handler on the second node for the determined authentication type; </claim-text>
<claim-text>the second node sending a challenge to the first node, wherein the challenge is in accordance with the determined authentication type; </claim-text>
<claim-text>the first authentication protocol handler generating response data in response to the challenge, wherein the response data includes information for use in authenticating the first node; </claim-text>
<claim-text>the first node sending the response data to the second node; and </claim-text>
<claim-text>the second authentication protocol handler authenticating the first node using the received response data; </claim-text>
<claim-text>wherein the first authentication protocol handler and the second authentication protocol handler are pluggable modules configured to be replaced to support different authentication types. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00064">
<claim-text><highlight><bold>64</bold></highlight>. The carrier medium as recited in <dependent-claim-reference depends_on="CLM-00066">claim 63</dependent-claim-reference>, wherein, in said authenticating the first node using the received response data, the program instructions are further computer-executable to implement comparing the response data to information comprised in a user repository, wherein the information is associated with one or more nodes. </claim-text>
</claim>
<claim id="CLM-00065">
<claim-text><highlight><bold>65</bold></highlight>. The carrier medium as recited in <dependent-claim-reference depends_on="CLM-00066">claim 63</dependent-claim-reference>, wherein, if the first node is successfully authenticated, the program instructions are further computer-executable to implement: 
<claim-text>determining an access control model to be used by the second node for the first node; and </claim-text>
<claim-text>initializing an access control context module for the determined access control model, wherein the access control context module is configured for use in controlling access to resources of the second node by the first node using the access control model. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00066">
<claim-text><highlight><bold>66</bold></highlight>. The carrier medium as recited in <dependent-claim-reference depends_on="CLM-00066">claim 65</dependent-claim-reference>, wherein the access control context module is a pluggable module configured to be replaced to support different access control models. </claim-text>
</claim>
<claim id="CLM-00067">
<claim-text><highlight><bold>67</bold></highlight>. The carrier medium as recited in <dependent-claim-reference depends_on="CLM-00066">claim 65</dependent-claim-reference>, wherein the access control context module is configured to support different pluggable access control models. </claim-text>
</claim>
<claim id="CLM-00068">
<claim-text><highlight><bold>68</bold></highlight>. The carrier medium as recited in <dependent-claim-reference depends_on="CLM-00066">claim 65</dependent-claim-reference>, wherein the program instructions are further computer-executable to implement: 
<claim-text>the first node sending to the second node a request for access to a resource of the second node; </claim-text>
<claim-text>the access control context module determining if the first node has access permission to the resource; </claim-text>
<claim-text>if said determining determines the first node has access permission to the resource, allowing the first node to access the resource; and </claim-text>
<claim-text>if said determining determines the first node does not have access permission to the resource, inhibiting the first node from accessing the resource. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00069">
<claim-text><highlight><bold>69</bold></highlight>. The carrier medium as recited in <dependent-claim-reference depends_on="CLM-00066">claim 63</dependent-claim-reference>, wherein networked computer system is a client-server system, wherein the first node is a client in the client-server system, and wherein the second node is a server in the client-server system. </claim-text>
</claim>
<claim id="CLM-00070">
<claim-text><highlight><bold>70</bold></highlight>. The carrier medium as recited in <dependent-claim-reference depends_on="CLM-00066">claim 63</dependent-claim-reference>, wherein the networked computer system is a peer-to-peer system, wherein the first node and the second node are peers in the peer-to-peer system.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>1B</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005117A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005117A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005117A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005117A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005117A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005117A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030005117A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030005117A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
