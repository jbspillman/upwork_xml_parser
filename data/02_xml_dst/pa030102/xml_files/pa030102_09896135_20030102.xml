<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030002188A1-20030102-D00000.TIF SYSTEM "US20030002188A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030002188A1-20030102-D00001.TIF SYSTEM "US20030002188A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030002188A1-20030102-D00002.TIF SYSTEM "US20030002188A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030002188A1-20030102-D00003.TIF SYSTEM "US20030002188A1-20030102-D00003.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030002188</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09896135</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010629</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G11B005/09</ipc>
</classification-ipc-primary>
<classification-ipc-secondary>
<ipc>G11B005/02</ipc>
</classification-ipc-secondary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>360</class>
<subclass>048000</subclass>
</uspc>
</classification-us-primary>
<classification-us-secondary>
<uspc>
<class>360</class>
<subclass>046000</subclass>
</uspc>
</classification-us-secondary>
<classification-us-secondary>
<uspc>
<class>360</class>
<subclass>067000</subclass>
</uspc>
</classification-us-secondary>
</classification-us>
<title-of-invention>Method and apparatus for handling end of data processing in a data storage device</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>William</given-name>
<middle-name>G.</middle-name>
<family-name>Bliss</family-name>
</name>
<residence>
<residence-us>
<city>Thornton</city>
<state>CO</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Razmik</given-name>
<family-name>Karabed</family-name>
</name>
<residence>
<residence-us>
<city>San Jose</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>James</given-name>
<middle-name>W.</middle-name>
<family-name>Rae</family-name>
</name>
<residence>
<residence-us>
<city>Rochester</city>
<state>MN</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Heiner</given-name>
<family-name>Stockmanns</family-name>
</name>
<residence>
<residence-us>
<city>Santa Cruz</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Kaichi</given-name>
<family-name>Zhang</family-name>
</name>
<residence>
<residence-us>
<city>Santa Cruz</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>DAVID ROZENBLAT</name-1>
<name-2>Brinks Hofer Gilson &amp; Lione</name-2>
<address>
<address-1>Suite 3600</address-1>
<address-2>455 N. Cityfront Plaza Dr.</address-2>
<city>Chicago</city>
<state>IL</state>
<postalcode>60611</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A method and apparatus for handling end of data processing in a data storage device. The method includes receiving a plurality of user data bits at a write channel. The method further includes appending primary padding bits to user data bits if the plurality of user data bits is less than a multiple of an input block length of an encoder in the write channel and encoding the plurality of user data bits and any primary padding bits into a plurality of encoded data bytes. Additionally, the method includes appending an end of data marker to an end of the plurality of encoded data bytes, wherein the end of data marker has a length of no more than one byte, and writing the plurality of encoded data bytes and the end of data marker to the data store. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">BACKGROUND </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> Computer hard disk drives, also known as fixed disk drives or hard drives, have become a de facto standard data storage component of modern computer systems and are making farther inroads into modem consumer electronics as well. Their proliferation can be directly attributed to their low cost, high storage capacity and high reliability, in addition to wide availability, low power consumption, high data transfer speeds and decreasing physical size. </paragraph>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> These disk drives typically consist of one or more rotating magnetic platters encased within an environmentally controlled housing that further includes all of the electronics and mechanics to read and write data and interface with other devices. Read/write heads are positioned above each of the platters, and typically on each face, to record and read data. The electronics of a hard disk drive are coupled with these read/write heads and include numerous components to control the position of the heads and generate or sense the electromagnetic fields representing data. These components receive data from a host device, such as a personal computer, and translate that data into magnetic encodings written onto the disk platters by the heads. Further, when a host device requests data from the drive, the electronics locate the desired data, sense the magnetic encodings which represent that data and translate those encodings back into the binary digital information which the host device can understand. Further, error detection and correction algorithms are applied to ensure accurate storage and retrieval of data. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> One area in which significant advancements have been made has been in the area of read/write head technology and the methods of interpreting the magnetic fluctuations sensed by these heads. The read/write head, of which a typical hard disk has several, is the interface between magnetic platters and the disk drive electronics. The read/write head actually reads and writes the magnetically encoded data as areas of magnetic flux on the platters. Data, consisting of binary 1&apos;s and 0&apos;s, are encoded by sequences of the presence or absence of flux reversals recorded or detected by the read/write head. A flux reversal is a change in the magnetic flux in two contiguous areas of the disk platter. Traditional hard drives read data off the platters by detecting the voltage peak imparted in the read/write head when a flux reversal passes underneath the read/write head as the platters rotate. This is known as &ldquo;peak detection.&rdquo; However, increasing storage densities require reduced peak amplitudes and better signal discrimination and higher platter rotational speeds are pushing the peaks closer together thus making peak detection more difficult to accomplish. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> Magneto-resistive (&ldquo;MR&rdquo;) read/write heads have been developed with increased sensitivity to sense smaller amplitude magnetic signals and with increased signal discrimination to address some of the problems with increasing storage densities. In addition, another technology, known as Partial Response Maximum Likelihood (&ldquo;PRML&rdquo;), has been developed to further address the problems with peak detection as densities and rotational speeds increase. Borrowed from communications technology, PRML is an algorithm implemented in the disk drive electronics to interpret the magnetic signals sensed by the read/write heads. PRML-based disk drives read the analog waveforms generated by the magnetic flux reversals stored on the disk. However, instead of looking for peak values to indicate flux reversals, PRML-based drives digitally sample this analog waveform (the &ldquo;Partial Response&rdquo;) and use advanced signal processing technologies to determine the bit pattern represented by that wave form (the &ldquo;Maximum Likelihood&rdquo;). This technology, in conjunction magneto-resistive (&ldquo;MR&rdquo;) heads, have permitted manufacturers to further increase data storage densities. PRML technology further tolerates more noise in the sensed magnetic signals permitting the use of lower quality platters and read/write heads which increases manufacturing yields and lowers costs. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> With many different drives available from multiple manufacturers, hard disk drives are typically differentiated by factors such as cost/megabyte of storage, data transfer rate, power requirements and form factor (physical dimensions) with the bulk of competition based on cost. With most competition between hard disk drive manufacturers coming in the area of cost, there is a need for enhanced hard disk drive components which prove cost effective in increasing supplies and driving down manufacturing costs all while increasing storage capacity, operating speed, reliability and power efficiency. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY </heading>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> The present invention is defined by the following claims, and nothing in this section should be taken as a limitation on those claims. By way of introduction, the preferred embodiments described below relate to a method of processing an end of data condition for data in a data storage and retrieval system, the data storage and retrieval system having a write channel and a read channel and a data store. The method includes receiving a plurality of user data bits at the write channel. The method further includes appending primary padding bits to the user data bits if the plurality of user data bits is less than a multiple of an input block length of an encoder in the write channel and encoding the plurality of user data bits and any primary padding bits into a plurality of encoded data bytes. Additionally, the method includes appending an end of data marker to an end of the plurality of encoded data bytes, wherein the end of data marker has a length of no more than one byte, and writing the plurality of encoded data bytes and the end of data marker to the data store. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> The preferred embodiments further relate to a read/write channel for a hard disk drive. The reads/write channel includes a write channel and a read channel. The write channel receives a plurality of user data bits from a controller and includes an encoder and a marker generator. The encoder encodes the plurality of user data bits into a plurality of encoded data bytes, and the marker generator generates an end of data marker at the end of the plurality of encoded data bytes. Preferably, the end of data marker has a length of no more than one byte. The read channel receives the plurality of encoded data bytes and the end of data marker from a data store. The read channel includes a Viterbi detector for processing the plurality of encoded data bytes in the read channel. The Viterbi detector has an end of data mode which places the Viterbi detector in a predetermined state where information in a path memory of the Viterbi detector is changed to a desired value. The Viterbi enters the end of data mode upon receiving the data marker. Further aspects and advantages of the invention are discussed below in conjunction with the preferred embodiments.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1A</cross-reference> depicts a block diagram of an exemplary hard disk drive coupled with a host device. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1B</cross-reference> depicts a block diagram of a read/write channel for use with the hard disk drive of <cross-reference target="DRAWINGS">FIG. 1A</cross-reference>. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> depicts the interface which connects a controller with the read/write channel of <cross-reference target="DRAWINGS">FIG. 1B</cross-reference>. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> depicts encoded data bytes output from an encoder of the read/write channel of <cross-reference target="DRAWINGS">FIG. 1B</cross-reference>. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> depicts encoded data bytes and an end of data marker output from a multiplexor of the read/write channel of <cross-reference target="DRAWINGS">FIG. 1B</cross-reference>.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF THE PRESENTLY PREFERRED EMBODIMENTS </heading>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> The embodiments described herein relate to a PRML-based read/write channel device for hard disk drive controllers. More specifically, described below is a method and apparatus for reducing read channel noise problems that may arise when processing the end of an encoded user data byte stream read off of a data store, such as a hard disk drive. The read/write channel is a device coupled with the read/write heads of the hard disk drive. Herein, the phrase &ldquo;coupled with&rdquo; is defined to mean directly connected to or indirectly connected with through one or more intermediate components. Such intermediate components may include both hardware and software based components. The read/write channel converts the encoded user data which is in binary/digital form from the host device into the electrical impulses which drive the read/write head to magnetically record the encoded user data to the disk drive platters. Further, the read/write channel receives the encoded user data in analog form from the read/write heads and converts the encoded user data from analog form back into binary/digital form. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> As described in more detail, a Viterbi detector is a maximum likelihood detector or Viterbi decoder implementing the Viterbi algorithm for analyzing the encoded user data which is read off the hard disk drive, which helps generate the binary/digital data that is stored on the hard disk drive. In performing maximum likelihood detection, the Viterbi algorithm provides an iterative method for determining the best path along branches of a trellis diagram. The maximum likelihood detection involves analyzing a number of consecutive bits of encoded user data to determine the most likely path. Thus, by analyzing a number of consecutive bits of encoded user data, the most likely sequence can be chosen. An example of one implementation of a Viterbi detector is described in greater detail in a paper entitled &ldquo;A 100MBIT/S Viterbi Detector Chip: Novel Architecture And Its Realization,&rdquo; written by Gerhard Fettweis and Heinrich Meyr, presented to the ICC in 1990, in Atlanta, Ga., on Apr. 16-19, 1990, given paper no. 257, at session <highlight><bold>307</bold></highlight>A, the entire disclosure of which is incorporated herein by reference. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> It is desired that Viterbi decisions on the encoded user data bits not to be influenced by any noise entering the read/write channel after the end of the encoded user data, or the end of the sector, is reached. Thus, in order for Viterbi decisions made by the Viterbi detector on the encoded user bits not to be influenced by any noise entering the read/write channel after the end of the user data, the bit length of the user data is extended by padding the encoded user data with secondary padding bits (PAD<highlight><bold>2</bold></highlight>), as described below. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> Typically, the length of secondary padding bits (PAD<highlight><bold>2</bold></highlight>), in bits, must be no less than the sum of the path memory length and any filtering delays, not counting any pipelining delays. The path memory length K is to be chosen such that the probability is maximized that all paths to all states considered by the Viterbi detector in the current time step emerged or passed through the very same state K time steps in the past. The filtering delays are the total number of non-causal output data samples of an analog to digital converter (&ldquo;ADC&rdquo;) which are considered in the filter operations performed by a finite impulse response (&ldquo;FIR&rdquo;) filter and an interpolated timing recovery (&ldquo;ITR&rdquo;) circuit in order to compute input data presented to the Viterbi detector. The pipelining delays are any delays introduced to distribute computation in time which are not inherent to the algorithm performed. The second set of padding bits (PAD<highlight><bold>2</bold></highlight>) are denoted by Q(<highlight><bold>1</bold></highlight>), Q(<highlight><bold>2</bold></highlight>), . . . , Q(L<highlight><bold>2</bold></highlight>), wherein L<highlight><bold>2</bold></highlight> represents the amount of secondary padding bits added. Secondary padding bits Q(j) which are added, wherein 1&lt;j&lE;L<highlight><bold>2</bold></highlight>, can be arbitrary. Now user data bits U(<highlight><bold>1</bold></highlight>), U(<highlight><bold>2</bold></highlight>), U(<highlight><bold>3</bold></highlight>), . . . , U(N), primary padding bits P(<highlight><bold>1</bold></highlight>), . . . , P(L<highlight><bold>1</bold></highlight>), and secondary padding bits Q(<highlight><bold>1</bold></highlight>), . . . , Q(L<highlight><bold>2</bold></highlight>), are all then sent to the channel for processing. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> For some types of Viterbi detectors the length of secondary padding bits (PAD<highlight><bold>2</bold></highlight>), in bits, can be quite long, such as for example up to 100 bits long. Since the secondary padding bits (PAD<highlight><bold>2</bold></highlight>), are at one time stored on the hard disk drive, the secondary padding bits (PAD<highlight><bold>2</bold></highlight>) can occupy quite a bit of space on the hard drive. Therefore, it is desirable to reduce the amount of space occupied on the hard disk drive by the secondary padding bits (PAD<highlight><bold>2</bold></highlight>). </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>A, there is shown a block diagram of an exemplary hard disk drive <highlight><bold>100</bold></highlight> coupled with a host device <highlight><bold>112</bold></highlight>. For clarity, some components, such as the servo/actuator motor control, are not shown. The drive <highlight><bold>100</bold></highlight> includes the magnetic platters and spindle motor <highlight><bold>102</bold></highlight>, the read/vrite heads and actuator assembly <highlight><bold>104</bold></highlight>, pre-amplifiers <highlight><bold>106</bold></highlight>, a read/write channel <highlight><bold>108</bold></highlight> and a controller <highlight><bold>110</bold></highlight>. The pre-amplifiers <highlight><bold>106</bold></highlight> are coupled with the read/write channel <highlight><bold>108</bold></highlight> via interfaces <highlight><bold>114</bold></highlight>, <highlight><bold>116</bold></highlight>. The controller <highlight><bold>110</bold></highlight> interfaces with the read/write channel <highlight><bold>108</bold></highlight> via interfaces <highlight><bold>118</bold></highlight>,<highlight><bold>120</bold></highlight>. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> For reads from the hard disk <highlight><bold>100</bold></highlight>, the host device <highlight><bold>112</bold></highlight> provides a location identifier which identifies the location of the data on the disk drive, e.g. a cylinder and sector address. The controller <highlight><bold>110</bold></highlight> receives this address and determines the physical location of the data on the platters <highlight><bold>102</bold></highlight>. The controller <highlight><bold>110</bold></highlight> then moves the read/write heads into the proper position for the data to spin underneath the read/write heads <highlight><bold>104</bold></highlight>. As the data spins underneath the read/write head <highlight><bold>104</bold></highlight>, the read/write head <highlight><bold>104</bold></highlight> senses the presence or absence of flux reversals, generating a stream of analog signal data. This data is passed to the pre-amplifiers <highlight><bold>106</bold></highlight> which amplifies the signal and passes it to the read/write channel <highlight><bold>108</bold></highlight> via the interface <highlight><bold>114</bold></highlight>. As will be discussed below, the read/write channel receives the amplified analog waveform from the pre-amplifiers <highlight><bold>106</bold></highlight> and decodes this waveform into the digital binary data that it represents. This digital binary data is then passed to the controller <highlight><bold>110</bold></highlight> via the interface <highlight><bold>118</bold></highlight>. The controller <highlight><bold>110</bold></highlight> interfaces the hard drive <highlight><bold>100</bold></highlight> with the host device <highlight><bold>112</bold></highlight> and may contain additional functionality, such as caching or error detection/correction functionality, intended to increase the operating speed and/or reliability of the hard drive <highlight><bold>100</bold></highlight>. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> For write operations, the host device <highlight><bold>112</bold></highlight> provides the controller <highlight><bold>110</bold></highlight> with the binary digital data to be written and the location, e.g. cylinder and sector address, of where to write it. The controller <highlight><bold>110</bold></highlight> moves the read/write heads <highlight><bold>104</bold></highlight> to the proper location and sends the binary digital data to be written to the read/write channel <highlight><bold>108</bold></highlight> via interface <highlight><bold>120</bold></highlight>. The read/write channel <highlight><bold>108</bold></highlight> receives the binary digital data, encodes it and generates analog signals which are used to drive the read/write head <highlight><bold>104</bold></highlight> to impart the proper magnetic flux reversals onto the magnetic platters <highlight><bold>102</bold></highlight> representing the binary digital data. The generated signals are passed to the pre-amplifiers <highlight><bold>106</bold></highlight> via interface <highlight><bold>116</bold></highlight> which drive the read/write heads <highlight><bold>104</bold></highlight>. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>B, there is shown an exemplary read/write channel <highlight><bold>108</bold></highlight> supporting Partial Response Maximum Likelihood (&ldquo;PRML&rdquo;) encoding technology for use with the hard disk drive <highlight><bold>100</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 1A</cross-reference>. For clarity, some components have been omitted. The read/write channel <highlight><bold>108</bold></highlight> is implemented as an integrated circuit using a complementary metal oxide semiconductor (&ldquo;CMOS&rdquo;) process at 0.18 micron. It will be appreciated that CMOS processes include processes which use metal gates as well as polysilicon gates. It will further be appreciated that other process technologies and feature sizes may used and that the circuitry disclosed herein may be further integrated with other circuitry comprising the hard disk electronics such as the hard disk controller logic. As was described, the read/write channel <highlight><bold>108</bold></highlight> converts between binary digital information and the analog signals representing the magnetic flux on the platters <highlight><bold>102</bold></highlight>. The read/write channel <highlight><bold>108</bold></highlight> is divided into two main sections, the read channel <highlight><bold>156</bold></highlight> and the write channel <highlight><bold>158</bold></highlight>. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> The write channel <highlight><bold>158</bold></highlight> includes a parallel-to-serial converter <highlight><bold>144</bold></highlight>, an encoder <highlight><bold>147</bold></highlight>, a write pre-compensation circuit <highlight><bold>150</bold></highlight> and a driver circuit <highlight><bold>152</bold></highlight>. The parallel-to-serial converter <highlight><bold>144</bold></highlight> receives user data from the host device <highlight><bold>112</bold></highlight> via interface <highlight><bold>120</bold></highlight> eight bits at a time. Preferably, the user data received from the host device <highlight><bold>112</bold></highlight> has already been padded with primary padding bits (PAD<highlight><bold>1</bold></highlight>), as described in greater detail below. The primary padding bits (PAD<highlight><bold>1</bold></highlight>) comprise dummy bits which are inserted at the end of the user data bits so that the length in bits of the user data is always a multiple of the of the input block length to the encoder <highlight><bold>147</bold></highlight>. The input block length to the encoder <highlight><bold>147</bold></highlight> is the number of bits the encoder needs to properly process the user data. Thus, if the input block length to the encoder <highlight><bold>147</bold></highlight> is 32 bits, the encoder needs to receive the user data in 32 bit blocks in order to properly process the user data. Therefore, if the user data is 100 bits long, and the input block length to the encoder <highlight><bold>147</bold></highlight> is 32 bits, 28 primary padding bits (PAD<highlight><bold>1</bold></highlight>) are inserted at the end of the user data to insure that the length in bits of the user data is a multiple of 32, that is 32*4&equals;128&equals;100&plus;28. Once the user data is received by the converter <highlight><bold>144</bold></highlight>, the converter <highlight><bold>144</bold></highlight> serializes the input data and sends the serial bit stream to the encoder <highlight><bold>147</bold></highlight>. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> The encoder <highlight><bold>147</bold></highlight> takes user data bits <highlight><bold>200</bold></highlight> U(<highlight><bold>1</bold></highlight>), U(<highlight><bold>2</bold></highlight>), U(<highlight><bold>3</bold></highlight>), . . . , U(N), having primary padding bits <highlight><bold>202</bold></highlight> P(<highlight><bold>1</bold></highlight>), . . . , P(L<highlight><bold>1</bold></highlight>), and then codes the user data bits <highlight><bold>200</bold></highlight> and the primary padding bits <highlight><bold>202</bold></highlight> into encoded data bytes <highlight><bold>204</bold></highlight> V(<highlight><bold>1</bold></highlight>), V(<highlight><bold>2</bold></highlight>), V(<highlight><bold>3</bold></highlight>), . . . , V(M), as illustrated in <cross-reference target="DRAWINGS">FIGS. 1B, 2</cross-reference>, and <highlight><bold>3</bold></highlight>. In one embodiment, the encoded data bytes <highlight><bold>204</bold></highlight> (V) are 34 bits long, wherein M&equals;(N&plus;L<highlight><bold>1</bold></highlight>)/4. The encoder <highlight><bold>147</bold></highlight> comprises a run-length-limited (&ldquo;RLL&rdquo;) encoder <highlight><bold>146</bold></highlight> and a parity encoder <highlight><bold>148</bold></highlight>. The RLL encoder <highlight><bold>146</bold></highlight> encodes the user data bits <highlight><bold>200</bold></highlight> and the primary padding bits <highlight><bold>202</bold></highlight> into symbolic binary sequences according to a known run-length limited algorithm for recording on the platters <highlight><bold>102</bold></highlight>. The exemplary RLL encoder uses a 32/33 bit symbol code to ensure that flux reversals are properly spaced and that long runs of data without flux reversals are not recorded. The RLL encoded user data bits <highlight><bold>200</bold></highlight> and the primary padding bits <highlight><bold>202</bold></highlight> are then passed to the parity encoder <highlight><bold>148</bold></highlight> which adds a parity bit to the data. In the exemplary parity encoder <highlight><bold>148</bold></highlight>, odd parity is used to ensure that long run&apos;s of 0&apos;s and 1&apos;s are not recorded due to the magnetic properties of such recorded data. The encoded data bytes <highlight><bold>204</bold></highlight> are subsequently treated as an analog signal rather than a digital signal. The analog signal is then passed through a multiplexor <highlight><bold>149</bold></highlight>, as illustrated in <cross-reference target="DRAWINGS">FIG. 1B</cross-reference>. When the end of the encoded data bytes <highlight><bold>204</bold></highlight> is reached, the multiplexor <highlight><bold>149</bold></highlight> switches its input from the output of the parity encoder <highlight><bold>148</bold></highlight> to the output of the marker generator <highlight><bold>151</bold></highlight>, and the marker generator <highlight><bold>151</bold></highlight> generates an end of data marker <highlight><bold>206</bold></highlight> (W) which is then added to the end of the encoded data bytes <highlight><bold>204</bold></highlight>, as discussed in more detail below. It is the task of the controller <highlight><bold>110</bold></highlight> to signal the end of user data. This might be done by either providing the number of user bytes such that the end of user data can be identified by counting or via a signal usually called the WRITE GATE. If signaling relies on the WRITE GATE, this signal must be timed by the controller <highlight><bold>110</bold></highlight> such that the channel <highlight><bold>108</bold></highlight> can perform any synchronization required to identify the end of data event with respect to the sequence of data to be written. In one preferred embodiment, the end of data marker <highlight><bold>206</bold></highlight> is represented by a series of zero bits, and even more preferably, by at least four zero bits. Preferably, these four zero bits are augmented by some more bits such that the total number of bits matches any filtering delays such as those filtering delays introduced by an FIR filter <highlight><bold>134</bold></highlight> and an ITR circuit <highlight><bold>136</bold></highlight>, as discussed in more detail below. In one preferred embodiment, the marker generator <highlight><bold>151</bold></highlight> hardcodes (NRZ) a data marker <highlight><bold>206</bold></highlight> of one byte after the encoded data bytes <highlight><bold>204</bold></highlight>. The data marker <highlight><bold>206</bold></highlight> is programmable. Preferably, the data marker <highlight><bold>206</bold></highlight> is made up of eight data marker bits (w<highlight><bold>1</bold></highlight> w<highlight><bold>2</bold></highlight> w<highlight><bold>3</bold></highlight> w<highlight><bold>4</bold></highlight> w<highlight><bold>5</bold></highlight> w<highlight><bold>6</bold></highlight> w<highlight><bold>7</bold></highlight> w<highlight><bold>8</bold></highlight>). In one embodiment, we set the eight data marker bits to zero, so that: (w<highlight><bold>1</bold></highlight> w<highlight><bold>2</bold></highlight> w<highlight><bold>3</bold></highlight> w<highlight><bold>4</bold></highlight> w<highlight><bold>5</bold></highlight> w<highlight><bold>6</bold></highlight> w<highlight><bold>7</bold></highlight> w<highlight><bold>8</bold></highlight>)&equals;(0 0 0 0 0 0 0 0). </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> In one preferred embodiment, the analog signal passes from the parity encoder <highlight><bold>148</bold></highlight> through a pre-coder <highlight><bold>153</bold></highlight> before passing through the multiplexor <highlight><bold>149</bold></highlight>, as illustrated in <cross-reference target="DRAWINGS">FIG. 1B</cross-reference>. The pre-coder <highlight><bold>153</bold></highlight> ensures that the timing information contained in the encoded data bytes <highlight><bold>204</bold></highlight> is preserved in a way such that reliable timing recovery is possible when reading back the encoded data bytes <highlight><bold>204</bold></highlight> from the hard disk drive platters <highlight><bold>102</bold></highlight>. The pre-coder <highlight><bold>153</bold></highlight> outputs pre-coded data bytes (VP) which are then sent to the multiplexor <highlight><bold>149</bold></highlight>. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> The analog signal is then passed from the multiplexor <highlight><bold>149</bold></highlight> to a write pre-compensation circuit <highlight><bold>150</bold></highlight> which dynamically adjusts the pulse widths of the bit stream to account for magnetic distortions in the recording process. The adjusted analog signal is passed to a driver circuit <highlight><bold>152</bold></highlight> which drives the signal to the pre-amplifiers <highlight><bold>106</bold></highlight> via interface <highlight><bold>116</bold></highlight> to drive the read/write heads <highlight><bold>104</bold></highlight> and record the data. The exemplary driver circuit <highlight><bold>152</bold></highlight> includes a pseudo emitter coupled logic (&ldquo;PECL&rdquo;) driver circuit which generates a differential output to the pre-amplifiers <highlight><bold>106</bold></highlight>. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> The read channel <highlight><bold>156</bold></highlight> includes an attenuation circuit/input resistance <highlight><bold>122</bold></highlight>, a variable gain amplifier (&ldquo;VGA&rdquo;) <highlight><bold>124</bold></highlight>, a magneto-resistive asymmetry linearizer (&ldquo;MRA&rdquo;) <highlight><bold>126</bold></highlight>, a continuous time filter (&ldquo;CTF&rdquo;) <highlight><bold>128</bold></highlight>, a buffer <highlight><bold>130</bold></highlight>, an analog to digital converter (&ldquo;ADC&rdquo;) <highlight><bold>132</bold></highlight>, a finite impulse response (&ldquo;FIR&rdquo;) filter <highlight><bold>134</bold></highlight>, an interpolated timing recovery (&ldquo;ITR&rdquo;) circuit <highlight><bold>136</bold></highlight>, a Viterbi algorithm detector <highlight><bold>138</bold></highlight>, a parity decoder <highlight><bold>140</bold></highlight> and a run-length-limited (&ldquo;RLL&rdquo;) decoder <highlight><bold>142</bold></highlight>. The amplified magnetic signals sensed from the platters <highlight><bold>102</bold></highlight> by the read/write head <highlight><bold>104</bold></highlight> are received by the read/write channel <highlight><bold>108</bold></highlight> via interface <highlight><bold>114</bold></highlight>. The analog signal waveform representing the sensed magnetic signals is first passed through an input resistance <highlight><bold>122</bold></highlight> which is a switching circuit to attenuate the signal and account for any input resistance. The attenuated signal is then passed to a VGA <highlight><bold>124</bold></highlight> which amplifies the signal. The amplified signal is then passed to the MRA <highlight><bold>126</bold></highlight> which adjusts the signal for any distortion created by the recording process. Essentially, the MRA <highlight><bold>126</bold></highlight> performs the opposite function of the write-pre-compensation circuit <highlight><bold>150</bold></highlight> in the write channel <highlight><bold>158</bold></highlight>. The signal is next passed through the CTF <highlight><bold>128</bold></highlight>, which is essentially a low pass filter, to filter out noise. The filtered signal is then passed to the ADC <highlight><bold>132</bold></highlight> via the buffer <highlight><bold>130</bold></highlight> which samples the analog signal and converts it to a digital form. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> The digital signal is then passed to a FIR filter <highlight><bold>134</bold></highlight> and then to a timing recovery circuit <highlight><bold>136</bold></highlight>. The timing recovery circuit <highlight><bold>136</bold></highlight> is connected (not shown in the figure) to the FIR filter <highlight><bold>134</bold></highlight>, the MRA <highlight><bold>126</bold></highlight> and the VGA <highlight><bold>124</bold></highlight> in a feedback orientation to adjust these circuits according to the signals received to provide timing compensation. The exemplary FIR filter <highlight><bold>134</bold></highlight> is a 10 tap FIR filter. The digital signal is then passed to the Viterbi algorithm detector <highlight><bold>138</bold></highlight> which determines the binary bit pattern represented by the digital signal using digital signal processing techniques. The Viterbi detector <highlight><bold>138</bold></highlight> has states with a predetermined memory length. The exemplary Viterbi algorithm detector <highlight><bold>138</bold></highlight> uses a 32 state Viterbi processor, wherein each state has a predetermined memory length of 4 bits. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> The Viterbi detector <highlight><bold>138</bold></highlight> then receives an end of data signal from the controller <highlight><bold>110</bold></highlight> (not illustrated), when the end of the user data is reached, to signal to the Viterbi detector <highlight><bold>138</bold></highlight> that the end of the user data has been reached. Alternatively, a signal from a counter (not shown), or a read gate signal from the controller <highlight><bold>110</bold></highlight>, can also signal to the Viterbi detector <highlight><bold>138</bold></highlight> that the end of the user data has been reached. When the counter (not shown) is used, the read/write channel <highlight><bold>108</bold></highlight> must be given the length of the sector. But when the read gate signal is used, it is assumed the read gate signal will drop in a known byte location (W). If the read gate signal drops prior to the Viterbi detector <highlight><bold>108</bold></highlight> receiving the data marker (W), then the Viterbi detector <highlight><bold>108</bold></highlight> needs to wait until the Viterbi detector <highlight><bold>108</bold></highlight> receives the data marker (W) before entering an end of data transfer (EDT) mode. However, if the read gate signal drops after the Viterbi detector <highlight><bold>138</bold></highlight> receives the data marker (W), then the Viterbi detector <highlight><bold>108</bold></highlight> may enter the EDT mode immediately. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> Once the Viterbi detector <highlight><bold>138</bold></highlight> receives the end of data signal, the Viterbi detector <highlight><bold>138</bold></highlight> awaits the receipt of the data marker (W). Upon receiving the data marker (W), the Viterbi detector <highlight><bold>138</bold></highlight> enters an end of data transfer (EDT) mode. Upon entering the EDT mode, the samples of encoded user data entering the Viterbi detector <highlight><bold>138</bold></highlight> will be replaced with secondary padding bits, preferably equal to 0. The secondary padding bits, preferably equal to 0, will be input into the Viterbi detector <highlight><bold>138</bold></highlight> until all the encoded user data is flushed out of the Viterbi detector <highlight><bold>138</bold></highlight>. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> In one embodiment, the end of data marker <highlight><bold>206</bold></highlight> is made up of eight marker data bits (w<highlight><bold>1</bold></highlight> w<highlight><bold>2</bold></highlight> w<highlight><bold>3</bold></highlight> w<highlight><bold>4</bold></highlight> w<highlight><bold>5</bold></highlight> w<highlight><bold>6</bold></highlight> w<highlight><bold>7</bold></highlight> w<highlight><bold>8</bold></highlight>). In one embodiment, we set the eight data marker bits to zero, so that: (w<highlight><bold>1</bold></highlight> w<highlight><bold>2</bold></highlight> w<highlight><bold>3</bold></highlight> w<highlight><bold>4</bold></highlight> w<highlight><bold>5</bold></highlight> w<highlight><bold>6</bold></highlight> w<highlight><bold>7</bold></highlight> w<highlight><bold>8</bold></highlight>) &equals;(0 0 0 0 0 0 0 0). If the Viterbi detector <highlight><bold>138</bold></highlight> has a predetermined memory length of 4 bits, the fourth data marker bit (w<highlight><bold>4</bold></highlight>) will force the correct path in the trellis within the Viterbi detector <highlight><bold>138</bold></highlight> to end in a state s&equals;&lsqb;p s<highlight><bold>1</bold></highlight> s<highlight><bold>2</bold></highlight> s<highlight><bold>3</bold></highlight> s<highlight><bold>4</bold></highlight>&rsqb;&equals;&lsqb;0 0 0 0 0&rsqb;, where s<highlight><bold>1</bold></highlight>, s<highlight><bold>2</bold></highlight>, s<highlight><bold>3</bold></highlight>, and s<highlight><bold>4</bold></highlight> are NRZ values, wherein s<highlight><bold>1</bold></highlight> is the current value, and wherein p is state parity information. The remaining data marker bits, w<highlight><bold>5</bold></highlight>-w<highlight><bold>8</bold></highlight>, will keep the correct path in state s&equals;&lsqb;0 0 0 0 0&rsqb;. After receiving the fourth data marker bit (w<highlight><bold>4</bold></highlight>), the Viterbi detector <highlight><bold>138</bold></highlight> will go into the end of data transfer (EDT) mode. If a read gate signal from the controller <highlight><bold>100</bold></highlight> is used, and if the read gate signal drops prior to the Viterbi detector <highlight><bold>108</bold></highlight> receiving the fourth data marker bit (w<highlight><bold>4</bold></highlight>), then the Viterbi detector <highlight><bold>138</bold></highlight> needs to wait for the fourth data marker bit (w<highlight><bold>4</bold></highlight>) before entering the EDT mode. However, if the READ GATE drops after the Viterbi detector <highlight><bold>108</bold></highlight> receiving the fourth data marker bit (w<highlight><bold>4</bold></highlight>), then the Viterbi detector <highlight><bold>138</bold></highlight> enters the EDT mode immediately. If the EDT mode is signaled by a counter, then the end of data marker <highlight><bold>206</bold></highlight> can have length which is equal to the predetermined memory length of the Viterbi detector <highlight><bold>138</bold></highlight>. For example, if the Viterbi detector <highlight><bold>138</bold></highlight> has a predetermined memory length of <highlight><bold>4</bold></highlight> bits, the end of data marker <highlight><bold>206</bold></highlight> can have a length of 4 bits, which is preferably augmented by as many bits as required to account for any filtering delays, as described above. In the present implementation, a survivor corresponding to state s&equals;&lsqb;0 0 0 0 0&rsqb; will be output from the Viterbi detector <highlight><bold>138</bold></highlight>. Using the above described method, the Viterbi will be protected from any large noise which might enter the read/write channel <highlight><bold>108</bold></highlight> after the last user encoded data bytes have been received by the Viterbi detector <highlight><bold>138</bold></highlight>. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> In one embodiment, a padding generator <highlight><bold>157</bold></highlight> generates the secondary padding bits which are then passed to a multiplexor <highlight><bold>159</bold></highlight>, as illustrated in <cross-reference target="DRAWINGS">FIG. 1B</cross-reference>. Multiplexor <highlight><bold>159</bold></highlight> receives both the output from the ITR <highlight><bold>136</bold></highlight> and the padding generator <highlight><bold>157</bold></highlight>. The output from the ITR <highlight><bold>136</bold></highlight> is allowed to pass through the multiplexor <highlight><bold>159</bold></highlight> until the Viterbi detector <highlight><bold>138</bold></highlight> enters the end of data transfer (EDT) mode, upon which the multiplexor then selects to receive the secondary padding bits generated by the padding generator <highlight><bold>157</bold></highlight>. While the above embodiments use a padding generator <highlight><bold>157</bold></highlight> to generate the secondary padding bits, secondary padding bits may be generated by the Viterbi detector <highlight><bold>138</bold></highlight>, or by any other circuitry known to those skilled in the art. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> In one embodiment, the Viterbi detector <highlight><bold>138</bold></highlight> may be configured to internally generate a stream of signals, such as logical zeros, to maintain the desired state in the Viterbi detector <highlight><bold>138</bold></highlight> and to prevent any large noise which might enter the read/write channel <highlight><bold>108</bold></highlight> after the last user encoded data bytes have been received by the Viterbi detector <highlight><bold>138</bold></highlight>. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> The binary data represented by the digital signal exiting the Viterbi detector <highlight><bold>138</bold></highlight> is then passed to the parity decoder <highlight><bold>140</bold></highlight> which removes the parity bit and then to the RLL decoder <highlight><bold>142</bold></highlight> which decodes the binary RLL encoding symbols back into the actual binary data that they represents This data is then passed to the controller <highlight><bold>110</bold></highlight> via the interface <highlight><bold>118</bold></highlight>. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> The read/write channel <highlight><bold>108</bold></highlight> further includes a clock synthesizer <highlight><bold>154</bold></highlight>. The clock synthesizer <highlight><bold>154</bold></highlight> generates the clock signals required for operating the read/write channel <highlight><bold>108</bold></highlight>. The exemplary clock synthesizer <highlight><bold>154</bold></highlight> includes a phased lock look (&ldquo;PLL&rdquo;) (not shown) with a voltage controlled oscillator and various clock dividers to generate the necessary frequencies. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> It is to be noted that suitable transistor sizes specifying channel width-to-length ratios (measured in micrometers or microns) for the transistors which make up the depicted circuits have been omitted from the figures. It will be appreciated that suitable ratios may be chosen depending on the design requirements and the capabilities and limitations of the particular integrated circuit fabrication process used for implementation of the circuit as well as the performance requirements of the specific embodiment. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> Thus, there has been disclosed in accordance with the invention, a method for Viterbi detector state metric re-normalization for a Viterbi detector of a read/write channel for a hard disk drive that fully provides the advantages set forth above. Although the invention has been described and illustrated with reference to specific illustrative embodiments thereof, it is not intended that the invention be limited to those illustrative embodiments. Those skilled in the art will recognize that variations and modifications can be made without departing from the spirit of the invention. It is therefore intended to include within the invention all such variations and modifications that fall within the scope of the appended claims and equivalents thereof. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">We claim: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method of processing an end of data condition for data in a data storage and retrieval system, the data storage and retrieval system having a write channel and a read channel and a data store, the method comprising: 
<claim-text>receiving a plurality of user data bits at the write channel; </claim-text>
<claim-text>appending primary padding bits to the user data bits if the plurality of user data bits is less than a multiple of an input block length of an encoder in the write channel; </claim-text>
<claim-text>encoding the plurality of user data bits and any primary padding bits into a plurality of encoded data bytes; </claim-text>
<claim-text>appending an end of data marker to an end of the plurality of encoded data bytes, wherein the end of data marker has a length of no more than one byte; and </claim-text>
<claim-text>writing the plurality of encoded data bytes and the end of data marker to the data store. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the appending of the end of data marker comprises appending an end of data marker having a bit length no less than a bit length of a predetermined memory length of a state for a Viterbi detector in the read channel of the data storage and retrieval system. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein appending an end of data marker comprises appending an end of data marker having a bit length equal to a bit length of a predetermined memory length of a state for a Viterbi detector in the read channel of the data storage and retrieval system. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the end of data marker further comprises one data byte. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the end of data marker comprises data configured to trigger an end of data transfer mode in a Viterbi detector in the read channel. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising: 
<claim-text>reading the plurality of encoded data bytes and the end of data marker from the data store and providing the plurality of encoded data bytes and the end of data marker to an input of a Viterbi detector in the read channel; </claim-text>
<claim-text>processing the plurality of encoded data bytes in the Viterbi detector; and </claim-text>
<claim-text>identifying the end of data marker at the Viterbi detector wherein the end of data marker triggers an end of data mode in the Viterbi detector, the end of data mode comprising: 
<claim-text>placing the Viterbi detector in a predetermined state where information in a path memory of the Viterbi detector is changed to a desired value; and </claim-text>
<claim-text>providing a predetermined input value to the input of the Viterbi detector until the Viterbi detector has completed processing all of the plurality of encoded data bytes, wherein read channel noise is prevented from entering the Viterbi detector after a last of the plurality of encoded data bytes is provided to the input. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. A method of processing an end of data condition for data in a data storage and retrieval system, the data storage and retrieval system having a write channel and a read channel and a data store, the method comprising: 
<claim-text>reading a plurality of encoded data bytes and an end of data marker from the data store, the end of data marker comprising information to trigger an end of data mode in a Viterbi detector in the read channel; </claim-text>
<claim-text>processing the plurality of encoded data bytes in the Viterbi detector in the read channel; and </claim-text>
<claim-text>identifying the end of data marker at the Viterbi detector wherein the end of data marker triggers an end of data mode in the Viterbi detector, the end of data mode comprising: 
<claim-text>placing the Viterbi detector in a predetermined state where information in a path memory of the Viterbi detector is changed to a desired value; and </claim-text>
<claim-text>providing a predetermined input value to the Viterbi detector until the Viterbi detector has completed processing all of the plurality of encoded data bytes, wherein read channel noise is prevented from entering the Viterbi detector after a last of the plurality of encoded data bytes is provided to the Viterbi detector. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference>, further comprising counting the plurality of encoded data bytes and sending a signal to the Viterbi detector when a last of the plurality of encoded data bytes has been input to the Viterbi detector, wherein the signal alerts the Viterbi detector to watch for the end of data marker. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference>, wherein the end of data marker comprises a bit length no less than a bit length of a predetermined memory length of a state for the Viterbi detector. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, wherein the end of data marker comprises a bit length equal to a multiple of the bit length of the predetermined memory length of the state for the Viterbi detector. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. A read/write channel for a hard disk drive, comprising: 
<claim-text>a write channel which receives a plurality of user data bits from a controller, the write channel comprising: 
<claim-text>an encoder which encodes the plurality of user data bits into a plurality of encoded data bytes; and </claim-text>
<claim-text>a marker generator which generates an end of data marker at the end of the plurality of encoded data bytes, wherein the end of data marker has a length of no more than one byte; and </claim-text>
</claim-text>
<claim-text>a read channel which receives the plurality of encoded data bytes and the end of data marker from a data store, the read channel comprising a Viterbi detector for processing the plurality of encoded data bytes in the read channel, wherein the Viterbi detector comprises an end of data mode which places the Viterbi detector in a predetermined state where information in a path memory of the Viterbi detector is changed to a desired value, and wherein the Viterbi enters the end of data mode upon receiving the data marker.</claim-text>
</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>1A</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030002188A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030002188A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030002188A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030002188A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
