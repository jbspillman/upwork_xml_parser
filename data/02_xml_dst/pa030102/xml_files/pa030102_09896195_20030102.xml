<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005118A1-20030102-D00000.TIF SYSTEM "US20030005118A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005118A1-20030102-D00001.TIF SYSTEM "US20030005118A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005118A1-20030102-D00002.TIF SYSTEM "US20030005118A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005118A1-20030102-D00003.TIF SYSTEM "US20030005118A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005118A1-20030102-D00004.TIF SYSTEM "US20030005118A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005118A1-20030102-D00005.TIF SYSTEM "US20030005118A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030005118A1-20030102-D00006.TIF SYSTEM "US20030005118A1-20030102-D00006.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005118</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09896195</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010630</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F015/173</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>709</class>
<subclass>225000</subclass>
</uspc>
</classification-us-primary>
<classification-us-secondary>
<uspc>
<class>709</class>
<subclass>203000</subclass>
</uspc>
</classification-us-secondary>
</classification-us>
<title-of-invention>Method and system for secure server-based session management using single-use HTTP cookies</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Ronald</given-name>
<middle-name>B.</middle-name>
<family-name>Williams</family-name>
</name>
<residence>
<residence-us>
<city>Austin</city>
<state>TX</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
</inventors>
<assignee>
<organization-name>INTERNATIONAL BUSINESS MACHINES CORPORATION</organization-name>
<address>
<city>ARMONK</city>
<state>NY</state>
</address>
<assignee-type>02</assignee-type>
</assignee>
<correspondence-address>
<name-1>Joseph R. Burwell</name-1>
<name-2>Law Office of Joseph R. Burwell</name-2>
<address>
<address-1>P.O. Box 28022</address-1>
<city>Austin</city>
<state>TX</state>
<postalcode>78755-8022</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A methodology for providing secure session management is presented. After a single-use token has been issued to a client, it presents the token, and the server may identify the client based upon the presented token. However, the token may be used only once without being refreshed prior to re-use, thereby causing the token to be essentially reissued upon each use. The token comprises a session identifier that allows the issuer of the token to perform session management with respect to the receiving entity. Tokens can be classified into two types: domain tokens and service tokens. Domain tokens represent a client identity to a secure domain, and service tokens represent a client identity to a specific service. A domain token may be used with any service within a domain that recognizes the domain token, but a service token is specific to the service from which it was obtained. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> 1. Field of the Invention </paragraph>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> The present invention relates to an improved data processing system and, in particular, to a method and apparatus for multicomputer data transferring. Still more particularly, the present invention provides a method and apparatus for computer-to-computer session management. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> 2. Description of Related Art </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> Information technology (IT) systems and the Internet have fueled commercial activity. While IT systems have significant benefits, at the same time they pose potential security threats from unauthorized third parties. Indeed, the lack of security in modern IT systems has emerged as a threat to the integrity of global computer networks. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> To deal with this problem, IT systems provide a number of known services: data authentication, data confidentiality, entity authentication, and entity authorization. Data authentication typically consists of two sub-services: data integrity and data origin authentication. A data integrity service is used to convince a receiver of some item of given data that the data was not changed during transit, and data origin authentication proves to the receiver the identity of the real sender. Data confidentiality protects against disclosure of data during transmission. Entity authentication provides a system with proof that a certain entity is who they claim to be. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> Authorization is the act of determining whether an authenticated entity has the right to execute an action. Authorization and authentication thus are dual services. To be able to provide authorization, it is necessary to determine who the entity is, e.g., by entity authentication. Authorization, in general, consists of two separate stages: the provision of privileges to a particular entity, e.g., authorization credentials, and the use of these privileges by the receiving entity in combination with access decision rules at a protected service or a protected resource to determine if access should be granted to the entity. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> The client-side applications of many IT systems are now based on a Web browser application architecture because of its adaptability to multiple uses. Through the standard Hypertext Transfer Protocol (HTTP), a user of a browser application on a client machine can gain access to resources or services on any HTTP-enabled server. If the user at the client desires to access a protected resource or a protected service at the server that can only be accessed by an authenticated and authorized user, however, there must be some process to authenticate and authorize the user/client. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> As is well-known, a cookie is a data item that is stored on a client by a server through a particular user&apos;s web browser. When a user of a client machine visits a Web server, the server may return a cookie to the user&apos;s browser to be stored in a client-side cookie cache. When a cookie is &ldquo;set&rdquo;, i.e. stored, as part of an HTTP transaction, it may include the path, i.e. domain, for which the cookie is valid, the cookie&apos;s name and value, and other optional attributes, such as the cookie&apos;s expiration date. In most cases, the client browser automatically stores the cookie data by default, sometimes without giving the user the option or the knowledge of it being done. When the user revisits the server at some later point in time, the cookie is sent with the request, thereby identifying the user to the server. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> A typical cookie can be quite convenient for identifying a user or client to a server, but depending on the type of resources and services provided by a server, a cookie introduces security vulnerabilities into client-server communications. In some prior art solutions, identification data is forwarded within a cookie when the client browser issues a request for a protected resource to the server that set the cookie. Such an approach can be insecure because an attacker that obtains possession of the cookie might be able to gain user authorization to access the protected resource. In other words, an insecure implementation of a cookie might equate proof of possession with proof of identity. In fact, some servers equate possession of a cookie with authentication of the identity of the client/user that possesses the cookie, thereby relying on the cookie as a short-cut for identifying a user or client by other means even though cookies may be stolen and then used maliciously. More insidiously, some cookie implementations also contain the username and password required by a user to authenticate into a system. This is particularly dangerous because if this information is stolen, a malicious user can authenticate to a system using other means, such as a login application, and thereby appear to be the user that is being impersonated. The malicious user could thereafter have his own cookies set by the server at the malicious user&apos;s client machine. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> Cookies can be either persistent cookies, which are stored on disk, or memory cookies, which are stored in memory. Persistent cookies reside in a client file or cookie cache, such as &ldquo;cookies.txt&rdquo;, after the client browser is closed and are available during the next browser session. Memory cookies disappear when the browser is shut down. However, both types of cookies can be dangerous since both types of cookies can be stolen by malicious code, such as a JavaScript that has a Trojan horse, i.e. benign code that hides malicious code, through interception of network traffic, or by a malicious server in the cookie&apos;s intended domain of use. Although both types of cookies are vulnerable to theft, persistent cookies are a bigger threat because they can be stolen from the cookie file. As a consequence, these prior art schemes are highly susceptible to replay attacks wherein one who acquires a cookie can simply assert it to gain access to a protected resource or protected service. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> As mentioned above, applications in many IT systems are increasingly using Web-based or Internet-based standards, such as HTTP. However, HTTP is a stateless protocol&mdash;each client request to a server establishes a connection between the client and the server, but according to a strict interpretation of the HTTP standard, the connection is considered closed when the server responds to the client request. The client may immediately generate another request to the server, but the subsequent request is considered to establish another connection. Obviously, the most common interactions between a client and a server require multiple requests that are related to each other and that the server needs to know are related to one another. In other words, the server needs to maintain a session context for each client through which it determines that a request from a client is related to a previous request and requires a response based on this temporal relationship. Hence, most servers need a session management mechanism. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> Due to the round-trip nature of a cookie being issued from a server to a user or client and then being returned to the server at a later point in time, cookies provide a degree of state to HTTP. Therefore, cookies are frequently used for session management purposes within the server that issued the cookie. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> Although session management within the server is facilitated or enabled by the use of cookies, the use of cookies for secure session management has been historically problematic because of the client-side vulnerabilities that were discussed above with respect to authentication. Since cookies are supported by all commercial Web browsers and servers, cookies are frequently used for detailed session management, such as tracking user movement within Web sites. From a security standpoint, however, a computational environment that employs cookies to enable secure access to protected resources and/or services while storing cookies in cookie caches creates vulnerabilities that are exploitable via the acquisition of cookies by malicious persons. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> Other alternative security methodologies rely heavily on client-side functionality, but most suffer from the fundamentally uncontrolled nature of most client-based systems. The infrastructure required to support these client systems and to maintain a secure trust chain among their components is considered to be unwieldy in many environments. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> Therefore, it would be advantageous to have a lightweight security solution for ongoing session management in a Web environment. It would be particularly advantageous to have a method and system for cookie-based secure session management that is server-based and is compliant with existing Internet protocols. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> The present invention is a method, system, apparatus, or computer program product for providing secure session management using single-use tokens, also termed single-use cookies. After a single-use token has been issued to an entity, the entity may present the token to a service, and the receiving entity may identify the presenting entity based upon the presented token. However, the token may be used only once, after which the token must be updated or refreshed prior to re-use, thereby causing the token to be essentially reissued upon each use. The token comprises a session identifier of some sort that allows the issuer of the token to perform session management with respect to the receiving entity. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> Tokens can be classified into two types: domain tokens and service tokens. Domain tokens represent a client identity to a secure domain, and service tokens represent a client identity to a specific service, but both domain tokens and service tokens can be implemented as a cookie in accordance with common protocols for obtaining and setting cookies for a client browser. A domain token may be used with any service within a domain that recognizes the domain token in order to obtain a service token, but a service token is specific to the service from which it was obtained; a service token may not be used with any services other than the one that created it. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> A client attempts to login to a domain through a first server, which challenges the client to provide authentication data for identifying the client or the user of the client. After the first server has authenticated the client or the user of the client, the first server generates a single-use domain token that is associated with the client or the user of the client and returns the single-use domain token to the client. The login request may have originated as a redirect response from a second server; if so, then the first server redirects the client to the second server. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> At some point in time, a client sends to the second server a request to access a protected resource. If the client already possesses a single-use domain token, then the single-use domain token is sent to the second server along with the request to access the protected resource. If the second server does not also receive a single-use domain token, then the client is redirected to the first server to complete the domain login process. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> If the client already possesses a single-use service token, then the single-use service token is also sent to the second server along with the request to access the protected resource. If not, then the second server attempts to issue a single-use service token for the client or the user of the client, and the single-use service token is sent to the client along with the response to the request to access the protected resource. If a single-use service token is also received with the request to access the protected resource, the single-use service token is validated prior to generating the response to the request to access the protected resource. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> This summary outlines some of the features of the present invention which are illustrative of the invention, and a fuller understanding of the invention may be had by referring to the Detailed Description. </paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> The novel features believed characteristic of the invention are set forth in the appended claims. The invention itself, further objectives, and advantages thereof, will be best understood by reference to the following detailed description when read in conjunction with the accompanying drawings, wherein: </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1A</cross-reference> depicts a typical network of data processing systems, each of which may implement the present invention; </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1B</cross-reference> illustrates a Web-based environment in which the present invention may be implemented; </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1C</cross-reference> is a data flow diagram illustrating a prior art process that may be used when a client attempts to access a protected resource; </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2A</cross-reference> is a block diagram depicting the primary entities that are involved in an environment that implements the present invention; </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2B</cross-reference> is a block diagram depicting a domain authentication process between a client and a Cookie Distribution Center (CDC); </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2C</cross-reference> is a block diagram depicting a service authentication process between a client and a protected server; </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2D</cross-reference> is a block diagram depicting subsequent processing of a request from a client to a protected server; </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3A</cross-reference> is a flowchart depicting some of the steps in a process through a client obtains an identity token from a CDC in accordance with a preferred embodiment of the present invention; </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3B</cross-reference> is a flowchart depicting some of the steps in a process through which a CDC issues an identity token to a client in accordance with a preferred embodiment of the present invention; </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3C</cross-reference> is a flowchart depicting some of the steps in a process through which a client initially obtains access to a protected resource in accordance with a preferred embodiment of the present invention; </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3D</cross-reference> is a flowchart depicting some of the steps in a process through which a client obtains access to a protected resource after already receiving a service token in accordance with a preferred embodiment of the present invention; </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> FIGS. <highlight><bold>4</bold></highlight>A-<highlight><bold>4</bold></highlight>B are a pair of flowcharts depicting some of the steps in a process through which a protected server provides access to a protected resource at the request of a client in accordance with a preferred embodiment of the present invention; and </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4C</cross-reference> is a flowchart depicting some of the steps in a process through which a CDC issues client credentials to a protected server that is granting initial access to a protected resource on behalf of a client in accordance with a preferred embodiment of the present invention. </paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF THE INVENTION </heading>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> The present invention is directed to a system and a methodology for secure client-server session management. Servers that implement the present invention may be dispersed throughout a network. As background, a typical organization of hardware and software components within a distributed data processing system is described prior to describing the present invention in more detail. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> With reference now to the figures, <cross-reference target="DRAWINGS">FIG. 1A</cross-reference> depicts a typical network of data processing systems, each of which may contain and/or operate the present invention. Distributed data processing system <highlight><bold>100</bold></highlight> contains network <highlight><bold>101</bold></highlight>, which is a medium that may be used to provide communications links between various devices and computers connected together within distributed data processing system <highlight><bold>100</bold></highlight>. Network <highlight><bold>101</bold></highlight> may include permanent connections, such as wire or fiber optic cables, or temporary connections made through telephone or wireless communications. In the depicted example, server <highlight><bold>102</bold></highlight> and server <highlight><bold>103</bold></highlight> are connected to network <highlight><bold>101</bold></highlight> along with storage unit <highlight><bold>104</bold></highlight>. In addition, clients <highlight><bold>105</bold></highlight>-<highlight><bold>107</bold></highlight> also are connected to network <highlight><bold>101</bold></highlight>. Clients <highlight><bold>105</bold></highlight>-<highlight><bold>107</bold></highlight> and servers <highlight><bold>102</bold></highlight>-<highlight><bold>103</bold></highlight> may be represented by a variety of computing devices, such as mainframes, personal computers, personal digital assistants (PDAs), etc. Distributed data processing system <highlight><bold>100</bold></highlight> may include additional servers, clients, routers, other devices, and peer-to-peer architectures that are not shown. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> In the depicted example, distributed data processing system <highlight><bold>100</bold></highlight> may include the Internet with network <highlight><bold>101</bold></highlight> representing a worldwide collection of networks and gateways that use various protocols to communicate with one another, such as Lightweight Directory Access Protocol (LDAP), Transport Control Protocol/Internet Protocol (TCP/IP), Hypertext Transport Protocol (HTTP), Wireless Application Protocol (WAP), etc. Of course, distributed data processing system <highlight><bold>100</bold></highlight> may also include a number of different types of networks, such as, for example, an intranet, a local area network (LAN), or a wide area network (WAN). For example, server <highlight><bold>102</bold></highlight> directly supports client <highlight><bold>109</bold></highlight> and network <highlight><bold>110</bold></highlight>, which incorporates wireless communication links. Network-enabled phone <highlight><bold>111</bold></highlight> connects to network <highlight><bold>110</bold></highlight> through wireless link <highlight><bold>112</bold></highlight>, and PDA <highlight><bold>113</bold></highlight> connects to network <highlight><bold>110</bold></highlight> through wireless link <highlight><bold>114</bold></highlight>. Phone <highlight><bold>111</bold></highlight> and PDA <highlight><bold>113</bold></highlight> can also directly transfer data between themselves across wireless link <highlight><bold>115</bold></highlight> using an appropriate technology, such as Bluetooth&trade; wireless technology, to create so-called personal area networks (PAN) or personal ad-hoc networks. In a similar manner, PDA <highlight><bold>113</bold></highlight> can transfer data to PDA <highlight><bold>107</bold></highlight> via wireless communication link <highlight><bold>116</bold></highlight>. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> The present invention could be implemented on a variety of hardware platforms; <cross-reference target="DRAWINGS">FIG. 1A</cross-reference> is intended as an example of a heterogeneous computing environment and not as an architectural limitation for the present invention. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 1B, a</cross-reference> diagram depicts a typical computer architecture of a data processing system, such as those shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>A, in which the present invention may be implemented. Data processing system <highlight><bold>120</bold></highlight> contains one or more central processing units (CPUs) <highlight><bold>122</bold></highlight> connected to internal system bus <highlight><bold>123</bold></highlight>, which interconnects random access memory (RAM) <highlight><bold>124</bold></highlight>, read-only memory <highlight><bold>126</bold></highlight>, and input/output adapter <highlight><bold>128</bold></highlight>, which supports various I/O devices, such as printer <highlight><bold>130</bold></highlight>, disk units <highlight><bold>132</bold></highlight>, or other devices not shown, such as a audio output system, etc. System bus <highlight><bold>123</bold></highlight> also connects communication adapter <highlight><bold>134</bold></highlight> that provides access to communication link <highlight><bold>136</bold></highlight>. User interface adapter <highlight><bold>148</bold></highlight> connects various user devices, such as keyboard <highlight><bold>140</bold></highlight> and mouse <highlight><bold>142</bold></highlight>, or other devices not shown, such as a touch screen, stylus, microphone, etc. Display adapter <highlight><bold>144</bold></highlight> connects system bus <highlight><bold>123</bold></highlight> to display device <highlight><bold>146</bold></highlight>. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> Those of ordinary skill in the art will appreciate that the hardware in <cross-reference target="DRAWINGS">FIG. 1B</cross-reference> may vary depending on the system implementation. For example, the system may have one or more processors, including a digital signal processor (DSP) and other types of special purpose processors, and one or more types of volatile and non-volatile memory. Other peripheral devices may be used in addition to or in place of the hardware depicted in <cross-reference target="DRAWINGS">FIG. 1B</cross-reference>. The depicted examples are not meant to imply architectural limitations with respect to the present invention. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> In addition to being able to be implemented on a variety of hardware platforms, the present invention may be implemented in a variety of software environments. A typical operating system may be used to control program execution within each data processing system. For example, one device may run a Unix&reg; operating system, while another device contains a simple Java&reg; runtime environment. A representative computer platform may include a browser, which is a well known software application for accessing hypertext documents in a variety of formats, such as graphic files, word processing files, Extensible Markup Language (XML), Hypertext Markup Language (HTML), Handheld Device Markup Language (HDML), Wireless Markup Language (WML), and various other formats and types of files. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 1C, a</cross-reference> network diagram illustrates a more specific, yet generic, Web-based environment in which the present invention may be implemented. In this environment, a user of a browser <highlight><bold>152</bold></highlight> at client <highlight><bold>150</bold></highlight> desires to access a protected resource or protected service on web application server <highlight><bold>154</bold></highlight> in DNS domain <highlight><bold>156</bold></highlight> or on web application server <highlight><bold>158</bold></highlight> in DNS domain <highlight><bold>160</bold></highlight> through a network. The computer network may be the Internet, an intranet, or other network, as shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>A, and the server may be a Web application server, a server application, a servlet process, or the like. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> A service may be considered to be a type of resource, and a resource may be provided via a service; hence, service and resource may be used interchangeably. A protected resource is a resource, such as an application, an object, a document, a page, a file, executable code, or other computational resource, communication-type resource, etc., that is only retrieved or accessed if the requesting client or user has been both authenticated and authorized. A protected resource, which is typically identified by a Uniform Resource Locator (URL), or more generally, a Uniform Resource Identifier (URI), can only be accessed by an authenticated and authorized user. Each DNS domain may have an associated authentication server, shown as server <highlight><bold>162</bold></highlight> and server <highlight><bold>164</bold></highlight>. Typically, once the user is authenticated by the authentication server, a cookie may be set and stored in a cookie cache in the browser. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> As noted above, the present invention may be used within a variety of networks and hardware/software platforms. More particularly, though, the present invention provides a methodology for secure client-server session management using cookies. The term &ldquo;cookie&rdquo;, &ldquo;token&rdquo;, or &ldquo;identifier&rdquo; may be used interchangeably in relation to the present invention, as is described below with respect to the remaining figures. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 2A, a</cross-reference> block diagram shows the primary entities that are involved in an environment that implements the present invention. Cookie Distribution Center (CDC) <highlight><bold>202</bold></highlight>, provides authentication, secure session management, and authorization credential acquisition services to protected servers in the CDC environment, i.e. domain <highlight><bold>200</bold></highlight>. In <cross-reference target="DRAWINGS">FIG. 2</cross-reference>A, client <highlight><bold>204</bold></highlight> represents a browser session of a user at a client machine. To initiate a secure session within CDC-protected domain <highlight><bold>200</bold></highlight>, the client authenticates to the CDC and, if successful, receives a single-use domain cookie that represents the client&apos;s identity for operations within domain <highlight><bold>200</bold></highlight>, which is equivalent to stating that the domain cookie represents the client&apos;s identity for operations with respect to the CDC alone, as will be explained in more detail further below. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> Protected server <highlight><bold>206</bold></highlight> hosts protected services and protected resources that are sought by clients. In other words, protected server <highlight><bold>206</bold></highlight> may be viewed as a protected resource to client <highlight><bold>204</bold></highlight>. To the CDC, however, protected server <highlight><bold>206</bold></highlight> is an authenticated client because protected server <highlight><bold>206</bold></highlight> also uses the CDC concurrently with client <highlight><bold>204</bold></highlight>, as is described below in more detail; to the protected server, the CDC is an authenticating server. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> It should be noted that the data format of any of the messages between the entities in the network, such as requests and responses, may vary depending upon system implementation in accordance with proprietary or standard formats. It should also be noted that the CDC, the protected server, and/or a client may be hosted on the same physical machine. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> Tokens can be classified into two types: domain tokens and service tokens. Domain tokens represent a client identity to a secure domain, and service tokens represent a client identity to a specific service, but both domain tokens and service tokens can be implemented as a cookie in accordance with the protocols for obtaining and setting cookies for a client browser. A domain token may be used with any service within a domain that recognizes the domain token, but a service token is specific to the service from which it was obtained; a service token may not be used with any services other than the one that created it. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> The data format of any tokens may vary depending upon system implementation in accordance with proprietary or standard formats. For example, a token may also include an optional timestamp for publicly indicating and limiting the useful lifetime of the token. A token may be formatted as a binary string, as an encoded ASCII string, or in some other interpretable format. A token may be optionally formatted in accordance with various standards, such as PKCS (Public Key Cryptography Standards) specifications for enveloped data. In other words, in addition to comprising hashed user-specified identity information, any information within a token may be encrypted to hide the information so as to limit the risk that it might be misappropriated. It should be noted either that the entire token can be an encrypted data item or that individual data items can be encrypted and then placed within the token. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> Protected server <highlight><bold>206</bold></highlight> is able to respond to service requests from client <highlight><bold>204</bold></highlight>, i.e. protected server <highlight><bold>206</bold></highlight> establishes a session context in which it will provide service to client <highlight><bold>204</bold></highlight>. However, protected server <highlight><bold>206</bold></highlight> initially generates a request to CDC <highlight><bold>202</bold></highlight> and establishes a session context between protected server <highlight><bold>206</bold></highlight> and CDC <highlight><bold>202</bold></highlight>. A protected server must be known and trusted by the CDC before the protected server can be provided service by the CDC. To that end, protected server <highlight><bold>206</bold></highlight> has established its own session context with CDC <highlight><bold>202</bold></highlight> prior to a client receiving access to a protected resource at the protected server. In addition, the protected server may have established a shared session key with which to protect communications between itself and the CDC; the entities within the network may share or synchronize cryptographic keys as appropriate in accordance with many well-known manners in the prior art. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 2B, a</cross-reference> block diagram depicts a domain authentication process between a client and a CDC. As a first step, client <highlight><bold>204</bold></highlight> sends a login request <highlight><bold>210</bold></highlight> to CDC <highlight><bold>202</bold></highlight>. Communications between client <highlight><bold>204</bold></highlight> and CDC <highlight><bold>202</bold></highlight> may be protected through the use of cryptographic keys as appropriate for a selected level of security. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> Assuming that the present invention is being implemented in a lightweight manner, the login request may be a simple request to access a markup language document that represents a login Web page. In this manner, the client does not require a login application to have been previously installed, and the present invention can rely on a browser application on the client machine to support the login process. In response to the login request, CDC <highlight><bold>202</bold></highlight> sends a login applet <highlight><bold>212</bold></highlight> and a randomly generated nonce value to client <highlight><bold>204</bold></highlight>. The login applet comprises cryptographic functionality to create a message authentication code (MAC) from the client to the server. In general, a nonce value is a server-supplied value, such as a hexadecimal string, that is returned by the receiving client in its response to the server in some manner. With the support of the browser application, the login applet would challenge the user at the client for a user identifier and a user password, and the login applet would generate the MAC by cryptographically combining or hashing the user-supplied information and the nonce value in an appropriate manner. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> Client <highlight><bold>204</bold></highlight> then sends MAC <highlight><bold>214</bold></highlight> to CDC <highlight><bold>202</bold></highlight>, which attempts to authenticate the client response. If the authentication is unsuccessful, then a failure message may be returned to the client and displayed for the user. However, assuming that the authentication is successful, then a single-use domain token <highlight><bold>216</bold></highlight>, i.e. a domain cookie, is returned to the client, and an appropriate message may be returned and displayed for the user. The browser application would store the single-use domain token for subsequent use as necessary for accessing protected resources, and the domain authentication process would be complete. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> As noted previously, at some point in time, protected server <highlight><bold>206</bold></highlight> is required to complete a successful authentication process in order to establish a session with CDC <highlight><bold>202</bold></highlight> before the protected server can process requests from a client. Rather than operating the protected server in a lightweight manner with respect to the CDC, a login application may be installed on the protected server, and the login application provides the cryptographic functionality that is required for generating the responses to the authentication challenges from the CDC. In that case, a protected server would receive a nonce value from the CDC but would not receive a login applet as part of the response from the CDC. For example, the login application may automatically perform its domain authentication process with the CDC during its initialization procedures at startup. In a manner similar to the client, if the protected server is successfully authenticated, then the protected server also receives a single-use domain token that is to be used with subsequent communications to the CDC. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 2C, a</cross-reference> block diagram depicts a service authentication process between a client and a protected server. As a first step, client <highlight><bold>204</bold></highlight> sends a request <highlight><bold>220</bold></highlight> for a protected service/resource to protected server <highlight><bold>206</bold></highlight>. Because the protected server is within the same domain <highlight><bold>200</bold></highlight> as CDC <highlight><bold>202</bold></highlight>, the client&apos;s browser application sends any cookies associated with the domain in the request or along with the request in some form of association between the domain token and the request; in this case, the client sends single-use domain token <highlight><bold>216</bold></highlight> that was received from CDC <highlight><bold>202</bold></highlight> during its domain authentication process as described above with respect to <cross-reference target="DRAWINGS">FIG. 2B</cross-reference>. </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> In response to receiving the request from the client, protected server <highlight><bold>206</bold></highlight> then sends user/client authorization credential request <highlight><bold>222</bold></highlight> to CDC <highlight><bold>202</bold></highlight>. The client authorization credential request comprises the client&apos;s single-use domain token and may include other secondary client authentication information, such as the client&apos;s IP address, which assumes that the protected server has the ability to obtain a client machine&apos;s IP address independent of the token itself. In order to identify itself to the CDC, the protected server also sends the protected server&apos;s single-use domain token to the CDC. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> Communications between protected server <highlight><bold>206</bold></highlight> and CDC <highlight><bold>202</bold></highlight> may be protected through the use of cryptographic keys as appropriate for a selected level of security, such as the session keys that were previously mentioned. The protected server may use well-known authorization schemes for obtain the client authorization credentials, such as the AuthAPI&trade; specification, which is the Open Group Authorization API. The protected server can use the client authorization credentials to bind an identity to the client&apos;s session, to create a service token for the client, and to represent the client in access control decision requests via an AuthAPI&trade; product. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> In response to receiving the client credential request, the CDC validates both the client&apos;s single-use domain token and the protected server&apos;s single-use domain token and then generates the client credentials, which might contain various types of information, such as authorization information for the client or user for indicating the types of resources that the client or the user may access. In general, the client credentials may comprise any user-specific or client-specific authorization information that is managed outside of a protected server but that may be used by a protected server to perform access control decisions with respect to service requests to access protected resources. </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> In addition, the CDC refreshes the client&apos;s single-use domain token and the protected server&apos;s single-use domain token. As should be apparent from the terminology of the present invention, the single-use domain token can be asserted and used only once by its owning entity, i.e. the entity with which the domain token is associated. After a single-use domain token has been used, it cannot be re-used without being refreshed or updated by its issuing entity so that it may be used again. Essentially, a token is reissued upon each use. Asserting a stale or invalid token would result in a failed operation and optionally other security measures, such as tracking the originating address of the asserting entity. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> If the domain tokens have been successfully validated, then the CDC returns the newly generated client credentials and the refreshed domain tokens to the protected server in an appropriate response message <highlight><bold>224</bold></highlight>. Otherwise, the response indicates some type of failure upon which the protected server may take further action. </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> Protected server <highlight><bold>206</bold></highlight> then stores the client credentials and the protected server&apos;s refreshed single-use domain token. After other possible processing steps for client request <highlight><bold>220</bold></highlight>, such as establishing a session context for client <highlight><bold>204</bold></highlight>, protected server <highlight><bold>206</bold></highlight> then generates, i.e. issues, a single-use service token, which is expected to be asserted by the client along with each request that the client sends to the protected server in order to identify the client to the protected server. The token also includes session information in some manner for allowing the protected server to identify the client&apos;s session context when a next request is received from the client within the established session. For example, a session ID can be issued by the protected server and inserted in the service token; the session ID is subsequently matched to the client&apos;s session context when received by the protected server. Preferably, the session information is a session key contained in the data field of the cookie. Protected server <highlight><bold>206</bold></highlight> then returns to client <highlight><bold>204</bold></highlight> a newly generated service response message <highlight><bold>226</bold></highlight>, which comprises (or is otherwise associated with) an updated single-use domain token from the CDC, a single-use service token from the protected server, and any other information that fulfills the request from the client. </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 2D, a</cross-reference> block diagram depicts subsequent processing of a request from a client to a protected server. As a first step, client <highlight><bold>204</bold></highlight> sends a request <highlight><bold>230</bold></highlight> for a protected service/resource to protected server <highlight><bold>206</bold></highlight>. Given the destination domain of the request, the client&apos;s browser application sends any cookies associated with the domain along with the request. In this case, assuming that the client has received refreshed tokens from the protected server in response to a previous request, the client sends the refreshed single-use domain token for domain <highlight><bold>200</bold></highlight> that was received from protected server <highlight><bold>206</bold></highlight> during the previous request as described above with respect to <cross-reference target="DRAWINGS">FIG. 2C</cross-reference>. In addition, the client also sends a single-use service token that was possibly newly generated during the previous request as described above with respect to <cross-reference target="DRAWINGS">FIG. 2C</cross-reference>. </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> In response, the protected server uses the session ID in the service token to match the previously established session context with the client, and the protected server processes the client&apos;s request and also refreshes the single-use service token. The protected server then generates and returns service response message <highlight><bold>232</bold></highlight> for the client that comprises the refreshed single-use service token in addition to any other information that fulfills the client&apos;s request. Hence, any subsequent request from a client would comprise a refreshed single-use service token rather than a newly generated service token. </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> In a preferred embodiment, prior to returning a response to client <highlight><bold>204</bold></highlight>, protected server <highlight><bold>206</bold></highlight> also refreshes the client&apos;s domain token by forwarding it to CDC <highlight><bold>202</bold></highlight>; in order to do so, protected server <highlight><bold>206</bold></highlight> also sends its domain token along with the client&apos;s domain token in request message <highlight><bold>234</bold></highlight>. After CDC <highlight><bold>202</bold></highlight> validates and refreshes the tokens, they are returned in message <highlight><bold>236</bold></highlight>. </paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> In a manner similar to that described above for the single-use domain token, a single-use service token can be asserted only once by its owning entity, i.e. the entity with which the service token is associated. After a single-use service token has been used, it cannot be re-used without being refreshed or updated by its issuing entity so that it may be used again. Essentially, a token is reissued upon each use. Asserting a stale or invalid token would result in a failed operation and optionally other security measures, such as tracking the originating address of the asserting entity. </paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> If a request from a client to a protected server does not include a single-use domain token, the protected server can redirect the client to the CDC to perform a login process in a manner similar to that described above with respect to <cross-reference target="DRAWINGS">FIG. 2B</cross-reference>. The protected server can indicate a return URI to which the client should be subsequently redirected after successfully completing the login process. Hence, request <highlight><bold>210</bold></highlight> and response <highlight><bold>216</bold></highlight> may contain information for redirecting the client as appropriate. Assuming that the HTTP protocol is being used for communication between the entities shown in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>D, the protected server may use an HTTP Redirect message. An HTTP Redirect allows a server to respond to a client request with instructions to load a resource at a different location, and in response, most browsers will automatically request the new resource in response to a redirect. When the browser receives the HTTP Redirect, the browser issues a new HTTP Request using the redirected URI provided in the HTTP Redirect. </paragraph>
<paragraph id="P-0068" lvl="0"><number>&lsqb;0068&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 3A, a</cross-reference> flowchart depicts some of the steps in a process through which a client obtains a domain token from a Cookie Distribution Center (CDC) in accordance with a preferred embodiment of the present invention. The process begins with the client initiating a login process with a CDC (step <highlight><bold>302</bold></highlight>), after which the client receives an authentication challenge from the CDC (step <highlight><bold>304</bold></highlight>). In response, the client then sends user-specific or client-specific authentication data to the CDC in a secure manner (step <highlight><bold>306</bold></highlight>), and the client subsequently receives a domain token, i.e. domain cookie, from the CDC (step <highlight><bold>308</bold></highlight>). The client stores the domain token (step <highlight><bold>310</bold></highlight>) until it is required to be asserted as proof-of-identity at some later point in time, and the process is complete. </paragraph>
<paragraph id="P-0069" lvl="0"><number>&lsqb;0069&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 3B, a</cross-reference> flowchart depicts some of the steps in a process through which a CDC issues a domain token to a client in accordance with a preferred embodiment of the present invention. The process begins with the CDC detecting the initiation of a login sequence by a client in some manner (step <highlight><bold>322</bold></highlight>), and the CDC responds by sending an authentication challenge to the client (step <highlight><bold>324</bold></highlight>). The CDC then receives user-specific or client-specific authentication data from the client (step <highlight><bold>326</bold></highlight>). The CDC authenticates the client or user (step <highlight><bold>328</bold></highlight>) by processing the authentication data to determine whether or not the client or the user that is asserting itself has properly established its identity, and if so, then the CDC generates a domain token for the client or user (step <highlight><bold>330</bold></highlight>), which might include registering the domain token within a database. The CDC then sends the domain token to the client (step <highlight><bold>332</bold></highlight>), and the process is complete. </paragraph>
<paragraph id="P-0070" lvl="0"><number>&lsqb;0070&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 3C, a</cross-reference> flowchart depicts some of the steps in a process through which a client initially obtains access to a protected resource in accordance with a preferred embodiment of the present invention. The process begins with the client generating a service request to access a protected resource at a protected server (step <highlight><bold>342</bold></highlight>). The client then sends the service request to the protected server along with any tokens that are associated with the domain containing the protected server, which in this case would include the client&apos;s domain token that was received from the CDC (step <highlight><bold>344</bold></highlight>). At some later point in time, the client receives from the protected server a service response along with a refreshed domain token and a newly issued service token, which contains some form of a session identifier (step <highlight><bold>346</bold></highlight>). The client stores the tokens that it has received from the protected server (step <highlight><bold>348</bold></highlight>), e.g., within a cookie cache. The client then processes any data that has been received as part of the service response (step <highlight><bold>350</bold></highlight>), and the process is complete. </paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 3D, a</cross-reference> flowchart depicts some of the steps in a process through which a client obtains access to a protected resource after already receiving a service token in accordance with a preferred embodiment of the present invention. The process shown in <cross-reference target="DRAWINGS">FIG. 3D</cross-reference> is similar to that shown in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>C, but <cross-reference target="DRAWINGS">FIG. 3C</cross-reference> represents the actions of a client while initiating a session with a protected server, whereas <cross-reference target="DRAWINGS">FIG. 3D</cross-reference> represents the actions of a client after a session has been established with a protected server. </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> The process begins with the client generating a service request to access a protected resource at a protected server (step <highlight><bold>362</bold></highlight>). The client then sends the service request to the protected server along with any tokens that are associated with the domain containing the protected server, which in this case would include the client&apos;s domain token that was received from the CDC and the client&apos;s service token (containing a session identifier) that was received from the protected server when a session was established between the client and the protected server (step <highlight><bold>364</bold></highlight>). At some later point in time, the client receives from the protected server a service response along with a refreshed service token and possibly a refreshed domain token (step <highlight><bold>366</bold></highlight>). The client stores the updated service token (and updated domain token, if necessary) that it has received from the protected server (step <highlight><bold>368</bold></highlight>), e.g., within a cookie cache. The client then processes any data that has been received as part of the service response (step <highlight><bold>370</bold></highlight>), and the process is complete. </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> With reference now to FIGS. <highlight><bold>4</bold></highlight>A-<highlight><bold>4</bold></highlight>B, a pair of flowcharts depict some of the steps in a process through which a protected server provides access to a protected resource at the request of a client in accordance with a preferred embodiment of the present invention. Referring to <cross-reference target="DRAWINGS">FIG. 4</cross-reference>A, the process begins with the protected server receiving a service request from a client (step <highlight><bold>402</bold></highlight>). A determination is then made as to whether or not the service request comprises a domain token (step <highlight><bold>404</bold></highlight>). If not, then the client is redirected to perform a login process at a CDC (step <highlight><bold>406</bold></highlight>), after which the CDC will redirect the client to the protected server. </paragraph>
<paragraph id="P-0074" lvl="0"><number>&lsqb;0074&rsqb;</number> If the service request comprises a domain token, then a determination is made as to whether the service request also comprises a service token (step <highlight><bold>408</bold></highlight>). If so, then the protected server validates the client&apos;s service token (step <highlight><bold>410</bold></highlight>), and assuming the validation is successful, the protected server refreshes the client&apos;s service token (step <highlight><bold>412</bold></highlight>); the session identifying information in the service token allows the protected server to match the previously established session context with the client and to update or refresh the client&apos;s session context, i.e. to perform any necessary session management. In an alternative embodiment, the protected server also sends the client&apos;s domain token to the CDC to refresh the client&apos;s domain token; in order to do so, the protected server would also send its domain token, which would also be refreshed. In response to the client&apos;s service request, the protected server then generates a service response (step <highlight><bold>414</bold></highlight>) and sends the service response with the refreshed service token to the client (step <highlight><bold>416</bold></highlight>), and the process is complete. </paragraph>
<paragraph id="P-0075" lvl="0"><number>&lsqb;0075&rsqb;</number> If the service request does not comprise a service token as determined at step <highlight><bold>408</bold></highlight>, then process branches to attempt to issue a service token for the client. Referring to <cross-reference target="DRAWINGS">FIG. 4</cross-reference>B, the protected server generates a credential request (step <highlight><bold>422</bold></highlight>) and sends the credential request to a CDC with the client&apos;s domain token and the protected server&apos;s domain token (step <highlight><bold>424</bold></highlight>); other secondary authentication information may also be included. Assuming that the CDC successfully authenticates the submitted domain tokens, the protected server receives the client&apos;s credentials along with a refreshed client domain token and a refreshed protected server domain token (step <highlight><bold>426</bold></highlight>). The protected server then stores the client&apos;s credentials (step <highlight><bold>428</bold></highlight>); the client&apos;s credentials comprise authorization information for making access control decisions with respect to protected resources on behalf of the client&apos;s service requests. </paragraph>
<paragraph id="P-0076" lvl="0"><number>&lsqb;0076&rsqb;</number> The protected server then stores its refreshed domain token (step <highlight><bold>430</bold></highlight>) and generates a service token for the client while establishing a session context for the client (step <highlight><bold>432</bold></highlight>). Since this portion of the process is complete, the process branches back to the steps shown in <cross-reference target="DRAWINGS">FIG. 4A</cross-reference>. </paragraph>
<paragraph id="P-0077" lvl="0"><number>&lsqb;0077&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 4C, a</cross-reference> flowchart depicts some of the steps in a process through which a CDC issues client credentials to a protected server that is granting initial access to a protected resource on behalf of a client in accordance with a preferred embodiment of the present invention. The process begins with the CDC receiving a credential request along with the client&apos;s domain token and the protected server&apos;s domain token (step <highlight><bold>442</bold></highlight>). The CDC validates the protected server&apos;s domain token (step <highlight><bold>444</bold></highlight>) and validates the client&apos;s domain token (step <highlight><bold>446</bold></highlight>), and assuming that the tokens are successfully validated, the CDC generates the client credentials (step <highlight><bold>448</bold></highlight>). The CDC then refreshes the protected server&apos;s domain token (step <highlight><bold>450</bold></highlight>) and refreshes the client&apos;s domain token (step <highlight><bold>452</bold></highlight>). The CDC sends the client credentials with the refreshed domain tokens to the protected server (step <highlight><bold>454</bold></highlight>), and the process is complete. </paragraph>
<paragraph id="P-0078" lvl="0"><number>&lsqb;0078&rsqb;</number> The advantages of the present invention should be apparent in view of the detailed description of the invention that is provided above. The present invention provides secure session management using single-use tokens, also termed single-use cookies. After a single-use token has been issued to an entity, it may be presented for use only once, after which the token must be updated or refreshed prior to re-use, thereby causing the token to be essentially reissued upon each use. The single-use token contains a session identifier of some type that allows the token issuer to perform session management with respect to the owner of the token. The present invention is relatively easy to implement because it uses standard Internet-based and Web-based protocols without requiring signed applets or browser plug-ins to support the ongoing use of single-use cookies by a client. Additionally, the present invention is independent of the encryption infrastructure that might be used to support secure communication between the interacting entities. </paragraph>
<paragraph id="P-0079" lvl="0"><number>&lsqb;0079&rsqb;</number> Through a server-based cookie refresh process, the present invention provides server-based management and control of the client security context. Separate domain cookies and service cookies can be implemented, yet the method is uniform for both clients and protected servers. </paragraph>
<paragraph id="P-0080" lvl="0"><number>&lsqb;0080&rsqb;</number> It is important to note that while the present invention has been described in the context of a fully functioning data processing system, those of ordinary skill in the art will appreciate that the processes of the present invention are capable of being distributed in the form of instructions in a computer readable medium and a variety of other forms, regardless of the particular type of signal bearing media actually used to carry out the distribution. Examples of computer readable media include media such as EPROM, ROM, tape, paper, floppy disc, hard disk drive, RAM, and CD-ROMs and transmission-type media, such as digital and analog communications links. </paragraph>
<paragraph id="P-0081" lvl="0"><number>&lsqb;0081&rsqb;</number> The description of the present invention has been presented for purposes of illustration but is not intended to be exhaustive or limited to the disclosed embodiments. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiments were chosen to explain the principles of the invention and its practical applications and to enable others of ordinary skill in the art to understand the invention in order to implement various embodiments with various modifications as might be suited to other contemplated uses. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method for controlling access to protected resources within a distributed data processing system, the method comprising: 
<claim-text>receiving at a first server from a client a request to access a protected resource and a single-use token associated with the client or a user of the client; </claim-text>
<claim-text>validating the single-use token, wherein the single-use token comprises session information for performing session management with respect to the client; </claim-text>
<claim-text>generating a response to the request; </claim-text>
<claim-text>refreshing the single-use token; and </claim-text>
<claim-text>sending the response and the refreshed single-use token to the client. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> further comprising: 
<claim-text>determining that the single-use token is a service token, wherein a service token is issued by the first server; and </claim-text>
<claim-text>refreshing the single-use service token at the first server. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein the session information in the single-use token is a session key. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> further comprising: 
<claim-text>determining that the single-use token is a domain token; </claim-text>
<claim-text>generating a client authorization credential request; </claim-text>
<claim-text>sending to a second server the client authorization credential request, the single-use domain token associated with the client or the user of the client, and a single-use domain token associated with the first server, wherein the first server and the second server are operated within a common domain. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00004">claim 4</dependent-claim-reference> further comprising: 
<claim-text>validating at the second server the single-use domain token associated with the client or the user of the client and the single-use domain token associated with the first server; </claim-text>
<claim-text>generating the client authorization credential; </claim-text>
<claim-text>refreshing at the second server the single-use domain token associated with the client or the user of the client and the single-use domain token associated with the first server; and </claim-text>
<claim-text>sending to the first server the client authorization credential, the refreshed single-use domain token associated with the client or the user of the client, and the refreshed single-use domain token associated with the first server. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference> further comprising: 
<claim-text>storing the client authorization credential at the first server; </claim-text>
<claim-text>generating a single-use service token associated with the client or the user of the client; and </claim-text>
<claim-text>sending to the client the single-use service token along with the response and the single-use domain token. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> further comprising: 
<claim-text>receiving a login request from the client at the second server; </claim-text>
<claim-text>challenging the client to provide authentication data; </claim-text>
<claim-text>receiving authentication data from the client; </claim-text>
<claim-text>authenticating the client; </claim-text>
<claim-text>generating a single-use domain token associated with the client or the user of the client; </claim-text>
<claim-text>generating an authentication response; and </claim-text>
<claim-text>sending the authentication response and the single-use domain token to the client. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference> further comprising: 
<claim-text>determining that the login request is a redirected request from the first server; and </claim-text>
<claim-text>modifying the authentication response to redirect the client to the first server. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. An apparatus for controlling access to protected resources within a distributed data processing system, the apparatus comprising: 
<claim-text>means for receiving at a first server from a client a request to access a protected resource and a single-use token associated with the client or a user of the client; </claim-text>
<claim-text>means for validating the single-use token, wherein the single-use token comprises session information for performing session management with respect to the client; </claim-text>
<claim-text>means for generating a response to the request; </claim-text>
<claim-text>means for refreshing the single-use token; and </claim-text>
<claim-text>means for sending the response and the refreshed single-use token to the client. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference> further comprising: 
<claim-text>means for determining that the single-use token is a service token, wherein a service token is issued by the first server; and </claim-text>
<claim-text>means for refreshing the single-use service token at the first server. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference> wherein the session information in the single-use token is a session key. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference> further comprising: 
<claim-text>means for determining that the single-use token is a domain token; </claim-text>
<claim-text>means for generating a client authorization credential request; </claim-text>
<claim-text>means for sending to a second server the client authorization credential request, the single-use domain token associated with the client or the user of the client, and a single-use domain token associated with the first server, wherein the first server and the second server are operated within a common domain. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference> further comprising: 
<claim-text>means for validating at the second server the single-use domain token associated with the client or the user of the client and the single-use domain token associated with the first server; </claim-text>
<claim-text>means for generating the client authorization credential; </claim-text>
<claim-text>means for refreshing at the second server the single-use domain token associated with the client or the user of the client and the single-use domain token associated with the first server; and </claim-text>
<claim-text>means for sending to the first server the client authorization credential, the refreshed single-use domain token associated with the client or the user of the client, and the refreshed single-use domain token associated with the first server. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference> further comprising: 
<claim-text>means for storing the client authorization credential at the first server; </claim-text>
<claim-text>means for generating a single-use service token associated with the client or the user of the client; and </claim-text>
<claim-text>means for sending to the client the single-use service token along with the response and the single-use domain token. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference> further comprising: 
<claim-text>means for receiving a login request from the client at the second server; </claim-text>
<claim-text>means for challenging the client to provide authentication data; </claim-text>
<claim-text>means for receiving authentication data from the client; </claim-text>
<claim-text>means for authenticating the client; </claim-text>
<claim-text>means for generating a single-use domain token associated with the client or the user of the client; </claim-text>
<claim-text>means for generating an authentication response; and </claim-text>
<claim-text>means for sending the authentication response and the single-use domain token to the client. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference> further comprising: 
<claim-text>means for determining that the login request is a redirected request from the first server; and </claim-text>
<claim-text>means for modifying the authentication response to redirect the client to the first server. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. A computer program product on a computer readable medium for controlling access to protected resources within a distributed data processing system, the computer program product comprising: 
<claim-text>instructions for receiving at a first server from a client a request to access a protected resource and a single-use token associated with the client or a user of the client; </claim-text>
<claim-text>instructions for validating the single-use token, wherein the single-use token comprises session information for performing session management with respect to the client; </claim-text>
<claim-text>instructions for generating a response to the request; </claim-text>
<claim-text>instructions for refreshing the single-use token; and </claim-text>
<claim-text>instructions for sending the response and the refreshed single-use token to the client. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The computer program product of <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference> further comprising: 
<claim-text>instructions for determining that the single-use token is a service token, wherein a service token is issued by the first server; and </claim-text>
<claim-text>instructions for refreshing the single-use service token at the first server. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The computer program product of <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference> wherein the session information in the single-use token is a session key. </claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The computer program product of <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference> further comprising: 
<claim-text>instructions for determining that the single-use token is a domain token; </claim-text>
<claim-text>instructions for generating a client authorization credential request; </claim-text>
<claim-text>instructions for sending to a second server the client authorization credential request, the single-use domain token associated with the client or the user of the client, and a single-use domain token associated with the first server, wherein the first server and the second server are operated within a common domain. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The computer program product of <dependent-claim-reference depends_on="CLM-00022">claim 20</dependent-claim-reference> further comprising: 
<claim-text>instructions for validating at the second server the single-use domain token associated with the client or the user of the client and the single-use domain token associated with the first server; </claim-text>
<claim-text>instructions for generating the client authorization credential; </claim-text>
<claim-text>instructions for refreshing at the second server the single-use domain token associated with the client or the user of the client and the single-use domain token associated with the first server; and </claim-text>
<claim-text>instructions for sending to the first server the client authorization credential, the refreshed single-use domain token associated with the client or the user of the client, and the refreshed single-use domain token associated with the first server. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The computer program product of <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference> further comprising: 
<claim-text>instructions for storing the client authorization credential at the first server; </claim-text>
<claim-text>instructions for generating a single-use service token associated with the client or the user of the client; and </claim-text>
<claim-text>instructions for sending to the client the single-use service token along with the response and the single-use domain token. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The computer program product of <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference> further comprising: 
<claim-text>instructions for receiving a login request from the client at the second server; </claim-text>
<claim-text>instructions for challenging the client to provide authentication data; </claim-text>
<claim-text>instructions for receiving authentication data from the client; </claim-text>
<claim-text>instructions for authenticating the client; </claim-text>
<claim-text>instructions for generating a single-use domain token associated with the client or the user of the client; </claim-text>
<claim-text>instructions for generating an authentication response; and </claim-text>
<claim-text>instructions for sending the authentication response and the single-use domain token to the client. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The computer program product of <dependent-claim-reference depends_on="CLM-00022">claim 23</dependent-claim-reference> further comprising: 
<claim-text>instructions for determining that the login request is a redirected request from the first server; and </claim-text>
<claim-text>instructions for modifying the authentication response to redirect the client to the first server.</claim-text>
</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>3A</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005118A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005118A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005118A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005118A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005118A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005118A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030005118A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
