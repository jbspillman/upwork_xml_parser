<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030004958A1-20030102-D00000.TIF SYSTEM "US20030004958A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030004958A1-20030102-D00001.TIF SYSTEM "US20030004958A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030004958A1-20030102-D00002.TIF SYSTEM "US20030004958A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030004958A1-20030102-D00003.TIF SYSTEM "US20030004958A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030004958A1-20030102-D00004.TIF SYSTEM "US20030004958A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030004958A1-20030102-D00005.TIF SYSTEM "US20030004958A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030004958A1-20030102-D00006.TIF SYSTEM "US20030004958A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030004958A1-20030102-D00007.TIF SYSTEM "US20030004958A1-20030102-D00007.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030004958</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09896601</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010629</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F007/00</ipc>
</classification-ipc-primary>
<classification-ipc-secondary>
<ipc>G06F017/00</ipc>
</classification-ipc-secondary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>707</class>
<subclass>100000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Platonic reasoning process</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Lucian</given-name>
<family-name>Russell</family-name>
</name>
<residence>
<residence-us>
<city>Alexandria</city>
<state>VA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
</inventors>
<correspondence-address>
<name-1>Greenberg and Lieberman Law Offices</name-1>
<name-2></name-2>
<address>
<address-1>314 Philadelphia Ave.</address-1>
<city>Takoma Park</city>
<state>MD</state>
<postalcode>20912</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">The distinguishing feature of the present invention is that it provides a means to answer a query about a database when the data in the database is not complete or is not considered to be trustworthy. The adverb Platonic is used to describe the reasoning process because of Plato&apos;s metaphorical description of how human beings perceive reality. The metaphor was one of a fire in a cave. Plato said that human beings cannot perceive objects in the real world in their exact form. If an object were in a cave, a fire in the cave would cast a shadow of that object on the wall. That shadow, however, would alter shape and the edges would appear to flicker. A person in that cave facing the wall would not be able to see the true form of the object, only the shadows. However, by looking at those shadows it would be possible to get a good approximation of the shape of the actual object. That is the intent of the present invention, to process the data as so as to obtain a good approximation of the object in the real world that the data represents. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> Priority is hereby claimed to U.S. provisional patent application No. ______ filed on ______. </paragraph>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> There has been extensive work in reasoning about the data in databases going back over 40 years. This work encompasses monotonic reasoning, best known in the guise of automatic theorem proving, and non-monotonic reasoning of truth maintenance. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> There has been extensive work in the area of applying Bayesian probability measures to complex situations, notably the work of Judea Pearl (Probabilistic Reasoning in Intelligent Systems : Networks of Plausible Inference), who maintains a bibliography of over 1000 references. Results are documented in many conferences on uncertainty reasoning. The only known practical example of the application of this formalism has been in text retrieval. The INQUERY system, developed at the University of Massachusetts at Amherst uses the relative occurrence of words in documents as an estimate of probability and then performs a Bayesian net inference on the data. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> There has been extensive literature in fuzzy sets. For a baseline see Klir&apos;s &ldquo;Fuzzy Sets and Fuzzy Logic: Theory and Applications&rdquo;, and &ldquo;Uncertainty-Based Information : Elements of Generalized Information Theory.&rdquo; Again, the question arises on how to assign fuzzy measures. For a small number of measures of simple systems they can be assigned by a human being. This breaks down when the problem becomes too complex. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> Baconian measures have not been applied mathematically and systematically except in a few academic settings. They have not been used as a technique to compute fuzzy measures. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> The use of filters was discussed in great detail by Lucian Russell in &ldquo;Posits and Rationales&rdquo;, a Ph.D. dissertation at George Mason University. It has been submitted as documentation for patents in 1998. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> Computer representations of information are stored in a database. The following definitions are those generally used by Information Technology standards bodies. A database consists of data elements and their relationships and the range of values that the data representation is expected to assume. The data that describes other data is called metadata. The metadata structure of data in terms of groupings of data and linking of groupings is the schema. The metadata structure that describes the expected range of values is called the integrity constraints. A database that is organized into a set of tables, where linkages among tabular entries are represented by explicit data values present in those tables, can be called a relational database. This is because the tables are a representation of the mathematical construct called a relation. The term relation is mathematically defined whereas the term relationship has a more general meaning, and requires a context in which it is precisely defined. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> A relational database has the property that any of its data elements can be reassembled into another table using a combination of three operations, select, project and join. A complex operation consisting of the use of these operations, perhaps multiple times, is a query. The use of a sequence of queries can also be used to create new tables. This process has been mathematically demonstrated to be identical, under three assumptions, to be the same as proving an equivalent mathematical theorem using that data. Because of this fact a process that queries data is a reasoning process. Therefore the Platonic Reasoning Process is also a Platonic Querying Process. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> The distinguishing feature of the PRP is that it provides a means to answer a query about a database when the data in the database is not complete or is not considered to be trustworthy. The adverb Platonic is used to describe the reasoning process because of Plato&apos;s metaphorical description of how human beings perceive reality. The metaphor was one of a fire in a cave. Plato said that human beings cannot perceive objects in the real world in their exact form. If an object were in a cave, a fire in the cave would cast a shadow of that object on the wall. That shadow, however, would alter shape and the edges would appear to flicker. A person in that cave facing the wall would not be able to see the true form of the object, only the shadows. However, by looking at those shadows it would be possible to get a good approximation of the shape of the actual object. That is the intent of the PRP, to process the data as so as to obtain a good approximation of the object in the real world that the data represents. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> The most general type of schema structure is called an Ontology. It provides a structure, frames containing slots, with inter-frame linkages, that is so general that it suffices to represent all the different varieties of metadata that have been found to be useful, and it can be extended to encompass new types of metadata. The Ontology provides the description of the data about the real world that, if available, represents the object of set or objects (1) about which data is collected and (2) queries made. In other words the Ontology can represent the database that describes the ideal description, the one that we would wish to obtain. The Ontology, because of its generality, can also describe the limitations that existed and constrain the completeness and accuracy and validity of the data that was actually collected in the real world. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> Therefore the Ontology is the means whereby we (1) organize the computer representations of information together with the representation of the presumed relationships that exist among elements of that information, and (2) applies and records corresponding measures of completeness and correctness of that information. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> The third step in the process is to generate new measures. The process is valuable because it is a means to generate &ldquo;fuzzy&rdquo; measures. The discipline of &ldquo;Fuzzy Sets&rdquo; and &ldquo;Fuzzy Logic&rdquo; has been well established for over 35 years; it is the mathematics that results from generalizing the binary function describing the membership relation of subsets of a set to a more general function. A binary relation is a mapping of an element &ldquo;a&rdquo; of a set &ldquo;A&rdquo; and a subset &ldquo;S&rdquo; of &ldquo;A&rdquo; to one of two numbers, &ldquo;1&rdquo; or &ldquo;0&rdquo; depending on whether &ldquo;a&rdquo; is said to be a member of the subset &ldquo;S&rdquo;. This mapping is called the membership function. When the mapping is not just to &ldquo;1&rdquo; or &ldquo;0&rdquo; but to numbers in between then the membership function is &ldquo;fuzzy&rdquo;. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> Fuzzy measures and the resulting fuzzy logic has been well accepted in the United States because of a linguistic prejudice against the word &ldquo;fuzzy&rdquo;. The mathematics, however, exists independent of linguistic conventions, and has been applied successfully to many industrial processes in Japan, where patents have been granted. In general the strength of the methods based on &ldquo;fuzzy logic&rdquo; is that they are used to create a simpler mathematical model of the control processes that need to be managed, which enable the creation of more efficient techniques for controlling the automatic operation of machinery. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> Although the usefulness and applicability of fuzzy mathematics is well demonstrated for nearly two decades, the extension of these methods to more general, non mechanistic problems has been halted by the difficult in setting forth general criteria by which to assign the measures to real world data. A similar problem exists in using probabilistic techniques that are called &ldquo;Bayesian&rdquo;. These require the generation of a large number of initial probability values that must be assigned to data, and the task of generating these probabilities has proved to be too complex for the technique to be useful to real problems, with the exception of the Computer Science discipline of Information Retrieval. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> The PRP, however, provides a mechanism for generating fuzzy measures. These are the &ldquo;new measures&rdquo; that provides a measure of a new category of information that summarizes the information available concisely. The latter summarization is what is done when fuzzy measures are applied in mechanical control systems. The process allows for two techniques to be applied, linguistic variable mapping and precision through abstraction. </paragraph>
<paragraph id="P-0016" lvl="2"><number>&lsqb;0016&rsqb;</number> 1. Linguistic variables are words assigned to ranges of data values. An example is the risk of an investment in a company&apos;s stock where the chance that you would make a 100% profit on your investment would be characterized by one of the words &ldquo;certainly, probably, plausibly, possibly, conceivably and inconceivably&rdquo;. </paragraph>
<paragraph id="P-0017" lvl="2"><number>&lsqb;0017&rsqb;</number> 2. Abstraction occurs when detail is omitted. If values for three variables are needed to describe an object, but only two are certain, one may define a new object that is described by just the two variables. For example to designate an area as a &ldquo;mountain&rdquo; one needs the height of the object, whereas a &ldquo;mountain range&rdquo; is a flat area on the map that has both mountains a non-mountainous areas. Lacking the height coordinate the latter more abstract term is appropriate. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> Using a-priori principles is one way of assigning the value of fuzzy measures. The PRP however, uses a more novel technique whereby the measures are induced by the data. There are several meanings for the word induction, but the one that is intended here is the one from electromagnetic theory. In this theory an electric charge moving through a conductor induces a magnetic field, and if another conductor is placed in the same field a current in the opposite direction. The data that is actually loaded into the database creates a series of objects which generate an description of those objects with respect to the description loaded in the Ontology. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> The foundation of this technique is the application of implicit functions. In mathematics a function is a table of values, like a relation, with some restrictions. Usually people describe functions &ldquo;intensionally&rdquo;, by a formula, especially if the formula has an infinite number of values like x*x&equals;y. An alternative is to describe functions &ldquo;extensionally&rdquo;, as a table where all values are explicitly recorded. Any given relational database can be described as a set of extensionally defined functions. These can in turn generate self-describing measures, of which one familiar example is quartiles (quartiles are four groupings of numerical values within a set of numbers from the lowest to the highest). By applying measures created by self-describing functions to the database it is possible to create fuzzy measures. These measures are then applied to the data in the database. The data and their fuzzy measurements enable the us of reasoning, the application of rules of the form &ldquo;If X then Y&rdquo; where the logical expressions X and Y contain terms that include the fuzzy measures.</paragraph>
</section>
</summary-of-invention>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION </heading>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> The PRP is realized by adding a set of processes, realized in software, into a system that performs reasoning on data. The PRP is the process of reasoning about the set-up of the data that will be used by process that reasons on exact data. Some basic processing functions are common to both types of reasoning, and so the software will share some programs in common. The baseline system components perform reasoning on exact data. As explained above, reasoning about a hypothesis using data in a database is the same thing as running a set of programs that perform a query on the database. That is because a hypothesis that can be validated or disproved on a data base has the form &ldquo;there exist data elements in the database form Y that match the description X&rdquo; can be proven by the query &ldquo;select all data from D that match the description X&rdquo;. If no such data exists the query returns no data and thereby disproves the hypothesis. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> The system will be shown in terms of a software Architecture diagram, one which identifies software components with special functions that interface with one another. The Architecture of the system is shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. It is a 3-tier architecture; the terms layer and tier will be used interchangeably. The first tier contains a user interface, a software client, that sends data to and receives it from software on the second tire, the middleware layer. At the bottom of the Figure, Tier <highlight><bold>3</bold></highlight>, are Database Management Systems (DBMSs) accessing databases containing the original information that the system must access. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> The baseline reasoning process without any PRP functions is simple. In the Client Tier there is a box that says &ldquo;Reasoning Chains and Filter Editor&rdquo; and one that says &ldquo;Display Results&rdquo;. The Reasoning Chain is the statement of the hypothesis to be proved, which may also be seen as a set of queries. There are no filters in this case. The results of the queries are displayed where indicated, if there is data to be displayed, and a &ldquo;no data found&rdquo; message is displayed otherwise. The software interacts along the path shown as the narrow, black think lines with triangular solid arrowheads. Note that the PRP Plug-In is bypassed and the SQL 3 Engine is directly accessed. The Object-Relational Database Management System is a standard middleware software Commercial Off the Shelf (COTS) software component, used to overcome formatting differences among the different data sources. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> The description in <cross-reference target="DRAWINGS">FIG. 1</cross-reference> covers the case where the PRP is used. </paragraph>
<paragraph id="P-0024" lvl="7"><number>&lsqb;0024&rsqb;</number> Tier <highlight><bold>1</bold></highlight> </paragraph>
<paragraph id="P-0025" lvl="2"><number>&lsqb;0025&rsqb;</number> 1. The Ontology Editor is the interface to the Ontology Builder (an example is available at the Knowledge Sharing Laboratory, www-ksl.stanford.edu at Stanford University). An Ontology is a general representation format for systems that represent knowledge about data items and their inter-relationships, including the various elements of metadata that describe the data. When an instance of an Ontology is built it will contain descriptions of (1) the ideal collection of descriptive data, (2) the data that is actually available, (3) transformations that are admissible between the two formats, (4) functions used to filter data that will be transformed, and screens that support the generation of new measures and objects that are the result of the PRP. This interface supports the first part of the PRP: it organizes computer representations of information together with the representation of the presumed relationships that exist among elements of that information. </paragraph>
<paragraph id="P-0026" lvl="2"><number>&lsqb;0026&rsqb;</number> 2. The Results Display Engine is an interface to COTS products on the client platform that are used to view the results of performing reasoning using the PRP. </paragraph>
<paragraph id="P-0027" lvl="2"><number>&lsqb;0027&rsqb;</number> 3. The User Interface for Reasoning Chains: This user interface is to two things, build the hypothesis and its associated reasoning chain (or query sets) and assign uncertainty management conditions. This supports the first half of the second part of the PRP: it records the measures of correctness corresponding of the information that will be used. It also feeds rules to any reasoning engine that may be needed to enhance the functionality of the Object Relational Database. </paragraph>
<paragraph id="P-0028" lvl="2"><number>&lsqb;0028&rsqb;</number> 4. The Screens Editor is the interface to the Ontology builder that is used to support the second half of the second part of the PRP: record the measures of completeness corresponding to the information that will be used. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> In addition there are system administrators who need interface with the system through COTS product interfaces. These are: </paragraph>
<paragraph id="P-0030" lvl="2"><number>&lsqb;0030&rsqb;</number> 5. The Command Center: The Object Relational Database&apos;s Interface </paragraph>
<paragraph id="P-0031" lvl="2"><number>&lsqb;0031&rsqb;</number> 6. Math Function Editor: This is an environment for building programs that are compiled and inserted into an executable program library for use in the Object Relational database by the PRP. </paragraph>
<paragraph id="P-0032" lvl="7"><number>&lsqb;0032&rsqb;</number> Tier <highlight><bold>2</bold></highlight>, the Middleware </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> Middleware is used to assemble data from multiple data sources, shown as databases in Tier <highlight><bold>3</bold></highlight>. The following components constitute the middleware: </paragraph>
<paragraph id="P-0034" lvl="2"><number>&lsqb;0034&rsqb;</number> 1. Object Relational Database: the Object-Relational database management system (ORDBMS) that is a general-purpose data management system that contains the ability to store relational data and other types of data. Although many of its functions could be managed purely be a relational database doing so would make for more complex application programs that access and use that data. In the diagram it will build databases of filters and screens because any person using the PRP will run a problem, decide on some changes and want to store the prior working assumptions in a database for reuse. </paragraph>
<paragraph id="P-0035" lvl="2"><number>&lsqb;0035&rsqb;</number> 2. The Reasoning Engine: the Reasoning Engine executes rules that impact both the Ontology and the data in the results database. It is likely to be part of the ORDBMS, but is shown separately just in case a more powerful reasoning system is required. </paragraph>
<paragraph id="P-0036" lvl="2"><number>&lsqb;0036&rsqb;</number> 3. PRP Application Server: the activities of the client user interfaces is coordinated by this application. It will interface with the ORDBMS to load screen and filters, and initiate the access to raw data and initiate the use of rule sets in order to generate results. This is the third part of the PRP: it generates a new, novel and useful measure that provides a useful new description of the information available that summarizes it concisely. </paragraph>
<paragraph id="P-0037" lvl="7"><number>&lsqb;0037&rsqb;</number> Tier <highlight><bold>3</bold></highlight> </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> This is the data that is input to the system. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> Refining Hypotheses is the term used describe the user&apos;s activity of interacting with the data as follows: </paragraph>
<paragraph id="P-0040" lvl="2"><number>&lsqb;0040&rsqb;</number> 1. The user come to the database with an initial hypothesis which he/she wants to validate using the data in the database. </paragraph>
<paragraph id="P-0041" lvl="2"><number>&lsqb;0041&rsqb;</number> 2. The user examines the data and comes up with a chain of reasoning, a set of steps during which the data in the database will be accessed, transformed, intermediate results created and finally a result generated. </paragraph>
<paragraph id="P-0042" lvl="2"><number>&lsqb;0042&rsqb;</number> 3. The results are examined and the process is repeated with either a reformulated hypothesis, a change in the scope and/or transformations of the data that is to be examined or both. The new results are examined. </paragraph>
<paragraph id="P-0043" lvl="2"><number>&lsqb;0043&rsqb;</number> 4. The process is repeated until the user is satisfied. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> This interaction can be done with or without using the PRP. The PRP provides a more powerful way for the user to use the data available </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> We assume that the user is familiar with the specialized field of inquiry to which the data in the database is relevant. That means specifically that due to the user&apos;s personal training and experience he/she knows what types of hypotheses may be propounded and validated with the data. For purposes of illustration we assume that the user is processing data to assess data describing the current situation in which it is suspected their may be a threat to resources, e.g. business, medical, or military assets. The data in the database may admit to multiple interpretations. Each can be formulated as an initial decision hypothesis: as follows: : &ldquo;the current situation X poses a threat to my resources Y at Z&rdquo;. After the data is analyzed one of the following may be inferred: </paragraph>
<paragraph id="P-0046" lvl="2"><number>&lsqb;0046&rsqb;</number> 1. Contradiction: &ldquo;the current situation X does not pose a threat to my resources Y at Z&rdquo;</paragraph>
<paragraph id="P-0047" lvl="2"><number>&lsqb;0047&rsqb;</number> 2. Alternatives: &ldquo;the current situation X poses a threat to my resources Y at W&rdquo; OR &ldquo;the current situation X poses a threat to my resources Y&prime; at Z&rdquo;</paragraph>
<paragraph id="P-0048" lvl="2"><number>&lsqb;0048&rsqb;</number> 3. Ambiguity: &ldquo;the current situation cannot be assessed with sufficient certainty to support any hypothesis&rdquo;. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> To use the data in the computer the hypothesis must be formulated in a specific manner. Because R. Reiter proved in 1984 that a query to a relational database was mathematically equivalent to a proof that the data supported a hypothesis the form of the hypothesis can be that of a query. The conversion from the verbal human statement to the computer format of the hypothesis is a two step process (the notation&mdash;backwards E means &ldquo;there exists&rdquo; and inverted A means &ldquo;for all&rdquo;): </paragraph>
<paragraph id="P-0050" lvl="2"><number>&lsqb;0050&rsqb;</number> 1. Expand the Meanings: </paragraph>
<paragraph id="P-0051" lvl="3"><number>&lsqb;0051&rsqb;</number> (&exist;(a,b,c . . . ) with relationships r<highlight><subscript>1</subscript></highlight>, r<highlight><subscript>2</subscript></highlight>, . . . )whenever situation X exists. </paragraph>
<paragraph id="P-0052" lvl="3"><number>&lsqb;0052&rsqb;</number> (&forall;(a,b,c . . . ) with relationships S<highlight><subscript>1</subscript></highlight>,s<highlight><subscript>2</subscript></highlight>, . . . ) define the my resources Y. </paragraph>
<paragraph id="P-0053" lvl="3"><number>&lsqb;0053&rsqb;</number> The area Z is defined by criteria (A,B,C, . . . ) </paragraph>
<paragraph id="P-0054" lvl="2"><number>&lsqb;0054&rsqb;</number> 2. Restate the verbal hypothesis as a query: &ldquo;the evidence available in the database shows X, Y exist and Y meets criteria (A,B,C,. . . )&rdquo;. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> The word used in step <highlight><bold>2</bold></highlight>, however, was not &ldquo;data&rdquo; but &ldquo;evidence&rdquo;. Once the conversion is made, the evidence will either (1) support the assumptions of a decision hypothesis H<highlight><subscript>1 </subscript></highlight>or (2) contradict it by supporting its contradiction H<highlight><subscript>1</subscript></highlight><highlight><superscript>C</superscript></highlight>, or (3) not be relevant at all. Data is not necessarily evidence, and a method of relevance determination is provided to convert the stream of data to evidence. One of its actions is to defined exactly when redundant data is present. Such data need not be considered (eliminating redundant data solves the info-glut problem). This is one of the explicit PRP process steps, converting data to evidence by building screens. The useful advantage of this step potentially reduces the massive volume of data (also known as &ldquo;infoglut&rdquo;) and makes both the reasoning process and results more amenable to being effectively reviewed by a human. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> Returning to the point about alternative hypotheses: whenever evidence is not relevant to one hypothesis about a situation it might be relevant to another. Thus this step of looking at alternative hypotheses can be applied to situations where multiple explanations for data are possible. A user may start out with one hypothesis, and monitor the situation, looking for new evidence that suggests that an initial hypothesis is now negated. This means that when the OPRP is used for monitoring it provides a useful advantage as all the plausible hypotheses by be compared against the evidence compared. </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 2</cross-reference> we see that Hypothesis<highlight><subscript>1 </subscript></highlight>predicts two negative events and three positive ones, but has 4 events unaccounted for. The others have different coverage. Under the circumstances Hypothesis<highlight><subscript>2 </subscript></highlight>is the best. The goal of the step in the PRP is to enable such a comparison. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> The process steps are: </paragraph>
<paragraph id="P-0059" lvl="2"><number>&lsqb;0059&rsqb;</number> 1. Initialize problem space: specify </paragraph>
<paragraph id="P-0060" lvl="3"><number>&lsqb;0060&rsqb;</number> Decision: a hypothesis OR a set of hypotheses. </paragraph>
<paragraph id="P-0061" lvl="3"><number>&lsqb;0061&rsqb;</number> Data sources, objects, algorithms etc. </paragraph>
<paragraph id="P-0062" lvl="2"><number>&lsqb;0062&rsqb;</number> 2. Generate missing data </paragraph>
<paragraph id="P-0063" lvl="2"><number>&lsqb;0063&rsqb;</number> 3. Establish the Chain of Reasoning: data transformations needed to gather the data neededd to test the hypothesis or hypotheses. </paragraph>
<paragraph id="P-0064" lvl="2"><number>&lsqb;0064&rsqb;</number> 4. Set thresholds of uncertainty for valid data. </paragraph>
<paragraph id="P-0065" lvl="2"><number>&lsqb;0065&rsqb;</number> 5. Create screens to convert data to evidential objects. </paragraph>
<paragraph id="P-0066" lvl="2"><number>&lsqb;0066&rsqb;</number> 6. Run hypotheses verification &amp; compare results. </paragraph>
<paragraph id="P-0067" lvl="2"><number>&lsqb;0067&rsqb;</number> 7. Adjust the abstraction level to encompass evidence. </paragraph>
<paragraph id="P-0068" lvl="2"><number>&lsqb;0068&rsqb;</number> 8. Potentially Perform Data Mining to improve results. </paragraph>
<paragraph id="P-0069" lvl="0"><number>&lsqb;0069&rsqb;</number> The first step is to state the subjective decision hypothesis or a set of competing hypotheses as a query. This means reformulating each hypotheses as a logical combination of one or more statements of the form: </paragraph>
<paragraph id="P-0070" lvl="2"><number>&lsqb;0070&rsqb;</number> &ldquo;There exist objects whose properties &lcub;P<highlight><subscript>i</subscript></highlight>&rcub; have value ranges &lcub;R<highlight><subscript>i</subscript></highlight>&rcub;&rdquo;</paragraph>
<paragraph id="P-0071" lvl="2"><number>&lsqb;0071&rsqb;</number> &ldquo;All objects of type X have properties &lcub;P<highlight><subscript>i</subscript></highlight>&rcub; within value ranges &lcub;R<highlight><subscript>i</subscript></highlight>&rcub;.&rdquo;</paragraph>
<paragraph id="P-0072" lvl="7"><number>&lsqb;0072&rsqb;</number> In logic these are the generalizations of statements containing &ldquo;OR&rdquo; conditions and &ldquo;AND&rdquo; conditions. </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> The second step is to use the Ontology editor to describe the </paragraph>
<paragraph id="P-0074" lvl="2"><number>&lsqb;0074&rsqb;</number> 1. Data Sources: form and constraints for all levels of available data inputs, and the </paragraph>
<paragraph id="P-0075" lvl="2"><number>&lsqb;0075&rsqb;</number> 2. Objects: complete description of all properties of objects that are detectable, of sensors, and abstract concepts (Ontology). This includes screen objects described below Further one should specify any additional </paragraph>
<paragraph id="P-0076" lvl="2"><number>&lsqb;0076&rsqb;</number> 3. algorithms, i.e. any new techniques embodied in programs that must be added to the PRP to enable filtering of data or eliminating uncertainty. This includes filter algorithms and thresholds described below. </paragraph>
<paragraph id="P-0077" lvl="7"><number>&lsqb;0077&rsqb;</number> These may be submitted also as input to the object relational database management system as needed. </paragraph>
<paragraph id="P-0078" lvl="0"><number>&lsqb;0078&rsqb;</number> Missing Data is generated after a subjective judgement by the PRP user. It may occur as an initial step, or during re-iteration of previous steps. Some sources </paragraph>
<paragraph id="P-0079" lvl="2"><number>&lsqb;0079&rsqb;</number> Projection of prior data about objects no longer visible, </paragraph>
<paragraph id="P-0080" lvl="2"><number>&lsqb;0080&rsqb;</number> Assumptions based on knowledge of enemy doctrine, or </paragraph>
<paragraph id="P-0081" lvl="2"><number>&lsqb;0081&rsqb;</number> Simulated data based on the data at hand. </paragraph>
<paragraph id="P-0082" lvl="7"><number>&lsqb;0082&rsqb;</number> Multiple hypotheses may reflect multiple guesses at the missing data and its values. This data will be necessary for making projections when not all of the area with possible data is observed. </paragraph>
<paragraph id="P-0083" lvl="0"><number>&lsqb;0083&rsqb;</number> Every data manipulation is the formal equivalent of reasoning step, so the total is called the Chain of Reasoning. The Chain of Reasoning is therefore the set of transformations from the raw data to the data used in the query based solely upon the meaning and form of the data. This is the set of steps that one uses to go from the data to the hypothesis. It is the data upon which the query representing that hypothesis is run. The Ontology will contain precise descriptions of all the data formats needed, and as needed these will be loaded into the ORDBMS. </paragraph>
<paragraph id="P-0084" lvl="0"><number>&lsqb;0084&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a visualization of four sources of data that will be used to generate the Final View, data used to test the hypothesis. Source <highlight><bold>1</bold></highlight> is input to other data streams and is therefore some standard immutable description like a terrain map. Other processing steps combine or fuse data from the different sources to make intermediate data sets. The &ldquo;F&rdquo; symbol stand for filtering action described below. </paragraph>
<paragraph id="P-0085" lvl="0"><number>&lsqb;0085&rsqb;</number> The chain of reasoning must be constructed with the knowledge that not all of the data is equally valid. Whenever tests can be devised to eliminate data that is too questionable for use they will be incorporated as a filter. The filter admits some data and excludes other data. To use one, however, a threshold value must be set. That is the user&apos;s tolerance for data uncertainty. In the PRP this sub-process is explicit and may be reset to a different value if the hypotheses need to be looked at a later time with a different tolerance for uncertainty. Specifically, although traditional Pascalian Probability measures can be used, as well as Baconian Probability Measures, explained below, fuzzy measures can be used as well, these can take the form of explicit assignments of values, or the values may be inferred from the Pascalian and Baconian measures, a KEY feature of the PRP. </paragraph>
<paragraph id="P-0086" lvl="0"><number>&lsqb;0086&rsqb;</number> Baconian Probability is not as well known as Pascalian Probability, although de-facto it is the basis of scientific induction and is used extensively albeit informally. Let B(H) be the monadic (i.e. True of False) Baconian Probability of a hypothesis H and B(H,E) the dyadic conditional probability of H given E; then these are the formal mathematical properties &lsqb;Schum, The Evidential Foundations of Probabilistic Reasoning, pp254-255&rsqb;: </paragraph>
<paragraph id="P-0087" lvl="2"><number>&lsqb;0087&rsqb;</number> (1) Ordinal Property: </paragraph>
<paragraph id="P-0088" lvl="3"><number>&lsqb;0088&rsqb;</number> monadic case: B(H<highlight><subscript>1</subscript></highlight>)&gE;B(H<highlight><subscript>2</subscript></highlight>) or B(H<highlight><subscript>2</subscript></highlight>)&gE;B(H<highlight><subscript>1</subscript></highlight>) </paragraph>
<paragraph id="P-0089" lvl="3"><number>&lsqb;0089&rsqb;</number> dyadic case: B(H<highlight><subscript>1</subscript></highlight>,E<highlight><subscript>1</subscript></highlight>*)&gE;B(H<highlight><subscript>2</subscript></highlight>, E<highlight><subscript>2</subscript></highlight>*) or B(H<highlight><subscript>2</subscript></highlight>, E<highlight><subscript>2</subscript></highlight>*)&gE;B(H<highlight><subscript>1</subscript></highlight>,E<highlight><subscript>1</subscript></highlight>*) </paragraph>
<paragraph id="P-0090" lvl="2"><number>&lsqb;0090&rsqb;</number> (2) Negation Property: </paragraph>
<paragraph id="P-0091" lvl="3"><number>&lsqb;0091&rsqb;</number> monadic case IF B(H)&gt;0 then B(&tilde;H)&equals;0 </paragraph>
<paragraph id="P-0092" lvl="3"><number>&lsqb;0092&rsqb;</number> dyadic case: IF B(H,E*)&gt;0 then if B(&tilde;E*)&equals;0, then B(&tilde;H,E*)&equals;0 </paragraph>
<paragraph id="P-0093" lvl="2"><number>&lsqb;0093&rsqb;</number> (3) Conjunction Rule: </paragraph>
<paragraph id="P-0094" lvl="3"><number>&lsqb;0094&rsqb;</number> monadic case: IF B(H<highlight><subscript>1</subscript></highlight>)&gE;B(H<highlight><subscript>2</subscript></highlight>) THEN B(H<highlight><subscript>1</subscript></highlight>&xcirc;H<highlight><subscript>2</subscript></highlight>)&equals;B(H<highlight><subscript>2</subscript></highlight>) </paragraph>
<paragraph id="P-0095" lvl="3"><number>&lsqb;0095&rsqb;</number> dyadic case: IF B(H<highlight><subscript>1</subscript></highlight>,E*)&gE;B(H<highlight><subscript>2</subscript></highlight>,E*) THEN B(H<highlight><subscript>1</subscript></highlight>&xcirc;H<highlight><subscript>2</subscript></highlight>,E*)&equals;B(H<highlight><subscript>2</subscript></highlight>,E*) </paragraph>
<paragraph id="P-0096" lvl="2"><number>&lsqb;0096&rsqb;</number> (4) Disjunction Rule: </paragraph>
<paragraph id="P-0097" lvl="3"><number>&lsqb;0097&rsqb;</number> monadic case: IF B(H<highlight><subscript>1</subscript></highlight>)&gE;B(H<highlight><subscript>2</subscript></highlight>) THEN B(H<highlight><subscript>1</subscript></highlight>&xcirc;H<highlight><subscript>2</subscript></highlight>)&equals;B(H<highlight><subscript>1</subscript></highlight>) </paragraph>
<paragraph id="P-0098" lvl="3"><number>&lsqb;0098&rsqb;</number> dyadic case: IF B(H<highlight><subscript>1</subscript></highlight>,E*)&gE;B(H<highlight><subscript>2</subscript></highlight>,E*) THEN B(H<highlight><subscript>1</subscript></highlight>&xcirc;H<highlight><subscript>2</subscript></highlight>,E*)&equals;B(H<highlight><subscript>1</subscript></highlight>,E*) </paragraph>
<paragraph id="P-0099" lvl="2"><number>&lsqb;0099&rsqb;</number> (5) Contraposition: </paragraph>
<paragraph id="P-0100" lvl="3"><number>&lsqb;0100&rsqb;</number> dyadic case: B(H,E*)&equals;B(&tilde;E*,&tilde;H) </paragraph>
<paragraph id="P-0101" lvl="0"><number>&lsqb;0101&rsqb;</number> The system has been of great interest to the many people who have become aware of it, but heretofore no practitioners have seen a way to interpret it to be applicable to real-world situations. The PRP provides this assignment by a novel mechanism. </paragraph>
<paragraph id="P-0102" lvl="0"><number>&lsqb;0102&rsqb;</number> The Baconian probability associated with an object is determined by (1) the object observed, (2) the question asked of it and (3) the number of tests of values of relevant variables. The innovation is to applying the probability to all terms or slots of the Ontological description of the object, not just the static attributes. For example, a jeep may have 25 possible data values or properties that describe it, but only six of them are needed for identification. Let the hypothesis H be that object X is a jeep. Suppose the data contains <highlight><bold>4</bold></highlight> relations each of which of six variables, and together they encompass 12 terms of the 25, but also together they account for only 5 of the 6 identifying attributes. Then the Baconian probability of the (H)&equals;<highlight><bold>5</bold></highlight>. This corresponds to the data passing five out of six possible Baconian existence tests on the different identifying property. </paragraph>
<paragraph id="P-0103" lvl="0"><number>&lsqb;0103&rsqb;</number> This process is totally new and is a major invention within the PRP. The problem is relevance of data and the value of having multiple instances of the &ldquo;same&rdquo; data. This must be addressed because future technology will enable better, more accurate, and more numerous data to be collected. The challenge is how then to use them without being overwhelmed&quest; The step is the conversion of data to evidence. </paragraph>
<paragraph id="P-0104" lvl="0"><number>&lsqb;0104&rsqb;</number> The key step is to provide a precise description of the distinctions made in the discipline of Evidential Reasoning. Let H<highlight><subscript>1 </subscript></highlight>be the decision hypothesis, and D<highlight><subscript>1 </subscript></highlight>a datum that supports it. If D<highlight><subscript>1 </subscript></highlight>supports a decision hypothesis H<highlight><subscript>1 </subscript></highlight>does the next datum D<highlight><subscript>2 </subscript></highlight>support the hypothesis more, less, the same&quest; Is it relevant at all&quest; In Evidential Reasoning the following definitions are provided: </paragraph>
<paragraph id="P-0105" lvl="2"><number>&lsqb;0105&rsqb;</number> Directly Relevant Data: data that is used to infer the decision hypothesis H. </paragraph>
<paragraph id="P-0106" lvl="2"><number>&lsqb;0106&rsqb;</number> Corroborating Data: data that strengthens the decision hypothesis H. </paragraph>
<paragraph id="P-0107" lvl="2"><number>&lsqb;0107&rsqb;</number> Redundant Data: data that duplicates what is already known about H. </paragraph>
<paragraph id="P-0108" lvl="2"><number>&lsqb;0108&rsqb;</number> Contradictory Data: data that supports the negation of H. </paragraph>
<paragraph id="P-0109" lvl="2"><number>&lsqb;0109&rsqb;</number> Conflicting Data: data either confirms or negates H<highlight><subscript>i </subscript></highlight>but does so for H<highlight><subscript>j</subscript></highlight>. </paragraph>
<paragraph id="P-0110" lvl="0"><number>&lsqb;0110&rsqb;</number> Using the PRP technology the user: </paragraph>
<paragraph id="P-0111" lvl="2"><number>&lsqb;0111&rsqb;</number> 1. enables the system to use relevant data as direct evidence, </paragraph>
<paragraph id="P-0112" lvl="2"><number>&lsqb;0112&rsqb;</number> 2. fuses corroborating data, </paragraph>
<paragraph id="P-0113" lvl="2"><number>&lsqb;0113&rsqb;</number> 3. screens out redundant data relevant to the competing hypotheses H<highlight><subscript>j </subscript></highlight>and their contradictions&tilde;H<highlight><subscript>j </subscript></highlight>or H<highlight><subscript>j</subscript></highlight><highlight><superscript>C</superscript></highlight>, and </paragraph>
<paragraph id="P-0114" lvl="2"><number>&lsqb;0114&rsqb;</number> 4. assigns conflicting data to the same process steps for competing hypotheses. </paragraph>
<paragraph id="P-0115" lvl="0"><number>&lsqb;0115&rsqb;</number> This is made possible by the use of the Ontology. </paragraph>
<paragraph id="P-0116" lvl="0"><number>&lsqb;0116&rsqb;</number> Hypothesis comparison requires defining the above terms precisely, and relating them to multiple hypothesis comparison. First the PRP user creates an Ontology for all objects &lcub;X<highlight><subscript>1</subscript></highlight>, . . . X<highlight><subscript>M</subscript></highlight>&rcub;, i.e. a complete logical description of the terms (a.k.a &ldquo;slots) for each object i.e. properties (attributes), functions, relations and axioms. Let object X have terms (t<highlight><subscript>1</subscript></highlight>, t<highlight><subscript>2</subscript></highlight>, t<highlight><subscript>3</subscript></highlight>, . . . ) that may be any of the types of slots mentioned. A given object may be identifiable, however, by a subset of those terms, and there may be more than one such subset. For object X<highlight><subscript>i </subscript></highlight>let the subsets of identifying terms be IT<highlight><subscript>i1</subscript></highlight>, IT<highlight><subscript>i2</subscript></highlight>, IT<highlight><subscript>i3</subscript></highlight>, . . . IT<highlight><subscript>iM </subscript></highlight>and let IT<highlight><subscript>i </subscript></highlight>be the set of these subsets. Note that if XT<highlight><subscript>i </subscript></highlight>is the set of all X<highlight><subscript>i</subscript></highlight>&apos;s terms, and <highlight><bold>2</bold></highlight><highlight><superscript>XTi </superscript></highlight>is its power set ,the set of all subsets, then the set of sets of identifying terms IT<highlight><subscript>i</subscript></highlight><highlight><uline>&sub;</uline></highlight>2<highlight><superscript>XTi</superscript></highlight>. </paragraph>
<paragraph id="P-0117" lvl="0"><number>&lsqb;0117&rsqb;</number> Then consider a set &lcub;d<highlight><subscript>0</subscript></highlight>, . . . d<highlight><subscript>n</subscript></highlight>&rcub; of data items that establish that an instance of object X<highlight><subscript>i </subscript></highlight>has been observed. The first one d<highlight><subscript>0 </subscript></highlight>establishes that X<highlight><subscript>i </subscript></highlight>exists. This means that values for the instance of X<highlight><subscript>i </subscript></highlight>may be filled in for it&apos;s property values, function and relation values, and the designation that certain axioms have been shown to apply. Then the rest of the elements of the set d<highlight><subscript>1</subscript></highlight>. . . d<highlight><subscript>n </subscript></highlight>that also establish it are split into two subsets, the corroborating evidence &lcub;c<highlight><subscript>1</subscript></highlight>, . . . c<highlight><subscript>n1</subscript></highlight>&rcub; and redundant evidence &lcub;r<highlight><subscript>1</subscript></highlight>, . . . r<highlight><subscript>n2</subscript></highlight>&rcub;. The distinction is that dj is redundant unless it provides a value for a term that d<highlight><subscript>0 </subscript></highlight>did not. Corroborating data is data that adds information about the object X<highlight><subscript>i</subscript></highlight>. Although it does not change the evidence that X<highlight><subscript>i </subscript></highlight>exists the new term values may be useful to subsequent queries that access the database. Otherwise, as they add no information, they are redundant. Formally: </paragraph>
<paragraph id="P-0118" lvl="2"><number>&lsqb;0118&rsqb;</number> Let d<highlight><subscript>1 </subscript></highlight>and d<highlight><subscript>2 </subscript></highlight>be relational data that consists of attributes (t<highlight><subscript>11</subscript></highlight>, t<highlight><subscript>12</subscript></highlight>, . . . t<highlight><subscript>1n</subscript></highlight>) and (t<highlight><subscript>21</subscript></highlight>, t<highlight><subscript>22</subscript></highlight>, . . . t<highlight><subscript>2m</subscript></highlight>) respectively. </paragraph>
<paragraph id="P-0119" lvl="2"><number>&lsqb;0119&rsqb;</number> Let d<highlight><subscript>1 </subscript></highlight>directly identify object X<highlight><subscript>i</subscript></highlight>: it provides values for the subset of terms IT<highlight><subscript>i1</subscript></highlight>, that is an element of IT<highlight><subscript>i</subscript></highlight>. Then d<highlight><subscript>2 </subscript></highlight>is: </paragraph>
<paragraph id="P-0120" lvl="3"><number>&lsqb;0120&rsqb;</number> Redundant if it confirms the values of IT<highlight><subscript>i1</subscript></highlight>, </paragraph>
<paragraph id="P-0121" lvl="3"><number>&lsqb;0121&rsqb;</number> Corroborative is it confirms values using IT<highlight><subscript>i2</subscript></highlight>&ne;IT<highlight><subscript>i1</subscript></highlight>, </paragraph>
<paragraph id="P-0122" lvl="3"><number>&lsqb;0122&rsqb;</number> Contradictory if it does not have all the values of one of the IT<highlight><subscript>i </subscript></highlight>elements, and </paragraph>
<paragraph id="P-0123" lvl="3"><number>&lsqb;0123&rsqb;</number> Conflicting if it identifies elements IT<highlight><subscript>j1 </subscript></highlight>of another object X<highlight><subscript>j </subscript></highlight>at the same time and place as X<highlight><subscript>i</subscript></highlight>. </paragraph>
<paragraph id="P-0124" lvl="0"><number>&lsqb;0124&rsqb;</number> The above technique of identifying IT<highlight><subscript>i </subscript></highlight>is called creating and using a screen. One advantage is that it reduces the data glut to a manageable flow of information. It also separates out what data accrues to what decision hypothesis about the existence of an object. Sensor fusion is now also easy to define. Every sensor is modeled as an object as well with its own Ontology. There is a line of reasoning from the output of that sensor to terms in the Ontologies of the objects that it identifies. In IT<highlight><subscript>1 </subscript></highlight>the infrared detector will see that the hood of a jeep is bright, meaning the jeep is operational. The logic of this association is stored in the Ontology. The fusion is done at the ontological level. The screen is now illustrated in detail in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>. </paragraph>
<paragraph id="P-0125" lvl="0"><number>&lsqb;0125&rsqb;</number> Continuing the example, a jeep may have an ontology entry yielding a set S of 25 properties, of which any of 4 subsets S<highlight><subscript>1</subscript></highlight>, S<highlight><subscript>2</subscript></highlight>, S<highlight><subscript>3 </subscript></highlight>or S<highlight><subscript>4 </subscript></highlight>of 6 properties might identify it (the IT<highlight><subscript>ij</subscript></highlight>&apos;s). These are sensor-identification objects (SIO) (new&excl;). Then if filtered data item d<highlight><subscript>1 </subscript></highlight>identifies X<highlight><subscript>1 </subscript></highlight>according to S<highlight><subscript>2 </subscript></highlight>we have an identification object (IDO) (new&excl;). The value d, becomes direct evidence of the existence of X<highlight><subscript>1</subscript></highlight>, and S<highlight><subscript>2 </subscript></highlight>together with any additional sensed properties becomes the identification object (new process&excl;). Then when data item d<highlight><subscript>i </subscript></highlight>is detected it is redundant if it uses S<highlight><subscript>2 </subscript></highlight>and corroborative otherwise, say using S<highlight><subscript>3</subscript></highlight>, as is datum d<highlight><subscript>17 </subscript></highlight>in <cross-reference target="DRAWINGS">FIG. 8</cross-reference>. Adding this information updates the IDO. The IDO is the screen (new concept) with the properties in S<highlight><subscript>2 </subscript></highlight>&xcirc;S<highlight><subscript>4 </subscript></highlight>together with all other properties of d<highlight><subscript>1 </subscript></highlight>and d<highlight><subscript>17</subscript></highlight>. The screen eliminates infoglut because once enough observations are made to establish all 25 properties, then, as long as these values hold all additional data with the same values is redundant and not considered for decision making purposes: its not relevant. The IDO contains a binary array that tells which of the properties in the Ontology is present and which not by a 0/1 coding. This is used for probability filtering. </paragraph>
<paragraph id="P-0126" lvl="0"><number>&lsqb;0126&rsqb;</number> This is shown in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>. Evidence of the existence of an object and its lack of existence are both results of evidential reasoning. Evidence that exists but cannot be assigned to objects is unassigned. No hypothesis accounts for it. It can either be rejected as outlier data, or erroneous data or a new more expansive hypothesis can be generated that accounts for it. </paragraph>
<paragraph id="P-0127" lvl="0"><number>&lsqb;0127&rsqb;</number> The term of &ldquo;abstraction&rdquo; has been used in computer science in a number of sub-disciplines for some time. In this context it refers to the amount of detail that is provided for objects. A jeep categorized differently from other objects in that it is a vehicle that is (1) small, (2) motorized, (3) open, and is (4) all-wheel drive. The evidence may be insufficient to identify the jeep from a small convertible, but for purposes of supporting one or more the decision support hypotheses it may be sufficient to use only properties (1) and (2). In exact terms this means that a more abstract object, &ldquo;small motorized vehicle&rdquo; exists and a jeep is also an instance of it. The Ontology shows all such classes and allows queries to be made at any level of abstraction. If this is done, then more evidence may &ldquo;come in from the cold&rdquo; and be associated with the hypotheses with striking results, as shown in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>. </paragraph>
<paragraph id="P-0128" lvl="0"><number>&lsqb;0128&rsqb;</number> This is shown in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>. Evidence of the existence of an object and its lack of existence are both results of evidential reasoning. Evidence that exists but cannot be assigned to objects is unassigned. No hypothesis accounts for it. It can either be rejected as outlier data, or erroneous data or a new more expansive hypothesis can be generated that accounts for it. </paragraph>
<paragraph id="P-0129" lvl="0"><number>&lsqb;0129&rsqb;</number> The PRP also allows an alternative use of fuzzy logic. Whereas it is possible to assign a measure to a data that provides an ordinal scale mapping to values like &ldquo;certainly, Probably, etc.&rdquo; a novel technique of applying measures results in an exact abstraction with a name that incorporates the fuzziness. The evidence on hand is describes exactly, and the fuzziness is refected in the name of the object created&mdash;it is not as exact as one would wish to have, but it summarizes precisely what is known. </paragraph>
<paragraph id="P-0130" lvl="0"><number>&lsqb;0130&rsqb;</number> The term of &ldquo;abstraction&rdquo; has been used in computer science in a number of sub-disciplines for some time. In this context it refers to the amount of detail that is provided for objects. A jeep categorized differently from other objects in that it is a vehicle that is (1) small, (2) motorized, (3) open, and is (4) all-wheel drive. The evidence may be insufficient to identify the jeep from a small convertible, but for purposes of supporting one or more the decision support hypotheses it may be sufficient to use only properties (1) and (2). In exact terms this means that a more abstract object, &ldquo;small motorized vehicle&rdquo; exists and a jeep is also an instance of it. The Ontology shows all such classes and allows queries to be made at any level of abstraction. If this is done, then more evidence may &ldquo;come in from the cold&rdquo; and be associated with the hypotheses with striking results, as shown in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>. </paragraph>
<paragraph id="P-0131" lvl="0"><number>&lsqb;0131&rsqb;</number> Sensor data coming into the system is directly mappable to a set of DIDs&mdash;data ID arrays. Each sensor has its own particular types of data that it gathers in its spectrum, and some sensors may output interpretations of what has been observed. This means that there are a number of different types of attributes that can be found. Let the input be a X-coordinate, a Y-coordinate and three values V<highlight><subscript>1 </subscript></highlight>through V<highlight><subscript>3</subscript></highlight>. These are then put in the &ldquo;dimensional baskets&rdquo;, as shown in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>. </paragraph>
<paragraph id="P-0132" lvl="0"><number>&lsqb;0132&rsqb;</number> The input needs then to be connected with the type of decision that must be made. The objects that may be present are represented in the Ontology. The Ontology provides ranges that the variables V<highlight><subscript>1 </subscript></highlight>though V<highlight><subscript>3 </subscript></highlight>may have and be consistent with the presence of the particular object that is being defined. This is shown for Object <highlight><bold>1</bold></highlight> of three possible objects in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>. This will result in three different ranges for the variables V<highlight><subscript>1 </subscript></highlight>to V<highlight><subscript>3 </subscript></highlight>depending on what object they identify (e.g. truck, jeep, tank). This means that the table of grouped data can be pivoted. In <cross-reference target="DRAWINGS">FIG. 7</cross-reference> we see it graphically. </paragraph>
<paragraph id="P-0133" lvl="0"><number>&lsqb;0133&rsqb;</number> This becomes a table upon which a clustering process of association (e.g. data mining) can proceed: groups of data values for different objects in the same 2,3 or 4-dimensional area will be compared to see to what objects they correspond. The value of this approach is that it works hand in glove with the abstraction technique. The pivoted table provides a summary of all of the input data, transformed into evidence. It is then possible to dynamically adjust the level of abstraction to take advantage of what data exists. However, even when inadequate data is present this can be useful. </paragraph>
<paragraph id="P-0134" lvl="0"><number>&lsqb;0134&rsqb;</number> The level of abstraction of data available &ldquo;small vehicle&rdquo; may lack sufficient detail, i.e. is it motorized or not to be useful directly. However, the filtering mechanism may be invoked here as well. The filter would normally exclude a piece of evidence for a small vehicle for being considered a jeep or a car if it only had two out of four identifications. On the other hand, the user could have a hypothesis of a &ldquo;worst case&rdquo; scenario and assume that all of the &ldquo;small vehicles&rdquo; were jeeps just to see what threat would be possible in this case. This could be compared to the traditional approach where an object is not part of a threat until it is identified as one. </paragraph>
<paragraph id="P-0135" lvl="0"><number>&lsqb;0135&rsqb;</number> The system must allow the PRP user to change parameters for uncertainty via filters and for the objects to be fused via Ontology entries. Summarized, the requirements of such a system are that the user must be able to specify (1) a set of data sources, or a process such as a search engine query that supplies them. For each data source the user must specify (2) the processing filter to be used to include or omit the data. Each filter consists of transformations, including (3) the user supplied parameters for screening out any data with too high an uncertainty. The filter at the final data level should include (4) the last (higher) level of detail at which information is to be processed and (5) how frequently the data is to be updated. In addition the user must specify (5) the Final View&apos;s filter for combining the final sources of data. This section discusses the fusion of data using objects and the application of Evidential Reasoning, the use of an Ontology and screens. The PRP results are displayed to the user and changes like the above are made to explore the possible interpretations of the evidence. </paragraph>
<paragraph id="P-0136" lvl="0"><number>&lsqb;0136&rsqb;</number> The various embodiments and modifications of the present invention are not just those which have been heretofore described, but also all those within the scope of the following claim. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">I claim: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A process for reasoning about the real world&apos;s representation as a database stored on a computer, comprising: 
<claim-text>organizing computer representations of information together with the representation of the presumed relationships that exist among elements of said information; </claim-text>
<claim-text>applying and recording corresponding measures of completeness and correctness of said information; and </claim-text>
<claim-text>generating a new measure that provides a useful new description of said information that summarizes it concisely.</claim-text>
</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>4</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030004958A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030004958A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030004958A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030004958A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030004958A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030004958A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030004958A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030004958A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
