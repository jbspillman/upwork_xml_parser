<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030004698A1-20030102-D00000.TIF SYSTEM "US20030004698A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030004698A1-20030102-D00001.TIF SYSTEM "US20030004698A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030004698A1-20030102-D00002.TIF SYSTEM "US20030004698A1-20030102-D00002.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030004698</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09896612</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010629</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F017/50</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>703</class>
<subclass>014000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Agent state drive simulation and method for detecting simulated drive fights</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Daniel</given-name>
<middle-name>D.</middle-name>
<family-name>Osborn</family-name>
</name>
<residence>
<residence-us>
<city>Fort Collins</city>
<state>CO</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Thomas</given-name>
<middle-name>J.</middle-name>
<family-name>Kennedy</family-name>
</name>
<residence>
<residence-us>
<city>Fort Collins</city>
<state>CO</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>HEWLETT-PACKARD COMPANY</name-1>
<name-2>Intellectual Property Administration</name-2>
<address>
<address-1>P.O. Box 272400</address-1>
<city>Fort Collins</city>
<state>CO</state>
<postalcode>80527-2400</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A method for detecting bus fights in a simulated bus system comprising simulating a first logic sequence and a second logic sequence respectively representing an output sequence of a first simulated device and a second simulated drive to a simulated bus, and determining a bus fight condition exists when a high logic state of the first logic sequence and the second logic sequence is detected on an adjacent clock cycle is provided. A computer executable program operable to cause a computer to simulate a respective sequence of logic states of a first device and a second device, determine the first device has gained access to the bus during a first clock cycle, analyze the logic state of the second device, and determine a bus fight condition exists when the second device has gained access to the bus during a clock cycle adjacent to the first clock cycle is provided. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">TECHNICAL FIELD OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> This invention relates to bus arbitration and, more particularly, to a system and method for detecting drive fights during bus arbitration simulation. </paragraph>
</section>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> Computer systems commonly have a plurality of components, such as processors, memory, and input/output devices, and a shared bus for transferring information among two or more of the components. The components commonly are coupled to the bus in the form of device modules, each of which may contain one or more processors, memory, and/or input/output devices. Information is transmitted on the bus among the devices during bus &ldquo;cycles,&rdquo;<highlight><bold>0</bold></highlight> each bus cycle being a period of time during which a device has control of the bus and is permitted to transfer, or drive, a limited quantity of information on the bus. Modules communicate by sending each other data on the bus that take one or more cycles to complete, such as conventional &ldquo;read&rdquo;<highlight><bold>0</bold></highlight> and &ldquo;write&rdquo;<highlight><bold>0</bold></highlight> operations. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> Typically, only one device can send, or drive, information on a shared bus in a given cycle. Thus, any shared bus system must have a bus arbitration scheme for determining which device is entitled to drive information on the bus in a particular cycle. Many conventional bus arbitration schemes are available. In most arbitration schemes, each device in a shared bus system generates a signal when it wants to drive the bus, and an arbitration algorithm, or bus arbitrator, implemented on one or more processors determines which device is entitled to drive the bus during a given cycle. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> Conventional arbitration schemes are generally designed to allow each device seeking to use the bus an opportunity to do so. Thus, each device is able to make forward progress on the transactions it needs to issue. For example, in a conventional round-robin arbitration scheme, the modules are effectively queued for arbitration priority purposes. The device at the head of the queue gains control of the bus during the next available bus cycle and is then placed at the end of the queue. Many conventional arbitration schemes are available that are more complex than a round-robin scheme. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> However, drive fights, also referred to herein as bus fights, often result between devices seeking to simultaneously access the bus. Bus arbitration schemes are designed to prevent such drive fights. Due to oversights in bus arbitration protocol design as well as differences in device performances relative to idealized device performances used during bus arbitration design, drive fights still often occur. The potential for drive fights is ideally determined during design of the bus system, that is during conceptualization and simulation of the bus system. Typically, a conceptualized bus system is analyzed by simulating various bus access configurations respectively including various device access configurations and various device access characteristics in order to simulate real-world conditions the bus may be subjected to. Signal collisions, in which two devices attempt to drive signals onto the bus concurrently in a situation referred to as a drive fight, in simulated bus systems may be detected with common bus simulation systems. A conceptualized bus system may then be re-designed to avoid a physical implementation of the bus having characteristics that may result in the drive fight of the simulated bus system. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> Hardware description languages, such as Verilog&reg;, are commonly used in the design of circuits and bus arbitration systems may be designed and simulated thereby. Electronic circuit design and gate level simulators may provide simulation of various bus characteristics and simulated microprocessor and/or peripheral devices access to the bus. For example, bus design and arbitration circuit simulators may accurately simulate a conceptualized bus clock rate, propagation characteristics of address, data and control signals driven on the bus and drive characteristics, such as signal drive delays, of devices that may access the bus. The simulation is generally implemented by one or more computer executable programs that comprise mathematical models that predict and simulate the behavior of the simulated bus system under one or more scenarios. Various arbitration schemes may accordingly be simulated by a bus simulation system. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> However, bus simulation systems do not generally detect bus simulations drive states having two devices attempt to drive signals onto the bus on adjacent clock cycles&mdash;a situation generally indicative of a drive fight. Accordingly, while bus simulation systems are helpful for eliminating bus design configurations that may lead to drive fights, implementation of bus systems nevertheless often result in bus systems that may result in drive fights thereon due to the failure to identify potential drive fight conditions characterized by drive access by multiple devices on adjacent clock signals. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> In accordance with an embodiment of the present invention, a method for detecting bus fights in a simulated bus system comprising simulating a first logic sequence representing an output sequence of a first simulated device to a simulated bus, simulating a second logic sequence representing an output sequence of a second simulated device to the simulated bus and determining a bus fight condition exists when a high logic state of the first logic sequence is detected on an adjacent clock cycle to a high logic state of the second logic sequence is provided. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> In accordance with another embodiment of the invention, a computer executable program operable to cause a computer to simulate a respective sequence of logic states of a first device and a second device, read the sequence of logic states by a drive state monitor module, determine the first device has gained access to the bus during a first clock cycle, analyze, for the first clock cycle and a clock cycle prior to and subsequent to the first clock cycle, the logic state of the second device, and determine a bus fight condition exists if one of the analyzed logic states of the second device indicates the second device has gained access to the bus is provided.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> For a more complete understanding of the present invention, the objects and advantages thereof, reference is now made to the following descriptions taken in connection with the accompanying drawings in which: </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a schematic of a shared bus and devices that may perform data writes and reads on the bus <highlight><bold>10</bold></highlight> that may be simulated by a simulated bus system according to an embodiment of the present invention.; </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> illustrate a simulated bus system according to an embodiment of the invention that may simulate the shared bus and devices described with reference to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>; </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3A</cross-reference> illustrates device module output states that may be maintained in a drive state monitor module <highlight><bold>80</bold></highlight> of a simulated bus system according to an embodiment of the invention; and </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> FIGS. <highlight><bold>3</bold></highlight>B-<highlight><bold>3</bold></highlight>D show output logic states maintained by a drive state simulation module according to an embodiment of the invention.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> The preferred embodiment of the present invention and its advantages are best understood by referring to <cross-reference target="DRAWINGS">FIGS. 1 through 3</cross-reference> of the drawings, like numerals being used for like and corresponding parts of the various drawings. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> The present invention provides a program and method for monitoring the drive state and/or the output enable state of each device that may access a bus in a simulated bus system. Simulated address and data signals driven by the devices sharing the bus are continuously monitored by a drive state monitoring module that maintains the address and data output logic states from all devices sharing the bus preferably for at least three clock cycles, but those skilled in the art will recognize four or more clock cycles may be maintained by the drive state monitoring module. When a device begins driving a signal on the bus in the simulated bus system, an analysis of the drive states of the remaining device(s) that may access the bus for the previous clock cycle and the present clock cycle is then made by the drive state monitoring module. The drive state for the remaining device(s) during the following clock cycle is also evaluated so that an attempt by a device to access the bus a clock cycle after access, in addition to an attempt to access the bus on a clock cycle prior to access by the first device, by the first device may be detected thus providing an indication of a bus fight condition. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, there is illustrated a schematic of a shared bus <highlight><bold>10</bold></highlight> and devices <highlight><bold>20</bold></highlight> and <highlight><bold>21</bold></highlight> that may perform data writes and reads on bus <highlight><bold>10</bold></highlight> and that may be simulated by a bus arbitration simulation system according to an embodiment of the present invention. Device <highlight><bold>20</bold></highlight> is coupled to bus <highlight><bold>10</bold></highlight> via an address line <highlight><bold>30</bold></highlight> for driving an address signal onto bus <highlight><bold>10</bold></highlight>. A data line <highlight><bold>31</bold></highlight> couples device <highlight><bold>20</bold></highlight> with bus <highlight><bold>10</bold></highlight> and allows data transfers thereacross to be driven onto bus <highlight><bold>10</bold></highlight>. Likewise, device <highlight><bold>21</bold></highlight> includes an address line <highlight><bold>40</bold></highlight> for driving an address signal onto bus <highlight><bold>10</bold></highlight> and a data line <highlight><bold>41</bold></highlight> couples device <highlight><bold>21</bold></highlight> with bus <highlight><bold>10</bold></highlight> and allows data transfers to be driven thereacross onto bus <highlight><bold>10</bold></highlight>. While address lines <highlight><bold>30</bold></highlight> and <highlight><bold>40</bold></highlight> are illustrated as single line mediums for sequential transfer of address bits, address lines <highlight><bold>30</bold></highlight> and <highlight><bold>40</bold></highlight> may each include a plurality of lines for driving address bits onto bus <highlight><bold>10</bold></highlight> in parallel. Similarly, data lines <highlight><bold>31</bold></highlight> and <highlight><bold>41</bold></highlight> may include a plurality of data lines for performing parallel data writes on bus <highlight><bold>10</bold></highlight>. Accordingly, bus <highlight><bold>10</bold></highlight> includes one or more data lines <highlight><bold>10</bold></highlight>A and one or more address lines <highlight><bold>10</bold></highlight>B. A bus arbitrator <highlight><bold>60</bold></highlight> may be coupled to a respective output ENABLE <highlight><bold>25</bold></highlight> and <highlight><bold>26</bold></highlight> of devices <highlight><bold>20</bold></highlight> and <highlight><bold>21</bold></highlight> for granting one of devices <highlight><bold>20</bold></highlight> and <highlight><bold>21</bold></highlight> write access to bus <highlight><bold>10</bold></highlight>. Bus arbitrator <highlight><bold>60</bold></highlight> may employ any one of numerous conventional bus arbitration schemes. In general, bus arbitrator <highlight><bold>60</bold></highlight> implements a bus arbitration scheme to determine which device gains access and control of bus <highlight><bold>10</bold></highlight> during any given clock cycle. Other devices, such as a memory module <highlight><bold>70</bold></highlight> and a processor <highlight><bold>71</bold></highlight>, may be coupled to bus <highlight><bold>10</bold></highlight> and bus arbitrator <highlight><bold>60</bold></highlight> and may gain control of bus <highlight><bold>10</bold></highlight> via bus arbitrator <highlight><bold>60</bold></highlight>. Furthermore, one of devices <highlight><bold>20</bold></highlight> and <highlight><bold>21</bold></highlight>, memory module <highlight><bold>70</bold></highlight> and processor <highlight><bold>71</bold></highlight> may receive control of bus <highlight><bold>10</bold></highlight> under default conditions. In the forthcoming description, only bus arbitration, and simulation thereof, between device <highlight><bold>20</bold></highlight> and <highlight><bold>21</bold></highlight> will be described to simplify the discussion of the invention. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> Devices <highlight><bold>20</bold></highlight> and <highlight><bold>21</bold></highlight>, also collectively referred to herein as &lsquo;agents&rsquo;, that need to utilize bus <highlight><bold>10</bold></highlight> arbitrate for control of bus <highlight><bold>10</bold></highlight> during any given clock cycle. Various bus arbitration protocols have been developed that attempt to eliminate the occurrence of simultaneous access of bus <highlight><bold>10</bold></highlight> by device <highlight><bold>20</bold></highlight> and <highlight><bold>21</bold></highlight>. However, often due to errors in the protocol or variations in operation of devices <highlight><bold>20</bold></highlight> and <highlight><bold>21</bold></highlight>, a bus fight may occur and result in failure of bus arbitration or erroneous read and/or writes thereto. In general, a bus fight condition may exist when two devices attempt to drive a signal to a shared bus on a common clock cycle or during adjacent clock cycles. However, state of the art bus design tools, such as computer simulated circuit systems, only detect occurrences of simultaneous bus access by bus agents when analyzing a bus design for potential deficiencies thereof. The present invention provides a system and method of simulating and monitoring the drive state of each agent that may arbitrate for control of a bus and detect a bus fight via agent drives to the bus on adjacent clock cycles. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, there is illustrated a simulated bus system <highlight><bold>100</bold></highlight> according to an embodiment of the invention that may simulate shared bus <highlight><bold>10</bold></highlight> and devices <highlight><bold>20</bold></highlight> and <highlight><bold>21</bold></highlight> described with reference to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. Simulated bus system <highlight><bold>100</bold></highlight> may be implemented as computer executable code that is storable on a storage medium, such as a magnetic hard disk or floppy disk, an optical medium or other digital storage device, and executable by a central processing unit of a computer <highlight><bold>150</bold></highlight>. Computer <highlight><bold>150</bold></highlight> may have various peripheral devices including a monitor <highlight><bold>152</bold></highlight>, a keyboard <highlight><bold>154</bold></highlight> and a mouse <highlight><bold>156</bold></highlight> for providing output to a user thereof and for receiving input from a user thereof. Simulated bus system <highlight><bold>100</bold></highlight> comprises numerous modules including a shared bus module <highlight><bold>110</bold></highlight> and one or more agent modules <highlight><bold>120</bold></highlight> and <highlight><bold>121</bold></highlight> that simulate access requests and signal drives to bus module <highlight><bold>1</bold></highlight> <highlight><bold>10</bold></highlight> via simulated bus arbitrator module <highlight><bold>160</bold></highlight> and, in general, simulate various component behaviors and logic states of elements of a bus system, such as shared bus <highlight><bold>10</bold></highlight> illustrated in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. Simulated bus system <highlight><bold>100</bold></highlight> further comprises a drive state monitor module <highlight><bold>80</bold></highlight> that operates to store and monitor the simulated drive states of agent modules <highlight><bold>120</bold></highlight> and <highlight><bold>121</bold></highlight> for the occurrence of a simulated bus fight according to the teachings of the invention. A clock module <highlight><bold>65</bold></highlight> may be simulated by bus system <highlight><bold>100</bold></highlight> as well. Drive state monitor module <highlight><bold>80</bold></highlight> maintains a plurality of output states <highlight><bold>81</bold></highlight>A-<highlight><bold>81</bold></highlight>C that respectively indicate drive states of device module <highlight><bold>120</bold></highlight> on address line module <highlight><bold>130</bold></highlight> and data line module <highlight><bold>131</bold></highlight> and device module <highlight><bold>121</bold></highlight> drive states on address line module <highlight><bold>140</bold></highlight> and data line module <highlight><bold>141</bold></highlight> simulated by system <highlight><bold>100</bold></highlight>. Output states <highlight><bold>81</bold></highlight>A-<highlight><bold>81</bold></highlight>C may be maintained in a first-in first-out (FIFO) queuing manner and are indicative of simulated output sequences made from device modules <highlight><bold>120</bold></highlight> and <highlight><bold>121</bold></highlight>. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> Each module of simulated bus system <highlight><bold>100</bold></highlight> may include various rules, parameters and/or mathematical models that mathematically simulate the behavior of a respective device. For example, device module <highlight><bold>120</bold></highlight> may simulate a magnetic hard disk and may include a mathematical model that defines, or approximates, the electronic behavior of a magnetic hard disk. For example, module <highlight><bold>120</bold></highlight> may simulate read and write operations performable by a typical hard disk and may include simulated switching delays and propagation characteristics known in common hard disks. Line modules <highlight><bold>130</bold></highlight>, <highlight><bold>131</bold></highlight>, <highlight><bold>140</bold></highlight> and <highlight><bold>141</bold></highlight> may simulate characteristics of output signals provided by device modules <highlight><bold>120</bold></highlight> and <highlight><bold>121</bold></highlight> on a conductive medium. Bus module <highlight><bold>110</bold></highlight> may comprise a data module <highlight><bold>110</bold></highlight>A and an address module <highlight><bold>110</bold></highlight>B that respectively simulate one or more data lines and one or more address lines and may include behavior parameters such as a simulated clock rate that governs the behavior thereof. Each of the modules of the simulated bus system may interact with other modules and may be operable to provide input, or function arguments, to other modules. Inter-module interaction may be performed by subroutine and/or function calls, program callbacks, and/or other software processing routines understood by those skilled in the art. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 3</cross-reference>A, there is illustrated exemplary device modules <highlight><bold>120</bold></highlight> and <highlight><bold>121</bold></highlight> output states that may be maintained in drive state monitor module <highlight><bold>80</bold></highlight>, for example by function calls to and/or from drive state monitor module <highlight><bold>80</bold></highlight> and device modules <highlight><bold>120</bold></highlight> and <highlight><bold>121</bold></highlight>, as well as a simulated clock cycle. Reference to signal drives by device modules <highlight><bold>120</bold></highlight> and <highlight><bold>121</bold></highlight> is understood to indicate a simulated signal drive. A simulated sequence <highlight><bold>35</bold></highlight> of address output signals and a simulated sequence <highlight><bold>36</bold></highlight> of data output signals of device module <highlight><bold>120</bold></highlight> are illustrated. Likewise, a simulated sequence <highlight><bold>37</bold></highlight> of address output signals and a simulated sequence <highlight><bold>38</bold></highlight> of data output signals for device module <highlight><bold>121</bold></highlight> are illustrated. A reference cycle is denoted as t<highlight><subscript>0</subscript></highlight>. Previous clock cycles are denoted as increments of t<highlight><subscript>0</subscript></highlight>, for example t<highlight><subscript>0&plus;1</subscript></highlight>, and t<highlight><subscript>0&minus;2</subscript></highlight>. Subsequent clock cycles are denoted as decrements of t<highlight><subscript>0</subscript></highlight>, for example t<highlight><subscript>0&minus;1</subscript></highlight>, and t<highlight><subscript>0&minus;2 </subscript></highlight>Clock cycles separated by only one clock cycle, for example t<highlight><subscript>0 </subscript></highlight>and t<highlight><subscript>0&plus;1</subscript></highlight>, are referred to as adjacent clock cycles. Preferably, drive state monitor module <highlight><bold>80</bold></highlight> is operable to monitor three or more sequential cycles of device modules <highlight><bold>120</bold></highlight> and <highlight><bold>121</bold></highlight>. State drive monitor module <highlight><bold>80</bold></highlight> preferably provides a FIFO queue for the simulated address and data output logic states of device modules <highlight><bold>120</bold></highlight> and <highlight><bold>121</bold></highlight>. Stored data and address logic state information is referred to as S<highlight><subscript>X </subscript></highlight>such that S<highlight><subscript>0 </subscript></highlight>represents the logic state corresponding to a current clock cycle. Accordingly, a logic state S<highlight><subscript>1</subscript></highlight>, represent a logic state one cycle previous to a logic state S<highlight><subscript>0</subscript></highlight>. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> State of the art simulated bus systems are generally operable to detect signal collisions between two or more device modules. A signal collision occurs when two or more devices attempt to drive a signal (data and/or address) to the bus. Detection of a signal collision during simulation indicates a flaw in the bus system design and/or performance limits thereof. Generally, bus systems require an idle clock cycle between any two bus access attempts by more than one device. Thus, during simulation the occurrence of signal drives by different devices on adjacent clock cycles is indicative of a drive fight. The present invention provides a method of detecting such a condition so that bus systems may be better designed and bus fights therein avoided. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> Drive state monitor module <highlight><bold>80</bold></highlight> is operable to perform state comparison and analysis of output states of device modules <highlight><bold>120</bold></highlight> and <highlight><bold>121</bold></highlight>. Upon detection of a signal driven to bus module <highlight><bold>110</bold></highlight> by a device module, for example device module <highlight><bold>120</bold></highlight>, an analysis is made by logic state monitor module <highlight><bold>80</bold></highlight> of the drive state(s) for the same clock cycle of other device modules. Accordingly, logic state monitor module <highlight><bold>80</bold></highlight> is operable to compare logic states S<highlight><subscript>0</subscript></highlight>-S<highlight><subscript>2 </subscript></highlight>of device modules <highlight><bold>120</bold></highlight> and <highlight><bold>121</bold></highlight>. Preferably, logic state monitor module <highlight><bold>80</bold></highlight> is operable to analyze different output states, for example address output and data output logic states, of device modules <highlight><bold>120</bold></highlight> and <highlight><bold>121</bold></highlight>. Additionally, it is preferable that output logic states of device module <highlight><bold>121</bold></highlight> may be analyzed for a previous clock cycle when it is detected that device module <highlight><bold>120</bold></highlight> drives a signal onto bus module <highlight><bold>110</bold></highlight>. Furthermore, it is preferable that output logic states of device module <highlight><bold>121</bold></highlight> may be analyzed for a subsequent clock cycle when it is detected that device module <highlight><bold>120</bold></highlight> drives a signal onto bus module <highlight><bold>110</bold></highlight>. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 3</cross-reference>B, there is illustrated output logic state data of device modules <highlight><bold>120</bold></highlight> and <highlight><bold>121</bold></highlight> (corresponding to reference t<highlight><subscript>o</subscript></highlight>) that is analyzed by drive state monitor module <highlight><bold>80</bold></highlight>. Drive state monitor module <highlight><bold>80</bold></highlight> preferably may store logic state information of three or more cycles (S<highlight><subscript>0</subscript></highlight>, S<highlight><subscript>1</subscript></highlight>, and S<highlight><subscript>2</subscript></highlight>). Output logic state information is preferably written into drive state monitor module <highlight><bold>80</bold></highlight> each simulated clock cycle. Logic states read during a cycle of simulated output sequences <highlight><bold>35</bold></highlight>-<highlight><bold>38</bold></highlight> of device modules <highlight><bold>120</bold></highlight> and <highlight><bold>121</bold></highlight> are preferably written into drive state monitor module <highlight><bold>80</bold></highlight> each clock cycle in a first-in first-out manner. For example, <cross-reference target="DRAWINGS">FIG. 3B</cross-reference> shows output logic state S<highlight><subscript>0 </subscript></highlight>that indicates the logic state simulated on output line modules <highlight><bold>130</bold></highlight>-<highlight><bold>131</bold></highlight> and <highlight><bold>140</bold></highlight>-<highlight><bold>141</bold></highlight> at t<highlight><subscript>0</subscript></highlight>. State drive monitor module <highlight><bold>80</bold></highlight> may detect bus access by device modules <highlight><bold>120</bold></highlight> and <highlight><bold>121</bold></highlight>. In an embodiment, an evaluation for bus fight conditions is not made by state drive monitor module <highlight><bold>80</bold></highlight> until one of device modules <highlight><bold>120</bold></highlight> and <highlight><bold>121</bold></highlight> is detected driving a signal onto bus module <highlight><bold>110</bold></highlight>. At t<highlight><subscript>0</subscript></highlight>, neither device module <highlight><bold>120</bold></highlight> or <highlight><bold>121</bold></highlight> is driving a signal as indicated by all zero logic states S<highlight><subscript>0 </subscript></highlight>of output line modules <highlight><bold>130</bold></highlight>-<highlight><bold>131</bold></highlight> and <highlight><bold>140</bold></highlight>-<highlight><bold>141</bold></highlight>. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 3</cross-reference>C, there is shown output logic states maintained by state drive monitor module <highlight><bold>80</bold></highlight> at a subsequent clock cycle, that is one clock cycle after the output states summarized in <cross-reference target="DRAWINGS">FIG. 3B</cross-reference>. Output states now represented by S<highlight><subscript>0 </subscript></highlight>correspond to logic states of output sequences <highlight><bold>35</bold></highlight>-<highlight><bold>38</bold></highlight> at t<highlight><subscript>0&plus;1</subscript></highlight>. Accordingly, output states S<highlight><subscript>2 </subscript></highlight>maintained in state drive monitor module <highlight><bold>80</bold></highlight> at t<highlight><subscript>0 </subscript></highlight>have all been shifted out of state drive monitor module <highlight><bold>80</bold></highlight> and output states S<highlight><subscript>0 </subscript></highlight>and S<highlight><subscript>1 </subscript></highlight>(at t<highlight><subscript>0</subscript></highlight>) have been respectively shifted to output states S<highlight><subscript>1 </subscript></highlight>and S<highlight><subscript>2 </subscript></highlight>(at t<highlight><subscript>0&plus;1</subscript></highlight>). As indicated by output sequences <highlight><bold>35</bold></highlight> at t<highlight><subscript>0&plus;1</subscript></highlight>, and logic state So for line <highlight><bold>30</bold></highlight>, the address output of device module <highlight><bold>120</bold></highlight> is asserted at t<highlight><subscript>0&plus;1</subscript></highlight>. A check for a drive fight is then made by state drive monitor module <highlight><bold>80</bold></highlight> by evaluating whether device module <highlight><bold>121</bold></highlight> is attempting to drive a signal to bus module <highlight><bold>110</bold></highlight> during the current clock cycle or attempted to drive a signal to bus module <highlight><bold>110</bold></highlight> during the previous clock cycle. Accordingly, state drive monitor module <highlight><bold>80</bold></highlight> then evaluates logic states S<highlight><subscript>0 </subscript></highlight>and S<highlight><subscript>1 </subscript></highlight>for device module <highlight><bold>121</bold></highlight>, that is the logic states of line modules <highlight><bold>140</bold></highlight> and <highlight><bold>141</bold></highlight> at t<highlight><subscript>0&plus;1 </subscript></highlight>and t<highlight><subscript>0</subscript></highlight>. As illustrated by output sequences <highlight><bold>37</bold></highlight> and <highlight><bold>38</bold></highlight> and summarized in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>C, neither address or data output logic states S<highlight><subscript>0 </subscript></highlight>and S<highlight><subscript>1 </subscript></highlight>for device module <highlight><bold>121</bold></highlight> is asserted on the current clock cycle (t<highlight><subscript>0&plus;1</subscript></highlight>) or during the previous clock cycle (t<highlight><subscript>0</subscript></highlight>). Accordingly, assertion of an address signal by device module <highlight><bold>120</bold></highlight> is determined to be valid by drive state monitor module <highlight><bold>80</bold></highlight>. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 3</cross-reference>D, there is shown output states maintained by state drive monitor module <highlight><bold>80</bold></highlight> at a subsequent clock cycle (t<highlight><subscript>0&plus;2</subscript></highlight>), that is one clock cycle after the output states summarized in <cross-reference target="DRAWINGS">FIG. 3C</cross-reference>. Output states now represented by S<highlight><subscript>0 </subscript></highlight>correspond to the logic states of output sequences <highlight><bold>35</bold></highlight>-<highlight><bold>38</bold></highlight> at t<highlight><subscript>0&plus;2</subscript></highlight>. Accordingly, logic states S<highlight><subscript>2 </subscript></highlight>in state drive monitor module <highlight><bold>80</bold></highlight> at t<highlight><subscript>0&plus;1 </subscript></highlight>have all been shifted out (at t<highlight><subscript>0&plus;2</subscript></highlight>) of state drive monitor module <highlight><bold>80</bold></highlight> and output states S<highlight><subscript>0 </subscript></highlight>and S<highlight><subscript>1 </subscript></highlight>at t<highlight><subscript>0&plus;1 </subscript></highlight>have been respectively shifted to output states S<highlight><subscript>1 </subscript></highlight>and S<highlight><subscript>2 </subscript></highlight>at t<highlight><subscript>0&plus;2</subscript></highlight>. Because a signal was detected to be driven to bus module <highlight><bold>110</bold></highlight> by device module <highlight><bold>120</bold></highlight> in the previous clock cycle, a check is again made of output states S<highlight><subscript>0 </subscript></highlight>of device module <highlight><bold>121</bold></highlight>, thereby determining if an attempted signal drive to bus module <highlight><bold>110</bold></highlight> is made by device module <highlight><bold>121</bold></highlight> one clock cycle after the detected signal drive by device module <highlight><bold>120</bold></highlight>. As illustrated by output state sequence <highlight><bold>37</bold></highlight> at t<highlight><subscript>0&plus;2 </subscript></highlight>in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>A and by logic state S<highlight><subscript>0 </subscript></highlight>for line <highlight><bold>40</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 3D, a</cross-reference> signal drive by device module <highlight><bold>121</bold></highlight> on line module <highlight><bold>140</bold></highlight> is detected by drive state monitor module <highlight><bold>80</bold></highlight> and thus indicates a bus fight condition existing between device modules <highlight><bold>120</bold></highlight> and <highlight><bold>121</bold></highlight> as indicated by a respective signal drive on adjacent clock cycles by device modules <highlight><bold>120</bold></highlight> and <highlight><bold>121</bold></highlight>. Simulated bus system <highlight><bold>100</bold></highlight> may then provide notification to a user of computer <highlight><bold>150</bold></highlight> of the existence of a bus fight condition in the simulated bus circuit. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> In another embodiment, drive state monitor module <highlight><bold>80</bold></highlight> may maintain and monitor an ENABLE module of device module <highlight><bold>120</bold></highlight> and/or <highlight><bold>121</bold></highlight> that simulates ENABLE signals provided thereto by a simulated bus arbitration module <highlight><bold>160</bold></highlight>. Simultaneous ENABLE signals, or adjacent ENABLE signals, to device modules <highlight><bold>120</bold></highlight> and <highlight><bold>121</bold></highlight> may indicate a drive fight condition and appropriate notification may be provided to a user of computer <highlight><bold>150</bold></highlight> executing simulated bus system <highlight><bold>100</bold></highlight>. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> Detection of a bus fight condition indicated by signals driven on adjacent clock cycles in a simulated bus circuit can then be accounted for during bus system design so that such scenarios are eliminated when the bus system is manufactured. Detection of a bus fight condition may invoke a notification thereof by simulated bus system <highlight><bold>100</bold></highlight>. For example, a visual indication of a bus fight may be provided to a designer via monitor <highlight><bold>152</bold></highlight> coupled to computer <highlight><bold>150</bold></highlight> executing the simulated bus system <highlight><bold>100</bold></highlight>. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method for detecting bus fights in a simulated bus system, comprising: 
<claim-text>simulating a first logic sequence representing an output sequence of a first simulated device to a simulated bus; </claim-text>
<claim-text>simulating a second logic sequence representing an output sequence of a second simulated device to the simulated bus; </claim-text>
<claim-text>determining a bus fight condition exists when a high logic state of the first logic sequence is detected on an adjacent clock cycle to a high logic state of the second logic sequence. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, wherein determining a bus fight condition exists further comprises determining a bus fight condition exists when a high logic state of the first logic sequence is detected on a clock cycle having a high logic state of the second logic sequence on the same clock cycle. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein simulating a first logic sequence representing an output sequence of a first simulated device to a simulated bus further comprises simulating a logic sequence representing an output sequence of the first simulated device to the bus on an address line and simulating an output sequence of the first simulated device to the bus on a data line, and simulating a second logic sequence representing an output sequence of a second simulated device to the simulated bus further comprises simulating a logic sequence representing an output sequence of the second simulated device to the bus on an address line and simulating an output sequence of the second simulated device to the bus on a data line. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference>, wherein determining a bus fight condition exists when a high logic state of the first logic sequence is detected on an adjacent clock cycle to a high logic state of the second logic sequence further comprises determining a bus fight condition exists when a high logic state of the first simulated device on one of the address line and the data line is detected on an adjacent clock cycle of the high logic state of the second simulated device, the high logic state of the second simulated device on one of the address line and the data line. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein simulating a first logic sequence further comprises simulating data and address signals driven by the first simulated device, the data and logic sequences including simulated drive delays. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein simulating a first logic sequence representing an output sequence of a first simulated device to a simulated bus further comprises simulating a first logic sequence representing an output sequence of the first simulated device to the simulated bus having a simulated clock speed. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising simulating a bus arbitrator that enables high logic states within at least one of the first logic sequence and the second logic sequence. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference>, wherein simulating a bus arbitrator further comprises simulating an output enable transmission to the first simulated device and the second simulated device. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising simulating propagation delays between the first simulated device and the simulated bus and simulating propagation delays between the second simulated device and the bus. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising maintaining a record of a logic state of three consecutive cycles for each of the first logic sequence and the second logic sequence, the record maintained in a first-in first-out order. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. A computer executable program, comprising: 
<claim-text>a computer readable medium; </claim-text>
<claim-text>computer executable instructions residing on the computer readable medium and operable to cause the computer to execute the following steps: </claim-text>
<claim-text>simulating a respective sequence of logic states of a first device and a second device, each of the devices operable to drive signals to a bus; </claim-text>
<claim-text>reading the sequence of logic states by a drive state monitor module; </claim-text>
<claim-text>determining the first device has gained access to the bus during a first clock cycle; </claim-text>
<claim-text>analyzing, for the first clock cycle and a clock cycle prior to and subsequent to the first clock cycle, the logic state of the second device; and </claim-text>
<claim-text>determining a bus fight condition exists if one of the analyzed logic states of the second device indicates the second device has gained access to the bus. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The computer executable program according to <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, wherein reading a sequence of logic states further comprises reading a sequence of logic states of a simulated first line and a simulated second line that respectively model a connection between the first device and the second device to a bus arbitrator, the sequence of logic states representing a respective enable input of the first device and the second device. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The computer executable program according to <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, wherein reading a sequence of logic states further comprises reading a sequence of logic states of at least a first simulated line respectively modeling a connection between the first device and the bus and a second simulated line respectively modeling a connection between the second device and the bus, and determining the first device has gained access to the bus during a first clock cycle further comprises determining the first device simulates a signal drive to the bus during the first clock cycle. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The computer executable program according to <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference>, wherein reading a sequence of logic states further comprises reading a sequence of logic states of a simulated first plurality of lines respectively modeling a connection between the first device and the bus and reading a plurality of logic states of a simulated second plurality of lines respectively modeling a connection between the second device and the bus. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The computer executable program according to <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference>, wherein reading a sequence of logic states on a first simulated line further comprises reading a respective sequence of logic states of a simulated address line modeling a connection between the first device and the bus and a simulated data line modeling a connection between the first device and the bus, and reading a sequence of logic states on a second simulated line further comprises reading a respective sequence of logic states on a simulated address line modeling a connection between the second device and the bus and a simulated data line modeling a connection between the second device and the bus.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>1</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030004698A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030004698A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030004698A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
