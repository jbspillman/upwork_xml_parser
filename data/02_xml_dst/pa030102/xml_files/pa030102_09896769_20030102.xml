<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005197A1-20030102-D00000.TIF SYSTEM "US20030005197A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005197A1-20030102-D00001.TIF SYSTEM "US20030005197A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005197A1-20030102-D00002.TIF SYSTEM "US20030005197A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005197A1-20030102-D00003.TIF SYSTEM "US20030005197A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005197A1-20030102-D00004.TIF SYSTEM "US20030005197A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005197A1-20030102-D00005.TIF SYSTEM "US20030005197A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030005197A1-20030102-D00006.TIF SYSTEM "US20030005197A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030005197A1-20030102-D00007.TIF SYSTEM "US20030005197A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030005197A1-20030102-D00008.TIF SYSTEM "US20030005197A1-20030102-D00008.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005197</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09896769</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010629</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F013/00</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>710</class>
<subclass>300000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Method and apparatus for deterministic removal and reclamation of work items from an expansion bus schedule</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Darren</given-name>
<middle-name>L.</middle-name>
<family-name>Abramson</family-name>
</name>
<residence>
<residence-us>
<city>Folsom</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>John</given-name>
<middle-name>S.</middle-name>
<family-name>Howard</family-name>
</name>
<residence>
<residence-us>
<city>Portland</city>
<state>OR</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>BLAKELY SOKOLOFF TAYLOR &amp; ZAFMAN</name-1>
<name-2></name-2>
<address>
<address-1>12400 WILSHIRE BOULEVARD, SEVENTH FLOOR</address-1>
<city>LOS ANGELES</city>
<state>CA</state>
<postalcode>90025</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A method and apparatus for deterministic removal and reclamation of work items from an expansion bus schedule are disclosed herein. A work item is removed from an enabled expansion bus schedule data structure and a coherency signal is then generated utilizing an expansion bus host controller. The work item is then reclaimed in response to the generation of the coherency signal. In one embodiment, the enabled expansion bus schedule data structure is a Universal Serial Bus (USB) asynchronous schedule including a plurality of queue heads. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">FIELD OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> The invention relates generally to the field of computer systems. More particularly, the invention relates to the deterministic removal and reclamation of work items from an expansion bus schedule. </paragraph>
</section>
<section>
<heading lvl="1">BACKGROUND </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> Peripheral devices may utilize an expansion bus to couple to and communicate with a computer system. Examples of expansion busses include the Industry Standard Architecture (ISA), Enhanced ISA (EISA), Micro Channel Architecture (MCA), Video Electronics Standards Association Local Bus (VESA or VL), Personal Computer Memory Card Industry Association (PCMCIA), Small Computer System Interface (SCSI), Peripheral Component Interconnect (PCI), IEEE 1394 (Firewire), and the Universal Serial Bus (USB). In a USB system, one or more USB peripheral devices are coupled via a shared USB interconnect to a single host computer system including client and USB system software as well as a USB host controller hardware interface. The USB supports functional data and control exchange between the USB host and a USB device as a set of one or more logical channels or &ldquo;pipes&rdquo; between client software and a particular endpoint on a USB device. Each pipe is associated with one of four USB-defined transfer types which are optimized for different client and device service requirements. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> Because the USB provides a shared physical transfer medium, bandwidth must be allocated among client software transfer requests. When a transfer request for a particular pipe is received from a client application, USB system software puts the request into the appropriate format and adds it to a schedule data structure or &ldquo;transaction list&rdquo; depending on the pipe&apos;s associated transfer type. An asynchronous schedule data structure is utilized for control and bulk transfer types while isochronous and interrupt transfers are placed into a periodic schedule data structure to ensure proper transmission latency. Once enabled, the schedules are executed by the host controller of the USB hardware interface to generate transactions on the USB. As the schedules are traversed, the host controller may cache the context or &ldquo;state&rdquo; of the schedule including schedule data structure elements or &ldquo;work items&rdquo;. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> The removal and reclamation of work items from the periodic and asynchronous schedules is similarly handled by USB system software. When a work item is removed from a schedule data structure however, it is unknown whether the host controller has a copy of the removed work item or a reference to it stored in cache. The removed work item cannot be reclaimed (i.e. its associated memory cannot be freed or reused) until it is determined that all cached state or data structures relating to the removed work item have been evicted or &ldquo;released&rdquo; by the host controller. Since the periodic schedule must regularly advance to ensure transmission latency for isochronous transfers, cache flushes occur on a periodic (frame or micro-frame) basis after which a removed periodic schedule work item may be reclaimed. Accordingly, in USB systems including a single schedule data structure, the coherency of the schedule may be ensured by waiting a predetermined amount of time after a work item is removed to reclaim it. In some USB systems however, separate periodic and asynchronous schedule data structures are defined. Consequently, methods for reclaiming asynchronous schedule work items in such systems based on the passage of time have proven inadequate to accurately determine when a removed asynchronous schedule data structure work item may be reclaimed to ensure asynchronous schedule coherency.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> The present invention is illustrated by way of example and not limitation in the figures of the accompanying drawings, in which: </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> illustrates a USB physical bus topology according to an embodiment of the present invention; </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> illustrates an exemplary computer system block diagram according to an embodiment of the present invention; </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> illustrates an interlayer communications model block diagram according to an embodiment of the present invention; </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> illustrates an exemplary schedule data structure layout according to an embodiment of the present invention; </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> illustrates a USB host controller block diagram according to an embodiment of the present invention; </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> illustrates a USB system software process flow diagram for one embodiment of the present invention; </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> illustrates a USB host controller process flow diagram for one embodiment of the present invention; and </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 8</cross-reference><highlight><italic>a</italic></highlight>-<highlight><bold>8</bold></highlight><highlight><italic>c </italic></highlight>illustrate an asynchronous schedule work item removal/reclamation sequence according to an embodiment of the present invention.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION </heading>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> A method and apparatus for the deterministic removal and reclamation of work items from an expansion bus schedule are described herein. In the following detailed description, numerous specific details such as specific computer system or host controller architectures are set forth in order to provide a more thorough understanding of the present invention. It should be evident however, that these specific details need not be used to practice the present invention. In other circumstances, well-known data structures, system elements, or connections have been omitted or have not been described in particular detail in order to avoid unnecessarily obscuring the present invention. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> illustrates a USB physical bus topology according to an embodiment of the present invention. It will be appreciated that both the number and arrangement of the USB devices illustrated are arbitrary and meant to be illustrative of, rather than limiting to, the present invention. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> The depicted USB system <highlight><bold>100</bold></highlight> includes USB devices <highlight><bold>108</bold></highlight> coupled to a host computer system <highlight><bold>102</bold></highlight> via a Universal Serial Bus. Each USB device <highlight><bold>108</bold></highlight> in the illustrated USB system <highlight><bold>100</bold></highlight> provides either a peripheral capability to the host or an attachment point, called a port <highlight><bold>106</bold></highlight>, on the USB. Such USB devices <highlight><bold>108</bold></highlight> are called functions and hubs, respectively. Although not shown in the illustrated embodiment, USB also provides support for &ldquo;compound devices&rdquo; which implement multiple functions in a single physical device. Similarly, USB provides support for &ldquo;composite devices&rdquo; which implement multiple interfaces controlled independently of one another. Both compound and composite devices are included in alternative embodiments of the present invention. The host computer system <highlight><bold>102</bold></highlight> occupies a unique position as the coordinating entity for the USB system <highlight><bold>100</bold></highlight>. In addition to its special physical position, host computer system <highlight><bold>102</bold></highlight> has specific responsibilities with regard to the USB system <highlight><bold>100</bold></highlight> and its attached USB devices <highlight><bold>108</bold></highlight>. For example, host computer system <highlight><bold>102</bold></highlight> provides Plug-and-Play (PnP) device support and also allows USB devices <highlight><bold>108</bold></highlight> to be &ldquo;hot-swapped&rdquo; without requiring the host computer system <highlight><bold>102</bold></highlight> to be powered down or restarted. To facilitate this, host computer system <highlight><bold>102</bold></highlight> monitors the topology of the USB system <highlight><bold>100</bold></highlight> to detect and account for the addition or removal of USB devices <highlight><bold>108</bold></highlight> in a process called bus enumeration. Host computer system <highlight><bold>102</bold></highlight> furthermore controls or &ldquo;mediates&rdquo; access to the USB physical bus medium using various schedule data structures. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> Host computer system <highlight><bold>102</bold></highlight> includes a USB host controller <highlight><bold>104</bold></highlight> according to an embodiment of the present invention which acts as a root hub for the USB system <highlight><bold>100</bold></highlight> and facilitates communication between the host computer system <highlight><bold>102</bold></highlight> and USB devices <highlight><bold>108</bold></highlight> on the bus. USB host controller <highlight><bold>104</bold></highlight> provides one or more ports <highlight><bold>106</bold></highlight> called root ports to which other USB devices <highlight><bold>108</bold></highlight> in USB system <highlight><bold>100</bold></highlight> may be coupled. Although a physical USB host controller device <highlight><bold>104</bold></highlight> has been shown, it will be appreciated that a USB host controller may be implemented using hardware, firmware, software, or any combination thereof. Similarly, although only a single host controller <highlight><bold>104</bold></highlight> has been illustrated, in alternative embodiments host controller <highlight><bold>104</bold></highlight> is coupled with a companion or legacy host controller to support communication according to one or more additional bus standards. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> A USB device <highlight><bold>108</bold></highlight> may be coupled directly to the host computer system <highlight><bold>102</bold></highlight> via a root port <highlight><bold>106</bold></highlight> on the USB host controller <highlight><bold>104</bold></highlight> such as function <highlight><bold>110</bold></highlight> and hub <highlight><bold>112</bold></highlight> of the illustrated embodiment. Alternatively, a USB device <highlight><bold>108</bold></highlight> may be coupled to the host computer system <highlight><bold>102</bold></highlight> via a port <highlight><bold>106</bold></highlight> on another hub <highlight><bold>112</bold></highlight>, <highlight><bold>116</bold></highlight> in the USB system <highlight><bold>100</bold></highlight> resulting in a tiered-star topology with a hub at the center of each star. For example, hub <highlight><bold>116</bold></highlight>, functions <highlight><bold>114</bold></highlight>, and function <highlight><bold>118</bold></highlight> are each coupled to the host computer system <highlight><bold>102</bold></highlight> in this manner. By coupling hubs together in this way, up to 127 USB devices <highlight><bold>108</bold></highlight> may be coupled to a host computer system <highlight><bold>102</bold></highlight>. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> illustrates an exemplary computer system block diagram according to an embodiment of the present invention. Although described in the context of computer system <highlight><bold>200</bold></highlight>, the present invention may be implemented in any suitable data processing system such as a network computer or other &ldquo;thin client&rdquo;, a palmtop computing device, robust cellular or Personal Communications Services (PCS) telephone, etc. having a greater or lesser number of system components. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> As illustrated in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, computer system <highlight><bold>100</bold></highlight> comprises one or more processors <highlight><bold>202</bold></highlight> and a chipset <highlight><bold>203</bold></highlight> coupled to a processor system bus <highlight><bold>208</bold></highlight>. Processor(s) <highlight><bold>202</bold></highlight> may each comprise any suitable processor architecture and for one embodiment comprise an Intel&trade; Architecture, used for example, in the Pentium&trade; family of processors available from Intel&trade; Corporation of Santa Clara, Calif. Chipset <highlight><bold>203</bold></highlight> for one embodiment of the present invention comprises a &ldquo;north bridge&rdquo; or memory controller hub (MCH) <highlight><bold>206</bold></highlight>, a &ldquo;south bridge&rdquo; or input/output (I/O) controller hub (ICH) <highlight><bold>218</bold></highlight>, and firmware hub (FWH) <highlight><bold>214</bold></highlight> coupled together as shown. MCH <highlight><bold>206</bold></highlight>, ICH <highlight><bold>218</bold></highlight>, and FWH <highlight><bold>214</bold></highlight> may each comprise any suitable circuitry and for one embodiment, are each formed as a separate integrated circuit chip. Chipset <highlight><bold>203</bold></highlight> for other embodiments may comprise any suitable one or more integrated circuit or discrete devices. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> FWH <highlight><bold>214</bold></highlight> may comprise any suitable interface controller to provide a suitable communication link to ICH <highlight><bold>218</bold></highlight>. FWH <highlight><bold>214</bold></highlight> comprises a basic I/O system (BIOS) memory <highlight><bold>216</bold></highlight> to store suitable system BIOS software or firmware. BIOS memory <highlight><bold>216</bold></highlight> may comprise any suitable non-volatile memory such as a flash memory for example. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> MCH <highlight><bold>206</bold></highlight> may comprise a suitable interface controller to provide for any suitable communication link to processor system bus <highlight><bold>208</bold></highlight> and/or to any suitable device or component in communication with MCH <highlight><bold>206</bold></highlight>. MCH <highlight><bold>206</bold></highlight> for one embodiment provides suitable arbitration, buffering, and coherency management for each interface. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> MCH <highlight><bold>206</bold></highlight> is coupled to processor system bus <highlight><bold>208</bold></highlight> and provides an interface to processor(s) <highlight><bold>202</bold></highlight> over the processor system bus <highlight><bold>208</bold></highlight>. Processor(s) <highlight><bold>202</bold></highlight> may, in alternative embodiments of the present invention, be combined with MCH <highlight><bold>206</bold></highlight> to form a single chip. MCH <highlight><bold>206</bold></highlight> for one embodiment also provides an interface to a main memory <highlight><bold>204</bold></highlight> and a graphics controller <highlight><bold>210</bold></highlight> each coupled to MCH <highlight><bold>206</bold></highlight>. Main memory <highlight><bold>204</bold></highlight> is capable of storing data and/or instructions executable on a processor such as processor <highlight><bold>202</bold></highlight> of computer system <highlight><bold>200</bold></highlight> and may comprise any suitable memory such as dynamic random access memory (DRAM) for example. Graphics controller <highlight><bold>210</bold></highlight> controls the display of information on a suitable display <highlight><bold>212</bold></highlight>, such as a cathode ray tube (CRT) or liquid crystal display (LCD) for example, coupled to graphics controller <highlight><bold>210</bold></highlight>. In the illustrated embodiment, MCH <highlight><bold>206</bold></highlight> interfaces with graphics controller <highlight><bold>210</bold></highlight> through an accelerated graphics port. However, it will be appreciated that the present invention may be practiced using any suitable graphics bus or port standard. Graphics controller <highlight><bold>210</bold></highlight> for one embodiment may alternatively be combined with MCH <highlight><bold>206</bold></highlight> to form a single chip. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> MCH <highlight><bold>206</bold></highlight> is also coupled to ICH <highlight><bold>218</bold></highlight> to provide access to ICH <highlight><bold>218</bold></highlight> through a hub interface. ICH <highlight><bold>218</bold></highlight> provides an interface to I/O devices or peripheral components for computer system <highlight><bold>200</bold></highlight>. ICH <highlight><bold>218</bold></highlight> may comprise any suitable interface controller to provide for any suitable communication link to MCH <highlight><bold>206</bold></highlight> and/or to any suitable device or component in communication with ICH <highlight><bold>218</bold></highlight>. ICH <highlight><bold>218</bold></highlight> for one embodiment provides suitable buffering and arbitration for each interface. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> In the illustrated embodiment, computer system <highlight><bold>200</bold></highlight> includes a USB host controller <highlight><bold>252</bold></highlight> according to the present invention for coupling one or more suitable USB devices to computer system <highlight><bold>200</bold></highlight> via ICH <highlight><bold>218</bold></highlight>. ICH <highlight><bold>218</bold></highlight> further provides an interface to a local area network (LAN) controller <highlight><bold>220</bold></highlight>, a mass store device <highlight><bold>222</bold></highlight>, an audio coder/decoder (codec) <highlight><bold>224</bold></highlight> and a modem codec <highlight><bold>226</bold></highlight>. An interface is also provided, through a super I/O controller <highlight><bold>228</bold></highlight> to a keyboard <highlight><bold>230</bold></highlight>, a mouse <highlight><bold>232</bold></highlight>, a floppy disk drive <highlight><bold>234</bold></highlight>, as well as additional devices via one or more standard serial <highlight><bold>238</bold></highlight> or parallel <highlight><bold>236</bold></highlight> ports. LAN controller <highlight><bold>220</bold></highlight> or alternatively modem codec <highlight><bold>226</bold></highlight> may be utilized to couple computer system <highlight><bold>200</bold></highlight> to a suitable communications network via various well-known methods. Audio devices such as speakers, microphones, etc. may be coupled to computer system <highlight><bold>200</bold></highlight> via audio codec <highlight><bold>224</bold></highlight>. Mass store device <highlight><bold>222</bold></highlight> may comprise any suitable device or component to store data and/or instructions such as a tape or fixed disk magnetic storage device, or an optical storage device such as a compact disk (CD) or digital versatile disk (DVD) read only memory (ROM) device. In one embodiment of the present invention, mass store device <highlight><bold>222</bold></highlight> comprises an integrated drive electronics (IDE) hard disk drive (HDD). </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> Interfaces are further provided in the illustrated embodiment to couple one or more suitable peripheral component interconnect (PCI) and industry standard architecture (ISA) devices to computer system <highlight><bold>200</bold></highlight>. A PCI bus <highlight><bold>240</bold></highlight> is provided using a PCI bus bridge <highlight><bold>244</bold></highlight> coupled to ICH <highlight><bold>218</bold></highlight> via a hub/bridge interface. One or more suitable PCI devices may then be coupled to computer system <highlight><bold>200</bold></highlight> via PCI slots <highlight><bold>248</bold></highlight> on the provided PCI bus <highlight><bold>240</bold></highlight>. Similarly, an ISA bus <highlight><bold>242</bold></highlight> is provided via an ISA bridge <highlight><bold>246</bold></highlight> coupled to PCI bus <highlight><bold>240</bold></highlight> enabling one or more suitable ISA devices to be coupled to the computer system <highlight><bold>200</bold></highlight> via one or more ISA slots <highlight><bold>250</bold></highlight>. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> The system of the present invention includes software, information processing hardware, and various processing operations further described herein. The features and process operations of the present invention may be embodied in executable instructions embodied within a machine-readable medium such as main memory <highlight><bold>204</bold></highlight>, mass store device <highlight><bold>222</bold></highlight>, removable disk media coupled with floppy disk drive <highlight><bold>234</bold></highlight>, a communications network available via LAN controller <highlight><bold>220</bold></highlight> or modem codec <highlight><bold>226</bold></highlight>, or the like. A machine-readable medium may include any mechanism that provides (i.e., stores and/or transmits) information in a form readable by a machine (e.g., computer system <highlight><bold>200</bold></highlight>). For example, a machine-readable medium includes read only memory (ROM); random access memory (RAM); magnetic disk storage media; optical storage media; flash memory devices; electrical, optical, acoustical or other form of propagated signals (e.g., carrier waves, infrared signals, digital signals, etc.); etc. The instructions can be used to cause a general purpose or special purpose processor such as processor <highlight><bold>202</bold></highlight>, programmed with the instructions, to perform methods or processes of the present invention. Alternatively, the features or operations of the present invention may be performed by specific hardware components that contain hard-wired logic for performing the operations, or by any combination of programmed computer components and custom hardware components. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> illustrates an interlayer communications model block diagram according to an embodiment of the present invention. In the illustrated diagram, a USB host <highlight><bold>300</bold></highlight> and a USB device <highlight><bold>302</bold></highlight> communicate using a number of interacting communication layers. At a function layer, a client software application <highlight><bold>304</bold></highlight> within USB host <highlight><bold>300</bold></highlight> communicates with a USB function <highlight><bold>306</bold></highlight> within a USB device <highlight><bold>302</bold></highlight> using a set of one or more USB pipes known as a pipe bundle <highlight><bold>310</bold></highlight>. Each pipe of pipe bundle <highlight><bold>310</bold></highlight> is associated with a uniquely addressable portion of a USB device <highlight><bold>302</bold></highlight> that is a source or sink of data in communication flow between a USB host <highlight><bold>300</bold></highlight> and the USB device <highlight><bold>302</bold></highlight> known as an endpoint <highlight><bold>316</bold></highlight>. Each pipe is also associated with a USB transfer type such as isochronous, interrupt, control, or bulk. Together, the set of endpoints associated with pipe bundle <highlight><bold>310</bold></highlight> make up an interface <highlight><bold>308</bold></highlight> for communication between a client software application <highlight><bold>304</bold></highlight> and a particular function <highlight><bold>306</bold></highlight> of USB device <highlight><bold>302</bold></highlight>. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> Isochronous transfers are transfers of isochronous data which occupy a pre-negotiated amount of USB bandwidth with a pre-negotiated delivery latency and are sometimes also called streaming real time transfers. Isochronous data is continuous and real-time in creation, delivery, and consumption. Isochronous data must be delivered at the rate received to maintain its timing. In addition to delivery rate, isochronous data may also be sensitive to delivery delays. A typical example of isochronous data is voice. The timely delivery of isochronous data is ensured at the expense of potential transient losses in the data stream. In other words, any error in transmission is not corrected by hardware mechanisms such as retries. All non-isochronous transfer types involve data which may be queued and retried upon delivery failure or delay. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> Interrupt transfers involve limited-latency data transfer to or from a device. Such data may be presented for transfer by a device at any time and is delivered by the USB at a rate no slower than is specified by the device. Interrupt data typically consists of event notification, characters, or coordinates that are organized as one or more bytes. An example of interrupt data is the coordinates from a pointing or cursor control device. Although an explicit timing rate is not required, interactive data may have response time bounds that the USB must support. Control transfers are used to transfer data used by the USB System Software to configure devices when they are first attached. Lastly, bulk data transfers typically involve large amounts of sequential data, such as that used for printers or scanners where the reliability and accuracy of data transmission is relevant. Reliable exchange of data is ensured using error detection and by invoking a limited number of retries. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> At a USB logical device layer, USB host <highlight><bold>300</bold></highlight> includes USB system software <highlight><bold>312</bold></highlight> according to the present invention and USB device <highlight><bold>302</bold></highlight> includes a USB logical device representation <highlight><bold>314</bold></highlight>. USB system software <highlight><bold>312</bold></highlight> acts as an interface between a client software application and a particular USB host controller hardware implementation to facilitate transfers on the USB and is also responsible for the configuration and control of USB devices. At this layer, USB logical device <highlight><bold>314</bold></highlight> appears to the USB system as a collection of endpoints <highlight><bold>316</bold></highlight> making up the interfaces <highlight><bold>308</bold></highlight> to the various functions <highlight><bold>306</bold></highlight> of the device. In one embodiment, a USB driver (USBD) component of USB system software provides this abstraction to facilitate USB data transfer and utilizes a default control pipe <highlight><bold>318</bold></highlight> to initialize and generically manipulate the USB logical device <highlight><bold>314</bold></highlight> (e.g., to configure the logical device). Each USB device provides input and output endpoints having endpoint number zero to which the default control pipe <highlight><bold>318</bold></highlight> communication channel to USBD is attached. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> When a device is attached and configured, the USBD is involved to ensure that the requested device configuration can be accommodated on the bus. The USBD receives configuration requests from configuring USB software client applications <highlight><bold>304</bold></highlight> that describe the requested device configuration: endpoint(s), transfer type(s), transfer period(s), data size(s), etc. The USBD either accepts or rejects a configuration request based on bandwidth availability and the ability to accommodate that request type on the bus. If it accepts the request, the USBD creates a pipe for the requester of the requested type and with appropriate constraints as defined for the transfer type. Once a device is configured, a software client application <highlight><bold>304</bold></highlight> can make a request, called an I/O request packet (IRP), to move data between itself and an endpoint <highlight><bold>316</bold></highlight> of a USB function on the configured device. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> In one embodiment, USB system software further includes a host controller driver (HCD) component which provides an abstraction of host controller hardware and of the host controller&apos;s view of data transmission over the USB. An HCD serves as an interface between a USB host controller and the USBD software. This interface allows a range of host controller implementations without requiring all client software applications <highlight><bold>304</bold></highlight> to be dependent on any particular implementation. A single USB driver can therefore support different host controllers without requiring specific knowledge of a host controller implementation. The HCD is responsible for tracking client software application-requested IRPs in progress and ensuring that USB bandwidth and (micro)frame time maximums are not exceeded. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> To facilitate this, an HCD administers one or more schedule data structures or &ldquo;transaction lists&rdquo; within the USB system, adding an appropriate work item when a transfer request (IRP) is made by a client software application <highlight><bold>304</bold></highlight> and removing work items where appropriate. When an IRP is complete, the HCD notifies the requesting software client <highlight><bold>304</bold></highlight> of the completion status for the IRP. A schedule data structure is a host controller implementation-dependent description of the current outstanding set of bus transactions that need to be run on the USB. Typically, only the HCD and its host controller have access to the specific schedule representation. Each description contains transaction descriptions in which parameters, such as data size in bytes, the device address and endpoint number, and the memory area to which data is to be sent or received, are identified. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> At a USB bus interface layer, a USB host controller <highlight><bold>320</bold></highlight> according to the present invention within USB host <highlight><bold>300</bold></highlight> is coupled to a USB bus interface <highlight><bold>322</bold></highlight> in USB device <highlight><bold>302</bold></highlight> via a physical USB interconnect <highlight><bold>324</bold></highlight> such as a USB cable, fiber, wireless infrared or radio frequency connection, or the like. All logical communication occurring at the function or logical device layers is provided to the bus interface layer and accomplished using the physical USB interconnect <highlight><bold>324</bold></highlight>. The USB System uses the Host Controller <highlight><bold>320</bold></highlight> to manage data transfers between the host <highlight><bold>300</bold></highlight> and USB devices <highlight><bold>302</bold></highlight>. The USB System, in concert with the host controller <highlight><bold>320</bold></highlight>, performs the translation between the client software application&apos;s view of data transfers and USB transactions appearing on the physical USB interconnect <highlight><bold>324</bold></highlight>. The host controller <highlight><bold>320</bold></highlight> has access to the schedule or &ldquo;transaction list&rdquo; and traverses or processes it to translate it into appropriate bus activity. The host controller <highlight><bold>320</bold></highlight> ensures that the bus access rules defined by the protocol are obeyed, such as inter-packet timings, timeouts, babble, etc. and may also provide a reporting mechanism whereby the status of a transaction (done, pending, halted, etc.) can be obtained. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> illustrates an exemplary schedule data structure layout according to an embodiment of the present invention. In the illustrated embodiment, an asynchronous schedule <highlight><bold>400</bold></highlight> and a periodic schedule <highlight><bold>402</bold></highlight> are provided. Asynchronous schedule <highlight><bold>400</bold></highlight> provides support for asynchronous (control and bulk) transfers on the USB and accordingly includes one or more control and/or bulk transfer queue heads <highlight><bold>426</bold></highlight> and corresponding queue element transfer descriptors <highlight><bold>428</bold></highlight>. Periodic schedule <highlight><bold>402</bold></highlight> provides support for periodic (isochronous and interrupt) transfers on the USB bus and accordingly includes one or more isochronous transfer descriptors <highlight><bold>406</bold></highlight>, interrupt transfer queue heads <highlight><bold>408</bold></highlight>, and interrupt transfer descriptors <highlight><bold>410</bold></highlight>. In one embodiment, both asynchronous schedule <highlight><bold>400</bold></highlight> and periodic schedule <highlight><bold>402</bold></highlight> are constructed and maintained by USB system software. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> Periodic schedule <highlight><bold>402</bold></highlight> may be accessed using one or more operational registers <highlight><bold>404</bold></highlight> and elements of a periodic frame list <highlight><bold>418</bold></highlight>. In the illustrated embodiment, values from a periodic list base address register <highlight><bold>412</bold></highlight> and a frame index register <highlight><bold>414</bold></highlight> stored within an operational register space <highlight><bold>404</bold></highlight> are utilized to reference an element within periodic frame list <highlight><bold>418</bold></highlight>. Periodic list base address register <highlight><bold>412</bold></highlight>, containing the base address of the periodic frame list <highlight><bold>418</bold></highlight> within memory, and frame index register <highlight><bold>414</bold></highlight>, containing a frame index into periodic frame list <highlight><bold>418</bold></highlight>, together form a periodic frame list element address <highlight><bold>416</bold></highlight> of a specific periodic frame list element within memory. Periodic frame list <highlight><bold>418</bold></highlight> is an array of up to 1024 elements which represent a sliding window of periodic schedule work over time. Each entry in periodic frame list <highlight><bold>418</bold></highlight> corresponds to a particular frame (1 millisecond) or micro-frame (125 microseconds) of time and contains a reference to one or more periodic schedule work items which describe the transactions to be executed during that particular time period. A work item may comprise a transfer descriptor, a queue head, or a combination of the two. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> A transfer descriptor expresses the characteristics of a transaction requested on a USB by a client software application. A transfer descriptor typically includes a pointer or reference to a buffer which is to serve as the source or destination for data transfer and may also include status and control data as well as a link pointer or reference to another transfer descriptor or queue head to be executed. A queue head is a data structure which is used to organize non-isochronous (i.e. interrupt, control, or bulk) transfer descriptors. Each queue head contains a &ldquo;horizontal&rdquo; link pointer and a &ldquo;vertical&rdquo; queue element transfer descriptor pointer. A horizontal link pointer may reference another queue head or alternatively a transfer descriptor such as an isochronous transfer descriptor <highlight><bold>406</bold></highlight>. In one embodiment, a queue element transfer descriptor pointer references a transfer descriptor within a linked list of transfer descriptors corresponding to a current transaction in the list or &ldquo;queue&rdquo;. Together a transfer descriptor linked list and its associated queue head make up a transfer queue or &ldquo;queue context&rdquo;. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> At the beginning of each (micro)frame, periodic frame list element address <highlight><bold>416</bold></highlight> is utilized by a host controller to access a periodic schedule work item. The fetched work item is processed or executed and its link pointer, if any, is then utilized to access another work item within the periodic schedule <highlight><bold>402</bold></highlight>. This method is used to traverse the graph of linked periodic schedule data structures from isochronous transfer descriptors <highlight><bold>406</bold></highlight> to interrupt transfer queues comprised of interrupt transfer queue heads <highlight><bold>408</bold></highlight> and interrupt transfer descriptors <highlight><bold>410</bold></highlight> until the current (micro)frame expires or an end of list mark <highlight><bold>420</bold></highlight> is encountered. If an end of list mark <highlight><bold>420</bold></highlight> is encountered before the end of the current (micro)frame, the host controller transitions to executing work items from asynchronous schedule <highlight><bold>400</bold></highlight>. If the periodic schedule is enabled, the host controller must attempt to execute from the periodic schedule <highlight><bold>402</bold></highlight> in each (micro)frame before executing the asynchronous schedule <highlight><bold>400</bold></highlight>. Once the transition is made, the host controller executes from the asynchronous schedule <highlight><bold>400</bold></highlight> until the end of the (micro)frame. Thereafter, in one embodiment, the value of frame index register <highlight><bold>414</bold></highlight> is incremented to reference the next element in periodic frame list <highlight><bold>418</bold></highlight> and the traversal and processing of the periodic <highlight><bold>402</bold></highlight> and asynchronous <highlight><bold>400</bold></highlight> schedules are continued. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> In the illustrated embodiment, asynchronous schedule <highlight><bold>400</bold></highlight> is accessed using a value from an asynchronous list address register <highlight><bold>422</bold></highlight> stored within operational register space <highlight><bold>404</bold></highlight>. Asynchronous address list register <highlight><bold>422</bold></highlight> contains a reference to a bulk or control queue head <highlight><bold>426</bold></highlight> within an asynchronous transfer list <highlight><bold>424</bold></highlight>. Asynchronous transfer list <highlight><bold>424</bold></highlight> is organized as a circular linked list of transfer queues comprised of bulk and/or control queue heads <highlight><bold>426</bold></highlight> and queue element transfer descriptors <highlight><bold>428</bold></highlight> coupled together as shown. In this embodiment of the present invention, asynchronous address list register <highlight><bold>422</bold></highlight> contains a pointer to the next queue head within the asynchronous transfer list <highlight><bold>424</bold></highlight> to be executed. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> When a host controller transitions from periodic <highlight><bold>402</bold></highlight> to asynchronous <highlight><bold>400</bold></highlight> schedule execution, it reads the queue head <highlight><bold>426</bold></highlight> referenced via an asynchronous address list register <highlight><bold>422</bold></highlight> value and begins executing transactions and traversing the asynchronous linked list <highlight><bold>424</bold></highlight> as appropriate. When a host controller encounters a queue head (QH), it caches it internally, and sets internal state to indicate it is in a Q-context. When the host controller &ldquo;completes&rdquo; processing asynchronous schedule <highlight><bold>400</bold></highlight>, it retains the value of the last accessed queue head&apos;s horizontal link pointer in asynchronous list address register <highlight><bold>422</bold></highlight>. The next time asynchronous schedule <highlight><bold>400</bold></highlight> is accessed, the value contained in this register references the first data structure or &ldquo;work item&rdquo; that will be serviced when the schedule&apos;s execution resumes. A host controller &ldquo;completes&rdquo; processing the asynchronous schedule when the host controller detects an empty list condition, the schedule has been disabled, or the end of a (micro)frame occurs. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> In the illustrated embodiment, operational register space <highlight><bold>404</bold></highlight> further includes a USB command register <highlight><bold>430</bold></highlight>, a USB status register <highlight><bold>432</bold></highlight>, and a USB interrupt enable register <highlight><bold>434</bold></highlight> according to the present invention. USB interrupt enable register <highlight><bold>434</bold></highlight> enables and disables reporting of corresponding interrupts to USB system software. When an interrupt enable bit is set and the corresponding interrupt source is active, an interrupt is generated. In one embodiment, USB interrupt enable register <highlight><bold>434</bold></highlight> includes an Interrupt on Async Advance Enable bit to indicate whether an Interrupt on Async Advance interrupt is enabled. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> USB status register <highlight><bold>432</bold></highlight> indicates pending interrupts as well as various host controller states. In one embodiment, USB status register <highlight><bold>432</bold></highlight> includes an Asynchronous Schedule Status bit to report the current real status (i.e. enabled/disabled) of the asynchronous schedule <highlight><bold>400</bold></highlight> and a Periodic Schedule Status bit to report the current real status of the periodic schedule <highlight><bold>402</bold></highlight>. In another embodiment, USB status register <highlight><bold>432</bold></highlight> includes an Interrupt on Async Advance bit which indicates the assertion of an Interrupt on Async Advance interrupt source. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> USB command register <highlight><bold>430</bold></highlight> is utilized as a USB host controller interface for USB system software to indicate a command to be executed by USB host controller hardware. Manipulating or modifying the bits of USB command register <highlight><bold>430</bold></highlight> controls the USB host controller&apos;s ability to process the asynchronous <highlight><bold>400</bold></highlight> and periodic <highlight><bold>402</bold></highlight> schedules, and may by extension cause commands or transactions to be executed on the USB by USB host controller hardware. The bits of USB command register <highlight><bold>430</bold></highlight> are primarily control structures however and do not explicitly control command execution. In one embodiment of the present invention, USB command register includes an Asynchronous Schedule Enable bit which indicates whether or not asynchronous schedule <highlight><bold>400</bold></highlight> is to be processed or &ldquo;executed&rdquo; by a host controller and a Periodic Schedule Enable bit which indicates whether or not periodic schedule <highlight><bold>402</bold></highlight> is to be processed. In another embodiment of the present invention, USB command register <highlight><bold>430</bold></highlight> further includes an Interrupt on Async Advance Doorbell bit to indicate a removal of a work item from asynchronous schedule <highlight><bold>400</bold></highlight>. The information communicated in this bit is a request for USB host controller hardware to indicate when (relative to USB system software setting the bit) all currently cached structures or references to structures have been purged from host controller hardware. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> illustrates a USB host controller block diagram according to an embodiment of the present invention. A USB host controller <highlight><bold>500</bold></highlight> according to one embodiment of the present invention is illustrated coupled to and acting as an interface between a Universal Serial Bus <highlight><bold>502</bold></highlight> and a host bus <highlight><bold>504</bold></highlight> such as PCI bus <highlight><bold>240</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 2</cross-reference>. To facilitate this interface, USB host controller <highlight><bold>500</bold></highlight> includes a USB transceiver <highlight><bold>506</bold></highlight>, a serial interface engine (SIE) <highlight><bold>508</bold></highlight>, a microcontroller <highlight><bold>510</bold></highlight>, an input FIFO (first-in, first-out) buffer <highlight><bold>514</bold></highlight>, an output FIFO buffer <highlight><bold>512</bold></highlight>, a host bus interface <highlight><bold>516</bold></highlight>, and one or more USB registers <highlight><bold>518</bold></highlight>. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> USB transceiver <highlight><bold>506</bold></highlight> acts as a serial data transmitter and receiver and provides a parallel data interface to SIE <highlight><bold>508</bold></highlight>. USB transceiver <highlight><bold>506</bold></highlight> further provides bit stuffing, bit unstuffing, and bit stuff error detection for the USB system. Serial interface engine <highlight><bold>508</bold></highlight> acts as a serializer/deserializer and an interface between FIFOs <highlight><bold>512</bold></highlight>, <highlight><bold>514</bold></highlight> and USB transceiver <highlight><bold>506</bold></highlight>. For data transmitted from the host, SIE <highlight><bold>508</bold></highlight> converts protocol and data information from a host native format to a bit stream transmitted on the USB. For data being received into the host, the reverse operation is performed. In an alternative embodiment, transceiver <highlight><bold>506</bold></highlight> is primarily a physical interconnect translator, handling analog functionality such as edge rates, current drive, output impedance matching, etc. and SIE <highlight><bold>508</bold></highlight> is utilized to handle the serial to parallel and parallel to serial translation, bit stuff/unstuffing. The interface between the SIE <highlight><bold>508</bold></highlight> and transceiver <highlight><bold>506</bold></highlight> in such an embodiment may be a serial or parallel implementation. Input FIFO <highlight><bold>514</bold></highlight> provides intermediate storage for data being transmitted from a client software application specified-buffer on a host to a USB device endpoint. Similarly, output FIFO <highlight><bold>512</bold></highlight> provides intermediate storage for data being transmitted from a device endpoint to a client application buffer. Host bus interface <highlight><bold>516</bold></highlight> provides a high-speed bus-mastering interface between main system memory of a USB host and the input <highlight><bold>514</bold></highlight> and output <highlight><bold>512</bold></highlight> FIFO queues. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> In one embodiment, USB host controller <highlight><bold>500</bold></highlight> includes a register space including configuration registers, capability registers, and operational registers. A configuration register is utilized to properly couple USB host controller <highlight><bold>500</bold></highlight> to a host bus <highlight><bold>504</bold></highlight>. A capability register is utilized to specify the limits, restrictions, and capabilities of a host controller implementation. An operational register is used by USB system software to control and monitor the operational state of the host controller. In one embodiment, capability registers and operational registers reside within a memory-mapped portion of USB host main memory and USB registers <highlight><bold>518</bold></highlight> comprise configuration registers. In an alternative embodiment however, USB registers <highlight><bold>518</bold></highlight> comprise one or more configuration, capability, and/or operational registers. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> In the illustrated embodiment, USB host controller <highlight><bold>500</bold></highlight> further includes a microcontroller <highlight><bold>510</bold></highlight>. Microcontroller <highlight><bold>510</bold></highlight> utilizes and manages the various other components of USB host controller <highlight><bold>500</bold></highlight> to process requests for data transmission to and from its attached USB host and serves as a protocol engine to support the protocol specified by the USB. Microcontroller <highlight><bold>510</bold></highlight> processes or traverses a schedule or &ldquo;transaction list&rdquo; in main memory by sequentially retrieving schedule work items and executing them to generate transactions on USB <highlight><bold>502</bold></highlight>. In one embodiment, microcontroller <highlight><bold>510</bold></highlight> comprises a cache memory <highlight><bold>520</bold></highlight> to store copies of retrieved work items as it traverses and processes a schedule data structure. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> illustrates a USB system software process flow diagram for one embodiment of the present invention. The process <highlight><bold>600</bold></highlight>, illustrated by <cross-reference target="DRAWINGS">FIG. 6</cross-reference>, begins (block <highlight><bold>602</bold></highlight>) and then one or more work items are unlinked from an enabled asynchronous USB schedule (block <highlight><bold>604</bold></highlight>). In the illustrated embodiment, an Interrupt on Async Advance Enable bit within a USB interrupt enable register is referenced to determine whether or not the Interrupt on Async Advance interrupt is enabled (block <highlight><bold>605</bold></highlight>). Thereafter, if it is determined that the Interrupt on Async Advance interrupt is enabled, a command signal is generated by setting an Interrupt on Async Advance Doorbell bit within a USB command register (block <highlight><bold>606</bold></highlight>). Next, it is determined whether a USB host controller has issued a hardware interrupt (block <highlight><bold>608</bold></highlight>). Once this occurs, USB system software determines whether the Interrupt on Async Advance interrupt is active (block <highlight><bold>610</bold></highlight>). In one embodiment, this may be accomplished by reading a value of the Interrupt on Async Advance bit within the USB status register. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> If no interrupt is issued by host controller hardware, or if the Interrupt on Async Advance Interrupt is inactive, the illustrated process remains idle until the Interrupt on Async Advance interrupt is generated. In one embodiment of the present invention, the generation of the Interrupt on Asynch Advance interrupt serves as a coherency signal to notify USB system software that a removed work item may be reclaimed. In another embodiment, a status bit (the Interrupt on Asynch Advance bit within the USB status register) serves as the described coherency signal and USB system software simply polls the Interrupt on Asynch Advance bit to determine when it has been set and consequently when removed work items may be reclaimed. In this embodiment, operations related to the generation of the Interrupt on Asynch Advance interrupt (blocks <highlight><bold>605</bold></highlight>, <highlight><bold>608</bold></highlight>, <highlight><bold>610</bold></highlight>) are not required. Once the coherency signal has been generated however, USB system software reclaims the previously removed work item(s) by freeing or reusing memory or other associated work item resources (block <highlight><bold>612</bold></highlight>). In the illustrated embodiment, USB system software next clears the Interrupt on Async Advance bit within the USB status register to acknowledge the Interrupt on Async Advance interrupt (block <highlight><bold>614</bold></highlight>) after which the process terminates (block <highlight><bold>616</bold></highlight>). It should be appreciated that variations in the order or sequence of the illustrated process <highlight><bold>600</bold></highlight> may be made without departing from the spirit and scope of the present invention. For example, the Interrupt on Asynch Advance may be cleared (block <highlight><bold>614</bold></highlight>) before unlinked work items are reclaimed (block <highlight><bold>612</bold></highlight>) and the Interrupt on Async Advance Enable bit may be referenced (block <highlight><bold>605</bold></highlight>) prior to allowing work items to be removed or unlinked from the Asynchronous schedule (block <highlight><bold>604</bold></highlight>). </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> illustrates a USB host controller flow diagram for one embodiment of the present invention. The illustrated process <highlight><bold>700</bold></highlight> begins, (block <highlight><bold>702</bold></highlight>) and thereafter the USB host controller processes an enabled asynchronous USB schedule (block <highlight><bold>704</bold></highlight>). Although a single process block has been included, it should be appreciated that a USB host controller processes the asynchronous schedule continuously for the duration of the illustrated process <highlight><bold>700</bold></highlight>. Next, the USB host controller determines whether or not an Interrupt on Async Advance Doorbell bit within a USB command register has been set (block <highlight><bold>706</bold></highlight>) which serves as a command signal for USB system software to indicate that the asynchronous schedule has been modified. If so, the process continues and it is determined whether all local copies of, or pointers to removed work items have been evicted or &ldquo;released&rdquo; from USB host controller internal state (block <highlight><bold>708</bold></highlight>). </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> If the Interrupt on Async Advance Doorbell bit has not been set, or if it is determined that a local copy of, or pointer to a removed work item remains in USB host controller cache, the illustrated process <highlight><bold>700</bold></highlight> restarts. Otherwise, the USB host controller generates a status signal by setting an Interrupt on Async Advance bit within the USB status register (block <highlight><bold>710</bold></highlight>). If the Interrupt on Async Advance Enable bit in the USB interrupt enable register indicates that the Interrupt on Async Advance interrupt is enabled, the USB host controller will then assert an interrupt at the next opportunity or &ldquo;interrupt threshold&rdquo; (block <highlight><bold>712</bold></highlight>). In alternative embodiments of the invention, either the status signal or the interrupt itself may serve as a coherency signal to notify USB system software that a removed work item may be reclaimed. Thereafter, the USB host controller waits until USB system software acknowledges the coherency signal by clearing the Interrupt on Async Advance bit (block <highlight><bold>714</bold></highlight>) and then clears the Interrupt on Async Advance Doorbell bit within the USB command register (block <highlight><bold>716</bold></highlight>) before restarting (block <highlight><bold>702</bold></highlight>). </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 8</cross-reference><highlight><italic>a</italic></highlight>-<highlight><bold>8</bold></highlight><highlight><italic>c </italic></highlight>illustrate an asynchronous schedule work item removal and reclamation sequence according to an embodiment of the present invention. In the illustrated embodiment, various states of an asynchronous transfer list <highlight><bold>800</bold></highlight> and USB host controller internal state <highlight><bold>802</bold></highlight> during a removal/reclamation sequence are illustrated. In one embodiment, internal state <highlight><bold>802</bold></highlight> comprises a local copy of a queue head <highlight><bold>804</bold></highlight> stored within a USB host controller cache memory. It will be appreciated that the depicted sequence is illustrated by way of example and not limitation and that embodiments of the present invention may be practiced utilizing any suitable Universal Serial Bus schedule containing any suitable number or type of data structures or work items. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 8</cross-reference><highlight><italic>a</italic></highlight>, queue heads &ldquo;B&rdquo; and &ldquo;C&rdquo; are targeted for removal from asynchronous transfer list <highlight><bold>800</bold></highlight>. Initially, asynchronous transfer list <highlight><bold>800</bold></highlight> includes targeted queue heads (&ldquo;B&rdquo; and &ldquo;C&rdquo;) and the USB host controller internal state <highlight><bold>802</bold></highlight> includes a local copy of queue head &ldquo;A&rdquo; as shown. In <cross-reference target="DRAWINGS">FIG. 8</cross-reference><highlight><italic>b</italic></highlight>, queue heads &ldquo;B&rdquo; and &ldquo;C&rdquo; are removed or &ldquo;unlinked&rdquo; from asynchronous transfer list <highlight><bold>800</bold></highlight> by USB system software. Although it may be shut down prior to removing one or more queue heads, asynchronous transfer list <highlight><bold>800</bold></highlight> is typically left enabled or &ldquo;activated&rdquo; during the removal process. Accordingly, one or more USB host controllers may independently process or &ldquo;traverse&rdquo; the schedule as work items are being removed. As each queue head is removed, its horizontal link pointer is modified to reference a queue head which will remain in the schedule following the unlink operation(s) (e.g. queue head &ldquo;D&rdquo; in the illustrated example). </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> At this point, USB system software is unaware whether USB host controller internal state <highlight><bold>802</bold></highlight> contains a removed schedule work item or a reference to a removed schedule work item (e.g. the cached link pointer of queue head &ldquo;A&rdquo; which references removed queue head &ldquo;B&rdquo;). Similarly, it is unknown how long a USB host controller might retain cached data relating to a removed schedule work item, as it is implementation-dependent and may be affected by the actual dynamics of the schedule load. Therefore, USB system software retains the coherency of each removed queue head (link pointers, etc.) until it determines or is notified that a USB host controller does not contain a local copy of, or a pointer to, any of the removed data structures and consequently that it is safe to reclaim a removed work item without risk of the USB hardware controller executing invalid data structures. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> To determine that it is safe to reclaim a removed work item, USB system software performs a handshake with the USB host controller. Following the removal of one or more queue heads from the asynchronous schedule, an Interrupt on Async Advance Doorbell bit within a USB command register is set by USB system software to indicate that the asynchronous schedule has been altered. In one embodiment, the Interrupt on Async Advance Doorbell bit is used by USB system software to request that the host controller set the Interrupt on Async Advance bit in the USB status register and issue an interrupt the next time the asynchronous schedule is advanced (<cross-reference target="DRAWINGS">FIG. 8</cross-reference><highlight><italic>c</italic></highlight>) following assertion of the Interrupt on Async Advance Doorbell. </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> In another embodiment, once the Interrupt on Async Advance Doorbell bit has been set, the USB host controller identifies which of the asynchronous schedule work items are accessible using the current internal state <highlight><bold>802</bold></highlight>. In <cross-reference target="DRAWINGS">FIG. 8</cross-reference><highlight><italic>b </italic></highlight>of the illustrated example, accessible work items include both queue head &ldquo;A&rdquo; (a copy of which is stored in the USB host controller internal state <highlight><bold>802</bold></highlight>) and queue head &ldquo;B&rdquo; (which is reachable via the cached link pointer of queue head &ldquo;A&rdquo;). The USB host controller then continues to process the asynchronous schedule and once it has traversed beyond current accessible schedule work items (i.e. traversed beyond queue head &ldquo;B&rdquo; as in <cross-reference target="DRAWINGS">FIG. 8</cross-reference><highlight><italic>c </italic></highlight>of the illustrated example) it sets the Interrupt on Async Advance bit in the USB status register. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> In still other alternative embodiments, the USB host controller may set the Interrupt on Async Advance bit in the USB status register in response to a detection of a cache flush operation of a USB host controller cache memory or the removal from USB host controller cache of specific work items identified using tags or other similar identifiers. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> In the foregoing description, the present invention has been described with reference to specific exemplary embodiments thereof. It will be apparent however, that variations or modification of the exemplary embodiments described as well as alternative embodiments of the present invention may be implemented without departing from the broader spirit or scope of the present invention as defined in the appended claims. For example, it should be apparent that the method of the present invention could be implemented with other expansion bus technologies having separate schedules for isochronous and asynchronous transfers. The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method comprising: 
<claim-text>removing a work item of a plurality of work items from an enabled expansion bus schedule data structure; </claim-text>
<claim-text>generating a coherency signal utilizing an expansion bus host controller in response to removing said work item from said enabled expansion bus schedule data structure; and </claim-text>
<claim-text>reclaiming said work item in response to generating said coherency signal. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method as set forth in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein said enabled expansion bus schedule data structure comprises an asynchronous schedule including a plurality of queue heads and removing said work item from said enabled expansion bus schedule data structure comprises unlinking a first queue head of said plurality of queue heads from said asynchronous schedule. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method as set forth in <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, wherein said plurality of queue heads includes a second queue head, said second queue head includes a horizontal link pointer to said first queue head, and unlinking said first queue head from said asynchronous schedule comprises modifying said horizontal link pointer of said second queue head. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method as set forth in <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, said method further comprising: 
<claim-text>generating a command signal in response to removing said work item from said enabled expansion bus schedule data structure; wherein, 
<claim-text>generating a coherency signal utilizing an expansion bus host controller in response to removing said work item from said enabled expansion bus schedule data structure comprises generating a status signal utilizing said expansion bus host controller in response to generating said command signal. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method as set forth in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein generating a coherency signal utilizing an expansion bus host controller in response to removing said work item from said enabled expansion bus schedule data structure comprises: 
<claim-text>traversing said plurality of work items according to a sequence; </claim-text>
<claim-text>storing a copy of a work item within a memory in response to traversing said plurality of work items; and </claim-text>
<claim-text>generating a coherency signal utilizing said copy of said work item. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method as set forth in <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference>, wherein generating a coherency signal utilizing said copy of said work item comprises: 
<claim-text>detecting a removal of said copy of said work item from said memory in response to removing said work item from said enabled expansion bus schedule data structure; and </claim-text>
<claim-text>generating a coherency signal in response to detecting said removal of said copy of said work item from said memory. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The method as set forth in <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference>, wherein detecting a removal of said copy of said work item from said memory in response to removing said work item from said enabled expansion bus schedule data structure comprises detecting a cache flush operation. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The method as set forth in <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference>, wherein generating a coherency signal utilizing said copy of said work item comprises: 
<claim-text>identifying an accessible work item of said plurality of work items utilizing said copy of said work item; and </claim-text>
<claim-text>generating a coherency signal in response to traversing beyond said accessible work item in said sequence. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The method as set forth in <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference>, said method further comprising: 
<claim-text>executing a transaction on a Universal Serial Bus in response to traversing said plurality of work items. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The method as set forth in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, said method further comprising storing each of said plurality of work items within a memory, wherein reclaiming said work item in response to generating said coherency signal comprises freeing a portion of said memory associated with said work item. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. A machine-readable medium that provides instructions which when executed by a machine cause said machine to perform operations comprising: 
<claim-text>removing a work item of a plurality of work items from an enabled expansion bus schedule data structure; </claim-text>
<claim-text>generating a coherency signal utilizing an expansion bus host controller in response to removing said work item from said enabled expansion bus schedule data structure; and </claim-text>
<claim-text>reclaiming said work item in response to generating said coherency signal. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The machine-readable medium as set forth in <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, wherein said enabled expansion bus schedule data structure comprises an asynchronous schedule including a plurality of queue heads and removing said work item from said enabled expansion bus schedule data structure comprises unlinking a first queue head of said plurality of queue heads from said asynchronous schedule. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The machine-readable medium as set forth in <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, wherein said plurality of queue heads includes a second queue head, said second queue head includes a horizontal link pointer to said first queue head, and unlinking said first queue head from said asynchronous schedule comprises modifying said horizontal link pointer of said second queue head. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The machine-readable medium as set forth in <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, said operations further comprising: 
<claim-text>generating a command signal in response to removing said work item from said enabled expansion bus schedule data structure; wherein, 
<claim-text>generating a coherency signal utilizing an expansion bus host controller in response to removing said work item from said enabled expansion bus schedule data structure comprises generating a status signal utilizing said expansion bus host controller in response to generating said command signal. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The machine-readable medium as set forth in <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, wherein generating a coherency signal utilizing an expansion bus host controller in response to removing said work item from said enabled expansion bus schedule data structure comprises: 
<claim-text>traversing said plurality of work items according to a sequence; </claim-text>
<claim-text>storing a copy of a work item within a memory in response to traversing said plurality of work items; and </claim-text>
<claim-text>generating a coherency signal utilizing said copy of said work item. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The machine-readable medium as set forth in <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference>, wherein generating a coherency signal utilizing said copy of said work item comprises: 
<claim-text>detecting a removal of said copy of said work item from said memory in response to removing said work item from said enabled expansion bus schedule data structure; and </claim-text>
<claim-text>generating a coherency signal in response to detecting said removal of said copy of said work item from said memory. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The machine-readable medium as set forth in <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, wherein detecting a removal of said copy of said work item from said memory in response to removing said work item from said enabled expansion bus schedule data structure comprises detecting a cache flush operation. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The machine-readable medium as set forth in <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference>, wherein generating a coherency signal utilizing said copy of said work item comprises: 
<claim-text>identifying an accessible work item of said plurality of work items utilizing said copy of said work item; and </claim-text>
<claim-text>generating a coherency signal in response to traversing beyond said accessible work item in said sequence. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The machine-readable medium as set forth in <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference>, said operations further comprising: 
<claim-text>executing a transaction on a Universal Serial Bus in response to traversing said plurality of work items. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The machine-readable medium as set forth in <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, said operations further comprising storing each of said plurality of work items within a memory, wherein reclaiming said work item in response to generating said coherency signal comprises freeing a portion of said memory associated with said work item. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. An apparatus comprising: 
<claim-text>a command register including a command signal bit to indicate a removal of a work item from an expansion bus schedule data structure including a plurality of work items; </claim-text>
<claim-text>a status register including a status signal bit to notify an expansion bus host controller driver that said work item may be reclaimed; and </claim-text>
<claim-text>a microcontroller to process said expansion bus schedule data structure and to modify said status signal bit of said status register in response to said removal of said work item from said expansion bus schedule data structure. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The apparatus as set forth in <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference>, wherein said expansion bus schedule data structure comprises a Universal Serial Bus (USB) asynchronous schedule. </claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The apparatus as set forth in <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference>, further comprising a cache memory to store a copy of a work item; wherein said microcontroller to process said expansion bus schedule data structure and to modify said status signal bit of said status register comprises: 
<claim-text>a microcontroller to traverse said plurality of work items according to a sequence, to store said copy of said work item within said cache memory, and to modify said status signal bit of said status register utilizing said copy of said work item. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The apparatus as set forth in <dependent-claim-reference depends_on="CLM-00022">claim 23</dependent-claim-reference>, wherein said microcontroller to modify said status signal bit of said status register utilizing said copy of said work item comprises: 
<claim-text>a microcontroller to modify said status signal bit of said status register in response to a removal of said copy of said work item from said cache memory. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. The apparatus as set forth in <dependent-claim-reference depends_on="CLM-00022">claim 24</dependent-claim-reference>, wherein said microcontroller to modify said status signal bit of said status register in response to a removal of said copy of said work item from said cache memory comprises a microcontroller to modify said status signal bit of said status register in response to a cache flush operation. </claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. The apparatus as set forth in <dependent-claim-reference depends_on="CLM-00022">claim 23</dependent-claim-reference>, wherein said microcontroller to modify said status signal bit of said status register utilizing said copy of said work item comprises: 
<claim-text>a microcontroller to identify an accessible work item of said plurality of work items utilizing said copy of said work item and to modify said status signal bit of said status register in response to a traversal beyond said accessible work item in said sequence. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. A computer system comprising: 
<claim-text>a memory to store an expansion bus schedule data structure including a plurality of work items; </claim-text>
<claim-text>an expansion bus host controller comprising: 
<claim-text>a command register including a command signal bit; </claim-text>
<claim-text>a status register including a status signal bit; and </claim-text>
<claim-text>a microcontroller to process said expansion bus schedule data structure and to modify said status signal bit of said status register in response to a modification of said command signal bit; and </claim-text>
</claim-text>
<claim-text>a processor to remove a work item of said plurality of work items from said expansion bus schedule data structure, to modify said command signal bit in response to said removal of said work item from said expansion bus schedule data structure; and to reclaim said work item in response to a modification of said status signal bit. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. The computer system as set forth in <dependent-claim-reference depends_on="CLM-00022">claim 27</dependent-claim-reference>, wherein said expansion bus host controller further comprises a cache memory to store a copy of a work item and said microcontroller to process said expansion bus schedule data structure and to modify said status signal bit of said status register comprises: 
<claim-text>a microcontroller to traverse said plurality of work items according to a sequence, to store said copy of said work item within said cache memory, and to modify said status signal bit of said status register utilizing said copy of said work item. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00029">
<claim-text><highlight><bold>29</bold></highlight>. The computer system as set forth in <dependent-claim-reference depends_on="CLM-00022">claim 28</dependent-claim-reference>, wherein said microcontroller to modify said status signal bit of said status register utilizing said copy of said work item comprises: 
<claim-text>a microcontroller to modify said status signal bit of said status register in response to a removal of said copy of said work item from said cache memory. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00030">
<claim-text><highlight><bold>30</bold></highlight>. The computer system as set forth in <dependent-claim-reference depends_on="CLM-00022">claim 28</dependent-claim-reference>, wherein said microcontroller to modify said status signal bit of said status register utilizing said copy of said work item comprises: 
<claim-text>a microcontroller to identify an accessible work item of said plurality of work items utilizing said copy of said work item and to modify said status signal bit of said status register in response to a traversal beyond said accessible work item in said sequence.</claim-text>
</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>1</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005197A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005197A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005197A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005197A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005197A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005197A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030005197A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030005197A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030005197A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
