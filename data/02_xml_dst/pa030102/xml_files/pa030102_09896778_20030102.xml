<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030004930A1-20030102-D00000.TIF SYSTEM "US20030004930A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030004930A1-20030102-D00001.TIF SYSTEM "US20030004930A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030004930A1-20030102-D00002.TIF SYSTEM "US20030004930A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030004930A1-20030102-D00003.TIF SYSTEM "US20030004930A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030004930A1-20030102-D00004.TIF SYSTEM "US20030004930A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030004930A1-20030102-D00005.TIF SYSTEM "US20030004930A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030004930A1-20030102-D00006.TIF SYSTEM "US20030004930A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030004930A1-20030102-D00007.TIF SYSTEM "US20030004930A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030004930A1-20030102-D00008.TIF SYSTEM "US20030004930A1-20030102-D00008.TIF" NDATA TIF>
<!ENTITY US20030004930A1-20030102-D00009.TIF SYSTEM "US20030004930A1-20030102-D00009.TIF" NDATA TIF>
<!ENTITY US20030004930A1-20030102-D00010.TIF SYSTEM "US20030004930A1-20030102-D00010.TIF" NDATA TIF>
<!ENTITY US20030004930A1-20030102-D00011.TIF SYSTEM "US20030004930A1-20030102-D00011.TIF" NDATA TIF>
<!ENTITY US20030004930A1-20030102-D00012.TIF SYSTEM "US20030004930A1-20030102-D00012.TIF" NDATA TIF>
<!ENTITY US20030004930A1-20030102-D00013.TIF SYSTEM "US20030004930A1-20030102-D00013.TIF" NDATA TIF>
<!ENTITY US20030004930A1-20030102-D00014.TIF SYSTEM "US20030004930A1-20030102-D00014.TIF" NDATA TIF>
<!ENTITY US20030004930A1-20030102-D00015.TIF SYSTEM "US20030004930A1-20030102-D00015.TIF" NDATA TIF>
<!ENTITY US20030004930A1-20030102-D00016.TIF SYSTEM "US20030004930A1-20030102-D00016.TIF" NDATA TIF>
<!ENTITY US20030004930A1-20030102-D00017.TIF SYSTEM "US20030004930A1-20030102-D00017.TIF" NDATA TIF>
<!ENTITY US20030004930A1-20030102-D00018.TIF SYSTEM "US20030004930A1-20030102-D00018.TIF" NDATA TIF>
<!ENTITY US20030004930A1-20030102-D00019.TIF SYSTEM "US20030004930A1-20030102-D00019.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030004930</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09896778</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010629</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F007/00</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>707</class>
<subclass>002000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Software and method for performing database operations</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Sharon</given-name>
<middle-name>E.</middle-name>
<family-name>Minder</family-name>
</name>
<residence>
<residence-us>
<city>Delray Beach</city>
<state>FL</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Teresa</given-name>
<middle-name>M.</middle-name>
<family-name>Beck</family-name>
</name>
<residence>
<residence-us>
<city>Sunrise</city>
<state>FL</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<assignee>
<organization-name>INTERNATIONAL BUSINESS MACHINES CORPORATION</organization-name>
<address>
<city>ARMONK</city>
<state>NY</state>
<country>
<country-code>US</country-code>
</country>
</address>
<assignee-type>02</assignee-type>
</assignee>
<correspondence-address>
<name-1>FLEIT, KAIN, GIBBONS,</name-1>
<name-2>GUTMAN &amp; BONGINI, P.L.</name-2>
<address>
<address-1>ONE BOCA COMMERCE CENTER</address-1>
<address-2>551 NORTHWEST 77TH STREET, SUITE 111</address-2>
<city>BOCA RATON</city>
<state>FL</state>
<postalcode>33487</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">Elements of one or more database manipulation language (DML) commands strings are stored in tables, read from those tables and DML commands are generated. Storing these command elements in tables facilitates access to and modification of database commands used in data processing applications. Temporary storage control elements are also stored in and read from those tables. The DML query command string is executed, the retrieved data is stored in temporary storage as specified by the temporary storage control elements and is bound to the parameters to the DML storage command strings which are executed to modify target database tables. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">PARTIAL WAIVER OF COPYRIGHT </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> All of the material in this patent application is subject to copyright protection under the copyright laws of the United States and other countries. As of the first effective filing date of the present application, this material is protected as unpublished material. However, permission to copy this material is hereby granted to the extent that the copyright owner has no objection to the facsimile reproduction by anyone of the patent documentation or patent disclosure, as it appears in the United States Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever. </paragraph>
</section>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> 1. Field of the Invention </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> The present invention relates to databases, and more specifically to software, systems, and methods for improving the accessibility of databases. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> 2. Description of Related Art </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> Databases, including relational databases in which data is stored in a plurality of interrelated tables, are one of the cornerstones of information technology. A relational database is composed of a number of interrelated tables. A relational database is characterized by a schema, which is a set of interrelationships between its component tables. The dominant standard for database querying languages is the Structured Query Language (SQL). The Data Manipulation Language (DML) component of SQL includes the following query language commands: SELECT, UPDATE, INSERT, and DELETE. These core commands which appear in numerous variations are used to specify how data in an SQL relational database is to be manipulated. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> Sequences of SQL commands can be arranged in SQL scripts and processed by an SQL database application. As an alternative to SQL scripts, some database applications provide an Application Program Interface (API) that allows an external program to issue an SQL query to the database application. The external applications can include the SQL query within its compiled code. The drawback of including SQL queries in compiled code is that programming skill and time are required to make any needed modifications. Certain new programming technologies such as the Java Database Connectivity (JDBC) package for Java (by Sun Microsystems of Palo Alto, Calif.) allow an SQL query that is stored as a string to be passed to a database application for execution, and for results to be returned for processing by a Java program. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> A SQL query can be quite complicated, involving a number of command tokens, and a number of arguments interspersed between the command tokens. Moreover, a process of extracting data from a database often involves a series of interrelated queries. When making changes to complicated interrelated series of SQL queries, careful attention must be paid to the rules of syntax. The task of editing a large set of complicated interdependent SQL queries is time consuming and requires a high level of expertise. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> One application of relational databases that often calls for the use of such a series of interrelated queries is data mining. A data mining application can be used to extract useful information from a very large amount of raw data. For example, a data mining application can </paragraph>
<paragraph id="P-0009" lvl="2"><number>&lsqb;0009&rsqb;</number> be run on the large amount of data that is generated by computers monitoring operator assistance calls, in order to generate useful information such as call statistics. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> The present invention provides a method and machine readable medium with a program that allows table driven data access and data manipulation of data stored in relational database tables. The present invention provides a method that reads a first plurality of elements of a query from a first set of one or more tables and then assembles a database query string from that first plurality of elements. The present invention may optionally read a second plurality of elements of a query from a second set of one or more tables and then assemble a data base table storage command string from that second plurality of elements. The database table storage command string maybe used to store data that was retrieved by executing the query string. The order in which the data base table storage command string stores the data may also be defined by the first and second plurality of elements.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a block diagram of an exemplary computer system that can be used in practicing the present invention. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a block diagram of a software system according to a preferred embodiment of the present invention. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is an example Table Definition Table according to one embodiment of the present invention. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> shows sample Field Definition Tables according example embodiments of the present invention. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a flow chart of a process for performing database operations according to one embodiment of the present invention. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5A</cross-reference> illustrates the data flow and processing of data in an example database according to one embodiment of the present invention. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference>B<highlight><bold>1</bold></highlight> illustrates an example SELECT clause used to read an example Field Definition Table and a portion of the processing performed to extract data from the resulting result set used to construct a SELECT clause for one or more source data tables. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference>B<highlight><bold>2</bold></highlight> diagrammatically illustrates the processing performed on the result set data that is defined in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>B<highlight><bold>1</bold></highlight>. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference>B<highlight><bold>3</bold></highlight> shows another example SELECT clause used to retrieve data from a Field Definition Table and a portion of the processing performed to extract data from the resulting result set that is used to construct the Group-By clause within the SELECT command for one or more source data tables. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference>B<highlight><bold>4</bold></highlight> diagrammatically illustrates the processing performed on the result set data that is defined in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>B<highlight><bold>3</bold></highlight>. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference>C<highlight><bold>1</bold></highlight> illustrates an example SELECT clause used to read an example Field Definition Table and a portion of the processing performed to extract the data from the resulting result set in order to construct the SET clause within the UPDATE command to be executed on a target data table. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference>C<highlight><bold>2</bold></highlight> diagrammatically illustrates the processing performed on the result set data that is defined in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>C<highlight><bold>1</bold></highlight>. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference>C<highlight><bold>3</bold></highlight> shows another example SELECT clause used to retrieve data from a Field Definition Table and a portion of the processing performed to extract data from the resulting result set that is used to construct the WHERE clause within the UPDATE command to be executed on a target data table. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference>C<highlight><bold>4</bold></highlight> diagrammatically illustrates the processing performed on the result set data that is defined in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>C<highlight><bold>3</bold></highlight>. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference>D<highlight><bold>1</bold></highlight> illustrates an example SELECT clause used to read an example Field Definition Table and a portion of the processing performed to extract the data from the resulting result set in order to build an INSERT command to be executed on a target data table. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference>D<highlight><bold>2</bold></highlight> diagrammatically illustrates the processing performed on the result set data that is defined in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>D<highlight><bold>1</bold></highlight>. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference>A<highlight><bold>1</bold></highlight> is a pseudo code schematic of a process for constructing a SELECT query string from the contents of tables according to an exemplary embodiment of the present invention. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference>A<highlight><bold>2</bold></highlight> is an example SELECT string constructed according to <cross-reference target="DRAWINGS">FIG. 6</cross-reference>A<highlight><bold>1</bold></highlight>. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference>B<highlight><bold>1</bold></highlight> is a pseudo code schematic of a process for constructing an UPDATE command string from the contents of tables according to an exemplary embodiment of the present invention. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference>B<highlight><bold>2</bold></highlight> is an example UPDATE string constructed according to <cross-reference target="DRAWINGS">FIG. 6</cross-reference>B<highlight><bold>1</bold></highlight>. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference>C<highlight><bold>1</bold></highlight> is pseudo code schematic of a process for constructing an INSERT command string from the contents of tables according to an exemplary embodiment of the present invention. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference>C<highlight><bold>2</bold></highlight> is an example INSERT string constructed according to <cross-reference target="DRAWINGS">FIG. 6</cross-reference>C<highlight><bold>1</bold></highlight>. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference>A and <cross-reference target="DRAWINGS">FIG. 7B</cross-reference> illustrate the processing flow used to transfer into internal data storage the data in the result set that was retrieved from the source data tables. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference>A<highlight><bold>1</bold></highlight>, <cross-reference target="DRAWINGS">FIG. 8</cross-reference>A<highlight><bold>2</bold></highlight>, <cross-reference target="DRAWINGS">FIG. 8</cross-reference>A<highlight><bold>3</bold></highlight> and <cross-reference target="DRAWINGS">FIG. 8</cross-reference>A<highlight><bold>4</bold></highlight> illustrate the processing used to bind the parameters of the Update Command string to the data stored in the internal data structures created with the processing illustrated in <cross-reference target="DRAWINGS">FIG. 7</cross-reference>A and <cross-reference target="DRAWINGS">FIG. 7B</cross-reference>. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference>A and <cross-reference target="DRAWINGS">FIG. 9B</cross-reference> illustrate the processing used to bind the parameters of the Values Clause <highlight><bold>650</bold></highlight> of the Insert Command string to the data stored in the internal data structures created with the processing illustrated in <cross-reference target="DRAWINGS">FIG. 7</cross-reference>A and <cross-reference target="DRAWINGS">FIG. 7B</cross-reference>.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF PREFERRED EMBODIMENTS </heading>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> Objects, features, and advantages of the present invention will become apparent from the following detailed description. It should be understood, however, that the detailed description and specific examples, while indicating preferred embodiments of the present invention, are given by way of illustration only and various modifications may naturally be performed without deviating from the present invention. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> The present invention can be carried out using a programmed general purpose computer. <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a block diagram of such a computer <highlight><bold>100</bold></highlight> that can be used in practicing the present invention. The computer <highlight><bold>100</bold></highlight> includes a microprocessor <highlight><bold>102</bold></highlight>, Random Access Memory (RAM) <highlight><bold>104</bold></highlight>, Read Only Memory (ROM) <highlight><bold>106</bold></highlight>, a data storage device in the form of a hard disk drive <highlight><bold>108</bold></highlight>, a display adapter <highlight><bold>110</bold></highlight> (e.g., a video card), a removable computer-readable medium reader <highlight><bold>114</bold></highlight>, a network adapter <highlight><bold>116</bold></highlight>, keyboard <highlight><bold>118</bold></highlight>, and an I/O port <highlight><bold>120</bold></highlight> that is communicatively coupled to a digital signal bus <highlight><bold>126</bold></highlight>. A video monitor <highlight><bold>112</bold></highlight> is coupled to the display adapter <highlight><bold>110</bold></highlight> for receiving a video signal. A pointing device <highlight><bold>122</bold></highlight> such as a mouse is coupled to the I/O port <highlight><bold>120</bold></highlight> that receives signals generated by user operation of the pointing device <highlight><bold>122</bold></highlight>. According to one embodiment, the network adapter <highlight><bold>116</bold></highlight> is used to communicatively couple the computer to an external source of data (e.g., a remote server). The computer-readable medium reader <highlight><bold>114</bold></highlight> can comprise a Compact Disk (CD) drive. A removable computer-readable medium <highlight><bold>124</bold></highlight> is provided for loading software <highlight><bold>124</bold></highlight> onto the computer <highlight><bold>100</bold></highlight> to configure the computer <highlight><bold>100</bold></highlight> to carry out desired processes. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a block diagram of a software system <highlight><bold>200</bold></highlight> according to a preferred embodiment of the present invention. The software system includes a data processing application <highlight><bold>202</bold></highlight>. The functioning of the data processing application <highlight><bold>202</bold></highlight> is discussed below with reference to the flow charts. In general terms, the data processing application reads a plurality of query statement elements (preferably in SQL form) from one or more query element tables <highlight><bold>218</bold></highlight>, assembles corresponding query statements from the query statement elements, and causes the query statements to be executed by a query database search engine <highlight><bold>214</bold></highlight>. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> According to one embodiment of the present invention, the data processing application operates along with a search engine application program interface (API) <highlight><bold>212</bold></highlight> through middleware <highlight><bold>204</bold></highlight>, <highlight><bold>208</bold></highlight>, and <highlight><bold>210</bold></highlight>. According to a preferred embodiment of the present invention, the middleware includes a Java Data Base Connectivity module <highlight><bold>208</bold></highlight> (JDBC) that has a JDBC API <highlight><bold>204</bold></highlight> and a database specific driver <highlight><bold>210</bold></highlight>. The database specific driver <highlight><bold>210</bold></highlight> communicates with a search engine API <highlight><bold>212</bold></highlight>. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> The database search engine <highlight><bold>214</bold></highlight> accesses one or more relational database tables <highlight><bold>216</bold></highlight>. As shown in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, the database tables include table one <highlight><bold>216</bold></highlight>A, table two <highlight><bold>216</bold></highlight>B, and so on up to an nth table <highlight><bold>216</bold></highlight>C. The number of tables is database dependent. The relational database tables <highlight><bold>216</bold></highlight> can be stored on the hard disk drive or a remote data storage device. The remote storage device may reside in another computer that is accessed through a network via the network adapter <highlight><bold>116</bold></highlight>. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> According to an embodiment of the present invention, the query element tables <highlight><bold>218</bold></highlight> include a Table Definition Table (TDT) <highlight><bold>220</bold></highlight> and a plurality of Field Definition Tables (FDTs) <highlight><bold>222</bold></highlight>A, <highlight><bold>222</bold></highlight>B, and <highlight><bold>222</bold></highlight>C. The TDT and FDTs can be stored on a computer-readable medium (such as the removable computer-readable medium <highlight><bold>124</bold></highlight>) or the hard disk drive <highlight><bold>108</bold></highlight>. These tables can be stored in any format including Relational Database Tables. The TDT and FDTs can be accessed and modified using any of a number of commercially available programs for editing tables. They facilitate modification of a database table and obviate the need to edit and recompile source code in order to make modification to queries that would be issued by a data processing program that issues SQL commands. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> The TDT <highlight><bold>220</bold></highlight> includes a plurality of rows. Each row of the TDT <highlight><bold>220</bold></highlight> includes DML command information (e.g., identification of one or more DML commands to be executed, identification of tables to which the one or more DML commands are to be applied, and identification of FDTs from which lists of command arguments for each DML command are to be obtained). Rows of a table are a form of record, and entries in a row are a form of data field. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> depicts a TDT <highlight><bold>220</bold></highlight> according to an exemplary embodiment of the present invention. As shown in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>, each row of the TDT <highlight><bold>220</bold></highlight> includes information for a series of DML commands (i.e., a SELECT command and an INSERT and/or UPDATE and/or INSERT command). Referring to <cross-reference target="DRAWINGS">FIG. 3, a</cross-reference> Target Table Name column <highlight><bold>302</bold></highlight> specifies the name of each table that is to be modified (e.g., by an UPDATE and/or INSERT command) with results obtained from one or more source tables. A Query Table Name column <highlight><bold>304</bold></highlight> includes names of source tables from which data is to be obtained (e.g., by using a SELECT command). It is to be noted that multiple tables maybe specified if multiple table operations are to be performed, such as a SQL &ldquo;JOIN&rdquo; operation. A Query Search Clause column <highlight><bold>306</bold></highlight> includes selection criteria (e.g., SELECT command WHERE clause arguments) that are to be used in selecting data from the one or many source tables named in the corresponding row of the Query Table Name column <highlight><bold>304</bold></highlight>. The Query Search Clause column <highlight><bold>306</bold></highlight> may contain selection criteria reflecting multiple source tables if a multiple source tables are specified. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> A Target Action column <highlight><bold>308</bold></highlight> indicates a type of action to be performed in modifying the table named in the Target Table Name column <highlight><bold>302</bold></highlight> (e.g., UPDATE or INSERT or UPDATE/INSERT). A Fielddef Table Name column <highlight><bold>310</bold></highlight> identifies by name an FDT (e.g., <highlight><bold>222</bold></highlight>A, <highlight><bold>222</bold></highlight>B, <highlight><bold>222</bold></highlight>C) that includes additional information to be used in composing and processing query, update and/or insert statements for each table in each row of the TDT <highlight><bold>220</bold></highlight>. The additional information includes lists of DML command arguments. These arguments are arranged in columns of each FDT. The Table Seq column <highlight><bold>312</bold></highlight> includes row numbers for the TDT <highlight><bold>220</bold></highlight> to ensure that the TDT entries are processed in the proper order. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> shows three exemplary FDTs <highlight><bold>400</bold></highlight>, <highlight><bold>420</bold></highlight>, and <highlight><bold>440</bold></highlight> that can be used in conjunction with the TDT <highlight><bold>220</bold></highlight> shown in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>. The FDTs <highlight><bold>400</bold></highlight>, <highlight><bold>420</bold></highlight>, and <highlight><bold>440</bold></highlight> include Target Field Name columns <highlight><bold>402</bold></highlight>, <highlight><bold>422</bold></highlight>, and <highlight><bold>442</bold></highlight>, each of which names one field of a table named in the Target Table Name column <highlight><bold>302</bold></highlight> that is to be modified based on data in a column retrieved by a query performed on one or more tables named in the Query Table Name column <highlight><bold>304</bold></highlight>. The entries in each Target Field Name column are used to identify each row in the FDT table. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> The FDTs <highlight><bold>400</bold></highlight>, <highlight><bold>420</bold></highlight>, and <highlight><bold>440</bold></highlight> include Query Select Clause columns <highlight><bold>404</bold></highlight>, <highlight><bold>424</bold></highlight>, and <highlight><bold>444</bold></highlight>, each of which specifies a field of the one or more tables named in the Query Table Name column <highlight><bold>304</bold></highlight> from which data is to be selected. As shown in FDT <highlight><bold>420</bold></highlight>, the Query Select Clause column <highlight><bold>424</bold></highlight> can also include column operation commands (e.g., &lsquo;SUM(Calls)&rsquo;) or operations upon one or more fields that result in a single column. The Query Select Clause column may also contain field specifications that reflect multiple source tables if multiple source table operations are performed, such as SQL &ldquo;JOIN&rdquo; operations. The contents of the Query Select Clause columns <highlight><bold>404</bold></highlight>, <highlight><bold>424</bold></highlight> and <highlight><bold>444</bold></highlight> are used as arguments to a SELECT command. The FDTs <highlight><bold>400</bold></highlight>, <highlight><bold>420</bold></highlight>, and <highlight><bold>440</bold></highlight> also include Query Group by Clause columns <highlight><bold>406</bold></highlight>, <highlight><bold>426</bold></highlight>, and <highlight><bold>446</bold></highlight>, each of which specifies a field in the one or more tables named in the Query Table Name column <highlight><bold>304</bold></highlight> that are used to group records with common entries, for the purpose of column operations. The entries in each of the Query Group by Clause columns <highlight><bold>406</bold></highlight>, <highlight><bold>426</bold></highlight>, and <highlight><bold>446</bold></highlight> are used as arguments in SELECT command GROUP BY clauses. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> The FDTs <highlight><bold>400</bold></highlight>, <highlight><bold>420</bold></highlight>, and <highlight><bold>440</bold></highlight> also include Update Set Clause columns <highlight><bold>408</bold></highlight>, <highlight><bold>428</bold></highlight>, and <highlight><bold>448</bold></highlight>, each of which can include identifications of a field that is to be modified. The field can be modified by resetting it to a new value, or by combining the new value with the existing value by a mathematical calculation such as addition. The entries in the Update Set Clause columns are used as arguments of a SET clause of a UPDATE command. Update Where Clause columns <highlight><bold>410</bold></highlight>, <highlight><bold>430</bold></highlight>, and <highlight><bold>450</bold></highlight> include field matching criteria used in combination via AND logic to locate each record in a target table that is to be updated as specified in the Update Set Clause columns. The entries in the Update Where Clause columns <highlight><bold>410</bold></highlight>, <highlight><bold>430</bold></highlight>, and <highlight><bold>450</bold></highlight> include arguments for UPDATE command WHERE clauses. Insert Field Clause columns <highlight><bold>412</bold></highlight>, <highlight><bold>432</bold></highlight>, and <highlight><bold>452</bold></highlight> each name the field into which data is to be inserted by INSERT commands. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> Field Java Type columns <highlight><bold>414</bold></highlight>, <highlight><bold>434</bold></highlight>, and <highlight><bold>454</bold></highlight> include entries that indicate the Java data type of internal variables used to store each column of data retrieved from the one or more tables named in the Query Table Name column and used to locate each record to modify and then modify it. Select Field Sequence &num; columns <highlight><bold>416</bold></highlight>, <highlight><bold>436</bold></highlight> and <highlight><bold>456</bold></highlight> indicate which internal variables are to be used to update fields. A single column of retrieved data can be used to update multiple fields. Target Field Sequence &num; columns <highlight><bold>418</bold></highlight>, <highlight><bold>438</bold></highlight> and <highlight><bold>458</bold></highlight> are used to make sure that the rows of the FDTs are processed in the correct order. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a flow chart of a process for performing database operations according to one embodiment of the present invention. The processing illustrated in <cross-reference target="DRAWINGS">FIG. 5</cross-reference> includes processing both SQL UPDATE and INSERT commands. A subset of the processing illustrated in <cross-reference target="DRAWINGS">FIG. 5</cross-reference> maybe performed according to the processing required by a particular application. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> In step <highlight><bold>502</bold></highlight> of the processing flow illustrated in <cross-reference target="DRAWINGS">FIG. 5, a</cross-reference> JDBC driver manager is loaded. The JDBC driver manager manages the database specific driver <highlight><bold>210</bold></highlight>. In step <highlight><bold>504</bold></highlight>, the JDBC driver <highlight><bold>210</bold></highlight> is used to open a connection between the SQL Query database search engine <highlight><bold>214</bold></highlight> and the data processing application program <highlight><bold>202</bold></highlight>. In step <highlight><bold>506</bold></highlight>, entries are read from the TDT <highlight><bold>220</bold></highlight>. In step <highlight><bold>508</bold></highlight>, entries are read from one or more FDTs <highlight><bold>400</bold></highlight>, <highlight><bold>420</bold></highlight>, and <highlight><bold>440</bold></highlight>. In this embodiment of the invention, the TDT <highlight><bold>220</bold></highlight> and FDTs <highlight><bold>400</bold></highlight>, <highlight><bold>420</bold></highlight> and <highlight><bold>440</bold></highlight> are read in the course of processing the data. Alternative embodiments may read the data from the TDT <highlight><bold>220</bold></highlight> and FDTs <highlight><bold>400</bold></highlight>, <highlight><bold>420</bold></highlight> and <highlight><bold>440</bold></highlight> prior to the processing illustrated in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>. In step <highlight><bold>510</bold></highlight>, an SQL SELECT command query string is generated from contents of the TDT <highlight><bold>220</bold></highlight> read in step <highlight><bold>506</bold></highlight> and one or more of the FDTs <highlight><bold>400</bold></highlight>, <highlight><bold>420</bold></highlight>, and <highlight><bold>440</bold></highlight> read instep <highlight><bold>508</bold></highlight>. In step <highlight><bold>512</bold></highlight>, SQL UPDATE and/or INSERT strings are composed based on the content of the TDT <highlight><bold>220</bold></highlight> read in step <highlight><bold>506</bold></highlight> and the FDTs <highlight><bold>400</bold></highlight>, <highlight><bold>420</bold></highlight>, and <highlight><bold>440</bold></highlight> read in step <highlight><bold>508</bold></highlight>. The processing performed in step <highlight><bold>506</bold></highlight> and <highlight><bold>508</bold></highlight> is illustrated in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>A through <cross-reference target="DRAWINGS">FIG. 5D</cross-reference>. The processing performed in step <highlight><bold>510</bold></highlight> is illustrated in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>A<highlight><bold>1</bold></highlight> and the processing performed in step <highlight><bold>512</bold></highlight> is illustrated in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>B<highlight><bold>1</bold></highlight> through <cross-reference target="DRAWINGS">FIG. 6</cross-reference>C<highlight><bold>2</bold></highlight>. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> In step <highlight><bold>514</bold></highlight>, the SQL statements generated in step <highlight><bold>512</bold></highlight> are prepared for execution. For example, step <highlight><bold>514</bold></highlight> can be accomplished by using the Connection prepare Statement method. In step <highlight><bold>516</bold></highlight>, a SQL SELECT statement is executed. In step <highlight><bold>518</bold></highlight>, a result set based on the query executed instep <highlight><bold>516</bold></highlight> is received. For example, steps <highlight><bold>516</bold></highlight> and <highlight><bold>518</bold></highlight> can be accomplished using the Statement execute Query and Result Set next methods of JDBC. Instep <highlight><bold>520</bold></highlight>, a next row of a result set returned in step <highlight><bold>518</bold></highlight> will be read and processed according to the processing described in <cross-reference target="DRAWINGS">FIG. 7A</cross-reference> below. In step <highlight><bold>522</bold></highlight>, values from an array used for temporary storage of the row of the result set will be set up as described in the processing illustrated in <cross-reference target="DRAWINGS">FIG. 8</cross-reference>A<highlight><bold>1</bold></highlight>, <cross-reference target="DRAWINGS">FIG. 8</cross-reference>A<highlight><bold>2</bold></highlight>, <cross-reference target="DRAWINGS">FIG. 8</cross-reference>A<highlight><bold>3</bold></highlight> and <cross-reference target="DRAWINGS">FIG. 8</cross-reference>A<highlight><bold>4</bold></highlight>, below. In step <highlight><bold>524</bold></highlight>, a SQL UPDATE command string prepared in step <highlight><bold>514</bold></highlight> is executed. For example, step <highlight><bold>524</bold></highlight> can be accomplished by using the Prepared Statement execute Update method of JDBC. Step <highlight><bold>526</bold></highlight> is a decision block, the outcome of which depends on whether the UPDATE command executed in step <highlight><bold>524</bold></highlight> failed. Step <highlight><bold>526</bold></highlight> may be performed to handle the case where there is no record found in the target data table. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> If the UPDATE command did not fail, then the process <highlight><bold>500</bold></highlight> jumps to step <highlight><bold>532</bold></highlight>. If the UPDATE command failed, then in step <highlight><bold>528</bold></highlight> values from an array used for temporary storage of the row of the result set will be set for an INSERT command as described in the processing illustrated in <cross-reference target="DRAWINGS">FIG. 9</cross-reference>A and <cross-reference target="DRAWINGS">FIG. 9</cross-reference>B, below. In step <highlight><bold>530</bold></highlight> an INSERT command that uses the row entries stored in the array will be executed. For example, step <highlight><bold>530</bold></highlight> can be accomplished by using the Prepared Statement execute Update method of JDBC. In decision block <highlight><bold>532</bold></highlight>, a determination is made as to whether there are more rows in the result set obtained in step <highlight><bold>518</bold></highlight> that are yet to be processed. If so, then the process <highlight><bold>500</bold></highlight> loops back to step <highlight><bold>518</bold></highlight>. If not, then the process <highlight><bold>500</bold></highlight> continues with step <highlight><bold>534</bold></highlight> in which the connection opened in step <highlight><bold>504</bold></highlight> is closed. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> Queries are maintained in such a way that they are accessible to both a program which drives a database application with the queries, and a database administrator who can edit the tables to affect modifications as necessary. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5A</cross-reference> schematically illustrates the data flow into and out of the processing performed by the invention. The initial data into the processing is obtained during step <highlight><bold>506</bold></highlight> wherein the data from the TDT <highlight><bold>220</bold></highlight> is retrieved. The data retrieved from TDT <highlight><bold>220</bold></highlight> is used to determine from which FDT <highlight><bold>222</bold></highlight>A, <highlight><bold>222</bold></highlight>B and/or <highlight><bold>222</bold></highlight>C to obtain data. The data retrieved from the TDT <highlight><bold>220</bold></highlight> and FDTs <highlight><bold>222</bold></highlight>A, <highlight><bold>222</bold></highlight>B and <highlight><bold>222</bold></highlight>C is used to determine the processing to be performed on the data in the one or more source tables and how that data will be transformed and stored in the target table, as is described herein. Each row of the TDT <highlight><bold>220</bold></highlight> specifies a particular operation to be executed by the present invention. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference>B<highlight><bold>1</bold></highlight> through <cross-reference target="DRAWINGS">FIG. 9B</cross-reference> illustrate an example of the processing performed by the present invention by showing detailed processing that is associated with the specific data shown in the second row of the TDT <highlight><bold>220</bold></highlight> that is illustrated in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>. This second row of the TDT <highlight><bold>220</bold></highlight> will result in database record fields being modified in the &ldquo;UnitStat&rdquo; (the target data table) as specified in column <highlight><bold>302</bold></highlight>. The database record fields will be modified in accordance with the data contained in the &ldquo;UnitStatTab&rdquo; FDT <highlight><bold>420</bold></highlight> as is specified in column <highlight><bold>310</bold></highlight>. That data will then be processed by the program executing the present invention to perform the &ldquo;Target Actions&rdquo; commands specified in column <highlight><bold>308</bold></highlight> of the TDT <highlight><bold>220</bold></highlight>, namely &ldquo;Update/Insert&rdquo; in this example. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> The processing shown in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>B<highlight><bold>1</bold></highlight> through <cross-reference target="DRAWINGS">FIG. 9B</cross-reference> illustrate processing within the example embodiment which uses JDBC and SQL database commands. The processing utilizes arrays internal to the Java program, JDBC methods such as &ldquo;getInt, &ldquo;getString,&rdquo; &ldquo;setInt&rdquo; and &ldquo;setString.&rdquo;</paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference>B<highlight><bold>1</bold></highlight> shows the Select Command String <highlight><bold>550</bold></highlight> which is used to retrieve the data from the Fielddef Table specified in the second row of TDT <highlight><bold>220</bold></highlight>. The Select Command <highlight><bold>550</bold></highlight> is executed to retrieve the specification of the various arguments that will be incorporated into the SQL SELECT command that will be executed upon the one or more Source data tables. The fields retrieved by Select Command String <highlight><bold>550</bold></highlight> include &ldquo;SCLAUSE,&rdquo; which are one or more data fields (or data fields processed by SQL commands) to be extracted from the one or more source data tables by the SELECT command; &ldquo;Jtype,&rdquo; which are the corresponding Java data types of the data in the fields specified in the &ldquo;SCLAUSE&rdquo;; and &ldquo;SfldSeq,&rdquo; which is the sequence number of the data row as stored in the FDT. The inclusion of SQL commands such as SUMO in the SCLAUSE column allows data reduction to be performed on the source data without modification of the Java or other programming used to implement the present invention. The SELECT command includes the &ldquo;Where SCLAUSE is NOT NULL&rdquo; clause so that only rows of the FDT <highlight><bold>400</bold></highlight>, <highlight><bold>420</bold></highlight> or <highlight><bold>440</bold></highlight> that have SCLAUSE rows specified are returned. In the illustrated embodiment of the present invention, the select command string <highlight><bold>550</bold></highlight> is predetermined based on the FDT table schema with the name of the FDT table substituted at time of execution. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> These three columns of data retrieved from the FDT after execution of the Select Command String <highlight><bold>550</bold></highlight> are then stored into three data arrays that are internal to the program of the present invention. The data are stored in the arrays by execution of the SClause algorithm <highlight><bold>551</bold></highlight>, which is shown in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>B<highlight><bold>1</bold></highlight>. The SClause algorithm <highlight><bold>551</bold></highlight> extracts the data in each column of the result set obtained by execution of the Select Command String <highlight><bold>550</bold></highlight> into separate arrays with array indices that correspond to the row of the result set. The transfer of data from the result set into the corresponding arrays is illustrated schematically in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>B<highlight><bold>2</bold></highlight>. These data items are transferred into these arrays by processing the individual rows in the result set, as shown in SClause algorithm <highlight><bold>551</bold></highlight>. These arrays are used to construct the SELECT clause <highlight><bold>604</bold></highlight> which will be executed on the one or more source data tables. Construction of that SELECT clause is shown in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>A<highlight><bold>1</bold></highlight> and <cross-reference target="DRAWINGS">FIG. 6</cross-reference>A<highlight><bold>2</bold></highlight>. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference>B<highlight><bold>3</bold></highlight> illustrates processing used to generate the Group By Clause <highlight><bold>612</bold></highlight>, as shown in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>A<highlight><bold>1</bold></highlight> and <cross-reference target="DRAWINGS">FIG. 6</cross-reference>A<highlight><bold>2</bold></highlight>, which is to be incorporated into the Select command string that will ultimately retrieve data from the one or more source data tables. The Group By Clause information is stored in column <highlight><bold>426</bold></highlight> of the specified FDT <highlight><bold>420</bold></highlight>. The Select statement <highlight><bold>556</bold></highlight> is executed and the result set contains the columns containing the Group By clause strings to be included in the retrieval command as well as the SFldSeq field sequence number as was retrieved by Select Command String <highlight><bold>550</bold></highlight>. The processing of algorithm <highlight><bold>556</bold></highlight> places the Group By clause string into the GClause&lsqb; &rsqb; array with indices that correspond to the row of the result set. </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference>C<highlight><bold>1</bold></highlight> and <cross-reference target="DRAWINGS">FIG. 5</cross-reference>C<highlight><bold>2</bold></highlight> illustrate the processing used to develop the Update Set Clause <highlight><bold>628</bold></highlight> of the SQL Update statement that will be used to modify data in the target data table. Line <highlight><bold>2</bold></highlight> of TDT <highlight><bold>220</bold></highlight> identifies the target data table as UnitStat in Column <highlight><bold>302</bold></highlight>. The Select Command String <highlight><bold>565</bold></highlight> retrieves the data from the specified FDT <highlight><bold>420</bold></highlight> to be used to create the Update Set Clause. The data are then loaded into local program data arrays as is shown in algorithm <highlight><bold>566</bold></highlight>. The SFldSeq <highlight><bold>436</bold></highlight> indices are used to specify which column of source data is to modify a target field. This allows one source field to be used to modify multiple target fields. The results of the Select Command String <highlight><bold>565</bold></highlight> are sorted into the proper order by the TFldSeq <highlight><bold>438</bold></highlight>. An internal variable UFldSeq is created with the index of each row retrieved from the result set of the Select Statement <highlight><bold>565</bold></highlight>. This is used to store the data retrieved into the correct parameter of the Update Statement. It is to be noted that the &ldquo;source data&rdquo; may include data processed by SQL commands in the retrieving select statement, such as &ldquo;SUM( ).&rdquo;</paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference>C<highlight><bold>3</bold></highlight> and <cross-reference target="DRAWINGS">FIG. 5</cross-reference>C<highlight><bold>4</bold></highlight> illustrate the processing which retrieves the data used to build the &ldquo;Where&rdquo; clause <highlight><bold>632</bold></highlight> of the Update command, as is shown in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>B<highlight><bold>1</bold></highlight>. The Where clause algorithm <highlight><bold>575</bold></highlight> transfers the data retrieved by the SELECT command <highlight><bold>574</bold></highlight> into the arrays as is shown in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>C<highlight><bold>4</bold></highlight>. An internal variable WFldSeq is created with the index of each row retrieved from the result set, incremented by the number of rows that were retrieved in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>C<highlight><bold>1</bold></highlight> to process the Update Set Clause. The parameters in the Where clause of the Update statement are assigned after the parameters of the Update Set Clause. </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> The processing which retrieves and processes the data used to construct the Insert command is shown in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>D<highlight><bold>1</bold></highlight> and <cross-reference target="DRAWINGS">FIG. 5</cross-reference>D<highlight><bold>2</bold></highlight>. <cross-reference target="DRAWINGS">FIG. 5</cross-reference>D<highlight><bold>1</bold></highlight> illustrates the processing steps of algorithm <highlight><bold>581</bold></highlight> which will transform the data retrieved by the SELECT command <highlight><bold>580</bold></highlight> into the arrays, as is shown in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>D<highlight><bold>2</bold></highlight>. </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference>A<highlight><bold>1</bold></highlight> is a pseudo code schematic <highlight><bold>600</bold></highlight> illustrating the processing of code which constructs a SELECT query string to operate upon the one or more source data tables <highlight><bold>216</bold></highlight> from the contents of a row of the TDT <highlight><bold>220</bold></highlight> and the FDT named in the row according to one embodiment of the present invention. The pseudo code <highlight><bold>600</bold></highlight> is executed for each row of the TDT <highlight><bold>220</bold></highlight>. The schematic shows a number of string literals, variables that contain string values, and segments of code that return lists of strings (e.g., lists of DML command arguments). All the strings are to be concatenated together to form a SELECT query string. </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> Element <highlight><bold>602</bold></highlight> is the DML token &ldquo;SELECT&rdquo;. Block <highlight><bold>604</bold></highlight> is a segment of code that determines the number of rows in the Query Select Clause column of the FDT <highlight><bold>400</bold></highlight>, <highlight><bold>420</bold></highlight>, or <highlight><bold>440</bold></highlight> named in the Fielddef tablename column <highlight><bold>310</bold></highlight>, and extracts all the entries from that row into a comma delimited list. The SClause&lsqb; &rsqb; array was constructed using the processing shown in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>B<highlight><bold>1</bold></highlight> through <highlight><bold>5</bold></highlight>B<highlight><bold>2</bold></highlight>. Element <highlight><bold>606</bold></highlight> is the literal &lsquo;FROM&rsquo; that forms a part of the SELECT query string. Element <highlight><bold>608</bold></highlight> is the variable &lsquo;Qtablename&rsquo; that points to an entry of the Query tablename column <highlight><bold>304</bold></highlight> of the row of the TDT <highlight><bold>220</bold></highlight> being processed by the pseudo code <highlight><bold>600</bold></highlight>. Block <highlight><bold>610</bold></highlight> includes a segment of code that extracts an entry from the current row of the Query Search Clause column <highlight><bold>306</bold></highlight> of the TDT <highlight><bold>220</bold></highlight>. If the entry is not empty, a literal string &lsquo;WHERE&rsquo; is appended in front of the entry. Block <highlight><bold>612</bold></highlight> includes a segment of code that extracts non null values from the Query Group by Clause <highlight><bold>426</bold></highlight> column of the FDT <highlight><bold>420</bold></highlight> named in the Fielddef Tablename column <highlight><bold>310</bold></highlight> of the current row of the TDT <highlight><bold>220</bold></highlight> into a comma delimited list prefixed with the literal &lsquo;GROUP BY&rsquo;. <cross-reference target="DRAWINGS">FIG. 6</cross-reference>A<highlight><bold>2</bold></highlight> shows the SELECT query string constructed using the example of row <highlight><bold>2</bold></highlight> of the TDT <highlight><bold>220</bold></highlight> shown in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>. </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference>B<highlight><bold>1</bold></highlight> is a pseudo code <highlight><bold>620</bold></highlight> schematic of a process for constructing an UPDATE command string from the contents of a row of the TDT <highlight><bold>220</bold></highlight> and the FDT named in the Fielddef TableName column of the row of the TDT <highlight><bold>220</bold></highlight> according to one embodiment of the present invention. This pseudo code <highlight><bold>620</bold></highlight> is executed for each row of the TDT <highlight><bold>220</bold></highlight> for which the entry in the Target Action column <highlight><bold>308</bold></highlight> of the Table Definition Table <highlight><bold>220</bold></highlight> is UPDATE or UPDATE/INSERT. </paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> Element <highlight><bold>622</bold></highlight> is the SQL DML token &lsquo;UPDATE.&rsquo; Utablename <highlight><bold>624</bold></highlight> is a variable that points to an entry in the current row of the Target Table Name column <highlight><bold>302</bold></highlight> of the TDT <highlight><bold>220</bold></highlight>. Element <highlight><bold>626</bold></highlight> is the SQL syntax literal &lsquo;SET&rsquo;. Block <highlight><bold>628</bold></highlight> is a code segment that extracts all the entries in the Update Set clause column <highlight><bold>408</bold></highlight>, <highlight><bold>428</bold></highlight>, or <highlight><bold>448</bold></highlight> of the FDT <highlight><bold>400</bold></highlight>, <highlight><bold>420</bold></highlight>, or <highlight><bold>440</bold></highlight> named in the Fielddef TableName column <highlight><bold>310</bold></highlight> of the current row of the TDT <highlight><bold>220</bold></highlight> into a comma delimited list. Element <highlight><bold>630</bold></highlight> is the SQL syntax token &lsquo;WHERE.&rsquo; Block <highlight><bold>632</bold></highlight> is a code segment that extracts all the entries in the Update Where Clause column <highlight><bold>430</bold></highlight> of the FDT <highlight><bold>420</bold></highlight> named in the current row of the TDT <highlight><bold>220</bold></highlight>. Each entry is appended into the Update string with the SQL syntax literal &lsquo;AND&rsquo; inserted between entries. <cross-reference target="DRAWINGS">FIG. 6</cross-reference>B<highlight><bold>2</bold></highlight> shows an example Update command string using line <highlight><bold>2</bold></highlight> of the TDT <highlight><bold>220</bold></highlight> shown in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>. </paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference>C<highlight><bold>1</bold></highlight> is a pseudo code schematic <highlight><bold>640</bold></highlight> of a process for constructing an INSERT command string from the contents of tables according to one embodiment of the present invention. Element <highlight><bold>642</bold></highlight> is the SQL syntax literal &lsquo;INSERT INTO.&rsquo; Itablename <highlight><bold>644</bold></highlight> is a variable that points to an entry in the current row of the Table Target Name column <highlight><bold>302</bold></highlight> of the TDT <highlight><bold>220</bold></highlight>. A literal &lsquo;(&rsquo; is appended after the Itablename. Block <highlight><bold>646</bold></highlight> is a code segment that extracts entries from the Insert Column Name column <highlight><bold>412</bold></highlight>, <highlight><bold>432</bold></highlight>, or <highlight><bold>452</bold></highlight> of the FDT <highlight><bold>420</bold></highlight>, <highlight><bold>420</bold></highlight>, or <highlight><bold>440</bold></highlight> named in the current row of the TDT <highlight><bold>220</bold></highlight> into a comma delimited list. Element <highlight><bold>648</bold></highlight> is the SQL syntax literal &lsquo;)VALUES(&rsquo;. Block <highlight><bold>650</bold></highlight> is a code segment used to generate a comma delimited string of the literal &lsquo;&quest;&rsquo;. The number of &lsquo;&quest;&rsquo; in the string is determined by the variable Isize, which is the number of fields in the Insert Field Clause. Element <highlight><bold>652</bold></highlight> is a literal &lsquo;)&rsquo; to properly terminate the VALUES argument. <cross-reference target="DRAWINGS">FIG. 6</cross-reference>C<highlight><bold>2</bold></highlight> shows the example INSERT command string generated by processing line <highlight><bold>2</bold></highlight> of the example TDT <highlight><bold>220</bold></highlight> shown in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>. </paragraph>
<paragraph id="P-0068" lvl="0"><number>&lsqb;0068&rsqb;</number> The processing described above, which creates the command strings, is performed prior to execution of those strings. <cross-reference target="DRAWINGS">FIG. 5</cross-reference> illustrates the processing whereby the processing shown in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>B<highlight><bold>1</bold></highlight> through <cross-reference target="DRAWINGS">FIG. 6</cross-reference>C<highlight><bold>2</bold></highlight> is performed in steps <highlight><bold>506</bold></highlight> through <highlight><bold>514</bold></highlight>. Once these SQL command strings are formed, the data query (Select) command is executed instep <highlight><bold>516</bold></highlight>. Steps <highlight><bold>518</bold></highlight> through <highlight><bold>522</bold></highlight> and step <highlight><bold>528</bold></highlight> perform processing of data in the result set prior to the insertion of data into the target data table through Update commands, as shown in step <highlight><bold>524</bold></highlight>, or insert commands as in step <highlight><bold>530</bold></highlight>. This processing of the data retrieved from the source data table prior to insertion into the target data table is described below. </paragraph>
<paragraph id="P-0069" lvl="0"><number>&lsqb;0069&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7A</cross-reference> describes the processing used to transfer into internal data storage the data in the result set that was retrieved from the source data table by executing the SELECT query string constructed as shown in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>A<highlight><bold>1</bold></highlight>. The result set data are stored in internal data storage with an ordering that is specified in the array SFldSeq&lsqb; &rsqb; as shown in <cross-reference target="DRAWINGS">FIG. 7A</cross-reference>. The values in the result set may be retrieved using the JDBC methods &ldquo;getString&rdquo; and &ldquo;getInt&rdquo;. The processing of the data in the result set produces two arrays, StringRS and IntRS, which contain string and integer values, respectively, that are retrieved by the Select clause. The transfer of a row of data from the result set is illustrated in <cross-reference target="DRAWINGS">FIG. 7B</cross-reference>. Each row of the result set is processed in turn. </paragraph>
<paragraph id="P-0070" lvl="0"><number>&lsqb;0070&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference>A<highlight><bold>1</bold></highlight> and <cross-reference target="DRAWINGS">FIG. 8</cross-reference>A<highlight><bold>2</bold></highlight> illustrate the processing used to bind the parameters of the Update Command string to the data stored in the internal data structures created with the processing illustrated in <cross-reference target="DRAWINGS">FIG. 7A</cross-reference>. The algorithms shown in <cross-reference target="DRAWINGS">FIG. 8</cross-reference>A<highlight><bold>1</bold></highlight> and <cross-reference target="DRAWINGS">FIG. 8</cross-reference>A<highlight><bold>2</bold></highlight> are executed to bind the parameters of the Update_Set clause <highlight><bold>628</bold></highlight> and the Where Clause <highlight><bold>632</bold></highlight> of the update statement shown in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>B<highlight><bold>1</bold></highlight>. The data stored in internal variables maybe bound to parameters by loading their values into a JDBC structure using the JDBC methods &ldquo;setString&rdquo; and &ldquo;setint.&rdquo; The result of the processing is illustrated in <cross-reference target="DRAWINGS">FIG. 8</cross-reference>A<highlight><bold>3</bold></highlight> and <cross-reference target="DRAWINGS">FIG. 8</cross-reference>A<highlight><bold>4</bold></highlight>. </paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference>A and <cross-reference target="DRAWINGS">FIG. 9B</cross-reference> illustrate the processing used to bind the parameters of the Values Clause <highlight><bold>650</bold></highlight> of the Insert Command string to the data stored in the internal data structures created with the processing illustrated in <cross-reference target="DRAWINGS">FIG. 7A</cross-reference>. The algorithm shown in <cross-reference target="DRAWINGS">FIG. 9A</cross-reference> is executed to bind the parameters of the Values clause <highlight><bold>650</bold></highlight> of the Insert statement shown in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>C<highlight><bold>1</bold></highlight> and <cross-reference target="DRAWINGS">FIG. 6</cross-reference>C<highlight><bold>2</bold></highlight>. The data stored in internal variables maybe bound to parameters by loading their values into a JDBC structure using the JDBC methods &ldquo;setString&rdquo; and &ldquo;setInt.&rdquo; The result of the processing is illustrated in <cross-reference target="DRAWINGS">FIG.9B</cross-reference>. </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> In a preferred embodiment, the processing and algorithms described above with reference to the figures are read from the computer readable medium <highlight><bold>124</bold></highlight> and executed by the microprocessor <highlight><bold>102</bold></highlight>. </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> The present invention realizes a system in which elements of query strings can be stored in tables and accessed at run time to compose database commands. The present invention is advantageous for data processing that entails numerous complex database commands, because modification can be more easily accomplished by altering selected TDT or FDTs, as opposed to rewriting SQL commands. </paragraph>
<paragraph id="P-0074" lvl="0"><number>&lsqb;0074&rsqb;</number> The present invention can be realized in hardware, software, or a combination of hardware and software. Any kind of computer system&mdash;or other apparatus adapted for carrying out the methods described herein&mdash;is suited. A typical combination of hardware and software could be a general purpose computer system with a computer program that, when being loaded and executed, controls the computer system such that it carries out the methods described herein. </paragraph>
<paragraph id="P-0075" lvl="0"><number>&lsqb;0075&rsqb;</number> The present invention can also be embedded in a computer program product, which comprises all the features enabling the implementation of the methods described herein, and which&mdash;when loaded in a computer system&mdash;is able to carry out these methods. Computer program means or computer program in the present context means any expression, in any language, code or notation, of a set of instructions intended to cause a system having an information processing capability to perform a particular function either directly or after either or both of the following a) conversion to another language, code or, notation; and b) reproduction in a different material form. </paragraph>
<paragraph id="P-0076" lvl="0"><number>&lsqb;0076&rsqb;</number> Each computer system may include, inter alia, one or more computers and at least a computer readable medium allowing a computer to read data, instructions, messages or message packets, and other computer readable information from the computer readable medium. The computer readable medium may include non-volatile memory, such as ROM, Flash memory, Disk drive memory, CD-ROM, and other permanent storage. Additionally, a computer medium may include, for example, volatile storage such as RAM, buffers, cache memory, and network circuits. Furthermore, the computer readable medium may comprise computer readable information in a transitory state medium such as a network link and/or a network interface, including a wired network or a wireless network, that allow a computer to read such computer readable information. </paragraph>
<paragraph id="P-0077" lvl="0"><number>&lsqb;0077&rsqb;</number> While there has been illustrated and described what are presently considered to be the preferred embodiments of the present invention, it will be understood by those skilled in the art that various other modifications maybe made, and equivalents may be substituted, without departing from the true scope of the invention. Additionally, many modifications maybe made to adapt a particular situation to the teachings of the present invention without departing from the central inventive concept described herein. Therefore, it is intended that the present invention not be limited to the particular embodiments disclosed, but that the invention include all embodiments falling within the scope of the appended claims. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method for performing database operations, the method comprising the steps of: 
<claim-text>reading a first plurality of elements of a first query from a first set of one or more tables; </claim-text>
<claim-text>assembling a query string from the first plurality of elements; and </claim-text>
<claim-text>executing the first query string to retrieve results from one or more source data tables. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the step of reading a first plurality of elements includes the sub-steps of: 
<claim-text>reading a name of a second table from a first table; and </claim-text>
<claim-text>reading a plurality of arguments for the query string from the second table. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the step of assembling the query string includes the sub-step of assembling a query string that includes a first query language command and the plurality of arguments. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, wherein the step of reading a first plurality of elements of a first query from the first set of one or more tables further includes the sub-step of reading one or more names corresponding to one or more source data tables from the first table. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00004">claim 4</dependent-claim-reference>, wherein the sub-step of reading a plurality of arguments for the first query language command from the second table includes the sub-step of reading a plurality of names of columns of the one or more source data tables from the second table. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference>, wherein the step of assembling the query string includes the sub-step of concatenating together a first plurality of elements that include the name of the one or more source data tables and the plurality of names of columns. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, further comprising the step of reading a second query language command from the first table. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference>, further comprising the step of reading a plurality of names of columns of a target data table from the second table. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference>, wherein the step of assembling the query string includes the sub-step of concatenating together a second plurality of elements that include the second query language command and the plurality of names of columns of the target data table. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. A method according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising the steps of: 
<claim-text>reading a second plurality of elements of a query from a second set of one or more tables; </claim-text>
<claim-text>assembling a data base table storage command string from the second plurality of elements and </claim-text>
<claim-text>executing the data base table storage command string in order to modify a target data table. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. A method according to <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein said storage command string is Structured Query Language UPDATE command string. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. A method according to <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein said storage command string is Structured Query Language INSERT command string. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. A method according to <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein one or more tables in said second set of one or more tables is also in said first set of one or more tables. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. A method according to <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein said second plurality of elements contain data used to specify the order in which data elements are to be stored. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. A method according to <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, further comprising the step of executing said storage command string so as to cause all or a part of said source data set to be stored. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. A machine-readable medium encoded with a program for performing database operations, said program containing instructions for performing the steps of: 
<claim-text>reading a first plurality of elements of a first query from a first set of one or more tables; </claim-text>
<claim-text>assembling a query string from the first plurality of elements; and </claim-text>
<claim-text>executing the first query string to retrieve results from one or more source data tables. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The computer readable medium according to <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, wherein the step of reading a plurality of elements includes the sub-steps of: 
<claim-text>reading a name of a second table from the first table; </claim-text>
<claim-text>reading a plurality of arguments for the query language command from the second table; and </claim-text>
<claim-text>executing the first query string to retrieve results from one or more source data tables. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The computer readable medium according to <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference>, wherein the step of assembling the query string includes the sub-step of assembling a query string that includes a first query language command and the plurality of arguments. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The computer readable medium according to <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference>, wherein the step of reading a first plurality of elements of a first query from the first set of one or more tables further includes the sub-step of reading one or more names corresponding to one or more source data tables from the first table. </claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The computer readable medium according to <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference>, wherein the step of reading a plurality of arguments for the first query language command from the second table further includes the sub-step of reading a plurality of names of columns of the one or more source data tables from the second table. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The computer readable medium according to <dependent-claim-reference depends_on="CLM-00022">claim 20</dependent-claim-reference>, wherein the step of assembling the query string includes the sub-step of concatenating together a first plurality of elements that include the name of the one or more source data tables and the plurality of names of columns. </claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The computer readable medium according to <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference>, wherein the program further contains instructions for performing the step of reading a second query language command from the first table. </claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The computer readable medium according to <dependent-claim-reference depends_on="CLM-00022">claim 22</dependent-claim-reference>, wherein the step of reading a plurality of arguments for the query language command from the second table includes the sub-step of reading a plurality of names of columns of a target data table from the second table. </claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The computer readable medium according to <dependent-claim-reference depends_on="CLM-00022">claim 23</dependent-claim-reference>, wherein the step of assembling the query string includes the sub-step of concatenating together a second plurality of elements that include the second query language command and the plurality of names of columns of the target data table. </claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. The computer readable medium according to <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, wherein the program further contains instructions for performing the steps of: 
<claim-text>reading a second plurality of elements of a query from a second set of one or more tables; </claim-text>
<claim-text>assembling a data base table storage command string from the second plurality of elements; and </claim-text>
<claim-text>executing the data base table storage command to modify a target data table. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. The computer readable medium according to <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>, wherein said storage command string is Structured Query Language UPDATE command string. </claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. The computer readable medium according to <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>, wherein said storage command string is Structured Query Language INSERT command string. </claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. The computer readable medium according to <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>, wherein one or more tables in said second set of one or more tables is also in said first set of one or more tables. </claim-text>
</claim>
<claim id="CLM-00029">
<claim-text><highlight><bold>29</bold></highlight>. The computer readable medium according to <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>, wherein said second plurality of elements contain data used to specify the order in which data elements are to be stored. </claim-text>
</claim>
<claim id="CLM-00030">
<claim-text><highlight><bold>30</bold></highlight>. The computer readable medium according to <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>, wherein the program further contains instructions for performing the step of executing said storage command string so as to cause all or apart of said source data set to be stored. </claim-text>
</claim>
<claim id="CLM-00031">
<claim-text><highlight><bold>31</bold></highlight>. A data processing system comprising: 
<claim-text>a storage device for storing a relational database; and </claim-text>
<claim-text>a processor programmed to: 
<claim-text>read a first plurality of elements of a first query from a first set of one or more tables; </claim-text>
<claim-text>assemble a query string from the first plurality of elements; and </claim-text>
<claim-text>execute the first query string to retrieve results from one or more source data tables. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00032">
<claim-text><highlight><bold>32</bold></highlight>. A data processing system according to <dependent-claim-reference depends_on="CLM-00033">claim 31</dependent-claim-reference>, wherein the processor is further programmed to: 
<claim-text>read a second plurality of elements of a query from a second set of one or more tables; </claim-text>
<claim-text>assemble a data base table storage command string from the second plurality of elements; and </claim-text>
<claim-text>execute the data base table storage command to modify a target data table. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00033">
<claim-text><highlight><bold>33</bold></highlight>. A data processing system comprising: 
<claim-text>means for storing one or more data tables; </claim-text>
<claim-text>means for reading a first plurality of elements of a first query from a first set of one or more tables; </claim-text>
<claim-text>means for assembling a query string from the first plurality of elements; and </claim-text>
<claim-text>means for executing the first query string to retrieve results from one or more source data tables. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00034">
<claim-text><highlight><bold>34</bold></highlight>. A data processing system according to <dependent-claim-reference depends_on="CLM-00033">claim 33</dependent-claim-reference>, further comprising: 
<claim-text>means for reading a second plurality of elements of a query from a second set of one or more tables; </claim-text>
<claim-text>means for assembling a data base table storage command string from the second plurality of elements; and </claim-text>
<claim-text>means for executing the database table storage command to modify a target data table. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00035">
<claim-text><highlight><bold>35</bold></highlight>. A computer-readable medium having stored thereon a data structure including: 
<claim-text>a name of a first table that includes data to be processed; and </claim-text>
<claim-text>a name of a second table that includes arguments to be used in composing a database command to process the data. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00036">
<claim-text><highlight><bold>36</bold></highlight>. The computer readable medium according to <dependent-claim-reference depends_on="CLM-00033">claim 35</dependent-claim-reference>, wherein the data structure further includes identification of an SQL command to be used in processing the data.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>2</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030004930A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030004930A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030004930A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030004930A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030004930A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030004930A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030004930A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030004930A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030004930A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00009">
<image id="EMI-D00009" file="US20030004930A1-20030102-D00009.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00010">
<image id="EMI-D00010" file="US20030004930A1-20030102-D00010.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00011">
<image id="EMI-D00011" file="US20030004930A1-20030102-D00011.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00012">
<image id="EMI-D00012" file="US20030004930A1-20030102-D00012.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00013">
<image id="EMI-D00013" file="US20030004930A1-20030102-D00013.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00014">
<image id="EMI-D00014" file="US20030004930A1-20030102-D00014.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00015">
<image id="EMI-D00015" file="US20030004930A1-20030102-D00015.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00016">
<image id="EMI-D00016" file="US20030004930A1-20030102-D00016.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00017">
<image id="EMI-D00017" file="US20030004930A1-20030102-D00017.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00018">
<image id="EMI-D00018" file="US20030004930A1-20030102-D00018.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00019">
<image id="EMI-D00019" file="US20030004930A1-20030102-D00019.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
