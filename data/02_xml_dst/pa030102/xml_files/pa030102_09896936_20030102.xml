<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005420A1-20030102-D00000.TIF SYSTEM "US20030005420A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005420A1-20030102-D00001.TIF SYSTEM "US20030005420A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005420A1-20030102-D00002.TIF SYSTEM "US20030005420A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005420A1-20030102-D00003.TIF SYSTEM "US20030005420A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005420A1-20030102-D00004.TIF SYSTEM "US20030005420A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005420A1-20030102-D00005.TIF SYSTEM "US20030005420A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030005420A1-20030102-D00006.TIF SYSTEM "US20030005420A1-20030102-D00006.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005420</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09896936</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010629</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F009/45</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>717</class>
<subclass>150000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Alias-free test for dynamic array structures</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Somnath</given-name>
<family-name>Ghosh</family-name>
</name>
<residence>
<residence-us>
<city>San Jose</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Rakesh</given-name>
<family-name>Krishnaiyer</family-name>
</name>
<residence>
<residence-us>
<city>Santa Clara</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Wei</given-name>
<family-name>Li</family-name>
</name>
<residence>
<residence-us>
<city>Redwood Shores</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Abhay</given-name>
<family-name>Kanhere</family-name>
</name>
<residence>
<residence-us>
<city>Sunnyvale</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Dattatraya</given-name>
<family-name>Kulkarni</family-name>
</name>
<residence>
<residence-us>
<city>Santa Clara</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Chu-cheow</given-name>
<family-name>Lim</family-name>
</name>
<residence>
<residence-us>
<city>Santa Clara</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>John</given-name>
<middle-name>L.</middle-name>
<family-name>Ng</family-name>
</name>
<residence>
<residence-us>
<city>San Jose</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>SCHWEGMAN, LUNDBERG, WOESSNER &amp; KLUTH, P.A.</name-1>
<name-2></name-2>
<address>
<address-1>P.O. BOX 2938</address-1>
<city>MINNEAPOLIS</city>
<state>MN</state>
<postalcode>55402</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">An apparatus, method, and program product for optimizing code that contains dynamically-allocated memory. The aliasing behavior of internal pointers of dynamically-allocated memory is used to disambiguate memory accesses and to eliminate false data dependencies. It is determined whether a dynamically-allocated array will behave like a statically-allocated array throughout the entire program execution once it has been allocated. This determination is used to improve the instruction scheduling efficiency, which yields better performance. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">FIELD </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> This invention relates generally to computers and more particularly to compilers that support dynamic memory allocation. </paragraph>
</section>
<section>
<heading lvl="1">COPYRIGHT NOTICE/PERMISSION </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> A portion of the disclosure of this patent document contains material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever. The following notice applies to the software and data as described below and in the drawings hereto: Copyright &copy; Intel, Incorporated, 2000. All Rights Reserved. </paragraph>
</section>
<section>
<heading lvl="1">BACKGROUND </heading>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> A computer operates under the control of programs consisting of coded instructions called object code that execute on the computer. But, object code is not readily understood by humans, so a human programmer typically writes programs in a high-level programming language, such as BASIC, PASCAL, C, C&plus;&plus;, or the like, which is easier to understand. High-level languages generally have a precise syntax that defines certain permitted structures for statements in the language and their meaning. A compiler, which is itself a program, translates the high-level language statements, called &ldquo;source code&rdquo; into object code. Thus, the terms &ldquo;source code&rdquo; and &ldquo;object code&rdquo; describe the form of a program prior to and after translation, respectively. Accordingly, the term &ldquo;source code&rdquo; generally refers to a program in its high-level programming language form. &ldquo;Object code,&rdquo; on the other hand, generally refers to the program in the form of the coded instructions generated by the compiler that are executable on a computer. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> In modern microprocessors, compilers play a significant role in obtaining good performance of the object code. In particular, the compiler&apos;s ability to extract instruction-level parallelism (ILP) in a program quite often holds the key to improved performance. For memory references, ILP can effectively hide the latency of performance-critical load operations by executing the loads before earlier store operations. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> Without accurate data-dependence information, the efficiency of ILP to reorder memory operations suffers significantly. This accuracy of data-dependence information critically depends on the compiler&apos;s ability to distinguish memory accesses to different locations, a process called memory disambiguation. When two memory accesses cannot be disambiguated, they may be &ldquo;aliased&rdquo;, i.e., they may refer to the same memory location. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> In many programming languages, programs can be written to dynamically allocate and create multi-dimensional arrays. Here &ldquo;dynamic allocation&rdquo; refers to obtaining storage at runtime as opposed to determining storage at compile time. In C programs, for example, multi-dimensional arrays are allocated and formed dynamically through the function-call &ldquo;malloc&rdquo; defined in the C language. The program then performs various computations on these arrays and finally deallocates them using another C language defined function-call &ldquo;free&rdquo;. In such programs, the compiler must disambiguate between references to dynamically-allocated multi-dimensional arrays in order to improve instruction-level parallelism. But, current techniques are inadequate to disambiguate between references to a dynamically-allocated multi-dimensional array. Therefore, performance of such programs can be severely affected when key loops cannot be parallelized due to false data dependencies that cannot be eliminated since the compiler was unable to disambiguate the dynamic-array accesses. </paragraph>
<paragraph id="P-0007" lvl="7"><number>&lsqb;0007&rsqb;</number> What is needed is a mechanism to disambiguate real data dependencies from false data dependencies, so that more loops can take advantage of instruction-level parallelism and performance of the resulting object code can be increased. </paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> depicts a block diagram of a computer that can be used to implement an embodiment of the invention. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 2A and 2B</cross-reference> depict block diagrams of example source code to be compiled, according to an embodiment of the invention. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> depicts a block diagram of allocated memory, according to an embodiment of the invention. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 4, 5</cross-reference>, and <highlight><bold>6</bold></highlight> depict flowcharts that describe a method according to an embodiment of the invention.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION </heading>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> In the following detailed description of exemplary embodiments of the invention, reference is made to the accompanying drawings (where like numbers represent like elements), which form a part hereof, and in which is shown by way of illustration specific exemplary embodiments in which the invention may be practiced. These embodiments are described in sufficient detail to enable those skilled in the art to practice the invention, but other embodiments may be utilized and logical, mechanical, electrical, and other changes may be made without departing from the scope of the present invention. The following detailed description is, therefore, not to be taken in a limiting sense, and the scope of the present invention is defined only by the appended claims. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> In the following description, numerous specific details are set forth to provide a thorough understanding of the invention. But, it is understood that the invention may be practiced without these specific details. In other instances, well-known circuits, structures and techniques have not been shown in detail in order not to obscure the invention. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> shows a block diagram illustrating an exemplary computer system <highlight><bold>100</bold></highlight> according to an embodiment of the invention. The exemplary computer system <highlight><bold>100</bold></highlight> includes processor <highlight><bold>105</bold></highlight>, storage device <highlight><bold>110</bold></highlight>, keyboard <highlight><bold>120</bold></highlight>, display device <highlight><bold>127</bold></highlight>, and network adapter <highlight><bold>130</bold></highlight>, all communicatively coupled via bus <highlight><bold>115</bold></highlight>. An unillustrated network may also be coupled to bus <highlight><bold>115</bold></highlight> through network adapter <highlight><bold>130</bold></highlight>. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> Processor <highlight><bold>105</bold></highlight> represents a central processing unit of any type of architecture, such as a CISC, RISC, VLIW, or a hybrid architecture, although any appropriate processor can be used. Processor <highlight><bold>105</bold></highlight> executes instructions and includes that portion of computer <highlight><bold>100</bold></highlight> that controls the operation of the entire computer, including executing the arithmetical and logical functions contained in a particular computer program. Although not depicted in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, processor <highlight><bold>105</bold></highlight> typically includes a control unit that organizes data and program storage in computer memory and transfers data and other information between the various part of the computer system. Processor <highlight><bold>105</bold></highlight> receives input data from input devices such as keyboard <highlight><bold>120</bold></highlight> and network adapter <highlight><bold>130</bold></highlight>, reads and stores code and data in storage device <highlight><bold>110</bold></highlight>, and presents output data to a user via display device <highlight><bold>127</bold></highlight>. Processor <highlight><bold>105</bold></highlight> also sends and receives packets of information across a network using network adapter <highlight><bold>130</bold></highlight>. Although computer <highlight><bold>100</bold></highlight> is shown to contain only a single processor and a single system bus, the present invention applies equally to computers that have multiple processors and to computers that have multiple buses that each performs different functions in different ways. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> Storage device <highlight><bold>110</bold></highlight> represents one or more mechanisms for storing data. For example, storage device <highlight><bold>110</bold></highlight> can include read only memory (ROM), random access memory (RAM), magnetic disk storage mediums, optical storage mediums, flash memory devices, and/or other machine-readable mediums. Although only one storage device <highlight><bold>110</bold></highlight> is shown, multiple storage devices and multiple types of storage devices can be present. Further, although computer <highlight><bold>100</bold></highlight> is drawn to contain storage device <highlight><bold>110</bold></highlight>, the storage device can be distributed across other computers. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> Bus <highlight><bold>115</bold></highlight> represents one or more busses (e.g., PCI, ISA, X-Bus, EISA, VESA, or any other appropriate bus) and bridges (also termed bus controllers). </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> also illustrates that storage device <highlight><bold>110</bold></highlight> has stored therein compiler <highlight><bold>135</bold></highlight>, source code <highlight><bold>140</bold></highlight>, object code <highlight><bold>145</bold></highlight>, and dynamically-allocated array <highlight><bold>150</bold></highlight>. Of course, storage device <highlight><bold>110</bold></highlight> can also contain additional software (not shown), which is not necessary to understanding the invention. Compiler <highlight><bold>135</bold></highlight> contains instructions capable of being executed on processor <highlight><bold>105</bold></highlight>. In another embodiment, compiler <highlight><bold>135</bold></highlight> can be implemented in hardware in lieu of a processor-based system. Compiler <highlight><bold>135</bold></highlight> compiles source code <highlight><bold>140</bold></highlight> into object code <highlight><bold>145</bold></highlight> that creates dynamically-allocated array <highlight><bold>150</bold></highlight>. An example of source code <highlight><bold>140</bold></highlight> is described below with reference to <cross-reference target="DRAWINGS">FIGS. 2A and 2B</cross-reference>. An example of dynamically-allocated array <highlight><bold>150</bold></highlight> is described below with reference to <cross-reference target="DRAWINGS">FIG. 3</cross-reference>. The operations of compiler <highlight><bold>135</bold></highlight> are further described below with reference to <cross-reference target="DRAWINGS">FIGS. 4, 5</cross-reference>, and <highlight><bold>6</bold></highlight>. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> Keyboard <highlight><bold>120</bold></highlight> is that part of computer <highlight><bold>100</bold></highlight> that resembles a typewriter keyboard and that enables a user to control particular aspects of the computer. </paragraph>
<paragraph id="P-0020" lvl="7"><number>&lsqb;0020&rsqb;</number> Display device <highlight><bold>127</bold></highlight> is the visual output of computer <highlight><bold>100</bold></highlight>. Display device <highlight><bold>127</bold></highlight> can be a cathode-ray tube (CRT) based video display well known in the art of computer hardware. But, with a portable or notebook-based computer, display device <highlight><bold>127</bold></highlight> can be replaced with a liquid crystal display (LCD) based or gas, plasma-based, flat-panel display. In still other embodiments, any appropriate display device can be used. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> Network adapter <highlight><bold>130</bold></highlight> facilitates communication between computer <highlight><bold>100</bold></highlight> and an unillustrated network. Network adapter <highlight><bold>130</bold></highlight> provides a user of computer <highlight><bold>100</bold></highlight> with a means of electronically communicating information, such as packets, with a remote computer or a network logical-storage device. In addition, in another embodiment, network adapter <highlight><bold>130</bold></highlight> supports distributed processing, which enables computer <highlight><bold>100</bold></highlight> to share a task with other computer systems linked to the network. Although network adapter <highlight><bold>130</bold></highlight> is shown as part of computer <highlight><bold>100</bold></highlight>, in another embodiment they are packaged separately. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> Computer <highlight><bold>100</bold></highlight> can be implemented using any suitable computer, such as a personal computer available from a number of vendors. Portable computers, laptop computers, mainframe computers, handheld devices, and network computers or Internet appliances are examples of other possible configurations. The hardware and software depicted in <cross-reference target="DRAWINGS">FIG. 1</cross-reference> may vary for specific applications. For example, other peripheral devices such as pointing devices, speech recognition devices, audio adapters, or chip programming devices, such as PAL or EPROM programming devices may be used in addition to or in place of the hardware already depicted. Thus, an embodiment of the invention can apply to any hardware configuration that allows compiling code, regardless of whether the hardware configuration is a complicated, multi-user computing apparatus, a single-user workstation, or a network appliance that does not have non-volatile storage of its own. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> As will be described in detail below, aspects of an embodiment pertain to specific apparatus and method elements implementable on computers. In another embodiment, the invention can be implemented as a computer program product for use with a computer system. The programs defining the functions of this embodiment can be delivered to a computer via a variety of signal-bearing media, which include, but are not limited to: </paragraph>
<paragraph id="P-0024" lvl="1"><number>&lsqb;0024&rsqb;</number> (1) information permanently stored on non-rewriteable storage media (e.g., read only memory devices within a computer such as CD-ROM readable by a CD-ROM drive; </paragraph>
<paragraph id="P-0025" lvl="1"><number>&lsqb;0025&rsqb;</number> (2) alterable information stored on rewriteable storage media (e.g., a hard disk drive or diskette); or </paragraph>
<paragraph id="P-0026" lvl="1"><number>&lsqb;0026&rsqb;</number> (3) information conveyed to a computer by a communications media, such as through a computer or telephone network accessed via network adapter <highlight><bold>130</bold></highlight>, including wireless communications. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> Such signal-bearing media, when carrying computer-readable instructions that direct the functions of the present invention, represent embodiments of the present invention. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 2A and 2B</cross-reference> depict block diagrams of example source code <highlight><bold>140</bold></highlight>-<highlight><bold>1</bold></highlight> and <highlight><bold>140</bold></highlight>-<highlight><bold>2</bold></highlight> to be compiled, according to an embodiment of the invention. Source code <highlight><bold>140</bold></highlight>-<highlight><bold>1</bold></highlight> and <highlight><bold>140</bold></highlight>-<highlight><bold>2</bold></highlight> are examples of source code <highlight><bold>140</bold></highlight>, as previously described above with reference to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. Referring again to <cross-reference target="DRAWINGS">FIG. 2</cross-reference>A, statements <highlight><bold>205</bold></highlight>, <highlight><bold>210</bold></highlight>, and <highlight><bold>215</bold></highlight> direct compiler <highlight><bold>135</bold></highlight> to generate object code that dynamically allocates an array &ldquo;A&rdquo; in three dimensions. The layout of array A in memory is further described below with reference to <cross-reference target="DRAWINGS">FIG. 3</cross-reference>. Referring again to <cross-reference target="DRAWINGS">FIG. 2</cross-reference>A, &ldquo;malloc&rdquo; is the memory-allocation function call defined in the C language, although in other embodiments, any language and any memory-allocation function call can be used. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2B</cross-reference> shows an example use of the elements of dynamically-allocated array A in For Loop <highlight><bold>250</bold></highlight>. The store of A&lsqb;1&rsqb;&lsqb;1&rsqb;&lsqb;i&rsqb; at reference label <highlight><bold>255</bold></highlight>, and the load of A&lsqb;1&rsqb;&lsqb;2&rsqb;&lsqb;i&rsqb; at reference label <highlight><bold>260</bold></highlight> can only be overlapped or reordered for better instruction scheduling if compiler <highlight><bold>135</bold></highlight> knows for certain that the memory locations accessed by A&lsqb;1&rsqb;&lsqb;1&rsqb;&lsqb;i&rsqb; <highlight><bold>255</bold></highlight> and A&lsqb;1&rsqb;&lsqb;2&rsqb;&lsqb;i&rsqb; <highlight><bold>260</bold></highlight> are distinct and do not map to the same memory location. Prior compilers cannot disambiguate the two accesses <highlight><bold>255</bold></highlight> and <highlight><bold>260</bold></highlight> because A&lsqb;1&rsqb;&lsqb;1&rsqb;&lsqb;i&rsqb; <highlight><bold>255</bold></highlight> and A&lsqb;1&rsqb;&lsqb;2&rsqb;&lsqb;i&rsqb; <highlight><bold>260</bold></highlight> are defined by the same malloc site <highlight><bold>215</bold></highlight> (a &ldquo;malloc site&rdquo; is defined to be a particular instance of the function-call malloc in the source code), but compiler <highlight><bold>135</bold></highlight> can disambiguate the two accesses <highlight><bold>255</bold></highlight> and <highlight><bold>260</bold></highlight> using the operations described below with reference to <cross-reference target="DRAWINGS">FIGS. 4, 5</cross-reference>, and <highlight><bold>6</bold></highlight>. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> Compiler <highlight><bold>135</bold></highlight> uses an alias-free test to determine whether the internal pointers used to reference elements of array A are defined once in each call to malloc and then never aliased in the program. (See <cross-reference target="DRAWINGS">FIG. 3</cross-reference>, described below, for examples of internal pointers.) If the alias-free test succeeds for the internal pointers of array A, then compiler <highlight><bold>135</bold></highlight> can safely assume that A&lsqb;1&rsqb;&lsqb;1&rsqb;&lsqb;i&rsqb; <highlight><bold>255</bold></highlight> and A&lsqb;1&rsqb;&lsqb;2&rsqb;&lsqb;i&rsqb; <highlight><bold>260</bold></highlight> reference distinct memory locations and can effectively create object code to reorder their store and load respectively. Thus, the alias-free test of compiler <highlight><bold>135</bold></highlight> determines whether a dynamically allocated multidimensional array will behave as a static array after it is allocated at runtime. More specifically, compiler <highlight><bold>135</bold></highlight> checks whether the internal pointers used to form the dynamic array are defined only once during the array allocation and are never aliased. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference><highlight><italic>b </italic></highlight>also shows another statement <highlight><bold>265</bold></highlight>, which alters the intermediate pointers used to access array A. Statements that alter the internal pointers used to access dynamically-allocated arrays cannot be optimized and will cause the alias-free test of compiler <highlight><bold>135</bold></highlight> to return a failure indication. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> depicts a block diagram example of dynamically-allocated memory, according to an embodiment of the invention. Dynamic memory array <highlight><bold>150</bold></highlight>-<highlight><bold>1</bold></highlight> is an example of dynamic memory array <highlight><bold>150</bold></highlight>, as previously described above with reference to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. Dynamic memory array <highlight><bold>150</bold></highlight>-<highlight><bold>1</bold></highlight> corresponds to the memory allocated by the code illustrated in the example of <cross-reference target="DRAWINGS">FIG. 2A</cross-reference>. Referring again to <cross-reference target="DRAWINGS">FIG. 3</cross-reference>, dynamic memory array <highlight><bold>150</bold></highlight>-<highlight><bold>1</bold></highlight> contains base pointer <highlight><bold>305</bold></highlight>, first level of internal pointers <highlight><bold>310</bold></highlight>, second level of internal pointers <highlight><bold>315</bold></highlight>, and array elements <highlight><bold>320</bold></highlight>. First level of internal pointers <highlight><bold>310</bold></highlight> are stored in the memory location associated with statement <highlight><bold>205</bold></highlight>. Second level of internal pointers <highlight><bold>315</bold></highlight> are stored in the memory location associated with statement <highlight><bold>210</bold></highlight>. Array elements <highlight><bold>320</bold></highlight>, which is where the actual array elements are stored, are stored in the memory location associated with statement <highlight><bold>215</bold></highlight>. Each of the internal pointer levels corresponds to a respective dimension in the multi-dimensional array A. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> Dynamically-allocated array A in this example has a first dimension of &ldquo;N&rdquo; elements (0 to N&minus;1), a second dimension of 3 elements (0 to 2), and a third dimension of &ldquo;M&rdquo; elements (0 to M&minus;1). The values of &ldquo;N&rdquo; and &ldquo;M&rdquo; are determined at runtime and can be any integers. The second dimension is defined to be 3 in this example, for ease of drawing the figure, but any number can be used for the second dimension. Also, the dimensions can be any combination of statically-allocated and dynamically-allocated dimensions, and in other embodiments all or only some of the dimensions of the array are dynamically allocated. Also, the invention is not limited to arrays of three dimensions, and the number of dimensions can be one, two, three, or any number. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> depicts a flowchart that describes a method for parallelizing code at computer <highlight><bold>100</bold></highlight>, according to an embodiment of the invention. Control begins at block <highlight><bold>400</bold></highlight>. Control then continues to block <highlight><bold>410</bold></highlight> where compiler <highlight><bold>135</bold></highlight> performs the alias-free test for a query on a dynamic-array reference, as further described below with reference to <cross-reference target="DRAWINGS">FIG. 6</cross-reference>. Although only one invocation of the functions of <cross-reference target="DRAWINGS">FIG. 6</cross-reference> are shown in block <highlight><bold>410</bold></highlight>, many invocations can be performed. Referring again to <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, control then continues to block <highlight><bold>420</bold></highlight> where compiler <highlight><bold>135</bold></highlight> determines whether the alias-free test was successful for certain dynamic-array references. Although only one test is shown at block <highlight><bold>420</bold></highlight>, many can be performed depending on the number and type of dynamic array-references. If the determination at block <highlight><bold>420</bold></highlight> is true, then control continues to block <highlight><bold>430</bold></highlight> where the instructions associated with the determination in block <highlight><bold>420</bold></highlight> are parallelized. In one embodiment, compiler <highlight><bold>135</bold></highlight> generates object code that overlaps load and store instructions. In another embodiment, compiler <highlight><bold>135</bold></highlight> generates object code that will execute a load instruction before an earlier store instruction. In still another embodiment software pipelining is performed. But, the invention can apply to any parallelizing technique that allows better instruction scheduling. <cross-reference target="DRAWINGS">FIG. 5</cross-reference> depicts a flowchart that describes a preprocessing method at computer <highlight><bold>100</bold></highlight>, according to an embodiment of the invention. Control begins at block <highlight><bold>500</bold></highlight>. Control then continues to block <highlight><bold>505</bold></highlight> where compiler <highlight><bold>135</bold></highlight> performs interprocedural linear-points-to analysis (LPT) on source code <highlight><bold>140</bold></highlight>. LPT is interprocedural in that it performs optimization between procedures. LPT analysis looks at all procedures in source code <highlight><bold>140</bold></highlight> and determines the memory locations that are referenced by pointers in source code <highlight><bold>140</bold></highlight>. LPT analysis also determines all of the pointers that reference each memory-allocation call. In addition, LPT analysis groups all the pointers into distinct sets in such a way that the pointers, across multiple sets, will not map to the same memory location. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> Control then continues to block <highlight><bold>510</bold></highlight> where compiler <highlight><bold>135</bold></highlight> determines whether all assignments in source code <highlight><bold>140</bold></highlight> have been processed. Block <highlight><bold>510</bold></highlight> is the beginning of a loop represented by blocks <highlight><bold>510</bold></highlight>, <highlight><bold>515</bold></highlight>, <highlight><bold>520</bold></highlight>, and <highlight><bold>522</bold></highlight>, which will process all assignment statements within source code <highlight><bold>140</bold></highlight>. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> When the determination at block <highlight><bold>510</bold></highlight> is false, control then continues to block <highlight><bold>515</bold></highlight> where compiler <highlight><bold>135</bold></highlight> determines the malloc location to which the left-hand side of the current assignment is aliased. That is, compiler <highlight><bold>135</bold></highlight> determines which statement (e.g., <highlight><bold>205</bold></highlight>, <highlight><bold>210</bold></highlight>, or <highlight><bold>215</bold></highlight>) in source code <highlight><bold>140</bold></highlight> created the malloc location associated with the assignee (the left-hand side of an assignment statement) in the current assignment statement. Using the examples of <cross-reference target="DRAWINGS">FIGS. 2A, 2B</cross-reference>, and <highlight><bold>3</bold></highlight>, one assignee is A&lsqb;1&rsqb;&lsqb;1&rsqb;&lsqb;i&rsqb; <highlight><bold>255</bold></highlight>, and compiler <highlight><bold>135</bold></highlight> at block <highlight><bold>515</bold></highlight> determines, in this example, that the malloc location associated with assignee <highlight><bold>255</bold></highlight> is malloc statement <highlight><bold>215</bold></highlight>, which corresponds to array elements <highlight><bold>320</bold></highlight>. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> Referring again to <cross-reference target="DRAWINGS">FIG. 5</cross-reference>, control then continues to block <highlight><bold>520</bold></highlight> where compiler <highlight><bold>135</bold></highlight> marks the malloc location found in block <highlight><bold>515</bold></highlight> as modified. Except that any assignment that invokes the malloc system call to account for the formation of the dynamic array is not marked as modified, such as assignments <highlight><bold>205</bold></highlight>, <highlight><bold>210</bold></highlight>, and <highlight><bold>215</bold></highlight> in the example shown in <cross-reference target="DRAWINGS">FIG. 2A</cross-reference>. Using the same example as for block <highlight><bold>515</bold></highlight>, compiler <highlight><bold>135</bold></highlight> marks the malloc location associated with statement <highlight><bold>215</bold></highlight> as modified since it is the malloc location associated with assignee <highlight><bold>255</bold></highlight>. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> Referring again to <cross-reference target="DRAWINGS">FIG. 5</cross-reference>, control then continues to block <highlight><bold>522</bold></highlight> where compiler <highlight><bold>135</bold></highlight> moves to the next assignment statement in source code <highlight><bold>140</bold></highlight>. Control then returns to block <highlight><bold>510</bold></highlight>, as previously described above. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> When the determination at block <highlight><bold>510</bold></highlight> is true, then all assignments within source code <highlight><bold>140</bold></highlight> have been processed, so control then continues to block <highlight><bold>599</bold></highlight> where the preprocessing phase concludes and the function returns. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> depicts a flowchart that describes processing for a query on a dynamic-array reference at computer <highlight><bold>100</bold></highlight>, according to an embodiment of the invention. The processing of <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is invoked once for each &ldquo;query&rdquo; from any compiler module. Here a &ldquo;query&rdquo; refers to a question that asks if a particular dynamic-array reference is alias-free and so can be treated as a statically-allocated array. Control begins at block <highlight><bold>625</bold></highlight>. Control then continues to block <highlight><bold>630</bold></highlight> where compiler <highlight><bold>135</bold></highlight> determines whether every level of internal pointers in the dynamic array corresponding to the current query have been processed. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> If the determination at block <highlight><bold>630</bold></highlight> is false, then control continues to block <highlight><bold>640</bold></highlight> where compiler <highlight><bold>135</bold></highlight> determines whether the malloc location corresponding to the current level of internal pointers is marked as having been modified. If the determination at block <highlight><bold>640</bold></highlight> is false, then control continues to block <highlight><bold>645</bold></highlight> where compiler <highlight><bold>135</bold></highlight> moves to the next level of internal pointers. Control then returns to block <highlight><bold>630</bold></highlight>, as previously described above. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> If the determination at block <highlight><bold>640</bold></highlight> is true, then control then continues to block <highlight><bold>650</bold></highlight> where compiler <highlight><bold>135</bold></highlight> indicates that the alias-free test failed for this query on a dynamic-array reference, so this query must be treated as query on a dynamic array. An example of such an assignment that causes the alias-free test to fail is statement <highlight><bold>265</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>B, which modifies second level of internal pointers <highlight><bold>315</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>. Referring again to <cross-reference target="DRAWINGS">FIG. 6</cross-reference>, control then continues to block <highlight><bold>651</bold></highlight> where the function returns. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> Referring again to <cross-reference target="DRAWINGS">FIG. 6</cross-reference>, if the determination at block <highlight><bold>630</bold></highlight> is true, then control continues to block <highlight><bold>635</bold></highlight> where compiler <highlight><bold>135</bold></highlight> indicates that the alias-free test passed for this query on a dynamic array reference, so this query can be treated as a query on a static array reference. Control then continues to block <highlight><bold>637</bold></highlight> where the function returns. </paragraph>
</section>
<section>
<heading lvl="1">Conclusion </heading>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> Code that dynamically allocates memory is optimized. An alias-free test analyzes the aliasing behavior of internal pointers of dynamically-allocated arrays and uses the analysis to disambiguate memory accesses and to eliminate false data dependencies. When a dynamically-allocated array behaves like a statically-allocated array throughout the entire program execution, the alias-free test allows better instruction scheduling, which yields better performance. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method, comprising: 
<claim-text>for every assignment statement in source code, determining a dynamic memory-allocation statement in the source code to which an assignee in the respective assignment statement refers; </claim-text>
<claim-text>when the respective assignment statement does not allocate memory, marking the respective dynamic memory-allocation statement as modified. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising: 
<claim-text>when the assignment statement does allocate memory, refraining from marking the respective dynamic memory-allocation statement as modified. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising: 
<claim-text>for every query on a dynamic array reference in the source code and for each level of internal pointers in a dynamic array associated with the query, 
<claim-text>determining whether the respective dynamic memory-allocation statement is marked as modified. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference>, further comprising: 
<claim-text>when none of the respective dynamic memory-allocations statements are marked as modified for the respective query, indicating that the respective dynamic-array is alias-free. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising: 
<claim-text>performing interprocedural linear-points-to analysis on the source code. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising: 
<claim-text>generating object code to create a multi-dimensional array in response to the dynamic memory-allocation statement. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference>, further comprising: 
<claim-text>creating internal pointers in response to the dynamic memory-allocation statement, wherein the internal pointers comprise a plurality of pointer levels, wherein each of the plurality of pointer levels corresponds to a respective dimension in the multi-dimensional array. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference>, wherein at least one dimension of the multi-dimensional array is dynamic. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. A compiler to translate source code into object code, wherein the compiler comprises instructions to: 
<claim-text>create internal pointers in response to a dynamic memory-allocation statement in the source code; </claim-text>
<claim-text>determine whether the internal pointers will be aliased when the object code is executed; </claim-text>
<claim-text>when the internal pointers are not aliased, parallelize memory accesses in the object code, wherein the memory accesses are associated with the dynamic memory-allocation statement. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The compiler of <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, wherein the compiler is to generate a portion of the object code to create a multi-dimensional array in response to the dynamic memory-allocation statement. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The compiler of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein the internal pointers comprise a plurality of pointer levels, wherein each of the plurality of pointer levels corresponds to a respective dimension in the multi-dimensional array. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The compiler of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein at least one dimension of the multi-dimensional array is dynamic. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The compiler of <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, wherein the instructions are further to: 
<claim-text>perform interprocedural linear-points-to analysis on the source code. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. A computer, comprising: 
<claim-text>a processor; and </claim-text>
<claim-text>memory communicatively coupled to the processor, wherein the memory comprises instructions, which when executed on the processor are to: 
<claim-text>find a dynamic memory-allocation statement in source code, </claim-text>
<claim-text>determine whether the source code includes a plurality of memory access statements to a memory allocated by the dynamic memory-allocation statement, wherein the plurality of memory access statements, when executed, will access the memory as if the memory were statically allocated, and </claim-text>
<claim-text>parallelize the plurality of memory access statements when the memory access statements will access the memory as if the memory were statically allocated. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The computer of <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference>, wherein the dynamic memory-allocation statement is to direct the instructions to: 
<claim-text>create a multi-dimensional array. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The computer of <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference>, wherein at least one dimension of the multi-dimensional array is dynamic. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The computer of <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference>, wherein all dimensions of the multi-dimensional array are dynamic. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The computer of <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference>, wherein the instructions are further to create internal pointers in response to the dynamic memory-allocation statement, wherein the internal pointers comprise a plurality of pointer levels, wherein each of the plurality of pointer levels corresponds to a respective dimension in the multi-dimensional array. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The compiler of <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference>, wherein to parallelize the plurality of memory access statements further comprises reordering load and store operations. </claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. A signal-bearing media comprising instructions, wherein the instructions when read and executed by a processor comprise: 
<claim-text>determining whether source code includes a plurality of memory access statements to a memory allocated by a dynamic memory-allocation statement in the source code, wherein the plurality of memory access statements, when executed, will access the memory as if the memory were statically allocated; and </claim-text>
<claim-text>when the determining element is true, parallelizing the plurality of memory access statements. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The signal-bearing media of <dependent-claim-reference depends_on="CLM-00022">claim 20</dependent-claim-reference>, wherein the dynamic memory-allocation statement is to direct the instructions to: 
<claim-text>create a multi-dimensional array. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The signal-bearing media of <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference>, wherein at least one dimension of the multidimensional array is dynamic. </claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The signal-bearing media of <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference>, wherein all dimensions of the multidimensional array are dynamic. </claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The signal-bearing media of <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference>, wherein the instructions are further to create internal pointers in response to the dynamic memory-allocation statement. </claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. The signal-bearing media of <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference>, wherein the internal pointers comprise: 
<claim-text>a plurality of pointer levels, wherein each of the plurality of pointer levels corresponds to a respective dimension in the multi-dimensional array. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. The signal-bearing media of <dependent-claim-reference depends_on="CLM-00022">claim 20</dependent-claim-reference>, wherein parallelizing the plurality of memory access statements further comprises: 
<claim-text>pipelining the plurality of memory access statements. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. The signal-bearing media of <dependent-claim-reference depends_on="CLM-00022">claim 20</dependent-claim-reference>, wherein parallelizing the plurality of memory access statements further comprises: 
<claim-text>overlapping a load instruction with a prior store instruction. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. The signal-bearing media of <dependent-claim-reference depends_on="CLM-00022">claim 20</dependent-claim-reference>, wherein parallelizing the plurality of memory access statements further comprises: 
<claim-text>reordering a load instruction and a prior store instruction.</claim-text>
</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>4</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005420A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005420A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005420A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005420A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005420A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005420A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030005420A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
