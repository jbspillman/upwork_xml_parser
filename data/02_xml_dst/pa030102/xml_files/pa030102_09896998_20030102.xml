<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030004972A1-20030102-D00000.TIF SYSTEM "US20030004972A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030004972A1-20030102-D00001.TIF SYSTEM "US20030004972A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030004972A1-20030102-D00002.TIF SYSTEM "US20030004972A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030004972A1-20030102-D00003.TIF SYSTEM "US20030004972A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030004972A1-20030102-D00004.TIF SYSTEM "US20030004972A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030004972A1-20030102-D00005.TIF SYSTEM "US20030004972A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030004972A1-20030102-D00006.TIF SYSTEM "US20030004972A1-20030102-D00006.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030004972</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09896998</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010702</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F007/00</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>707</class>
<subclass>200000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Method and apparatus for implementing a reliable open file system</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Alexander</given-name>
<family-name>Winokur</family-name>
</name>
<residence>
<residence-us>
<city>Haifa</city>
<state>IL</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
</inventors>
<correspondence-address>
<name-1>Peter M. Dichiara</name-1>
<name-2>Hale and Dorr LLP</name-2>
<address>
<address-1>60 State Street</address-1>
<city>Boston</city>
<state>MA</state>
<postalcode>02109</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">Systems and methods of servicing requests of a first file system communicated in accordance with a first storage protocol using a storage system that is responsive to requests communicated according to a second storage protocol and that is organized in accordance with a second file system. Among other things, this allows the use of potentially more reliable and robust storage systems for holding information of the first file system and allows potentially more reliable and robust management tools to manage the information of the first file system. </paragraph>
</subdoc-abstract>
<subdoc-description>
<cross-reference-to-related-applications>
<heading lvl="1">CROSS REFERENCE TO RELATED APPLICATIONS </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> This application is related to the following applications, all of which were filed on Jun. 28, 2000, all of which are assigned to the assignee of this applicatios, and all of which are incorporated by reference in their entirety: </paragraph>
<paragraph id="P-0002" lvl="2"><number>&lsqb;0002&rsqb;</number> I/O System Supporting Extended Functions and Methods Therefor (U.S. patent application Ser. No. 09/605,493); </paragraph>
<paragraph id="P-0003" lvl="2"><number>&lsqb;0003&rsqb;</number> Clustering System and Method (U.S. patent application Ser. No. 09/605,182); and </paragraph>
<paragraph id="P-0004" lvl="2"><number>&lsqb;0004&rsqb;</number> Device, System, and Method of Intelligently Splitting Information in an I/O System (U.S. patent application Ser. No. 09/605,438).</paragraph>
</cross-reference-to-related-applications>
<summary-of-invention>
<section>
<heading lvl="1">BACKGROUND </heading>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> 1. Field of the Invention </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> The present invention relates to a system and method that stores data for non-mainframe file systems on mainframe storage systems and that allows such data to be accessed by mainframe or non-mainframe file systems and connectivity. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> 2. Discussion of Related Art </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> The projected growth of storage for the coming years is staggering. Most of the growth is expected to be in &ldquo;open systems&rdquo; architectures and devices. Open systems storage, however, is considered to have certain shortcomings, concerning (a) disk reliability, (b) the robustness and richness of data management software, (c) data management functionality, (d) system reliability, and (e) performance. On the other hand, mainframe storage systems are believed to address the above concerns favorably. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> Open systems maintain data on open system disks using open system file systems like NTFS or UNIX (SUN/Solaris). Open system access their data using SCSI or fibre channel (FC) connectivity. Typically, servers access storage by specifying a device number a sector number and number of sectors to read/write. Each sector is typically 512 bytes. Typical file systems include a file directory table and a disk free space table along with other forms of &ldquo;meta data&rdquo; (i.e., information about the files themselves in contrast to the file&apos;s data). Each file has an entry in the file directory table that specifies the file&apos;s name and the physical locations where the file&apos;s data is stored. Typically, the physical locations are specified as a set of fixed-sized sectors (a cluster in NTFS terminology). The disk free space table specifies physical locations of free sectors or clusters, i.e., areas of storage that are currently free to be used by the file system. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> Mainframes maintain their data on mainframe storage systems using file systems like PS and VSAM. Mainframes manage their file systems through tools like SMS, HSM, and DFDSS. Mainframes access their data using ESCON connectivity. Mainframes typically organize storage as tracks (e.g., a complete circular section of a disk), cylinders (e.g., 15 stacked tracks corresponding to 15 stacked disk plates), and blocks, which can vary in size from as little as about 12 bytes to as large as about 56 kilobytes. Typical file systems include a file directory table and a disk free space table along with other forms of &ldquo;meta data.&rdquo; Each file has an entry in the file directory table (e.g., VTOC) that specifies the file&apos;s name and the physical locations where the file&apos;s data is stored. Typically, the physical locations are specified as blocks in tracks, or more specifically, by the cylinder, block, and head numbers. Each block may be arranged in CKD form, which specifies the count, key, and data. The disk free space table specifies free tracks of mainframe disks. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY </heading>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> The present invention provides systems and methods of servicing requests of a first file system communicated in accordance with a first storage protocol using a storage system that is responsive to requests communicated according to a second storage protocol and that is organized in accordance with a second file system. Among other things, this allows the use of potentially more reliable and robust storage systems for holding information of the first file system and allows potentially more reliable and robust management tools to manage the information of the first file system. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> According to one aspect of the invention, a first portion of the storage system is allocated to hold data of the first file system. The first portion includes a set of locations for holding directory information of the first file system. A second portion of the storage system is allocated to hold data for the second file system. The second portion includes a set of locations for holding directory information of the second file system, including a set of file information entries corresponding to files of the first file system. Requests of the first file system are intercepted, and the intercepted requests are converted to corresponding requests in the second storage protocol. The conversion includes converting addressing information in the intercepted requests to addressing information in accordance with the second storage protocol. The converted requests are provided to the storage system so that the storage system may service the request. The intercepted requests are analyzed to determine if the requests are updating the set of locations holding directory information of the first file system. If so, corresponding update requests are constructed to update a corresponding file information entry in the second portion. In this fashion, the second portion includes entries that are consistent with the information in the first portion.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE FIGURES </heading>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> In the Drawing, </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> illustrates the architecture of preferred embodiments; </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> FIGS. <highlight><bold>2</bold></highlight>A-B illustrate the access logic platform according to preferred embodiments of the invention; </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> illustrates the software architecture of the access logic platform according to a preferred embodiment of the invention; </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> illustrates a preferred embodiment of the invention using the platform of FIGS. <highlight><bold>2</bold></highlight>A-C; </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> illustrates the common file system logic according to a preferred embodiment of the invention.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION </heading>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> Preferred embodiments maintain files on mainframe storage and allow access to the files by both mainframe file systems and open system file systems over, respectively, mainframe connectivity and open systems connectivity. From the perspective of the open system servers (e.g., NT and UNIX machines), the files look and behave like conventional files in an open system file system connected by conventional open systems connectivity. From the perspective of the mainframe systems, the files look and behave like conventional files in a mainframe file system connected by conventional mainframe connectivity. Thus, by using preferred embodiments of the invention, open system files may be stored on mainframe storage systems and disks, yet remain accessible to software executing on the mainframe or open system server. Thus, for example, applications running on the open system server may still use the files, and data management tools running on a mainframe may also access and manage the files. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> illustrates the architecture of preferred embodiments. A mainframe host <highlight><bold>110</bold></highlight> and an open systems server <highlight><bold>130</bold></highlight> each communicate with access logic <highlight><bold>150</bold></highlight>, which in turn communicates with conventional mainframe storage <highlight><bold>120</bold></highlight> (which can be a conventional disk system, control unit, or the like). The mainframe storage holds file data and meta data for the mainframe file system <highlight><bold>115</bold></highlight> and the file data and meta data for the open system file system. Specifically, a portion <highlight><bold>140</bold></highlight> of the mainframe storage <highlight><bold>120</bold></highlight> is allocated to hold the file data and the file system meta data of the open system file system <highlight><bold>135</bold></highlight>. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> Under preferred embodiments, the mainframe <highlight><bold>110</bold></highlight> and open system server <highlight><bold>130</bold></highlight> access files using their conventional, respective file system logic <highlight><bold>115</bold></highlight>, <highlight><bold>135</bold></highlight> and using their conventional forms of physical connectivity <highlight><bold>117</bold></highlight>, <highlight><bold>137</bold></highlight>. In this fashion, access to the files is seamless. As stated above, the mainframe host <highlight><bold>110</bold></highlight> may use PS file system logic <highlight><bold>115</bold></highlight>, and the open system server <highlight><bold>130</bold></highlight> may use NTFS or SUN/Solaris for file system logic <highlight><bold>135</bold></highlight>. The mainframe <highlight><bold>110</bold></highlight> might use ESCON connectivity to access files, and the open systems server <highlight><bold>130</bold></highlight> might use native SCSI connectivity or SCSI over fibre channel (SCSI/FC) connectivity <highlight><bold>137</bold></highlight>. Under certain embodiments, the access logic <highlight><bold>150</bold></highlight> will access the mainframe storage <highlight><bold>120</bold></highlight> with ESCON connectivity <highlight><bold>157</bold></highlight>. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> The access logic <highlight><bold>150</bold></highlight> receives commands and addresses from the mainframe host <highlight><bold>110</bold></highlight> and the open system server <highlight><bold>130</bold></highlight> expressed in forms conventional for the respective host and server. The access logic <highlight><bold>150</bold></highlight> converts the commands and addresses from the open system server <highlight><bold>130</bold></highlight> to corresponding commands and addresses that the mainframe storage <highlight><bold>120</bold></highlight> can process. Likewise, the access logic <highlight><bold>150</bold></highlight> converts command responses and status from the mainframe storage <highlight><bold>120</bold></highlight> to an appropriate form to send to the open system server <highlight><bold>130</bold></highlight>. The commands and addresses from the mainframe host <highlight><bold>110</bold></highlight> do not need conversion, though under certain embodiments they may be monitored by the access logic <highlight><bold>150</bold></highlight>. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> More specifically, the access logic <highlight><bold>150</bold></highlight> includes (a) logic to bridge open systems connectivity links (e.g., SCSI or FC) to links used by mainframe storage (e.g., ESCON); (b) logic to map or correlate commands, addresses, and disk formats of open systems to corresponding commands, addresses, and disk formats for mainframe systems; and (c) logic to maintain the meta-data for both the mainframe and open systems disk file systems to facilitate file access by both mainframe systems and open system servers. </paragraph>
<paragraph id="P-0024" lvl="7"><number>&lsqb;0024&rsqb;</number> Platform for Access Logic </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> A preferred embodiment of the invention implements the access logic outlined above on a platform described in U.S. patent application Ser. No. 09/605,493, entitled &ldquo;IO SYSTEM SUPPORTING EXTENDED FUNCTIONS AND METHOD THEREFOR&rdquo; (filed Jun. 28,2000) which is hereby incorporated by reference in its entirety. That platform is outlined below for convenience. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> Referring to FIGS. <highlight><bold>2</bold></highlight>A-B and as described in the patent application identified above, the platform includes a host system <highlight><bold>260</bold></highlight> (as distinguished from a mainframe host) and one or more intelligent splitters <highlight><bold>200</bold></highlight>. Among other things, the host <highlight><bold>260</bold></highlight> interacts with and may control and configure the various splitters, and it may communicate with open system servers (e.g., server <highlight><bold>280</bold></highlight>) according to open system connectivity links and protocols. The host <highlight><bold>260</bold></highlight> may also communicate using other communication and storage protocols, e.g., TCP/IP. In this fashion, the host <highlight><bold>260</bold></highlight> may be made to communicate with &ldquo;agents&rdquo; on servers or other computer systems. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> Under preferred embodiments, the host <highlight><bold>260</bold></highlight>, under programmatic or user control, can define &ldquo;sessions&rdquo; in a splitter <highlight><bold>200</bold></highlight>, which instruct the splitter to detect certain commands and addresses on its links, e.g., <highlight><bold>117</bold></highlight>, and to take specified actions in response thereto. For example, the session may instruct the splitter to (a) detect whether a mainframe link <highlight><bold>117</bold></highlight> is reading from or writing to certain addresses corresponding to storage locations having file system meta data and (b) inform the host <highlight><bold>260</bold></highlight> accordingly. Likewise, the session may instruct the splitter to detect when a storage link <highlight><bold>157</bold></highlight> is returning data and/or status and to inform the host <highlight><bold>260</bold></highlight> accordingly. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> Moreover, under preferred embodiments, the host <highlight><bold>260</bold></highlight> can cause the splitter <highlight><bold>200</bold></highlight> to transmit specified channel command words (CCWs) under the ESCON protocol to a particular connectivity link. Thus, for example, the host <highlight><bold>260</bold></highlight> may create a CCW that would write information to a particular storage location and cause the splitter to send that CCW on a particular link, e.g., <highlight><bold>157</bold></highlight>. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> As described more fully in the patent application identified above, each intelligent splitter <highlight><bold>200</bold></highlight> is a multiport programmable device. The splitter can monitor the various ports and detect the commands and addresses flowing through it. Moreover, the splitter can retransmit IO streams received by it on one or more ports, respond to IO streams received by it, alter the received IO stream (either in a control or data portion) and transmit the altered stream, or invoke the host <highlight><bold>260</bold></highlight> in response to a received IO stream. All of the above may be the result of a specific session definition and/or in response to instructions from host <highlight><bold>260</bold></highlight>. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> The intelligent splitter <highlight><bold>200</bold></highlight> may communicate with a host system <highlight><bold>260</bold></highlight> via a bus <highlight><bold>268</bold></highlight>. This communication path may require separate logic <highlight><bold>270</bold></highlight>, for example, to bridge the bus <highlight><bold>268</bold></highlight> with the local bus <highlight><bold>250</bold></highlight> of the intelligent splitter. Alternatively, the bridge logic <highlight><bold>270</bold></highlight> may be integrated into the processor <highlight><bold>230</bold></highlight> as is known in the art. <cross-reference target="DRAWINGS">FIG. 2B</cross-reference> illustrates a DMA Engine <highlight><bold>266</bold></highlight> separately as a convenient descriptive shorthand to show the relevant functionality; this logic may be separate, integrated in bus bridge hardware <highlight><bold>270</bold></highlight> or provided by the local processor <highlight><bold>230</bold></highlight>. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> The path <highlight><bold>268</bold></highlight> allows a host system to, among other things, read data from, and write data to, the splitter&apos;s common buffer <highlight><bold>220</bold></highlight> and the processor memory <highlight><bold>240</bold></highlight> either directly or indirectly. In this way, the host <highlight><bold>260</bold></highlight> may load software for the processor <highlight><bold>230</bold></highlight> to execute, may establish configuration parameters, and may pass messages to the processor <highlight><bold>230</bold></highlight>. The host processor <highlight><bold>262</bold></highlight> and memory <highlight><bold>264</bold></highlight> are part of a complete host system <highlight><bold>260</bold></highlight> that, among other things, includes non-volatile storage and a network connection(s). </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> Under a preferred embodiment, the splitter <highlight><bold>200</bold></highlight> operates on IO streams at a physical address level, and the host <highlight><bold>260</bold></highlight> is responsible for implementing functionality at a logical level. Under this arrangement, the splitter <highlight><bold>200</bold></highlight> is configured by the host <highlight><bold>260</bold></highlight> to take certain actions when IO streams fall within prescribed, physical address domains (e.g., physical volumes, tracks, sectors, and physical blocks). This specification of a physical address domain and associated actions to be performed is a &ldquo;session definition.&rdquo; The host <highlight><bold>260</bold></highlight> is a separate computing entity (akin to a file server) that is programmed to understand a logical level of addressing abstraction (e.g., databases, file systems, logical records). It includes logic (discussed more fully below) to map logical-level objects to a corresponding physical address domain. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a diagram illustrating the software architecture of a preferred embodiment. It includes a link interface <highlight><bold>305</bold></highlight>, an intelligent splitter subsystem <highlight><bold>310</bold></highlight>, a host/splitter interface <highlight><bold>325</bold></highlight>, and a host system <highlight><bold>320</bold></highlight>. It also includes a web server subsystem and an agent module subsystem (not shown). </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> The link interface (or splitter/port interface) software <highlight><bold>305</bold></highlight> controls the link hardware of the splitter <highlight><bold>200</bold></highlight> and is used by the splitter subsystem <highlight><bold>310</bold></highlight>, described below. This interface <highlight><bold>305</bold></highlight> is used for the transmission and reception of ESCON frames on splitter ports. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> The intelligent splitter subsystem software <highlight><bold>310</bold></highlight> provides data and control access to mainframe storage and other devices connected to one of the ports of a splitter device <highlight><bold>200</bold></highlight>. This subsystem primarily operates at a physical level. It operates in response to one of the following events: (1) a service request from the host <highlight><bold>260</bold></highlight> through the host/splitter interface <highlight><bold>325</bold></highlight>, (2) indirectly as a result of an interrupt from a splitter port, processed by the link interface; and (3) timer interrupts. The splitter subsystem <highlight><bold>310</bold></highlight> also includes logic to send CCWs or chains out one of the splitter Ports to mimic the operations that might otherwise result from a mainframe host or a control unit issuing a CCW chain. This logic interacts with a host <highlight><bold>260</bold></highlight> and includes state machine logic to monitor and control the sending of a CCW or chain to comply with the ESCON protocol. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> Host/splitter interface software <highlight><bold>325</bold></highlight> defines a mechanism for transferring data and control between the host <highlight><bold>260</bold></highlight> and a splitter <highlight><bold>200</bold></highlight>. Among other things, this interface is used so that the host can convey session definitions to a splitter <highlight><bold>200</bold></highlight>. For example a message may be sent to the splitter to specify (a) the control unit address (b) the device address, and (c) the set of tracks for which a specified action is to be performed. This information may be stored in splitter data structures and later used by the software to determine whether an IO stream received by the splitter falls into a registered domain. The host <highlight><bold>260</bold></highlight> also sends a message to the intelligent splitter <highlight><bold>200</bold></highlight> that identifies the logic to execute for the specific subject. The interface software <highlight><bold>325</bold></highlight> facilitates the control of the splitter&apos;s work, shares information between the splitter <highlight><bold>200</bold></highlight> and the host <highlight><bold>260</bold></highlight>, synchronizes content of corresponding data structures across host/splitter boundaries, and synchronizes execution flow between the tasks executing on a host and the tasks executing on a splitter. Among other things, this interface helps the host <highlight><bold>260</bold></highlight> configure a splitter <highlight><bold>200</bold></highlight> and request services from the splitter. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> In one embodiment, interface <highlight><bold>325</bold></highlight> uses messages to provide communication between the host and a splitter. Messages are sent over the bus <highlight><bold>268</bold></highlight> by a PCI bus driver, and the splitter and host communicate according to a defined splitter interface API. The splitter interface API defines the interface through which applications access the functionality provided by the splitter <highlight><bold>200</bold></highlight> and splitter subsystem <highlight><bold>310</bold></highlight>. The host software uses routines from the API to communicate with the splitter. The routine sends a corresponding message to a relevant splitter. This routine passes the host&apos;s request along with the necessary, corresponding parameters to the splitter. When the splitter <highlight><bold>200</bold></highlight> completes the processing of the request, the splitter <highlight><bold>200</bold></highlight> sends a message back with the completion status and possibly with additional data to satisfy the request. Some API routines execute synchronously, meaning that the host routine making the call blocks from further execution until a reply message is received from the splitter. Some API routines operate asynchronously (i.e., non-blocking). In one embodiment, asynchronous routines operate in conjunction with a callback routine that should be invoked when a response message eventually arrives from the splitter. In one embodiment, the interface API provides routines for (1) defining sessions; (2) service requests; (3) breakpoint/notification requests; (4) querying and setting the current state of a splitter; (5) receiving and/or sending data update requests; and (6) resources allocation requests. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> The host subsystem <highlight><bold>320</bold></highlight> includes a web interface component <highlight><bold>331</bold></highlight>, an interrupt handler <highlight><bold>332</bold></highlight>, file system mappers <highlight><bold>333</bold></highlight>, system management <highlight><bold>334</bold></highlight>, a Fibre Channel (FC) subsystem <highlight><bold>335</bold></highlight>, system services <highlight><bold>336</bold></highlight>, and clustering services <highlight><bold>337</bold></highlight>. These components and services in turn may be used by host applications <highlight><bold>340</bold></highlight> and the other host components to implement data management applications and functions. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> The web interface component <highlight><bold>331</bold></highlight> provides an interface to a web server subsystem <highlight><bold>270</bold></highlight> that allows a web server to facilitate servicing, managing, and debugging of the system via a remote web-based console. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> The interrupt handler <highlight><bold>332</bold></highlight> handles breakpoints and assists with their dispatching. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> The file system mappers <highlight><bold>333</bold></highlight> include logic to map logical objects into their corresponding physical addresses. These physical addresses may then be used in the construction of session definitions and service requests. In one embodiment, the file system mappers cooperate with agents on other systems. For example an agent may execute on a file server <highlight><bold>280</bold></highlight> operating under another operating system (e.g., LINUX, NT, Solaris) and this other file server may be effectively merged into the system using the host <highlight><bold>260</bold></highlight>. For example, the file mapper may cooperate with such agents to request physical and logical level information from such file servers (i.e., metadata) or to perform other operating system functions on the host behalf (e.g., open a file on the server). The host may use metadata to implement logical level functions and operations in conjunction with a splitter, e.g., mirroring on a logical level. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> System management <highlight><bold>334</bold></highlight> is responsible for performing administrative functions, e.g., configuring the system, shutting down devices, and the like. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> Fibre Channel (FC) subsystem <highlight><bold>335</bold></highlight> is responsible for communicating with components <highlight><bold>290</bold></highlight> over a fibre channel protocol. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> System services <highlight><bold>336</bold></highlight> is responsible for providing and interfacing with operating system services. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> Clustering services <highlight><bold>337</bold></highlight> is responsible for arranging hosts <highlight><bold>260</bold></highlight> and splitters into clustered arrangements to improve connectivity and reliability. (This clustering is not to be confused with mainframe-level clustering described below.) </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> Applications <highlight><bold>340</bold></highlight> refers to data management applications that may be executed on the host. For example, the applications identified above described various forms of extended functions that may be implemented on the platform. In the sections that follow, another application to implement the common file system logic is described. </paragraph>
<paragraph id="P-0047" lvl="7"><number>&lsqb;0047&rsqb;</number> Common File System Logic </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> One embodiment of the invention uses the platform outlined above to implement the access logic <highlight><bold>150</bold></highlight>. Referring to <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, the platform <highlight><bold>150</bold></highlight> uses one port on a splitter <highlight><bold>200</bold></highlight> to handle the ESCON connectivity <highlight><bold>117</bold></highlight> to the mainframe host <highlight><bold>110</bold></highlight>, another port on the same splitter <highlight><bold>200</bold></highlight> to handle ESCON connectivity <highlight><bold>157</bold></highlight> to the mainframe storage <highlight><bold>120</bold></highlight>, and fibre channel interface card <highlight><bold>405</bold></highlight> (e.g., available from QLogic) in communication with host <highlight><bold>260</bold></highlight> to handle connectivity <highlight><bold>137</bold></highlight> to the open system server <highlight><bold>130</bold></highlight>. Not shown in this figure for the sake of simplicity is an IP interface from host <highlight><bold>260</bold></highlight> and through which the host <highlight><bold>260</bold></highlight> may communicate with agents <highlight><bold>113</bold></highlight> and <highlight><bold>133</bold></highlight> shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> The host <highlight><bold>260</bold></highlight> software includes common file system logic <highlight><bold>155</bold></highlight> (see <cross-reference target="DRAWINGS">FIGS. 1 and 5</cross-reference>) as an application that uses the splitter <highlight><bold>200</bold></highlight> and splitter software of the access logic platform <highlight><bold>150</bold></highlight> outlined above. The common file system logic <highlight><bold>155</bold></highlight> includes open system link handling logic <highlight><bold>505</bold></highlight>; address mapping logic <highlight><bold>510</bold></highlight>; command mapping logic <highlight><bold>515</bold></highlight>; mainframe storage logic <highlight><bold>520</bold></highlight>; and meta data maintenance logic <highlight><bold>525</bold></highlight>. </paragraph>
<paragraph id="P-0050" lvl="7"><number>&lsqb;0050&rsqb;</number> Open System Link Handling Logic </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> The link handling logic <highlight><bold>505</bold></highlight> is primarily responsible for interfacing with the open system connectivity link <highlight><bold>137</bold></highlight> (e.g., via FC interface cards) and monitoring traffic on such link. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> On the reception side, this logic <highlight><bold>505</bold></highlight> is invoked when new commands and addresses arrive on open system connectivity link. Under one embodiment, the link handling logic <highlight><bold>505</bold></highlight> then accesses internal data structures (not shown) to determine if the command and address (a) fall within a range that should be processed by mainframe storage <highlight><bold>120</bold></highlight> or (b) are outside of the above-mentioned range. In the former case, the link handling logic cooperates with the address mapping logic <highlight><bold>510</bold></highlight> and the command mapping logic <highlight><bold>515</bold></highlight> to determine corresponding mainframe storage addresses and commands for those open system commands and addresses that are to be processed by the mainframe storage. In the latter case, the command and address (and any other data part of the open system operation) will be forwarded on open system connectivity to open system storage (see <cross-reference target="DRAWINGS">FIG. 4</cross-reference>); in this case, the open system storage requests are not handled by the mainframe storage <highlight><bold>120</bold></highlight>. In one embodiment, all open system operations arriving on open system connectivity <highlight><bold>137</bold></highlight> are to be processed by the mainframe storage <highlight><bold>120</bold></highlight>, but in other embodiments, only a subset of the IO space may be so handled, for example, for the applications most needing the reliability and data management offered by the mainframe storage system <highlight><bold>120</bold></highlight>. Once the corresponding mainframe command and address for the storage locations are determined, the information is passed to the mainframe storage logic <highlight><bold>520</bold></highlight>, discussed below, which is responsible for ensuring that the operation is issued to mainframe storage <highlight><bold>120</bold></highlight>. In this way, open system commands and addresses may be transformed or translated to corresponding mainframe storage system commands and addresses. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> On the transmission side, the link handling logic <highlight><bold>505</bold></highlight> receives mainframe data and statuses from the mainframe storage logic <highlight><bold>520</bold></highlight>. The link handling logic <highlight><bold>505</bold></highlight> then cooperates with the command mapping logic <highlight><bold>515</bold></highlight> to convert the statuses as appropriate to open system commands. It also causes the converted statuses or data to be sent to the open system server in accordance with the connectivity protocol. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> The open system link handling logic <highlight><bold>505</bold></highlight> can be configured to watch for (or monitor) command and address pairs and to inform other software accordingly in response thereto. In this fashion, and as will be explained more fully below, the link handling logic <highlight><bold>505</bold></highlight> can detect whether the open system server <highlight><bold>130</bold></highlight> is attempting to update certain meta data by detecting write commands to addresses used for holding meta data file information. Any writes to such addresses may then be detected and used to inform other software, such as the meta data maintenance logic <highlight><bold>525</bold></highlight>. </paragraph>
<paragraph id="P-0055" lvl="7"><number>&lsqb;0055&rsqb;</number> Address Mapping Logic </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> One embodiment of the invention uses algorithmic mapping of open system addresses to mainframe addresses. Under this embodiment, the portion <highlight><bold>140</bold></highlight> of the mainframe storage <highlight><bold>120</bold></highlight> that is allocated to hold open system file system data is initially formatted to be organized as fixed physical blocks. That is, even though the mainframe file system logic <highlight><bold>115</bold></highlight> permits the mainframe storage system to be allocated as variable sized blocks, the file system logic <highlight><bold>115</bold></highlight> is invoked to organize portion <highlight><bold>140</bold></highlight> as fixed size blocks. Moreover, the portion <highlight><bold>140</bold></highlight> is configured so that the block size is the size of one or more sector sizes of the open system organization (i.e., the open system unit of file space allocation is a sector). </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> As stated above, the open system server will address IO space using a device number and a sector number. The correspondence between the open system device number, e.g., SCSI, and the mainframe system device number may be represented as</paragraph>
<paragraph lvl="0"><in-line-formula>(Mainframe_dev, offset)&equals;MAP (SCSI_dev)</in-line-formula></paragraph>
<paragraph id="P-0058" lvl="7"><number>&lsqb;0058&rsqb;</number> meaning that the set of mainframe device numbers and offset (in sectors) may be equated to a mapping function with the SCSI device number as a variable. Thus, more than one SCSI device can share the same mainframe device. Moreover, the mapping (i.e., MAP_ may be defined as part of system configuration). Device addresses are as specified by the SCSI and ECKD standards respectively. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> Under the above embodiment, this device number and sector number are algorithmically converted into a specific location on mainframe storage, specified as a combination of cylinder number, head number, block number and sequence number (indicating the given sector within a block, if the block is configured to have a size to hold multiple sectors). </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> For embodiments in which the mainframe storage <highlight><bold>120</bold></highlight> uses cylinders having 15 heads, the mainframe storage address is determined from the open system address according to the following logic. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> Inputs: </paragraph>
<paragraph id="P-0062" lvl="2"><number>&lsqb;0062&rsqb;</number> SCSI_dev is the SCSI device ID </paragraph>
<paragraph id="P-0063" lvl="2"><number>&lsqb;0063&rsqb;</number> N is the number of blocks on track (determined based on disk technology used); </paragraph>
<paragraph id="P-0064" lvl="2"><number>&lsqb;0064&rsqb;</number> M is the number of sectors per block </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> Outputs: </paragraph>
<paragraph id="P-0066" lvl="2"><number>&lsqb;0066&rsqb;</number> Sector is the open system sector number specified in an open system read or write operation (in this context Sector and ESCON_dev are output of the MAP function); </paragraph>
<paragraph id="P-0067" lvl="2"><number>&lsqb;0067&rsqb;</number> ESCON_dev is the mainframe device address; </paragraph>
<paragraph id="P-0068" lvl="2"><number>&lsqb;0068&rsqb;</number> Offset beginning track of the open systems devices on the mainframe device </paragraph>
<paragraph id="P-0069" lvl="2"><number>&lsqb;0069&rsqb;</number> S is the sector number as mapped to a mainframe device </paragraph>
<paragraph id="P-0070" lvl="2"><number>&lsqb;0070&rsqb;</number> C is the mainframe cylinder number where a sector S resides </paragraph>
<paragraph id="P-0071" lvl="2"><number>&lsqb;0071&rsqb;</number> H is the mainframe disk head number (assume there are 15 heads all together) through which sector S will be read/written </paragraph>
<paragraph id="P-0072" lvl="2"><number>&lsqb;0072&rsqb;</number> R is the mainframe block number on the track where sector S resides </paragraph>
<paragraph id="P-0073" lvl="2"><number>&lsqb;0073&rsqb;</number> I is the mainframe sequence number of sector S in block R (this is used if the block holds more than one sector) </paragraph>
<paragraph id="P-0074" lvl="0"><number>&lsqb;0074&rsqb;</number> Since the number of sectors on cylinder is N*M*15 (assuming that there are 15 heads in a cylinder) then</paragraph>
<paragraph lvl="0"><in-line-formula>(ESCON_dev, offset)&equals;MAP (SCSI_dev)</in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>S</italic></highlight>&equals;Sector&plus;offset</in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>C</italic></highlight>&equals;floor(<highlight><italic>S</italic></highlight>/(<highlight><italic>N*M*</italic></highlight>15))</in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>H</italic></highlight>&equals;floor((<highlight><italic>S&minus;C*N*M*</italic></highlight>15)/(<highlight><italic>N*M</italic></highlight>))</in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>R</italic></highlight>&equals;floor((<highlight><italic>S&minus;C*N*M*</italic></highlight>15<highlight><italic>&minus;H*N*M))</italic></highlight></in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>I&equals;S&minus;C*N*M*</italic></highlight><highlight><bold>15</bold></highlight>&minus;<highlight><italic>H*N*M&minus;R*M</italic></highlight></in-line-formula></paragraph>
<paragraph id="P-0075" lvl="7"><number>&lsqb;0075&rsqb;</number> &ldquo;Floor&rdquo; is the operand truncating a number to the lower integer value. </paragraph>
<paragraph id="P-0076" lvl="7"><number>&lsqb;0076&rsqb;</number> Command Mapping Logic </paragraph>
<paragraph id="P-0077" lvl="0"><number>&lsqb;0077&rsqb;</number> As outlined above, the command mapping logic <highlight><bold>515</bold></highlight> can map an open system command(s) to a corresponding mainframe command(s) and vice versa. For example, one embodiment maps SCSI control commands to the corresponding CCW control commands. SCSI control commands which have no meaning in the mainframe disk domain will be intercepted and blocked from passing to the mainframe storage, i.e., translating those commands into &ldquo;no operations&rdquo; or &ldquo;no-ops&rdquo;. In these instances, the link handling logic <highlight><bold>505</bold></highlight> will return appropriate status to the open system server so that the server will believe that the operation executed correctly. Analogously, SCSI read or write commands are mapped to corresponding mainframe commands. In some instance, one open system command may require several &ldquo;sub&rdquo; commands as part of a CCW chain, and in this sense it may be easier to think of the mapping as between open system commands and the operations contained in CCWs to mainframe storage <highlight><bold>120</bold></highlight>. </paragraph>
<paragraph id="P-0078" lvl="0"><number>&lsqb;0078&rsqb;</number> Responses and statuses from the mainframe storage <highlight><bold>120</bold></highlight> need to be converted into an appropriate form for the open system <highlight><bold>130</bold></highlight> as outlined above. For example, an &ldquo;end of chain Channel end device end&rdquo; is translated to good SCSI status. A unit check status is translated to check condition SCSI status. A status modifier is translated to condition met SCSI status. A device busy or control unit busy status is translated to busy SCSI status. All other ESCON status codes will be internally handled by the bridging apparatus in a way similar to a mainframe handling of these statuses. </paragraph>
<paragraph id="P-0079" lvl="0"><number>&lsqb;0079&rsqb;</number> Alternative embodiments that support SCSI over FC connectivity operate analogously. </paragraph>
<paragraph id="P-0080" lvl="7"><number>&lsqb;0080&rsqb;</number> Mainframe Storage Logic </paragraph>
<paragraph id="P-0081" lvl="0"><number>&lsqb;0081&rsqb;</number> The mainframe storage logic <highlight><bold>520</bold></highlight> is primarily responsible for interfacing with the splitter software outlined above. More specifically, the mainframe storage logic <highlight><bold>520</bold></highlight> receives commands and addresses from the link handling logic, and in response constructs CCWs and causes the splitter <highlight><bold>200</bold></highlight> to issue the CCWs. Among other things, this logic may need to establish breakpoints to monitor the status of CCW operations. On the reception side, this logic <highlight><bold>520</bold></highlight> receives CCWs and other responses from the mainframe storage <highlight><bold>120</bold></highlight>, via the splitter <highlight><bold>200</bold></highlight>, and sends the corresponding information to the link handling logic <highlight><bold>505</bold></highlight>. </paragraph>
<paragraph id="P-0082" lvl="0"><number>&lsqb;0082&rsqb;</number> The mainframe storage logic <highlight><bold>520</bold></highlight> of certain embodiments is responsible for defining sessions in the splitter <highlight><bold>200</bold></highlight> to cause the splitter to monitor the IO stream from the mainframe to detect whether relevant meta data (more below) is being updated by the mainframe <highlight><bold>110</bold></highlight>. If so, the splitter <highlight><bold>200</bold></highlight> will inform the mainframe storage logic <highlight><bold>520</bold></highlight>, for example, via a breakpoint, which in turn will inform the meta data maintenance logic <highlight><bold>525</bold></highlight> accordingly. </paragraph>
<paragraph id="P-0083" lvl="7"><number>&lsqb;0083&rsqb;</number> Meta Data Maintenance Logic </paragraph>
<paragraph id="P-0084" lvl="0"><number>&lsqb;0084&rsqb;</number> The purpose of the meta data maintenance logic <highlight><bold>525</bold></highlight> is to ensure that the mainframe <highlight><bold>110</bold></highlight> and the open system <highlight><bold>130</bold></highlight> have consistent images of the open system files stored on the mainframe storage. In this fashion, the mainframe <highlight><bold>110</bold></highlight> can, if desired, operate on the open system files stored on the mainframe storage <highlight><bold>120</bold></highlight> using mainframe data management tools, or the like in a file-specific way. Certain embodiments of the invention can receive the reliability benefit of mainframe storage without the meta data maintenance logic, but the mainframe tools cannot operate on such data at a file-level of operation. Instead, under these embodiments, the tools would have to treat the open system files as one mainframe file corresponding to the entire reserved portion <highlight><bold>140</bold></highlight>. </paragraph>
<paragraph id="P-0085" lvl="0"><number>&lsqb;0085&rsqb;</number> In one embodiment, the mainframe <highlight><bold>110</bold></highlight> is expected to only operate passively on the open system files, meaning that the mainframe will not delete or alter the contents of the open system files. The mainframe file system <highlight><bold>115</bold></highlight> defines the data within portion <highlight><bold>140</bold></highlight> like ordinary mainframe files (more below). Thus, if an open system files within portion <highlight><bold>140</bold></highlight> is called &ldquo;X.doc&rdquo; then the mainframe file system&apos;s meta data also reflects that there is a file at the identical location called &ldquo;X.doc&rdquo; or at least something that has a correspondency thereto. Note, for Unix-like file systems the file name reflects the complete path of the file. For NTFS, the filename includes the device letter on which the file resides. Likewise, the IO locations within <highlight><bold>140</bold></highlight> that hold meta data for the open system will likewise be reflected as files manageable by the mainframe file system <highlight><bold>115</bold></highlight>. </paragraph>
<paragraph id="P-0086" lvl="0"><number>&lsqb;0086&rsqb;</number> In this one embodiment, the meta data maintenance logic <highlight><bold>525</bold></highlight> is responsible for ensuring in real time that the mainframe&apos;s meta data image of portion <highlight><bold>140</bold></highlight> is consistent with the open system&apos;s image. To such end, the link handling logic <highlight><bold>505</bold></highlight> is configured to detect writes to the locations corresponding to the open system&apos;s file system&apos;s meta data. For example, these locations may be written to write an entry in the file directory table to create a file or to clear an entry to delete file. The locations may also be written to update the free space table if a file is being created or changed in size. The open system&apos;s meta data will be updated consistently with the logic of the open system&apos;s file system logic <highlight><bold>135</bold></highlight>, but the same types of changes need to be reflected in the meta data used by the mainframe file system logic <highlight><bold>115</bold></highlight>, if the meta data is to be kept consistent so that mainframe tools and software can operate on the open system files. If the link handling logic <highlight><bold>505</bold></highlight> detects such an update, it informs the meta data logic <highlight><bold>525</bold></highlight> accordingly. </paragraph>
<paragraph id="P-0087" lvl="0"><number>&lsqb;0087&rsqb;</number> In one sub-embodiment, the meta data logic <highlight><bold>525</bold></highlight>, in response to being informed of an update to the open system meta data image, communicate via TCP connectivity <highlight><bold>116</bold></highlight> with an agent <highlight><bold>113</bold></highlight> on the mainframe <highlight><bold>110</bold></highlight> to inform it of the update. The agent then, acting as a client to the mainframe file system logic <highlight><bold>115</bold></highlight>, informs the file logic accordingly. For example, if the open system file system <highlight><bold>135</bold></highlight> is updating a file directory with a new entry to correspond to a new file being created, the meta data logic <highlight><bold>525</bold></highlight> will be informed of the update to the locations and will look into the data stream to determine what information is being placed in the open systems file system file directory. This information is conveyed to the agent <highlight><bold>113</bold></highlight> which then constructs a request to the mainframe file system <highlight><bold>115</bold></highlight> requesting that a file be created with similar information to create file X at mainframe address A (where A maps exactly to the sector addresses where the open system understands the data to be). Routines update the VTOC and free space tables accordingly. </paragraph>
<paragraph id="P-0088" lvl="0"><number>&lsqb;0088&rsqb;</number> In another implementation, the open system agent <highlight><bold>133</bold></highlight> can pass directly to mainframe agent the filename&plus;file location information whenever a new file is created, deleted or resized. The mainframe agent <highlight><bold>113</bold></highlight> will then create the mainframe directory entries, bypassing the need to intercept SCSI commands all together. </paragraph>
<paragraph id="P-0089" lvl="0"><number>&lsqb;0089&rsqb;</number> Under an alternative sub-embodiment, the meta data logic <highlight><bold>525</bold></highlight> may be made to cooperate with the mainframe storage logic to write the corresponding information into the appropriate file structures (e.g., VTOC) on the mainframe storage <highlight><bold>120</bold></highlight> directly. </paragraph>
<paragraph id="P-0090" lvl="0"><number>&lsqb;0090&rsqb;</number> In yet another implementation, the open system file system meta data (names and locations) will be passed to the mainframe in offline as opposed to real time. In this implementation, the mainframe meta data is created only when the file system is to be backed up by the mainframe for example. In such a case, the mainframe meta data is not needed until the files are to be accessed the mainframe backup. In this case, either the open system agent <highlight><bold>133</bold></highlight>, or the common file system logic <highlight><bold>155</bold></highlight> will traverse the open system meta data and using one of the methods described above create the corresponding mainframe meta data. </paragraph>
<paragraph id="P-0091" lvl="0"><number>&lsqb;0091&rsqb;</number> In yet another implementation the mainframe meta data will be created off line as explained above in conjunction with creating a snapshot of the open system file system to another disk first. For example, once a snapshot copy has been made of the open system&apos;s file system&apos;s meta data, that snapshot copy may then be scanned and used to update the corresponding meta data maintained by the mainframe for the open system files. In this way, the mainframe system (and its corresponding data management tools) may not have a view of the open systems meta data that is consistent with that of the open system in real time, but it will have it when the view needs to be consistent, e.g., before the mainframe tools act on the open system files stored on mainframe storage. </paragraph>
<paragraph id="P-0092" lvl="0"><number>&lsqb;0092&rsqb;</number> For certain open system file systems there may be inconsistencies in formats between mainframe file names and open system file names. For example, mainframes may support only upper case character set for filenames, or there may be some limitation on the length of mainframe file names that differs from open system file system. One embodiment addresses these limitations by maintaining additional name conversion tables (not shown) as meta data (stored on corresponding disk storage) accessed by the common file system logic but hidden from either the open system file system or the mainframe file system. Each entry in this table includes an open system file name, and it&apos;s corresponding mainframe name as it appears in mainframe directory table. </paragraph>
<paragraph id="P-0093" lvl="0"><number>&lsqb;0093&rsqb;</number> The sector addresses and the mainframe addresses used to hold specific, relevant meta data may be determined in an operating system and file system dependent way. </paragraph>
<paragraph id="P-0094" lvl="0"><number>&lsqb;0094&rsqb;</number> Depending on the file system used by the mainframe or the opens system, various forms of meta data information may be included by the file directory tables and disk free space tables and other tables. This additional information is maintained as appropriate in the meta data images but it may not be necessary to &ldquo;trap&rdquo; on it, as outlined above. </paragraph>
<paragraph id="P-0095" lvl="7"><number>&lsqb;0095&rsqb;</number> Basic File Operations </paragraph>
<paragraph id="P-0096" lvl="0"><number>&lsqb;0096&rsqb;</number> The following sections describe basic file operations to illustrate the interaction of the various pieces of logic. </paragraph>
<paragraph id="P-0097" lvl="7"><number>&lsqb;0097&rsqb;</number> Initial Disk Formatting </paragraph>
<paragraph id="P-0098" lvl="0"><number>&lsqb;0098&rsqb;</number> The portion <highlight><bold>140</bold></highlight> of the mainframe storage is formatted as fixed size blocks in which each block has a size equal to some integral number of sectors of the open system file system. The open system file system <highlight><bold>135</bold></highlight> then executes its logic to allocate and initialize its directory table and free space table. This is done through normal read and write operations that are mapped as outlined above to update the locations in mainframe storage <highlight><bold>120</bold></highlight>. In certain embodiments, the open system agent <highlight><bold>133</bold></highlight> returns to the mainframe agent <highlight><bold>113</bold></highlight> the location and sizes of these tables. Space is also allocated for the meta data tables of the mainframe. </paragraph>
<paragraph id="P-0099" lvl="7"><number>&lsqb;0099&rsqb;</number> File Creation </paragraph>
<paragraph id="P-0100" lvl="0"><number>&lsqb;0100&rsqb;</number> To create a file, the open system file server <highlight><bold>135</bold></highlight> allocates disk space and creates the file by regularly issuing SCSI commands to update the meta-date tables. These SCSI commands are intercepted as outlined above and mapped to CCW commands and issued to the mainframe disk. Any updates to meta data files are recognized as such and the meta data logic <highlight><bold>525</bold></highlight>, which will look into the data stream to identify relevant information and use that information to inform and update the mainframe meta data as well. </paragraph>
<paragraph id="P-0101" lvl="7"><number>&lsqb;0101&rsqb;</number> File Deletion </paragraph>
<paragraph id="P-0102" lvl="0"><number>&lsqb;0102&rsqb;</number> To delete a file, the open system file server issues SCSI commands to update the meta-data tables by removing the file name from the file directory table, and returning space to the disk free space table by marking the space used for the file&apos;s data as now free. </paragraph>
<paragraph id="P-0103" lvl="0"><number>&lsqb;0103&rsqb;</number> Similar to file creation, SCSI commands are intercepted and mapped to CCW commands and issued to the mainframe disk to update the open system&apos;s image of the meta data. The platform will recognize, based on the target address of the SCSI commands, that the update is to the meta-data files and it will look in the data portion of the commands to identify the file&apos;s name and the disk locations allocated for the file. Again, the platform will update the mainframe meta-data tables accordingly. </paragraph>
<paragraph id="P-0104" lvl="7"><number>&lsqb;0104&rsqb;</number> File Resizing </paragraph>
<paragraph id="P-0105" lvl="0"><number>&lsqb;0105&rsqb;</number> To resize a file, the file server issues SCSI commands to update the meta data tables accordingly. The same type of remapping is done here as outlined above. </paragraph>
<paragraph id="P-0106" lvl="7"><number>&lsqb;0106&rsqb;</number> File reads/writes </paragraph>
<paragraph id="P-0107" lvl="0"><number>&lsqb;0107&rsqb;</number> To service reads and writes from the open system server, the file server issues a read or write SCSI command. The platform translates the disk addresses in the SCSI commands and issues a corresponding CCW chain to the mainframe disk. For write commands, the platform will convert any received status and send it to the open system. For read commands, the platform will relay any received data and send it to the open system along with converted statuses. </paragraph>
<paragraph id="P-0108" lvl="7"><number>&lsqb;0108&rsqb;</number> Allocating Storage </paragraph>
<paragraph id="P-0109" lvl="0"><number>&lsqb;0109&rsqb;</number> Certain embodiments of the invention cause the Open System file system <highlight><bold>135</bold></highlight> to use a cluster size that corresponds to an intergral number of tracks. Since space is allocated in the mainframe storage system <highlight><bold>120</bold></highlight> in units of tracks, causing the open system file system to fix cluster size to a number of sectors that fits into an integral number of tracks uses storage resources efficiently. </paragraph>
<paragraph id="P-0110" lvl="7"><number>&lsqb;0110&rsqb;</number> Alternative Embodiments </paragraph>
<paragraph id="P-0111" lvl="0"><number>&lsqb;0111&rsqb;</number> In another implementation extraction of data from the open system file system meta-data can be accomplish by modifying the appropriate create file, delete file and resize file routines, and passing the relevant information to the bridging apparatus using TCP/IP, as opposed to monitoring IO addresses. </paragraph>
<paragraph id="P-0112" lvl="0"><number>&lsqb;0112&rsqb;</number> In another implementation the mainframe file system meta-data is updated by an mainframe resident agent after receiving the appropriate information from the bridging apparatus using TCP/IP. </paragraph>
<paragraph id="P-0113" lvl="0"><number>&lsqb;0113&rsqb;</number> In another embodiment, addresses between the first and second file systems may be related by the use of look-up tables or equivalent data structures, in contrast to the use of algoritmic mapping. </paragraph>
<paragraph id="P-0114" lvl="0"><number>&lsqb;0114&rsqb;</number> Since certain changes may be made in the above apparatus without departing from the scope of the invention herein involved, it is intended that all matter contained in the above description or shown in the accompanying drawing shall be interpreted in an illustrative and not a limiting sense.</paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method of servicing requests of a first file system communicated in accordance with a first storage protocol using a storage system that is responsive to requests communicated according to a second storage protocol and that is organized in accordance with a second file system, the method comprising the acts of: 
<claim-text>allocating a first portion of the storage system to hold data of the first file system, the first portion including a set of locations for holding directory information of the first file system; </claim-text>
<claim-text>allocating a second portion of the storage system to hold data for the second file system, the second portion including a set of locations for holding directory information of the second file system, wherein the directory information of the second file system includes a set of file information entries corresponding to files of the first file system; </claim-text>
<claim-text>intercepting requests of the first file system and converting the intercepted requests to corresponding requests in the second storage protocol, including converting addressing information in the intercepted requests to addressing information in accordance with the second storage protocol; </claim-text>
<claim-text>providing the converted request to the storage system so that the storage system may service the request; </claim-text>
<claim-text>analyzing the intercepted requests to determine if the requests are updating the set of locations holding directory information of the first file system and if so constructing corresponding update requests to a corresponding file information entry in the second portion, so that the second portion includes entries that are consistent with the information in the first portion. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein the first file system is an open system file system and wherein the second file system is a mainframe file system. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein the first storage system protocol is SCSI and wherein the second storage system protocol is ESCON. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein storage is allocated for the first portion to create an algorithmic relationship of addresses of the first file system to addresses of the second file system. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00004">claim 4</dependent-claim-reference> wherein the addresses of the first file system are based on fixed-size sector numbers and wherein the addresses of the second file system are based on a cylinder number, disk head number, and a block number, wherein the second file system permits block size to vary. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein the requests of the first file system are intercepted by a bridging apparatus in communication with the storage system and wherein the bridging apparatus constructs the update requests to a corresponding file information entry in the second portion. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein the requests of the first file system are intercepted by a bridging apparatus in communication with the storage system and wherein the bridging apparatus communicates with an agent that constructs the update requests to a corresponding file information entry in the second portion. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein the directory information of the first file system manages files organized according to an i-node based file structure and wherein the second directory information is a volume table of contents (VTOC) structure. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference> wherein the second file system allocates storage organized as tracks having blocks of a fixed size and wherein the first file system is caused to allocate storage as a cluster of sectors, wherein the cluster fits into an integral number of tracks. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein the set of file information entries corresponding to files of the first file system include filename entries and wherein the filename entries have an algorithmic relationship to filenames used by the first file system. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein the set of file information entries corresponding to files of the first file system include filename entries having a mapped correspondency to filenames used by the first file system. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. A system for handling requests from a first file system communicated in accordance with a first storage protocol using a storage system that is responsive to requests communicated according to a second storage protocol and that is organized in accordance with a second file system, wherein a first portion of the storage system is allocated to hold data of the first file system, the first portion including a set of locations for holding directory information of the first file system, and wherein a second portion of the storage system is allocated to hold data for the second file system, the second portion including a set of locations for holding directory information of the second file system, and wherein the directory information of the second file system includes a set of file information entries corresponding to files of the first file system, the system comprising: 
<claim-text>logic to intercept requests of the first file system; </claim-text>
<claim-text>logic to convert the intercepted requests to corresponding requests in the second storage protocol, including converting addressing information in the intercepted requests to addressing information in accordance with the second storage protocol; </claim-text>
<claim-text>logic to issue the converted request to the storage system; </claim-text>
<claim-text>logic to analyze the intercepted requests to determine if the requests are updating the set of locations holding directory information of the first file system; </claim-text>
<claim-text>logic, responsive to the logic to analyze, to construct update requests to a corresponding file information entry in the second portion, so that the second portion includes entries that are consistent with the information in the first portion. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference> wherein the first file system is an open system file system and wherein the second file system is a mainframe file system. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference> wherein the first storage system protocol is SCSI and wherein the second storage system protocol is ESCON. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference> wherein the logic to convert includes logic to convert addresses based on an algortimic mapping of addresses of the first file system to addresses of the second file system. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference> wherein the addresses of the first file system are based on fixed-size sector numbers and wherein the addresses of the second file system are based on a cylinder number, disk head number, and a block number, wherein the second file system permits block size to vary. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference> wherein the logic to intercept, the logic to convert, the logic to issue and the logic to analyze are provided on a bridging apparatus in communication with the first file system and with the storage system. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference> wherein the logic to construct update requests is provided on the bridging apparatus. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference> wherein the logic to construct update requests is provided by agent logic in communication with the second file system. </claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference> wherein the directory information of the first file system manages files organized according to an i-node based file structure and wherein the second directory information is a volume table of contents (VTOC) structure. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference> wherein the second file system allocates storage organized as tracks having blocks of a fixed size and wherein the first file system is caused to allocate storage as a cluster of sectors, wherein the cluster fits into an integral number of tracks. </claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference> wherein the set of file information entries corresponding to files of the first file system include filename entries and wherein the filename entries have an algorithmic relationship to filenames used by the first file system. </claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. A method of managing and maintaining information of a first file system communicated in accordance with a first storage protocol using a storage system that is responsive to requests communicated according to a second storage protocol and that is organized in accordance with a second file system, the method comprising the acts of: 
<claim-text>allocating a first portion of the storage system to hold data of the first file system, the first portion including a set of locations for holding directory information of the first file system; </claim-text>
<claim-text>allocating a second portion of the storage system to hold data for the second file system, the second portion including a set of locations for holding directory information of the second file system, wherein the directory information of the second file system includes a set of file information entries corresponding to files of the first file system; </claim-text>
<claim-text>converting requests of the first file system to corresponding requests in the second storage protocol, including converting addressing information in the intercepted requests to addressing information in accordance with the second storage protocol; </claim-text>
<claim-text>providing the converted request to the storage system so that the storage system may service the request; </claim-text>
<claim-text>analyzing the information at the set of locations of the first file system and creating and storing corresponding information in the set of file information entries of the second file system corresponding to files of the first file system; and </claim-text>
<claim-text>at specified times using a data management tool of the second file system to manage files in the first portion of storage by accessing the the set of file information entries of the second file system corresponding to files of the first file system to locate the files of the first file system. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 23</dependent-claim-reference> further comprising the act of creating a snapshot copy of the information at the set of locations of the first file system and wherein the analyzing act is performed by analyzing the snapshot copy. </claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. A system for managing and maintaining information of a first file system communicated in accordance with a first storage protocol using a storage system that is responsive to requests communicated according to a second storage protocol and that is organized in accordance with a second file system, wherein a first portion of the storage system is allocated to hold data of the first file system, the first portion including a set of locations for holding directory information of the first file system, and wherein a second portion of the storage system is allocated to hold data for the second file system, the second portion including a set of locations for holding directory information of the second file system, and wherein the directory information of the second file system includes a set of file information entries corresponding to files of the first file system, the system comprising: 
<claim-text>logic to convert requests of the first file system to corresponding requests in the second storage protocol, including converting addressing information in the intercepted requests to addressing information in accordance with the second storage protocol; </claim-text>
<claim-text>logic to provide the converted request to the storage system so that the storage system may service the request; </claim-text>
<claim-text>logic to analyze the information at the set of locations of the first file system and to create and store corresponding information in the set of file information entries of the second file system corresponding to files of the first file system so that at specified times a data management tool of the second file system may be used to manage files in the first portion of storage by accessing the the set of file information entries of the second file system corresponding to files of the first file system to locate the files of the first file system. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference> wherein the logic to analyze the information includes logic to analyze a snapshot copy of the information at the set of locations of the first file system.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>2A</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030004972A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030004972A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030004972A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030004972A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030004972A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030004972A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030004972A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
