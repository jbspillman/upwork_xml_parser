<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030004973A1-20030102-D00000.TIF SYSTEM "US20030004973A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030004973A1-20030102-D00001.TIF SYSTEM "US20030004973A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030004973A1-20030102-D00002.TIF SYSTEM "US20030004973A1-20030102-D00002.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030004973</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09897803</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010702</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F012/00</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>707</class>
<subclass>200000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Random sampling as a built-in function for database administration and replication</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>John</given-name>
<middle-name>William</middle-name>
<family-name>Harper</family-name>
</name>
<residence>
<residence-us>
<city>San Jose</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Gordon</given-name>
<middle-name>Robert</middle-name>
<family-name>Slishman</family-name>
</name>
<residence>
<residence-us>
<city>Morgan Hill</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<assignee>
<organization-name>International Business Machines Corporation</organization-name>
<assignee-type>02</assignee-type>
</assignee>
<correspondence-address>
<name-1>Michael E. Hudzinski</name-1>
<name-2>FAY, SHARPE, FAGAN,</name-2>
<address>
<address-1>MINNICH &amp; McKEE, LLP</address-1>
<address-2>1100 Superior Avenue, Seventh Floor</address-2>
<city>Cleveland</city>
<state>OH</state>
<postalcode>44110-2518</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A database management system and method for administration and replication having a built-in random sampling facility for approximation partition analysis on very large databases. The method utilizes a random sampling algorithm that provides results accurate to within a few percentage points for large homogeneous databases. The accuracy is not affected by the size of the database and is determined primarily by the size of the sample. The system and method for approximate partition analysis reduces the time required for an analysis to a fraction of the time required for an exact analysis. The database management system is configured with the random sampling facility built-in thereby enabling even greater efficiency by reducing communication overhead between an analysis program and the database management system to a fraction of the overhead required when sampling is performed by a separate analysis program. The reduction in time thereby permits frequent and timely analyses for replication and administration of database partitions. </paragraph>
</subdoc-abstract>
<subdoc-description>
<cross-reference-to-related-applications>
<heading lvl="1">CROSS-REFERENCE TO RELATED APPLICATION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> This application is related to U.S. application Ser. No. unknown, filed together with this application, entitled Partition Boundary Determination Using Random Sampling on Very Large Databases, attorney docket IBM 2 0003.</paragraph>
</cross-reference-to-related-applications>
<summary-of-invention>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> The invention pertains to partition size analysis for very large databases having multiple partitions and, more particularly, to accurate, fast, and scalable characterization and estimation of large populations using a random sampling function that is integrated directly into a database engine. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> Databases provide a means to conveniently store and retrieve a wealth of information such as, in the business setting, individual and corporate accounts and, in the business example provide a means to analyze business trends and make other business, educational, and scientific decisions. Accordingly, over the years, typical database populations reach upward of a billion rows and records. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> Analysis of these large databases for administration and replication purposes typically involves processes which are very input/output intensive, as numerous queries must be performed by an analysis program across a vast number of records. Random sampling by an associated application program outside of the database management system (DBMS) can reduce the number of records analyzed. However, the number of requests passed from an analysis program to the DBMS remains high because requests must be made not only for selected records but also to skip non-selected records. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> It would be beneficial to provide a method and system for administration and replication of large databases including a means for partition size analysis that reduces the amount of time required to perform the analysis so that such analyses can be executed in a more timely basis without placing an undue burden on the computer system hosting the database. The ability to perform size analyses in a timely basis allows database managers to monitor growth patterns and to accurately estimate needs for database reorganization in terms of predicting the time of a required reorganization and projecting space allocation requirements. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> Partition size analyses require only a sufficiently accurate approximate solution as compared to the very precise solution obtainable by analyzing each and every item of data in a database. It is of little worth to provide a precisely accurate solution for a volatile database that is constantly changing including changing at the very moment that it is being analyzed. It is typically not possible to provide an exact analysis without first removing a database from online for an extended period of time. For size analyses, only a small portion of the full set of data must be processed to provide an accurate estimate of partition size, especially for very large homogeneous databases. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> The present invention provides a method and system for performing database characterization and approximation analyses to generate very precise, as well as timely results. The method is based on first deriving a random sample of known size from a database of unknown size, or known size, and then extrapolating the results to provide an accurate approximation of a full-scale analysis. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> The method and system provided are unique in that a random sample is selected of predetermined known size, but uniformly distributed across the entire database, from a database of known or unknown size while reading only a fraction of the records in the database without the requirement of indexing the entire database which, as indicated above, is time consuming and provides results having an unnecessary degree of precision. The sampling facility is provided as a built-in feature of the database management system and not simply attached to the DBMS as an associated external application. This enables earlier pruning and better performance because the sampling function is closer to the source database. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> Other previous random sampling techniques typically require that the database be indexed in order not to read the entire database, or read the entire database and randomly select samples from the entire result. As an example, U.S. Pat. No. 5,675,786 provides a simple sampling function in a database engine. The sampling function taught there generates a sequential stream of initial results by first addressing a query to the database and then sampling the stream of initial results to produce a sampled result substantially smaller than the initial result. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> The present invention, on the other hand, retrieves only a user-selectable fraction of the records stored in the database. This advantageously improves the overall performance of the system and accuracy of the results. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> In order to produce samples of predetermined size that are normally distributed across a database typically requires a knowledge of the exact number of records in the database beforehand. As an alternative to prior knowledge of the number of records, a complete scan of the database prior to sampling is needed. For example, the &apos;786 patent identified above requires that a particular sampling probability be selected in order to produce a particular sample size from a given result. The present invention, however, overcomes this requirement. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> The present invention therefore provides a solution to the aforementioned problems, and offers other advantages over the prior art. </paragraph>
</section>
<section>
<heading lvl="1">BRIEF SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> In accordance with the present invention, a system and method for administration and replication of database partitions is provided. The administration system includes a built-in (integrated) sampling facility that performs a random sampling function to sample a predetermined number of records from the database using a preferred random sampling algorithm. Preferably, each time the method is utilized, different random number generator seed values are used so that different database records are selected for the random sampling. Further, the selected records are different for successive utilizations of the method when at least one record has been added to or deleted from the database between successive utilizations of the random sampling method. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> Statistics are stored for each of the sampled records, including a record key for each record, and an approximation partition analysis is produced based on the stored statistics. The approximation partition analysis is not mathematically exact because of the sampling, however, the analysis is generally accurate to within a few percentage points which is adequate for dynamically changing databases where exactness would be rendered meaningless after a few transactions. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> The preferred embodiment of the sampling method follows a mechanical procedure including the following steps: </paragraph>
<paragraph id="P-0016" lvl="2"><number>&lsqb;0016&rsqb;</number> 1. A table of number pairs (Y<highlight><subscript>j</subscript></highlight>,I<highlight><subscript>j</subscript></highlight>), j&equals;1,2, . . . ,S, is generated where all Y and all I are initially set to zero, and S is the user-selected predetermined sample size. </paragraph>
<paragraph id="P-0017" lvl="2"><number>&lsqb;0017&rsqb;</number> 2. A reservoir for storing records is set to an empty state. </paragraph>
<paragraph id="P-0018" lvl="2"><number>&lsqb;0018&rsqb;</number> 3. Variable M, an index to the reservoir, is set equal to zero. </paragraph>
<paragraph id="P-0019" lvl="2"><number>&lsqb;0019&rsqb;</number> 4. A sequence of N non-repeating random numbers U<highlight><subscript>1</subscript></highlight>,U<highlight><subscript>2</subscript></highlight>, . . . ,U<highlight><subscript>N</subscript></highlight>, 0&lt;U&lt;1, is generated as database records are considered for retrieval, where N is the initially unknown number of records in the database, and additional steps are performed for each random number U<highlight><subscript>k </subscript></highlight>generated including: </paragraph>
<paragraph id="P-0020" lvl="3"><number>&lsqb;0020&rsqb;</number> 4.1 The next record in the database is skipped if U<highlight><subscript>k </subscript></highlight>is less than the smallest value of Y in the table of number pairs. </paragraph>
<paragraph id="P-0021" lvl="3"><number>&lsqb;0021&rsqb;</number> 4.2 The table is updated if a Y less than U<highlight><subscript>k </subscript></highlight>exists as follows: </paragraph>
<paragraph id="P-0022" lvl="4"><number>&lsqb;0022&rsqb;</number> 4.2.1 M is set equal to M&plus;1. </paragraph>
<paragraph id="P-0023" lvl="4"><number>&lsqb;0023&rsqb;</number> 4.2.2 The smallest Y in the table is replaced with U<highlight><subscript>k</subscript></highlight>. </paragraph>
<paragraph id="P-0024" lvl="4"><number>&lsqb;0024&rsqb;</number> 4.2.3 The I value paired with the smallest Y is set equal to M. </paragraph>
<paragraph id="P-0025" lvl="4"><number>&lsqb;0025&rsqb;</number> 4.2.4 All or part of the next record of the database is stored in the reservoir where the current value of M is an index to the stored record. </paragraph>
<paragraph id="P-0026" lvl="4"><number>&lsqb;0026&rsqb;</number> 4.2.5 The table is rearranged into a heap with respect to Y. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> Following the generation of an approximation partition analysis, multiple partition boundaries are defined that are sufficient to accommodate the database records and include spare space for future growth. All database records are accessed in an arbitrary sequence and the partitions are filled iteratively, except the last, with the accessed records to a maximum byte count, and the remaining accessed records are stored in the last partition. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> Raw partition analysis, without random sampling analysis, places a heavy strain on a computer system in terms of memory usage and typically requires multiple dataspaces. Random sampling relieves the strain on the computer system in terms of processing and memory requirements. Much less memory is required to analyze 20,000 sampled records using the random sampling approach than to analyze 2,000,000,000 records without sampling. However, in order to maintain consistency with an unsampled approach which may be desirable under some circumstances, the preferred method using random sampling analysis utilizes one or more of each of the following types of dataspaces: index, key and statistics. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> One benefit obtained from the present invention as a result of providing a built-in sampling facility is the reduction in the number of system calls required to perform an approximation partition analysis. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> Another benefit obtained from the present invention is the reduction in time required to perform an approximation partition analysis compared to the time required for an exact partition analysis. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> Still another benefit obtained from the present invention is that approximation partition analyses is performed frequently without straining or otherwise compromising computer system resources. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> Yet another benefit obtained from the present invention is an improved accuracy of the analyses, particularly for homogeneous database populations. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> Yet another benefit obtained from the present invention is that a random sample of predetermined size is obtained without prior knowledge of the number of records in the sampled database. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> Other benefits and advantages of the subject method and system will become apparent to those skilled in the art upon a reading and understanding of this specification.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> The invention may take physical form in certain parts and steps and arrangements of parts and steps, the preferred embodiments of which will be described in detail in the specification and illustrated in the accompanying drawings hereof and wherein: </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a generalized diagram of a computer system having a partitioned database and a database management system; and, </paragraph>
<paragraph id="P-0037" lvl="2"><number>&lsqb;0037&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a flowchart illustrating the preferred method of performing random sampling on very large databases in accordance with the present invention. </paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF THE INVENTION </heading>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> The capacity of DL/I databases is limited by the maximum size of a data set that can be addressed by a four-byte relative byte address (RBA). Many other databases in use presently suffer from similar size limitations. In current full function databases managed by database management systems such as IMS, multiple data sets are supported. This helps to increase the capacity of the database. One requirement, however, is that all segments of the same type must be in the same data set. As a result, when one data set is full, the database is deemed to be essentially full even if empty space exists in the remaining data sets. As a consequence, methods have been developed to extend the capacity of such databases. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> As shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, partitioning removes the data set limitation by relieving the restriction that all occurrences of the same segment type must be in the same data set. Partitioning database <highlight><bold>10</bold></highlight> groups database records into sets of partitions <highlight><bold>12</bold></highlight> that are treated as a single database by database management system (DBMS) <highlight><bold>14</bold></highlight> running on computer system <highlight><bold>16</bold></highlight>, while still permitting functions to be performed independently against individual partitions. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> Partitions may be very large. More particularly, each partition has the same capacity limit as a non-partitioned database, in that no single data set may exceed the addressing limit. The ability to divide the database into multiple partitions provides the added advantage of decreasing the amount of data unavailable if a partition fails or is taken offline. For these reasons, partitioning has become a widely used and is well known means of extending the storage capacity of databases. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> Correct initial sizing of a large partitioned database is important because after the database is in use, reorganization of the database is usually necessary to alter the size of the database, resulting in a potentially extended periods of database unavailability. For this reason, computer utility programs are used to statistically analyze existing databases while they are in use for growth trends and future storage capacity requirements. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> A typical partition analysis program <highlight><bold>18</bold></highlight>, in communication with DBMS <highlight><bold>14</bold></highlight>, performs queries and stores compressed statistics in random access memory (RAM) <highlight><bold>20</bold></highlight>, which may comprise real and virtual memory, or an external storage device <highlight><bold>22</bold></highlight> for every record in the database. Under certain conditions, the analysis program sorts those statistics by key in RAM, or on the storage device. Since a database may contain upward of a billion records, storing and sorting even compressed statistics involves numerically intensive computation, which may burden even large powerful computers such as a mainframe. Sorting a large number of statistical records places a heavy load on the computer system because the time for sorting is typically proportional to N<highlight><subscript>rec</subscript></highlight>*log<highlight><subscript>2</subscript></highlight>(N<highlight><subscript>rec</subscript></highlight>) where N<highlight><subscript>rec </subscript></highlight>is the number of records being sorted and log<highlight><subscript>2 </subscript></highlight>is logarithm base <highlight><bold>2</bold></highlight>. Even when sorting is not needed, the analysis is time consuming because, as appreciated by those skilled in the art, nearly all elapsed time is spent in a get-next function to traverse the entire database. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> By way of example, in the case of an IMS database which can contain up to 8 gigabytes (GB) in keys, on a computer system having RAM <highlight><bold>20</bold></highlight> dataspaces of up to 2<highlight><superscript>31 </superscript></highlight>bytes (2 GB), four dataspaces are required to store the keys. Another 2 GB are sufficient to store indices to the keys. However, the record statistics, even when compressed, may require dozens of dataspaces. To minimize the effort of storing and sorting, the present invention randomly samples a database and produces an extrapolated partition analysis <highlight><bold>24</bold></highlight> providing sufficiently accurate results. Preferably, the sample size selected is sufficiently small so that three dataspaces will suffice, one each for indices, keys, and statistics. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> An analysis program <highlight><bold>16</bold></highlight>, in communication with DBMS <highlight><bold>14</bold></highlight>, partitions a random sample size of S records, and then scales the tabulated numbers by the ratio of the number of records in the database to the number of records in the sample. For a homogeneous database, with records mostly of similar structure, the sampling is remarkably accurate. In one experiment used to test the accuracy of the sampling generally, 20,000 random integers were selected from a set of integers 1 to 2,147,483,646, the sample sorted, and the middle two averaged (sample&lsqb;10000&rsqb; and sample&lsqb;10001&rsqb;). Repeated 100 times, this experiment produced estimates all within 1.78% of the actual mean, 1,073,741,823.5. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> In the present invention, an IMS database is bisected by first sorting by key, and then bisecting at the median. A sample of size 20,000 normally produces a result within a percent or two of the exact result which would be obtained if the entire database was sampled. The present invention leverages the sampling strategy that in most cases it doesn&apos;t make sense to store and sort orders of magnitude more data for less than 2% improvement in accuracy, particularly when the database is not static. Perhaps counter-intuitively, larger databases do not require larger samples for similar accuracy. Accordingly, the present invention does not rely on large sample sizes for accuracy but rather is based on the theory of &ldquo;order statistics&rdquo; to perform random sampling of records. Although any suitable form of order statistics can be used, the complete mathematical description of the preferred order statistics used in the present invention is taught in &ldquo;Introduction to Mathematical Statistics&rdquo; by Hogg and Craig, 5<highlight><superscript>th </superscript></highlight>ed. the teachings of which are incorporated by reference. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> The scaling factor used to inflate the sample to the size of the full database is the number of records in the database (N) divided by the number of records in the sample (S), thus (N/S). Therefore, by definition, the root segment counts in the estimated partitions add up exactly to the total number of root segments in the database, while other estimates merely approximate corresponding database totals. Preferably, sampling stability is verified beforehand by experimenting with different sample sizes and random seeds, e.g. &ldquo;sample&equals;10000,seed&equals;7&rdquo;. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> While random sampling can be of great benefit in reducing the number of records retrieved from database <highlight><bold>10</bold></highlight> for partition analysis, a large amount of time is spent in communicating requests from analysis program <highlight><bold>18</bold></highlight> to DBMS <highlight><bold>14</bold></highlight>. For example, a call to DBMS <highlight><bold>14</bold></highlight> must be issued for each record to be skipped as well as for each record to be retrieved from database <highlight><bold>10</bold></highlight>. In accordance with the present invention, a more efficient solution is to provide a built-in random sampling facility <highlight><bold>26</bold></highlight> configured as a part of the DBMS <highlight><bold>14</bold></highlight>. In that way, only a single request from analysis program <highlight><bold>18</bold></highlight> is required to provide parameters to DBMS <highlight><bold>14</bold></highlight> for random sampling. Sampling facility <highlight><bold>26</bold></highlight> then performs all random sampling tasks on the database <highlight><bold>10</bold></highlight>, and stores statistics from sampled records in RAM <highlight><bold>20</bold></highlight> or on external storage device <highlight><bold>20</bold></highlight> for use by analysis program <highlight><bold>18</bold></highlight>. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> An added benefit of providing the built-in sampling facility in accordance with the present invention, is that sampling facility <highlight><bold>26</bold></highlight>, as an integral part of DBMS <highlight><bold>14</bold></highlight>, has access to all low level I/O functions and I/O buffers. This enables rapid access to records being retrieved and a more efficient means for skipping records not selected for retrieval. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> Sampling a desired sample size requires selecting S items at random from database <highlight><bold>10</bold></highlight>. However, the number of records present in the database is unknown. One method is to traverse the database with the sampling facility <highlight><bold>26</bold></highlight> and count the records, then take a second pass to make the random selections. In accordance with the preferred embodiment of the invention, however, M records (M&gE;S) are sampled on the first pass, where M is much less than N, so that only M items must be considered on the second pass. It is necessary to do this in such a way that the final result is a truly random sample of the original file. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> With reference now to <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, and with continuing reference to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, the preferred algorithm of the built-in random sampling facility <highlight><bold>26</bold></highlight> is illustrated for providing a method of random sampling according to the aforementioned conditions. The algorithm is incorporated directly into the sampling facility <highlight><bold>26</bold></highlight> so that statistics for sampled records are communicated by DBMS <highlight><bold>14</bold></highlight> to analysis program <highlight><bold>18</bold></highlight> which, in turn, produces an approximation partition analysis report <highlight><bold>24</bold></highlight>. The approximation partition analysis is then used by reorganization program <highlight><bold>28</bold></highlight> to reorganize input database <highlight><bold>10</bold></highlight> by reading records from partitions <highlight><bold>12</bold></highlight> and writing the same records to an output database <highlight><bold>30</bold></highlight> comprising partitions <highlight><bold>32</bold></highlight>, including first partition <highlight><bold>34</bold></highlight>, intermediate partitions <highlight><bold>36</bold></highlight> and last partition <highlight><bold>38</bold></highlight>. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> The overall strategy incorporated into sampling facility <highlight><bold>26</bold></highlight> preferably uses the technique of order statistics. N random values are computed, and then the largest S of these is ascertained. The corresponding S records are selected for the final sample. During the first pass, a reservoir is constructed which contains only those M records which are possible candidates, i.e., those records which correspond to a random value that has not been preceded by S larger values. The first S items are always placed into the reservoir. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> The sampling algorithm first performs several initialization functions. In a first step <highlight><bold>40</bold></highlight>, a variable S is initially set to a pre-configured default sample size. A particular desired sample size is selectively received to replace the initial value of S at step <highlight><bold>42</bold></highlight>. A table of paired numbers (Y<highlight><subscript>j</subscript></highlight>,I<highlight><subscript>j</subscript></highlight>) is generated and initialized such that (Y<highlight><subscript>j</subscript></highlight>,I<highlight><subscript>j</subscript></highlight>)&equals;(0,0), j&equals;1,2, . . . ,S at step <highlight><bold>44</bold></highlight>. A reservoir R, for storing compressed statistics from selected database records, is initialized to an empty state at step <highlight><bold>46</bold></highlight>. The variable M which represents the number of possible coordinates is zeroed at step <highlight><bold>48</bold></highlight>, and a random number generator seed value is provided at step <highlight><bold>50</bold></highlight>. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> Once initialization has been completed according to the above, an iterative loop is processed to perform the random sampling function. A random number U is generated from a random number generator capable of generating N uniformly distributed, non-repeating random numbers at step <highlight><bold>52</bold></highlight>. A set of variables (Y<highlight><subscript>k</subscript></highlight>,I<highlight><subscript>k</subscript></highlight>) is found such that Y<highlight><subscript>k</subscript></highlight>&lE;Y<highlight><subscript>j</subscript></highlight>, 1&lE;j&lE;N, or, in other words, Y<highlight><subscript>k </subscript></highlight>is a minimum Y at step <highlight><bold>54</bold></highlight>. Next, the random number U is compared to Y<highlight><subscript>k </subscript></highlight>at step <highlight><bold>56</bold></highlight>. A comparison &ldquo;if U&lt;Y<highlight><subscript>k</subscript></highlight>&rdquo; is made, and if true, then the next available record in the database is skipped at step <highlight><bold>58</bold></highlight>, otherwise the variable I<highlight><subscript>k </subscript></highlight>is tested at step <highlight><bold>59</bold></highlight> to determine if the minimum Y found at step <highlight><bold>54</bold></highlight> is residue from the reservoir initialization process. This indicates that the reservoir is not yet full. If it is determined at step <highlight><bold>59</bold></highlight> that the reservoir is not yet full, the variable M is incremented M&equals;M&plus;1 at step <highlight><bold>60</bold></highlight>, and the next available record in the database, or portions of it, are stored in reservoir R where M is an index, symbolically R<highlight><subscript>M </subscript></highlight>at step <highlight><bold>62</bold></highlight>; the variables Y and I are updated (Y<highlight><subscript>k</subscript></highlight>,I<highlight><subscript>k</subscript></highlight>)&equals;(U,M) at step <highlight><bold>64</bold></highlight>, and the table of paired numbers (Y,I) is rearranged to form a heap (defined below) with respect to Y at step <highlight><bold>66</bold></highlight>. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> A test is then performed to determine if more records exist in the database at step <highlight><bold>68</bold></highlight>, and if more records exist, processing returns to the top of the iterative loop, otherwise processing continues to the next step. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> After the reservoir is full, the minimum Y value found at step <highlight><bold>54</bold></highlight> will not be a value remaining from the initialization step <highlight><bold>44</bold></highlight>, but will be a non-zero value originating from the random number U assigned previously at step <highlight><bold>64</bold></highlight>. This is tested at step <highlight><bold>59</bold></highlight> whereupon the value of I<highlight><subscript>k </subscript></highlight>is assigned to the variable M at step <highlight><bold>61</bold></highlight>. It can be seen that the variable M increases by integer increments until the reservoir becomes full. Thereafter, the increment step <highlight><bold>60</bold></highlight> is bypassed whereupon the indexes M are revised or reassigned to the reservoir entries. As a final step, the table of number pairs (Y,I) are sorted on I to place the table in order by record at step <highlight><bold>70</bold></highlight>. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> For purposes of the description of the preferred embodiment of the invention, the aforementioned heap is defined as follows: </paragraph>
<paragraph id="P-0057" lvl="2"><number>&lsqb;0057&rsqb;</number> S elements (Y,I) are a heap with respect to Y if and only if Y<highlight><subscript>j</subscript></highlight>&lt;Y<highlight><subscript>2j </subscript></highlight>and Y<highlight><subscript>j</subscript></highlight>&lt;Y<highlight><subscript>2j&plus;1 </subscript></highlight>for all j&lE;S/2. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> Maintaining the table in a heap, so that the smallest element is always on top, facilitates testing each random number against the smallest number in the table. Each time a random tag is found that is larger than the smallest Y in the table, the smallest element is replaced, and the table is reformed into a heap. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> The memory required by a partition analysis, even when random sampling is employed, can be large and, consequently, multiple dataspaces may be required. For databases organized with indexes and keys, sampling may require one or more dataspaces, e.g. one or more index dataspaces, one or more key dataspaces, and one or more statistics dataspaces. </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> After the random sampling has been performed by sampling facility <highlight><bold>26</bold></highlight>, and analysis program <highlight><bold>18</bold></highlight> has performed a partition analysis, reorganization program <highlight><bold>28</bold></highlight> defines output partitions, accesses all database records in an arbitrary sequence and iteratively fills all of the partitions, except the last, to their maximum byte count. The last partition is typically filled to less than its maximum byte count. The partitions can optionally be sized somewhat larger than the calculated maximum byte count to allow for growth within each partition. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> The invention has been described with reference to the preferred embodiments. Modifications and alterations will occur to others upon a reading and understanding of the specification. It is our intention to include all such modifications and alterations insofar as they come within the scope of the appended claims, or the equivalents thereof. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">Having thus described our invention, we now claim: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method for administration and replication of a database, comprising the steps of: 
<claim-text>providing a database management system with a built-in random sampling facility integrated into said database management system; and, </claim-text>
<claim-text>executing said random sampling facility from within the database management system to perform a replication operation on said database. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method as set forth in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising the steps of: 
<claim-text>defining a database record sample size S; </claim-text>
<claim-text>randomly sampling S records of the database using said random sampling facility; </claim-text>
<claim-text>storing statistics for each of said S records, wherein said statistics include a record key for each record; and, </claim-text>
<claim-text>producing an extrapolated replication partition analysis based on said statistics. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method as set forth in <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, wherein the step of defining said sample size S includes: 
<claim-text>defining a default sample size; </claim-text>
<claim-text>selectively receiving a desired sample size; and, </claim-text>
<claim-text>setting said sample size S as said default sample size when the desired sample size is not selectively received, and setting said sample size S as said desired sample size when the desired sample size is selectively received. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method as set forth in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising the steps of: 
<claim-text>defining a database record sample size S; </claim-text>
<claim-text>randomly sampling S records of the database using said random sampling facility; </claim-text>
<claim-text>storing statistics for each of said S records, wherein said statistics include a record key for each record; and, </claim-text>
<claim-text>producing a partial replication partition analysis based on said statistics. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method as set forth in <dependent-claim-reference depends_on="CLM-00004">claim 4</dependent-claim-reference>, wherein the step of defining said sample size S includes: 
<claim-text>defining a default sample size; </claim-text>
<claim-text>selectively receiving a desired sample size; and, </claim-text>
<claim-text>setting said sample size S as said default sample size when the desired sample size is not selectively received, and setting said sample size S as said desired sample size when the desired sample size is selectively received. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. A method for database administration and replication, comprising the steps of: 
<claim-text>providing a database management system with an integrated random sampling facility; </claim-text>
<claim-text>selecting a default sample size value S; </claim-text>
<claim-text>selectively receiving a desired sample size value D and setting said default sample size value S to said desired sample size value D when said desired sample size value D is received; </claim-text>
<claim-text>randomly sampling S records of the database using said random sampling facility; </claim-text>
<claim-text>storing statistics for each of said S records, wherein said statistics include a record key for each record; and, </claim-text>
<claim-text>producing at least one of: 
<claim-text>an extrapolated replication partition analysis based on said statistics; and </claim-text>
<claim-text>a partial replication partition analysis based on said statistics. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The method as set forth in <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference>, wherein the step of selecting said default sample size value D further includes the steps of: 
<claim-text>generating a table of S number pairs (Y<highlight><subscript>j</subscript></highlight>,I<highlight><subscript>j</subscript></highlight>), j&equals;1,2, . . . ,S, wherein all Y and all I are initially set to zero; </claim-text>
<claim-text>initializing a reservoir of records to an empty&plus;state; </claim-text>
<claim-text>setting an index M to said reservoir equal to zero; </claim-text>
<claim-text>generating a sequence of N non-repeating random numbers U<highlight><subscript>1</subscript></highlight>,U<highlight><subscript>2</subscript></highlight>, . . . ,U<highlight><subscript>N</subscript></highlight>, 0&lE;U&lE;1, wherein N is the number of records in the database; and, </claim-text>
<claim-text>performing additional steps for each random number U<highlight><subscript>k </subscript></highlight>generated, k&equals;1,2, . . . ,N, the additional steps including: 
<claim-text>skipping the next record in the database if U<highlight><subscript>k </subscript></highlight>is less than the smallest value of Y in said table of number pairs; and, </claim-text>
<claim-text>updating the table if a Y less than U<highlight><subscript>k </subscript></highlight>exists by performing further steps including: 
<claim-text>setting M equal to its current value plus one; </claim-text>
<claim-text>replacing the smallest Y in the table with U<highlight><subscript>k</subscript></highlight>; </claim-text>
<claim-text>setting the I value paired with the smallest Y equal to M; and, </claim-text>
<claim-text>storing all or part of the next record of the database in said reservoir of stored records, wherein the current value of M is a reservoir index to said stored record. </claim-text>
</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The method as set forth in <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference>, wherein the step of updating the table further includes the step of: 
<claim-text>arranging the table in a heap with respect to Y. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The method as set forth in <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference>, further comprising the step of: 
<claim-text>sorting said stored statistics by key prior to producing said partition analysis. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The method as set forth in <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, further comprising the steps of: 
<claim-text>accessing all database records in an arbitrary sequence; </claim-text>
<claim-text>iteratively filling all of said partitions except the last said partition with said accessed records to a maximum byte count; and, storing remaining accessed records in the last of said partitions. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The method as set forth in <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference>, wherein the step of storing statistics includes storing said statistics in a memory. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The method as set forth in <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, wherein the step of storing statistics includes storing said statistics in said memory in a compressed format. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The method as set forth in <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference>, wherein the step of producing at least one of said partition analyses includes the step of defining multiple partition boundaries. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The method as set forth in <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference>, wherein the step of sampling said S records includes randomly sampling the S records utilizing dataspaces including: 
<claim-text>at least one index dataspace; </claim-text>
<claim-text>at least one key dataspace; and, </claim-text>
<claim-text>at least one statistics dataspace. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. A database management system (DBMS) for managing an associated database, the DBMS comprising: 
<claim-text>random sampling facility integrated with the database management system; </claim-text>
<claim-text>first database analysis tools using said integrated random sampling facility for generating extrapolated reports on database content; </claim-text>
<claim-text>second database analysis tools using said integrated random sampling facility for generating extrapolated reports on database size; and, </claim-text>
<claim-text>database replication tools adapted to execute at least one of a complete replication having output partition sizes determined by extrapolating a random sample of said database, and a partial replication in which the data stored in the partial replication comprises a random sample of said database. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The database management system of <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference> further comprising: 
<claim-text>a pre-configured number S defining a default sample size; </claim-text>
<claim-text>a means for selectively receiving a particular number defining a desired sample size and setting said number S equal to said particular number; </claim-text>
<claim-text>a means for randomly sampling S records of the database using said random sampling facility; </claim-text>
<claim-text>a means for storing statistics for each of said S records, wherein said statistics include a record key for each record; and, </claim-text>
<claim-text>a means for producing at least one of: 
<claim-text>an extrapolated database content analysis based on said statistics; </claim-text>
<claim-text>an extrapolated partition analysis based on said statistics; and, </claim-text>
<claim-text>a partial partition analysis based on said statistics. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The database management system of <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, further comprising: 
<claim-text>a means for sorting said stored statistics by key prior to producing at least one of said analyses. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The database management system of <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, wherein said means for randomly sampling S records further comprises: 
<claim-text>a means for generating a table of S number pairs (Y<highlight><subscript>j</subscript></highlight>,I<highlight><subscript>j</subscript></highlight>), j&equals;1,2, . . . ,S, wherein all Y and all I are initially zero; </claim-text>
<claim-text>a means for initializing a reservoir of records to an empty state; </claim-text>
<claim-text>a means for setting an index M to said reservoir equal to zero; </claim-text>
<claim-text>a means for generating a sequence of N non-repeating random numbers U<highlight><subscript>1</subscript></highlight>,U<highlight><subscript>2</subscript></highlight>, . . . ,U<highlight><subscript>N</subscript></highlight>, 0&lE;U&lE;1, wherein N is the number of records in the database; and, </claim-text>
<claim-text>a means, for each random number U<highlight><subscript>k </subscript></highlight>generated, k&equals;1,2, . . . ,N, comprising: 
<claim-text>a means to skip the next record in said database if U<highlight><subscript>k </subscript></highlight>is less than the smallest value of Y in said table of number pairs; and, </claim-text>
<claim-text>a means to update the table if a Y less than U<highlight><subscript>k </subscript></highlight>exists, comprising: </claim-text>
<claim-text>a means to set M equal to its current value plus one; </claim-text>
<claim-text>a means to replace the smallest Y in the table with U<highlight><subscript>k</subscript></highlight>; </claim-text>
<claim-text>a means to set the I value paired with the smallest Y equal to M; and, </claim-text>
<claim-text>a means to store all or part of the next record of said database in said reservoir of stored records, wherein the current value of M is a reservoir index to said stored record. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The database management system of <dependent-claim-reference depends_on="CLM-00011">claim 18</dependent-claim-reference> wherein the means to update the table further comprises: 
<claim-text>a means to arrange the table in a heap with respect to Y. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The database management system of <dependent-claim-reference depends_on="CLM-00011">claim 18</dependent-claim-reference>, wherein said means for storing statistics comprises a means for storing said statistics in memory. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The database management system of <dependent-claim-reference depends_on="CLM-00022">claim 20</dependent-claim-reference>, further comprising a means for sorting said stored statistics by key prior to producing at least one of said analyses. </claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The database management system of <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference>, wherein said partition analyses include analyses of multiple partition boundaries. </claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The database management system of <dependent-claim-reference depends_on="CLM-00022">claim 22</dependent-claim-reference>, further comprising: 
<claim-text>a means for accessing all database records in an arbitrary sequence; </claim-text>
<claim-text>a means for iteratively filling all of said partitions except the last with said accessed records to a maximum byte count; and, </claim-text>
<claim-text>a means for storing remaining accessed records in the last of said partitions. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The database management system of <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, further comprising: 
<claim-text>a means for utilizing at least one index dataspace; </claim-text>
<claim-text>a means for utilizing at least one key dataspace; and, </claim-text>
<claim-text>a means for utilizing at least one statistics dataspace.</claim-text>
</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>1</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030004973A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030004973A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030004973A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
