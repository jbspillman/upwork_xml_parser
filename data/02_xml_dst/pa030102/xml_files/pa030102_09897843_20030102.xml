<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005422A1-20030102-D00000.TIF SYSTEM "US20030005422A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005422A1-20030102-D00001.TIF SYSTEM "US20030005422A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005422A1-20030102-D00002.TIF SYSTEM "US20030005422A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005422A1-20030102-D00003.TIF SYSTEM "US20030005422A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005422A1-20030102-D00004.TIF SYSTEM "US20030005422A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005422A1-20030102-D00005.TIF SYSTEM "US20030005422A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030005422A1-20030102-D00006.TIF SYSTEM "US20030005422A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030005422A1-20030102-D00007.TIF SYSTEM "US20030005422A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030005422A1-20030102-D00008.TIF SYSTEM "US20030005422A1-20030102-D00008.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005422</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09897843</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010702</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F009/45</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>717</class>
<subclass>154000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Technique for improving the prediction rate of dynamically unpredictable branches</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Nicolai</given-name>
<family-name>Kosche</family-name>
</name>
<residence>
<residence-us>
<city>San Francisco</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Chris</given-name>
<family-name>Hescott</family-name>
</name>
<residence>
<residence-us>
<city>Minneapolis</city>
<state>MN</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Qing</given-name>
<family-name>Zhao</family-name>
</name>
<residence>
<residence-us>
<city>Urbans</city>
<state>IL</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Youngsoo</given-name>
<family-name>Choi</family-name>
</name>
<residence>
<residence-us>
<city>Pleasanton</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>David</given-name>
<middle-name>J.</middle-name>
<family-name>Lilja</family-name>
</name>
<residence>
<residence-us>
<city>Maplewood</city>
<state>MN</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>ROSENTHAL &amp; OSHA L.L.P.</name-1>
<name-2></name-2>
<address>
<address-1>1221 MCKINNEY AVENUE</address-1>
<address-2>SUITE 2800</address-2>
<city>HOUSTON</city>
<state>TX</state>
<postalcode>77010</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A method of improving a prediction rate for instructions in code includes determining a sequence from profile information; and transforming the code based on the determined sequence. A method of improving processor performance includes transforming a set of branches into a second set of branches, wherein the second set of branches comprises the original set of branches; and a sequence of branches likely to execute as an entity. A processor includes means for processing instructions; and means for transforming a set of branches into a second set of branches, wherein the second set of branches comprises the original set of branches; and a sequence of branches likely to execute as an entity. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">BACKGROUND OF INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> Computer processors contain arithmetic, logic, and control circuitry that interpret and execute instructions from a computer program. Referring to <cross-reference target="DRAWINGS">FIG. 1, a</cross-reference> typical computer system includes a microprocessor (<highlight><bold>10</bold></highlight>) having, among other things, a CPU (<highlight><bold>12</bold></highlight>) containing a load/store unit (<highlight><bold>14</bold></highlight>), and an on-board cache memory (<highlight><bold>16</bold></highlight>). The microprocessor (<highlight><bold>12</bold></highlight>) is connected to external cache memory (<highlight><bold>17</bold></highlight>) and a main memory (<highlight><bold>18</bold></highlight>) that both hold data and program instructions to be executed by the microprocessor (<highlight><bold>10</bold></highlight>). Internally, the execution of program instructions is carried out by the CPU (<highlight><bold>12</bold></highlight>). Data needed by the CPU (<highlight><bold>12</bold></highlight>) to carry out an instruction are fetched by the load/store unit (<highlight><bold>14</bold></highlight>) and loaded into internal registers (<highlight><bold>15</bold></highlight>) of the CPU (<highlight><bold>12</bold></highlight>). Upon command from the CPU (<highlight><bold>12</bold></highlight>), the load/store unit (<highlight><bold>14</bold></highlight>) searches for the data first in the fast on-board cache memory (<highlight><bold>16</bold></highlight>), then in external cache memory (<highlight><bold>17</bold></highlight>), and finally in the main memory (<highlight><bold>18</bold></highlight>). Finding the data in the cache memory is referred to as a &ldquo;hit.&rdquo; Not finding the data in the cache memory is referred to as a &ldquo;miss.&rdquo;</paragraph>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> The time between when a CPU requests data and when the data is retrieved and available for use by the CPU is termed the &ldquo;latency&rdquo; of the request. If requested data is found in cache memory, i.e., a data hit occurs, the requested data can be accessed at the speed of the cache and the latency of the system is reduced. If, on the other hand, the data is not found in cache, i.e., a data miss occurs, and thus the data must be retrieved from main memory for access and the latency of the request is increased. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> In the pursuit of improving processor performance, designers have sought two main goals: making operations faster and executing more operations in parallel. Making operations faster can be approached in several ways. For example, transistors can be made to switch faster and thus propagate signals faster by improving semiconductor processes; execution-unit latency can be reduced by increasing the number of transistors in the design; and the levels of logic required by the design to implement a given function can be minimized to increase speed. To execute more operations in parallel, designers mainly rely on one, or a combination of pipelining and superscalar techniques. Pipelined processors overlap instructions in time on common execution resources. Superscalar processors overlap instructions in space on separate resources. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> Pipeline stalls are a main performance inhibitor with regard to parallel processing. Stalls arise from data dependencies, changes in program flow, and hardware resource conflicts. At times, pipeline stalls can be avoided by rearranging the order of execution for a set of instructions. Compilers can be used to statically reschedule instructions. However, incomplete knowledge of run-time information reduces the effectiveness of static rescheduling. In-order processors, i.e., processors that issue, execute, complete, and retire instructions in strict program order, have to rely entirely on static rescheduling and thus are prone to pipeline stalls. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> As a result, designers generally use out-of-order processors and seek to implement dynamic instruction rescheduling. The simplest out-of-order processors issue instructions in order but allow them to execute out of order. Even these simple out-of-order processors require complex hardware to reorder results before the corresponding instructions are retired. A strict result order is not required from a data-flow perspective. However, such ordering is necessary to maintain precise exceptions and to recover from mispredicted speculative execution. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> A well-known method of reordering is through the use of a reorder buffer, i.e., a buffer that maintains results until written to the register file in program order. Designers also use other types of reordering hardware, such as history buffers and future files. History buffers record source-operand history so the processor can backtrack to a precise architectural state and future files store the current state and the architectural state in separate register files allowing the processor to be restored to a precise check-point state. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> Branch prediction and speculative execution are additional techniques used to increase the efficiency of a processor. In a pipelined processor, the outcomes of branch instructions are often determined after subsequent instructions have been fetched. Using branch prediction schemes, microprocessors attempt to accurately predict whether a branch is taken or not based on how that branch has behaved previously. The aggregate behavior, or the average behavior over time, of the branch instruction is stored in a Branch Prediction Table (&ldquo;BPT&rdquo;). Given a branch instruction&apos;s aggregate behavior, the branch predictor, which resides in an instruction fetch unit, predicts the outcome of the branch instruction and then loads instructions thereafter based on that prediction. For example, if the branch predictor predicts that a branch will be taken, then the processor fetches subsequent instructions according to the address to which the instruction branches. When the branch proceeds in the predicted direction, pipeline stalls are completely avoided. On the other hand, if the branch direction is mispredicted, all the instructions after the mispredicted instruction must be removed from the processor. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> Among other techniques, compiler technology, e.g., trace scheduling, profiling, and case-peeling, is used to improve the accuracy of these predictions. Trace scheduling is a compiler technique that schedules across several branches. Trace scheduling relates to the arrangement of a control flow from the most frequently executed paths, possibly at the expense of the less frequently executed paths. Profiling is a compiler technique that involves monitoring of the execution of code to identify a history pattern. The generated profile information can then be used by a dynamic branch predictor in situations where history information upon which to base prediction is not available. Case-peeling is the removal of one case from the beginning of a switch by inserting a copy of the entire case statement before the beginning of the switch. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> Certain loops have multi-way branches that are impossible to predict in hardware. Specifically, many interpretive engines have a multi-way branch for each interpreted instruction. Because these instructions vary, prediction hardware routinely has a low probability of computing the target. Referring to <cross-reference target="DRAWINGS">FIG. 2, a</cross-reference> exemplary block diagram showing a conventional branched instruction line (<highlight><bold>100</bold></highlight>) with identified line probabilities. In the example shown, a switch instruction (<highlight><bold>102</bold></highlight>) leads to a next instruction (<highlight><bold>110</bold></highlight>) through one of three possible cases, case 1 (<highlight><bold>104</bold></highlight>), case 2, (<highlight><bold>106</bold></highlight>), and case 3 (<highlight><bold>108</bold></highlight>). From profiling, it is known that case 1 has an associated probability of 35% (P&equals;0.35), case 2 has an associated probability of 33% (P&equals;0.33), and case 3 has an associated probability of 32% (P&equals;0.32). Thus, in the prediction of the flow, the compiler proceeds from the highest probability case to the lowest probability case as illustrated in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> shows exemplary conventional code (<highlight><bold>112</bold></highlight>) for processing a branched instruction line. Because case 1 has the highest probability, case 1 is predicted first. As can be seen, the associated probability of prediction is 65% (P&equals;0.65) that the branch will not be taken. In the situation that case 1 is not taken, case 2 is predicted as it has the second highest probability. After the occurrence of case 1, the probability for case 2 occurring is 51% (P&equals;0.51). Lastly, the case 3 is predicted. After eliminating case 1 and case 2, case 3 has an associated probability of 100% (P&equals;1.00). This prediction process is repeated on every loop. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF INVENTION </heading>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> In general, in one aspect, the present invention involves a method for improving branch prediction rates in a microprocessor comprising processing a case; determining a next case from a sequence involving the processed case; and processing the next case. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> In general, in one aspect, the present invention involves a method of improving a prediction rate for instructions in code comprising determining a sequence from profile information; and transforming the code based on the determined sequence. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> In general, in one aspect, the present invention involves an apparatus for improving branch prediction rates in a microprocessor comprising a compiler comprising an optimization component, wherein the optimization component determines a sequence from profile information and transforms code received by the compiler based on the determined sequence. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> In general, in one aspect, the present invention involves a software tool for improving branch prediction rates in a microprocessor comprising a program stored on computer-readable media for processing a case; determining a next case from a sequence involving the processed case; and processing the next case. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> In general, in one aspect, the present invention involves a software tool for improving a prediction rate for instructions in code comprising a program stored on computer-readable media for determining a sequence from profile information; and transforming the code based on the determined sequence. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> In general, in one aspect, the present invention involves an apparatus for improving branch prediction rates in a microprocessor comprising means for determining a sequence; and means for transforming code based on the sequence. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> In general, in one aspect, the present invention involves a method of improving branch prediction rates in a microprocessor comprising converting a plurality of unpredictable branches into a set of predictable branches by expanding at least one of the unpredictable branches into a follow-set branch based on a profile for the unpredictable branches. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> In general, in one aspect, the present invention involves a method for improving branch prediction rates in a microprocessor comprising determining a sequence involving a branch from profile information; processing the branch; determining a next branch in the sequence; and selectively processing the next branch during the processing of the branch based on an associated probability. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> In general, in one aspect, the present invention involves a method of improving processor performance comprising transforming a set of branches into a second set of branches, wherein the second set of branches comprises the original set of branches; and a sequence of branches likely to execute as an entity. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> In general, in one aspect, the present invention involves a processor comprising means for processing instructions; and means for transforming a set of branches into a second set of branches, wherein the second set of branches comprises the original set of branches; and a sequence of branches likely to execute as an entity. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> Other aspects and advantages of the invention will be apparent from the following description and the appended claims.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF DRAWINGS </heading>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> shows a typical computer system. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> shows an exemplary conventional branched instruction line with identified line probabilities. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> shows exemplary conventional code for processing a branched instruction line. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> shows an exemplary branched instruction line with identified line probabilities in accordance with an embodiment of the present invention. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> shows exemplary code for processing a branched instruction line in accordance with an embodiment of the present invention. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is a flow chart describing branched instruction line processing in accordance with an embodiment of the present invention. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> is a flow chart describing branched instruction line processing in accordance with an embodiment of the present invention.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION </heading>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> The present invention relates to a method and apparatus for improving the prediction rate of dynamically unpredictable branches. In one or more embodiments, the present invention improves the predictability of branches through the use of follow-sets, or likely branch target sequences. The follow-sets are used to isolate cases where branch sequences are predictable. Referring to the drawings, <cross-reference target="DRAWINGS">FIG. 4</cross-reference> shows an exemplary branched instruction line with identified line probabilities in accordance with an embodiment of the present invention. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> In the example shown, a switch instruction (<highlight><bold>202</bold></highlight>) leads to a next instruction (<highlight><bold>210</bold></highlight>) via one of three cases: case 1 (<highlight><bold>204</bold></highlight>); case 2 (<highlight><bold>206</bold></highlight>); and case 3 (<highlight><bold>208</bold></highlight>). Additionally, a follow-set (<highlight><bold>203</bold></highlight>) is created after the most probable case, case 1 (<highlight><bold>204</bold></highlight>). The follow-set includes three new instructions (<highlight><bold>205</bold></highlight>), (<highlight><bold>209</bold></highlight>), and (<highlight><bold>212</bold></highlight>), together with the &ldquo;next&rdquo; cases in sequence, case 2 (<highlight><bold>207</bold></highlight>) and case 3 (<highlight><bold>211</bold></highlight>). The &ldquo;next&rdquo; cases in sequence, case 2 (<highlight><bold>207</bold></highlight>) and case 3 (<highlight><bold>211</bold></highlight>) are copies of case 2 (<highlight><bold>206</bold></highlight>) and case 3 (<highlight><bold>208</bold></highlight>) respectively. The new instructions (<highlight><bold>205</bold></highlight>), (<highlight><bold>209</bold></highlight>), and (<highlight><bold>212</bold></highlight>) determine whether the sequence continues in accordance with profile information for the flow. In this example there is a 95% probability that the sequence case 1, case 2, case 3, case 1 will occur (P&equals;0.95 sequence case 1, case 2, case 3, case 1). </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> The follow-set involves grouping sequences of likely cases together so that the sequences have more branches, but the branches are more predictable. In the example shown, when case 1 (<highlight><bold>204</bold></highlight>) occurs, given the profile information, it is highly likely that case 2 (<highlight><bold>207</bold></highlight>) will occur next. Thus, that probability is exploited to a create better prediction scheme. Similarly, when case 2 (<highlight><bold>207</bold></highlight>) occurs, it is highly likely that case 3 (<highlight><bold>211</bold></highlight>) will occur next and when case 3 (<highlight><bold>211</bold></highlight>) occurs that case 1 (<highlight><bold>204</bold></highlight>) will occur next. By duplicating the &ldquo;next&rdquo; computation and creating a test for the subsequent case condition as a subset of the switch/multiway branch, a sequence of instructions with predictable branches is. created. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 5</cross-reference>, exemplary code for processing a branched instruction line in accordance with an embodiment of the present invention is shown. The code shown adds a follow-set to the standard code for processing case 1 (<highlight><bold>204</bold></highlight>). As can be seen, the probability of accurately predicting case 2 (<highlight><bold>206</bold></highlight>) after case 1 (<highlight><bold>204</bold></highlight>) occurs is 95% (P&equals;0.95). Further, the sequence continues accordingly with 95% probabilities for case 2 (<highlight><bold>206</bold></highlight>) to case 3 (<highlight><bold>208</bold></highlight>) and case 3 (<highlight><bold>208</bold></highlight>) back to case 1 (<highlight><bold>204</bold></highlight>). Thus, the branches executed most often are accurately predicted. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> A process in accordance with one or more embodiments of the present invention is shown in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>. First, the most predictable case in the set is processed (step <highlight><bold>220</bold></highlight>). Then, the most probable next case is determined from sequence information (step <highlight><bold>222</bold></highlight>). If the determined next case meets the follow-set probability threshold (step <highlight><bold>224</bold></highlight>), that next case is processed (step <highlight><bold>226</bold></highlight>). If not, the process ends. Thus, once the first case in the sequence has been processed, the remaining stages of the sequence are checked prior to restarting case prediction. In this manner, the probability of accurate prediction is increased. Those skilled in the art will appreciate that this process is not limited to sequences beginning with the most probable case, rather it can be applied to all known sequences. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 7</cross-reference>, the compilation process (<highlight><bold>250</bold></highlight>) involves translating source code (<highlight><bold>252</bold></highlight>) with a compiler (<highlight><bold>254</bold></highlight>) to produce a compiled program (<highlight><bold>262</bold></highlight>) suitable for execution on a processor. The compiler (<highlight><bold>254</bold></highlight>) includes an optimization component (<highlight><bold>256</bold></highlight>) in accordance with one or more embodiments of the present invention, as well as an instruction scheduler (<highlight><bold>258</bold></highlight>), and other compilation components (<highlight><bold>260</bold></highlight>) for carrying out other compilation tasks. During compilation, the source code (<highlight><bold>252</bold></highlight>) is converted into intermediary stages by the components of the compiler (<highlight><bold>254</bold></highlight>). Specifically, the optimization component (<highlight><bold>256</bold></highlight>) transforms the code by adding a follow-set as described above for sequences identified from profile information. The operation of the optimization component (<highlight><bold>256</bold></highlight>) is discussed in more detail below. Once an independent portion of the source code (<highlight><bold>252</bold></highlight>) has been optimized by the optimization component (<highlight><bold>256</bold></highlight>), the instruction scheduler (<highlight><bold>258</bold></highlight>) compiles an instruction set. The operation of the instruction scheduler and other compiler components are well known in the art and will not be discussed in detail here. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> is a flow chart describing exemplary operation of the optimization component (<highlight><bold>256</bold></highlight>) in accordance with one or more embodiments of the present invention. The process begins with the identification of the most predictable branch (step <highlight><bold>300</bold></highlight>) and reliable sequences from profile information (step <highlight><bold>302</bold></highlight>). Then, the code is transformed into a follow-set structure as described above (step <highlight><bold>304</bold></highlight>). Finally, after optimizing the code, the optimization component (<highlight><bold>256</bold></highlight>) passes the code to the instruction scheduler (<highlight><bold>258</bold></highlight>) for further processing (step <highlight><bold>306</bold></highlight>). Those skilled in the art will appreciate that the order of identification may vary or occur concurrently, and the transformation process may occur multiple times for different sequences before passing the code to the instruction scheduler (<highlight><bold>258</bold></highlight>). </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> Advantages of the present invention may include one or more of the following. Sequences of likely cases are grouped together so that the sequences have more branches, but the branches are more predictable. These sequences of more predictable branches yield more efficient processor operations because memory transactions requested by the processor are more probably going to be used by the processor. Accordingly, less unnecessary memory transaction are requested by the processor. Also, branches can be grouped into larger sets. This allows longer traces to be created with greater certainty. These traces can be further optimized via trace scheduling techniques, and other techniques. Thus, the probability of accurately predicting branches is increased and hardware branch prediction is improved. Those skilled in the art will appreciate that the present invention also may include other advantages and features. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> While the invention has been described with respect to a limited number of embodiments, those skilled in the art, having benefit of this disclosure, will appreciate that other embodiments can be devised which do not depart from the scope of the invention as disclosed herein. Accordingly, the scope of the invention should be limited only by the attached claims. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method for improving branch prediction rates in a microprocessor comprising: 
<claim-text>processing a case; </claim-text>
<claim-text>determining a next case from a sequence involving the processed case; and </claim-text>
<claim-text>processing the next case. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising: 
<claim-text>selectively processing the next case based on an associated probability. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein determining the next case and processing the next case occur during the processing of the case. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising: 
<claim-text>determining the sequence from profile information. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising: 
<claim-text>determining a second next case from the sequence; and </claim-text>
<claim-text>processing the second next case. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference>, wherein processing the second next case is selective based on an associated probability. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference>, wherein determining the second next case and processing the second next case occur during the processing of the case. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the case and the next case are branch instructions. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. A method of improving a prediction rate for instructions in code comprising: 
<claim-text>determining a sequence from profile information; and </claim-text>
<claim-text>transforming the code based on the determined sequence. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference> wherein transforming the code comprises: 
<claim-text>adding a follow-set to a portion of the code for processing a first instruction in the sequence. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein adding the follow-set is selective based on a probability associated with the sequence. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. An apparatus for improving branch prediction rates in a microprocessor comprising: 
<claim-text>a compiler comprising an optimization component, </claim-text>
<claim-text>wherein the optimization component determines a sequence from profile information and transforms code received by the compiler based on the determined sequence. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, wherein the optimization component adds a follow-set to a portion of the code. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. A software tool for improving branch prediction rates in a microprocessor comprising: 
<claim-text>a program stored on computer-readable media for processing a case; </claim-text>
<claim-text>determining a next case from a sequence involving the processed case; and </claim-text>
<claim-text>processing the next case. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The software tool of <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference>, further comprising: 
<claim-text>a program stored on computer-readable media for selectively processing the next case based on an associated probability. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The software tool of <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference>, wherein determining the next case and processing the next case occur during the processing of the case. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The software tool of <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, further comprising: 
<claim-text>a program stored on computer-readable media for determining the sequence from profile information. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The software tool of <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference>, further comprising: 
<claim-text>a program stored on computer-readable media for determining a second next case from the sequence; and </claim-text>
<claim-text>processing the second next case. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The software tool of <dependent-claim-reference depends_on="CLM-00011">claim 18</dependent-claim-reference>, further comprising: 
<claim-text>a program stored on computer-readable media for selectively processing the second next case based on an associated probability. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The software tool of <dependent-claim-reference depends_on="CLM-00011">claim 18</dependent-claim-reference>, wherein determining the second next case and processing the second next case occur during the processing of the case. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The software tool of <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference>, wherein the case and the next case are branch instructions. </claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. A software tool for improving a prediction rate for instructions in code comprising: 
<claim-text>a program stored on computer-readable media for determining a sequence from profile information; and </claim-text>
<claim-text>transforming the code based on the determined sequence. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The software tool of <dependent-claim-reference depends_on="CLM-00022">claim 22</dependent-claim-reference>, wherein transforming the code comprises: 
<claim-text>a program stored on computer-readable media for adding a follow-set to a portion of the code for processing a first instruction in the sequence. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The software tool of <dependent-claim-reference depends_on="CLM-00022">claim 22</dependent-claim-reference>, wherein adding the follow-set is selective based on a probability associated with the sequence. </claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. An apparatus for improving branch prediction rates in a microprocessor comprising: 
<claim-text>means for determining a sequence; and </claim-text>
<claim-text>means for transforming code based on the sequence. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>, further comprising: 
<claim-text>means for adding a follow-set to a portion of the code. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. A method of improving branch prediction rates in a microprocessor comprising: 
<claim-text>converting a plurality of unpredictable branches into a set of predictable branches by expanding at least one of the unpredictable branches into a follow-set branch based on a profile for the unpredictable branches. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. A method for improving branch prediction rates in a microprocessor comprising: 
<claim-text>determining a sequence involving a branch from profile information; </claim-text>
<claim-text>processing the branch; </claim-text>
<claim-text>determining a next branch in the sequence; and </claim-text>
<claim-text>selectively processing the next branch during the processing of the branch based on an associated probability. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00029">
<claim-text><highlight><bold>29</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 28</dependent-claim-reference>, further comprising: 
<claim-text>determining second next branch in the sequence; and </claim-text>
<claim-text>selectively processing the second next branch during the processing of the branch based on an associated probability. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00030">
<claim-text><highlight><bold>30</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 28</dependent-claim-reference>, wherein the processing is based on code transformed to comprise a follow-set for the sequence. </claim-text>
</claim>
<claim id="CLM-00031">
<claim-text><highlight><bold>31</bold></highlight>. A method of improving processor performance comprising: 
<claim-text>transforming a set of branches into a second set of branches, </claim-text>
<claim-text>wherein the second set of branches comprises 
<claim-text>the original set of branches; and </claim-text>
<claim-text>a sequence of branches likely to execute as an entity. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00032">
<claim-text><highlight><bold>32</bold></highlight>. A processor comprising: 
<claim-text>means for processing instructions; and </claim-text>
<claim-text>means for transforming a set of branches into a second set of branches, </claim-text>
<claim-text>wherein the second set of branches comprises 
<claim-text>the original set of branches; and </claim-text>
<claim-text>a sequence of branches likely to execute as an entity.</claim-text>
</claim-text>
</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>6</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005422A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005422A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005422A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005422A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005422A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005422A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030005422A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030005422A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030005422A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
