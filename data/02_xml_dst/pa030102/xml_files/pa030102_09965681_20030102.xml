<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030000528A1-20030102-M00001.NB SYSTEM "US20030000528A1-20030102-M00001.NB" NDATA NB>
<!ENTITY US20030000528A1-20030102-M00001.TIF SYSTEM "US20030000528A1-20030102-M00001.TIF" NDATA TIF>
<!ENTITY US20030000528A1-20030102-M00002.NB SYSTEM "US20030000528A1-20030102-M00002.NB" NDATA NB>
<!ENTITY US20030000528A1-20030102-M00002.TIF SYSTEM "US20030000528A1-20030102-M00002.TIF" NDATA TIF>
<!ENTITY US20030000528A1-20030102-M00003.NB SYSTEM "US20030000528A1-20030102-M00003.NB" NDATA NB>
<!ENTITY US20030000528A1-20030102-M00003.TIF SYSTEM "US20030000528A1-20030102-M00003.TIF" NDATA TIF>
<!ENTITY US20030000528A1-20030102-M00004.NB SYSTEM "US20030000528A1-20030102-M00004.NB" NDATA NB>
<!ENTITY US20030000528A1-20030102-M00004.TIF SYSTEM "US20030000528A1-20030102-M00004.TIF" NDATA TIF>
<!ENTITY US20030000528A1-20030102-M00005.NB SYSTEM "US20030000528A1-20030102-M00005.NB" NDATA NB>
<!ENTITY US20030000528A1-20030102-M00005.TIF SYSTEM "US20030000528A1-20030102-M00005.TIF" NDATA TIF>
<!ENTITY US20030000528A1-20030102-D00000.TIF SYSTEM "US20030000528A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030000528A1-20030102-D00001.TIF SYSTEM "US20030000528A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030000528A1-20030102-D00002.TIF SYSTEM "US20030000528A1-20030102-D00002.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030000528</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09965681</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010927</filing-date>
</domestic-filing-data>
<foreign-priority-data>
<priority-application-number>
<doc-number>SE 0003531-1</doc-number>
</priority-application-number>
<filing-date>20001002</filing-date>
<country-code>SE</country-code>
</foreign-priority-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>A62B007/00</ipc>
</classification-ipc-primary>
<classification-ipc-secondary>
<ipc>A61M016/00</ipc>
</classification-ipc-secondary>
<classification-ipc-secondary>
<ipc>F16K031/02</ipc>
</classification-ipc-secondary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>128</class>
<subclass>204230</subclass>
</uspc>
</classification-us-primary>
<classification-us-secondary>
<uspc>
<class>128</class>
<subclass>204210</subclass>
</uspc>
</classification-us-secondary>
<classification-us-secondary>
<uspc>
<class>128</class>
<subclass>204180</subclass>
</uspc>
</classification-us-secondary>
</classification-us>
<title-of-invention>Auto CPAP</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Ove</given-name>
<family-name>Eklund</family-name>
</name>
<residence>
<residence-non-us>
<city>Surrey</city>
<country-code>GB</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Henrik</given-name>
<family-name>Bergfalk</family-name>
</name>
<residence>
<residence-non-us>
<city>Goteborg</city>
<country-code>SE</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>MOSER, PATTERSON &amp; SHERIDAN L.L.P.</name-1>
<name-2></name-2>
<address>
<address-1>595 SHREWSBURY AVE</address-1>
<address-2>FIRST FLOOR</address-2>
<city>SHREWSBURY</city>
<state>NJ</state>
<postalcode>07702</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A method for the detection and treatment of disordered breathing during sleep employs an artificial neural network (ANN) in which data related to breathing gas flow are analyzed. A respiratory circuit is established by connecting the patient to a continuous positive airway pressure (CPAP) system with pressurized breathing gas supply, the gas flow in the circuit is periodically sampled, one or several cepstrum parameters distinctive of various breathing patterns are periodically calculated; the parameter values are periodically fed to an ANN trained to recognize breathing patterns characteristic of sleep disordered breathing and are analyzed in the network, the CPAP pressurized breathing gas supply is controlled in response to the ANN output. Also disclosed is a corresponding apparatus. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">CROSS REFERENCE TO RELATED APPLICATIONS </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> The present application claims the benefit of Swedish patent application No. SE 0003531-1 which was filed on Oct. 2, 2000 and is incorporated herein by reference. </paragraph>
</section>
<section>
<heading lvl="1">FIELD OF THE INVENTION </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> The present invention relates to method and an apparatus for the detection and treatment of disordered breathing during sleep, in particular to a method and apparatus employing an artificial neural network. </paragraph>
</section>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> U.S. Pat. No. 5,953,713 (Behbehani et al.), incorporated herein by reference, discloses a method for treating sleep disordered breathing comprising measuring a respiration-related variable at an interface placed over a patient&apos;s airway coupled to a pressurized gas, feeding cepstrum data obtained from the respiration related variable(s) into an artificial neural network trained to recognize patterns characterizing sleep disordered breathing; supplying pressurized gas to the patients airway in response to recognition of the artificial neural network of sleep disordered breathing. The sampling frequency of the pressure transducer&apos;s output disclosed in the preferred embodiment is 512 Hz. A Fourier transform is calculated every {fraction (1/16)} second using a 32 sample values window. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> Another aspect of frequency analysis is that, on the one hand, the precision is proportional to the number of input data but that, on the other hand, the response time is correspondingly increased. While high precision is welcome since rather small changes in breath pattern can be detected, a slower response increases the risk of progressive deterioration of the airway aperture, and thereby more severe respiratory disturbance before the patient is aroused. Other methods of detecting sleep disorder are based on breath-by-breath analysis. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> Alternatively, if adequate treatment is not installed, the patient will be aroused in a more extended time perspective. </paragraph>
</section>
<section>
<heading lvl="1">OBJECTS OF THE INVENTION </heading>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> It is an object of the present invention to provide an improved method for automatically supplying continuous positive airways pressure to a patient. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> It is another object of the present invention to provide an automatic continuous positive airways pressure apparatus (ACPAP) which lacks at least some of the drawbacks of state-of-the-art apparatus. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> Additional objects of the invention are evident from the following short description of the invention, the attached drawings illustrating a preferred embodiment, the detailed description thereof, and the appended claims. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> The present invention is based on the insight that a direct analysis of the flow signal is more specific than an analysis of disordered breath, in particular flow limited breath, based on frequency analysis. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> According to the present invention is provided an automatic continuous positive airways pressure apparatus (ACPAP) in which the air flow from a CPAP or other system providing positive air pressure to a patient is measured for calculation of a number of parameters specific to the signal. The set of parameters comprises cepstrum coefficients and energy content, and is selected to indicate an apneic event of breathing during sleep, such as apnea, hypoapnea, and flow limitation. Data for these parameters collected from a large number of patients were used to train an artificial neural network to teach the system the variation ranges of the parameters for subsets of patients under a number of circumstances. The result from the artificial neural network is obtained as a low-dimensional grid of nodes in which each respiration type is represented by trajectory or a subsets of nodes. A trajectory for a normal breath looks very different from that of a breath during disturbed sleep. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> If breathes symptomatic of a condition of disturbed sleep are detected the CPAP pressure is increased. In contrast, CPAP pressure is reduced in a normal condition. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> Thus, according to the present invention is disclosed a method for the detection and treatment of disordered breathing during sleep employing an artificial neural network in which data related to breathing gas flow are analyzed in an artificial neural network. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> Specifically, a method according to an embodiment of the present invention comprises the following steps: </paragraph>
<paragraph id="P-0014" lvl="2"><number>&lsqb;0014&rsqb;</number> placing a mask with a tube over a patient&apos;s airway, the mask being in communication with a source of a pressurized breathing gas controlled by a CPAP, thereby establishing a respiratory circuit; </paragraph>
<paragraph id="P-0015" lvl="2"><number>&lsqb;0015&rsqb;</number> periodically sampling the gas flow in the circuit; </paragraph>
<paragraph id="P-0016" lvl="2"><number>&lsqb;0016&rsqb;</number> periodically calculating values for one or several parameters distinctive of a breathing pattern; </paragraph>
<paragraph id="P-0017" lvl="2"><number>&lsqb;0017&rsqb;</number> periodically feeding the parameter values to an artificial neural network trained to recognize breathing patterns characteristic of sleep disordered breathing; </paragraph>
<paragraph id="P-0018" lvl="2"><number>&lsqb;0018&rsqb;</number> analyzing the parameter values in the neural network; </paragraph>
<paragraph id="P-0019" lvl="2"><number>&lsqb;0019&rsqb;</number> controlling pressurized breathing gas supply in response to the output from the neural network. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> It is preferred to feed said parameter values to the network at a frequency of from 2 Hz to 30 Hz, preferably of about 20 Hz. It is preferred for said parameters to comprise cepstrum coefficients and energy slope. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> According to a first preferred aspect of the invention the artificial neural network is trained with data collected from a large number of patients. The data will have been collected from patients differing in many aspects: sex, age, body weight, breath pattern, etc. In addition, variants of sleep disordered breathing such as those occurring preferentially in the back position, those occurring during particular stages of sleep, and those occurring under the influence of drugs or alcohol need to be addressed. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> Such data are advantageously collected in sleep laboratories in which the state of sleep is followed as well as the type and severity of the breathing disturbance is monitored by use of a polysomnography system. The collected data form a primary database. During the training of the artificial neural network the data is quantified under formation of a small secondary dedicated database which can be stored in a ACPAP. Thus, according to the present invention, a dedicated secondary database obtained from a primary database comprising data collected from a large number of persons is stored in the ACPAP. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> According to a second aspect of the invention it is preferred to periodically sample the gas flow during breathing. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> The ANN comprises a number of nodes representing sets of training data. Each note reflects a state or an incident (feature). Neighboring nodes represent incidents of small geometric distance. In the same way as in training an incident vector is extracted for each flow data sample. The Euclidean distance from the incident vector to each node is calculated. The node in closest proximity to the vector is associated with it. Sequences of incident vectors are followed as sequences of nodes in the artificial neural network. It can be said that a sequence of nodes is the response of the network. Thus a trajectory in the geometric structure of the network (response) is followed rather than in the parameter space. The fact that the dimension of the network most often is smaller than the parameter space is of advantage since calculation thereby is simplified. The response from the network forms the basis for distinguishing between apnea, hypoapnea and a normal breathing state and thus, for CPAP pressure control. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> The invention thus is based on the use of an artificial neural network (ANN) of Kohonen-map type (associative memory; T. Kohonen, Self-Organization and Associative Memory, 2<highlight><superscript>nd </superscript></highlight>Ed., Springer Verl., Berlin 1987) for detecting apnea or apnea-like episodes. The ANN is trained with data obtained from a number of patients in a sleep laboratory. The readily trained ANN forms a global (universal) structure of data stored in a non-volatile memory in an ACPAP. In use the breathing pattern of a patient forms trajectories (traces) in the ANN. A normal breathing cycle forms a closed trajectory. A trajectory deviating from normal is indicative of a breath disturbance. The ANN is structured in way so as to make certain areas represent initial stages of apnea. The passage of a trajectory through such an area or touching its border indicates that the amount of air provided to the patient should be increased so as to re-establish normal breathing. Once breathing has been normalized the adduced amount of air is reduced to normal, i.e., to the pre-established base value. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> The artificial neural network is trained in two phases described in P. Brauer and P. Knagenhjelm, Infrastructure in Kohonen Maps, Proc. IEEE ICASSP, Glasgow 1989. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> The purpose of the analysis is to extract, from the series of air flow rate measurements, values of the parameters chosen to classify and detect apneic and hypoapneic states. In each single analysis the parameters are made to form an incident or feature vector on which all training and decision-making is based. All sample values are individually analyzed in preparation for a quick response to changes in flow which are typical forewarnings of an apneic or hypoapneic state. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> According to a third preferred aspect of the invention linear predictive coding is used to analyze the parameter values fed to the neural network. A linear predictive coding analysis comprising four parameters is carried out for all samples. In particular, the so-called A-parameters from the analysis are converted to cepstrum parameters for optimal correlation between parameter distance and conceptual distance, that is, so-called associativity. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> According to a fourth preferred aspect of the invention the prediction error in calculating linear predictive coding is used as a basis for the parameter next in line. The error is filtered to counteract short-term variations and normalized with the total energy of the analytical window. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> For calculations of energy a larger window than for the linear predictive coding analysis is used. The energy of the latest windows can be used to calculate a line the inclination which describes a trend. The difference in trend is used as a further parameter. Thus, according to a fifth preferred aspect of the invention, the inclination of a trend line calculated from measurements and is used as a parameter. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> According to the present invention is also disclosed an apparatus for the detection and treatment of disordered breathing during sleep for use with a CPAP, the apparatus including a probe for sampling breathing air flow data, in particular on inhalation, and an artificial neural network for analyzing, directly or indirectly, said data to control breathing air pressure. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> According to the present invention is also disclosed a CAPAP comprising a probe for sampling breathing air flow data, in particular on inhalation, and an artificial neural network for analyzing, directly or indirectly, said data to control breathing air pressure. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> Further variations of the present invention are disclosed in the following detailed description of a preferred embodiment thereof illustrated in a drawing. </paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">DESCRIPTION OF THE DRAWING </heading>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> The invention is illustrated by a drawing comprising several figures, showing: </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> depicts a block diagram regarding parameter extraction; </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> depicts a feature map response in regard of example 3; </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> depicts a feature vector; </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> depicts a feature map response in regard of example 4.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DESCRIPTION OF A PREFERRED EMBODIMENT </heading>
</section>
<section>
<heading lvl="1">EXAMPLE 1 </heading>
</section>
<section>
<heading lvl="1">General </heading>
<paragraph id="P-0039" lvl="7"><number>&lsqb;0039&rsqb;</number> Primary Data Analysis. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> The purpose of the analysis is to extract, from the series of air flow rate measurements, values of the parameters chosen to classify and detect apneic and hypoapneic states. In each single analysis the parameters are made to form an incident or feature vector on which all training and decision-making is based. All sample values are individually analyzed in preparation for a quick response to changes in flow which are typical forewarnings of an apneic or hypoapneic state. </paragraph>
<paragraph id="P-0041" lvl="7"><number>&lsqb;0041&rsqb;</number> Incident Vector Parameters. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> LPC-Cepstrum. For each sample a Linear Predictive Coding (LPC) four-parameter analysis is carried out. The so-called A-parameters from the analysis are converted to cepstrum parameters for optimal correlation between parameter distance and conceptual distance, that is, associativity. The term cepstrum introduced by Bogert et al. in connection with echo time series analysis designates the inverse Fourier transform of the logarithm of the power spectrum of a signal. The transformation of a signal into its cepstrum is a homo-morphic transformation, see A. V. Oppenheim and R. W. Schafer, Discrete-Time Signal Processing, Prentice Hall, Englewood Cliffs, N.J., 1989. Residual. The error of prediction in calculating LPC is used as a basis for the following parameter. The error is filtered to oppose short-term variations, and is normalized with the total energy for the analytical window. Energy slope. For calculations of energy larger windows are used than for LPC analysis. The energy at the most recent windows is used to calculate a line the slope of which describes a trend. Difference in trend. The difference in trend is used as a further parameter. </paragraph>
<paragraph id="P-0043" lvl="7"><number>&lsqb;0043&rsqb;</number> Parameters. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> To detect an apneic event (i.e. central/obstructive apnea, hypoapnea, and flow limitations) a model is used to characterize typical qualities and features of the flow-signal during the event. The parameters of the model is chosen with the aim to be as distinct, unambiguous, and informative as possible. The set of parameters shall respond to typical apneic events that are readily detected by physicians. In addition to be sensitive to apneic events, it is important that the parameters shall be insensitive to features irrelevant to the task of detecting apneic events. </paragraph>
<paragraph id="P-0045" lvl="7"><number>&lsqb;0045&rsqb;</number> The Feature Vector. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> The values of the parameters are compiled to form a vector, below named the Feature Vector. Each time the flow-signal is measured (sampled), the values of the Feature Vector are extracted. This means that if the flow signal is measured &fnof;<highlight><subscript>s </subscript></highlight>times per second, and N parameter values are needed in the model, the data rate is increased from &fnof;<highlight><subscript>s </subscript></highlight>to N&middot;&fnof;<highlight><subscript>s </subscript></highlight>samples per second. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> Prior to the extraction of parameter values, the flow signal is differentiated (high-pass filtered) to avoid the influence of the mean signal value. The mean will vary with patients and/or hardware and do not contribute in the classification of apneic events, and is therefore removed. Each N-dimensional Feature Vector can be regarded as one point in a N-dimensional signal space. </paragraph>
<paragraph id="P-0048" lvl="7"><number>&lsqb;0048&rsqb;</number> Training the Network. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> An Artificial Neural Network (ANN) is iteratively trained to organize groups or clusters of Feature Vectors with similar properties. The self organizing process known as Kohonen&apos;s Self-Organizing Feature Map &lsqb;1-2&rsqb; has shown great capability of performing this task. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> The number of clusters is defined prior to the training and is determined by the required resolution of the ANN. The training is initiated by a set of M clusters, randomly positioned in the N-dimensional signal space. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> The database used for training is formed by compiling the Feature Vectors from a large number of patients with various sleep disorders and at all stages of sleep. During the training, each input Feature Vector is compared to each cluster to find the one with best resemblance to the input vector. This cluster is voted winner, and is adjusted towards the input vector. In addition, all other clusters within a neighborhood to the winner in another domain, the so-called map-space are adjusted towards the input vector. The map-space is usually of low dimension containing one node for each cluster in the signal-space. The nodes are arranged in hexagonal or a square lattice, and the Euclidian distance between them defines their internal relation. A node&apos;s neighborhood is usually defined by a neighborhood function and contains the set all nodes in the beginning of the training whereas only a few (or none) are considered neighbors at the end. The further away a node is to the winner in the map-space, the less the corresponding cluster in the signal-space is adjusted towards the input vector. Thus all adjustments are done in the signal space, while the rules of adjustments are defined in the map-space. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> The training time is predetermined, and an annealing function is used to &ldquo;freeze&rdquo; down the system causing only small adjustments at the end of the training. The neighborhood function creates correlation between the signal-space distance and the map-space distance allowing classification to be performed in the (low dimensional) map-space, rather than in the more complicated signal-space. The method described above is known as &ldquo;unsupervised learning&rdquo;, i.e. there is no need to use classified data in the training procedure described above. Classification of data into various apneic events is a tedious task. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> When the ANN is readily trained, the clusters will represent M features of the input flow signal including normal breathing, hypoapnea, flow-limitations, and apnea (provided these features are represented in the database used for training). The response of the ANN is proportional to the signal distance between the input signal and all the clusters. See <cross-reference target="DRAWINGS">FIG. 2</cross-reference>. Often this output is of less interest in the case of classification. The output is instead used to find the node with best resemblance to a classified input, such as normal breathing and apneic events. This is known as the labeling phase in the design of the ANN. Classified Feature Vectors are presented for the ANN, the output is observed, and the node giving the highest output is labeled with the presented feature. The actual output thereafter is the label rather than the response value. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> The set of clusters are now stored in the memory of the APAP to be used in runtime mode. Patient flow-data is analyzed exactly the same way as done in the training phase to extract the values of the parameters used in the model i.e. the Feature Vector. The vector is then presented to the network that will produce the output label (classification) which is used by the flow-control logic. </paragraph>
</section>
<section>
<heading lvl="1">EXAMPLE 2 </heading>
</section>
<section>
<heading lvl="1">Algorithm </heading>
<paragraph id="P-0055" lvl="7"><number>&lsqb;0055&rsqb;</number> Data Acquisition. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> Let the flow signal be a digitized version of the analog flow-signal sampled at &fnof;<highlight><subscript>s </subscript></highlight>samples/second, giving a sequence of samples </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>x</italic></highlight><highlight><subscript>i</subscript></highlight><highlight><italic>, i&equals;</italic></highlight>0,1, . . . , </in-line-formula></paragraph>
<paragraph id="P-0057" lvl="7"><number>&lsqb;0057&rsqb;</number> where x<highlight><subscript>i </subscript></highlight>is short for x(i&middot;T) i.e. the sample at time instant i&middot;T and </paragraph>
<paragraph id="P-0058" lvl="7"><number>&lsqb;0058&rsqb;</number> Preprocessing. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> To reduce the influence of individual patient variations and to facilitate classification stability, the signal should pass a device to remove the signal mean. Any kind of steep edge high pass filter can be employed, thus the ideal differentiator is used for simplicity. The output from the differentiator, d, (and the input to the parameter extractor) will then be </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>d</italic></highlight><highlight><subscript>i</subscript></highlight><highlight><italic>&equals;x</italic></highlight><highlight><subscript>i</subscript></highlight><highlight><italic>&minus;x</italic></highlight><highlight><subscript>i&minus;1 </subscript></highlight></in-line-formula></paragraph>
<paragraph id="P-0060" lvl="7"><number>&lsqb;0060&rsqb;</number> where i&equals;0,1, . . . , and x<highlight><subscript>&minus;1</subscript></highlight>&equiv;0 </paragraph>
<paragraph id="P-0061" lvl="7"><number>&lsqb;0061&rsqb;</number> Parameters. </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> The cepstrum coefficients have shown to well model the frequency content of the signal using only a few parameters (low order model). In addition, the dynamics of the cepstrum coefficients facilitate quantization of the parameters. Often the parameters are weighted to produce parameters with similar variances. The cepstrum coefficients are derivatives of the so called A-polynomial calculated by standard Linear Predictive Coding (LPC). </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> As the cepstrum coefficients used do not hold information about the signal energy, the cepstrum will be augmented with a parameter to account for the long term (say 10 seconds) energy variations. This parameter shall be insensitive to the absolute level of the flow signal and only reflect the relative fluctuations. </paragraph>
<paragraph id="P-0064" lvl="7"><number>&lsqb;0064&rsqb;</number> Cepstrum. </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> To calculate P model parameters at time k, the last Wz input samples are used (windowing). The sample, d<highlight><subscript>k</subscript></highlight>, is predicted to be  
<math-cwu id="MATH-US-00001">
<number>1</number>
<math>
<mrow>
  <msub>
    <mover>
      <mi>d</mi>
      <mo>~</mo>
    </mover>
    <mi>k</mi>
  </msub>
  <mo>=</mo>
  <mrow>
    <mo>-</mo>
    <mrow>
      <munderover>
        <mo>&Sum;</mo>
        <mrow>
          <mi>l</mi>
          <mo>=</mo>
          <mn>1</mn>
        </mrow>
        <mi>P</mi>
      </munderover>
      <mo>&it;</mo>
      <mrow>
        <msub>
          <mi>a</mi>
          <mi>l</mi>
        </msub>
        <mo>&CenterDot;</mo>
        <mrow>
          <msub>
            <mi>d</mi>
            <mrow>
              <mi>k</mi>
              <mo>-</mo>
              <mi>l</mi>
            </mrow>
          </msub>
          <mo>.</mo>
        </mrow>
      </mrow>
    </mrow>
  </mrow>
</mrow>
</math>
<mathematica-file id="MATHEMATICA-00001" file="US20030000528A1-20030102-M00001.NB"/>
<image id="EMI-M00001" wi="216.027" he="24.97635" file="US20030000528A1-20030102-M00001.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> Thus the prediction error signal is  
<math-cwu id="MATH-US-00002">
<number>2</number>
<math>
<mrow>
  <msub>
    <mi>e</mi>
    <mi>k</mi>
  </msub>
  <mo>=</mo>
  <mrow>
    <mrow>
      <msub>
        <mi>d</mi>
        <mi>k</mi>
      </msub>
      <mo>-</mo>
      <msub>
        <mover>
          <mi>d</mi>
          <mo>~</mo>
        </mover>
        <mi>k</mi>
      </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
      <mo>-</mo>
      <mrow>
        <munderover>
          <mo>&Sum;</mo>
          <mrow>
            <mi>l</mi>
            <mo>=</mo>
            <mn>1</mn>
          </mrow>
          <mi>P</mi>
        </munderover>
        <mo>&it;</mo>
        <mrow>
          <msub>
            <mi>a</mi>
            <mi>l</mi>
          </msub>
          <mo>&CenterDot;</mo>
          <mrow>
            <msub>
              <mi>d</mi>
              <mrow>
                <mi>k</mi>
                <mo>-</mo>
                <mi>l</mi>
              </mrow>
            </msub>
            <mo>.</mo>
          </mrow>
        </mrow>
      </mrow>
    </mrow>
  </mrow>
</mrow>
</math>
<mathematica-file id="MATHEMATICA-00002" file="US20030000528A1-20030102-M00002.NB"/>
<image id="EMI-M00002" wi="216.027" he="24.97635" file="US20030000528A1-20030102-M00002.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> The task is to find the set, a, which minimizes the energy of the prediction error signal (i.e. finding the values of a&equals;&lsqb;a<highlight><subscript>1</subscript></highlight>, . . . , a<highlight><subscript>P</subscript></highlight>&rsqb; to make {tilde over (d)}<highlight><subscript>k </subscript></highlight>as similar to d<highlight><subscript>k </subscript></highlight>as possible) over all samples within the window. The optimal solution is found solving the matrix equation </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>R&middot;a&equals;&minus;r </italic></highlight></in-line-formula></paragraph>
<paragraph id="P-0068" lvl="7"><number>&lsqb;0068&rsqb;</number> known as the Yule-Walker or normal equation, using for instance the Cholesky algorithm. </paragraph>
<paragraph id="P-0069" lvl="0"><number>&lsqb;0069&rsqb;</number> The vector a constitutes the so called A-polynomial which is transformed into a set of cepstrum coefficients c using the following algorithm:  
<math-cwu id="MATH-US-00003">
<number>3</number>
<math>
  <mrow>
    <msub>
      <mi>c</mi>
      <mn>0</mn>
    </msub>
    <mo>=</mo>
    <mn>0</mn>
  </mrow>
</math>
<math>
  <mrow>
    <msub>
      <mi>c</mi>
      <mn>1</mn>
    </msub>
    <mo>=</mo>
    <msub>
      <mi>a</mi>
      <mn>1</mn>
    </msub>
  </mrow>
</math>
<math>
  <mrow>
    <mrow>
      <msub>
        <mi>c</mi>
        <mi>n</mi>
      </msub>
      <mo>=</mo>
      <mrow>
        <mrow>
          <msub>
            <mi>a</mi>
            <mi>n</mi>
          </msub>
          <mo>-</mo>
          <mrow>
            <munderover>
              <mo>&Sum;</mo>
              <mrow>
                <mi>l</mi>
                <mo>=</mo>
                <mn>1</mn>
              </mrow>
              <mi>P</mi>
            </munderover>
            <mo>&it;</mo>
            <mrow>
              <mrow>
                <mfrac>
                  <mrow>
                    <mi>n</mi>
                    <mo>-</mo>
                    <mi>l</mi>
                  </mrow>
                  <mi>n</mi>
                </mfrac>
                <mo>&CenterDot;</mo>
                <msub>
                  <mi>c</mi>
                  <mrow>
                    <mi>n</mi>
                    <mo>-</mo>
                    <mi>l</mi>
                  </mrow>
                </msub>
                <mo>&CenterDot;</mo>
                <msub>
                  <mi>a</mi>
                  <mi>l</mi>
                </msub>
              </mrow>
              <mo>&it;</mo>
              <mstyle>
                <mtext>&emsp;</mtext>
              </mstyle>
              <mo>&it;</mo>
              <mi>n</mi>
            </mrow>
          </mrow>
        </mrow>
        <mo>=</mo>
        <mn>2</mn>
      </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
      <mi>&hellip;</mi>
      <mo>&it;</mo>
      <mstyle>
        <mtext>&emsp;</mtext>
      </mstyle>
      <mo>&it;</mo>
      <mi>P</mi>
    </mrow>
  </mrow>
</math>
<mathematica-file id="MATHEMATICA-00003" file="US20030000528A1-20030102-M00003.NB"/>
<image id="EMI-M00003" wi="216.027" he="47.99655" file="US20030000528A1-20030102-M00003.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0070" lvl="0"><number>&lsqb;0070&rsqb;</number> The cepstrum coefficients c<highlight><subscript>1</subscript></highlight>, . . . , c<highlight><subscript>P </subscript></highlight>are used as the p first coefficients in the Feature Vector. </paragraph>
<paragraph id="P-0071" lvl="7"><number>&lsqb;0071&rsqb;</number> Parameter of Energy Trend (PET). </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> The energy from a number of windows are used to calculate a trend for the energy values. If the trend indicates increasing energy levels, PET is set to zero. If the trend is decreasing, the point where the trend is crossing the time-axis is calculated. A non-linear transform of this value form the PET coefficient. HBK figure </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> The PET is added to the Feature Vector. The complete Feature Vector is thus composed according to <cross-reference target="DRAWINGS">FIG. 3</cross-reference>. </paragraph>
<paragraph id="P-0074" lvl="7"><number>&lsqb;0074&rsqb;</number> Feature Map Geometry and Definitions. </paragraph>
<paragraph id="P-0075" lvl="0"><number>&lsqb;0075&rsqb;</number> Let the Mmap nodes be denoted </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>m</italic></highlight><highlight><subscript>i</subscript></highlight><highlight><italic>, i&equals;</italic></highlight>0<highlight><italic>, . . . , M&minus;</italic></highlight>1. </in-line-formula></paragraph>
<paragraph id="P-0076" lvl="0"><number>&lsqb;0076&rsqb;</number> Most often the nodes are arranged in a square (2-dimensional) grid. The distance between two map nodes i and j, is denoted D<highlight><subscript>i,j </subscript></highlight>and defined as the squared Euclidian distance (L<highlight><superscript>2 </superscript></highlight>norm) between them </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>D</italic></highlight><highlight><subscript>i,j</subscript></highlight><highlight><italic>&equals;L</italic></highlight><highlight><superscript>2</superscript></highlight>(<highlight><italic>m</italic></highlight><highlight><subscript>i</subscript></highlight><highlight><italic>,m</italic></highlight><highlight><subscript>j</subscript></highlight>). </in-line-formula></paragraph>
<paragraph id="P-0077" lvl="0"><number>&lsqb;0077&rsqb;</number> Let the input Feature Vector representing sample x<highlight><subscript>k </subscript></highlight>be denoted y<highlight><subscript>k</subscript></highlight>. The map response in node i for feature k, S<highlight><subscript>ik</subscript></highlight>, is defined as:  
<math-cwu id="MATH-US-00004">
<number>4</number>
<math>
<mrow>
  <mrow>
    <msub>
      <mi>S</mi>
      <mi>ik</mi>
    </msub>
    <mo>=</mo>
    <mrow>
      <mi>exp</mi>
      <mo>&it;</mo>
      <mrow>
        <mo>{</mo>
        <mrow>
          <mrow>
            <mo>-</mo>
            <msubsup>
              <mi>d</mi>
              <mi>ik</mi>
              <mn>2</mn>
            </msubsup>
          </mrow>
          <mo>/</mo>
          <mrow>
            <mo>(</mo>
            <mrow>
              <mi>P</mi>
              <mo>+</mo>
              <mn>1</mn>
            </mrow>
            <mo>)</mo>
          </mrow>
        </mrow>
        <mo>}</mo>
      </mrow>
    </mrow>
  </mrow>
  <mo>,</mo>
</mrow>
</math>
<mathematica-file id="MATHEMATICA-00004" file="US20030000528A1-20030102-M00004.NB"/>
<image id="EMI-M00004" wi="216.027" he="11.02815" file="US20030000528A1-20030102-M00004.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0078" lvl="7"><number>&lsqb;0078&rsqb;</number> where the signal space distance d<highlight><subscript>ik</subscript></highlight><highlight><superscript>2 </superscript></highlight>is defined as  
<math-cwu id="MATH-US-00005">
<number>5</number>
<math>
<mrow>
  <msubsup>
    <mi>d</mi>
    <mi>ik</mi>
    <mn>2</mn>
  </msubsup>
  <mo>=</mo>
  <mrow>
    <munderover>
      <mo>&Sum;</mo>
      <mrow>
        <mi>l</mi>
        <mo>=</mo>
        <mn>1</mn>
      </mrow>
      <mrow>
        <mi>P</mi>
        <mo>+</mo>
        <mn>1</mn>
      </mrow>
    </munderover>
    <mo>&it;</mo>
    <msup>
      <mrow>
        <msub>
          <mi>w</mi>
          <mi>l</mi>
        </msub>
        <mo>&af;</mo>
        <mrow>
          <mo>(</mo>
          <mrow>
            <msubsup>
              <mi>y</mi>
              <mi>l</mi>
              <mi>k</mi>
            </msubsup>
            <mo>-</mo>
            <msubsup>
              <mi>m</mi>
              <mi>l</mi>
              <mi>i</mi>
            </msubsup>
          </mrow>
          <mo>)</mo>
        </mrow>
      </mrow>
      <mn>2</mn>
    </msup>
  </mrow>
</mrow>
</math>
<mathematica-file id="MATHEMATICA-00005" file="US20030000528A1-20030102-M00005.NB"/>
<image id="EMI-M00005" wi="216.027" he="24.97635" file="US20030000528A1-20030102-M00005.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0079" lvl="7"><number>&lsqb;0079&rsqb;</number> and w<highlight><subscript>1 </subscript></highlight>is some suitable weight function. </paragraph>
<paragraph id="P-0080" lvl="7"><number>&lsqb;0080&rsqb;</number> Annealing Function. </paragraph>
<paragraph id="P-0081" lvl="0"><number>&lsqb;0081&rsqb;</number> The task of the annealing function is to obtain an equilibrium at the end of the training. The principle is that large adjustments are allowed in the beginning of the training whereas only small (or zero) adjustments are allowed at the end. How the decrease incorporated is not critical. Linear, exponential, and even pulsating &lsqb;4&rsqb; decay schedules are proposed in the literature. </paragraph>
<paragraph id="P-0082" lvl="7"><number>&lsqb;0082&rsqb;</number> Initialization. </paragraph>
<paragraph id="P-0083" lvl="0"><number>&lsqb;0083&rsqb;</number> Traditionally, all data driven clustering schemes, including ANNs, employ random positioning of the clusters in the signal space, by assigning (small) random numbers to the parameters. The actual values are not important as long as they are not identical. The ordering of the clusters is also at random. </paragraph>
<paragraph id="P-0084" lvl="7"><number>&lsqb;0084&rsqb;</number> Training. </paragraph>
<paragraph id="P-0085" lvl="0"><number>&lsqb;0085&rsqb;</number> The iterative algorithm adjust all clusters after each input Feature Vector, y<highlight><subscript>k</subscript></highlight>, presented. The direction of the adjustment is towards y<highlight><subscript>k</subscript></highlight>, and how much is determined partly by the annealing function, partly by the neighborhood function. The adjustment formulae for cluster y<highlight><subscript>k </subscript></highlight>at time instant t&plus;1 is: </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>y</italic></highlight><highlight><subscript>k</subscript></highlight>(<highlight><italic>t&plus;</italic></highlight>1)<highlight><italic>y</italic></highlight><highlight><subscript>k</subscript></highlight>(<highlight><italic>t</italic></highlight>)&plus;&ggr;<highlight><subscript>k</subscript></highlight>&middot;(<highlight><italic>t</italic></highlight>)(<highlight><italic>z&minus;y</italic></highlight><highlight><subscript>k</subscript></highlight>(<highlight><italic>t</italic></highlight>)), </in-line-formula></paragraph>
<paragraph id="P-0086" lvl="7"><number>&lsqb;0086&rsqb;</number> where </paragraph>
<paragraph lvl="0"><in-line-formula>&ggr;<highlight><subscript>k</subscript></highlight>(<highlight><italic>t</italic></highlight>)&equals;&fnof;(<highlight><italic>t</italic></highlight>)&middot;<highlight><italic>g</italic></highlight><highlight><subscript>k</subscript></highlight>(<highlight><italic>t</italic></highlight>) </in-line-formula></paragraph>
<paragraph id="P-0087" lvl="7"><number>&lsqb;0087&rsqb;</number> and &fnof;(t) is the annealing function and g(t) is the neighborhood function. Various suitable functions are discussed in &lsqb;3&rsqb;. </paragraph>
</section>
<section>
<heading lvl="1">EXAMPLE 3 </heading>
</section>
<section>
<heading lvl="1">Hard Decision A </heading>
<paragraph id="P-0088" lvl="0"><number>&lsqb;0088&rsqb;</number> Let 64 map nodes be arranged in an 8&times;8 square grid and numbered 0 to 63 from the top left to the low right corner. Thus for example the map distance D<highlight><subscript>0,1</subscript></highlight>&equals;1, D<highlight><subscript>0,2</subscript></highlight>&equals;4 and D<highlight><subscript>0,9</subscript></highlight>&equals;2 . </paragraph>
<paragraph id="P-0089" lvl="0"><number>&lsqb;0089&rsqb;</number> A large database is recorded containing flow-measures from several patients during all phases of sleep. The recordings are performed at 20 Hz and stored on a memory disk. The database will contain normal sleep breathing, flow limitations, snoring, yawning, coughing, various apneic events, but also mask leakage and other artifacts. </paragraph>
<paragraph id="P-0090" lvl="0"><number>&lsqb;0090&rsqb;</number> The database is analyzed sample for sample. The 20 Hz flow-signal is first passed through an ideal differentiator. A rectangular window of 180 samples is used to form basis for extracting 4 cepstrum coefficients (c<highlight><subscript>1</subscript></highlight>, . . . , c<highlight><subscript>4</subscript></highlight>) and the PET parameter. Thus the Feature Vector is a 5-dimensional vector with values extracted every 50 ms. </paragraph>
<paragraph id="P-0091" lvl="0"><number>&lsqb;0091&rsqb;</number> Samples are collected from the database in a random manner as long as the training proceed. The number of iterations, T, is determined by the size of the database, but as a rule of thumb, 10-30 iterations per sample may be an adequate number. </paragraph>
<paragraph id="P-0092" lvl="0"><number>&lsqb;0092&rsqb;</number> The Euclidian distance to all clusters y<highlight><subscript>i </subscript></highlight>i&equals;0, . . . , M&minus;1 are calculated and the cluster closest to the Feature Vector is voted winner and is denoted y<highlight><subscript>1</subscript></highlight>. </paragraph>
<paragraph id="P-0093" lvl="0"><number>&lsqb;0093&rsqb;</number> In calculating the distance, the following weight function is employed: </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>w&equals;&lsqb;</italic></highlight>1 2 3 4 1&rsqb;</in-line-formula></paragraph>
<paragraph id="P-0094" lvl="0"><number>&lsqb;0094&rsqb;</number> The neighborhood function will allow all clusters to be adjusted at all times (i.e. the size of neighborhood is not decreased in time), but will penalize clusters far away from the winner y<highlight><subscript>1</subscript></highlight>. </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>g</italic></highlight>(<highlight><italic>t</italic></highlight>)&equals;<highlight><italic>e</italic></highlight><highlight><superscript>&minus;2&middot;D</superscript></highlight><highlight><superscript><highlight><subscript>kI</subscript></highlight></superscript></highlight><highlight><italic>, &forall;t </italic></highlight></in-line-formula></paragraph>
<paragraph id="P-0095" lvl="0"><number>&lsqb;0095&rsqb;</number> The annealing function, &fnof;(t), follows a linear decay schedule </paragraph>
<paragraph lvl="0"><in-line-formula>&fnof;(<highlight><italic>t</italic></highlight>)&equals;0.2&middot;(1&minus;<highlight><italic>t/T</italic></highlight>)<highlight><italic>t&equals;</italic></highlight>0, . . . , <highlight><italic>T </italic></highlight></in-line-formula></paragraph>
<paragraph id="P-0096" lvl="0"><number>&lsqb;0096&rsqb;</number> After the training phase, the map is presented with known features such as normal breathing, flow limitation signals etc. For each event the response, S, in each node of the map is calculated (see, <cross-reference target="DRAWINGS">FIG. 2</cross-reference>). </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>S</italic></highlight><highlight><subscript>ik</subscript></highlight>&equals;exp(&minus;<highlight><italic>d</italic></highlight><highlight><subscript>ik</subscript></highlight><highlight><superscript>2</superscript></highlight><highlight><italic>/P), </italic></highlight></in-line-formula></paragraph>
<paragraph id="P-0097" lvl="0"><number>&lsqb;0097&rsqb;</number> Regions with high response for normal breathing are labeled as normal regions; regions reacting for flow-limitations are labeled as flow-limitation area and so forth. </paragraph>
<paragraph id="P-0098" lvl="0"><number>&lsqb;0098&rsqb;</number> It is then decided which nodes that shall represent events needed to respond to; i.e. an alarm signal is passed to the pressure control system. In <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, the map response to an input corresponding to flow limitations is depicted. In this case, nodes X,Y,Z will probably be labeled as a flow limitation region. </paragraph>
</section>
<section>
<heading lvl="1">EXAMPLE 4 </heading>
</section>
<section>
<heading lvl="1">Hard Decision B </heading>
<paragraph id="P-0099" lvl="0"><number>&lsqb;0099&rsqb;</number> This example is similar to the one described in example 1, but here a Hamming window of 180 samples is used instead of the rectangular. Furthermore the cepstrum coefficients are weighted to have approximately the same variances, whereas the PET parameter is given twice the variance of the cepstrum. This will give the PET parameter a little more importance than the rest of the parameters. The following weight function is employed: </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>w&equals;&lsqb;</italic></highlight>1 1.41 1.5 4 2&rsqb;</in-line-formula></paragraph>
<paragraph id="P-0100" lvl="0"><number>&lsqb;0100&rsqb;</number> The training is carried out exactly ass before, and the map response for a typical flow-limitation signal is shown in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>. In this case, nodes X,Y,Z will probably be labeled as a flow limitation region. </paragraph>
</section>
<section>
<heading lvl="1">EXAMPLE 5 </heading>
</section>
<section>
<heading lvl="1">Soft Decision </heading>
<paragraph id="P-0101" lvl="0"><number>&lsqb;0101&rsqb;</number> In this example, the map nodes are given a number 0, 2, 5, or 10 as labels to indicate the seriousness of the classification result. Thus instead of presenting an alarm signal on/off to the pressure control system, the number is passed on. If for instance 0 reflects normal regions and 10 reflects apnea, the numbers can be integrated to form an overall breathing status classification. If the level is very high, rapid increases in pressure is allowed, low levels allow for a pressure decrease, and intermediate levels result in a slow increase of the pressure. </paragraph>
</section>
<section>
<heading lvl="1">EXAMPLE 6 </heading>
</section>
<section>
<heading lvl="1">Down Sampling </heading>
<paragraph id="P-0102" lvl="0"><number>&lsqb;0102&rsqb;</number> If the capacity of the processor do not allow for all calculations described above, the LPC calculation can be decimated by a factor two or four. The number of samples within the analysis window must then be reduced so that the time span of the window is still about two breathing cycles. The resolution of the map response will not suffer from this. </paragraph>
</section>
<section>
<heading lvl="1">EXAMPLE 7 </heading>
</section>
<section>
<heading lvl="1">Pressure Regulation and Runtime Mode </heading>
<paragraph id="P-0103" lvl="0"><number>&lsqb;0103&rsqb;</number> The pressure control system will increase the pressure one step of 0.125 mbar if the ANN response is positive for 50 samples in one sequence. The pressure will decrease with one step of 0.125 mbar if the ANN response is negative for 300 samples in one sequence. The pressure will not be changed if the ANN response is changed during those sequences. </paragraph>
<paragraph id="P-0104" lvl="0"><number>&lsqb;0104&rsqb;</number> In a runtime mode, a sample of the flow signal is analyzed as described above (i.e. extracting the Feature Vector), and presented to the map, now stored in a memory bank in the APAP-unit. There is no need to calculate the exponent in the expression for map response, as the function is monotonic.  
<table-cwu id="TABLE-US-00001">
<number>1</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center">EXAMPLE 8</entry>
</row>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Program Code</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>// function ann_detect</entry>
</row>
<row>
<entry></entry>
<entry>// COPYRIGHT (TC) 2000 PePe Research</entry>
</row>
<row>
<entry></entry>
<entry>// GOTHEBORGH, SWEDEN.</entry>
</row>
<row>
<entry></entry>
<entry>&num;include &lt;stdio.h&gt;</entry>
</row>
<row>
<entry></entry>
<entry>&num;include &ldquo;ann_detect.h&rdquo;</entry>
</row>
<row>
<entry></entry>
<entry>&num;include &ldquo;apne_func.h&rdquo;</entry>
</row>
<row>
<entry></entry>
<entry>int ann_detect(const float new_sample) &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>float corr&lsqb;10&rsqb;;</entry>
</row>
<row>
<entry></entry>
<entry>int ana_dim &equals; 5;</entry>
</row>
<row>
<entry></entry>
<entry>int win &equals; 180;</entry>
</row>
<row>
<entry></entry>
<entry>float apol&lsqb;5&rsqb;;</entry>
</row>
<row>
<entry></entry>
<entry>float alpha;</entry>
</row>
<row>
<entry></entry>
<entry>float dvec&lsqb;5&rsqb;;</entry>
</row>
<row>
<entry></entry>
<entry>int respx, respy;</entry>
</row>
<row>
<entry></entry>
<entry>int resp_en, resp_ann;</entry>
</row>
<row>
<entry></entry>
<entry>calc_corr(new_sample, win, ana_dim&plus;1, corr);</entry>
</row>
<row>
<entry></entry>
<entry>/* Check levels, and slope */</entry>
</row>
<row>
<entry></entry>
<entry>resp_en &equals; reg_r0(corr&lsqb;0&rsqb;, &amp;dvec&lsqb;4&rsqb;);</entry>
</row>
<row>
<entry></entry>
<entry>lpc(corr, ana_dim, apol, &amp;alpha);</entry>
</row>
<row>
<entry></entry>
<entry>a2cep(apol, ana_dim, dvec);</entry>
</row>
<row>
<entry></entry>
<entry>dvec &lsqb;1&rsqb; *&equals; 1.41;</entry>
</row>
<row>
<entry></entry>
<entry>dvec &lsqb;2&rsqb; *&equals; 1.5;</entry>
</row>
<row>
<entry></entry>
<entry>dvec &lsqb;3&rsqb; *&equals; 4;</entry>
</row>
<row>
<entry></entry>
<entry>dvec &lsqb;4&rsqb; *&equals; 2;</entry>
</row>
<row>
<entry></entry>
<entry>map_resp(dvec, ana_dim, &amp;respx, &amp;respy);</entry>
</row>
<row>
<entry></entry>
<entry>resp_ann &equals; apne_dec(respx, respy);</entry>
</row>
<row>
<entry></entry>
<entry>if ( resp_ann &equals;&equals; 1 &verbar;&verbar; resp_en &equals;&equals; 1 )</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="70PT" align="left"/>
<colspec colname="1" colwidth="147PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>return 1;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>return 0;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>// functions for apne detection</entry>
</row>
<row>
<entry></entry>
<entry>//</entry>
</row>
<row>
<entry></entry>
<entry>// COPYRIGHT (C) 2000 PePe Research</entry>
</row>
<row>
<entry></entry>
<entry>// GOTHEBORGH, SWEDEN.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="84PT" align="left"/>
<colspec colname="2" colwidth="119PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&num;define MAP_DIM_X</entry>
<entry>8</entry>
</row>
<row>
<entry></entry>
<entry>&num;define MAP_DIM_Y</entry>
<entry>8</entry>
</row>
<row>
<entry></entry>
<entry>&num;define MAP_SIZE</entry>
<entry>64</entry>
</row>
<row>
<entry></entry>
<entry>&num;define DATA_DIM</entry>
<entry>5</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="105PT" align="left"/>
<colspec colname="2" colwidth="98PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&num;define NHEAD</entry>
<entry>256</entry>
</row>
<row>
<entry></entry>
<entry>&num;define NMB_SAVE</entry>
<entry>100</entry>
</row>
<row>
<entry></entry>
<entry>&num;define MaxR0</entry>
<entry>180</entry>
</row>
<row>
<entry></entry>
<entry>&num;define MaxR0_</entry>
<entry>2 90</entry>
</row>
<row>
<entry></entry>
<entry>&num;define SLOPE</entry>
<entry>0.006</entry>
</row>
<row>
<entry></entry>
<entry>&num;include &lt;stdio.h&gt;</entry>
</row>
<row>
<entry></entry>
<entry>&num;include &lt;math.h&gt;</entry>
</row>
<row>
<entry></entry>
<entry>&num;include &ldquo;map.h&rdquo;</entry>
</row>
<row>
<entry></entry>
<entry>&num;include &ldquo;annpar.h&rdquo;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>float distance ( const float *x const float *y int d )</entry>
</row>
<row>
<entry>&lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>int i;</entry>
</row>
<row>
<entry></entry>
<entry>float dist, t;</entry>
</row>
<row>
<entry></entry>
<entry>t &equals; &times;&lsqb;0&rsqb;&minus;y&lsqb;0&rsqb;;</entry>
</row>
<row>
<entry></entry>
<entry>dist &equals; t*t;</entry>
</row>
<row>
<entry></entry>
<entry>for ( i&equals;1; i&lt;d; i&plus;&plus;) &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>t &equals; &times;&lsqb;i&rsqb;&minus;y&lsqb;i&rsqb;;</entry>
</row>
<row>
<entry></entry>
<entry>dist &plus;&equals; t*t;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>return dist;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>void calc_corr(float const rec_sample, int const win, int const</entry>
</row>
<row>
<entry></entry>
<entry>ana_dim, float* corr)</entry>
</row>
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>static float&emsp;&emsp;samp_win&lsqb;180&rsqb;;</entry>
</row>
<row>
<entry></entry>
<entry>static int first &equals; 0;</entry>
</row>
<row>
<entry></entry>
<entry>static float prev_sample&equals;0;</entry>
</row>
<row>
<entry></entry>
<entry>float diff;</entry>
</row>
<row>
<entry></entry>
<entry>int i,j;</entry>
</row>
<row>
<entry></entry>
<entry>/* calc diff of new and prev sample */</entry>
</row>
<row>
<entry></entry>
<entry>diff &equals; rec_sample &minus; prev_sample;</entry>
</row>
<row>
<entry></entry>
<entry>prev_sample &equals; rec_sample;</entry>
</row>
<row>
<entry></entry>
<entry>/* Insert new sample first move all the other */</entry>
</row>
<row>
<entry></entry>
<entry>for ( i&equals;win&minus;1; i &gt; 0; i-- ) &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>samp_win&lsqb;i&rsqb; &equals; samp_win&lsqb;i&minus;1&rsqb;;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>samp_win&lsqb;0&rsqb; &equals; diff;</entry>
</row>
<row>
<entry></entry>
<entry>for( j &equals; 0;j &lt; ana_dim; j&plus;&plus;)&lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>corr&lsqb;j&rsqb; &equals;&equals; 0</entry>
</row>
<row>
<entry></entry>
<entry>for (i &equals; 0; i &lt; win&minus;j; i&plus;&plus;)&lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>corr&lsqb;j&rsqb; &plus;&equals; samp_win&lsqb;i&plus;j&rsqb;;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>/* Add an offset to avoid near /0 operations */</entry>
</row>
<row>
<entry></entry>
<entry>corr&lsqb;0&rsqb; &plus;&equals;1;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>int reg_r0(float cur_r0)</entry>
</row>
<row>
<entry></entry>
<entry>&lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>static float rf&lsqb;MaxR0&rsqb;;</entry>
</row>
<row>
<entry></entry>
<entry>static int first &equals; 1;</entry>
</row>
<row>
<entry></entry>
<entry>static int index &equals; 0;</entry>
</row>
<row>
<entry></entry>
<entry>int i;</entry>
</row>
<row>
<entry></entry>
<entry>static float prev_r0 &equals; 0;</entry>
</row>
<row>
<entry></entry>
<entry>float k,m, rf0, dec;</entry>
</row>
<row>
<entry></entry>
<entry>rf0 &equals; 0.9*prev_r0 &plus; 0.1*cur_r0</entry>
</row>
<row>
<entry></entry>
<entry>prev_r0 &equals; rf0;</entry>
</row>
<row>
<entry></entry>
<entry>k &equals; 0.5*(rf0 &minus; rf&lsqb;MaxR0&minus;1&rsqb;);</entry>
</row>
<row>
<entry></entry>
<entry>m &equals; (rf0 &plus; rf&lsqb;MaxR0/2&rsqb; &plus; rf&lsqb;MaxR0&minus;1&rsqb;)/3.;</entry>
</row>
<row>
<entry></entry>
<entry>/*update the saved old values */</entry>
</row>
<row>
<entry></entry>
<entry>for ( i&equals;MaxR0&minus;1; i &gt; 0; i-- ) &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>rf&lsqb;i&rsqb; &equals; rf&lsqb;i&minus;1&rsqb;;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>rf&lsqb;0&rsqb; &equals; rf0;</entry>
</row>
<row>
<entry></entry>
<entry>/* second rule check the regression line */</entry>
</row>
<row>
<entry></entry>
<entry>if (k &gt; &minus;1)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>dec &equals; 1000;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>else</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>dec &equals; &minus;MaxR0_2*((m/k)&plus;1);</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>*out &equals; exp(&minus;SLOPE*dec);</entry>
</row>
<row>
<entry></entry>
<entry>/* first rule, if energy less then 15 make alarm */</entry>
</row>
<row>
<entry></entry>
<entry>if (cur_r0 &lt; 15 )&lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>return 1;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>/* second rule, if regression line crosses zero line too soon make</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>alarm */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>if ( dec &lt; 50 )&lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>return 1;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>return 0;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>void lpc(float* const acf, int const ana_dim, float* aCoeffs, float*</entry>
</row>
<row>
<entry></entry>
<entry>alpha)</entry>
</row>
<row>
<entry></entry>
<entry>&lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>float err;</entry>
</row>
<row>
<entry></entry>
<entry>int i j;</entry>
</row>
<row>
<entry></entry>
<entry>float refls&lsqb;5&rsqb;;</entry>
</row>
<row>
<entry></entry>
<entry>float sum, refl, tmp;</entry>
</row>
<row>
<entry></entry>
<entry>err &equals; acf&lsqb;0&rsqb;;</entry>
</row>
<row>
<entry></entry>
<entry>for (i &equals; 0; i &lt; ana_dim; i&plus;&plus;) &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>if (err &lt;&equals; 0) &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>refls&lsqb;i&rsqb; &equals; 0;</entry>
</row>
<row>
<entry></entry>
<entry>aCoeffs&lsqb;i&rsqb; &equals; 0;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub; else &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>sum &equals; 0;</entry>
</row>
<row>
<entry></entry>
<entry>for (j &equals; 0; j &lt; i;j&plus;&plus;)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="70PT" align="left"/>
<colspec colname="1" colwidth="147PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>sum &plus;&equals; aCoeffs&lsqb;j&rsqb; * acf&lsqb;i &minus; j&rsqb;;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>refl &equals; (acf&lsqb;i &plus;1&rsqb; &minus; sum) / err;</entry>
</row>
<row>
<entry></entry>
<entry>refls&lsqb;i&rsqb; &equals; refl;</entry>
</row>
<row>
<entry></entry>
<entry>for (j &equals; 0; j &lt; i / 2; j&plus;&plus;) &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="70PT" align="left"/>
<colspec colname="1" colwidth="147PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>tmp &equals; aCoeffs&lsqb;j&rsqb;;</entry>
</row>
<row>
<entry></entry>
<entry>aCoeffs&lsqb;j&rsqb; &minus;&equals; refl* aCoeffs&lsqb;i &minus; j &minus; 1&rsqb;;</entry>
</row>
<row>
<entry></entry>
<entry>aCoeffs &lsqb;i &minus; j &minus; 1&rsqb; &minus;&equals; refl * tmp;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>if (i &amp; 1)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="70PT" align="left"/>
<colspec colname="1" colwidth="147PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>aCoeffs&lsqb;i / 2&rsqb; &minus;&equals;refl * aCoeffs&lsqb;i / 2&rsqb;;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>aCoeffs&lsqb;i&rsqb; &equals; refi;</entry>
</row>
<row>
<entry></entry>
<entry>err *&equals; i &minus; refl * refl;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>for (i &equals; 0 i &lt; ana_dim; i&plus;&plus;) &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>aCoefs&lsqb;i&rsqb; &equals; &minus;aCoeffs&lsqb;i&rsqb;;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>*alpha &equals; sqrt(err);</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>void a2cep(float* const a, int const ana_dim, float* cep)</entry>
</row>
<row>
<entry></entry>
<entry>&lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>int l, j, ind;</entry>
</row>
<row>
<entry></entry>
<entry>float sum;</entry>
</row>
<row>
<entry></entry>
<entry>cep &lsqb;0&rsqb;&equals; &minus;1*&lsqb;0&rsqb;;</entry>
</row>
<row>
<entry></entry>
<entry>for (l&equals; 2; l &lt; ana_dim&plus;1; l&plus;&plus;) &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>sum &equals; l*a&lsqb;l&minus;1&rsqb;;</entry>
</row>
<row>
<entry></entry>
<entry>for (j&equals;2; j &lt;&equals; l; j&plus;&plus;) &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>ind &equals; l&minus;j&plus;1;</entry>
</row>
<row>
<entry></entry>
<entry>sum &equals; sum &plus; a&lsqb;j&minus;2&rsqb;*cep&lsqb;ind&minus;1&rsqb;*ind;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>cep&lsqb;l&minus;1&rsqb; &equals; &minus;sum/l;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>void map_resp(float* const dvec, int const ana_dim, int* respx, int*</entry>
</row>
<row>
<entry></entry>
<entry>respy)</entry>
</row>
<row>
<entry></entry>
<entry>&lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>int xm, ind, i;</entry>
</row>
<row>
<entry></entry>
<entry>float dist;</entry>
</row>
<row>
<entry></entry>
<entry>float min_dist &equals; 1000000</entry>
</row>
<row>
<entry></entry>
<entry>for( xm &equals; 0; xm &lt; MAP_DIM X; xm &plus;&plus; ) &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>for( ym &equals; 0; ym &lt; MAP_DIM_Y; ym &plus;&plus; ) &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>ind &equals; (xm &plus; (ym*MAP_DIM_X))*DATA_DIM;</entry>
</row>
<row>
<entry></entry>
<entry>if ((dist &equals; distance(dvec, &amp;map&lsqb;ind&rsqb;, DATA_DIM)) &lt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>min_dist )&lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="70PT" align="left"/>
<colspec colname="1" colwidth="147PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>*respx &equals; xm;</entry>
</row>
<row>
<entry></entry>
<entry>*respy &equals; ym;</entry>
</row>
<row>
<entry></entry>
<entry>min_dist &equals; dist;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>int apne_dec( int const respx, int const respy, float* d_out)</entry>
</row>
<row>
<entry></entry>
<entry>&lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>static float mean_x &equals; MAP_DIM_X/2;</entry>
</row>
<row>
<entry></entry>
<entry>static float mean_y &equals; MAP_DIM_Y/2;</entry>
</row>
<row>
<entry></entry>
<entry>static int first &equals; 0;</entry>
</row>
<row>
<entry></entry>
<entry>static float resp_hist&lsqb;NMB_SAVE&rsqb;;</entry>
</row>
<row>
<entry></entry>
<entry>static int n_hist_x &equals; 0;</entry>
</row>
<row>
<entry></entry>
<entry>static int n_hist_y &equals; 0;</entry>
</row>
<row>
<entry></entry>
<entry>float rad_filt;</entry>
</row>
<row>
<entry></entry>
<entry>float rad_inst;</entry>
</row>
<row>
<entry></entry>
<entry>double dx, dy, dfx, dfy;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>int current_in_area &equals; 0;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>int new_in &equals; 0, i;</entry>
</row>
<row>
<entry></entry>
<entry>dx &equals; (respx&minus;area_x_mid )*( respx&minus;area_x_mid);</entry>
</row>
<row>
<entry></entry>
<entry>dy &equals; (respy&minus;area_y_mid )*( respy&minus;area_y_mid);</entry>
</row>
<row>
<entry></entry>
<entry>rad_inst &equals; sqrt(dx &plus; dy);</entry>
</row>
<row>
<entry></entry>
<entry>mean_x &equals; lp_a*mean_x &plus; (1&minus;lp_a)*respx;</entry>
</row>
<row>
<entry></entry>
<entry>mean_y &equals; lp_a*mean_y &plus; (1&minus;lp_a)*respy;</entry>
</row>
<row>
<entry></entry>
<entry>dfx &equals; (mean_x&minus;x_cen)*(mean_x&minus;x_cen);</entry>
</row>
<row>
<entry></entry>
<entry>dfy &equals; (mean_y&minus;y_cen)*(mean_y&minus;y_cen);</entry>
</row>
<row>
<entry></entry>
<entry>rad_filt &equals; sq rt(dfx &plus;dfy);</entry>
</row>
<row>
<entry></entry>
<entry>/*check if the current response is in the area */</entry>
</row>
<row>
<entry></entry>
<entry>if ( area_rad &gt; rad_inst) new_in &equals; 1;</entry>
</row>
<row>
<entry></entry>
<entry>for( i &equals; NMB_SAVE&minus;1; i&gt; 0; i-- ) &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>resp_hist&lsqb;i&rsqb; &equals; resp_hist&lsqb;i&minus;1&rsqb;;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>resp_hist&lsqb;0&rsqb; &equals; new_in</entry>
</row>
<row>
<entry></entry>
<entry>for( i &equals; 0; i &lt; nb_resp_hist; i&plus;&plus; ) &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>if( 1 &equals;&equals; resp_hist&lsqb;i&rsqb; ) current_in_area&plus;&plus;;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>if ( mean_x &gt; det_x_min &amp;&amp;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>mean_y &gt; det_y_min &amp;&amp;</entry>
</row>
<row>
<entry></entry>
<entry>mean_x &lt; det_x_max &amp;&amp;</entry>
</row>
<row>
<entry></entry>
<entry>mean_y &lt; det_y_max)</entry>
</row>
<row>
<entry></entry>
<entry>/* standard case, when detecting a simple square area of the</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>filtred response */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>return 0;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>else if (rad &gt; rad_filt )</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>/* within circle calc, otherwise same as above */</entry>
</row>
<row>
<entry></entry>
<entry>return 0;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>else if (resp_in_area &lt; current_in_area )</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>/*instant resp totaly over the given number */</entry>
</row>
<row>
<entry></entry>
<entry>return 0;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>else</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>return 1;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;;</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
</section>
<section>
<heading lvl="1">EXAMPLE 9 </heading>
</section>
<section>
<heading lvl="1">Patient Treatment </heading>
<paragraph id="P-0105" lvl="7"><number>&lsqb;0105&rsqb;</number> Equipment. </paragraph>
<paragraph id="P-0106" lvl="0"><number>&lsqb;0106&rsqb;</number> Breas CPAP pvlO prototype (Breas AB, Molndal, Sweden) with internal flow measurement; PSG system, EMBLATM Polysomnography (Embla hf, Reykjavik, Iceland); PC with artificial neural network software for sleep disturbance detection. </paragraph>
<paragraph id="P-0107" lvl="7"><number>&lsqb;0107&rsqb;</number> Patients. </paragraph>
<paragraph id="P-0108" lvl="0"><number>&lsqb;0108&rsqb;</number> 6 males aged from 31 to 60 years, suffering from sleep disorders of various kind. </paragraph>
<paragraph id="P-0109" lvl="7"><number>&lsqb;0109&rsqb;</number> Measurement. </paragraph>
<paragraph id="P-0110" lvl="0"><number>&lsqb;0110&rsqb;</number> The patient was set up with all sensors from the PSG system: EEG, EOG, EMG, oxygen saturation, pulse, nasal flow thermistor measurement, body position. With this setup it is possible to determine sleep stages, arousals, sleep apnea, sleep hypoapnea, and other sleep related events. The CPAP provides air through a tube via a nasal mask to the patient. Via the CPAP communication interface the PC was connected to the CPAP. The PC software can read air flow values from the CPAP and set new pressure set points on the CPAP by the communication interface. The information was exchanged at a rate of about 20 Hz. The PC program feeds the flow values into the artificial neural network (ANN). The output from the ANN is entered into a pressure regulation algorithm (PRA). The pressure regulation algorithm calculates a new pressure set point and activates the new value in the CPAP. The output from the artificial neural network and the pressure setpoint is read by the PSG system. </paragraph>
<paragraph id="P-0111" lvl="7"><number>&lsqb;0111&rsqb;</number> Evaluation. </paragraph>
<paragraph id="P-0112" lvl="0"><number>&lsqb;0112&rsqb;</number> In a normal CPAP titration (sleep disorder analysis) a CPAP is connected to a patient during sleep. The CPAP pressure is adjusted during the night so as to put the patient in a state with no indications of sleep disorders. This pressure is the one used in the CPAP treatment. The patient&apos;s need for various CPAP pressures can be seen with the PSG system breath-by-breath. The required CPAP pressure varies depending on sleep stage, body position, etc. The data from the auto CPAP test was evaluated in the PSG system in the same manner as for CPAP titration by a physician used to evaluate patients receiving CPAP treatment. Thereby the correlation between the detection of sleep disorder by the ANN and the analysis in the PSG system could be determined. The good correlation obtained indicated that the AFN reacted correctly. </paragraph>
</section>
<section>
<heading lvl="1">REFERENCES </heading>
<paragraph id="P-0113" lvl="1"><number>&lsqb;0113&rsqb;</number> &lsqb;1&rsqb; T. Kohonen, T. Torkkola, M. Shozakai, 0. Venta &ldquo;Phonetic typewriter for Finnish and Japanese&rdquo;, Proc IEEE ICASSP, New York, N.Y., 1988 </paragraph>
<paragraph id="P-0114" lvl="1"><number>&lsqb;0114&rsqb;</number> &lsqb;2&rsqb; H. C. Leung, V. W. Zue &ldquo;Some Phonetic Recognition Experiments using Artificial Neural Nets&rdquo;. , Proc IEEE ICASSP, New York, N.Y., 1988 </paragraph>
<paragraph id="P-0115" lvl="1"><number>&lsqb;0115&rsqb;</number> &lsqb;3&rsqb; P. Brauer &ldquo;Infrastructure in Kohonen maps&rdquo;, Proc. IEEE ICASSP, Glasgow, Scotland, 1989. </paragraph>
<paragraph id="P-0116" lvl="1"><number>&lsqb;0116&rsqb;</number> &lsqb;4&rsqb; P. Knagenhjelm &ldquo;A Recursive Design Method for Robust Vector Quantization&rdquo;, Proc. ICSPAT, Boston, Mass., 1992. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method for the detection and treatment of disordered breathing during sleep employing an artificial neural network (ANN) in which data related to breathing gas flow are analyzed, comprising: 
<claim-text>placing a mask with a tube over a patient&apos;s airway, the mask being in communication with a source of a pressurized breathing gas controlled by a continuous positive airway pressure (CPAP) system, thereby establishing a respiratory circuit; </claim-text>
<claim-text>periodically sampling the gas flow in the circuit; </claim-text>
<claim-text>periodically calculating values for one or several parameters distinctive of various breathing patterns; </claim-text>
<claim-text>periodically feeding said parameter values to an ANN trained to recognize breathing patterns characteristic of sleep disordered breathing; </claim-text>
<claim-text>analyzing said parameter values in the neural network; </claim-text>
<claim-text>controlling pressurized breathing gas supply in response to the output from said ANN. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, where in said parameter values are fed to the network at a frequency of from 2 Hz to 30 Hz. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, wherein said parameter values are fed to the network at a frequency of about 20 Hz. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein said parameters comprise cepstrum coefficients, energy slope, difference in trend. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the ANN has been trained with data collected from a large number of patients. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the ANN has been trained with data collected from patients during a particular stage of sleep. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the ANN has been trained with data collected from patients resting in a particular body position during sleep. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the ANN has been trained with data collected from patients being under influence of drugs including alcohol during sleep. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the ANN has been trained with data collected from patients by use of a polysomnography system. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the ANN comprises a number of nodes representing sets of training data. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the ANN is a Kohonen-map type ANN. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, comprising a structure of data stored in a non-volatile memory. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, wherein the non-volatile memory is comprised by an auto CPAP. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, wherein the ANN co mprises areas representing initial stages of apnea. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference>, wherein a closed trajectory characteristic of the breathing pattern of the patient is made to pass through the ANN and is analyzed in regard of its geometric relationship to said areas representing initial stages of apnea, the passage of said trajectory through such area or touching such area being indicative of a disturbed breathing pattern and being used to control the ACPAP so as to increase the amount of air provided to the patient to restore normal breathing. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference>, wherein the additional amount of air adduced to restore normal breathing is reduced upon a normal breathing pattern having been re-established. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, comprising the use of linear predictive coding to analyze the parameter values fed to the ANN. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference>, wherein, in said linear predictive coding analysis, so-called A-parameters from the analysis are converted to cepstrum parameters for optimal correlation between parameter distance and conceptual distance. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, wherein the prediction error in calculating linear predictive coding is used as a basis for determining the parameter value next in line. </claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference>, wherein said prediction error is filtered to counteract short-term variations, and is normalized with the total energy of the analytical window. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. An apparatus for the detection and treatment of disordered breathing during sleep for use with a CPAP, the apparatus including a probe for sampling breathing air flow data, in particular on inhalation, and an artificial neural network (ANN) for analyzing, directly or indirectly, said data to control breathing air pressure. </claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference>, wherein the ANN is a Kohonen map-type ANN. </claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. An automatic continuous positive airways pressure apparatus (ACPAP) comprising a probe for sampling breathing air flow data and an artificial neural network (ANN) for analyzing, directly or indirectly, said data to control breathing air pressure. </claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 23</dependent-claim-reference>, wherein the ANN is a Kohonen map-type ANN. </claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. A method of treating sleep disorder breathing, the method comprising the steps of: 
<claim-text>placing an interface over a patient&apos;s airway, the interface coupled to a source of pressurized gas; </claim-text>
<claim-text>measuring a respiration-related variable in the interface; </claim-text>
<claim-text>inputting cepstrum data from the respiration-related variables into an artificial neural network trained to recognize patterns characterizing sleep disorder breathing; </claim-text>
<claim-text>responsive to recognition by the artificial neural network of sleep disorder breathing, supplying pressurized gas to the patient&apos;s airway through the interface. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference> wherein the step of measuring respiration-related variables includes the step of obtaining a frequency spectrum from the measured respiration-related variables. </claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference> further comprising the step of: 
<claim-text>comparing a number of outputs of the artificial neural network over a selected interval to a selected threshold value and indicating sleep disorder breathing only if the number of outputs of the artificial neural network indicative of sleep disorder breathing exceeds the selected threshold value. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference> further comprising the step of normalizing the measured respiration-related variable prior to inputting them into the artificial neural network. </claim-text>
</claim>
<claim id="CLM-00029">
<claim-text><highlight><bold>29</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference> wherein the respiration-related variable is the pressure in the interface. </claim-text>
</claim>
<claim id="CLM-00030">
<claim-text><highlight><bold>30</bold></highlight>. A method of treating sleep disorder breathing, the method comprising the steps of: 
<claim-text>placing an interface over a patient&apos;s airway, the interface coupled to a source of pressurized gas; </claim-text>
<claim-text>measuring respiration-related variables in the interface; </claim-text>
<claim-text>obtaining a frequency spectrum from the measured respiration-related variables, the frequency spectrum including at least one frequency component; </claim-text>
<claim-text>inputting the frequency component of the frequency spectrum into an artificial neural network trained to recognize patterns characteristic of sleep disorder breathing; </claim-text>
<claim-text>responsive to output from the artificial neural network indicative of sleep disorder breathing, supplying pressurized gas to the patient&apos;s airway through the interface. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00031">
<claim-text><highlight><bold>31</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00033">claim 30</dependent-claim-reference> wherein the step of obtaining a frequency spectrum from the measured respiration-related variables comprises performing a fast Fourier transform on a selected group of sample of measured respiration-related variables. </claim-text>
</claim>
<claim id="CLM-00032">
<claim-text><highlight><bold>32</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00033">claim 30</dependent-claim-reference> further comprising the step of: 
<claim-text>comparing a number of outputs of the artificial neural network over a selected interval to a selected threshold value and indicating sleep disorder breathing only if the number of outputs of the artificial neural network indicative of sleep disorder breathing exceeds the selected threshold value. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00033">
<claim-text><highlight><bold>33</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00033">claim 30</dependent-claim-reference> further comprising the step of: 
<claim-text>normalizing the components of the frequency spectrum prior to inputting them into the artificial neural network. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00034">
<claim-text><highlight><bold>34</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00033">claim 30</dependent-claim-reference> wherein the respiration-related variables are the pressure in the interface. </claim-text>
</claim>
<claim id="CLM-00035">
<claim-text><highlight><bold>35</bold></highlight>. A method of treating sleep disorder breathing, the method comprising the steps of: 
<claim-text>placing an interface over a patient&apos;s airway, the interface coupled to a source of pressurized gas; </claim-text>
<claim-text>periodically sampling pressure in the interface; </claim-text>
<claim-text>periodically inputting cepstrum data from the sample of pressure in the interface into an artificial neural network trained to recognize patterns characterizing sleep disorder breathing, the artificial neural network producing an output for each sample of pressure input; </claim-text>
<claim-text>comparing the number of outputs indicating sleep disorder breathing to a selected threshold value, sleep disorder breathing being indicated if the number of outputs exceeds the threshold value; and </claim-text>
<claim-text>responsive indicated sleep disorder breathing, supplying pressurized gas to the patient&apos;s airway through the interface. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00036">
<claim-text><highlight><bold>36</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00033">claim 35</dependent-claim-reference> further including the step of obtaining a frequency spectrum from the measured respiration-related variables. </claim-text>
</claim>
<claim id="CLM-00037">
<claim-text><highlight><bold>37</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00033">claim 36</dependent-claim-reference> further comprising the step of: 
<claim-text>normalizing the components of the frequency spectrum prior to inputting them into the artificial neural network. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00038">
<claim-text><highlight><bold>38</bold></highlight>. An apparatus for treatment of sleep disorder breathing comprising: 
<claim-text>an interface for placement over a patient&apos;s airway, the interface coupled to a source of pressurized gas; </claim-text>
<claim-text>means for measuring respiration-related variables in the interface; </claim-text>
<claim-text>means for inputting cepstrum data from the respiration-related variables into an artificial neural network trained to recognize patterns characterizing sleep disorder breathing; </claim-text>
<claim-text>means for supplying pressurized gas to the patient&apos;s airway through the interface responsive to recognition by the artificial neural network of sleep disorder breathing. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00039">
<claim-text><highlight><bold>39</bold></highlight>. The apparatus according to <dependent-claim-reference depends_on="CLM-00033">claim 38</dependent-claim-reference> further comprising: 
<claim-text>means for obtaining a frequency spectrum from the measured respiration-related variables. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00040">
<claim-text><highlight><bold>40</bold></highlight>. The apparatus according to <dependent-claim-reference depends_on="CLM-00033">claim 38</dependent-claim-reference> further comprising: 
<claim-text>means for comparing a number of outputs of the artificial neural network over a selected interval to a selected threshold value and indicating sleep disorder breathing only if the number of outputs of the artificial neural network indicative of sleep disorder breathing exceeds the selected threshold value. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00041">
<claim-text><highlight><bold>41</bold></highlight>. The apparatus according to <dependent-claim-reference depends_on="CLM-00033">claim 38</dependent-claim-reference> further comprising: 
<claim-text>means for normalizing the measured respiration-related variables prior to inputting them into the artificial neural network.</claim-text>
</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>1</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030000528A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030000528A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030000528A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
