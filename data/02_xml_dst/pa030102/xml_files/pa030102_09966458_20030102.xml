<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030004974A1-20030102-D00000.TIF SYSTEM "US20030004974A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030004974A1-20030102-D00001.TIF SYSTEM "US20030004974A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030004974A1-20030102-D00002.TIF SYSTEM "US20030004974A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030004974A1-20030102-D00003.TIF SYSTEM "US20030004974A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030004974A1-20030102-D00004.TIF SYSTEM "US20030004974A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030004974A1-20030102-D00005.TIF SYSTEM "US20030004974A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030004974A1-20030102-D00006.TIF SYSTEM "US20030004974A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030004974A1-20030102-D00007.TIF SYSTEM "US20030004974A1-20030102-D00007.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030004974</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09966458</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20010928</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F012/00</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>707</class>
<subclass>200000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Configurable system monitoring for dynamic optimization of program execution</title-of-invention>
</technical-information>
<continuity-data>
<non-provisional-of-provisional>
<document-id>
<doc-number>60302058</doc-number>
<document-date>20010628</document-date>
<country-code>US</country-code>
</document-id>
</non-provisional-of-provisional>
</continuity-data>
<inventors>
<first-named-inventor>
<name>
<given-name>Hong</given-name>
<family-name>Wang</family-name>
</name>
<residence>
<residence-us>
<city>Fremont</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Dong-Yuan</given-name>
<family-name>Chen</family-name>
</name>
<residence>
<residence-us>
<city>Fremont</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>John</given-name>
<family-name>Shen</family-name>
</name>
<residence>
<residence-us>
<city>San Jose</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Wen-Hann</given-name>
<family-name>Wang</family-name>
</name>
<residence>
<residence-us>
<city>Portland</city>
<state>OR</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Oren</given-name>
<family-name>Gershon</family-name>
</name>
<residence>
<residence-non-us>
<city>Rehovot</city>
<country-code>IL</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Gadi</given-name>
<middle-name>Reuven</middle-name>
<family-name>Ziv</family-name>
</name>
<residence>
<residence-non-us>
<city>Haifa</city>
<country-code>IL</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>Blakely, Sokoloff, Taylor &amp; Zafman</name-1>
<name-2></name-2>
<address>
<address-1>12400 Wilshire Boulevard, Seventh Floor</address-1>
<city>Los Angeles</city>
<state>CA</state>
<postalcode>90025-1030</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">According to the invention, an apparatus and method are disclosed for configurable system monitoring for dynamic optimization of program execution. According to one embodiment, an event monitoring apparatus for dynamic optimization comprises an event monitor to capture profiles of events that occur in the processing of an application by a microprocessor; an interface to a software component; monitor control vectors to direct the operation of the event monitor; and a profile buffer. According to the embodiment, the events to be monitored are selected by the software component. Profiles of the selected events are captured and stored in the profile buffer. The profiles are made available to a handler routine selected by the software component, which processes the profiles to identify regions of the application for optimization and invokes optimizers to optimize the identified regions. </paragraph>
</subdoc-abstract>
<subdoc-description>
<cross-reference-to-related-applications>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> This application claims the benefit of U.S. Provisional Application No. 60/302,058, filed Jun. 28, 2001.</paragraph>
</cross-reference-to-related-applications>
<summary-of-invention>
<section>
<heading lvl="1">COPYRIGHT NOTICE </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> Contained herein is material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the United States Patent and Trademark Office patent file or records, but otherwise reserves all rights to the copyright whatsoever. The following notice applies to the software and data as described below and in the drawings hereto: Copyright&reg; 2001, Intel Corporation, All Rights Reserved. </paragraph>
</section>
<section>
<heading lvl="1">FIELD OF THE INVENTION </heading>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> This invention relates to computers in general, and more specifically to configurable system monitoring for dynamic optimization of program execution. </paragraph>
</section>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> Dynamic optimization is an optimization mechanism by which the execution of a computer program is adapted to dynamic execution environment as affected by program inputs and the various states of the microprocessor. A dynamic optimizer continuously monitors the dynamic execution of a program over time and looks for areas in the program that can be adapted or modified to achieve better performance. Dynamic optimization is optimization that utilizes run-time information during program operation. Dynamic optimization can be contrasted with static optimization, which is based on program analysis instead of the data obtained during run-time. The process of monitoring, selecting regions for optimization, and performing the dynamic optimization cycle is typically performed totally in either hardware or software. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> A trace cache mechanism in certain microprocessors is an example of conventional dynamic optimization accomplished using hardware. A trace is a record of the actions carried out by a computer system. In this example, a microprocessor continuously monitors the retired instruction stream from the execution pipeline and selectively places traces from the retired instruction stream in a linear cache to speed up future instruction fetch and decoding processes. A hardware monitor can monitor microarchitecture events that generally cannot be monitored by software alone. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> However, hardware optimization of computer applications has limitations. By its nature, hardware is generally fixed and thus is difficult to modify and update. Further, conventional hardware optimization requires that additional work be done in the execution pipeline, thereby potentially slowing the computation process. In hardware optimization, a significant amount of logic is necessary even for simple optimization schemes. Sophisticated optimization is thus difficult to implement in hardware and may significantly increase the cost of hardware. Further, the data that is collected in conventional hardware optimization is isolated in the hardware and is not available for other uses. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> In contrast, software optimization is easily implemented and is much simpler to modify and update in comparison with hardware optimization. For these reasons, software optimization may allow for more aggressive and sophisticated approaches to optimization. In a software dynamic optimizer, such as Dynamo of Hewlett Packard Corporation of Palo Alto, Calif., an interpreter may be used to execute the program initially, collecting the execution profile for the program as execution progresses and determining which region of the code is executed most often. Once the execution profile reaches a predetermined threshold, a frequently executed region of the program may be selected for optimization and be translated into a more efficient form. The dynamic optimized code is then used in future interpretation to improve program execution. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> However, there are also disadvantages to conventional software optimization. Software optimization can create a bottleneck because of the overhead of implementing a software monitor. Further, in a software approach, the software can determine how many times certain regions of a program are executed, but generally cannot determine the real time costs of different operations and thus cannot accurately determine optimization needs. </paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> The appended claims set forth the features of the invention with particularity. The invention, together with its advantages, may be best understood from the following detailed descriptions taken in conjunction with the accompanying drawings, of which: </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a flow diagram illustrating an embodiment of hybrid dynamic optimization operations; </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a diagram illustrating an embodiment of a hybrid dynamic optimizer; </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a diagram illustrating an embodiment of a software component of a hybrid dynamic optimizer; </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a diagram illustrating an embodiment of monitor control vectors; </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a diagram illustrating an embodiment of a profile register file; </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is a diagram illustrating an embodiment of a profile backstore buffer; and </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> illustrates an embodiment of a microprocessor execution pipeline. </paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION </heading>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> A method and apparatus are described for configurable system monitoring for dynamic optimization of program execution. A hybrid approach to dynamic optimization, in which both hardware and software optimization work together, offers advantages over conventional optimizers that are solely hardware or software based. In the hybrid approach, the advantages of hardware optimization, which can determine time costs more accurately and can monitor different types of events, and the advantages of software, which is easier to track and allows for more complex operation, are merged to provide a better dynamic optimization solution. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> In the following description, for the purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the present invention. However, it will be apparent to one skilled in the art that the present invention may be practiced without some of these specific details. In other instances, well-known structures and devices are shown in block diagram form. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> The present invention includes various processes, which will be described below. The processes of the present invention may be performed by hardware components or may be embodied in machine-executable instructions, which may be used to cause a general-purpose or special-purpose processor or logic circuits programmed with the instructions to perform the processes. Alternatively, the processes may be performed by a combination of hardware and software. </paragraph>
<paragraph id="P-0020" lvl="7"><number>&lsqb;0020&rsqb;</number> Terminology </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> Before describing an exemplary environment in which various embodiments of the present invention may be implemented, some terms that will be used throughout this application will briefly be defined: </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> As used herein, a &ldquo;monitor&rdquo; is a hardware device that measures electrical events, such as pulses or voltage levels, in a processor or computer, with measured events including microarchitecture events. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> In this discussion, the term &ldquo;optimization&rdquo; is not limited to performance and achieving maximum speed, but is rather intended to indicate more general improvements in operation. A system may be optimized in many different ways depending on the motivations of the system programmer. The hybrid optimization method may, for example, be used if there is a need to slow down or throttle the operations of a system. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> In this discussion, the term &ldquo;event&rdquo; means a processor microarchitecture event, including but not limited to instruction cache misses, retired branches, and other related events, and platform events, such as bus transactions. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> In an embodiment of a hybrid hardware-software approach to dynamic optimization, hardware is employed to monitor dynamic program behavior and collect event profiles. Periodically a software component of the dynamic optimizer examines and processes the profiles that have been collected and identifies the program regions of interest that present a good opportunity for dynamic optimization (which may be referred to as &ldquo;hot blocks&rdquo;). A hybrid dynamic optimizer presents several advantages over purely hardware-based or software-based approaches. In a hybrid dynamic optimizer, the hardware monitor is able to monitor microarchitecture events that are not available to a software-based dynamic optimizer. Software-based region selection and optimization allows the implementation of more sophisticated optimizations that cannot be easily accomplished in a conventional hardware-based dynamic optimizer. In addition, with a hybrid approach, the types of events that are monitored and the profiles that are collected can be programmable in order to support varied needs and objectives. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> In the hybrid dynamic optimization approach, the interaction between the hardware and the software determines the performance benefits that are achieved by optimization. A flexible interface to specify what events to monitor enables the software component of the hybrid dynamic optimizer to employ a wide and versatile array of optimization tools. A fast and efficient hardware profile collection mechanism allows the dynamic optimizer to adapt to changing program behavior quickly with minimal overhead. Further, a simple and efficient mechanism to transfer control between the hardware monitoring and profiling entity and the software optimizing entity provides a smooth transition between the hardware and software components of the optimizer. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> Under one embodiment, the software component can choose types of events to be monitored by the hardware component. Under a particular embodiment, the events that are monitored include events that are associated with specific instructions and events that are global to the instruction pipeline. The hardware component includes a set of monitor control vectors that are programmed by the software component. The hardware monitor control vectors then control which events are monitored at what times. For example, based on selections made by the software component, a monitor control vector may direct that I-cache (instruction cache) miss events be monitored. Further, the monitor control vector may direct that the events be captured on a statistical sampling basis, such as capturing I-cache miss events every 1000 I-cache misses. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> Under an embodiment, a microarchitectural technique is used to capture the pipeline event traces at very low cost in terms of the complexity of the design and the performance of the system. In this technique, the traces are initially stored in register files, which comprise a first level buffer, and then transferred to an architecturally visible mechanism in a memory buffer accessible by memory address, which comprises a second level buffer. When the memory buffer designated for a specified event is fully allocated or when some other condition specified by the software component exists, control is transferred to a handler routine through a lightweight interrupt mechanism. The handler routine processes the profile data and, upon finding code regions that will benefit from optimization, invokes appropriate optimizations for the regions of interest. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> Under a specific embodiment of dynamic hybrid optimization involving a microprocessor containing an execution pipeline, an extension of the pipeline may be introduced at the exception detection (DET) and write-back (WRB) stages to filter the event instruction profile and to write the instruction profile into the profile register file. Under one embodiment, the microprocessor utilized is an Itanium&reg; microprocessor of Intel Corporation of Santa Clara, Calif. However, embodiments are not limited to Itanium series microprocessors and may be implemented with other processors. In a particular embodiment of an Itanium series microprocessor, there is a dedicated stage for exception detection to detect exception conditions and invoke the architectural vector handler. For the execution pipeline of an Itanium microprocessor, this dedicated stage is responsible for performing predicate checker functionality to determine whether an executed instruction should be written back based on the resolved value of the predicate. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> For a retired instruction, the write-back stage of an execution pipeline may be used to write back speculative values of destination registers into the architecturally visible register file. In an execution pipeline of an Itanium family microprocessor, where there are at least 5 or 6 registers for both source operands and destination operands per instruction, the existing data path to the register file is relatively wide and thus is particularly adaptable for saving profile information because such function may be accomplished without introducing new data paths. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> Under an embodiment involving an Itanium microprocessor, a profile selection filtering logic may be introduced. Under a particular embodiment, the profile selection filtering logic is physically implemented as a predicate-like tag mask carried with an instruction. Under the embodiment, the mask vector is checked at the exception detection (DET) stage for profile legitimacy. If a profile is qualified for profile tracing, the profile of the instruction of concern is treated as an extra operand of the instruction, and, during the write-back stage, the profile is written back into the profile register file using the data path that already exists for the register access in the Itanium microprocessor. Depending upon specific implementation details, more information can be synthesized with the profile value of interest at the exception detection stage or write-back stage before the profile value is written into the profile register file. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> In the general application of dynamic hybrid optimization, <cross-reference target="DRAWINGS">FIG. 1</cross-reference> illustrates a flowchart of operations under an embodiment of a hybrid dynamic optimizer. Under this embodiment, the software component of the hybrid dynamic optimizer selects the events to monitor, process block <highlight><bold>100</bold></highlight>. Upon selecting the events, the software component associates these events with handlers selected by the software component, process block <highlight><bold>105</bold></highlight>. In the processing of an application, the event monitoring and profiling entity monitors the events and captures an event profile, process block <highlight><bold>110</bold></highlight>. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> In the embodiment shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, the profile buffer for storing captured event profiles consists of two levels. The first level profile buffer is a profile register file, comprising a frame for each event being monitored. The second level profile buffer is a profile backstore buffer, comprising one memory buffer for each event being monitored. When an event profile is captured, there is a determination whether the registers within the frame for the event are fully allocated or another condition set by the software component is met, process block <highlight><bold>115</bold></highlight>. In one embodiment, the microprocessor may proactively spill the content of an event profile frame into the appropriate memory buffer within the profile backstore buffer when sufficient memory space is available, thereby maintaining available register space and allowing the microprocessor to continue writing without encountering delay when the all registers in the event profile frame are allocated. A determination whether the registers are fully allocated may be conducted in parallel with other determinations if proactive spilling is enabled. If the registers in the frame are not fully allocated and no other established condition is not met, the captured event profile is stored in a register in the appropriate frame within the profile register file, process block <highlight><bold>120</bold></highlight>, and the process continues with the capturing of event profiles, process block <highlight><bold>110</bold></highlight>. If the frame registers of the event are fully allocated or another condition is met, there is a determination whether the memory buffer for the event in the profile backstore buffer is fully allocated or some other established condition is met, process block <highlight><bold>125</bold></highlight>. If the memory buffer is not fully allocated and no other condition is met, the event profiles currently contained in the frame are stored in the profile backstore buffer, process block <highlight><bold>130</bold></highlight>, and the new event profile is stored in the frame registers for the event, process block <highlight><bold>132</bold></highlight>. The process then continues with the capturing of event profiles, process block <highlight><bold>110</bold></highlight>. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> If the memory buffer for the event is fully allocated or another condition is met, the stored event profiles are made available to the handler specified by the software component, process block <highlight><bold>135</bold></highlight>, via an interrupt or special event handler sent to the specified handler. In one embodiment, the profile backstore buffer is architecturally visible to the software component, and is therefore programmable. The handler selected by the software component processes the event profile data, process block <highlight><bold>145</bold></highlight>, and identifies a region of interest for optimization, process block <highlight><bold>150</bold></highlight>. The software component selects an optimizer for the identified region of interest, process block <highlight><bold>155</bold></highlight>, and the optimizer is invoked, process block <highlight><bold>160</bold></highlight>, to optimize the operation of the region of interest. As stated above, the optimization may involve optimizing the speed of operation of the region of interest or may involve one or more different optimization goals. The system then may continue the monitoring and profiling process, process block <highlight><bold>165</bold></highlight>. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> An embodiment of a hybrid dynamic optimization system <highlight><bold>205</bold></highlight> is illustrated in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>. In <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, the hybrid dynamic optimization system <highlight><bold>205</bold></highlight> includes an event monitoring and profiling portion <highlight><bold>210</bold></highlight> of a microprocessor <highlight><bold>200</bold></highlight>. In addition, the hybrid dynamic optimization system <highlight><bold>205</bold></highlight> includes a software component <highlight><bold>220</bold></highlight>. Microprocessor <highlight><bold>200</bold></highlight> runs an application process <highlight><bold>230</bold></highlight> that is subject to optimization. Thus, the system provides a software component that is interfaced with a hardware component to accomplish dynamic optimization. The hybrid dynamic optimization system <highlight><bold>205</bold></highlight> continuously monitors the execution of application process <highlight><bold>230</bold></highlight> and applies dynamic optimization to improve the performance of the application when optimization opportunities are identified. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, the event monitoring and profiling entity <highlight><bold>210</bold></highlight> contains a number of monitor control vectors <highlight><bold>240</bold></highlight>, which are configurable by the software component <highlight><bold>220</bold></highlight>. In this manner, the monitor control vectors <highlight><bold>240</bold></highlight> control the capture and storage of data regarding the processor events to be monitored using the process monitor <highlight><bold>250</bold></highlight>. Events that are monitored may be events associated with specific instructions or may be events that are global to the pipeline. When an event profile is captured, the profile is stored in the appropriate frame of a profile register file <highlight><bold>270</bold></highlight>, which is the first level of profile buffer <highlight><bold>260</bold></highlight>. When the frame in the profile register file for an event is fully allocated or another condition set by the software component is met, the captured profiles are transferred to a memory buffer for the event in a profile backstore buffer <highlight><bold>280</bold></highlight>, the second level of profile buffer <highlight><bold>260</bold></highlight>. In one embodiment, microprocessor <highlight><bold>200</bold></highlight> may also proactively spill the contents of the event profile frame into the appropriate memory buffer within the profile backstore buffer <highlight><bold>280</bold></highlight> when sufficient memory space is available. When the memory buffer for the event in profile backstore buffer <highlight><bold>280</bold></highlight> is fully allocated or another condition established by the software component is met, a notification is sent to the handler specified by the software component <highlight><bold>220</bold></highlight>. As more fully explained below, the turn around time for a handler routine to process data in the profile backstore buffer may be reduced by making an empty memory buffer available to the microprocessor when an event handler routine begins operation. In one embodiment, profile backstore buffer <highlight><bold>280</bold></highlight> is architecturally visible to software component <highlight><bold>220</bold></highlight>. Software component <highlight><bold>220</bold></highlight> processes the event profile data and identifies regions of interest in application process <highlight><bold>230</bold></highlight> that may be optimized. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> illustrates a software component of a hybrid dynamic optimizer under a particular embodiment. In the illustration, software component <highlight><bold>300</bold></highlight> is optimizing an application process <highlight><bold>330</bold></highlight>. For the purposes of this illustration, application process <highlight><bold>330</bold></highlight> is shown to contain code <highlight><bold>335</bold></highlight>. The instructions <highlight><bold>305</bold></highlight> contained in software component <highlight><bold>300</bold></highlight> include handler routines, shown in <cross-reference target="DRAWINGS">FIG. 3</cross-reference> as handler routine<highlight><subscript>1 </subscript></highlight><highlight><bold>310</bold></highlight> through handler routine<highlight><subscript>n </subscript></highlight><highlight><bold>315</bold></highlight>, and optimizers, shown in <cross-reference target="DRAWINGS">FIG. 3</cross-reference> as optimizer<highlight><subscript>1 </subscript></highlight><highlight><bold>320</bold></highlight> through optimizer<highlight><subscript>m </subscript></highlight><highlight><bold>325</bold></highlight>. Each handler routine contains instructions for processing monitor event profiles and coordinating with respect to the information contained in the profile for an event. If handler routine<highlight><subscript>1 </subscript></highlight><highlight><bold>310</bold></highlight> is the handler routine for a monitored event, a pointer to the handler routine is stored in a field in one of the monitor control vectors <highlight><bold>345</bold></highlight>. Further details regarding exemplary monitor control vectors are discussed below. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> Based at least in part on captured event profiles, software component <highlight><bold>300</bold></highlight> will attempt to identify regions of interest for optimization in code <highlight><bold>335</bold></highlight> of application process <highlight><bold>330</bold></highlight>. In <cross-reference target="DRAWINGS">FIG. 3</cross-reference>, for example, a region of interest <highlight><bold>340</bold></highlight> is identified. Upon identifying region of interest <highlight><bold>340</bold></highlight>, software component <highlight><bold>300</bold></highlight> will select the appropriate optimizer. In <cross-reference target="DRAWINGS">FIG. 3</cross-reference>, optimizer<highlight><subscript>x </subscript></highlight><highlight><bold>350</bold></highlight> is selected and is invoked to optimize region of interest <highlight><bold>340</bold></highlight>. As indicated above, optimization of a region of interest may take various forms and is not limited to increasing the speed of operation of regions of interest. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> Under one embodiment, each monitor control vector includes a number of fields to control the monitoring of an event. For example, a control field in each monitor control vector controls may specify the type of events to monitor and other relevant parameters. A trigger field in a monitor control vector may specify when a given event should be monitored. Further, a handler field in each monitor control vector may contain a function pointer to a handler routine in the software component for the processing of captured event profile data. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> Details regarding an embodiment of monitor control vectors are illustrated in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>. In a particular embodiment, the monitor control vectors <highlight><bold>400</bold></highlight> include vector<highlight><subscript>1 </subscript></highlight><highlight><bold>410</bold></highlight> through vector<highlight><subscript>n </subscript></highlight><highlight><bold>420</bold></highlight>. Each vector is comprised of a number of different fields. For example, the fields within vector<highlight><subscript>1 </subscript></highlight><highlight><bold>410</bold></highlight> include a handler field, handler<highlight><subscript>1 </subscript></highlight><highlight><bold>430</bold></highlight>, a control field, control<highlight><subscript>1 </subscript></highlight><highlight><bold>440</bold></highlight>, and a trigger field, trigger<highlight><subscript>1 </subscript></highlight><highlight><bold>450</bold></highlight>, in addition to any other fields <highlight><bold>460</bold></highlight>. Other fields may include fields indicating the location and size of the profile register file or the address of the profile backstore buffer. In this illustration, handler<highlight><subscript>1 </subscript></highlight><highlight><bold>430</bold></highlight> will contain a pointer to a handler routine in the software component <highlight><bold>470</bold></highlight>. Control<highlight><subscript>1 </subscript></highlight><highlight><bold>440</bold></highlight> contains data regarding what type of event will be monitored by vector<highlight><subscript>1 </subscript></highlight><highlight><bold>410</bold></highlight>. Trigger<highlight><subscript>1 </subscript></highlight><highlight><bold>450</bold></highlight> contains data regarding when the specified type of event will be captured. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> A handler routine processes the captured event profile data regarding a specific type of event to identify promising regions for optimizations and selects an optimization method. Once the handler routine has chosen an optimization method, the handler routine invokes the appropriate optimizer from the optimizers available to perform the task and eventually links the optimized code with the execution image of the application process. In general, the handler routines reside in the OS (operating system) kernal space, similar to a device driver, while the optimizers reside in an application process. However, embodiments are not limited to this structure and components may be stored in different locations. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> Based upon the directions of the monitor control vectors, profiles of events are captured by a hardware monitor. Once the event profiles are captured, the data is stored in a profile buffer. According to one embodiment, the profile buffer is comprised of two levels, a first level profile register file and a second level profile backstore buffer. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 5</cross-reference>, an embodiment of a profile register file is illustrated. Profile register file <highlight><bold>500</bold></highlight> is the first level profile buffer. As a first level buffer, profile register file <highlight><bold>500</bold></highlight> is a small and fast register for the initial storage of event profile data. Profile register file <highlight><bold>500</bold></highlight> contains a plurality of frames, each frame being for the storage of event profiles captured by monitor <highlight><bold>515</bold></highlight> for a particular event. In <cross-reference target="DRAWINGS">FIG. 5</cross-reference>, profile register file <highlight><bold>500</bold></highlight> contains n frames, the frames being frame<highlight><subscript>1 </subscript></highlight><highlight><bold>505</bold></highlight> through frame<highlight><subscript>n </subscript></highlight><highlight><bold>510</bold></highlight>. Note that the separate frames shown are based on a logical view of the profile register file and are not necessarily physically separated. The frames may be included within a single physical register file. Each frame in profile register file <highlight><bold>500</bold></highlight> can contain a certain number of registers for event profiles, which for this illustration is shown as k event profile registers for each event frame. Therefore, frame<highlight><subscript>1 </subscript></highlight><highlight><bold>505</bold></highlight> contains event profile register<highlight><subscript>11 </subscript></highlight><highlight><bold>520</bold></highlight> through event profile register<highlight><subscript>1k </subscript></highlight><highlight><bold>535</bold></highlight>, while frame<highlight><subscript>n </subscript></highlight><highlight><bold>510</bold></highlight> contains event profile registers<highlight><subscript>n1 </subscript></highlight><highlight><bold>540</bold></highlight> through event profile register<highlight><subscript>nk </subscript></highlight><highlight><bold>545</bold></highlight>. When any frame has k event profiles stored, k being the maximum number of event profiles that may be stored in the frame, the stored event profiles are transferred to profile backstore buffer <highlight><bold>570</bold></highlight>, the second level buffer for storage of event profiles. As indicated above, in certain embodiments event profiles may also be proactively spilled to profile backstore buffer <highlight><bold>570</bold></highlight>, thereby maintaining available register space and reducing microprocessor delays. After event profiles stored in a frame have been spilled over to the profile backstore buffer <highlight><bold>570</bold></highlight>, the frame may then again be used to store an additional k event profiles as such event profiles are captured. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> In the embodiment shown in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>, each register has a bit indicating that the register is in use. In one example, event profile register<highlight><subscript>11 </subscript></highlight>has used bit <highlight><bold>550</bold></highlight>. In this example, used bit <highlight><bold>550</bold></highlight> contains a &ldquo;1&rdquo;, which indicates that event profile register<highlight><subscript>11 </subscript></highlight><highlight><bold>520</bold></highlight> in frame<highlight><subscript>1 </subscript></highlight><highlight><bold>505</bold></highlight> is currently in use. A current frame position pointer <highlight><bold>565</bold></highlight> points to the next register in frame<highlight><subscript>1 </subscript></highlight><highlight><bold>505</bold></highlight> that is currently not used, which is event profile register<highlight><subscript>12 </subscript></highlight><highlight><bold>525</bold></highlight> as used bit <highlight><bold>555</bold></highlight> for event profile register<highlight><subscript>12 </subscript></highlight><highlight><bold>525</bold></highlight> contains a &ldquo;0&rdquo;. When another event profile is captured, the profile data is stored in event profile register<highlight><subscript>12 </subscript></highlight><highlight><bold>525</bold></highlight> and current frame position pointer <highlight><bold>565</bold></highlight> is updated to point to the next register in frame<highlight><subscript>1 </subscript></highlight><highlight><bold>505</bold></highlight> that is currently not in use, which in this particular example then would be event profile register<highlight><subscript>13 </subscript></highlight><highlight><bold>530</bold></highlight> as used bit <highlight><bold>560</bold></highlight> contains a &ldquo;0&rdquo;. When the profile registers in a frame are spilled into profile backstore buffer <highlight><bold>570</bold></highlight>, then the used bits in the profile registers are reset to indicate that the registers are available for storage. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> In one embodiment, a spill position pointer (not shown in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>) is also maintained in each frame of profile register file <highlight><bold>500</bold></highlight> to indicate the next register to be written to the profile backstore buffer <highlight><bold>570</bold></highlight>. Once the content of the designated register is spilled into profile backstore buffer <highlight><bold>570</bold></highlight>, then the spill position pointer is updated to point to the next register to be spilled and the used bit in the spilled register is reset. Further, under one embodiment, profile register file <highlight><bold>500</bold></highlight> is not made architecturally visible because profile backstore buffer <highlight><bold>570</bold></highlight> is architecturally visible and thus the captured event profile data can be obtained by the software component by accessing profile backstore buffer <highlight><bold>570</bold></highlight>. Note that under a particular embodiment the current frame position pointer and spill position pointer can be made architecturally visible by storing such pointers as part of the monitor control vector. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> shows an embodiment of a profile backstore buffer. As the second level buffer in the profile buffer, profile backstore buffer <highlight><bold>600</bold></highlight> receives event profiles from the first level buffer, profile register file <highlight><bold>630</bold></highlight>. Under a particular embodiment, profile backstore buffer <highlight><bold>600</bold></highlight> is a linear buffer with one buffer for each monitor control vector, but an arrangement as a linear buffer is not required. In <cross-reference target="DRAWINGS">FIG. 6</cross-reference>, profile backstore buffer contains n memory buffers denoted as buffer<highlight><subscript>1 </subscript></highlight><highlight><bold>610</bold></highlight> through buffer<highlight><subscript>n </subscript></highlight><highlight><bold>620</bold></highlight>. Under one embodiment, when a memory buffer in profile backstore buffer <highlight><bold>600</bold></highlight> is fully allocated and contains the maximum number of event profiles that may be stored or when another condition set by the software component is met, the handler selected by software component <highlight><bold>640</bold></highlight> is notified by a lightweight interrupt or special event handler and the appropriate handler routine in the software component <highlight><bold>640</bold></highlight> processes the event profiles stored in the memory buffer to identify regions of interest for optimization. Within each memory buffer, the next available address for storage is indexed by a current buffer position pointer. For example, in buffer<highlight><subscript>x </subscript></highlight><highlight><bold>650</bold></highlight>, the next available pointer <highlight><bold>660</bold></highlight> points to entry<highlight><subscript>x2 </subscript></highlight><highlight><bold>670</bold></highlight> and the next event profile to be written to buffer<highlight><subscript>x </subscript></highlight><highlight><bold>650</bold></highlight> will be written to entry<highlight><subscript>x2 </subscript></highlight><highlight><bold>670</bold></highlight>. Upon data being stored in entry<highlight><subscript>x2 </subscript></highlight><highlight><bold>670</bold></highlight>, next available pointer <highlight><bold>660</bold></highlight> will be updated to point to the next available register. Under certain embodiments, the next available pointer is made architecturally visible and therefore is programmable. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> Under an another embodiment, a buffering mechanism is utilized to reduce the turn around time for a handler routine to process data in the event profile buffer. According to the embodiment, when a memory buffer is fully allocated and an event handler routine begins operation, an empty buffer is made available to the microprocessor to begin storing new captured profile data. For example, the handler routine may notify the microprocessor regarding the starting address and size of the empty memory buffer to be used for the event, such that the collection of event profiles can continue while the previously collected data is processed. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> illustrates an embodiment of an execution pipeline of a microprocessor that may be utilized in a particular embodiment of hybrid dynamic optimization. The execution pipeline embodiment illustrated is derived from the Itanium series microprocessors of Intel Corporation, but the concepts presented are not limited to this particular family of microprocessors. The execution pipeline <highlight><bold>700</bold></highlight> includes ten stages. The first three stages of the execution pipeline <highlight><bold>700</bold></highlight> make up the front end <highlight><bold>760</bold></highlight> of the pipeline. The front end stages are the IPG (instruction pointer generation) <highlight><bold>705</bold></highlight>, FET (fetch) <highlight><bold>710</bold></highlight>, and ROT (instruction rotation) <highlight><bold>715</bold></highlight> stages, which perform the functions of fetching an instruction and delivering the instruction to a decoupling buffer in the ROT <highlight><bold>715</bold></highlight> stage that allows the front-end <highlight><bold>760</bold></highlight> of execution pipeline <highlight><bold>700</bold></highlight> to operate independently from the remainder of the pipeline. The point of decoupling <highlight><bold>720</bold></highlight> is illustrated by the line separating the stages of the pipeline. Dispersal and register renaming are performed in the EXP (expand) <highlight><bold>725</bold></highlight> and REN (rename) <highlight><bold>730</bold></highlight> stages, which make up the instruction delivery portion <highlight><bold>765</bold></highlight> of execution pipeline <highlight><bold>700</bold></highlight>. The functions of the operand delivery portion <highlight><bold>770</bold></highlight> of execution pipeline <highlight><bold>700</bold></highlight> are performed in the WLD (wordline decode) <highlight><bold>735</bold></highlight> and REG (register read) <highlight><bold>740</bold></highlight> stages, which provide for accessing register files and delivering data through the bypass network after processing predicate control. The last three stages of execution pipeline <highlight><bold>700</bold></highlight>, EXE (execute) <highlight><bold>745</bold></highlight>, DET (exception detection) <highlight><bold>750</bold></highlight>, and WRB (write-back) <highlight><bold>755</bold></highlight>, form the execution and retirement portion <highlight><bold>775</bold></highlight> and perform wide parallel execution, exception management, and retirement. The DET stage <highlight><bold>750</bold></highlight> accommodates delayed branch execution as well as memory exception management and speculation support. As discussed above, the structure of the DET <highlight><bold>750</bold></highlight> and WRB <highlight><bold>755</bold></highlight> stages of the pipeline allows these stages to be utilized in embodiments of hybrid dynamic optimization. However, hybrid dynamic optimization is not limited to these stages and other embodiments are possible. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> In the foregoing specification, the invention has been described with reference to specific embodiments thereof. It will, however, be evident that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention. The specification and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. An event monitoring component for dynamic optimization comprising: 
<claim-text>an event monitor to selectively capture profiles of one or more microarchitecture events occurring in the execution of an application by a microprocessor based upon configuration information supplied by a software component; and </claim-text>
<claim-text>an interface through which the software component provides the configuration information to direct the operation of the event monitor. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The event monitoring component of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising: 
<claim-text>one or more monitor control vectors, the monitor control vectors storing the configuration information provided by the software component. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The event monitoring component of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, wherein each monitor control vector includes: 
<claim-text>a control field to specify a microarchitecture event to monitor; </claim-text>
<claim-text>a handler field, the handler field containing a pointer to a handler routine to process the profiles of the microarchitecture event; and </claim-text>
<claim-text>a trigger field to specify when the microarchitecture event is monitored. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The event monitoring component of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising: 
<claim-text>a profile buffer to store the captured profiles of the one or more microarchitecture events. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The event monitoring component of <dependent-claim-reference depends_on="CLM-00004">claim 4</dependent-claim-reference>, wherein the profile buffer comprises a first level buffer for initial storage of the captured profiles of the one or more microarchitecture events and a second level buffer for subsequent storage of the captured profiles of the one or more microarchitecture events. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The event monitoring component of <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference>, wherein the first level buffer is a register file. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The event monitoring apparatus of <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference>, wherein the second level buffer is a memory buffer that is architecturally visible to the software component. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The event monitoring apparatus of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the captured event profiles of each monitored microarchitecture events are made available to a handler routine selected by the software component for processing. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The event monitoring apparatus of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the event monitoring apparatus initiates an interrupt or special event handler to notify the software component when captured event profiles are available for processing. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. A microprocessor, comprising: 
<claim-text>an execution pipeline; </claim-text>
<claim-text>one or more event monitors coupled to the execution pipeline to selectively monitor one or more microarchitecture events in the execution of a program and to capture event profiles; </claim-text>
<claim-text>one or more monitor control vectors to store configuration information provided by a software component in connection with the operation of the one or more event monitors; and </claim-text>
<claim-text>a profile buffer to store captured microarchitecture event profiles. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The microprocessor of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein the captured profiles of the one or more microarchitecture events stored in the buffer are made available to a handler routine selected by the software component for optimization processing. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The microprocessor of <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, wherein the profile buffer comprises a first level buffer for initial storage of the captured microarchitecture event profiles and a second level buffer for subsequent storage of the captured microarchitecture event profiles. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The microprocessor of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, wherein the first level buffer is a register file. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The microprocessor of <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference>, wherein the second level buffer is a memory buffer that is architecturally visible to the software component. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The microprocessor of <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference>, wherein the first level buffer is comprised of a plurality of register frames and the second level buffer is comprised of a plurality of memory buffers, with one of the frames of the first level buffer and one of the memory buffers in the second level buffer being assigned to each monitored microarchitecture event. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The microprocessor of <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference>, wherein the profiles of a microarchitecture event stored in a frame assigned to the microarchitecture event in the first level buffer memory are spilled into a buffer assigned to the microarchitecture event in the second level memory buffer when the frame assigned to the microarchitecture event in the first level memory buffer is fully allocated or when a condition established by the software component is met. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The microprocessor of <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, wherein the captured profiles of a microarchitecture event are made available to the handler routine when the buffer assigned to the event in the second level memory buffer is fully allocated or when a condition established by the software component is met. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The microprocessor of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein each of the monitor control vectors includes: 
<claim-text>a control field to specify a microarchitecture event to monitor; </claim-text>
<claim-text>a handler field, the handler field containing a pointer to a handler routine for the microarchitecture event; and </claim-text>
<claim-text>a trigger field to specify when the microarchitecture event is monitored. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The microprocessor of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein the one or more microarchitecture events are monitored during an exception detection stage of the execution pipeline. </claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The microprocessor of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein the captured microarchitecture event profiles are stored in the memory buffer during a write back stage of the execution pipeline. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. A method comprising: 
<claim-text>receiving configuration information from a software component directing the monitoring of one or more microarchitecture events connected with the operation of a microprocessor in executing an application; </claim-text>
<claim-text>monitoring the one or more microarchitecture events and capturing profiles of the one or more microarchitecture events; </claim-text>
<claim-text>storing the captured event profiles in a profile buffer; and </claim-text>
<claim-text>making the profiles of the event available to the software component for optimization processing. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference>, wherein receiving the configuration information from the software component comprises receiving information regarding the setting of one or more monitor control vectors. </claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 22</dependent-claim-reference>, wherein each monitor control vector includes at least the following fields: 
<claim-text>a control field to specify the microarchitecture event to monitor; </claim-text>
<claim-text>a handler field, the handler field containing a pointer to a handler routine for processing of captured profiles of the microarchitecture event; and </claim-text>
<claim-text>a trigger field to specify when the microarchitecture event is monitored. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference>, wherein the profile buffer is comprised of a first stage for initial storage of the captured profiles of the one or more microarchitecture events and a second stage for subsequent storage of the captured profiles of the one or more microarchitecture events. </claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. The event monitoring component of <dependent-claim-reference depends_on="CLM-00022">claim 24</dependent-claim-reference>, wherein the first stage is a register file. </claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. The processor of <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>, wherein the second stage of the profile buffer is a memory architecturally visible to the software component. </claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 26</dependent-claim-reference>, further comprising assigning a register in the first stage and a memory buffer in the second stage to each monitored microarchitecture event. </claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 27</dependent-claim-reference>, further comprising storing the profiles of each monitored microarchitecture event in the register assigned to the microarchitecture event in the first stage as the profiles of the microarchitecture event are captured. </claim-text>
</claim>
<claim id="CLM-00029">
<claim-text><highlight><bold>29</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 27</dependent-claim-reference>, further comprising spilling the profiles of a microarchitecture event from the register assigned to the microarchitecture event in the first stage to the memory buffer assigned to the microarchitecture event in the second stage when the register is fully allocated or when a condition established by the software component is met. </claim-text>
</claim>
<claim id="CLM-00030">
<claim-text><highlight><bold>30</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 29</dependent-claim-reference>, further comprising notifying the software component when the register assigned to the event in the second stage of the memory buffer is fully allocated or when a condition established by the software component is met.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>2</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030004974A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030004974A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030004974A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030004974A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030004974A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030004974A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030004974A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030004974A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
