<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005247A1-20030102-D00000.TIF SYSTEM "US20030005247A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005247A1-20030102-D00001.TIF SYSTEM "US20030005247A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005247A1-20030102-D00002.TIF SYSTEM "US20030005247A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005247A1-20030102-D00003.TIF SYSTEM "US20030005247A1-20030102-D00003.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005247</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09974245</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20011009</filing-date>
</domestic-filing-data>
<foreign-priority-data>
<priority-application-number>
<doc-number>90111125</doc-number>
</priority-application-number>
<filing-date>20010510</filing-date>
<country-code>TW</country-code>
</foreign-priority-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F012/00</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>711</class>
<subclass>163000</subclass>
</uspc>
</classification-us-primary>
<classification-us-secondary>
<uspc>
<class>711</class>
<subclass>101000</subclass>
</uspc>
</classification-us-secondary>
</classification-us>
<title-of-invention>Memory access using system management interrupt and associated computer system</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Kuo-Chi</given-name>
<family-name>Chang</family-name>
</name>
<residence>
<residence-non-us>
<city>Taipei Hsien</city>
<country-code>TW</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
</inventors>
<correspondence-address>
<name-1>J.C. Patents, Inc.</name-1>
<name-2>Suite 250</name-2>
<address>
<address-1>4 Venture</address-1>
<city>Irvine</city>
<state>CA</state>
<postalcode>92618</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A method and computer system for accessing memory through a system management interrupt is disclosed. The computer system contains a CPU, a chipset and a memory unit. When the CPU receives a system management interrupt signal, the computer system enters a system management mode. In one embodiment, a software interrupt is invoked for achieving the purpose of accessing the memory space beyond 1 Mbytes. A system management interrupt signal is generated by the chipset while a software interrupt service routine associated with the software interrupt is running. The memory space beyond 1 Mbytes can therefore be accessed while the system management interrupt handler routine relative to the system management interrupt signal is running. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">CROSS-REFERENCE TO RELATED APPLICATION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> This application claims the priority benefit of Taiwan application serial no. 90111125, filed on May 10, 2001. </paragraph>
</section>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> 1. Field of Invention </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> The present invention relates to a memory access technique. More particularly, the present invention relates to a method of accessing memory whose memory address is greater than 1 Mbytes in a personal computer system. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> 2. Description of Related Art </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> Most conventional personal computer system runs on Intel&apos;s 80&times;86 central processing unit (CPU). The 80&times;86 type of CPU is capable of operating under two different modes: the real mode and the protected mode. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> A conventional computer system having the 80286 CPU has 20 address lines only and hence is able to address a memory space of up to 1 Mbytes. Intel&apos;s 80386 CPU has 32 address lines and hence is capable of addressing a memory space of up to 4 Gbytes. In real mode operation, however, the 80386 CPU has an effective bit width of 20 bits only. <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a schematic diagram showing the steps in a conventional method for accessing the memory space beyond the standard 1 Mbytes. As shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, if the CPU currently operates under the real mode <highlight><bold>100</bold></highlight>, the CPU needs to be switched into the protected mode <highlight><bold>120</bold></highlight> before accessing memory <highlight><bold>140</bold></highlight> at a location greater than the standard 1 Mbytes memory space. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> Due to design limitations of a conventional CPU, accessing memory space beyond the 1 Mbytes range is impossible when operating in the real mode. In the past, accessing the memory space beyond the standard 1 Mbytes range required that the system enters the protected mode. However, a task cannot recognize that whether the CPU is currently in the protected mode or not. Therefore, to access memory beyond the 1 Mbytes memory space, the CPU must first be detected before executing associated procedures or steps necessary for bringing the CPU into the protected mode. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> According to the aforementioned discussion, the conventional approach suggests a complicated way to access memory greater than or equal to 1 Mbytes because CPU has to enter the protected mode firstly. Furthermore, some tasks may be incapable of detecting the current operating mode of the CPU. Those tasks may bring the CPU into the protected mode again when the CPU is already in the protected mode. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> Accordingly, one object of the present invention is to provide a memory access method using system management interrupt so that the memory space of a computer system beyond the standard 1 Mbytes can still be accessed without entering the protected mode. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> To achieve these and other advantages and in accordance with the purpose of the invention, as embodied and broadly described herein, the invention provides a computer system using a memory access method that utilizes system management interrupt. The computer system includes at least a CPU. When the CPU receives a system management interrupt signal, the computer system starts operating in the system management mode and the CPU executes a system management interrupt handler routine. The method includes the following steps. First, a software interrupt is arisen for generating a system management interrupt signal. According to the system management interrupt signal, a system management interrupt handler routine is executed to access the data within the memory. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> According to the memory access method of this invention, the computer system further includes a chipset. The system management interrupt signal is provided and accessed by a system management interrupt command port of the chipset. The software interrupt service routine and system management interrupt handler routine are provided by the basic input/output system (BIOS). </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> This invention also provides an alternative memory access method through the system management interrupt. This method includes the following steps. First, a software interrupt is produced if the addressed memory lies beyond 1 Mbytes. A system management interrupt signal is produced during the execution of the software interrupt service routine. Thereafter, the system management interrupt handler routine is executed so that the memory space above the 1 Mbytes can be accessed while the system management interrupt handler routine is running. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> This invention also provides a computer system that utilizes system management interrupt to access memory. The computer system comprises a CPU, a chipset and a memory unit. The CPU is coupled to the chipset and the memory unit. When the CPU receives a system management interrupt signal, the computer system turns to operate in a system management mode. The chipset is used to arise the required system management interrupt signal. The computer system uses the aforementioned method to access the data residing in the memory unit addressed beyond 1 Mbytes. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> This invention provides a software interface for bringing a CPU into a system management mode and the system management interrupt handler routine is executed. Hence, memory location beyond 1 Mbytes can be easily accessed without disadvantages of conventional approaches. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> It is to be understood that both the foregoing general description and the following detailed description are exemplary, and are intended to provide further explanation of the invention as claimed.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> The accompanying drawings are included to provide a further understanding of the invention, and are incorporated in and constitute a part of this specification. The drawings illustrate embodiments of the invention and, together with the description, serve to explain the principles of the invention. In the drawings, </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a schematic diagram showing the steps in a conventional method for accessing the memory space beyond the standard 1M; </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a schematic diagram showing a computer system according to one preferred embodiment of this invention; and </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a schematic diagram showing the steps for accessing memory data using system management interrupt according to one preferred embodiment of this invention. </paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DESCRIPTION OF THE PREFERRED EMBODIMENTS </heading>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> Reference will now be made in detail to the present preferred embodiments of the invention, examples of which are illustrated in the accompanying drawings. Wherever possible, the same reference numbers are used in the drawings and the description to refer to the same or like parts. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> System management mode (SMM) is a special function inside a central processing unit (CPU such as a Pentium processor) of most personal computers. The SMM provides system designers with a type of firmware such as basic input/output system (BIOS) to control the computer. The SMM has a certain degree of transparency to the operating system (OS). Major characteristics of SMM include: </paragraph>
<paragraph id="P-0022" lvl="2"><number>&lsqb;0022&rsqb;</number> 1. The SMM has a system management interrupt (SMI) hardware interface and the associated chipset has an SMIOUT &num; pin. When the SMIOUT&num; pin of the chipset is enabled, the CPU proceeds into the SMM to execute the SMI handler routine provided by the BIOS. The SMI handler routine also has a 4Gbytes memory addressing capacity. </paragraph>
<paragraph id="P-0023" lvl="2"><number>&lsqb;0023&rsqb;</number> 2. The SMM has dedicated and safe memory space normally referred to as system management random access memory (SMRAM). The memory space is an area for storing SMI handler routine codes and dumping state codes of CPU. Hence, in the SMM, a firmware or BIOS handler is able to obtain the content inside CPU register, such as EAX and EBX, when SMI occurs. </paragraph>
<paragraph id="P-0024" lvl="2"><number>&lsqb;0024&rsqb;</number> 3. The SMM also has system management mode base (SMBase) addresses as well as default addresses. Moreover, these addresses can be reset. Furthermore, in a multiple processor (MP) system, different CPU has its own special SMBases. </paragraph>
<paragraph id="P-0025" lvl="2"><number>&lsqb;0025&rsqb;</number> 4. A resume (RSM) instruction can be used to leave SMM so that CPU can execute the program code immediately following the SMI. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> The BIOS is able to actuate a number of SMI handler routines under SMM to support other functions not supported or fully supported by the operating system (OS), for example: </paragraph>
<paragraph id="P-0027" lvl="2"><number>&lsqb;0027&rsqb;</number> 1. USB devices, e.g., keyboards, mouse and so on may be supported. In general, operating systems such as OS DOS and NT 4.0 that do not contain USB driver programs to drive a USB device and controller. Therefore, the chipset in cooperation with the BIOS may provide SMI hardware interrupt interface and associated handler to capture information from the output ports (port 60h and port 64h) of a conventional keyboard controller (for example, 8042) and to simulate functions of the USB device and controller. In other words, under OS DOS and NT 4.0, a USB device can still be used even without a USB driver program. </paragraph>
<paragraph id="P-0028" lvl="2"><number>&lsqb;0028&rsqb;</number> 2. Advanced power management (APM) device is supported. The BIOS provides INT 15 and relative software to the operating system for managing a power source. Hence, a power-saving mode can be performed. </paragraph>
<paragraph id="P-0029" lvl="2"><number>&lsqb;0029&rsqb;</number> 3. Motherboard main functions are supported. Motherboard designers who design special functions often use the SMI handler routine to achieve their desires. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> Because the system management mode (SMM) has the aforementioned characteristics, a computer system that utilizes the system management interrupt to access memory can be implemented. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a schematic diagram showing a computer system according to one preferred embodiment of this invention. As shown in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, the computer system includes a CPU <highlight><bold>200</bold></highlight>, a chipset <highlight><bold>220</bold></highlight> and a memory unit <highlight><bold>240</bold></highlight>. The CPU <highlight><bold>200</bold></highlight> is coupled to the chipset <highlight><bold>220</bold></highlight>. The chipset <highlight><bold>220</bold></highlight> has a SMIOUT &num; pin that connects with a corresponding SMI pin in the CPU <highlight><bold>200</bold></highlight>. When the CPU <highlight><bold>200</bold></highlight> receives a system management interrupt signal (that is, an enable signal from the SMIOUT&num; pin of the chipset) from the chipset <highlight><bold>220</bold></highlight>, the CPU <highlight><bold>200</bold></highlight> proceeds into the SMM and then actuates a SMI handler routine. The memory unit <highlight><bold>240</bold></highlight> is coupled to the CPU <highlight><bold>200</bold></highlight> for receiving and holding data. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> This invention provides a software interrupt interface in the BIOS. The software interrupt interface is capable of sending a command to the SMI command port so that the chipset <highlight><bold>220</bold></highlight> can enable the SMIOUT&num; pin and trigger the CPU <highlight><bold>200</bold></highlight> into the SMM. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a schematic diagram showing the steps for accessing memory data using system management interrupt according to one preferred embodiment of this invention. As shown in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>, to access memory data with an address beyond 1 Mbytes while the CPU is in the real mode <highlight><bold>100</bold></highlight>, the computer system invokes a software interrupt. According to this embodiment, a software interrupt service routine provided by the interrupt vector int 15h is used as a software interrupt interface <highlight><bold>160</bold></highlight>. A command is transmitted from the software interrupt interface <highlight><bold>160</bold></highlight> to the SMI command port so that the chipset can arise a system management interrupt (SMI) signal (an enable signal from the SMIOUT&num; pin) triggering the CPU into the SMM <highlight><bold>180</bold></highlight>. In the SMM <highlight><bold>180</bold></highlight>, the SMI handler routine is able to access the memory space whose addressing range beyond than 1 Mbytes. After a data access operation, a resume (RSM) instruction is arisen for jumping back to the software interrupt interface <highlight><bold>160</bold></highlight>. Thereafter, the software interrupt interface <highlight><bold>160</bold></highlight> utilizes an interrupt return (IRET) instruction to return the CPU into the real mode <highlight><bold>100</bold></highlight>. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> The following is a description of the steps for implementing the aforementioned memory access method through system management interrupt. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> To read the data from memory address E8000120H, the following program is used:  
<table-cwu id="TABLE-US-00001">
<number>1</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="49PT" align="left"/>
<colspec colname="1" colwidth="63PT" align="left"/>
<colspec colname="2" colwidth="105PT" align="left"/>
<thead>
<row>
<entry></entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
<entry>mov</entry>
<entry>edi, 0E8000000h;</entry>
</row>
<row>
<entry></entry>
<entry>mov</entry>
<entry>ebx, 120h;</entry>
</row>
<row>
<entry></entry>
<entry>mov</entry>
<entry>ah, 0A1h;</entry>
</row>
<row>
<entry></entry>
<entry>mov</entry>
<entry>al, 88h;</entry>
</row>
<row>
<entry></entry>
<entry>int</entry>
<entry>15h;</entry>
</row>
<row>
<entry></entry>
<entry>mov</entry>
<entry>eax, ecx</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> In the above program, the value stored inside the registers edi and ebx are actual memory addresses. The value 0A1h stored inside the register ah serves to inform the software interrupt interface and issue a SMI. The value 88h stored inside register al indicates a data read operation. The int 15h command initiates an interrupt operation. At the end of the interrupt operation, the value stored inside the register eax is the data retrieved from the memory address E8000120H. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> To write 000055AAH to the memory unit with an address E8000120H, the following program is suggested:  
<table-cwu id="TABLE-US-00002">
<number>2</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="49PT" align="left"/>
<colspec colname="1" colwidth="63PT" align="left"/>
<colspec colname="2" colwidth="105PT" align="left"/>
<thead>
<row>
<entry></entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
<entry>mov</entry>
<entry>edi, 0E8000000h;</entry>
</row>
<row>
<entry></entry>
<entry>mov</entry>
<entry>ebx, 120h;</entry>
</row>
<row>
<entry></entry>
<entry>mov</entry>
<entry>ecx, 000055Aah;</entry>
</row>
<row>
<entry></entry>
<entry>mov</entry>
<entry>ah, 0A1h;</entry>
</row>
<row>
<entry></entry>
<entry>mov</entry>
<entry>al, 89h;</entry>
</row>
<row>
<entry></entry>
<entry>int</entry>
<entry>15h</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> Similarly, the value of the registers edi and ebx are actual memory addresses. The register ecx stores the data to be written into the memory. The value 0A1h stored inside the register ah serves to inform the software interrupt interface and issue a SMI. The value 89h stored inside register al indicates a data write operation. The int 15h command initiates an interrupt operation. At the end of the interrupt operation, the value stored inside the register ecx is written to the memory address E8000120H. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> Furthermore, when the CPU is executing the software interrupt (int 15h) service routine within the BIOS, the software interrupt interface <highlight><bold>160</bold></highlight> access an SMI command port so that the chipset produces a system management interrupt signal (the SMIOUT&num; pin of the chipset is enabled). The chipset may generate a system management interrupt signal according to the following program, for example:  
<table-cwu id="TABLE-US-00003">
<number>3</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="91PT" align="left"/>
<colspec colname="2" colwidth="35PT" align="left"/>
<colspec colname="3" colwidth="70PT" align="left"/>
<thead>
<row>
<entry></entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
<entry>INT_15h_Service</entry>
<entry>Proc</entry>
<entry>far</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>.</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>.</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>.</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>cmp</entry>
<entry>ab, 0a1h;</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>jne</entry>
<entry>Not_Issue_SMI;</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>jmp</entry>
<entry>INT_Issue_SMI;</entry>
</row>
<row>
<entry></entry>
<entry>Not_Issue_SMI:</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>.</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>.</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>.</entry>
</row>
<row>
<entry></entry>
<entry>INT_15h_ServiceEndp</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> In the above interrupt service routine, the stored value inside the register a1 is compared with the value 0A1h. The chipset generates the system management interrupt signal (INT15_Issue_SMI) when there is a match.  
<table-cwu id="TABLE-US-00004">
<number>4</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="77PT" align="left"/>
<colspec colname="2" colwidth="35PT" align="left"/>
<colspec colname="3" colwidth="91PT" align="left"/>
<thead>
<row>
<entry></entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
<entry>INI15_Issue_SMI</entry>
<entry>Proc</entry>
<entry>far</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>Cmp</entry>
<entry>al, 00h;</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>Jc</entry>
<entry>Succ_Exit;</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>Push</entry>
<entry>dx;</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>Mov</entry>
<entry>dx, ACPI_PORT &plus; 2Fh;</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>Out</entry>
<entry>dx, al;</entry>
</row>
<row>
<entry></entry>
<entry>NEWIODELAY</entry>
</row>
<row>
<entry></entry>
<entry>NEWIODELAY</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>Pop</entry>
<entry>dx;</entry>
</row>
<row>
<entry></entry>
<entry>Succ_Exit:</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>Clc;</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>Retf</entry>
<entry>2;</entry>
</row>
<row>
<entry></entry>
<entry>INT15_Issue_SMI</entry>
<entry>Endp</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> In the above program provided by a chipset, the value stored inside the register al is first checked to determine whether to enters into the SMM or not. The SMI command port address (ACPI<highlight><subscript>13 </subscript></highlight>PORT&plus;2Fh) is put to dx. When the Out dx, al instruction is executed, the system management interrupt signal (INT15_Issue<highlight><subscript>&minus;</subscript></highlight>SMI) is produced by the chipset. Note that the values of all the registers in the CPU are put into the state dump area of the memory during the SMM. The write-in locations of the data are described in supplementary document <highlight><bold>1</bold></highlight>. In other words, the value inside the register (ecx), which is designed to hold write-in data, is stored inside the state dump area during a write-in operation. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> When the CPU receives the system management interrupt signal, the CPU <highlight><bold>100</bold></highlight> proceeds into the SMM <highlight><bold>180</bold></highlight> and executes a corresponding system management interrupt (SMI) handler routine to access the memory space greater than 1 Mbytes in the memory unit <highlight><bold>140</bold></highlight>. The SMI handler routine for carrying out actual data access can be explained using an example as follows:  
<table-cwu id="TABLE-US-00005">
<number>5</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>READ_OHCI_REG EQU 88h;</entry>
</row>
<row>
<entry>WRITE_OHCI_REG EQU 89h;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="98PT" align="left"/>
<colspec colname="2" colwidth="28PT" align="left"/>
<colspec colname="3" colwidth="91PT" align="left"/>
<tbody valign="top">
<row>
<entry>SW_SMI_For_Memory</entry>
<entry>Proc</entry>
<entry>Near</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="154PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Pushad;</entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry>Push</entry>
<entry>ds;</entry>
</row>
<row>
<entry></entry>
<entry>Mov</entry>
<entry>dx, ACPI_PORT &plus; 2Fh;</entry>
</row>
<row>
<entry></entry>
<entry>In</entry>
<entry>al, dx;</entry>
</row>
<row>
<entry></entry>
<entry>Cmp</entry>
<entry>al, READ_OHCI_REG;</entry>
</row>
<row>
<entry></entry>
<entry>Je</entry>
<entry>Is_1394_SMI;</entry>
</row>
<row>
<entry></entry>
<entry>Cmp</entry>
<entry>al, WRITE_OHCI_REG;</entry>
</row>
<row>
<entry></entry>
<entry>Je</entry>
<entry>Is_1394_SMI;</entry>
</row>
<row>
<entry></entry>
<entry>Jmp</entry>
<entry>1394_SMI_Exit</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> In the above program, the value in register al is first checked to determine if the value is 88h (read) or 89h (write) and then a read/write operation (Is<highlight><subscript>&mdash;</subscript></highlight>1394_SMI) is conducted. The read/write operation is executed according to the following program:  
<table-cwu id="TABLE-US-00006">
<number>6</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>Is_1394_SMI:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="154PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Push</entry>
<entry>ax;</entry>
</row>
<row>
<entry></entry>
<entry>Xor</entry>
<entry>ax, ax;</entry>
</row>
<row>
<entry></entry>
<entry>Mov</entry>
<entry>ds, ax;</entry>
</row>
<row>
<entry></entry>
<entry>Mov</entry>
<entry>si, 7FECh;</entry>
</row>
<row>
<entry></entry>
<entry>Mov</entry>
<entry>edi, dword ptr cs:&lsqb;si&rsqb;;</entry>
</row>
<row>
<entry></entry>
<entry>Mov</entry>
<entry>si, 7FDCh;</entry>
</row>
<row>
<entry></entry>
<entry>Mov</entry>
<entry>ebx, dword ptr cs:&lsqb;si&rsqb;;</entry>
</row>
<row>
<entry></entry>
<entry>Mov</entry>
<entry>si, 7FD4h;</entry>
</row>
<row>
<entry></entry>
<entry>Mov</entry>
<entry>ecx, dword ptr cs:&lsqb;si&rsqb;;</entry>
</row>
<row>
<entry></entry>
<entry>Pop</entry>
<entry>ax;</entry>
</row>
<row>
<entry></entry>
<entry>Cmp</entry>
<entry>al, READ_OHCI_REG;</entry>
</row>
<row>
<entry></entry>
<entry>Jne</entry>
<entry>WRITE_OHCI;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>Read_OHCI:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="154PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Mov</entry>
<entry>si, 7FD4h;</entry>
</row>
<row>
<entry></entry>
<entry>Mov</entry>
<entry>eax, dword ptr ds:&lsqb;edi &plus; ebx&rsqb;;</entry>
</row>
<row>
<entry></entry>
<entry>Mov</entry>
<entry>dword prt &emsp;cs:&lsqb;si&rsqb;, eax</entry>
</row>
<row>
<entry></entry>
<entry>Jmp</entry>
<entry>1394_SMI Exit;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>Write_OHCL:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="154PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Mov</entry>
<entry>dword prt &emsp;ds:&lsqb;edi &plus; ebx&rsqb;, ecx;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>1394_SMI Exit;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="154PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Pop</entry>
<entry>ds;</entry>
</row>
<row>
<entry></entry>
<entry>Pop</entry>
<entry>ad;</entry>
</row>
<row>
<entry></entry>
<entry>Ret</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="98PT" align="left"/>
<colspec colname="2" colwidth="119PT" align="left"/>
<tbody valign="top">
<row>
<entry>SW_SMI_For_Memory</entry>
<entry>Endp</entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> Before conducting any read or write operation, a memory address must be fetched. Hence, the program looks for an actual memory address (7FECH and 7FDCH in supplementary document <highlight><bold>1</bold></highlight>) in the stage dump area and transfer the address to the registers edi and ebx. Similarly, the value 7FD4H is also fetched and transferred to the register ecx. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> The value inside the register al is fetched and compared to determine if a read or a write operation is required. In a write operation, the value inside the register ecx is written into memory location indicated by the actual address (inside edi and ebx). In a read operation, however, data within the designated address is transferred into the register eax before moving the data into the location (7FD4H) within the state dump area where ecx data are held. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> At the end of the SMI handler routine, control right is returned to the software interrupt (int 15h) service routine and a full set of data within the state dump area is transferred back to the CPU. Hence, at the end of software interrupt (int 15h), data within the ecx register stores the actual memory data required for a read operation and data within the ecx register holds data that can be written into the memory for a write operation. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> Note that the aforementioned embodiment illustrates the method for accessing double word information form memory. However, the concept can be extended to the application of accessing whole a block of memory at a time. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> It will be apparent to those skilled in the art that various modifications and variations can be made to the structure of the present invention without departing from the scope or spirit of the invention. In view of the foregoing, it is intended that the present invention cover modifications and variations of this invention provided they fall within the scope of the following claims and their equivalents. </paragraph>
</section>
<section>
<heading lvl="1">Supplementary Document 1</heading>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number>  
<table-cwu id="TABLE-US-00007">
<number>7</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="105PT" align="left"/>
<colspec colname="2" colwidth="70PT" align="left"/>
<colspec colname="3" colwidth="42PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Offset</entry>
<entry></entry>
<entry></entry>
</row>
<row>
<entry>(Added to SMBASE &plus; 8000 H)</entry>
<entry>Register</entry>
<entry>Writable</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>7FFCH</entry>
<entry>CR0</entry>
<entry>No</entry>
</row>
<row>
<entry>7FF8H</entry>
<entry>RC3</entry>
<entry>No</entry>
</row>
<row>
<entry>7FF4H</entry>
<entry>EFLAGSCR0</entry>
<entry>Yes</entry>
</row>
<row>
<entry>7FF0H</entry>
<entry>EIP</entry>
<entry>Yes</entry>
</row>
<row>
<entry>7FECH</entry>
<entry>EDI</entry>
<entry>Yes</entry>
</row>
<row>
<entry>7FE8H</entry>
<entry>ESI</entry>
<entry>Yes</entry>
</row>
<row>
<entry>7FE4H</entry>
<entry>EBP</entry>
<entry>Yes</entry>
</row>
<row>
<entry>7FE0H</entry>
<entry>ESP</entry>
<entry>Yes</entry>
</row>
<row>
<entry>7FDCH</entry>
<entry>EBX</entry>
<entry>Yes</entry>
</row>
<row>
<entry>7FD8H</entry>
<entry>EDX</entry>
<entry>Yes</entry>
</row>
<row>
<entry>7FD4H</entry>
<entry>ECX</entry>
<entry>Yes</entry>
</row>
<row>
<entry>7FD0H</entry>
<entry>EAX</entry>
<entry>Yes</entry>
</row>
<row>
<entry>7FCCH</entry>
<entry>DR6</entry>
<entry>No</entry>
</row>
<row>
<entry>7FC8H</entry>
<entry>ER7</entry>
<entry>No</entry>
</row>
<row>
<entry>7FC4H</entry>
<entry>TR*</entry>
<entry>No</entry>
</row>
<row>
<entry>7FC0H</entry>
<entry>LDTBase*</entry>
<entry>No</entry>
</row>
<row>
<entry>7FBCH</entry>
<entry>GS*</entry>
<entry>No</entry>
</row>
<row>
<entry>7FB8H</entry>
<entry>FS*</entry>
<entry>No</entry>
</row>
<row>
<entry>7FB4H</entry>
<entry>DS*</entry>
<entry>No</entry>
</row>
<row>
<entry>7FB0H</entry>
<entry>SS*</entry>
<entry>No</entry>
</row>
<row>
<entry>7FACH</entry>
<entry>CS8</entry>
<entry>No</entry>
</row>
<row>
<entry>7FA8H</entry>
<entry>ES*</entry>
<entry>No</entry>
</row>
<row>
<entry>7FA7H-7F04H</entry>
<entry>Reserved</entry>
<entry>No</entry>
</row>
<row>
<entry>7F02H</entry>
<entry>Auto HALT Restart</entry>
<entry>Yes</entry>
</row>
<row>
<entry></entry>
<entry>Field (Word)</entry>
</row>
<row>
<entry>7F00H</entry>
<entry>SMM Revision</entry>
<entry>No</entry>
</row>
<row>
<entry></entry>
<entry>Identifier Field</entry>
</row>
<row>
<entry></entry>
<entry>(Double Word)</entry>
</row>
<row>
<entry>7EF8H</entry>
<entry>SMBASE Field</entry>
<entry>Yes</entry>
</row>
<row>
<entry></entry>
<entry>(Double Word)</entry>
</row>
<row>
<entry>7EF7H-7E00H</entry>
<entry>Reserved</entry>
<entry>No</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A memory access method for a computer system, a memory unit of said computer system having a first addressing range and a second addressing range wherein said second addressing range is beyond a pre-determined threshold, said computer system accessing said first addressing range under a first operating mode and accesses said second addressing range under a second operating mode, said method comprising: 
<claim-text>invoking a software interrupt to arise a system management interrupt signal while said computer system has to access said memory unit in said second addressing range; and </claim-text>
<claim-text>executing a system management interrupt handler routine for accessing said memory unit from said second addressing range under a system management mode instead of entering said second operating mode while receiving said system management interrupt signal. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The memory access method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein said computer system includes a chipset for arising said system management interrupt signal according to a software interrupt invoked from a central processing unit (CPU) of said computer system. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The memory access method of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, wherein a software interrupt service routine provided by a basic input/output system (BIOS) unit of said computer system is responsive to said software interrupt to actuate said chipset for arising said system management interrupt signal. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The memory access method of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, wherein said CPU operates in said first operating mode while invoking said software interrupt. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The memory access method of <dependent-claim-reference depends_on="CLM-00004">claim 4</dependent-claim-reference>, wherein said first operating mode is a real mode of said computer system and said second operating mode is a protected mode of said computer system. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The memory access method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein said second addressing range is a memory space beyond 1 Mbytes. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The memory access method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein said system management mode comprises an interrupt return for returning said computer system back to said first operating mode. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. A memory access method for a computer system that runs in a protected mode and a real mode, a memory unit of said computer system having a first addressing range and a second addressing range wherein said second addressing range is beyond a pre-determined threshold, said computer system accessing said first addressing range under said real mode and accesses said second addressing range under said protected mode, said method comprising: 
<claim-text>invoking a software interrupt by a central processing unit (CPU) of said computer system while said computer system accesses said memory unit in said second addressing range, wherein said CPU currently operates under said real mode; </claim-text>
<claim-text>arising a system management interrupt signal according to said software interrupt; and </claim-text>
<claim-text>executing a system management interrupt handler routine for accessing said memory unit in said second addressing range under a system management mode instead of entering said protected mode while receiving said system management interrupt signal. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The memory access method of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference>, wherein said computer system includes a chipset for arising said system management interrupt signal. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The memory access method of <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, wherein a software interrupt service routine provided by a basic input/output system (BIOS) unit of said computer system is responsive to said software interrupt to actuate said chipset for arising said system management interrupt signal. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The memory access method of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference>, wherein said second addressing range is a memory space beyond 1 Mbytes. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The memory access method of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference>, wherein said system management mode comprises an interrupt return for returning said CPU back to operate in said real mode. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. A computer system capable of running in a real mode and a protected mode comprising: 
<claim-text>a chipset for arising a system management interrupt signal; </claim-text>
<claim-text>a memory unit having memory spaces being separated into a first addressing range and a second addressing range, wherein said second addressing range is beyond a pre-determined threshold, said first addressing range being accessed under said real mode and said second addressing range being accessed under said protected mode; and </claim-text>
<claim-text>a center processing unit (CPU) coupled to said memory unit and said chipset for entering a system management mode while receiving said system management interrupt signal, for executing a system management interrupt handler routine after entering said system management mode, and for accessing said memory unit under said system management mode, wherein when said CPU has to access said memory unit within said second addressing range and said CPU currently operates in said real mode, said CPU invokes a software interrupt to execute a system management interrupt handler routine so that said chipset can generate said system management interrupt signal to make said CPU to access said memory unit in said second addressing range under a system management mode instead of entering said protected mode. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The computer system of <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference>, wherein said software interrupt is sent from said CPU to a system management interrupt command port of said chipset to arise said system management interrupt signal. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The computer system of <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference>, wherein said memory unit of said second addressing range being accessed while said CPU is still executing said system management interrupt handler routine. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The computer system method of <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference>, wherein a software interrupt service routine provided by a basic input/output system (BIOS) unit of said computer system is responsive to said software interrupt to actuate said chipset for arising said system management interrupt signal.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>2</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005247A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005247A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005247A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005247A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
