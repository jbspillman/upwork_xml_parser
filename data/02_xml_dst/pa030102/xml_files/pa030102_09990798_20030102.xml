<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005256A1-20030102-D00000.TIF SYSTEM "US20030005256A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005256A1-20030102-D00001.TIF SYSTEM "US20030005256A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005256A1-20030102-D00002.TIF SYSTEM "US20030005256A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005256A1-20030102-D00003.TIF SYSTEM "US20030005256A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005256A1-20030102-D00004.TIF SYSTEM "US20030005256A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005256A1-20030102-D00005.TIF SYSTEM "US20030005256A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030005256A1-20030102-D00006.TIF SYSTEM "US20030005256A1-20030102-D00006.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005256</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>09990798</doc-number>
</application-number>
<application-number-series-code>09</application-number-series-code>
<filing-date>20011114</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F012/00</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>711</class>
<subclass>202000</subclass>
</uspc>
</classification-us-primary>
<classification-us-secondary>
<uspc>
<class>711</class>
<subclass>220000</subclass>
</uspc>
</classification-us-secondary>
</classification-us>
<title-of-invention>Mechanism to reduce the cost of forwarding pointer aliasing</title-of-invention>
</technical-information>
<continuity-data>
<non-provisional-of-provisional>
<document-id>
<doc-number>60299244</doc-number>
<document-date>20010619</document-date>
<country-code>US</country-code>
</document-id>
</non-provisional-of-provisional>
</continuity-data>
<inventors>
<first-named-inventor>
<name>
<given-name>Jeffrey</given-name>
<middle-name>P.</middle-name>
<family-name>Grossman</family-name>
</name>
<residence>
<residence-us>
<city>Cambridge</city>
<state>MA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Thomas</given-name>
<middle-name>F.</middle-name>
<family-name>Knight</family-name>
<name-suffix>JR.</name-suffix>
</name>
<residence>
<residence-us>
<city>Belmont</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Jeremy</given-name>
<middle-name>H.</middle-name>
<family-name>Brown</family-name>
</name>
<residence>
<residence-us>
<city>Cambridge</city>
<state>MA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Andrew</given-name>
<middle-name>S.</middle-name>
<family-name>Huang</family-name>
</name>
<residence>
<residence-us>
<city>Cambridge</city>
<state>MA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>HAMILTON, BROOK, SMITH &amp; REYNOLDS, P.C.</name-1>
<name-2></name-2>
<address>
<address-1>530 VIRGINIA ROAD</address-1>
<address-2>P.O. BOX 9133</address-2>
<city>CONCORD</city>
<state>MA</state>
<postalcode>01742-9133</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">Short-quasi-unique-identifiers (SQUIDs) are generated and assigned to the data objects stored in memory. Pointers to a particular data object contain the data object&apos;s assigned SQUID. If a data object is moved to a second allocated memory segment, a new pointer to the second allocated memory segment is placed at the original memory segment, so that any pointers to the original memory segment now point to the new pointer. The distribution of SQUIDs is uniform. SQUIDs can be generated by counting, generated randomly, generating through some hashing mechanism, or other means. In comparing two different pointers, it is determined that the two pointers do not reference the same data object if the SQUIDs are different. On the other hand, if the SQUIDs are identical and the address fields of the two pointers are identical, then the two pointers reference the same data object. In addition, a pointer is associated with a migration indicator field which indicates the number of migrations of the referenced data object prior to the pointer being created. The comparator determines that two pointers do not reference the same data object if their associated migration indicators indicate identical numbers of migrations and their corresponding addresses are different. </paragraph>
</subdoc-abstract>
<subdoc-description>
<cross-reference-to-related-applications>
<heading lvl="1">RELATED APPLICATION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> This application claims the benefit of U.S. Provisional Application No. 60/299,244, filed on Jun. 19, 2001. </paragraph>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> The entire teachings of the above application are incorporated herein by reference.</paragraph>
</cross-reference-to-related-applications>
<federal-research-statement>
<heading lvl="1">GOVERNMENT SUPPORT </heading>
<paragraph-federal-research-statement id="P-0003"><number>&lsqb;0003&rsqb;</number> The invention was supported, in whole or in part, by a grant F30602-98-1-0172 from Air Force Research Lab. The Government has certain rights in the invention.</paragraph-federal-research-statement>
</federal-research-statement>
<summary-of-invention>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> Forwarding pointers are an architectural mechanism that allow references to a memory location to be transparently forwarded to another location. Known variously as &ldquo;invisible pointers,&rdquo; &ldquo;forwarding pointers&rdquo; and &ldquo;memory forwarding,&rdquo; they are familiar to the hardware community but to date have been incorporated into very few architectures. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> One reason that forwarding pointers have received little support is that they have been perceived as possessing limited utility. Recently, however, it has become apparent that forwarding pointers are indeed useful constructs that can expedite program execution. Chi-Keung Luk and Todd C. Mowry, &ldquo;Memory Forwarding: Enabling Aggressive Layout Optimizations by Guaranteeing the Safety of Data Relocation,&rdquo; Proc. ISCA 1999, pp. 88-99 (hereafter &ldquo;Luk&rdquo;), incorporated by reference herein in its entirety, show that using forwarding pointers to perform safe data relocation can result in significant performance gains on arbitrary programs written in C, speeding up some applications by more than a factor of two. Jeremy Brown, &ldquo;Memory Management on a Massively Parallel Capability Architecture&rdquo;, Ph.D. thesis proposal, M.I.T., December 1999, gives an algorithm for performing asynchronous local compacting garbage collection in a massively parallel distributed system. This algorithm uses forwarding pointers to avoid the high run-time costs usually associated with such a system. Thus, there is growing motivation to include hardware support for forwarding pointers in novel architectures. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> A second and perhaps more significant reason that forwarding pointers have received little attention from hardware designers is that they introduce aliasing&mdash;that is, it is possible for two different pointers to resolve to the same word in memory. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1A</cross-reference> illustrates how aliasing occurs. A first pointer P<highlight><subscript>2 </subscript></highlight><highlight><bold>14</bold></highlight> points directly to some target data <highlight><bold>16</bold></highlight>. A second, indirect pointer, P<highlight><subscript>1 </subscript></highlight><highlight><bold>10</bold></highlight> points to a forwarding pointer <highlight><bold>12</bold></highlight> which in turn points to the target data <highlight><bold>16</bold></highlight>. Thus, pointers P<highlight><subscript>1 </subscript></highlight>and P<highlight><subscript>2</subscript></highlight>, which hold different values, resolve to the same target data <highlight><bold>16</bold></highlight>. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 1B and 1C</cross-reference> illustrate one manner in which such a scenario can occur. Here, two data objects A <highlight><bold>4</bold></highlight> and D <highlight><bold>16</bold></highlight> are stored in a memory <highlight><bold>2</bold></highlight>A (<cross-reference target="DRAWINGS">FIG. 1B</cross-reference>), with a pointer P<highlight><subscript>1 </subscript></highlight><highlight><bold>10</bold></highlight> directly referencing data object D <highlight><bold>16</bold></highlight>. As a result of data compaction or other operations, data object D <highlight><bold>16</bold></highlight> is moved, as shown in memory <highlight><bold>2</bold></highlight>B (<cross-reference target="DRAWINGS">FIG. 1C</cross-reference>), and a new forwarding pointer <highlight><bold>12</bold></highlight> is inserted into data object D&apos;s old location. Thus pointer P<highlight><subscript>1 </subscript></highlight><highlight><bold>10</bold></highlight> now points to the forwarding pointer <highlight><bold>12</bold></highlight> which points to the new location of data object D <highlight><bold>16</bold></highlight>. Pointer P<highlight><subscript>1 </subscript></highlight><highlight><bold>10</bold></highlight> is therefore now an indirect pointer. Meanwhile, a new direct pointer P<highlight><subscript>2 </subscript></highlight><highlight><bold>14</bold></highlight> has been created which points to the new location of data object <highlight><bold>16</bold></highlight>, resulting in the combination of pointers pictured in <cross-reference target="DRAWINGS">FIG. 1A</cross-reference>. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> The presence of this aliasing necessarily introduces run time costs in order to ensure correctness of execution. In Luk, two specific problems are identified. First, direct pointer comparisons are no longer a safe operation; some mechanism must be provided for determining the final addresses of the pointers. Second, seemingly independent memory operations may no longer be reordered in out-of-order machines. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> In Luk, the problem of pointer comparisons is addressed by inserting code to determine the final address for each pointer, unless the compiler is able to determine that the pointers do not point to relocated objects. The overhead of this approach is potentially large. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> In the best case, both target memory words will be resident in the cache, neither of them will contain a forwarding pointer, and the pointer comparison will be slowed down by roughly an order of magnitude. However, since pointer comparisons often precede a decision to perform operations on an object, a common case will be when one or both dereferences cause a cache miss, slowing down the comparison by another order of magnitude. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> The solution proposed by Luk for reordering memory operations is to use &ldquo;data dependence speculation,&rdquo; which allows loads to execute speculatively before it is known that they are independent of any preceding stores. In an architecture that supports data dependence speculation, it is fairly easy to extend the hardware to operate correctly in the presence of forwarding pointers. Luk found that this solution is effective as incorrect speculation occurs only rarely. However, Luk assumes the presence of some fairly complex hardware. For architectures in which silicon area efficiency is a concern, a lower cost alternative is preferable. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> The forwarding pointer aliasing problem is an instance of the more general challenge of determining object identity in the presence of multiple and/or changing names. This problem has been studied explicitly. See, for example, Setrag N. Khoshafian, George P. Copeland, &ldquo;Object Identity&rdquo;, Proc. 1986 ACM Conference on Object Oriented Programming Systems, Languages and Applications, pp. 406-416, incorporated by reference herein in its entirety. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> A natural solution which has appeared time and again is the use of system-wide unique object IDs or UIDs. UIDs completely solve the aliasing problem, but have two disadvantages. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> First, the use of UIDs to reference objects requires an expensive translation each time an object is referenced to obtain the virtual address of the object. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> Second, quite a few bits are required to ensure that there are enough UIDs for all objects and that globally unique IDs can be easily generated in a distributed computing environment. In a large system, at least sixty-four bits would likely be required in order to avoid any expensive garbage collection of UIDs and to allow each processor to allocate UIDs independently. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> In the worst case, one of the pointers points to data which is not even resident in main memory. This can occur frequently in programs that deal with massive datasets. It is desirable to be able to compare pointers without having to dereference them. By using short quasi-unique identifiers (SQUIDs), it is possible to do so in the majority of cases. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> SQUIDs maintain one of the advantages of UIDs, namely they allow pointers to different objects to be distinguished quickly, and with high probability. Because SQUIDs are not unique, they can be much shorter than UIDs, comprising only a small number of bits, while still providing similar functionality. Furthermore, SQUIDs do not require any translation tables, since they are a part of the pointer format. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> Therefore, in accordance with one aspect of the present invention, a data processing system comprises memory for storing data objects, where the data objects are referenced by pointers. A short-quasi-unique-identifier (SQUID) generator generates and assigns SQUIDs to data objects stored in the memory segment. Pointers to a particular data object contain the data object&apos;s assigned SQUID. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> The system further comprises a memory allocator which allocates a segment of the memory to a data object. If the data object is moved to a second allocated memory segment, for example, due to resizing, data compaction or garbage collection, a new pointer to the second allocated memory segment is placed at the original memory segment, so that any pointers to the original memory segment now point to the new pointer. The data object might also be moved from a first memory to a second memory within a distributed system. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> In at least one embodiment, the distribution of SQUIDs over a range is uniform. SQUIDs can be generated by counting, generated randomly, generating through some hashing mechanism, or other means. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> Where two different pointers must be compared, a comparator compares their respective SQUIDs. The comparator determines that the two pointers do not reference the same data object if the SQUIDs are different. On the other hand, the comparator determines that the two pointers reference the same data object if the SQUIDs are identical and the address fields of the two pointers are identical. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> In at least one embodiment, each pointer address field comprises a base address and an offset, and the comparator determines that the two pointers do not reference identical locations within a referenced data object if the pointers&apos; offsets are not identical. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> SQUIDs can be implemented either in hardware, or software, or a combination. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> According to another aspect of the invention, a pointer is associated with a migration indicator field which indicates the number of migrations of the referenced data object prior to the pointer being created. The comparator determines that two pointers do not reference the same data object if their associated migration indicators indicate identical numbers of migrations and their corresponding addresses are different. The migration indicator can comprise just one bit, or may comprise multiple bits. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> In at least one embodiment of the present invention, pointers are guarded pointers.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> The foregoing and other objects, features and advantages of the invention will be apparent from the following more particular description of preferred embodiments of the invention, as illustrated in the accompanying drawings in which like reference characters refer to the same parts throughout the different views. The drawings are not necessarily to scale, emphasis instead being placed upon illustrating the principles of the invention. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1A</cross-reference> is a schematic diagram illustrating the concept of forwarding pointer aliasing. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 1B and 1C</cross-reference> are schematic diagrams illustrating one manner in which the scenario of <cross-reference target="DRAWINGS">FIG. 1A</cross-reference> can come about. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a block diagram of an embodiment of the present invention. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a schematic diagram illustrating a simple SQUID embodiment of the present invention. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> FIGS. <highlight><bold>4</bold></highlight>A-<highlight><bold>4</bold></highlight>E are schematic diagrams illustrating the different scenarios described in Table 1. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a schematic diagram illustrating how the invention can be used in deciding whether to reorder instructions. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is a schematic diagram illustrating an embodiment of the present invention that utilizes SQUIDs and a one-bit migration indicator. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> is a schematic diagram illustrating an embodiment of the present invention that utilizes SQUIDs and a multiple-bit migration indicator. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> is a schematic diagram illustrating an application of the present invention to guarded pointers.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF THE INVENTION </heading>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> A description of preferred embodiments of the invention follows. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> The present invention is a simple mechanism which can be used to reduce the cost of forwarding pointer aliasing. Each object is assigned a short random tag, to be stored in each pointer to the object. This tag is similar in role to a unique identifier (UID), but is not necessarily unique. These tags are referred to as Short Quasi-Unique IDentifiers, or SQUIDs. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> illustrates an embodiment in which a memory <highlight><bold>100</bold></highlight> can hold many different data objects <highlight><bold>102</bold></highlight>, two of which are shown. Unused memory space from the memory <highlight><bold>100</bold></highlight> is allocated to a new data object by a memory allocator <highlight><bold>104</bold></highlight> when the data object is first created. A SQUID is generated by a SQUID generator <highlight><bold>106</bold></highlight>, and supplied to the memory allocator <highlight><bold>104</bold></highlight>. The memory allocator <highlight><bold>104</bold></highlight> generates a pointer to the data object. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> Thereafter, new pointers need by various applications <highlight><bold>112</bold></highlight> are generated by a pointer copier <highlight><bold>114</bold></highlight> that copies existing pointers. Since the SQUID is part of the pointer format, it is copied when an existing pointer is copied. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> For example, when a device such as garbage collector <highlight><bold>108</bold></highlight> moves an object, it references the object through a pointer. When the object is moved, a forwarding pointer, pointing to the object&apos;s new location and generated for example by a pointer generator <highlight><bold>110</bold></highlight>, is left at the old location. The SQUID from the referencing pointer is copied by the pointer generator <highlight><bold>110</bold></highlight> into the forwarding pointer. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> In the common case, SQUIDs allow pointer comparison and memory operation reordering to proceed with no overhead. Only in rare cases is it necessary to degrade performance to ensure correctness. Thus, SQUIDs allow an architecture to support forwarding pointers with reduced average run-time overhead. Furthermore, this overhead can be eliminated altogether if the software chooses not to make use of forwarding pointers. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> As shown in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>, to implement SQUIDs, a pointer <highlight><bold>20</bold></highlight> according to the present invention comprises an address field <highlight><bold>21</bold></highlight> augmented with a short n-bit tag field <highlight><bold>23</bold></highlight>, where n is, for example, from eight to sixteen bits in length. This tag field <highlight><bold>23</bold></highlight> is filled with a SQUID which is assigned a value when an object is allocated. Preferably, SQUIDs are assigned according to a uniform distribution over some range. Such assignment could be implemented, for example, by a simple counting function, randomly, or by a hashing function. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> Unlike a UID, two pointers with the same SQUID might not point to the same object. However, two pointers with different SQUIDs necessarily point to different objects. In many cases this fact alone can be used to avoid the run-time costs of forwarding pointer aliasing. </paragraph>
<paragraph id="P-0045" lvl="7"><number>&lsqb;0045&rsqb;</number> Pointer Comparisons </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> An address is typically logically divided into a base <highlight><bold>21</bold></highlight>A and an offset <highlight><bold>21</bold></highlight>B. Two pointers can be efficiently compared by examining their base addresses, offsets and SQUIDs. Table 1 below illustrates the different possible scenarios. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> In CASES 1 and 2, if the base addresses are the same, then the pointers point to the same object, and the pointers are the same if and only if they have the same offset into the object. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4A</cross-reference> illustrates CASE 1. Two pointers <highlight><bold>60</bold></highlight>, <highlight><bold>62</bold></highlight> have identical SQUIDs, base addresses and offsets. Therefore, they both pont to the same data at address <highlight><bold>104</bold></highlight> in data object, Object A <highlight><bold>66</bold></highlight> within the memory <highlight><bold>64</bold></highlight>. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4B</cross-reference> illustrates CASE 2, in which only the offsets of the two pointers <highlight><bold>60</bold></highlight>, <highlight><bold>62</bold></highlight> are different. In this case, the pointers <highlight><bold>60</bold></highlight>, <highlight><bold>62</bold></highlight> both point to the same object, Object A <highlight><bold>66</bold></highlight>, but they point to different data, pointer <highlight><bold>60</bold></highlight> pointing to data located at address <highlight><bold>104</bold></highlight> and pointer <highlight><bold>62</bold></highlight> pointing to data located at address <highlight><bold>132</bold></highlight> </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> As <cross-reference target="DRAWINGS">FIG. 4C</cross-reference> illustrates, if, as in CASE 3, the SQUIDs are different, then the pointers <highlight><bold>60</bold></highlight>, <highlight><bold>62</bold></highlight> point to different objects, here shown as Object A <highlight><bold>66</bold></highlight> and Object B <highlight><bold>68</bold></highlight>. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> It is only in CASE 4, that is, in the case that the base addresses are different but the SQUIDs and offsets are the same, that it is necessary to perform expensive dereferencing operations to determine whether or not the final addresses are equal.  
<table-cwu id="TABLE-US-00001">
<number>1</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="5">
<colspec colname="OFFSET" colwidth="35PT" align="left"/>
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="28PT" align="left"/>
<colspec colname="3" colwidth="35PT" align="left"/>
<colspec colname="4" colwidth="84PT" align="left"/>
<thead>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="4" align="center">TABLE 1</entry>
</row>
<row>
<entry></entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="4" align="center" rowsep="1"></entry>
</row>
<row>
<entry></entry>
<entry>SQUIDS</entry>
<entry>BASES</entry>
<entry>OFFSETS</entry>
<entry>POINTERS</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="4" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="5">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="35PT" align="left"/>
<colspec colname="3" colwidth="28PT" align="left"/>
<colspec colname="4" colwidth="35PT" align="left"/>
<colspec colname="5" colwidth="84PT" align="left"/>
<tbody valign="top">
<row>
<entry>CASE 1</entry>
<entry>SAME</entry>
<entry>SAME</entry>
<entry>SAME</entry>
<entry>SAME</entry>
</row>
<row>
<entry>CASE 2</entry>
<entry>SAME</entry>
<entry>SAME</entry>
<entry>DIFF</entry>
<entry>Point to same object, but</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry></entry>
<entry></entry>
<entry>different offsets, so</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry></entry>
<entry></entry>
<entry>pointers are DIFFERENT</entry>
</row>
<row>
<entry>CASE 3</entry>
<entry>DIFF</entry>
<entry>X</entry>
<entry>X</entry>
<entry>DIFFERENT</entry>
</row>
<row>
<entry>CASE 4</entry>
<entry>SAME</entry>
<entry>DIFF</entry>
<entry>SAME</entry>
<entry>Must be resolved</entry>
</row>
<row><entry namest="1" nameend="5" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> It can be argued that this latter case, i.e., CASE 4, will be rare. It occurs in two circumstances: either the pointers reference different objects which have the same SQUID, or the pointers reference the same object through different levels of indirection. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4D</cross-reference> illustrates a first scenario for CASE 4, in which the two pointer <highlight><bold>60</bold></highlight>, <highlight><bold>62</bold></highlight> point to different objects, Object A <highlight><bold>66</bold></highlight> and Object B <highlight><bold>68</bold></highlight>, whose SQUIDs have the same value, i.e., 23 in this example. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4E</cross-reference> illustrates the second scenario for CASE 4, in which the second pointer <highlight><bold>62</bold></highlight> indirectly points to the same object, i.e., Object A <highlight><bold>66</bold></highlight>, as the first pointer <highlight><bold>60</bold></highlight>, through a forwarding pointer <highlight><bold>70</bold></highlight>. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> The former scenario (<cross-reference target="DRAWINGS">FIG. 4D</cross-reference>) occurs with probability 2<highlight><superscript>&minus;n</superscript></highlight>. The latter scenario (<cross-reference target="DRAWINGS">FIG. 4E</cross-reference>) is application dependent, but we note that (1) applications tend to compare pointers to different objects more frequently than they compare pointers to the same object, and (2) the results of the simulations in Luk indicate that it is reasonable to expect the majority of pointers to migrated data to be updated, so that two pointers to the same object will usually have the same level of indirection. </paragraph>
<paragraph id="P-0056" lvl="7"><number>&lsqb;0056&rsqb;</number> Reordering Memory Operations </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> As <cross-reference target="DRAWINGS">FIG. 5</cross-reference> illustrates, in a similar manner, a decision can be made, most likely by hardware, as to whether or not it is possible to reorder memory operations based on SQUIDs. Two pointers <highlight><bold>120</bold></highlight>, <highlight><bold>122</bold></highlight> are compared by a comparator <highlight><bold>124</bold></highlight>. An instruction reorderor <highlight><bold>126</bold></highlight> decides whether to reorder instructions based on the output of the comparator <highlight><bold>124</bold></highlight>. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> If the two pointers <highlight><bold>120</bold></highlight>, <highlight><bold>122</bold></highlight> have different offsets or different SQUIDs then the corresponding operations can be safely reordered. If the offsets and the SQUIDs are the same, then the operations are not reordered. No other mechanism is required to guarantee correctness of execution, and the probability of failing to reorder references to different objects is 2<highlight><superscript>&minus;n</superscript></highlight>. </paragraph>
<paragraph id="P-0059" lvl="7"><number>&lsqb;0059&rsqb;</number> Improving Performance </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> The use of SQUIDs reduces the average overhead necessary to check for aliasing to a small but still non-zero amount. Ideally, pointers to objects which are never migrated should incur no overhead whatsoever. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> As illustrated in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>, this can be achieved by adding a single &lsquo;migrated&rsquo; bit (M) <highlight><bold>25</bold></highlight> to the pointer <highlight><bold>30</bold></highlight> to indicate whether or not the pointer points to the original address at which the object was allocated. When a new object is created, pointers to that object have M&equals;0. When the object is migrated, pointers to the new location (and all subsequent locations) have M&equals;1. If two pointers each with M&equals;0 are being compared (either as the result of a user comparison instruction, or to determine whether or not memory operations can be reordered), the SQUIDs can be ignored and the comparison performed based on the addresses alone, and in fact, this migration bit <highlight><bold>25</bold></highlight> can be used without SQUIDs. Hence, there is no runtime cost associated with support for forwarding pointers until the software makes use of them. </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> As illustrated in <cross-reference target="DRAWINGS">FIG. 7</cross-reference>, the migration indicator <highlight><bold>27</bold></highlight> can be expanded to multiple bits to indicate the migration generation, that is, the number of times the data has moved Pointers having migration indicators <highlight><bold>27</bold></highlight> that are equal (but not saturated&mdash;see below) can be compared without reference to the SQUIDs. When comparing two pointers having different values in their respective migration indicators, it is only necessary to dereference one of the pointers until the migration indicators match, at which point a valid address comparison can be performed. Of course, a pointer&apos;s migration indicator must saturate at some maximum value determined by its length, at which point it is not valid to use the migration indicator to compare pointers. </paragraph>
<paragraph id="P-0063" lvl="7"><number>&lsqb;0063&rsqb;</number> Hardware and Software Overhead </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> The only software overhead required to support SQUIDs is the code that generates them when objects are allocated. This adds just a few instructions to memory allocation. A trap handler is needed to check for aliasing when comparing different addresses with the same SQUID, but this code (or an equivalent hardware mechanism) is a general requirement for supporting forwarding pointers without UIDs and is not specific to the implementation of SQUIDs. Moreover, placing a single copy of this code in a trap handler creates much less software overhead than inlining the code at every pointer comparison as suggested by Luk. </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> In order to be effective, SQUIDs require only a small number of bits to be added to the pointer. For example, if eight bits are added (seven SQUID bits and one migrated bit), then the probability of failing to distinguish pointers to different objects is less than 0.008. The hardware required to implement SQUIDs consists of some simple logic to inspect SQUID/M bits for pointer comparisons and memory operation reordering, and support for a trap which occurs when different pointers with the same SQUIDs are compared. </paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> SQUIDs can be applied to guarded pointers, which are described in U.S. Pat. No. 5,845,331 to Carter et al. (hereafter &ldquo;Carter&rdquo;), which is incorporated by reference herein in its entirety. Guarded pointers are a form of unforgeable capabilities, which include both a pointer and segment information within the guarded pointer itself. Guarded pointers are discussed in R. S. Fabry, &ldquo;Capability-Based Addressing&rdquo;, Communications of the ACM, Volume 17, Number 7, pp. 403-412, July 1974, which is incorporated by reference herein in its entirety. The specific format of the guarded pointer is not important, but we assume that it is possible to determine the base address of an object given a pointer to the object&apos;s interior, as in Carter. </paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> illustrates a guarded pointer embodiment of the present invention in which the guarded pointer <highlight><bold>50</bold></highlight> consists of an address <highlight><bold>51</bold></highlight>, segment information <highlight><bold>53</bold></highlight>, and a single pointer bit P <highlight><bold>59</bold></highlight> to distinguish guarded pointers from data. To support SQUIDs, a single migrated bit M <highlight><bold>57</bold></highlight> and a small number of SQUID bits (seven as shown) <highlight><bold>55</bold></highlight> are added. </paragraph>
<paragraph id="P-0068" lvl="7"><number>&lsqb;0068&rsqb;</number> Applications </paragraph>
<paragraph id="P-0069" lvl="0"><number>&lsqb;0069&rsqb;</number> Forwarding pointers are a key enabling mechanism for safe data compaction and efficient garbage collection. The present invention allows forwarding pointer support to be incorporated into novel architectures with little or no average run-time cost due to aliasing. </paragraph>
<paragraph id="P-0070" lvl="0"><number>&lsqb;0070&rsqb;</number> Luk made clear the advantages of data relocation in the context of a uniprocessor. By compacting live data, better use can be made of the cache and as a result program execution is sped up by as much as a factor of two. In a distributed shared memory multiprocessor it is also important to be able to relocate data for a different reason: a processor can access local memory an order of magnitude faster than it can access remote memory. Effective computation on such a machine therefore depends on being able to move data to the processing node at which it is needed. SQUIDs provide efficient support for data migration and are therefore applicable to both single processor and multiprocessor high performance systems. </paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> Historically, one of the primary uses of forwarding pointers has been to implement incremental garbage collection. More recently, it is shown in Jeremy Brown, &ldquo;Memory Management on a Massively Parallel Capability Architecture,&rdquo; Ph.D. thesis proposal, M.I.T., December 1999, incorporated by reference herein in its entirety, that forwarding pointers can be used to implement efficient local compacting garbage collection in a massively parallel distributed system. Hardware support for fast garbage collection is especially important given the growing prevalence of the Java programming environment, which is the language of choice for web programming and which specifies a garbage collected memory model. Another application of SQUIDs is therefore the implementation and/or improvement of systems which are specifically designed to run Java efficiently. Such systems are currently under development. For example, see Marc Tremblay, &ldquo;An Architecture for the New Millenium&rdquo;, Proc. Hot Chips XI, Aug. 15-17, 1999, which is incorporated by reference herein in its entirety. </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> A SQUID need not necessarily be a part of the pointer itself. For example, Instead, a &ldquo;SQUID cache&rdquo; could be employed that stores SQUIDS of recently-used pointers. SQUIDS would then be retrieved by presenting the pointer address to the cache. While this might slow execution and require more complicated hardware, it might actually be a useful technique if the size of pointers is so severely constrained that there is absolutely no way to include the SQUID, for example, in a 32 bit machine in which all 32 bits are required for the pointer address. </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> While this invention has been particularly shown and described with references to preferred embodiments thereof, it will be understood by those skilled in the art that various changes in form and details may be made therein without departing from the scope of the invention encompassed by the appended claims. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A data processing system for processing programs, the system comprising: 
<claim-text>memory for storing data objects, the data objects being referenced by pointers; and </claim-text>
<claim-text>a short-quasi-unique-identifier (SQUID) generator which generates SQUIDs for newly allocated data objects to be stored in the memory segment, pointers to a particular data object being associated with the data object&apos;s SQUID. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising: 
<claim-text>a memory allocator which allocates a segment of the memory to a data object. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, wherein if the data object is moved to a second allocated memory segment, a pointer to the second allocated memory segment is placed at the original memory segment. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference>, wherein the data object is moved due to resizing. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference>, wherein the data object is moved from a first memory to a second memory within a distributed system. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference>, wherein the data object is moved due to garbage collection. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference>, wherein the data object is moved due to data compaction. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the distribution of SQUIDs over a range is uniform. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference>, wherein SQUIDs are generated by counting. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference>, wherein SQUIDs are generated randomly. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference>, wherein SQUIDs are generated by hashing. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising: 
<claim-text>a comparator which compares SQUIDs associated with two different pointers. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, further comprising: 
<claim-text>an instruction reordering mechanism which reorders instructions and which is responsive to the comparator. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, the comparator determining that the two pointers do not reference the same data object if the SQUIDs are different. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference>, the comparator further determining that the two pointers reference the same data object if the SQUIDs are identical and address fields of the two pointers are identical. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference>, each pointer address field comprising: 
<claim-text>a base address; and </claim-text>
<claim-text>an offset, </claim-text>
<claim-text>the comparator further determining the two pointers do not reference identical locations within a referenced data object if the pointers&apos; offsets are not identical. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, wherein a pointer is associated with a migration indicator field which indicates a number of migrations of the referenced data object by the time said pointer is created, the comparator determining that said two pointers do not reference the same data object if their associated migration indicators indicate identical numbers of migrations and their corresponding addresses are different. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference>, wherein the migration indicator comprises one bit. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein at least one pointer is a guarded pointer. </claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the SQUID is implemented by hardware. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the SQUID is implemented by software. </claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein a pointer contains its associated SQUID. </claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising a SQUID cache for storing SQUIDS of recently-used pointers. </claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. A data processing system for processing programs, the system comprising: 
<claim-text>memory for storing data objects; </claim-text>
<claim-text>pointers to data objects stored in the memory; </claim-text>
<claim-text>migration indicators associated with pointers, a migration indicator indicating a number of migrations of a data object referenced by an associated pointer prior to said pointer being created; and </claim-text>
<claim-text>a comparator which determines that said two pointers do not reference the same data object if their associated migration indicators indicate identical numbers of migrations and their corresponding addresses are different. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00022">claim 22</dependent-claim-reference>, wherein the migration indicator comprises one bit. </claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00022">claim 22</dependent-claim-reference>, wherein the migration indicator comprises multiple bits. </claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00022">claim 22</dependent-claim-reference>, wherein the migration indicator is implemented by hardware. </claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00022">claim 22</dependent-claim-reference>, wherein the migration indicator is implemented by software. </claim-text>
</claim>
<claim id="CLM-00029">
<claim-text><highlight><bold>29</bold></highlight>. A method for processing programs, the system comprising: 
<claim-text>storing data objects in a memory, the data objects being referenced by pointers; and </claim-text>
<claim-text>generating a short-quasi-unique-identifier (SQUID) and assigning the SQUID to a data object stored in the memory segment, pointers to the data object being associated with the data object&apos;s assigned SQUID. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00030">
<claim-text><highlight><bold>30</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 27</dependent-claim-reference>, further comprising: 
<claim-text>allocating a segment of the memory to the data object. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00031">
<claim-text><highlight><bold>31</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 28</dependent-claim-reference>, wherein if the data object is moved to a second allocated memory segment, a pointer to the second allocated memory segment is placed at the original memory segment. </claim-text>
</claim>
<claim id="CLM-00032">
<claim-text><highlight><bold>32</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 29</dependent-claim-reference>, wherein the data object is moved due to resizing. </claim-text>
</claim>
<claim id="CLM-00033">
<claim-text><highlight><bold>33</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 29</dependent-claim-reference>, wherein the data object is moved from a first memory to a second memory within a distributed system. </claim-text>
</claim>
<claim id="CLM-00034">
<claim-text><highlight><bold>34</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 29</dependent-claim-reference>, wherein the data object is moved due to garbage collection. </claim-text>
</claim>
<claim id="CLM-00035">
<claim-text><highlight><bold>35</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 29</dependent-claim-reference>, wherein the data object is moved due to data compaction. </claim-text>
</claim>
<claim id="CLM-00036">
<claim-text><highlight><bold>36</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 27</dependent-claim-reference>, wherein the distribution of SQUIDs over a range is uniform. </claim-text>
</claim>
<claim id="CLM-00037">
<claim-text><highlight><bold>37</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00033">claim 34</dependent-claim-reference>, wherein SQUIDs are generated by counting. </claim-text>
</claim>
<claim id="CLM-00038">
<claim-text><highlight><bold>38</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00033">claim 34</dependent-claim-reference>, wherein SQUIDs are generated randomly. </claim-text>
</claim>
<claim id="CLM-00039">
<claim-text><highlight><bold>39</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00033">claim 34</dependent-claim-reference>, wherein SQUIDs are generated by hashing. </claim-text>
</claim>
<claim id="CLM-00040">
<claim-text><highlight><bold>40</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 27</dependent-claim-reference>, further comprising: 
<claim-text>comparing SQUIDs of two different pointers. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00041">
<claim-text><highlight><bold>41</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00033">claim 38</dependent-claim-reference>, further comprising: 
<claim-text>reordering instructions responsive to the comparison of SQUIDs. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00042">
<claim-text><highlight><bold>42</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00033">claim 38</dependent-claim-reference>, further comprising: 
<claim-text>determining that the two pointers do not reference the same data object if the SQUIDs are different. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00043">
<claim-text><highlight><bold>43</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00044">claim 40</dependent-claim-reference>, further comprising: 
<claim-text>determining that the two pointers reference the same data object if the SQUIDs are identical and address fields of the two pointers are identical. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00044">
<claim-text><highlight><bold>44</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00044">claim 41</dependent-claim-reference>, each pointer address field comprises a base address and an offset, the method further comprising: 
<claim-text>determining the two pointers do not reference identical locations within a referenced data object if the pointers&apos; offsets are not identical. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00045">
<claim-text><highlight><bold>45</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00033">claim 38</dependent-claim-reference>, wherein a pointer is associated with a migration indicator field which indicates a number of migrations of the referenced data object by the time said pointer is created, the method further comprising: 
<claim-text>determining that said two pointers do not reference the same data object if their associated migration indicators indicate identical numbers of migrations and their corresponding addresses are different. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00046">
<claim-text><highlight><bold>46</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00044">claim 43</dependent-claim-reference>, wherein the migration indicator comprises one bit. </claim-text>
</claim>
<claim id="CLM-00047">
<claim-text><highlight><bold>47</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 27</dependent-claim-reference>, wherein at least one pointer is a guarded pointer. </claim-text>
</claim>
<claim id="CLM-00048">
<claim-text><highlight><bold>48</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 27</dependent-claim-reference>, wherein the SQUID is implemented by hardware. </claim-text>
</claim>
<claim id="CLM-00049">
<claim-text><highlight><bold>49</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 27</dependent-claim-reference>, wherein the SQUID is implemented by software. </claim-text>
</claim>
<claim id="CLM-00050">
<claim-text><highlight><bold>50</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 27</dependent-claim-reference>, wherein a pointer contains its associated SQUID. </claim-text>
</claim>
<claim id="CLM-00051">
<claim-text><highlight><bold>51</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 27</dependent-claim-reference>, further comprising: 
<claim-text>maintaining a SQUID cache for storing SQUIDS of recently-used pointers. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00052">
<claim-text><highlight><bold>52</bold></highlight>. A method for processing programs, the method comprising: 
<claim-text>storing data objects in memory; </claim-text>
<claim-text>generating pointers to the stored data objects; </claim-text>
<claim-text>associating migration indicators with the pointers, a migration indicator indicating a number of migrations of a data object referenced by an associated pointer prior to said associated pointer being created; and </claim-text>
<claim-text>comparing two pointers and determining that said two pointers do not reference the same data object if their associated migration indicators indicate identical numbers of migrations and their corresponding addresses are different. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00053">
<claim-text><highlight><bold>53</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00044">claim 48</dependent-claim-reference>, wherein the migration indicator comprises one bit. </claim-text>
</claim>
<claim id="CLM-00054">
<claim-text><highlight><bold>54</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00044">claim 48</dependent-claim-reference>, wherein the migration indicator comprises multiple bits. </claim-text>
</claim>
<claim id="CLM-00055">
<claim-text><highlight><bold>55</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00044">claim 48</dependent-claim-reference>, wherein migration indicators are implemented by hardware. </claim-text>
</claim>
<claim id="CLM-00056">
<claim-text><highlight><bold>56</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00044">claim 48</dependent-claim-reference>, wherein the migration indicators are implemented by software. </claim-text>
</claim>
<claim id="CLM-00057">
<claim-text><highlight><bold>57</bold></highlight>. A data processing system for processing programs, the system comprising: 
<claim-text>means for storing data objects in a memory, the data objects being referenced by pointers; and </claim-text>
<claim-text>means for generating a short-quasi-unique-identifier (SQUID) and assigning the SQUID to a data object stored in the memory segment, pointers to the data object containing the data object&apos;s assigned SQUID. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00058">
<claim-text><highlight><bold>58</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00055">claim 53</dependent-claim-reference>, further comprising: 
<claim-text>means for comparing SQUIDs of two different pointers. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00059">
<claim-text><highlight><bold>59</bold></highlight>. A data processing system for processing programs, the method comprising: 
<claim-text>means for storing data objects in memory; </claim-text>
<claim-text>means for generating pointers to the stored data objects; </claim-text>
<claim-text>means for associating migration indicators with the pointers, a migration indicator indicating a number of migrations of a data object referenced by an associated pointer prior to said associated pointer being created; and </claim-text>
<claim-text>means for comparing two pointers and determining that said two pointers do not reference the same data object if their associated migration indicators indicate identical numbers of migrations and their corresponding addresses are different. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00060">
<claim-text><highlight><bold>60</bold></highlight>. A computer program product for processing programs, the computer program product comprising a computer usable medium having computer readable code thereon, including program code which: 
<claim-text>stores data objects in a memory, the data objects being referenced by pointers; and </claim-text>
<claim-text>generates a short-quasi-unique-identifier (SQUID) and assigns the SQUID to a data object stored in the memory segment, pointers to the data object containing the data object&apos;s assigned SQUID. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00061">
<claim-text><highlight><bold>61</bold></highlight>. The computer program product of <dependent-claim-reference depends_on="CLM-00055">claim 56</dependent-claim-reference>, further including program code which: 
<claim-text>compares SQUIDs of two different pointers. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00062">
<claim-text><highlight><bold>62</bold></highlight>. A computer data signal embodied in a carrier wave for processing programs, comprising: 
<claim-text>a program code segment for storing data objects in a memory, the data objects being referenced by pointers; and </claim-text>
<claim-text>a program code segment for generating a short-quasi-unique-identifier (SQUID) and assigning the SQUID to a data object stored in the memory segment, pointers to the data object containing the data object&apos;s assigned SQUID. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00063">
<claim-text><highlight><bold>63</bold></highlight>. The computer data signal of <dependent-claim-reference depends_on="CLM-00055">claim 58</dependent-claim-reference>, further comprising: 
<claim-text>a program code segment for comparing SQUIDs of two different pointers. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00064">
<claim-text><highlight><bold>64</bold></highlight>. A computer program product for processing programs, the computer program product comprising a computer usable medium having computer readable code thereon, including program code which: 
<claim-text>stores data objects in memory; </claim-text>
<claim-text>generates pointers to the stored data objects; </claim-text>
<claim-text>associates migration indicators with the pointers, a migration indicator indicating a number of migrations of a data object referenced by an associated pointer prior to said associated pointer being created; and </claim-text>
<claim-text>compares two pointers, determining that said two pointers do not reference the same data object if their associated migration indicators indicate identical numbers of migrations and their corresponding addresses are different. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00065">
<claim-text><highlight><bold>65</bold></highlight>. A computer data signal embodied in a carrier wave for processing programs, comprising: 
<claim-text>a program code segment for storing data objects in memory; </claim-text>
<claim-text>a program code segment for generating pointers to the stored data objects; </claim-text>
<claim-text>a program code segment for associating migration indicators with the pointers, a migration indicator indicating a number of migrations of a data object referenced by an associated pointer prior to said associated pointer being created; and </claim-text>
<claim-text>a program code segment for comparing two pointers, said segment determining that said two pointers do not reference the same data object if their associated migration indicators indicate identical numbers of migrations and their corresponding addresses are different.</claim-text>
</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>2</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005256A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005256A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005256A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005256A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005256A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005256A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030005256A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
