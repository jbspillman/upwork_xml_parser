<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030004882A1-20030102-D00000.TIF SYSTEM "US20030004882A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00001.TIF SYSTEM "US20030004882A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00002.TIF SYSTEM "US20030004882A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00003.TIF SYSTEM "US20030004882A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00004.TIF SYSTEM "US20030004882A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00005.TIF SYSTEM "US20030004882A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00006.TIF SYSTEM "US20030004882A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00007.TIF SYSTEM "US20030004882A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00008.TIF SYSTEM "US20030004882A1-20030102-D00008.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00009.TIF SYSTEM "US20030004882A1-20030102-D00009.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00010.TIF SYSTEM "US20030004882A1-20030102-D00010.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00011.TIF SYSTEM "US20030004882A1-20030102-D00011.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00012.TIF SYSTEM "US20030004882A1-20030102-D00012.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00013.TIF SYSTEM "US20030004882A1-20030102-D00013.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00014.TIF SYSTEM "US20030004882A1-20030102-D00014.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00015.TIF SYSTEM "US20030004882A1-20030102-D00015.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00016.TIF SYSTEM "US20030004882A1-20030102-D00016.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00017.TIF SYSTEM "US20030004882A1-20030102-D00017.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00018.TIF SYSTEM "US20030004882A1-20030102-D00018.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00019.TIF SYSTEM "US20030004882A1-20030102-D00019.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00020.TIF SYSTEM "US20030004882A1-20030102-D00020.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00021.TIF SYSTEM "US20030004882A1-20030102-D00021.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00022.TIF SYSTEM "US20030004882A1-20030102-D00022.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00023.TIF SYSTEM "US20030004882A1-20030102-D00023.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00024.TIF SYSTEM "US20030004882A1-20030102-D00024.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00025.TIF SYSTEM "US20030004882A1-20030102-D00025.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00026.TIF SYSTEM "US20030004882A1-20030102-D00026.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00027.TIF SYSTEM "US20030004882A1-20030102-D00027.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00028.TIF SYSTEM "US20030004882A1-20030102-D00028.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00029.TIF SYSTEM "US20030004882A1-20030102-D00029.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00030.TIF SYSTEM "US20030004882A1-20030102-D00030.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00031.TIF SYSTEM "US20030004882A1-20030102-D00031.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00032.TIF SYSTEM "US20030004882A1-20030102-D00032.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00033.TIF SYSTEM "US20030004882A1-20030102-D00033.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00034.TIF SYSTEM "US20030004882A1-20030102-D00034.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00035.TIF SYSTEM "US20030004882A1-20030102-D00035.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00036.TIF SYSTEM "US20030004882A1-20030102-D00036.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00037.TIF SYSTEM "US20030004882A1-20030102-D00037.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00038.TIF SYSTEM "US20030004882A1-20030102-D00038.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00039.TIF SYSTEM "US20030004882A1-20030102-D00039.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00040.TIF SYSTEM "US20030004882A1-20030102-D00040.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00041.TIF SYSTEM "US20030004882A1-20030102-D00041.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00042.TIF SYSTEM "US20030004882A1-20030102-D00042.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00043.TIF SYSTEM "US20030004882A1-20030102-D00043.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00044.TIF SYSTEM "US20030004882A1-20030102-D00044.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00045.TIF SYSTEM "US20030004882A1-20030102-D00045.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00046.TIF SYSTEM "US20030004882A1-20030102-D00046.TIF" NDATA TIF>
<!ENTITY US20030004882A1-20030102-D00047.TIF SYSTEM "US20030004882A1-20030102-D00047.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030004882</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10005729</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20011106</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>H04K001/00</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>705</class>
<subclass>051000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Optimized server for streamed applications</title-of-invention>
</technical-information>
<continuity-data>
<non-provisional-of-provisional>
<document-id>
<doc-number>60246384</doc-number>
<document-date>20001106</document-date>
<country-code>US</country-code>
</document-id>
</non-provisional-of-provisional>
</continuity-data>
<inventors>
<first-named-inventor>
<name>
<given-name>Anne</given-name>
<middle-name>Marie</middle-name>
<family-name>Holler</family-name>
</name>
<residence>
<residence-us>
<city>Los Altos</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Lacky</given-name>
<middle-name>Vasant</middle-name>
<family-name>Shah</family-name>
</name>
<residence>
<residence-us>
<city>Fremont</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Sameer</given-name>
<family-name>Panwar</family-name>
</name>
<residence>
<residence-us>
<city>Fremont</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Amit</given-name>
<family-name>Patel</family-name>
</name>
<residence>
<residence-us>
<city>Sunnyvale</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>GLENN PATENT GROUP</name-1>
<name-2></name-2>
<address>
<address-1>3475 EDISON WAY</address-1>
<address-2>SUITE L</address-2>
<city>MENLO PARK</city>
<state>CA</state>
<postalcode>94025</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">An optimized server for streamed applications provides a streamed application server optimized to provide efficient delivery of streamed applications to client systems across a computer network such as the Internet. The server persistently stores streamed application program sets that contain streamed application file pages. Client systems request streamed application file pages from the server using a unique set of numbers common among all servers that store the particular streamed application file pages. A license server offloads the streamed application server by performing client access privilege validations. Commonly accessed streamed application file pages are stored in a cache on the streamed application server which attempts to retrieve requested streamed application file pages from the cache before retrieving them from persistent storage. Requested streamed application file pages are compressed before being sent to a client as well as those stored in the cache. </paragraph>
</subdoc-abstract>
<subdoc-description>
<cross-reference-to-related-applications>
<heading lvl="1">CROSS REFERENCE TO RELATED APPLICATIONS </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> This application Claims benefit of U.S. Provisional Patent Application Serial No. 60/246,384, filed on Nov. 6, 2000 (OTI.2000.0).</paragraph>
</cross-reference-to-related-applications>
<summary-of-invention>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> 1. Technical Field </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> The invention relates to the streaming of computer program object code across a network in a computer environment. More particularly, the invention relates to optimizing server performance for the delivery and management of streaming applications to client systems across a computer network. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> 2. Description of the Prior Art </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> Retail sales model s of computer application programs are fairly straight forward. The consumer either purchases the application program from a retailer that is either a brick and mortar or an ecommerce entity. The product is delivered to the consumer in a shrink-wrap form. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> The consumer installs the program from a floppy disk or a CD-ROM included in the packaging. A serial number is generally provided that must be entered at installation or the first time the program is run. Other approaches require that the CD-ROM be present whenever the program is run. However, CD-ROMs are easily copied using common CDR technology. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> Another approach is for the consumer to effectuate the purchase through an ecommerce entity. The application program is downloaded in its entirety to the consumer across the Internet. The consumer is emailed a serial number that is required to run the program. The consumer enters the serial number at the time the program is installed or the first time the program is run. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> Once the application program is installed on a machine, it resides on the machine, occupying precious hard disk space, until it is physically removed. The installer portion of the program can also be installed on a server along with the installation files. Users within an intranet can install the program from the server, across the network, onto their machines. The program is a full installation of the program and resides on the user&apos;s machine until it is manually removed. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> Trial versions of programs are also available online that are a partial or full installation of the application program. The program executes normally for a preset time period. At the end of the time period, the consumer is told that he must purchase the program and execution is terminated. The drawback to this approach is that there is an easy way for the consumer to fool the program. The consumer simply uninstalls the program and then reinstalls it, thereby restarting the time period. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> Additionally, piracy problems arise once the application program is resident on the consumer&apos;s computer. Serial numbers for programs are easily obtained across the Internet. Software companies lose billions of dollars a year in revenue because of this type of piracy. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> The above approaches fail to adequately protect software companies&apos; revenue stream. These approaches also require the consumer to install a program that resides indefinitely on the consumer&apos;s hard disk, occupying valuable space even though the consumer may use the program infrequently. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> The enterprise arena allows Application Service Providers (ASP) to provide browser-based implementations such as Tarantella offered by Santa Cruz Operation, Inc. in Santa Cruz, Calif. and Metaframe offered by Citrix Systems Inc. of Fort Lauderdale, Fla. A remote application portal site allows the user to click on an application in his browser to execute the application. The application runs on the portal site and GUI interfaces such as display, keystrokes and mouse clicks are transferred over the wire. The access to the program is password protected. This approach allows the provider to create an audit trail and to track the use of an application program. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> AppStream Inc. of Palo Alto, Calif. uses Java code streamlets to provide streaming applications to the user. The system partitions a Web application program into Java streamlets. Java streamlets are then streamed to the user&apos;s computer on an as-needed basis. The application runs on the user&apos;s computer, but is accessed through the user&apos;s network browser. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> The drawback to the browser-based approaches is that the user is forced to work within his network browser, thereby adding another layer of complexity. The browser or Java program manages the application program&apos;s run-time environment. The user loses the experience that the software manufacturer had originally intended for its product including features such as application invocation based on file extension associations. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> It would be advantageous to provide an optimized server for streamed applications that optimizes the delivery system of streamed application program servers. It would further be advantageous to provide an optimized server for streamed applications that efficiently manages the streamed application programs resident on a streamed application program server. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> The invention provides an optimized server for streamed applications. The system enables a server to efficiently stream application programs to a plurality of clients across a computer network. In addition, the invention provides a system that efficiently manages the storage and retrieval of streaming application program source and data files resident on a server. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> The invention provides a streamed application server optimized to provide efficient delivery of streamed applications to client systems across a computer network such as the Internet. The server persistently stores streamed application program sets that contain streamed application file pages. Client systems request streamed application file pages from the server using a unique set of numbers common among all servers that store the particular streamed application file pages. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> The streamed application file pages are read-only making it easier for the server to maintain the streaming application file pages. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> Streamed application file pages are only returned to clients with the proper access privileges. Another preferred embodiment of the invention provides a license server. The license server offloads the streamed application server by performing the client access privilege validations. The license server provides a client with an access token that contains information regarding access rights, the application that it applies to, and an expiration time. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> The streamed application server receives an access token from a requesting client, decrypts and validates the access token&apos;s contents, and grants access to the requesting client having a valid access token. The streamed application server decrypts access tokens using a secret key shared with the license server. Recently approved access tokens are kept track of by the streamed application server and incoming access tokens that match a recently approved access token are approved without further processing. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> Commonly accessed streamed application file pages are stored in a cache on the streamed application server. The server attempts to retrieve requested streamed application file pages from the cache before retrieving them from persistent storage. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> Requested streamed application file pages are compressed before being sent to a client. When a client requests multiple streamed application file pages, they are concatenated together and the entire set compressed at once before sending to the client. The commonly accessed streamed application file pages are also compressed before being stored in the cache. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> Another preferred embodiment of the invention compresses all of the streamed application file pages in the streamed application sets before being stored in the persistent storage. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> Streamed application servers profile the access patterns of streamed application file pages. The profiles are used by clients to guide their prefetching of streamed application file pages and by the server to pre-package and compress groups of streamed application file pages to be sent to a client that requests pages within a set and to perform prefetching of streamed application file pages for pushing to clients. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> Individual servers across the network can be assigned a specific set of streamed applications sets to serve to clients to improve the response time for certain applications. Servers can be asymmetrically assigned different sets of streamed application sets to improve overall server efficiency. Individual servers can also be dynamically assigned streamed application sets to match client accesses over time. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> A central control server is also provided where individual servers periodically send a summary of their file access patterns. The central server then generates prefetching information from the aggregate file access patterns and updates the individual servers with the prefetching information. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> Other aspects and advantages of the invention will become apparent from the following detailed description in combination with the accompanying drawings, illustrating, by way of example, the principles of the invention.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a block schematic diagram of a preferred embodiment of the invention showing components on the server that deal with users subscribing to and running applications according to the invention; </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a block schematic diagram of a preferred embodiment of the invention showing the client components supporting application delivery and execution according to the invention; </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a block schematic diagram of a preferred embodiment of the invention showing the components needed to install applications on the client according to the invention; </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a block schematic diagram of the Builder that takes an existing application and extracts the Application File Pages for that application according to the invention; </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference><highlight><italic>a </italic></highlight>is a block schematic diagram illustrating how the Client Network Spoofer is used to handle mapping TCP interfaces to HTTP interfaces according to the invention; </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference><highlight><italic>b </italic></highlight>is a block schematic diagram illustrating how the Client Network Spoofer is used to handle mapping TCP interfaces to HTTP interfaces according to the invention; </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference><highlight><italic>a </italic></highlight>is a block schematic diagram showing several different components of the client software according to the invention; </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference><highlight><italic>b </italic></highlight>is a block schematic diagram showing the use of volatile and non-volatile storage of code and data in the client and server according to the invention; </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference><highlight><italic>a </italic></highlight>is a block schematic diagram showing one of two ways in which data may be compressed while in transit between the server and client according to the invention; </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference><highlight><italic>b </italic></highlight>is a block schematic diagram showing the other way in which data may be compressed while in transit between the server and client according to the invention; </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> is a block schematic diagram showing an organization of the streaming client software according to the invention; </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference> is a block schematic diagram showing an alternative organization of the streaming client software according to the invention; </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10</cross-reference> is a block schematic diagram showing the application streaming software consisting of a streaming block driver according to the invention; </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 11</cross-reference> is a block schematic diagram showing the application streaming software has been divided into a disk driver and a user mode client according to the invention; </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 12</cross-reference> is a block schematic diagram showing the unencrypted and encrypted client caches according to the invention; </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 13</cross-reference> is a block schematic diagram showing an application generating a sequence of code or data requests to the operating system according to the invention; </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 14</cross-reference> is a block schematic diagram showing server-based prefetching according to the invention; </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 15</cross-reference> is a block schematic diagram showing a client-to-client communication mechanism that allows local application customization to travel from one client machine to another without involving server communication according to the invention; </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 16</cross-reference> is a block schematic diagram showing a client cache with extensions for supporting local file customization according to the invention; </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 17</cross-reference> is a block schematic diagram showing aspects of a preferred embodiment of the invention related to load balancing and hardware fail over according to the invention; </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 18</cross-reference> is a block schematic diagram showing the benefits to the use of compression in the streaming of Application File Pages according to the invention; </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 19</cross-reference> is a block schematic diagram showing pre-compression of Application File Pages according to the invention; </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 20</cross-reference> is a block schematic diagram showing multi-page compression of Application File Pages according to the invention; </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 21</cross-reference> is a block schematic diagram showing profile-based prefetching according to the invention; </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 22</cross-reference> is a block schematic diagram showing the use of tokens and a License Server according to the invention; </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 23</cross-reference> is a block schematic diagram showing a flowchart for the Builder Install Monitor according to the invention; </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 24</cross-reference> is a block schematic diagram showing a flowchart for the Builder Application Profiler according to the invention; </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 25</cross-reference> is a block schematic diagram showing a flowchart for the Builder SAS Packager according to the invention; </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 26</cross-reference><highlight><italic>a </italic></highlight>is a block schematic diagram showing versioning support according to the invention; </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 26</cross-reference><highlight><italic>b </italic></highlight>is a block schematic diagram showing versioning support according to the invention; </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 27</cross-reference> is a block schematic diagram showing a data flow diagram for the Streamed Application Set Builder according to the invention; </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 28</cross-reference> is a block schematic diagram showing the Streamed Application Set format according to the invention; </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 29</cross-reference> is a block schematic diagram showing an SAS client using a device driver paradigm according to the invention; </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 30</cross-reference> is a block schematic diagram showing an SAS client using a file system paradigm according to the invention; </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 31 a through 31</cross-reference><highlight><italic>h </italic></highlight>is a schematic diagram showing various components of the AppinstallBlock format according to the invention; </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 32</cross-reference> is a block schematic diagram showing the Application Install Block lifecycle according to the invention; </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 33</cross-reference> is a block schematic diagram showing peer caching according to the invention; </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 34</cross-reference> is a block schematic diagram showing proxy caching according to the invention; </paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 35</cross-reference> is a block schematic diagram showing multicast within a LAN and a packet protocol according to the invention; </paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 36</cross-reference> is a block schematic diagram showing concurrent requests for application server pages, for the case when the page is first requested through the proxy according to the invention; </paragraph>
<paragraph id="P-0068" lvl="0"><number>&lsqb;0068&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 37</cross-reference> is a block schematic diagram showing concurrent requests for application server pages, for the case when the page is first requested through the peer caching according to the invention; </paragraph>
<paragraph id="P-0069" lvl="0"><number>&lsqb;0069&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 38</cross-reference> is a block schematic diagram showing concurrent requests for application server pages, for the case when the page is received only through peer caching according to the invention; </paragraph>
<paragraph id="P-0070" lvl="0"><number>&lsqb;0070&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 39</cross-reference> is a block schematic diagram showing a client-server system using peer and proxy caching according to the invention; </paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 40</cross-reference> is a block schematic diagram showing a preferred embodiment of the invention preventing piracy of remotely served, locally executed applications according to the invention; </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 41</cross-reference> is a block schematic diagram showing the filtering of accesses to remote application files according to the invention; </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 42</cross-reference> is a block schematic diagram showing the filtering of accesses to remote files based on process code location according to the invention; </paragraph>
<paragraph id="P-0074" lvl="0"><number>&lsqb;0074&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 43</cross-reference> is a block schematic diagram showing the filtering of accesses to remote files based on targeted file section according to the invention; </paragraph>
<paragraph id="P-0075" lvl="0"><number>&lsqb;0075&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 44</cross-reference> is a block schematic diagram showing the filtering of accesses to remote files based on surmised purpose according to the invention; and </paragraph>
<paragraph id="P-0076" lvl="0"><number>&lsqb;0076&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 45</cross-reference> is a block schematic diagram showing the filtering of accesses to remote files based on past access history according to the invention.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF THE INVENTION </heading>
<paragraph id="P-0077" lvl="0"><number>&lsqb;0077&rsqb;</number> The invention is embodied in an optimized server for streamed applications. A system according to the invention enables a server to efficiently stream application programs to a plurality of clients across a computer network. In addition, the invention provides a system that efficiently manages the storage and retrieval of streaming application program source and data files resident on a server. </paragraph>
<paragraph id="P-0078" lvl="0"><number>&lsqb;0078&rsqb;</number> The invention provides a highly efficient and secure application delivery system in conjunction with the adaptively optimized execution of applications across a network such as the Internet, a corporate intranet, or a wide area network. This is done in such a way that existing applications do not need to be recompiled or recoded. Furthermore, the invention is a highly scalable, load-balancing, and fault-tolerant system that provides anti-piracy protection of the streamed applications. </paragraph>
<paragraph id="P-0079" lvl="0"><number>&lsqb;0079&rsqb;</number> When using the invention, an end-user requests applications that are resident on remote systems to be launched and run on the end-user&apos;s local system. The end-user&apos;s local system is called the client or client system, e.g., a desktop, laptop, palmtop, or information appliance. A remote system is a called a server or server system and is located within a collection of one or more servers called a server cluster. </paragraph>
<paragraph id="P-0080" lvl="0"><number>&lsqb;0080&rsqb;</number> From the point of view of the client system, the application appears to be installed locally on the client even though it was initially installed on a different computer system. The applications execute locally on the client system and not on the server system. To achieve this result, the application is converted into a form suitable for streaming over the network. The streaming-enabled form of an application is called the Streamed Application Set (SAS) and the conversion process is termed the SAS Builder. The conversion of an application into its SAS form typically takes place on a system different from either an end-user client system or an Application Service Provider Server Cluster. This system is called the SAS Conversion System or, simply, the conversion system. </paragraph>
<paragraph id="P-0081" lvl="0"><number>&lsqb;0081&rsqb;</number> Components of the invention are installed on the client system to support activities such as the installation, invocation, and execution of a SAS-based application. Other components of the invention are installed on the server system to support activities such as the verification of end user application subscription and license data and the transfer and execution of a SAS-based application on the client system. Some of the client and some of the server components run in the kernel-mode while other components run in the usual user-mode. </paragraph>
<paragraph id="P-0082" lvl="0"><number>&lsqb;0082&rsqb;</number> The term Application Service Provider (ASP) refers to an entity that uses the server components on one or more server systems, ie., an ASP Server Cluster, to deliver applications to end-user client systems. Such an entity could be, for example, a software manufacturer, an e-commerce vendor that rents or leases software, or a service department within a company. The invention enables an ASP to deliver applications across a network, in a highly efficient and secure way; the applications are adaptively optimized for execution on an end-user&apos;s client system. </paragraph>
<paragraph id="P-0083" lvl="0"><number>&lsqb;0083&rsqb;</number> A number of techniques are employed to increase the overall performance of the delivery of an application and its subsequent execution by minimizing the effect of network latency and bandwidth. Among the techniques employed are: the SAS Builder identifies sequences of frequently accessed application pages and uses this information when generating a SAS; individual SAS pages and sequences of SAS pages are compressed and cached in an in-memory cache on the server system; various aspects of the applications are monitored during their actual use on a client and the resulting profiling data is used by the client to pre-fetch (pull) and by the server to send (push) additional pages which have a high likelihood of being used prior to their actual use; and SAS pages are cached locally on a client for their immediate use when an application is invoked. </paragraph>
<paragraph id="P-0084" lvl="0"><number>&lsqb;0084&rsqb;</number> Aggregate profile data for an application, obtained by combining the profile data from all the end-user client systems running the application, is used to increase the system performance as well. A number of additional caching techniques that improve both system scalability and performance are also employed. The above techniques are collectively referred to as collaborative caching. </paragraph>
<paragraph id="P-0085" lvl="0"><number>&lsqb;0085&rsqb;</number> In an embodiment of the invention, the SAS Builder consists of three phases: installation monitoring, execution profiling, and application stream packaging. In the final SAS Builder phase, the Application Stream Packager takes the information gathered by the Application Install Monitor and the Application Execution Profiler and creates the SAS form of the application, which consists of a Stream Enabled Application Pages File and a Stream Enabled Application Install Block. </paragraph>
<paragraph id="P-0086" lvl="0"><number>&lsqb;0086&rsqb;</number> The Stream Enabled Application Install Block is used to install a SAS-based application on a client system while selected portions of the Stream Enabled Application Pages File are streamed to a client to be run on the client system. The Stream Enabled Application Install Block is the first set of data to be streamed from the server to the client and contains, among other things, the information needed by the client system to prepare for the streaming and execution of the particular application. Individual and aggregate client dynamic profile data is merged into the existing Stream Enabled Application Install Block on the server to optimize subsequent streaming of the application. </paragraph>
<paragraph id="P-0087" lvl="0"><number>&lsqb;0087&rsqb;</number> The invention employs a Client Streaming File System that is used to manage specific application-related file accesses during the execution of an application. For example, there are certain shared library files, e.g., &ldquo;foo.dll&rdquo;, that need to be installed on the local file system, e.g., &ldquo;c:&bsol;winnt&bsol;system32&bsol;foo.dll&rdquo;, for the application to execute. Such file names get added to a &ldquo;spoof database&rdquo;. For the previous example, the spoof database would contain an entry saying that &ldquo;c:&bsol;winnt&bsol;system32&bsol;foo.dll&rdquo; is mapped to &ldquo;z:&bsol;word&bsol;winnt&bsol;system32&bsol;foo.dll&rdquo; where &ldquo;z:&rdquo; implies that this file is accessed by the Client Streaming File System. The Client Spoofer will then redirect all accesses to &ldquo;c:&bsol;winnt&bsol;system32&bsol;foo.dll&rdquo; to &ldquo;z:&bsol;word&bsol;winnt&bsol;system32&bsol;foo.dll&rdquo;. In this manner, the client system gets the effect of the file being on the local machine whereas in reality the file is streamed from the server. Several different classes of files can be treated in this way, e.g., specific application registry entries and application-based networking calls when such calls cross a firewall. </paragraph>
<paragraph id="P-0088" lvl="0"><number>&lsqb;0088&rsqb;</number> Lastly, the invention incorporates a number of software anti-piracy techniques directed at combating the piracy of applications of the type described herein that are delivered to the end-user over a network for execution on a client system. Among the anti-piracy techniques included are: client-side fine-grained filtering of file accesses directed at remotely served files; filtering of file accesses based on where the code for the process that originated the request is stored; identification of crucial portions of application files and filtering file access depending on the portions of the application targeted; filtering of file accesses based on the surmised purpose of the file access, as determined by examining the program stack or flags associated with the request; and filtering of file accesses based on the surmised purpose of the file access, as determined by examining a history of previous file accesses by the same process. </paragraph>
<paragraph id="P-0089" lvl="0"><number>&lsqb;0089&rsqb;</number> As mentioned above, the invention provides server and client technology for streaming application delivery and execution. The invention includes secure license-based streaming delivery of applications over Internet/extranets/intranets utilizing client-based execution with client caching and server-based file accesses by page. </paragraph>
<paragraph id="P-0090" lvl="1"><number>&lsqb;0090&rsqb;</number> 1. The invention provides many advantages over the present approaches, including: </paragraph>
<paragraph id="P-0091" lvl="2"><number>&lsqb;0091&rsqb;</number> Secure license-based streaming delivery over Internet/extranets/intranets: </paragraph>
<paragraph id="P-0092" lvl="3"><number>&lsqb;0092&rsqb;</number> reduces IT costs over client installation; </paragraph>
<paragraph id="P-0093" lvl="3"><number>&lsqb;0093&rsqb;</number> supports rental model of app delivery, which opens new markets and increases user convenience over purchase and client installation; and </paragraph>
<paragraph id="P-0094" lvl="3"><number>&lsqb;0094&rsqb;</number> enhances the opportunities to prevent software piracy over purchase and client installation. </paragraph>
<paragraph id="P-0095" lvl="2"><number>&lsqb;0095&rsqb;</number> Client-based execution with client caching: </paragraph>
<paragraph id="P-0096" lvl="3"><number>&lsqb;0096&rsqb;</number> increases typical application performance over server-based execution; </paragraph>
<paragraph id="P-0097" lvl="3"><number>&lsqb;0097&rsqb;</number> reduces network latency and bandwidth usage over non-cached client execution; and </paragraph>
<paragraph id="P-0098" lvl="3"><number>&lsqb;0098&rsqb;</number> allows existing applications to be run w/o rewrite/recompile/rebuild unlike other explicitly-distributed client/server application delivery approaches. </paragraph>
<paragraph id="P-0099" lvl="2"><number>&lsqb;0099&rsqb;</number> Server-based file accesses: </paragraph>
<paragraph id="P-0100" lvl="3"><number>&lsqb;0100&rsqb;</number> improve server-scaling over server-based execution; </paragraph>
<paragraph id="P-0101" lvl="3"><number>&lsqb;0101&rsqb;</number> allow transparent failover to another server whereas server-based execution does not; </paragraph>
<paragraph id="P-0102" lvl="3"><number>&lsqb;0102&rsqb;</number> make server load balancing easier than it is with server-based execution; and </paragraph>
<paragraph id="P-0103" lvl="3"><number>&lsqb;0103&rsqb;</number> allow increased flexibility in server platform selection over server-based execution. </paragraph>
<paragraph id="P-0104" lvl="2"><number>&lsqb;0104&rsqb;</number> Server-based file accesses by page: </paragraph>
<paragraph id="P-0105" lvl="3"><number>&lsqb;0105&rsqb;</number> reduce network latency over complete file downloads; </paragraph>
<paragraph id="P-0106" lvl="3"><number>&lsqb;0106&rsqb;</number> reduce network bandwidth overhead over complete file downloads; and </paragraph>
<paragraph id="P-0107" lvl="2"><number>&lsqb;0107&rsqb;</number> reduce client cache footprint over complete file downloads. </paragraph>
<paragraph id="P-0108" lvl="1"><number>&lsqb;0108&rsqb;</number> 2. Features of the Invention </paragraph>
<paragraph id="P-0109" lvl="1"><number>&lsqb;0109&rsqb;</number> A) Server Components Supporting Application Delivery and Execution. </paragraph>
<paragraph id="P-0110" lvl="2"><number>&lsqb;0110&rsqb;</number> i) referring to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, the server components include: </paragraph>
<paragraph id="P-0111" lvl="3"><number>&lsqb;0111&rsqb;</number> a. Client/server network interface <highlight><bold>110</bold></highlight> that is common to the client <highlight><bold>113</bold></highlight> and the server. This is the communication mechanism through which the client and the server communicate. </paragraph>
<paragraph id="P-0112" lvl="3"><number>&lsqb;0112&rsqb;</number> b. The Subscription Server <highlight><bold>105</bold></highlight>&mdash;This is the server the client <highlight><bold>113</bold></highlight> connects to for subscribing and unsubscribing applications. This server then adds/deletes the subscription information to the Subscription Database <highlight><bold>101</bold></highlight> and also updates the License Database <highlight><bold>102</bold></highlight> with the information stating that the client <highlight><bold>113</bold></highlight> can/cannot run the subscribed information under the agreed upon licensing terms. This communication between the client <highlight><bold>113</bold></highlight> and the Subscription Server <highlight><bold>105</bold></highlight> happens over SSL that is an industry standard protocol for secure communication. The Subscription Server <highlight><bold>105</bold></highlight> is also contacted for updating any existing subscription information that is in the Subscription Database <highlight><bold>101</bold></highlight>. </paragraph>
<paragraph id="P-0113" lvl="3"><number>&lsqb;0113&rsqb;</number> c. The License Server <highlight><bold>106</bold></highlight>&mdash;This is the server the client <highlight><bold>113</bold></highlight> connects to for getting a license to run an application after the client has subscribed to the application. This server validates the user and his subscriptions by consulting the License Database <highlight><bold>102</bold></highlight>. If the client <highlight><bold>113</bold></highlight> does have a valid license, the License Server <highlight><bold>106</bold></highlight> sends an &ldquo;Access token&rdquo; to the client that is encrypted using an &ldquo;encryption key&rdquo; that the License Database <highlight><bold>102</bold></highlight> obtains from the Server Config Database <highlight><bold>103</bold></highlight>. The &ldquo;Access token&rdquo; contains information like the Application ID and an expiration time. Along with the &ldquo;Access token,&rdquo; the License Server <highlight><bold>106</bold></highlight> also sends a list of least loaded application servers that it obtains from the Server Config Database <highlight><bold>103</bold></highlight> and also the expiration time that was encoded in the &ldquo;Access token&rdquo;. The client <highlight><bold>113</bold></highlight> uses this expiration time to know when to ask for a new token. This communication between the client <highlight><bold>113</bold></highlight> and the License Server <highlight><bold>106</bold></highlight> happens over SSL. </paragraph>
<paragraph id="P-0114" lvl="3"><number>&lsqb;0114&rsqb;</number> d. The Application Server <highlight><bold>107</bold></highlight>&mdash;Once the client <highlight><bold>113</bold></highlight> obtains an &ldquo;Access token&rdquo; to run an application, it connects to the Application Server <highlight><bold>107</bold></highlight> and presents to it the &ldquo;Access token&rdquo; along with the request for the application bits. Note that the &ldquo;Access token&rdquo; is opaque to the client <highlight><bold>113</bold></highlight> since it does not have the key to decrypt it. The Application Server <highlight><bold>107</bold></highlight> validates the &ldquo;Access token&rdquo; by decrypting it using a &ldquo;decryption key&rdquo; obtained from the Server Config Database <highlight><bold>103</bold></highlight> and checking the content against a predefined value like for example the Application ID and also by making sure that the expiration time in the &ldquo;Access token&rdquo; has not elapsed. It then serves the appropriate bits to the client <highlight><bold>113</bold></highlight> to enable it to run the application. The encryption and decryption keys could be something like a private key/public key pair or a symmetric key or any other means of providing security. Note that the keys are uniform across all the servers within an ASP. </paragraph>
<paragraph id="P-0115" lvl="3"><number>&lsqb;0115&rsqb;</number> e. The Monitor Server <highlight><bold>108</bold></highlight>&mdash;It monitors the load in terms of percent of CPU utilization on the Application Servers <highlight><bold>107</bold></highlight> and the License Servers <highlight><bold>106</bold></highlight> on a periodic basis (for example&mdash;every minute) and adds that information to the Server Config Database <highlight><bold>103</bold></highlight>. </paragraph>
<paragraph id="P-0116" lvl="3"><number>&lsqb;0116&rsqb;</number> f. The Profile Server <highlight><bold>109</bold></highlight>&mdash;It receives profile information from the clients periodically. It adds this information to the Profile Database <highlight><bold>104</bold></highlight>. The Profile Server <highlight><bold>109</bold></highlight> based on the profile information from different clients updates the App Prefetch Page List section of the Stream App Install Blocks <highlight><bold>112</bold></highlight>. </paragraph>
<paragraph id="P-0117" lvl="2"><number>&lsqb;0117&rsqb;</number> ii) The data structures supporting the above server components include: </paragraph>
<paragraph id="P-0118" lvl="3"><number>&lsqb;0118&rsqb;</number> a. Subscription Database <highlight><bold>101</bold></highlight>&mdash;This is the database that stores the user information in terms of username, list of apps subscribed, password, billing information, address, group, admin. The username is the primary key. The admin field identifies if this user has admin privileges for the group he belongs to. </paragraph>
<paragraph id="P-0119" lvl="3"><number>&lsqb;0119&rsqb;</number> b. License Database <highlight><bold>102</bold></highlight>&mdash;This is the database that stores licensing information, i.e., which user can run what application and under which license. This database also keeps track of usage information, i.e., which user has used which application for how long and how many times. The information looks like: </paragraph>
<paragraph id="P-0120" lvl="4"><number>&lsqb;0120&rsqb;</number> Username, application, time of usage, number of times run </paragraph>
<paragraph id="P-0121" lvl="4"><number>&lsqb;0121&rsqb;</number> Username, application, licensing policy </paragraph>
<paragraph id="P-0122" lvl="4"><number>&lsqb;0122&rsqb;</number> Username, application, is app running, no of instances, time of start </paragraph>
<paragraph id="P-0123" lvl="3"><number>&lsqb;0123&rsqb;</number> &emsp;The username is the primary key. The licensing policy could be something simple like expiry date or something more complicated like number of instances simultaneously allowed within a group etc. </paragraph>
<paragraph id="P-0124" lvl="3"><number>&lsqb;0124&rsqb;</number> c. Server Config Database <highlight><bold>103</bold></highlight>&mdash;This database stores information about which server can run which application, what is the load on all the servers, what is the encryption &ldquo;key&rdquo; to be used by the servers and all other information that is needed by the servers. The information looks like: </paragraph>
<paragraph id="P-0125" lvl="4"><number>&lsqb;0125&rsqb;</number> Server IP address, App/Slim server, application list, current load </paragraph>
<paragraph id="P-0126" lvl="4"><number>&lsqb;0126&rsqb;</number> Encryption key, Decryption key </paragraph>
<paragraph id="P-0127" lvl="3"><number>&lsqb;0127&rsqb;</number> &emsp;The Server IP address is the primary key for the first table. The keys are common across all servers. </paragraph>
<paragraph id="P-0128" lvl="3"><number>&lsqb;0128&rsqb;</number> d. Profile Database <highlight><bold>104</bold></highlight>&mdash;This database stores the profile information received by the profile server from the clients periodically. The information looks like: </paragraph>
<paragraph id="P-0129" lvl="4"><number>&lsqb;0129&rsqb;</number> Application ID, File ID, Block ID number of hits </paragraph>
<paragraph id="P-0130" lvl="3"><number>&lsqb;0130&rsqb;</number> &emsp;The Application ID is the primary key. </paragraph>
<paragraph id="P-0131" lvl="3"><number>&lsqb;0131&rsqb;</number> e. Application File Pages <highlight><bold>111</bold></highlight>&mdash;This is the one of the outputs of the &ldquo;builder&rdquo; as explained below and is put on the Application Server <highlight><bold>107</bold></highlight> so that it can serve the appropriate bits to the client. </paragraph>
<paragraph id="P-0132" lvl="3"><number>&lsqb;0132&rsqb;</number> f. Stream App Install Blocks <highlight><bold>112</bold></highlight>&mdash;This is the other output of the &ldquo;builder&rdquo; and contains the information for successfully installing applications on the client for streaming applications. </paragraph>
<paragraph id="P-0133" lvl="1"><number>&lsqb;0133&rsqb;</number> B) Client Components Supporting Application Delivery &amp; Execution </paragraph>
<paragraph id="P-0134" lvl="2"><number>&lsqb;0134&rsqb;</number> i) With respect to <cross-reference target="DRAWINGS">FIGS. 1 and 2</cross-reference>, these client components include: </paragraph>
<paragraph id="P-0135" lvl="3"><number>&lsqb;0135&rsqb;</number> a. Client/Server Network interface <highlight><bold>202</bold></highlight>&mdash;This is the same interface as explained above. </paragraph>
<paragraph id="P-0136" lvl="3"><number>&lsqb;0136&rsqb;</number> b. Client License Manager <highlight><bold>205</bold></highlight>&mdash;This component requests licenses (&ldquo;Access tokens&rdquo;) from the License Server <highlight><bold>106</bold></highlight> when the client wants to run applications. The License Server <highlight><bold>106</bold></highlight> sends an &ldquo;Access token&rdquo; to the client that can be used to run the applications by presenting it to the Application Server <highlight><bold>107</bold></highlight>. Along with the token, the License Server <highlight><bold>106</bold></highlight> also sends the expiry time of the token. The Client License Manager <highlight><bold>205</bold></highlight> renews the token just before the expiry period so that the client can continue running the application. When the application is complete, the Client License Manager <highlight><bold>205</bold></highlight> releases the token by sending a message to the License Server <highlight><bold>106</bold></highlight>. In addition, when a user has subscribed to an application, the Client License Manager <highlight><bold>205</bold></highlight> first checks to make sure that the application is installed on the machine the user is trying to run the application from and if not requests for the application installation. It does this using a list of Installed Apps that it maintains. </paragraph>
<paragraph id="P-0137" lvl="3"><number>&lsqb;0137&rsqb;</number> c. Client Cache Manager <highlight><bold>207</bold></highlight>&mdash;This component caches the application bits received from the Application Server <highlight><bold>107</bold></highlight> so that next time a request is made to the same bits, the request can be served by the cache instead of having to go to the Application Server <highlight><bold>107</bold></highlight>. The Client Cache Manager <highlight><bold>207</bold></highlight> has a limited amount of space on the disk of the client machine that it uses for the cache. When the space is fully occupied, the Client Cache Manager <highlight><bold>207</bold></highlight> uses a policy to replace existing portions of the cache. This policy can be something like LRU, FIFO, random etc. The Client Cache Manager <highlight><bold>207</bold></highlight> is responsible for getting the application bits requested by the Client Streaming File System <highlight><bold>212</bold></highlight>. If it does not have the bits cached, it gets them from the Application Server <highlight><bold>107</bold></highlight> through the network interface. However it also need to get the &ldquo;Access token&rdquo; from the Client License Manager <highlight><bold>205</bold></highlight> that it needs to send along with the request for the application bits. The Client Cache Manager <highlight><bold>207</bold></highlight> also updates the Prefetch History Info <highlight><bold>209</bold></highlight> with the requests it receives from the Client Streaming File System <highlight><bold>212</bold></highlight>. </paragraph>
<paragraph id="P-0138" lvl="3"><number>&lsqb;0138&rsqb;</number> d. Client Streaming File System <highlight><bold>212</bold></highlight>&mdash;This component serves all file system requests made by the application running on the client. The application makes calls like &ldquo;read&rdquo;, &ldquo;write&rdquo; etc. to files that need to be streamed. These requests lead to page faults in the operating system and the page faults are handled by the Client Streaming File System <highlight><bold>212</bold></highlight> that in turn asks the Client Cache Manager <highlight><bold>207</bold></highlight> for the appropriate bits. The Client Cache Manager <highlight><bold>207</bold></highlight> will send those bits from the cache if they exist there or forward the request to the Application Server <highlight><bold>107</bold></highlight> through the network interface to get the appropriate bits. </paragraph>
<paragraph id="P-0139" lvl="3"><number>&lsqb;0139&rsqb;</number> e. Client Prefetcher <highlight><bold>208</bold></highlight>&mdash;This component monitors the requests made by the client to the Application Server <highlight><bold>107</bold></highlight> and uses heuristics to make additional requests to the Application Server <highlight><bold>107</bold></highlight> so that the bits can be obtained from the Application Server <highlight><bold>107</bold></highlight> before the client machine makes the request for them. This is mainly to hide the latency between the client and the Application Server <highlight><bold>107</bold></highlight>. The history information of the requests is stored in the Prefetch History Info file <highlight><bold>209</bold></highlight>. </paragraph>
<paragraph id="P-0140" lvl="3"><number>&lsqb;0140&rsqb;</number> f. Client Profiler <highlight><bold>203</bold></highlight>&mdash;At specific time intervals, the client profiler sends the profile information, which is the Prefetch History Info to the prefetch server at the ASP that can then update the App Prefetch Page Lists for the different applications accordingly. </paragraph>
<paragraph id="P-0141" lvl="3"><number>&lsqb;0141&rsqb;</number> g. Client File Spoofer <highlight><bold>211</bold></highlight>&mdash;Certain files on the client need to be installed at specific locations on the client system. To be able to stream these files from the Application Server <highlight><bold>107</bold></highlight>, the Client Spoofer <highlight><bold>211</bold></highlight> intercepts all requests to these files made by a running application and redirects them to the Client Streaming File System <highlight><bold>212</bold></highlight> so that the bits can be streamed from the Application Server <highlight><bold>107</bold></highlight>. </paragraph>
<paragraph id="P-0142" lvl="3"><number>&lsqb;0142&rsqb;</number> h. Client Registry Spoofer <highlight><bold>213</bold></highlight>&mdash;Similar to files, certain registry entries need to be different when the application being streamed is running and since it is undesirable to overwrite the existing registry value, the read of the registry value is redirected to the Client Registry Spoofer <highlight><bold>215</bold></highlight> which returns the right value. However, this is optional as it is very likely that overwriting the existing registry value will make the system work just fine. </paragraph>
<paragraph id="P-0143" lvl="3"><number>&lsqb;0143&rsqb;</number> i. Client Network Spoofer <highlight><bold>213</bold></highlight>&mdash;Certain applications make networking calls through a protocol like TCP. To make these applications work across firewalls, these networking calls need to be redirected to the Client Network Spoofer <highlight><bold>213</bold></highlight> which can tunnel these requests through a protocol like HTTP that works through firewalls. </paragraph>
<paragraph id="P-0144" lvl="2"><number>&lsqb;0144&rsqb;</number> ii) The data structures needed to support the above client components include: </paragraph>
<paragraph id="P-0145" lvl="3"><number>&lsqb;0145&rsqb;</number> a. File Spoof Database <highlight><bold>210</bold></highlight>&mdash;The list of files the requests to which need to be redirected to the Client Streaming File System <highlight><bold>212</bold></highlight>. This information looks like (The source file name is the primary key) </paragraph>
<paragraph id="P-0146" lvl="4"><number>&lsqb;0146&rsqb;</number> Source File Name, Target File Name </paragraph>
<paragraph id="P-0147" lvl="3"><number>&lsqb;0147&rsqb;</number> b. Registry Spoof Database <highlight><bold>216</bold></highlight>&mdash;List of registry entries and their corresponding values that need to be spoofed. Each entry looks like: </paragraph>
<paragraph id="P-0148" lvl="4"><number>&lsqb;0148&rsqb;</number> Registry entry, new value </paragraph>
<paragraph id="P-0149" lvl="3"><number>&lsqb;0149&rsqb;</number> c. Network Spoof Database <highlight><bold>214</bold></highlight>&mdash;Like of IP addresses, the networking connections to which need to be redirected to the Client Network Spoofer <highlight><bold>213</bold></highlight>. Each entry looks like (IP address is the primary key): </paragraph>
<paragraph id="P-0150" lvl="4"><number>&lsqb;0150&rsqb;</number> IP address, Port number, new IP address, new Port number </paragraph>
<paragraph id="P-0151" lvl="3"><number>&lsqb;0151&rsqb;</number> d. Client Stream Cache <highlight><bold>206</bold></highlight>&mdash;The on-disk cache that persistently stores application bits. </paragraph>
<paragraph id="P-0152" lvl="3"><number>&lsqb;0152&rsqb;</number> e. Known ASPs and Installed Apps <highlight><bold>204</bold></highlight>&mdash;The list of ASP servers (Application, License and Subscription) and also the list of applications that are installed on the client. </paragraph>
<paragraph id="P-0153" lvl="3"><number>&lsqb;0153&rsqb;</number> f. Prefetch History Info <highlight><bold>209</bold></highlight>&mdash;The history of the requests made to the cache. This consists of which blocks were requested from which file for which application and how many times each block was requested. It also consists of predecessor-successor information indicating which block got requested after a particular block was requested. </paragraph>
<paragraph id="P-0154" lvl="1"><number>&lsqb;0154&rsqb;</number> C) Client Application Installation </paragraph>
<paragraph id="P-0155" lvl="0"><number>&lsqb;0155&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 3</cross-reference>, the client application installation components include: </paragraph>
<paragraph id="P-0156" lvl="2"><number>&lsqb;0156&rsqb;</number> i) Client License Manager <highlight><bold>303</bold></highlight>&mdash;This is the same component explained above. </paragraph>
<paragraph id="P-0157" lvl="2"><number>&lsqb;0157&rsqb;</number> ii) Client Application Installer <highlight><bold>305</bold></highlight>&mdash;This component is invoked when the application needs to be installed. The Client Application Installer <highlight><bold>305</bold></highlight> sends a specific request to the Application Server <highlight><bold>107</bold></highlight> for getting the Stream App Install Block <highlight><bold>301</bold></highlight> for the particular application that needs to be installed. The Stream App Install Block <highlight><bold>301</bold></highlight> consists of the App Prefetch Page List <highlight><bold>306</bold></highlight>, Spoof Database <highlight><bold>308</bold></highlight>, <highlight><bold>309</bold></highlight>, <highlight><bold>310</bold></highlight>, and App Registry Info <highlight><bold>307</bold></highlight>. The Client Application Installer <highlight><bold>305</bold></highlight> then updates the various Spoof Databases <highlight><bold>308</bold></highlight>, <highlight><bold>309</bold></highlight>, <highlight><bold>310</bold></highlight> and the Registry <highlight><bold>307</bold></highlight> with this information. It also asks the Client Prefetcher <highlight><bold>208</bold></highlight> to start fetching pages in the App Prefetch Page List <highlight><bold>306</bold></highlight> from the Application Server <highlight><bold>107</bold></highlight>. These are the pages that are known to be needed by a majority of the users when they run this application. </paragraph>
<paragraph id="P-0158" lvl="1"><number>&lsqb;0158&rsqb;</number> D) Application Stream Builder Input/Output </paragraph>
<paragraph id="P-0159" lvl="0"><number>&lsqb;0159&rsqb;</number> With respect to <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, the Builder components include the following: </paragraph>
<paragraph id="P-0160" lvl="2"><number>&lsqb;0160&rsqb;</number> i) Application Install Monitor <highlight><bold>403</bold></highlight>&mdash;This component monitors the installation of an application <highlight><bold>401</bold></highlight> and figures out all the files that have been created during installation <highlight><bold>402</bold></highlight>, registry entries that were created and all the other changes made to the system during installation. </paragraph>
<paragraph id="P-0161" lvl="2"><number>&lsqb;0161&rsqb;</number> ii) Application Profiler <highlight><bold>407</bold></highlight>&mdash;After the application is installed, it is executed using a sample script. The Application Profiler <highlight><bold>407</bold></highlight> monitors the application execution <highlight><bold>408</bold></highlight> and figures out the application pages that got referenced during the execution. </paragraph>
<paragraph id="P-0162" lvl="2"><number>&lsqb;0162&rsqb;</number> iii) App Stream Packager <highlight><bold>404</bold></highlight>&mdash;The App Stream Packager <highlight><bold>404</bold></highlight> takes the information gathered by the Application Profiler <highlight><bold>407</bold></highlight> and the Application Install Monitor <highlight><bold>403</bold></highlight> and forms the Application File Pages <highlight><bold>406</bold></highlight> and the Stream App Install Block <highlight><bold>405</bold></highlight> from that information. </paragraph>
<paragraph id="P-0163" lvl="1"><number>&lsqb;0163&rsqb;</number> E) Network Spoofing for client-server applications: </paragraph>
<paragraph id="P-0164" lvl="2"><number>&lsqb;0164&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIGS. 1, 4</cross-reference>, <highlight><bold>5</bold></highlight><highlight><italic>a</italic></highlight>, <highlight><bold>5</bold></highlight><highlight><italic>b</italic></highlight>, and <highlight><bold>6</bold></highlight><highlight><italic>a</italic></highlight>, the component that does the Network Spoofing is the TCP to HTTP converter <highlight><bold>503</bold></highlight>, <highlight><bold>507</bold></highlight>. The basic idea is to take TCP packets and tunnel them through HTTP on one side and do exactly the opposite on the other. As far as the client <highlight><bold>501</bold></highlight> and the server <highlight><bold>502</bold></highlight> are concerned the communication is TCP and so existing applications that run with that assumption work unmodified. This is explained in more detail below. </paragraph>
<paragraph id="P-0165" lvl="0"><number>&lsqb;0165&rsqb;</number> On the client side, the user launches an application that resides on the Client Streaming File System. That application may be started in the same ways that applications on other client file systems may be started, e.g., opening a data file associated with the application or selecting the application from the Start/Programs menu in a Windows system. From the point of view of the client&apos;s operating system and from the point of view of the application itself, that application is located locally on the client. </paragraph>
<paragraph id="P-0166" lvl="0"><number>&lsqb;0166&rsqb;</number> Whenever a page fault occurs on behalf of any application file residing on the Client Streaming File System <highlight><bold>604</bold></highlight>, that file system requests the page from the Client Cache Manager <highlight><bold>606</bold></highlight>. The Client Cache Manager <highlight><bold>606</bold></highlight>, after ensuring via interaction with the Client License Manager <highlight><bold>608</bold></highlight> that the user&apos;s client system holds a license to run the application at the current time, checks the Client Stream Cache <highlight><bold>611</bold></highlight> and satisfies the page fault from that cache, if possible. If the page is not currently in the Client Stream Cache <highlight><bold>611</bold></highlight>, the Client Cache Manager <highlight><bold>606</bold></highlight> makes a request to the Client/Server Network Interface <highlight><bold>505</bold></highlight>, <highlight><bold>609</bold></highlight> to obtain that page from the Application File Pages stored on an Application Server <highlight><bold>506</bold></highlight>. </paragraph>
<paragraph id="P-0167" lvl="0"><number>&lsqb;0167&rsqb;</number> The Client Prefetcher <highlight><bold>606</bold></highlight> tracks all page requests passed to the Client Cache Manager <highlight><bold>606</bold></highlight>. Based on the pattern of those requests and on program locality or program history, the Client Prefetcher <highlight><bold>606</bold></highlight> asks the Client Cache Manager <highlight><bold>606</bold></highlight> to send additional requests to the ClienVServer Network Interface <highlight><bold>505</bold></highlight>, <highlight><bold>609</bold></highlight> to obtain other pages from the Application File Pages stored on the Application Server <highlight><bold>506</bold></highlight>. </paragraph>
<paragraph id="P-0168" lvl="0"><number>&lsqb;0168&rsqb;</number> Files located on the Client Streaming File System <highlight><bold>604</bold></highlight> are typically identified by a particular prefix (like drive letter or pathname). However, some files whose names would normally imply that they reside locally are mapped to the Client Streaming File System <highlight><bold>604</bold></highlight>, in order to lower the invention&apos;s impact on the user&apos;s local configuration. For instance, there are certain shared library files (dil&apos;s) that need to be installed on the local file system (c:&bsol;winnt&bsol;system32&bsol;foo.dll). It is undesirable to add that file on the user&apos;s system. The file name gets added to a &ldquo;spoof database&rdquo; which contains an entry saying that c:&bsol;winnt&bsol;system32&bsol;foo.dll is mapped to z:&bsol;word&bsol;winnt&bsol;system32&bsol;foo.dll where z: implies that it is the Client Streaming File System. The Client Spoofer <highlight><bold>603</bold></highlight> will then redirect all accesses to c:&bsol;winnt&bsol;system32&bsol;foo.dll to z:&bsol;word&bsol;winnt&bsol;system32&bsol;foo.dll. In this manner the client system gets the effect of the file being on the local machine whereas in reality the file is streamed from the server. </paragraph>
<paragraph id="P-0169" lvl="0"><number>&lsqb;0169&rsqb;</number> In a similar fashion the Client Spoofer <highlight><bold>603</bold></highlight> may also be used to handle mapping TCP interfaces to HTTP interfaces. There are certain client-server applications (like ERP/CRM applications) that have a component running on a client and another component running on a database server, Web server etc. These components talk to each other through TCP connections. The client application will make TCP connections to the appropriate server (for this example, a database server) when the client piece of this application is being streamed on a user&apos;s machine. </paragraph>
<paragraph id="P-0170" lvl="0"><number>&lsqb;0170&rsqb;</number> The database server could be resident behind a firewall and the only way for the client and the server to communicate is through a protocol like HTTP that can pass through firewalls. To enable the client to communicate with the database server, the client&apos;s TCP requests need to be converted to HTTP and sent to the database server. Those requests can be converted back to TCP so that the database server can appropriately process the requests just before the requests reach the database server. The Client Spoofer&apos;s <highlight><bold>603</bold></highlight> responsibility in this case is to trap all TCP requests going to the database server and convert it into HTTP requests and take all HTTP requests coming from the database server and convert them into TCP packets. Note that the TCP to HTTP converters <highlight><bold>505</bold></highlight>, <highlight><bold>507</bold></highlight> convert TCP traffic to HTTP and vice versa by embedding TCP packets within the HTTP protocol and by extracting the TCP packets from the HTTP traffic. This is called tunneling. </paragraph>
<paragraph id="P-0171" lvl="0"><number>&lsqb;0171&rsqb;</number> When the Client License Manager <highlight><bold>608</bold></highlight> is asked about a client&apos;s status with respect to holding a license for a particular application and the license is not already being held, the Client License Manager <highlight><bold>608</bold></highlight> contacts the License Server <highlight><bold>106</bold></highlight> via the Client/Server Network Interface <highlight><bold>609</bold></highlight> and asks that the client machine be given the license. The License Server <highlight><bold>106</bold></highlight> checks the Subscription <highlight><bold>101</bold></highlight> and License <highlight><bold>102</bold></highlight> Databases and, if the user has the right to hold the license at the current time, it sends back an Access Token, which represents the right to use the license. This Access Token is renewed by the client on a periodic basis. </paragraph>
<paragraph id="P-0172" lvl="0"><number>&lsqb;0172&rsqb;</number> The user sets up and updates his information in the Subscription <highlight><bold>101</bold></highlight> and License <highlight><bold>102</bold></highlight> Databases via interacting with the Subscription Server <highlight><bold>105</bold></highlight>. Whenever a user changes his subscription information, the Subscription Server <highlight><bold>105</bold></highlight> signals the user&apos;s client system since the client&apos;s Known ASPs and Installed Apps information potentially needs updating. The client system also checks the Subscription <highlight><bold>101</bold></highlight> and License <highlight><bold>102</bold></highlight> Databases whenever the user logs into any of his client systems set up for Streaming Application Delivery and Execution. If the user&apos;s subscription list in the Subscription <highlight><bold>101</bold></highlight> and License <highlight><bold>102</bold></highlight> Databases list applications that have not been installed on the user&apos;s client system, the user is given the opportunity to choose to install those applications. </paragraph>
<paragraph id="P-0173" lvl="0"><number>&lsqb;0173&rsqb;</number> Whenever the user chooses to install an application, the Client License Manager <highlight><bold>608</bold></highlight> passes the request to the Client Application Installer <highlight><bold>607</bold></highlight> along with the name of the Stream App Install Block to be obtained from the Application Server <highlight><bold>107</bold></highlight>. The Client Application Installer <highlight><bold>607</bold></highlight> opens and reads that file (which engages the Client Streaming File System) and updates the Client system appropriately, including setting up the spoof database, downloading certain needed non-application-specific files, modifying the registry file, and optionally providing a list of applications pages to be prefetched to warm up the Client Stream Cache <highlight><bold>611</bold></highlight> with respect to the application. </paragraph>
<paragraph id="P-0174" lvl="0"><number>&lsqb;0174&rsqb;</number> The Application Stream Builder creates the Stream App Install Block <highlight><bold>405</bold></highlight> used to set up a client system for Streaming Application Delivery and Execution and it also creates the set of Application File Pages <highlight><bold>406</bold></highlight> sent to satisfy client requests by the Application Server <highlight><bold>107</bold></highlight>. The process that creates this information is offline and involves three components. The Application Install Monitor <highlight><bold>403</bold></highlight> watches a normal installation of the application and records various information including registry entries, required system configuration, file placement, and user options. The Application Profiler <highlight><bold>407</bold></highlight> watches a normal execution of the application and records referenced pages, which may be requested to pre-warm the client&apos;s cache on behalf of this application. The Application Stream Packager <highlight><bold>404</bold></highlight> takes information from the other two Builder components, plus some information it compiles with respect to the layout of the installed application and forms the App Install Block <highlight><bold>405</bold></highlight> and the set of Application File Pages <highlight><bold>406</bold></highlight>. </paragraph>
<paragraph id="P-0175" lvl="0"><number>&lsqb;0175&rsqb;</number> Server fail-over and server quality of service problems are handled by the client via observation and information provided by the server components. An ASP&apos;s Subscription Server provides a list of License Servers associated with that ASP to the client, when the user initiates/modifies his account or when the client software explicitly requests a new list. A License Server provides a list of Application Servers associated with an application to the client, whenever it sends the client an Access Token for the application. </paragraph>
<paragraph id="P-0176" lvl="0"><number>&lsqb;0176&rsqb;</number> Should the client observe apparent non-response or slow response from an Application Server, it switches to another Application Server in its list for the application in question. If none of the Application Servers in its list respond adequately, the client requests a new set for the application from a License Server. The strategy is similar in the case in which the client observes apparent non-response or slow response from a License Server; the client switches to another License Server in its list for the ASP in question. If none of the License Servers in its list responds adequately, the client requests a new set of License Servers from the ASP. </paragraph>
<paragraph id="P-0177" lvl="0"><number>&lsqb;0177&rsqb;</number> Server load balancing is handled by the server components in cooperation with the client. A server monitor component tracks the overall health and responsiveness of all servers. When a server is composing one of the server lists mentioned in the previous paragraph, it selects a set that is alive and relatively more lightly used than others. Client cooperation is marked by the client using the server lists provided by the servers in the expected way, and not unilaterally doing something unexpected, like continuing to use a server which does not appear in the most recent list provided. </paragraph>
<paragraph id="P-0178" lvl="0"><number>&lsqb;0178&rsqb;</number> Security issues associated with the server client relationship are considered in the invention. To ensure that the communication between servers and clients is private and that the servers in question are authorized via appropriate certification, an SSL layer is used. To ensure that the clients are licensed to use a requested application, user credentials (username&plus;password) are presented to a License Server, which validates the user and his licensing status with respect to the application in question and issues an Access Token, and that Access Token is in turn presented to an Application Server, which verifies that the Token&apos;s validity before delivering the requested page. Protecting the application in question from piracy on the client&apos;s system is discussed in another section, below. </paragraph>
</section>
<section>
<heading lvl="1">Client-side Performance Optimization </heading>
<paragraph id="P-0179" lvl="0"><number>&lsqb;0179&rsqb;</number> This section focuses on client-specific portions of the invention. The invention may be applied to any operating system that provides a file system interface or block driver interface. A preferred embodiment of the invention is Windows 2000 compliant. </paragraph>
<paragraph id="P-0180" lvl="0"><number>&lsqb;0180&rsqb;</number> With respect to <cross-reference target="DRAWINGS">FIG. 6</cross-reference><highlight><italic>a</italic></highlight>, several different components of the client software are shown. Some components will typically run as part of the operating system kernel, and other portions will run in user mode. </paragraph>
<paragraph id="P-0181" lvl="0"><number>&lsqb;0181&rsqb;</number> The basis of the client side of the streamed application delivery and execution system is a mechanism for making applications appear as though they were installed on the client computer system without actually installing them. </paragraph>
<paragraph id="P-0182" lvl="0"><number>&lsqb;0182&rsqb;</number> Installed applications are stored in the file system of the client system as files organized in directories. In the state of the art, there are two types of file systems: local and network. Local file systems are stored entirely on media (disks) physically resident in the client machine. Network file systems are stored on a machine physically separate from the client, and all requests for data are satisfied by getting the data from the server. Network file systems are typically slower than local file systems. A traditional approach to use the better performance of a local file system is to install important applications on the local file system, thereby copying the entire application to the local disk. The disadvantages of this approach are numerous. Large applications may take a significant amount of time to download, especially across slower wide area networks. Upgrading applications is also more difficult, since each client machine must individually be upgraded. </paragraph>
<paragraph id="P-0183" lvl="0"><number>&lsqb;0183&rsqb;</number> The invention eliminates these two problems by providing a new type of file system: a streaming file system. The streaming file system allows applications to be run immediately by retrieving application file contents from the server as they are needed, not as the application is installed. This removes the download cost penalty of doing local installations of the application. The streaming file system also contains performance enhancements that make it superior to running applications directly from a network file system. The streaming file system caches file system contents on the local machine. File system accesses that hit in the cache are nearly as fast as those to a local file system. The streaming file system also has sophisticated information about application file access patterns. By using this knowledge, the streaming file system can request portions of application files from the server in advance of when they will actually be needed, thus further improving the performance of applications running on the application streaming file system. </paragraph>
<paragraph id="P-0184" lvl="0"><number>&lsqb;0184&rsqb;</number> In a preferred embodiment of the invention, the application streaming file system is implemented on the client using a file system driver and a helper application running in user mode. The file system driver receives all requests from the operating system for files belonging to the application streaming file system. The requests it handles are all of the standard file system requests that every file system must handle, including (but not limited to) opening and closing files, reading and writing files, renaming files, and deleting files. Each file has a unique identifier consisting of an application number, and a file number within that application. In one embodiment of the invention, the application number is 128 bits and the file number is 32 bits, resulting in a unique file ID that is 160 bits long. The file system driver is responsible for converting path names (such as &ldquo;z:&bsol;program files&bsol;foo.exe&rdquo;) into file IDs (this is described below). Once the file system driver has made this translation, it basically forwards the request to the user-mode program to handle. </paragraph>
<paragraph id="P-0185" lvl="0"><number>&lsqb;0185&rsqb;</number> The user-mode program is responsible for managing the cache of application file contents on the local file system and contacting the application streaming server for file contents that it cannot satisfy out of the local cache. For each file system request, such as read or open, the user-mode process will check to see if it has the requested information in the cache. If it does, it can copy the data from the cache and return it to the file system driver. If it does not, it contacts the application streaming server over the network and obtains the information it needs. To obtain the contents of the file, the user-mode process sends the file identifier for the file it is interested in reading along with an offset at which to read and the number of bytes to read. The application streaming server will send back the requested data. </paragraph>
<paragraph id="P-0186" lvl="0"><number>&lsqb;0186&rsqb;</number> The file system can be implemented using a fragmented functionality to facilitate development and debugging. All of the functionality of the user-mode component can be put into the file system driver itself without significantly changing the scope of the invention. Such an approach is believed to be preferred for a client running Windows 95 as the operating system. </paragraph>
<paragraph id="P-0187" lvl="0"><number>&lsqb;0187&rsqb;</number> Directories are specially formatted files. The file system driver reads these from the user mode process just like any other files with reads and writes. Along with a header containing information about the directory (such as how long it is), the directory contains one entry for each file that it contains. Each entry contains the name of the file and its file identifier. The file identifier is necessary so that the specified file can be opened, read, or written. Note that since directories are files, directories may recursively contain other directories. All files in an application streaming file system are eventual descendents of a special directory called the &ldquo;root&rdquo;. The root directory is used as the starting point for parsing file names. </paragraph>
<paragraph id="P-0188" lvl="0"><number>&lsqb;0188&rsqb;</number> Given a name like &ldquo;z:/foo/bar/baz&rdquo;, the file system driver must translate the path &ldquo;z:/foo/bar/baz&rdquo; into a file identifier that can be used to read the file from the application streaming service. First, the drive letter is stripped off, leaving &ldquo;/foo/bar/baz&rdquo;. The root directory will be searched for the first part of the path, in this case &ldquo;foo&rdquo;. If the file &ldquo;foo&rdquo; is found in the root directory, and the file &ldquo;foo&rdquo; is a directory, then &ldquo;foo&rdquo; will be searched for the next portion of the path, &ldquo;bar&rdquo;. The file system driver achieves this by using the file id for &ldquo;foo&rdquo; (found by searching the root directory) to open the file and read its contents. The entries inside &ldquo;foo&rdquo; are then searched for &ldquo;bar&rdquo;, and this process continues until the entire path is parsed, or an error occurs. </paragraph>
<paragraph id="P-0189" lvl="0"><number>&lsqb;0189&rsqb;</number> In the following examples and text, the root directory is local and private to the client. Each application that is installed will have its own special subdirectory in the root directory. This subdirectory will be the root of the application. Each application has its own root directory. </paragraph>
<paragraph id="P-0190" lvl="0"><number>&lsqb;0190&rsqb;</number> The invention&apos;s approach is much more efficient than other approaches like the standard NFS approach. In those cases, the client sends the entire path &ldquo;/foo/bar/baz&rdquo; to the server and the server returns the file id for that file. The next time there is a request for &ldquo;/foo/bar/baz2&rdquo; the entire path again needs to be sent. In the approach described here, once the request for &ldquo;bar&rdquo; was made, the file ids for all files within bar are sent back including the ids for &ldquo;baz&rdquo; and &ldquo;baz<highlight><bold>2</bold></highlight>&rdquo; and hence &ldquo;baz2&rdquo; will already be known to client. This reduces communication between the client and the server. </paragraph>
<paragraph id="P-0191" lvl="0"><number>&lsqb;0191&rsqb;</number> In addition, this structure also allows applications to be easily updated. If certain code segments need to be updated, then the code segment listing in the application root directory is simply changed and the new code segment subdirectory added. This results in the new and correct code segment subdirectory being read when it is referenced. For example if a file by the name of &ldquo;/foo/bar/baz3&rdquo; needs to be added, the root directory is simply changed to point to a new version of &ldquo;foo&rdquo; and that new version of &ldquo;foo&rdquo; points to a new version of &ldquo;bar&rdquo; which contains &ldquo;baz3&rdquo; in addition to the files it already contained. However the rest of the system is unchanged. </paragraph>
</section>
<section>
<heading lvl="1">Client Features </heading>
<paragraph id="P-0192" lvl="0"><number>&lsqb;0192&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIGS. 6</cross-reference><highlight><italic>a </italic></highlight>and <highlight><bold>6</bold></highlight><highlight><italic>b</italic></highlight>, a key aspect of the preferred embodiment of the invention is that application code and data are cached in the client&apos;s persistent storage <highlight><bold>616</bold></highlight>, <highlight><bold>620</bold></highlight>. This caching provides better performance for the client, as accessing code and data in the client&apos;s persistent storage <highlight><bold>620</bold></highlight> is typically much faster than accessing that data across a wide area network. This caching also reduces the load on the server, since the client need not retrieve code or data from the application server that it already has in its local persistent storage. </paragraph>
<paragraph id="P-0193" lvl="0"><number>&lsqb;0193&rsqb;</number> In order to run an application, its code and data must be present in the client system&apos;s volatile storage <highlight><bold>619</bold></highlight>. The client software maintains a cache of application code and data that normally reside in the client system&apos;s nonvolatile memory <highlight><bold>620</bold></highlight>. When the running application requires data that is not present in volatile storage <highlight><bold>619</bold></highlight>, the client streaming software <highlight><bold>604</bold></highlight> is asked for the necessary code or data. The client software first checks its cache <highlight><bold>611</bold></highlight>, <highlight><bold>620</bold></highlight> in nonvolatile storage for the requested code or data. If it is found there, the code or data are copied from the cache in nonvolatile storage <highlight><bold>620</bold></highlight> to volatile memory <highlight><bold>619</bold></highlight>. If the requested code or data are not found in the nonvolatile cache <highlight><bold>611</bold></highlight>, <highlight><bold>620</bold></highlight>, the client streaming software <highlight><bold>604</bold></highlight> will acquire the code or data from the server system via the client&apos;s network interface <highlight><bold>621</bold></highlight>, <highlight><bold>622</bold></highlight>. </paragraph>
<paragraph id="P-0194" lvl="0"><number>&lsqb;0194&rsqb;</number> Application code and data may be compressed <highlight><bold>623</bold></highlight>, <highlight><bold>624</bold></highlight> on the server to provide better client performance over slow networks. Network file systems typically do not compress the data they send, as they are optimized to operate over local area networks. </paragraph>
<paragraph id="P-0195" lvl="0"><number>&lsqb;0195&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 7</cross-reference><highlight><italic>a </italic></highlight>&amp; <highlight><bold>7</bold></highlight><highlight><italic>b </italic></highlight>demonstrate two ways in which data may be compressed while in transit between the server and client. With either mechanism, the client may request multiple pieces of code and data from multiple files at once. <cross-reference target="DRAWINGS">FIG. 7A</cross-reference> illustrates the server <highlight><bold>701</bold></highlight> compressing the concatenation of A, B, C, and D <highlight><bold>703</bold></highlight> and sending this to the client <highlight><bold>702</bold></highlight>. <cross-reference target="DRAWINGS">FIG. 7B</cross-reference> illustrates the server <highlight><bold>706</bold></highlight> separately compressing A, B, C, and D <highlight><bold>708</bold></highlight> and sending the concatenation of these compressed regions to the client <highlight><bold>707</bold></highlight>. In either case, the client <highlight><bold>702</bold></highlight>, <highlight><bold>707</bold></highlight> will decompress the blocks to retrieve the original contents A, B, C, and D <highlight><bold>704</bold></highlight>, <highlight><bold>709</bold></highlight> and these contents will be stored in the cache <highlight><bold>705</bold></highlight>, <highlight><bold>710</bold></highlight>. </paragraph>
<paragraph id="P-0196" lvl="0"><number>&lsqb;0196&rsqb;</number> The boxes marked &ldquo;Compression&rdquo; represent any method of making data more compact, including software algorithms and hardware. The boxes marked &ldquo;Decompression&rdquo; represent any method for expanding the compacted data, including software algorithms and hardware. The decompression algorithm used must correspond to the compression algorithm used. </paragraph>
<paragraph id="P-0197" lvl="0"><number>&lsqb;0197&rsqb;</number> The mechanism for streaming of application code and data may be a file system. Many network file systems exist. Some are used to provide access to applications, but such systems typically operate well over a local area network (LAN) but perform poorly over a wide area network (WAN). While this solution involves a file system driver as part of the client streaming software, it is more of an application delivery mechanism than an actual file system. </paragraph>
<paragraph id="P-0198" lvl="0"><number>&lsqb;0198&rsqb;</number> With respect to <cross-reference target="DRAWINGS">FIG. 8</cross-reference>, application code and data are installed onto the file system <highlight><bold>802</bold></highlight>, <highlight><bold>805</bold></highlight>, <highlight><bold>806</bold></highlight>, <highlight><bold>807</bold></highlight> of a client machine, but they are executed from the volatile storage (main memory). This approach to streamed application delivery involves installing a special application streaming file system <highlight><bold>803</bold></highlight>, <highlight><bold>804</bold></highlight>. To the client machine, the streaming file system <highlight><bold>803</bold></highlight>, <highlight><bold>804</bold></highlight> appears to contain the installed application <highlight><bold>801</bold></highlight>. The application streaming file system <highlight><bold>803</bold></highlight> will receive all requests for code or data that are part of the application <highlight><bold>801</bold></highlight>. This file system <highlight><bold>803</bold></highlight> will satisfy requests for application code or data by retrieving it from its special cache stored in a native file system or by retrieving it directly from the streaming application server <highlight><bold>802</bold></highlight>. Code or data retrieved from the server <highlight><bold>802</bold></highlight> will be placed in the cache in case it is used again. </paragraph>
<paragraph id="P-0199" lvl="0"><number>&lsqb;0199&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 9</cross-reference>, an alternative organization of the streaming client software is shown. The client software is divided into the kernel-mode streaming file system driver <highlight><bold>905</bold></highlight> and a user-mode client <highlight><bold>902</bold></highlight>. Requests made to the streaming file system driver <highlight><bold>905</bold></highlight> are all directed to the user-mode client <highlight><bold>902</bold></highlight>, which handles the streams from the application streaming server <highlight><bold>903</bold></highlight> and sends the results back to the driver <highlight><bold>905</bold></highlight>. The advantage of this approach is that it is easier to develop and debug compared with the pure-kernel mode approach. The disadvantage is that the performance will be worse than that of a kernel-only approach. </paragraph>
<paragraph id="P-0200" lvl="0"><number>&lsqb;0200&rsqb;</number> As shown in <cross-reference target="DRAWINGS">FIGS. 10 and 11</cross-reference>, the mechanism for streaming of application code and data may be a block driver <highlight><bold>1004</bold></highlight>, <highlight><bold>1106</bold></highlight>. This approach is an alternative to that represented by <cross-reference target="DRAWINGS">FIGS. 8 and 9</cross-reference>. </paragraph>
<paragraph id="P-0201" lvl="0"><number>&lsqb;0201&rsqb;</number> With respect to <cross-reference target="DRAWINGS">FIG. 10</cross-reference>, the application streaming software consists of a streaming block driver <highlight><bold>1004</bold></highlight>. This block driver <highlight><bold>1004</bold></highlight> provides the abstraction of a physical disk to a native file system <highlight><bold>1003</bold></highlight> already installed on the client operating system <highlight><bold>1002</bold></highlight>. The driver <highlight><bold>1004</bold></highlight> receives requests for physical block reads and writes, which it satisfies out of a cache on a standard file system <highlight><bold>1003</bold></highlight> that is backed by a physical disk drive <highlight><bold>1006</bold></highlight>, <highlight><bold>1007</bold></highlight>. Requests that cannot be satisfied by the cache go to the streaming application server <highlight><bold>1005</bold></highlight>, as before. </paragraph>
<paragraph id="P-0202" lvl="0"><number>&lsqb;0202&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 11</cross-reference>, the application streaming software has been divided into a disk driver <highlight><bold>1106</bold></highlight> and a user mode client <highlight><bold>1</bold></highlight> <highlight><bold>102</bold></highlight>. In a manner similar to that of <cross-reference target="DRAWINGS">FIG. 9</cross-reference>, the disk driver <highlight><bold>1106</bold></highlight> sends all requests it gets to the user-mode client <highlight><bold>1102</bold></highlight>, which satisfies them out of the cache <highlight><bold>1</bold></highlight> <highlight><bold>107</bold></highlight>, <highlight><bold>1108</bold></highlight> or by going to the application streaming server <highlight><bold>1103</bold></highlight>. </paragraph>
<paragraph id="P-0203" lvl="0"><number>&lsqb;0203&rsqb;</number> The persistent cache may be encrypted with a key not permanently stored on the client to prevent unauthorized use or duplication of application code or data. Traditional network file systems do not protect against the unauthorized use or duplication of file system data. </paragraph>
<paragraph id="P-0204" lvl="0"><number>&lsqb;0204&rsqb;</number> With respect to <cross-reference target="DRAWINGS">FIG. 12</cross-reference>, unencrypted and encrypted client caches. A, B, C, and D <highlight><bold>1201</bold></highlight> representing blocks of application code and data in their natural form are shown. E<highlight><subscript>k</subscript></highlight>(X) represents the encryption of block X with key k <highlight><bold>1202</bold></highlight>. </paragraph>
<paragraph id="P-0205" lvl="0"><number>&lsqb;0205&rsqb;</number> Any encryption algorithm may be used. The key k is sent to the client upon application startup, and it is not stored in the application&apos;s persistent storage. </paragraph>
<paragraph id="P-0206" lvl="0"><number>&lsqb;0206&rsqb;</number> Client-initiated prefetching of application code and data helps to improve interactive application performance. Traditional network file systems have no prefetching or simple locality based prefetching. </paragraph>
<paragraph id="P-0207" lvl="0"><number>&lsqb;0207&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 13</cross-reference>, the application <highlight><bold>1301</bold></highlight> generates a sequence of code or data requests <highlight><bold>1302</bold></highlight> to the operating system(OS) <highlight><bold>1303</bold></highlight>. The OS <highlight><bold>1303</bold></highlight> directs these <highlight><bold>1304</bold></highlight> to the client application streaming software <highlight><bold>1305</bold></highlight>. The client software <highlight><bold>1305</bold></highlight> will fetch the code or data <highlight><bold>1306</bold></highlight> for any requests that do not hit in the cache from the server <highlight><bold>1307</bold></highlight>, via the network. The client software <highlight><bold>1305</bold></highlight> inspects these requests and consults the contents of the cache <highlight><bold>1309</bold></highlight> as well as historic information about application fetching patterns <highlight><bold>1308</bold></highlight>. It will use this information to request additional blocks of code and data that it expects will be needed soon. This mechanism is referred to as &ldquo;pull prefetching.&rdquo;</paragraph>
<paragraph id="P-0208" lvl="0"><number>&lsqb;0208&rsqb;</number> Server-initiated prefetching of application code and data helps to improve interactive application performance. Traditional network file systems have no prefetching or simple locality based prefetching. </paragraph>
<paragraph id="P-0209" lvl="0"><number>&lsqb;0209&rsqb;</number> With respect to <cross-reference target="DRAWINGS">FIG. 14</cross-reference>, the server-based prefetching is shown. As in <cross-reference target="DRAWINGS">FIG. 13</cross-reference>, the client application streaming software <highlight><bold>1405</bold></highlight> makes requests for blocks <highlight><bold>1407</bold></highlight> from the application streaming server <highlight><bold>1408</bold></highlight>. The server <highlight><bold>1408</bold></highlight> examines the patterns of requests made by this client and selectively returns to the client additional blocks <highlight><bold>1406</bold></highlight> that the client did not request but is likely to need soon. This mechanism is referred to as &ldquo;push prefetching.&rdquo;</paragraph>
<paragraph id="P-0210" lvl="0"><number>&lsqb;0210&rsqb;</number> A client-to-client communication mechanism allows local application customization to travel from one client machine to another without involving server communication. Some operating systems have a mechanism for copying a user&apos;s configuration and setup to another machine. However, this mechanism typically doesn&apos;t work outside of a single organization&apos;s network, and usually will copy the entire environment, even if only the settings for a single application are desired. </paragraph>
<paragraph id="P-0211" lvl="0"><number>&lsqb;0211&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 15, a</cross-reference> client-to-client mechanism is demonstrated. When a user wishes to run an application on a second machine, but wishes to retain customizations made previously on the first, the client software will handle this by contacting the first machine to retrieve customized files and other customization data. Unmodified files will be retrieved as usual from the application streaming server. </paragraph>
<paragraph id="P-0212" lvl="0"><number>&lsqb;0212&rsqb;</number> Here, File <highlight><bold>4</bold></highlight> exists in three different versions. The server <highlight><bold>1503</bold></highlight> provides one version of this file <highlight><bold>1506</bold></highlight>, client <highlight><bold>1</bold></highlight> <highlight><bold>1501</bold></highlight> has a second version of this file <highlight><bold>1504</bold></highlight>, and client <highlight><bold>2</bold></highlight> <highlight><bold>1502</bold></highlight> has a third version <highlight><bold>1505</bold></highlight>. Files may be modified differently for each client. </paragraph>
<paragraph id="P-0213" lvl="0"><number>&lsqb;0213&rsqb;</number> The clients may also contain files not present on the server or on other clients. File <highlight><bold>5</bold></highlight> <highlight><bold>1507</bold></highlight> is one such file; it exists only on client <highlight><bold>1</bold></highlight> <highlight><bold>1501</bold></highlight>. File <highlight><bold>6</bold></highlight> <highlight><bold>1508</bold></highlight> only exists on client <highlight><bold>2</bold></highlight> <highlight><bold>1502</bold></highlight>. </paragraph>
</section>
<section>
<heading lvl="1">Local Customization </heading>
<paragraph id="P-0214" lvl="0"><number>&lsqb;0214&rsqb;</number> A local copy-on-write file system allows some applications to write configuration or initialization files where they want to without rewriting the application, and without disturbing the local customization of other clients. Installations of applications on file servers typically do not allow the installation directories of applications to be written, so additional reconfiguration or rewrites of applications are usually necessary to allow per-user customization of some settings. </paragraph>
<paragraph id="P-0215" lvl="0"><number>&lsqb;0215&rsqb;</number> With respect to <cross-reference target="DRAWINGS">FIG. 16</cross-reference>, the cache <highlight><bold>1602</bold></highlight> with extensions for supporting local file customization is shown. Each block of data in the cache is marked as &ldquo;clean&rdquo; <highlight><bold>1604</bold></highlight> or &ldquo;dirty&rdquo; <highlight><bold>1605</bold></highlight>. Pages marked as dirty have been customized by the client <highlight><bold>1609</bold></highlight>, and cannot be removed from the cache <highlight><bold>1602</bold></highlight> without losing client customization. Pages marked as clean may be purged from the cache <highlight><bold>1602</bold></highlight>, as they can be retrieved again from the server <highlight><bold>1603</bold></highlight>. The index <highlight><bold>1601</bold></highlight> indicates which pages are clean and dirty. In <cross-reference target="DRAWINGS">FIG. 16</cross-reference>, clean pages are white, and dirty pages are shaded. File <highlight><bold>1</bold></highlight> <highlight><bold>1606</bold></highlight> contains only clean pages, and thus may be entirely evicted from the cache <highlight><bold>1602</bold></highlight>. File <highlight><bold>2</bold></highlight> <highlight><bold>1607</bold></highlight> contains only dirty pages, and cannot be removed at all from the cache <highlight><bold>1602</bold></highlight>. File <highlight><bold>3</bold></highlight> <highlight><bold>1608</bold></highlight> contains some clean and some dirty pages <highlight><bold>1602</bold></highlight>. The clean pages of File <highlight><bold>3</bold></highlight> <highlight><bold>1608</bold></highlight> may be removed from the cache <highlight><bold>1602</bold></highlight>, while the dirty pages must remain. </paragraph>
</section>
<section>
<heading lvl="1">Selective Write Protection </heading>
<paragraph id="P-0216" lvl="0"><number>&lsqb;0216&rsqb;</number> The client streaming software disallows modifications to certain application files. This provides several benefits, such as preventing virus infections and reducing the chance of accidental application corruption. Locally installed files are typically not protected in any way other than conventional backup. Application file servers may be protected against writing by client machines, but are not typically protected against viruses running on the server itself. Most client file systems allow files to be marked as read-only, but it is typically possible to change a file from read-only to read-write. The client application streaming software will not allow any data to be written to files that are marked as not modifiable. Attempts to mark the file as writeable will not be successful. </paragraph>
</section>
<section>
<heading lvl="1">Error Detection and Correction </heading>
<paragraph id="P-0217" lvl="0"><number>&lsqb;0217&rsqb;</number> The client streaming software maintains checksums of application code and data and can repair damaged or deleted files by retrieving another copy from the application streaming server. Traditional application delivery mechanisms do not make any provisions for detecting or correcting corrupted application installs. The user typically detects a corrupt application, and the only solution is to completely reinstall the application. Corrupt application files are detected by the invention automatically, and replacement code or data are invisibly retrieved by the client streaming software without user intervention. </paragraph>
<paragraph id="P-0218" lvl="0"><number>&lsqb;0218&rsqb;</number> When a block of code or data is requested by the client operating system, the client application streaming software will compute the checksum of the data block before it is returned to the operating system. If this checksum does not match that stored in the cache, the client will invalidate the cache entry and retrieve a fresh copy of the page from the server. </paragraph>
</section>
<section>
<heading lvl="1">File Identifiers </heading>
<paragraph id="P-0219" lvl="0"><number>&lsqb;0219&rsqb;</number> Applications may be patched or upgraded via a change in the root directory for that application. Application files that are not affected by the patch or upgrade need not be downloaded again. Most existing file systems do not cache files locally. </paragraph>
<paragraph id="P-0220" lvl="0"><number>&lsqb;0220&rsqb;</number> Each file has a unique identifier (number). Files that are changed or added in the upgrade are given new identifiers never before used for this application. Files that are unchanged keep the same number. Directories whose contents change are also considered changes. If any file changes, this will cause its parent to change, all the way up to the root directory. </paragraph>
</section>
<section>
<heading lvl="1">Upgrade Mechanism </heading>
<paragraph id="P-0221" lvl="0"><number>&lsqb;0221&rsqb;</number> When the client is informed of an upgrade, it is told of the new root directory. It uses this new root directory to search for files in the application. When retrieving an old file that hasn&apos;t changed, it will find the old file identifier, which can be used for the existing files in the cache. In this way, files that do not change can be reused from the cache without downloading them again. For a file that has changed, when the file name is parsed, the client will find a new file number. Because this file number did not exist before the upgrade, the client will not have this file in the cache, and will stream the new file contents when the file is freshly accessed. This way it always gets the newest version of files that change. </paragraph>
<paragraph id="P-0222" lvl="0"><number>&lsqb;0222&rsqb;</number> The client application streaming software can be notified of application upgrades by the streaming application server. These upgrades can be marked as mandatory, in which case the client software will force the application to be upgraded. </paragraph>
<paragraph id="P-0223" lvl="0"><number>&lsqb;0223&rsqb;</number> The client will contact the application streaming server when it starts the application. At this time, the streaming application server can inform the client of any upgrades. If the upgrade is mandatory, the client will be informed, and it will automatically begin using the upgraded application by using the new root directory. </paragraph>
</section>
<section>
<heading lvl="1">Multicast Technique </heading>
<paragraph id="P-0224" lvl="0"><number>&lsqb;0224&rsqb;</number> A broadcast or multicast medium may be used to efficiently distribute applications from one application streaming server to multiple application streaming clients. Traditional networked application delivery mechanisms usually involve installing application code and data on a central server and having client machines run the application from that server. The multicast mechanism allows a single server to broadcast or multicast the contents of an application to many machines simultaneously. The client machines will receive the application via the broadcast and save it in their local disk cache. The entire application can be distributed to a large number of client machines from a single server very efficiently. </paragraph>
<paragraph id="P-0225" lvl="0"><number>&lsqb;0225&rsqb;</number> The multicast network is any communication mechanism that has broadcast or multicast capability. Such media include television and radio broadcasts and IP multicasting on the Internet. Each client that is interested in a particular application may listen to the multicast media for code and data for that application. The code and data are stored in the cache for later use when the application is run. </paragraph>
<paragraph id="P-0226" lvl="0"><number>&lsqb;0226&rsqb;</number> These client techniques can be used to distribute data that changes rarely. Application delivery is the most appealing use for these techniques, but they could easily be adopted to distribute other types of slowly changing code and data, such as static databases. </paragraph>
</section>
<section>
<heading lvl="1">Load Balancing and Fault Tolerance for Streamed Applications </heading>
<paragraph id="P-0227" lvl="0"><number>&lsqb;0227&rsqb;</number> This section focuses on load balancing (and thereby scalability) and hardware fail over. Throughout this discussion reference should be made to <cross-reference target="DRAWINGS">FIG. 17</cross-reference>. Load balancing and fault tolerance are addressed in the invention by using a smart client and smart server combination. A preferred embodiment of the invention that implements these features includes three types of servers (described below): app servers; SLM servers; and an ASP Web server. These are organized as follows: </paragraph>
<paragraph id="P-0228" lvl="2"><number>&lsqb;0228&rsqb;</number> 1: ASP Web server <highlight><bold>1703</bold></highlight>&mdash;This is the Web server that the user goes to for subscribing to applications, creating accounts etc. Compared to the other two types of servers it is characterized by: lowest traffic, fewest number of them, &amp; least likely to go down. </paragraph>
<paragraph id="P-0229" lvl="2"><number>&lsqb;0229&rsqb;</number> 2: SLM Servers <highlight><bold>1707</bold></highlight>&mdash;subscription license manager servers&mdash;These keep track of which user has subscribed to what applications under what license etc. Compared to the other two types of servers it is characterized by: medium traffic, manageable number, and less likely to go down. </paragraph>
<paragraph id="P-0230" lvl="2"><number>&lsqb;0230&rsqb;</number> 3: App Servers <highlight><bold>1710</bold></highlight>&mdash;These are the servers to which the users go to for application pages. Compared to the other two types of servers it is characterized by: highest traffic, most number of them, most likely to go down either due to hardware failure or application re-configuration. </paragraph>
</section>
<section>
<heading lvl="1">Server Lists </heading>
<paragraph id="P-0231" lvl="0"><number>&lsqb;0231&rsqb;</number> Clients <highlight><bold>1704</bold></highlight> subscribe and unsubscribe to applications via the ASP Web server <highlight><bold>1703</bold></highlight>. At that point, instead of getting a primary and a secondary server that can perform the job, the ASP Web server <highlight><bold>1703</bold></highlight> gives them a non-prioritized list of a large number of SLM servers <highlight><bold>1706</bold></highlight> that can do the job. When the application starts to run, each client contacts the SLM servers <highlight><bold>1707</bold></highlight>, <highlight><bold>1708</bold></highlight>, <highlight><bold>1709</bold></highlight> and receive its application server list <highlight><bold>1705</bold></highlight> that can serve the application in question and also receive the access tokens that can be used to validate themselves with the application servers <highlight><bold>1710</bold></highlight>-<highlight><bold>1715</bold></highlight>. All access tokens have an expiration time after which they need to be renewed. </paragraph>
</section>
<section>
<heading lvl="1">Server Selection </heading>
<paragraph id="P-0232" lvl="0"><number>&lsqb;0232&rsqb;</number> Having gotten a server list for each type of server <highlight><bold>1705</bold></highlight>, <highlight><bold>1706</bold></highlight>, the client <highlight><bold>1704</bold></highlight> will decide which specific server to send its request to. In a basic implementation, a server is picked randomly from the list, which will distribute the client&apos;s load on the servers very close to evenly. An alternative preferred implementation will do as follows: </paragraph>
<paragraph id="P-0233" lvl="2"><number>&lsqb;0233&rsqb;</number> a) Clients will initially pick servers from the list randomly, but they will also keep track of the overall response time they get from each request; and </paragraph>
<paragraph id="P-0234" lvl="2"><number>&lsqb;0234&rsqb;</number> b) As each client learns about response times for each server, it can be more intelligent (rather than random) and pick the most responsive server. It is believed that the client is better suited at deciding which server is most responsive because it can keep track of the round trip response time. </paragraph>
</section>
<section>
<heading lvl="1">Client-side Hardware Fail Over </heading>
<paragraph id="P-0235" lvl="0"><number>&lsqb;0235&rsqb;</number> The server selection logic provides hardware failover in the following manner: </paragraph>
<paragraph id="P-0236" lvl="2"><number>&lsqb;0236&rsqb;</number> a) If a server does not respond, i.e., times out, the client <highlight><bold>1704</bold></highlight> will pick another server from its list <highlight><bold>1705</bold></highlight>, <highlight><bold>1706</bold></highlight> and re-send the request. Since all the servers in the client&apos;s server list <highlight><bold>1705</bold></highlight>, <highlight><bold>1706</bold></highlight> are capable of processing the client&apos;s request, there are no questions of incompatibility. </paragraph>
<paragraph id="P-0237" lvl="2"><number>&lsqb;0237&rsqb;</number> b) If a SAS client <highlight><bold>1704</bold></highlight> gets a second time out, i.e., two servers are down, it re-sends the request to multiple servers from its list <highlight><bold>1705</bold></highlight>, <highlight><bold>1706</bold></highlight> in parallel. This approach staggers the timeouts and reduces the overall delay in processing a request. </paragraph>
<paragraph id="P-0238" lvl="2"><number>&lsqb;0238&rsqb;</number> c) In case of a massive hardware failure, all servers in the client&apos;s list <highlight><bold>1705</bold></highlight>, <highlight><bold>1706</bold></highlight> may be down. At this point, the client will use the interfaces to refresh its server list. This is where the three tiers of servers become important: </paragraph>
<paragraph id="P-0239" lvl="3"><number>&lsqb;0239&rsqb;</number> 1) If the client <highlight><bold>1704</bold></highlight> want to refresh its App server list <highlight><bold>1705</bold></highlight>, it will contact an SLM server <highlight><bold>1707</bold></highlight>, <highlight><bold>1709</bold></highlight> in its list of SLM servers <highlight><bold>1706</bold></highlight>. Again, the same random (SLM) server selection order is utilized here. Most of the time, this request will be successful and the client will get an updated list of app servers. </paragraph>
<paragraph id="P-0240" lvl="3"><number>&lsqb;0240&rsqb;</number> 2) If for some reason all of the SLM servers <highlight><bold>1707</bold></highlight>, <highlight><bold>1709</bold></highlight> in the client&apos;s list <highlight><bold>1706</bold></highlight> are down, it will contact the ASP Web server <highlight><bold>1703</bold></highlight> to refresh its SLM server list <highlight><bold>1706</bold></highlight>. </paragraph>
<paragraph id="P-0241" lvl="0"><number>&lsqb;0241&rsqb;</number> This <highlight><bold>3</bold></highlight>-tiered approach significantly reduces the impact of a single point of failure&mdash;the ASP Web server <highlight><bold>1703</bold></highlight>, effectively making it a fail over of a fail over. </paragraph>
</section>
<section>
<heading lvl="1">Server Load Balancing </heading>
<paragraph id="P-0242" lvl="0"><number>&lsqb;0242&rsqb;</number> In a preferred embodiment of the invention, a server side monitor <highlight><bold>1702</bold></highlight> keeps track of the overall health and response times for each server request. The Monitor performs this task for all Application and SLM servers. It posts prioritized lists of SLM servers and app servers <highlight><bold>1701</bold></highlight> that can serve each of the apps in a database shared by the monitor <highlight><bold>1702</bold></highlight> and all servers. The monitor&apos;s algorithm for prioritizing server lists is dominated by the server&apos;s response time for each client request. If any servers fail, the monitor <highlight><bold>1702</bold></highlight> informs the ASP <highlight><bold>1703</bold></highlight> and removes it from the server list <highlight><bold>1701</bold></highlight>. Note that the server lists <highlight><bold>1705</bold></highlight>, <highlight><bold>1706</bold></highlight> that the client <highlight><bold>1704</bold></highlight> maintains are subsets of lists the monitor <highlight><bold>1702</bold></highlight> maintains in a shared database <highlight><bold>1701</bold></highlight>. </paragraph>
<paragraph id="P-0243" lvl="0"><number>&lsqb;0243&rsqb;</number> Since all servers can access the shared database <highlight><bold>1701</bold></highlight>, they know how to &lsquo;cut&rsquo; a list of servers to a client. For example, the client starts to run an SAS application or it wants to refresh its app server list: It will contact an SLM server and the SLM server will access the database <highlight><bold>1701</bold></highlight> and cut a list of servers that are most responsive (from the server&apos;s prospective). </paragraph>
<paragraph id="P-0244" lvl="0"><number>&lsqb;0244&rsqb;</number> In this scheme, the server monitor <highlight><bold>1702</bold></highlight> is keeping track of what it can track the best: how effectively servers are processing client requests (server&apos;s response time). It does not track the network propagation delays etc. that can significantly contribute to a client&apos;s observed response time. </paragraph>
</section>
<section>
<heading lvl="1">ASP Managing Hardware Failovers </heading>
<paragraph id="P-0245" lvl="0"><number>&lsqb;0245&rsqb;</number> The foregoing approaches provide an opportunity for ASPs to better manage massive scale failures. Specifically, when an ASP <highlight><bold>1703</bold></highlight> realizes that massive numbers of servers are down, it can allocate additional resource on a temporary basis. The ASP <highlight><bold>1703</bold></highlight> can update the central database <highlight><bold>1701</bold></highlight> such that clients will receive only the list that the ASP <highlight><bold>1703</bold></highlight> knows to be up and running. This includes any temporary resources added to aid the situation. A particular advantage of this approach is that ASP <highlight><bold>1703</bold></highlight> doesn&apos;t need special actions, e.g., emails or phone support, to route clients over to these temporary resources; the transition happens automatically. </paragraph>
</section>
<section>
<heading lvl="1">Handling Client Crashes and Client Evictions </heading>
<paragraph id="P-0246" lvl="0"><number>&lsqb;0246&rsqb;</number> To prevent the same user from running the same application from multiple machines, the SLM servers <highlight><bold>1707</bold></highlight>, <highlight><bold>1708</bold></highlight>, <highlight><bold>1709</bold></highlight> track what access tokens have been handed to what users. The SAS file system tracks the beginning and end of applications. The user&apos;s SAS client software asks for an access token from the SLM servers <highlight><bold>1707</bold></highlight>, <highlight><bold>1708</bold></highlight>, <highlight><bold>1709</bold></highlight> at the beginning of an application if it already does not have one and it releases the access token when the application ends. The SLM server makes sure that at a given point only one access token has been given to a particular user. In this manner, the user can run the application from multiple machines, but only from one at a particular time. However, if the user&apos;s machine crashes before the access token has been relinquished or if for some reason the ASP <highlight><bold>1703</bold></highlight> wants to evict a user, the access token granted to the user must be made invalid. To perform this, the SLM server gets the list of application servers <highlight><bold>1705</bold></highlight> that have been sent to the client <highlight><bold>1704</bold></highlight> for serving the application and sends a message to those application servers <highlight><bold>1710</bold></highlight>, <highlight><bold>1711</bold></highlight>, <highlight><bold>1713</bold></highlight>, <highlight><bold>1714</bold></highlight> to stop serving that particular access token. This list is always maintained in the database so that every SLM server can find out what list is held by the user&apos;s machine. The application servers before servicing any access token must check with this list to ensure that the access token has not become invalid. Once the access token expires, it can be removed from this list. </paragraph>
</section>
<section>
<heading lvl="1">Server-side Performance Optimization </heading>
<paragraph id="P-0247" lvl="0"><number>&lsqb;0247&rsqb;</number> This section describes approaches that can be taken to reduce client-side latency (the time between when an application page is needed and when it is obtained) and improve Application Server scalability (a measure of the number of servers required to support a given population of clients). The former directly affects the perceived performance of an application by an end user (for application features that are not present in the user&apos;s cache), while the latter directly affects the cost of providing application streaming services to a large number of users. </paragraph>
</section>
<section>
<heading lvl="1">Application Server Operation </heading>
<paragraph id="P-0248" lvl="0"><number>&lsqb;0248&rsqb;</number> The basic purpose of the Application Server is to return Application File Pages over the network as requested by a client. The Application Server holds a group of Stream Application Sets from which it obtains the Application File Pages that match a client request. The Application Server is analogous to a typical network file system (which also returns file data), except it is optimized for delivery of Application file data, Le., code or data that belong directly to the application, produced by the software provider, as opposed to general user file data (document files and other content produced by the users themselves). The primary differences between the Application Server and a typical network file system are: </paragraph>
<paragraph id="P-0249" lvl="2"><number>&lsqb;0249&rsqb;</number> 1. The restriction to handle only Application file data allows the Application Server to only service read requests, with writes being disallowed or handled on the client itself in a copy-on-write manner; </paragraph>
<paragraph id="P-0250" lvl="2"><number>&lsqb;0250&rsqb;</number> 2. Access checks occur at the application level, that is a client is given all-or-none access to files for a given software application; </paragraph>
<paragraph id="P-0251" lvl="2"><number>&lsqb;0251&rsqb;</number> 3. The Application Server is designed to operate across the Internet, as opposed to typical network file systems, which are optimized to run over LANs. This brings up additional requirements of handling server failures, maximizing network bandwidth and minimizing latency, and handling security; and </paragraph>
<paragraph id="P-0252" lvl="2"><number>&lsqb;0252&rsqb;</number> 4. The Application Server is application-aware, unlike typical network file systems, which treat all software application files the same as all other files. This allows the Application Server to use and collect per-application access profile information along with other statistics. </paragraph>
<paragraph id="P-0253" lvl="0"><number>&lsqb;0253&rsqb;</number> To service a client request, the Application Server software component keeps master copies of the full Application Stream Sets on locally accessible persistent storage. In main memory, the Application Server maintains a cache of commonly accessed Application File Pages. The primary steps taken by the Application Server to service a client request are: </paragraph>
<paragraph id="P-0254" lvl="2"><number>&lsqb;0254&rsqb;</number> 1. Receive and decode the client request; </paragraph>
<paragraph id="P-0255" lvl="2"><number>&lsqb;0255&rsqb;</number> 2. Validate the client&apos;s privilege to access the requested data, e.g., by means of a Kerberos-style ticket issued by a trusted security service; </paragraph>
<paragraph id="P-0256" lvl="2"><number>&lsqb;0256&rsqb;</number> 3. Look up the requested data in the main memory cache, and failing that, obtain it from the master copy on disk while placing it in the cache; and </paragraph>
<paragraph id="P-0257" lvl="2"><number>&lsqb;0257&rsqb;</number> 4. Return the File Pages to the client over the network. </paragraph>
<paragraph id="P-0258" lvl="0"><number>&lsqb;0258&rsqb;</number> The techniques used to reduce latency and improve server scalability (the main performance considerations) are described below. </paragraph>
</section>
<section>
<heading lvl="1">Server Optimization Features </heading>
<paragraph id="P-0259" lvl="0"><number>&lsqb;0259&rsqb;</number> Read-Only File System for Application Files&mdash;Because virtually all application files (code and data) are never written to by users, virtually the entire population of users have identical copies of the application files. Thus a system intending to deliver the application files can distribute a single, fixed image across all servers. The read-only file system presented by the Application Server represents this sharing, and eliminates the complexities of replication management, e.g., coherency, that occur with traditional network file systems. This simplification enables the Application Servers to respond to requests more quickly, enables potential caching at intervening nodes or sharing of caches across clients in a peer-to-peer fashion, and facilitates fail over, since with the read-only file system the Application File Pages as identified by the client (by a set of unique numbers) will always globally refer to the same content in all cases. </paragraph>
<paragraph id="P-0260" lvl="0"><number>&lsqb;0260&rsqb;</number> Per-page Compression&mdash;Overall latency observed by the client can be reduced under low-bandwidth conditions by compressing each Application File Page before sending it. Referring to <cross-reference target="DRAWINGS">FIG. 18</cross-reference>, the benefits of the use of compression in the streaming of Application File Pages, is illustrated. The client <highlight><bold>1801</bold></highlight> and server <highlight><bold>1802</bold></highlight> timelines are shown for a typical transfer of data versus the same data sent in a compressed form. The client <highlight><bold>1801</bold></highlight> requests the data from the server <highlight><bold>1803</bold></highlight>. The server <highlight><bold>1803</bold></highlight> processes the request <highlight><bold>1804</bold></highlight> and begins sending the requested data. The timelines then diverge due to the ability to stream the compressed data <highlight><bold>1805</bold></highlight> faster than the uncompressed data <highlight><bold>1806</bold></highlight>. </paragraph>
<paragraph id="P-0261" lvl="0"><number>&lsqb;0261&rsqb;</number> With respect to <cross-reference target="DRAWINGS">FIG. 19</cross-reference>, the invention&apos;s pre-compression of Application File Pages process is shown. The Builder generates the stream application sets <highlight><bold>1901</bold></highlight>, <highlight><bold>1902</bold></highlight> which are then pre-compressed by the Stream Application Set Post-Processor <highlight><bold>1903</bold></highlight>. The Stream Application Set Post-Processor <highlight><bold>1903</bold></highlight> stores the compressed application sets in the persistent storage device <highlight><bold>1904</bold></highlight>. Any client requests for data are serviced by the Application Server which sends the pre-compressed data to the requesting client <highlight><bold>1905</bold></highlight>. The reduction in size of the data transmitted over the network reduces the time to arrival (though at the cost of some processing time on the client to decompress the data). When the bandwidth is low relative to processing power, e.g., <highlight><bold>256</bold></highlight> kbps with a Pentium-<highlight><bold>111</bold></highlight>-<highlight><bold>600</bold></highlight>, this can reduce latency significantly. </paragraph>
<paragraph id="P-0262" lvl="0"><number>&lsqb;0262&rsqb;</number> Page-set Compression&mdash;When pages are relatively small, matching the typical virtual memory page size of <highlight><bold>4</bold></highlight> kB, adaptive compression algorithms cannot deliver the same compression ratios that they can for larger blocks of data, e.g., <highlight><bold>32</bold></highlight> kB or larger. Referring to <cross-reference target="DRAWINGS">FIG. 20</cross-reference>, when a client <highlight><bold>2001</bold></highlight> requests multiple Application File Pages at one time <highlight><bold>2002</bold></highlight>, the Application Server <highlight><bold>2006</bold></highlight> can concatenate all the requested pages and compress the entire set at once <highlight><bold>2004</bold></highlight>, thereby further reducing the latency the client will experience due to the improved compression ratio. If the pages have already been compressed <highlight><bold>2003</bold></highlight>, then the request is fulfilled from the cache <highlight><bold>2007</bold></highlight> where the compressed pages are stored. The server <highlight><bold>2006</bold></highlight> responds to the client&apos;s request through the transfer of the compressed pages <highlight><bold>2005</bold></highlight>. </paragraph>
<paragraph id="P-0263" lvl="0"><number>&lsqb;0263&rsqb;</number> Post-processing of Stream Application Sets&mdash;The Application Server may want to perform some post processing of the raw Stream Application Sets in order to reduce its runtime-processing load, thereby improving its performance. One example is to pre-compress all Application File Pages contained in the Stream Application Sets, saving a great deal of otherwise repetitive processing time. Another possibility is to rearrange the format to suit the hardware and operating system features, or to reorder the pages to take advantage of access locality. </paragraph>
<paragraph id="P-0264" lvl="0"><number>&lsqb;0264&rsqb;</number> Static and Dynamic Profiling&mdash;With respect to <cross-reference target="DRAWINGS">FIG. 21</cross-reference>, since the same application code is executed in conjunction with a particular Stream Application Set <highlight><bold>2103</bold></highlight> each time, there will be a high degree of temporal locality of referenced Application File Pages, e.g., when a certain feature is invoked, most if not all the same code and data is referenced each time to perform the operation. These access patterns can be collected into profiles <highlight><bold>2108</bold></highlight>, which can be shipped to the client <highlight><bold>2106</bold></highlight> to guide its prefetching (or to guide server-based <highlight><bold>2105</bold></highlight> prefetching), and they can be used to pre-package groups of Application File Pages <highlight><bold>2103</bold></highlight>, <highlight><bold>2104</bold></highlight> together and compress them offline as part of a post-processing step <highlight><bold>2101</bold></highlight>, <highlight><bold>2102</bold></highlight>, <highlight><bold>2103</bold></highlight>. The benefit of the latter is that a high compression ratio can be obtained to reduce client latency without the cost of runtime server processing load (though only limited groups of Application File Pages will be available, so requests which don&apos;t match the profile would get a superset of their request in terms of the pre-compressed groups of Application File Pages that are available). </paragraph>
<paragraph id="P-0265" lvl="0"><number>&lsqb;0265&rsqb;</number> Fast Server-Side Client Privilege Checks&mdash;Referring to <cross-reference target="DRAWINGS">FIG. 22</cross-reference>, having to track individual user&apos;s credentials, i.e., which Applications they have privileges to access, can limit server scalability since ultimately the per-user data must be backed by a database, which can add latency to servicing of user requests and can become a central bottleneck. Instead, a separate License Server <highlight><bold>2205</bold></highlight> is used to offload per-user operations to grant privileges to access application data, and thereby allow the two types of servers <highlight><bold>2205</bold></highlight>, <highlight><bold>2210</bold></highlight> to scale independently. The License Server <highlight><bold>2205</bold></highlight> provides the client an Access Token (similar to a Kerberos ticket) that contains information about what application it represents rights for along with an expiration time. This simplifies the operations required by the Application Server <highlight><bold>2210</bold></highlight> to validate a client&apos;s privileges <highlight><bold>2212</bold></highlight>. The Application Server <highlight><bold>2210</bold></highlight> needs only to decrypt the Access Token (or a digest of it) via a secret key shared <highlight><bold>2209</bold></highlight> with the License Server <highlight><bold>2205</bold></highlight> (thus verifying the Token is valid), then checking the validity of its contents, e.g., application identifier, and testing the expiration time. Clients <highlight><bold>2212</bold></highlight> presenting Tokens for which all checks pass are granted access. The Application Server <highlight><bold>2210</bold></highlight> needs not track anything about individual users or their identities, thus not requiring any database operations. To reduce the cost of privilege checks further, the Application Server <highlight><bold>2210</bold></highlight> can keep a list of recently used Access Tokens for which the checks passed, and if a client passes in a matching Access Token, the server need only check the expiration time, with no further decryption processing required. </paragraph>
<paragraph id="P-0266" lvl="0"><number>&lsqb;0266&rsqb;</number> Connection Management&mdash;Before data is ever transferred from a client to a server, the network connection itself takes up one and a half network round trips. This latency can adversely impact client performance if it occurs for every client request. To avoid this, clients can use a protocol such as HTTP 1.1, which uses persistent connections, i.e., connections stay open for multiple requests, reducing the effective connection overhead. Since the client-side file system has no knowledge of the request patterns, it will simply keep the connection open as long as possible. However, because traffic from clients may be bursty, the Application Server may have more open connections than the operating system can support, many of them being temporarily idle. To manage this, the Application Server can aggressively close connections that have been idle for a period of time, thereby achieving a compromise between the client&apos;s latency needs and the Application Server&apos;s resource constraints. Traditional network file systems do not manage connections in this manner, as LAN latencies are not high enough to be of concern. </paragraph>
<paragraph id="P-0267" lvl="0"><number>&lsqb;0267&rsqb;</number> Application Server Memory Usage/Load Balancing&mdash;File servers are heavily dependent on main memory for fast access to file data (orders of magnitude faster than disk accesses). Traditional file servers manage their main memory as a cache of file blocks, keeping the most commonly accessed ones. With the Application Server, the problem of managing main memory efficiently becomes more complicated due to there being multiple servers providing a shared set of applications. In this case, if each server managed its memory independently, and was symmetric with the others, then each server would only keep those file blocks most common to all clients, across all applications. This would cause the most common file blocks to be in the main memory of each and every Application server, and since each server would have roughly the same contents in memory, adding more servers won&apos;t improve scalability by much, since not much more data will be present in memory for fast access. For example, if there are application A (accessed 50% of the time), application B (accessed 40% of the time), and application C (accessed 10% of the time), and application A and B together consume more memory cache than a single Application Server has, and there are ten Application Servers, then none of the Application Servers will have many blocks from C in memory, penalizing that application, and doubling the number of servers will improve C&apos;s performance only minimally. This can be improved upon by making the Application Servers asymmetric, in that a central mechanism, e.g., system administrator, assigns individual Application Servers different Application Stream Sets to provide, in accordance with popularity of the various applications. Thus, in the above example, of the ten servers, five can be dedicated to provide A, four to B, and one to C, (any extra memory available for any application) making a much more effective use of the entire memory of the system to satisfy the actual needs of clients. This can be taken a step further by dynamically (and automatically) changing the assignments of the servers to match client accesses over time, as groups of users come and go during different time periods and as applications are added and removed from the system. This can be accomplished by having servers summarize their access patterns, send them to a central control server, which then can reassign servers as appropriate. </paragraph>
</section>
<section>
<heading lvl="1">Conversion of Conventional Applications to Enable Streamed Delivery and Execution </heading>
<paragraph id="P-0268" lvl="0"><number>&lsqb;0268&rsqb;</number> The Streamed Application Set Builder is a software program. It is used to convert locally installable applications into a data set suitable for streaming over a network. The streaming-enabled data set is called the Streamed Application Set (SAS). This section describes the procedure used to convert locally installable applications into the SAS. </paragraph>
<paragraph id="P-0269" lvl="0"><number>&lsqb;0269&rsqb;</number> The application conversion procedure into the SAS consists of several phases. In the first phase, the Builder program monitors the installation process of a local installation of the desired application for conversion. The Builder monitors any changes to the system and records those changes in an intermediate data structure. After the application is installed locally, the Builder enters the second phase of the conversion. In the second phase, the Builder program invokes the installed application executable and obtains sequences of frequently accessed file blocks of this application. Both the Builder program and the client software use the sequence data to optimize the performance of the streaming process. Once the sequencing information is obtained, the Builder enters the final phase of the conversion. In this phase, the Builder gathers all data obtained from the first two phases and processes the data into the Streamed Application Set. </paragraph>
<paragraph id="P-0270" lvl="0"><number>&lsqb;0270&rsqb;</number> Detailed descriptions of the three phases of the Builder conversion process are described in the following sections. The three phases consist of installation monitoring (IM), application profiling (AP), and SAS packaging (SP). In most cases, the conversion process is general and applicable to all types of systems. In places where the conversion is OS dependent, the discussion is focused on the Microsoft Windows environment. Issues on conversion procedure for other OS environments are described in later sections. </paragraph>
</section>
<section>
<heading lvl="1">Installation Monitoring (IM) </heading>
<paragraph id="P-0271" lvl="0"><number>&lsqb;0271&rsqb;</number> In the first phase of the conversion process, the Builder Installation Monitor (IM) component invokes the application installation program that installs the application locally. The IM observes all changes to the local computer during the installation. The changes may involve one or more of the following: changes to system or environment variables; and modifications, addition, or deletion of one or more files. Initial system variables, environment variables, and files are accounted for by the IM before the installation begins to give a more accurate picture of any changes that are observed. The IM records all changes to the variables and files in a data structure to be sent to the Builder&apos;s Streamed Application Packaging component. In the following paragraphs, detailed description of the Installation Monitor is described for Microsoft Windows environment. </paragraph>
<paragraph id="P-0272" lvl="0"><number>&lsqb;0272&rsqb;</number> In Microsoft Windows system, the Installation Monitor (IM) component consists of a kernel-mode driver subcomponent and a user-mode subcomponent. The kernel-mode driver is hooked into the system registry and file system function interface calls. The hook into the registry function calls allows the IM to monitor system variable changes. The hook into the file system function calls enables the IM to observe file changes. </paragraph>
<paragraph id="P-0273" lvl="0"><number>&lsqb;0273&rsqb;</number> Installation Monitor Kernel-Mode subcomponent (IM-KM) </paragraph>
<paragraph id="P-0274" lvl="0"><number>&lsqb;0274&rsqb;</number> With respect to <cross-reference target="DRAWINGS">FIG. 23</cross-reference>, the IM-KM subcomponent monitors two classes of information during an application installation: system registry modifications and file modifications. Different techniques are used for each of these classes. </paragraph>
<paragraph id="P-0275" lvl="0"><number>&lsqb;0275&rsqb;</number> To monitor system registry modifications <highlight><bold>2314</bold></highlight>, the IM-KM component replaces all kernel-mode API calls in the System Service Table that write to the system registry with new functions defined in the IM-KM subcomponent. When an installation program calls one of the API functions to write to the registry <highlight><bold>2315</bold></highlight>, the IM-KM function is called instead, which logs the modification data <highlight><bold>2317</bold></highlight> (including registry key path, value name and value data) and then forwards the call to the actual operating system defined function <highlight><bold>2318</bold></highlight>. The modification data is made available to the IM-UM subcomponent through a mechanism described below. </paragraph>
<paragraph id="P-0276" lvl="0"><number>&lsqb;0276&rsqb;</number> To monitor file modifications, a filter driver is attached to the file system&apos;s driver stack. Each time an installation program modifies a file on the system, a function is called in the IM-KM subcomponent, which logs the modification data (including file path and name) and makes it available to the IM-UM using a mechanism described below. </paragraph>
<paragraph id="P-0277" lvl="0"><number>&lsqb;0277&rsqb;</number> The mechanisms used for monitoring registry modifications and file modifications will capture modifications made by any of the processes currently active on the computer system. While the installation program is running, other processes that, for example, operate the desktop and service network connections may be running and may also modify files or registry data during the installation. This data must be removed from the modification data to avoid inclusion of modifications that are not part of the application installation. The IM-KM uses process monitoring to perform this filtering. </paragraph>
<paragraph id="P-0278" lvl="0"><number>&lsqb;0278&rsqb;</number> To do process monitoring, the IM-KM installs a process notification callback function that is called each time a process is created or destroyed by the operating system. Using this callback function, the operating system sends the created process ID as well as the process ID of the creator (or parent) process. The IM-KM uses this information, along with the process ID of the IM-UM, to create a list of all of the processes created during the application installation. The IM-KM uses the following algorithm to create this list: </paragraph>
<paragraph id="P-0279" lvl="2"><number>&lsqb;0279&rsqb;</number> 1. Before the installation program is launched by the IM-UM, the IM-UM passes its own process ID to the IM-KM. Since the IM-UM is launching the installation application, the IM-UM will be the ancestor (parent, grandparent, etc.) of any process (with one exception&mdash;the Installer Service described below) that modifies files or registry data as part of the application installation. </paragraph>
<paragraph id="P-0280" lvl="2"><number>&lsqb;0280&rsqb;</number> 2. When the installation is launched and begins the creating processes, the IM-KM process monitoring logic is notified by the operating system via the process notification callback function. </paragraph>
<paragraph id="P-0281" lvl="2"><number>&lsqb;0281&rsqb;</number> 3. If the creator (parent) process ID sent to the process notification callback function is already in the process list, the new process is included in the list. </paragraph>
<paragraph id="P-0282" lvl="0"><number>&lsqb;0282&rsqb;</number> When an application on the system modifies either the registry or files, and the IM-KM monitoring logic captures the modification data, but before making it available to the IM-UM, it first checks to see if the process that modified the registry or file is part of the process list. It is only made available to the IM-UM if it is in the process list. </paragraph>
<paragraph id="P-0283" lvl="0"><number>&lsqb;0283&rsqb;</number> It is possible that a process that is not a process ancestor of the IM-UM will make changes to the system as a proxy for the installation application. Using interprocess communication, an installation program may request than an Installer Service make changes to the machine. In order for the IM-KM to capture changes made by the Installer Service, the process monitoring logic includes a simple rule that also includes any registry or file changes that have been made by a process with the same name as the Installer Service process. On Windows 2000, for example, the Installer Service is called &ldquo;msi.exe&rdquo;. </paragraph>
<paragraph id="P-0284" lvl="0"><number>&lsqb;0284&rsqb;</number> Installation Monitor User-Mode subcomponent (IM-UM) </paragraph>
<paragraph id="P-0285" lvl="0"><number>&lsqb;0285&rsqb;</number> The IM kernel-mode (IM-KM) driver subcomponent is controlled by the user-mode subcomponent (IM-UM). The IM-UM sends messages to the IM-KM to start <highlight><bold>2305</bold></highlight> and stop <highlight><bold>2309</bold></highlight> the monitoring process via standard I/O control messages known as IOCTLs. The message that starts the IM-KM also passes in the process ID of the IM-UM to facilitate process monitoring described in the IM-KM description. </paragraph>
<paragraph id="P-0286" lvl="0"><number>&lsqb;0286&rsqb;</number> When the installation program <highlight><bold>2306</bold></highlight> modifies the computer system, the IM-KM signals a named kernel event. The IM-UM listens for these events during the installation. When one of these events is signaled, the IM-UM calls the IM-KM using an IOCTL message. In response, the IM-KM packages data describing the modification and sends it to the IM-UM <highlight><bold>2318</bold></highlight>. </paragraph>
<paragraph id="P-0287" lvl="0"><number>&lsqb;0287&rsqb;</number> The IM-UM sorts this data and removes duplicates. Also, it parameterizes all local-system-specific registry keys, value names, and values. For example, an application will often store paths in the registry that allow it to find certain files at run-time. These path specifications must be replaced with parameters that can be recognized by the client installation software. </paragraph>
<paragraph id="P-0288" lvl="0"><number>&lsqb;0288&rsqb;</number> A user interface is provided for the IM-UM that allows an operator of the Builder to browse through the changes made to the machine and to edit the modification data before the data is packaged into an SAS. </paragraph>
<paragraph id="P-0289" lvl="0"><number>&lsqb;0289&rsqb;</number> Once the installation of an application is completed <highlight><bold>2308</bold></highlight>, the IM-UM forwards data structures representing the file and registry modifications to the Streamed Application Packager <highlight><bold>2312</bold></highlight>. </paragraph>
</section>
<section>
<heading lvl="1">Monitoring Application Configuration </heading>
<paragraph id="P-0290" lvl="0"><number>&lsqb;0290&rsqb;</number> Using the techniques described above for monitoring file modifications and monitoring registry modifications, the builder can also monitor a running application that is being configured for a particular working environment. The data acquired by the IM-UM can be used to duplicate the same configuration on multiple machines, making it unnecessary for each user to configure his/her own application installation. </paragraph>
<paragraph id="P-0291" lvl="0"><number>&lsqb;0291&rsqb;</number> An example of this is a client server application for which the client will be streamed to the client computer system. Common configuration modifications can be captured by the IM and packed into the SAS. When the application is streamed to the client machine, it is already configured to attach to the server and begin operation. </paragraph>
</section>
<section>
<heading lvl="1">Application Profiling (AP) </heading>
<paragraph id="P-0292" lvl="0"><number>&lsqb;0292&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 24</cross-reference>, in the second phase of the conversion process, the Builder&apos;s Application Profiler (AP) component invokes the application executable program that is installed during the first phase of the conversion process. Given a particular user input, the executable program file blocks are accessed in a particular sequence. The purpose of the AP is to capture the sequence data associated with some user inputs. This data is useful in several ways. </paragraph>
<paragraph id="P-0293" lvl="0"><number>&lsqb;0293&rsqb;</number> First of all, frequently used file blocks can be streamed to the client machine before other less used file blocks. A frequently used file block is cached locally on the client cache before the user starts using the streamed application for the first time. This has the effect of making the streamed application as responsive to the user as the locally installed application by hiding any long network latency and bandwidth problems. </paragraph>
<paragraph id="P-0294" lvl="0"><number>&lsqb;0294&rsqb;</number> Secondly, the frequently accessed files can be reordered in the directory to allow faster lookup of the file information. This optimization is useful for directories with large number of files. When the client machine looks up a frequently used file in a directory, it finds this file early in the directory search. In an application run with many directory queries, the performance gain is significant. </paragraph>
<paragraph id="P-0295" lvl="0"><number>&lsqb;0295&rsqb;</number> Finally, the association of a set of file blocks with a particular user input allows the client machine to request minimum amount of data needed to respond to that particular user command. The profile data association with a user command is sent from the server to the client machine in the AppinstallBlock during the &lsquo;preparation&rsquo; of the client machine for streaming. When the user on a client machine invokes a particular command, the codes corresponding to this command are prefetched from the server. </paragraph>
<paragraph id="P-0296" lvl="0"><number>&lsqb;0296&rsqb;</number> The Application Profiler (AP) is not as tied to the system as the Installation Monitor (IM) but there are still some OS dependent issues. In the Windows system, the AP still has two subcomponents: kernel-mode (AP-KM) subcomponent and the user-mode (AP-UM) subcomponent. The AP-UM invokes the converting application executable. Then AP-UM starts the AP-KM <highlight><bold>2403</bold></highlight>, <highlight><bold>2413</bold></highlight> to track the sequences of file block accesses by the application <highlight><bold>2414</bold></highlight>. Finally when the application exits after the pre-specified amount of sequence data is gathered, the AP-UM retrieves the data from AP-KM <highlight><bold>2406</bold></highlight>, <highlight><bold>2417</bold></highlight> and forwards the data to the Streamed Application Packager <highlight><bold>2411</bold></highlight>. </paragraph>
</section>
<section>
<heading lvl="1">Streamed Application Set Packaging (SP) </heading>
<paragraph id="P-0297" lvl="0"><number>&lsqb;0297&rsqb;</number> With respect to <cross-reference target="DRAWINGS">FIG. 25</cross-reference>, in the final phase of the conversion process, the Builder&apos;s Streamed Application Set Packager (SP) component processes the data structure from IM and AP to create a data set suitable for streaming over the network. This converted data set is called the Streamed Application Set <highlight><bold>2520</bold></highlight> and is suitable for uploading to the Streamed Application Servers for subsequent downloading by the stream client. <cross-reference target="DRAWINGS">FIG. 23</cross-reference> shows the control flow of the SP module. </paragraph>
<paragraph id="P-0298" lvl="0"><number>&lsqb;0298&rsqb;</number> Each file included in a Streamed Application Set <highlight><bold>2520</bold></highlight> is assigned a file number that identifies it within the SAS. </paragraph>
<paragraph id="P-0299" lvl="0"><number>&lsqb;0299&rsqb;</number> The Streamed Application Set <highlight><bold>2520</bold></highlight> consists of the three sets of data from the Streamed Application Server&apos;s perspective. The three types of data are the Concatenation Application File (CAF) <highlight><bold>2519</bold></highlight>, <highlight><bold>2515</bold></highlight>, the Size Offset File Table (SOFT)<highlight><bold>2518</bold></highlight>, <highlight><bold>2514</bold></highlight>, <highlight><bold>2507</bold></highlight>, and the Root Versioning Table (RVT) <highlight><bold>2518</bold></highlight>, <highlight><bold>2514</bold></highlight>. </paragraph>
<paragraph id="P-0300" lvl="0"><number>&lsqb;0300&rsqb;</number> The CAF <highlight><bold>2519</bold></highlight>, <highlight><bold>2515</bold></highlight> consists of all the files and directories needed to stream to the client. The CAF can be further divided into two subsets: initialization data set and the runtime data set. </paragraph>
<paragraph id="P-0301" lvl="0"><number>&lsqb;0301&rsqb;</number> The initialization data set is the first set of data to be streamed from the server to the client. This data set contains the information captured by IM and AP needed by the client to prepare the client machine for streaming this particular application. This initialization data set is also called the AppInstallBlock (AIB) <highlight><bold>2516</bold></highlight>, <highlight><bold>2512</bold></highlight>. In addition to the data captured by the IM and AP modules, the SP is also responsible for merging any new dynamic profile data gathered from the client and the server. This data is merged into the existing AppInstallBlock to optimize subsequent streaming of the application <highlight><bold>2506</bold></highlight>. With the list of files obtained by the IM during application installation, the SP module separates the list of files into regular streamed files and the spoof files. The spoof files consists of those files not installed into standard application directory. This includes files installed into system directories and user specific directories. The detailed format description of the AppinstallBlock is described later. </paragraph>
<paragraph id="P-0302" lvl="0"><number>&lsqb;0302&rsqb;</number> The second part of the CAF consists of the runtime data set. This is the rest of the data that is streamed to the client once the client machine is initialized for this particular application. The runtime data consists of all the regular application files and the directories containing information about those application files. Detailed format description of the runtime data in the CAF section is described below. The SP appends every file recorded by IM into the CAF and generates all directories. Each directory contains list of file name, file number, and the metadata associated with the files in that particular directory <highlight><bold>2517</bold></highlight>, <highlight><bold>2513</bold></highlight>. </paragraph>
<paragraph id="P-0303" lvl="0"><number>&lsqb;0303&rsqb;</number> The SP is also responsible for generating the SOFT file <highlight><bold>2518</bold></highlight>, <highlight><bold>2514</bold></highlight>, <highlight><bold>2507</bold></highlight>. This is a table used to index into the CAF for determining the start and the end of a file. The server uses this information to quickly access the proper file within the directory for serving the proper file blocks to the client. </paragraph>
<paragraph id="P-0304" lvl="0"><number>&lsqb;0304&rsqb;</number> Finally, the SP creates the RVT file <highlight><bold>2518</bold></highlight>, <highlight><bold>2514</bold></highlight>. The Root Versioning Table contains a list of root file number and version number. This information is used to track minor application patches and upgrades. Each entry in the RVT corresponds to one patch level of the application with a corresponding new root directory. The SP generates new parent directories when any single file in that subdirectory tree is changed from the patched upgrade. The RVT is uploaded to the server and requested by the client at appropriate time for the most updated version of the application by a simple comparison of the client&apos;s Streamed Application root file number with the RVT table located on the server once the client is granted access authorization to retrieve the data. </paragraph>
<paragraph id="P-0305" lvl="0"><number>&lsqb;0305&rsqb;</number> With respect to <cross-reference target="DRAWINGS">FIGS. 26</cross-reference><highlight><italic>a </italic></highlight>and <highlight><bold>26</bold></highlight><highlight><italic>b</italic></highlight>, the internal representation of a simple SAS before and after a new file is added to a new version of an application is shown. The original CAF <highlight><bold>2601</bold></highlight> has the new files <highlight><bold>2607</bold></highlight> appended to it <highlight><bold>2604</bold></highlight> by the SP. The SOFT <highlight><bold>2602</bold></highlight> is correspondingly updated <highlight><bold>2605</bold></highlight> with the appropriate table entries <highlight><bold>2608</bold></highlight> to index the new files <highlight><bold>2607</bold></highlight> the CAF <highlight><bold>2604</bold></highlight>. Finally, the RVT <highlight><bold>2603</bold></highlight> is updated <highlight><bold>2606</bold></highlight> to reflect the new version <highlight><bold>2609</bold></highlight>. </paragraph>
</section>
<section>
<heading lvl="1">Data Flow Description </heading>
<paragraph id="P-0306" lvl="0"><number>&lsqb;0306&rsqb;</number> The following list describes the data that is passed from one component to another. The numbers corresponds to the numbering in the Data Flow diagram of <cross-reference target="DRAWINGS">FIG. 27</cross-reference>. </paragraph>
</section>
<section>
<heading lvl="1">Install Monitor </heading>
<paragraph id="P-0307" lvl="2"><number>&lsqb;0307&rsqb;</number> <highlight><bold>1</bold></highlight>. The full pathname of the installer program is queried from the user by the Builder program and is sent to the Install Monitor. </paragraph>
<paragraph id="P-0308" lvl="2"><number>&lsqb;0308&rsqb;</number> <highlight><bold>2</bold></highlight>. The Install Monitor (IM) user-mode sends a read request to the OS to spawn a new process for installing the application on the local machine. </paragraph>
<paragraph id="P-0309" lvl="2"><number>&lsqb;0309&rsqb;</number> <highlight><bold>3</bold></highlight>. The OS loads the application installer program into memory and runs the application installer program. OS returns the process ID to the IM. </paragraph>
<paragraph id="P-0310" lvl="2"><number>&lsqb;0310&rsqb;</number> <highlight><bold>4</bold></highlight>. The application program is started by the IM-UM. </paragraph>
<paragraph id="P-0311" lvl="2"><number>&lsqb;0311&rsqb;</number> <highlight><bold>5</bold></highlight>. The application installer program sends read request to the OS to read the content of the CD. </paragraph>
<paragraph id="P-0312" lvl="2"><number>&lsqb;0312&rsqb;</number> <highlight><bold>6</bold></highlight>. The CD media data files are read from the CD. </paragraph>
<paragraph id="P-0313" lvl="2"><number>&lsqb;0313&rsqb;</number> <highlight><bold>7</bold></highlight>. The files are written to the appropriate location on the local hard-drive. </paragraph>
<paragraph id="P-0314" lvl="2"><number>&lsqb;0314&rsqb;</number> <highlight><bold>8</bold></highlight>. IM kernel-mode captures all file read/write requests and all registry read/write requests by the application installer program. </paragraph>
<paragraph id="P-0315" lvl="2"><number>&lsqb;0315&rsqb;</number> <highlight><bold>9</bold></highlight>. IM user-mode program starts the IM kernel-mode program and sends the request to start capturing all relevant file and registry data. </paragraph>
<paragraph id="P-0316" lvl="2"><number>&lsqb;0316&rsqb;</number> <highlight><bold>10</bold></highlight>. IM kernel-mode program sends the list of all file modifications, additions, and deletions; and all registry modifications, additions, and deletions to the IM user-mode program. </paragraph>
<paragraph id="P-0317" lvl="2"><number>&lsqb;0317&rsqb;</number> <highlight><bold>11</bold></highlight>. IM informs the SAS Builder UI that the installation monitoring has completed and displays the file and registry data in a graphical user interface. </paragraph>
</section>
<section>
<heading lvl="1">Application Profiler </heading>
<paragraph id="P-0318" lvl="2"><number>&lsqb;0318&rsqb;</number> <highlight><bold>12</bold></highlight>. Builder UI invokes Application Profiling (AP) user-mode program by querying the user for the list of application executable names to be profiled. The AP user-mode also queries the user for division of file blocks into sections corresponding to the commands invoked by the user of the application being profiled. </paragraph>
<paragraph id="P-0319" lvl="2"><number>&lsqb;0319&rsqb;</number> <highlight><bold>13</bold></highlight>. Application Profiler user-mode invokes each application executable in succession by spawning each program in a new process. The OS loads the application executable into memory, runs the application executable, and returns the process ID to the Application Profiler. </paragraph>
<paragraph id="P-0320" lvl="2"><number>&lsqb;0320&rsqb;</number> <highlight><bold>14</bold></highlight>. During execution, the OS on behalf of the application, sends the request to the hard-drive controller to read the appropriate file blocks into memory as needed by the application. </paragraph>
<paragraph id="P-0321" lvl="2"><number>&lsqb;0321&rsqb;</number> <highlight><bold>15</bold></highlight>. The hard-drive controller returns all file blocks requested by the OS. </paragraph>
<paragraph id="P-0322" lvl="2"><number>&lsqb;0322&rsqb;</number> <highlight><bold>16</bold></highlight>. Every file access to load the application file blocks into memory is monitored by the Application Profiler (AP) kernel-mode program. </paragraph>
<paragraph id="P-0323" lvl="2"><number>&lsqb;0323&rsqb;</number> <highlight><bold>17</bold></highlight>. The AP user-mode program informs the AP kernel-mode program to start monitoring relevant file accesses. </paragraph>
<paragraph id="P-0324" lvl="2"><number>&lsqb;0324&rsqb;</number> <highlight><bold>18</bold></highlight>. Application Profiler kernel-mode returns the file access sequence and frequency information to the user-mode program. </paragraph>
<paragraph id="P-0325" lvl="2"><number>&lsqb;0325&rsqb;</number> <highlight><bold>19</bold></highlight>. Application Profiler returns the processed profile information. This has two sections. The first section is used to identify the frequency of files accessed. The second section is used to list the file blocks for prefetch to the client. The file blocks can be further categorized into subsections according to the commands invoked by the user of the application. </paragraph>
</section>
<section>
<heading lvl="1">SAS Packager </heading>
<paragraph id="P-0326" lvl="2"><number>&lsqb;0326&rsqb;</number> <highlight><bold>20</bold></highlight>. The Streamed Application Packager receives files and registry changes from the Builder UI. It also receives the file access frequency and a list of file blocks from the Profiler. File numbers are assigned to each file. </paragraph>
<paragraph id="P-0327" lvl="2"><number>&lsqb;0327&rsqb;</number> <highlight><bold>21</bold></highlight>. The Streamed Application Packager reads all the file data from the hard-drive that are copied there by the application installer. </paragraph>
<paragraph id="P-0328" lvl="2"><number>&lsqb;0328&rsqb;</number> <highlight><bold>22</bold></highlight>. The Streamed Application Packager also reads the previous version of Streamed Application Set for support of minor patch upgrades. </paragraph>
<paragraph id="P-0329" lvl="2"><number>&lsqb;0329&rsqb;</number> <highlight><bold>23</bold></highlight>. Finally, the new Streamed Application Set data is stored back to non-volatile storage. </paragraph>
<paragraph id="P-0330" lvl="2"><number>&lsqb;0330&rsqb;</number> <highlight><bold>24</bold></highlight>. For new profile data gathered after the SAS has been created, the packager is invoked to update the AppinstallBlock in the SAS with the new profile information. </paragraph>
</section>
<section>
<heading lvl="1">Mapping of Data Flow to Streamed Application Set (SAS) </heading>
<paragraph id="P-0331" lvl="2"><number>&lsqb;0331&rsqb;</number> Step <highlight><bold>7</bold></highlight>: Data gathered from this step consist of the registry and file modification, addition, and deletion. The data are mapped to the AppinstallBlock&apos;s File Section, Add Registry Section, and Remove Registry Section. </paragraph>
<paragraph id="P-0332" lvl="2"><number>&lsqb;0332&rsqb;</number> Step <highlight><bold>8</bold></highlight> &amp; <highlight><bold>19</bold></highlight>: File data are copied to the local hard-drive then concatenated into part of the CAF contents. Part of the data is identified as spoof or copied files and the file names and/or contents are added to the AppinstallBlock. </paragraph>
<paragraph id="P-0333" lvl="2"><number>&lsqb;0333&rsqb;</number> Step <highlight><bold>15</bold></highlight> &amp; <highlight><bold>21</bold></highlight>: Part of the data gathered by the Profiler or gathered dynamically by the client is used in the AppInstallBlock as a prefetch hint to the client. Another part of the data is used to generate a more efficient SAS Directory content by ordering the files according the usage frequency. </paragraph>
<paragraph id="P-0334" lvl="2"><number>&lsqb;0334&rsqb;</number> Step <highlight><bold>20</bold></highlight>: If the installation program was an upgrade, SAS Packager needs previous version of the Streamed Application Set data. Appropriate data from the previous version are combined with the new data to form the new Streamed Application Set. </paragraph>
</section>
<section>
<heading lvl="1">Format of Streamed Application Set </heading>
<paragraph id="P-0335" lvl="0"><number>&lsqb;0335&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 28</cross-reference>, the format of the Streamed Application Set consists of three sections: Root Version Table (RVT) <highlight><bold>2802</bold></highlight>, Size Offset File Table (SOFT) <highlight><bold>2803</bold></highlight>, and Concatenation Application File (CAF) <highlight><bold>2801</bold></highlight>. The RVT section <highlight><bold>2802</bold></highlight> lists all versions of the root file numbers available in a Streamed Application Set. The SOFT <highlight><bold>2803</bold></highlight> section consists of the pointers into the CAF <highlight><bold>2801</bold></highlight> section for every file in the CAF <highlight><bold>2801</bold></highlight>. The CAF section <highlight><bold>2801</bold></highlight> contains the concatenation of all the files associated with the streamed application. The CAF section <highlight><bold>2801</bold></highlight> is made up of regular application files, SAS directory files <highlight><bold>2805</bold></highlight>, AppinstallBlock <highlight><bold>2804</bold></highlight>, and icon files. See below for detailed information on the content of the SAS file. </paragraph>
</section>
<section>
<heading lvl="1">OS Dependent Format </heading>
<paragraph id="P-0336" lvl="0"><number>&lsqb;0336&rsqb;</number> The format of the Streamed Application Set is designed to be as portable as possible across all OS platforms. At the highest level, the format of CAF, SOFT, and RVT that make up the format of the Streamed Application Set are completely portable across any OS platforms. One piece of data structure that is OS dependent is located in the initialization data set called AppinstallBlock in the CAF. This data is dependent on the type of OS due to the differences in low-level system differences among different OS. For example, Microsoft Windows contains system environment variables called the Registry. The Registry has a particular tree format not found in other operating systems like UNIX or MacOS. </paragraph>
<paragraph id="P-0337" lvl="0"><number>&lsqb;0337&rsqb;</number> Another OS dependent piece of data is located in the SAS directory files in the CAF. The directory contains file metadata information specific to Windows files. For example on the UNIX platform, there does not exist a hidden flag. This platform specific information needs to be transmitted to the client to fool the streamed application into believing that the application data is located natively on the client machine with all the associated file metadata intact. If SAS is to be used to support streaming of UNIX or MacOS applications, file metadata specific to those systems will need to be recorded in the SAS directory. </paragraph>
<paragraph id="P-0338" lvl="0"><number>&lsqb;0338&rsqb;</number> Lastly, the format of the file names itself is OS dependent. Applications running on the Windows environment inherit the old MSDOS 8.3 file name format. To support this properly, the format of the SAS Directory file in CAF requires an additional 8.3 field to store this information. This field is not needed in other operating systems like UNIX or MacOS. </paragraph>
</section>
<section>
<heading lvl="1">Device Driver Versus File System Paradigm </heading>
<paragraph id="P-0339" lvl="0"><number>&lsqb;0339&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIGS. 29 and 30</cross-reference>, the SAS client Prototype is implemented using the &lsquo;device driver&rsquo; paradigm. One of the advantages of the device driver approach is that the caching of the sector blocks is simpler. In the device driver approach, the client cache manager <highlight><bold>2902</bold></highlight> only needs to track sector numbers in its cache <highlight><bold>2903</bold></highlight>. In comparison with the &lsquo;file system&rsquo; paradigm, more complex data structure are required by the client cache manager <highlight><bold>3002</bold></highlight> to track a subset of a file that is cached <highlight><bold>3003</bold></highlight> on a client machine. This makes the device driver paradigm easier to implement. </paragraph>
<paragraph id="P-0340" lvl="0"><number>&lsqb;0340&rsqb;</number> On the other hand, there are many drawbacks to the device driver paradigm. On the Windows system, the device driver approach has a problem supporting large numbers of applications. This is due to the phantom limitation on the number of assignable drive letters available in a Windows system (26 letters); and the fact that each application needs to be located on its own device. Note that having multiple applications on a device is possible, but then the server needs to maintain an exponential number of devices that support all possible combinations of applications. This is too costly to maintain on the server. </paragraph>
<paragraph id="P-0341" lvl="0"><number>&lsqb;0341&rsqb;</number> Another problem with the device driver approach is that the device driver operates at the disk sector level. This is a much lower level than operating at the file level in the file system approach. The device driver does not know anything about files. Thus, the device driver cannot easily interact with the file level issues. For example, spoofing files and interacting with the OS file cache is nearly impossible with the device driver approach. Both spoofing files and interacting with the OS buffer cache are needed to get higher performance. In addition, operating at the file system level lends to optimizing the file system to better suit this approach of running applications. For instance, typical file systems do logging and make multiple disk sector requests at a time. These are not needed in this approach and are actually detrimental to the performance. When operating at the device driver level, not much can be done about that. Also, operating at the file system level helps in optimizing the protocol between the client and the server. </paragraph>
</section>
<section>
<heading lvl="1">Implementation in the Prototype </heading>
<paragraph id="P-0342" lvl="0"><number>&lsqb;0342&rsqb;</number> The prototype has been implemented and tested successfully on the Windows and Linux distributed system. The prototype is implemented using the device driver paradigm as described above. The exact procedure for streaming application data is described next. </paragraph>
<paragraph id="P-0343" lvl="0"><number>&lsqb;0343&rsqb;</number> First of all, the prototype server is started on either the Windows-based or Linux-based system. The server creates a large local file mimicking large local disk images. Once the disk images are prepared, it listens to TCP/IP ports for any disk sector read or write requests. </paragraph>
</section>
<section>
<heading lvl="1">Implementation of SAS Builder </heading>
<paragraph id="P-0344" lvl="0"><number>&lsqb;0344&rsqb;</number> The SAS Builder has been implemented on the Windows-based platform. A preliminary Streamed Application Set file has been created for real-world applications like Adobe Photoshop. A simple extractor program has been developed to extract the SAS data on a pristine machine without the application installed locally. Once the extractor program is run on the SAS, the application runs as if it was installed locally on that machine. This process verifies the correctness of the SAS Building process. </paragraph>
</section>
<section>
<heading lvl="1">Format of Streamed Application Set (SAS) </heading>
</section>
<section>
<heading lvl="1">Functionality </heading>
<paragraph id="P-0345" lvl="0"><number>&lsqb;0345&rsqb;</number> The streamed application set (SAS), illustrated in <cross-reference target="DRAWINGS">FIG. 28</cross-reference>, is a data set associated with an application suitable for streaming over the network. The SAS is generated by the SAS Builder program. The program converts locally installable applications into the SAS. This section describes the format of the SAS. </paragraph>
<paragraph id="P-0346" lvl="0"><number>&lsqb;0346&rsqb;</number> Note: Fields greater than a single byte are stored in little-endian format. The Stream Application Set (SAS) file size is limited to 2&circ; 64 bytes. The files in the CAF section are laid out in the same order as its corresponding entries in the SOFT table. </paragraph>
</section>
<section>
<heading lvl="1">Data Type Definitions </heading>
<paragraph id="P-0347" lvl="0"><number>&lsqb;0347&rsqb;</number> The format of the SAS consists of four sections: header, Root Version Table (RVT), Size Offset File Table (SOFT), and Concatenation Application File (CAF) sections. </paragraph>
<paragraph id="P-0348" lvl="1"><number>&lsqb;0348&rsqb;</number> 1. Header section </paragraph>
<paragraph id="P-0349" lvl="2"><number>&lsqb;0349&rsqb;</number> MagicNumber &lsqb;4 bytes&rsqb;: Magic number identifying the file content with the SAS. </paragraph>
<paragraph id="P-0350" lvl="2"><number>&lsqb;0350&rsqb;</number> ESSVersion &lsqb;4 bytes&rsqb;: Version number of the SAS file format. </paragraph>
<paragraph id="P-0351" lvl="2"><number>&lsqb;0351&rsqb;</number> AppID &lsqb;16 bytes&rsqb;: A unique application ID for this application. This field must match the AppID located in the AppinstallBlock. Window Guidgen API is used to create this identifier. </paragraph>
<paragraph id="P-0352" lvl="2"><number>&lsqb;0352&rsqb;</number> Flags &lsqb;4 bytes&rsqb;: Flags pertaining to SAS. </paragraph>
<paragraph id="P-0353" lvl="2"><number>&lsqb;0353&rsqb;</number> Reserved &lsqb;32 bytes&rsqb;: Reserved spaces for future. </paragraph>
<paragraph id="P-0354" lvl="2"><number>&lsqb;0354&rsqb;</number> RVToffset &lsqb;8 bytes&rsqb;: Byte offset into the start of the RVT section. </paragraph>
<paragraph id="P-0355" lvl="2"><number>&lsqb;0355&rsqb;</number> RVTsize &lsqb;8 bytes&rsqb;: Byte size of the RVT section. </paragraph>
<paragraph id="P-0356" lvl="2"><number>&lsqb;0356&rsqb;</number> SOFToffset &lsqb;8 bytes&rsqb;: Byte offset into the start of the SOFT section. </paragraph>
<paragraph id="P-0357" lvl="2"><number>&lsqb;0357&rsqb;</number> SOFTsize &lsqb;8 bytes&rsqb;: Byte size of the SOFT section. </paragraph>
<paragraph id="P-0358" lvl="2"><number>&lsqb;0358&rsqb;</number> CAFoffset &lsqb;8 bytes&rsqb;: Byte offset into the start of the CAF section. </paragraph>
<paragraph id="P-0359" lvl="2"><number>&lsqb;0359&rsqb;</number> CAFsize &lsqb;8 bytes&rsqb;: Byte size of the CAF section. </paragraph>
<paragraph id="P-0360" lvl="2"><number>&lsqb;0360&rsqb;</number> VendorNameIsAnsi &lsqb;1 byte&rsqb;: 0 if the vendor name is in Unicode format. <highlight><bold>1</bold></highlight> if the vendor name is in ANSI format. </paragraph>
<paragraph id="P-0361" lvl="2"><number>&lsqb;0361&rsqb;</number> VendorNameLength &lsqb;4 bytes&rsqb;: Byte length of the vendor name. </paragraph>
<paragraph id="P-0362" lvl="2"><number>&lsqb;0362&rsqb;</number> VendorName &lsqb;X bytes&rsqb;: Name of the software vendor who created this application. e.g., &ldquo;Microsoft&rdquo;. Null-terminated. </paragraph>
<paragraph id="P-0363" lvl="2"><number>&lsqb;0363&rsqb;</number> AppBaseNameIsAnsi &lsqb;1 byte&rsqb;: 0 if the vendor name is in Unicode format. <highlight><bold>1</bold></highlight> if the vendor name is in ANSI format. </paragraph>
<paragraph id="P-0364" lvl="2"><number>&lsqb;0364&rsqb;</number> AppBaseNameLength &lsqb;<highlight><bold>4</bold></highlight> bytes&rsqb;: Byte length of the application base name. </paragraph>
<paragraph id="P-0365" lvl="2"><number>&lsqb;0365&rsqb;</number> AppBaseName &lsqb;X bytes&rsqb;: Base name of the application. e.g., &ldquo;Word 2000&rdquo;. Null-terminated. </paragraph>
<paragraph id="P-0366" lvl="2"><number>&lsqb;0366&rsqb;</number> MessageIsAnsi &lsqb;1 byte&rsqb;: 0 if the vendor name is in Unicode format. 1 if the vendor name is in ANSI format. </paragraph>
<paragraph id="P-0367" lvl="2"><number>&lsqb;0367&rsqb;</number> MessageLength &lsqb;4 bytes&rsqb;: Byte length of the message text. </paragraph>
<paragraph id="P-0368" lvl="2"><number>&lsqb;0368&rsqb;</number> Message &lsqb;X bytes&rsqb;: Message text. Null-terminated. </paragraph>
<paragraph id="P-0369" lvl="1"><number>&lsqb;0369&rsqb;</number> 2. Root Version Table (RVT) section </paragraph>
<paragraph id="P-0370" lvl="2"><number>&lsqb;0370&rsqb;</number> The Root version entries are ordered in a decreasing value according to their file numbers. The Builder generates unique file numbers within each SAS in a monotonically increasing value. So larger root file numbers imply later versions of the same application. The latest root version is located at the top of the section to allow the SAS Server easy access to the data associated with the latest root version. </paragraph>
<paragraph id="P-0371" lvl="3"><number>&lsqb;0371&rsqb;</number> NumberEntries &lsqb;4 bytes&rsqb;: Number of patch versions contained in this SAS. The number indicates the number of entries in the Root Version Table (RVT). </paragraph>
<paragraph id="P-0372" lvl="2"><number>&lsqb;0372&rsqb;</number> Root Version structure: (variable number of entries) </paragraph>
<paragraph id="P-0373" lvl="3"><number>&lsqb;0373&rsqb;</number> VersionNumber &lsqb;4 bytes&rsqb;: Version number of the root directory. </paragraph>
<paragraph id="P-0374" lvl="3"><number>&lsqb;0374&rsqb;</number> FileNumber &lsqb;4 bytes&rsqb;: File number of the root directory. </paragraph>
<paragraph id="P-0375" lvl="3"><number>&lsqb;0375&rsqb;</number> VersionNameIsAnsi &lsqb;1 byte&rsqb;: 0 if the vendor name is in Unicode format. 1 if the vendor name is in ANSI format. </paragraph>
<paragraph id="P-0376" lvl="3"><number>&lsqb;0376&rsqb;</number> VersionNameLength &lsqb;4 bytes&rsqb;: Byte length of the version name </paragraph>
<paragraph id="P-0377" lvl="3"><number>&lsqb;0377&rsqb;</number> VersionName &lsqb;X bytes&rsqb;: Application version name. e.g., &ldquo;SP 1&rdquo;. </paragraph>
<paragraph id="P-0378" lvl="3"><number>&lsqb;0378&rsqb;</number> Metadata &lsqb;32 bytes&rsqb;: See SAS FS Directory for format of the metadata. </paragraph>
<paragraph id="P-0379" lvl="1"><number>&lsqb;0379&rsqb;</number> 3. Size Offset File Table (SOFT) section </paragraph>
<paragraph id="P-0380" lvl="2"><number>&lsqb;0380&rsqb;</number> The SOFT table contains information to locate specific files in the CAF section. The entries are ordered according to the file number starting from 0 to NumberFiles&minus;1. The start of the SOFT table is aligned to eight-byte boundaries for faster access. </paragraph>
<paragraph id="P-0381" lvl="2"><number>&lsqb;0381&rsqb;</number> SOFT entry structure: (variable number of entries) </paragraph>
<paragraph id="P-0382" lvl="3"><number>&lsqb;0382&rsqb;</number> Offset &lsqb;8 bytes&rsqb;: Byte offset into CAF of the start of this file. </paragraph>
<paragraph id="P-0383" lvl="3"><number>&lsqb;0383&rsqb;</number> Size &lsqb;8 bytes&rsqb;: Byte size of this file. The file is located from address Offset to Offset&plus;Size. </paragraph>
<paragraph id="P-0384" lvl="1"><number>&lsqb;0384&rsqb;</number> 4. Concatenation Application File (CAF) section </paragraph>
<paragraph id="P-0385" lvl="2"><number>&lsqb;0385&rsqb;</number> CAF is a concatenation of all file or directory data into a single data structure. Each piece of data can be a regular file, an AppinstallBlock, an SAS FS directory file, or an icon file. </paragraph>
<paragraph id="P-0386" lvl="2"><number>&lsqb;0386&rsqb;</number> a. Regular Files </paragraph>
<paragraph id="P-0387" lvl="3"><number>&lsqb;0387&rsqb;</number> FileData &lsqb;X bytes&rsqb;: Content of a regular file </paragraph>
<paragraph id="P-0388" lvl="2"><number>&lsqb;0388&rsqb;</number> b. AppInstallBlock (See AppinstallBlock section for detailed format) </paragraph>
<paragraph id="P-0389" lvl="3"><number>&lsqb;0389&rsqb;</number> A simplified description of the AppinstallBlock is listed here. The exact detail of the individual fields in the AppInstallBlock are described later. </paragraph>
<paragraph id="P-0390" lvl="4"><number>&lsqb;0390&rsqb;</number> Header section &lsqb;X bytes&rsqb;: Header for AppInstallBlock containing information to identify this AppinstallBlock. </paragraph>
<paragraph id="P-0391" lvl="4"><number>&lsqb;0391&rsqb;</number> Files section &lsqb;X bytes&rsqb;: Section containing file to be copied or spoofed. </paragraph>
<paragraph id="P-0392" lvl="4"><number>&lsqb;0392&rsqb;</number> AddVariable section &lsqb;X bytes&rsqb;: Section containing system variables to be added. </paragraph>
<paragraph id="P-0393" lvl="4"><number>&lsqb;0393&rsqb;</number> RemoveVariable section &lsqb;X bytes&rsqb;: Section containing system variables to be removed. </paragraph>
<paragraph id="P-0394" lvl="4"><number>&lsqb;0394&rsqb;</number> Prefetch section &lsqb;X bytes&rsqb;: Section containing pointers to file blocks to be prefetched to the client. </paragraph>
<paragraph id="P-0395" lvl="4"><number>&lsqb;0395&rsqb;</number> Profile section &lsqb;X bytes&rsqb;: Section containing profile data. </paragraph>
<paragraph id="P-0396" lvl="4"><number>&lsqb;0396&rsqb;</number> Comment section &lsqb;X bytes&rsqb;: Section containing comments about AppinstallBlock. </paragraph>
<paragraph id="P-0397" lvl="4"><number>&lsqb;0397&rsqb;</number> Code section &lsqb;X bytes&rsqb;: Section containing application-specific code needed to prepare local machine for streaming this application </paragraph>
<paragraph id="P-0398" lvl="4"><number>&lsqb;0398&rsqb;</number> LicenseAgreement section &lsqb;X bytes&rsqb;: Section containing licensing agreement message. </paragraph>
<paragraph id="P-0399" lvl="2"><number>&lsqb;0399&rsqb;</number> c. SAS Directory </paragraph>
<paragraph id="P-0400" lvl="3"><number>&lsqb;0400&rsqb;</number> An SAS Directory contains information about the subdirectories and files located within this directory. This information is used to store metadata information related to the files associated with the streamed application. This data is used to fool the application into thinking that it is running locally on a machine when most of the data is resided elsewhere. </paragraph>
<paragraph id="P-0401" lvl="3"><number>&lsqb;0401&rsqb;</number> The SAS directory contains information about files in its directory. The information includes file number, names, and metadata associated with the files. </paragraph>
<paragraph id="P-0402" lvl="4"><number>&lsqb;0402&rsqb;</number> MagicNumber &lsqb;4 bytes&rsqb;: Magic number for SAS directory file. </paragraph>
<paragraph id="P-0403" lvl="4"><number>&lsqb;0403&rsqb;</number> ParentFileID &lsqb;16&plus;4 bytes&rsqb;: AppID&plus;FileNumber of the parent directory. AppID is set to 0 if the directory is the root. </paragraph>
<paragraph id="P-0404" lvl="4"><number>&lsqb;0404&rsqb;</number> SelfFileID &lsqb;16&plus;4 bytes&rsqb;: AppID&plus;FileNumber of this directory. </paragraph>
<paragraph id="P-0405" lvl="4"><number>&lsqb;0405&rsqb;</number> NumFiles &lsqb;4 bytes&rsqb;: Number of files in the directory. </paragraph>
<paragraph id="P-0406" lvl="3"><number>&lsqb;0406&rsqb;</number> Variable-Sized File Entry: </paragraph>
<paragraph id="P-0407" lvl="4"><number>&lsqb;0407&rsqb;</number> UsedFlag &lsqb;1 byte&rsqb;: 1 for used, 0 for unused. </paragraph>
<paragraph id="P-0408" lvl="4"><number>&lsqb;0408&rsqb;</number> ShortLen &lsqb;1 byte&rsqb;: Length of short file name. </paragraph>
<paragraph id="P-0409" lvl="4"><number>&lsqb;0409&rsqb;</number> LongLen &lsqb;2 byte&rsqb;: Length of long file name. </paragraph>
<paragraph id="P-0410" lvl="4"><number>&lsqb;0410&rsqb;</number> NameHash &lsqb;4 bytes&rsqb;: Hash value of the short file name for quick lookup without comparing whole string. </paragraph>
<paragraph id="P-0411" lvl="4"><number>&lsqb;0411&rsqb;</number> ShortName &lsqb;24 bytes&rsqb;: 8.3 short file name in Unicode. Not null-terminated. </paragraph>
<paragraph id="P-0412" lvl="4"><number>&lsqb;0412&rsqb;</number> FileID &lsqb;16&plus;4 bytes&rsqb;: AppID&plus;FileNumber of each file in this directory. </paragraph>
<paragraph id="P-0413" lvl="4"><number>&lsqb;0413&rsqb;</number> Metadata &lsqb;32 bytes&rsqb;: The metadata consists of file byte size (8 bytes), file creation time (8 bytes), file modified time (8 bytes), attribute flags (4 bytes), SAS flags (4 bytes). The bits of the attribute flags have the following meaning: </paragraph>
<paragraph id="P-0414" lvl="5"><number>&lsqb;0414&rsqb;</number> Bit 0: Read-only&mdash;Set if file is read-only </paragraph>
<paragraph id="P-0415" lvl="5"><number>&lsqb;0415&rsqb;</number> Bit 1: Hidden&mdash;Set if file is hidden from user </paragraph>
<paragraph id="P-0416" lvl="5"><number>&lsqb;0416&rsqb;</number> Bit 2: Directory&mdash;Set if the file is an SAS Directory </paragraph>
<paragraph id="P-0417" lvl="5"><number>&lsqb;0417&rsqb;</number> Bit 3: Archive&mdash;Set if the file is an archive </paragraph>
<paragraph id="P-0418" lvl="5"><number>&lsqb;0418&rsqb;</number> Bit 4: Normal&mdash;Set if the file is normal </paragraph>
<paragraph id="P-0419" lvl="5"><number>&lsqb;0419&rsqb;</number> Bit 5: System&mdash;Set if the file is a system file </paragraph>
<paragraph id="P-0420" lvl="5"><number>&lsqb;0420&rsqb;</number> Bit 6: Temporary&mdash;Set if the file is temporary </paragraph>
<paragraph id="P-0421" lvl="4"><number>&lsqb;0421&rsqb;</number> The bits of the SAS flags have the following meaning: </paragraph>
<paragraph id="P-0422" lvl="5"><number>&lsqb;0422&rsqb;</number> Bit 0: ForceUpgrade&mdash;Used only on root file. Set if client is forced to upgrade to this particular version if the current root version on the client is older. </paragraph>
<paragraph id="P-0423" lvl="5"><number>&lsqb;0423&rsqb;</number> Bit 1: RequireAccessToken&mdash;Set if file require access token before client can read it. </paragraph>
<paragraph id="P-0424" lvl="5"><number>&lsqb;0424&rsqb;</number> Bit 2: Read-only&mdash;Set if the file is read-only </paragraph>
<paragraph id="P-0425" lvl="3"><number>&lsqb;0425&rsqb;</number> LongName &lsqb;X bytes&rsqb;: Long filename in Unicode format with null-termination character. </paragraph>
<paragraph id="P-0426" lvl="2"><number>&lsqb;0426&rsqb;</number> d. Icon files </paragraph>
<paragraph id="P-0427" lvl="3"><number>&lsqb;0427&rsqb;</number> IconFileData &lsqb;X bytes&rsqb;: Content of an icon file. </paragraph>
</section>
<section>
<heading lvl="1">Format of APPINSTALLBLOCK </heading>
</section>
<section>
<heading lvl="1">Functionality </heading>
<paragraph id="P-0428" lvl="0"><number>&lsqb;0428&rsqb;</number> With respect to <cross-reference target="DRAWINGS">FIGS. 31</cross-reference><highlight><italic>a</italic></highlight>-<highlight><bold>31</bold></highlight><highlight><italic>h</italic></highlight>, the AppinstallBlock is a block of code and data associated with a particular application. This AppinstallBlock contains the information needed to by the SAS client to initialize the client machine before the streamed application is used for the first time. It also contains optional profiling data for increasing the runtime performance of that streamed application. </paragraph>
<paragraph id="P-0429" lvl="0"><number>&lsqb;0429&rsqb;</number> The AppinstallBlock is created offline by the SAS Builder program. First of all, the Builder monitors the installation process of a local version of the application installation program and records changes to the system. This includes any environment variables added or removed from the system <highlight><bold>3103</bold></highlight>, and any files added or modified in the system directories <highlight><bold>3102</bold></highlight>. Files added to the application specific directory are not recorded in the AppinstallBlock to reduce the amount of time needed to send the AppinstallBlock to the SAS client. Secondly, the Builder profiles the application to obtain the list of critical pages needed to run the application initially and an initial page reference sequence of the pages accessed during a sample run of the application. The AppInstallBlock contains an optional application-specific initialization code <highlight><bold>3107</bold></highlight>. This code is needed when the default initialization procedure is insufficient to setup the local machine environment for that particular application. </paragraph>
<paragraph id="P-0430" lvl="0"><number>&lsqb;0430&rsqb;</number> The AppinstallBlock and the runtime data are packaged into the SAS by the Builder and then uploaded to the application server. After the SAS client is subscribed to an application and before the application is run for the first time, the AppInstallBlock is sent by the server to the client. The SAS client invokes the default initialization procedure and the optional application-specific initialization code <highlight><bold>3107</bold></highlight>. Together, the default and the application-specific initialization procedure process the data in the AppInstallBlock to make the machine ready for streaming that particular application. </paragraph>
</section>
<section>
<heading lvl="1">Data Type Definitions </heading>
<paragraph id="P-0431" lvl="0"><number>&lsqb;0431&rsqb;</number> The AppInstallBlock is divided into the following sections: header section <highlight><bold>3101</bold></highlight>, variable section <highlight><bold>3103</bold></highlight>, file section <highlight><bold>3102</bold></highlight>, profile section <highlight><bold>3105</bold></highlight>, prefetch section <highlight><bold>3104</bold></highlight>, comment section <highlight><bold>3106</bold></highlight>, and code section <highlight><bold>3107</bold></highlight>. The header section <highlight><bold>3101</bold></highlight> contains general information about the AppinstallBlock. The information includes the total byte size and an index table containing size and offset into other sections. In a Windows version, the variable section consists of two registry tree structures to specify the registry entries added or removed from the OS environment. The file section <highlight><bold>3102</bold></highlight> is a tree structure consisting of the files copied to C drive during the application installation. The profile section <highlight><bold>3105</bold></highlight> contains the initial set of block reference sequences during Builder profiling of the application. The prefetch section <highlight><bold>3104</bold></highlight> consists of a subset of profiled blocks used by the Builder as a hint to the SAS client to prefetch initially. The comment section <highlight><bold>3106</bold></highlight> is used to inform the SAS client user of any relevant information about the application installation. Finally, the code section <highlight><bold>3107</bold></highlight> contains an optional program tailored for any application-specific installation not covered by the default streamed application installation procedure. In Windows version, the code section contains a Windows DLL. The following is a detailed description of each fields of the AppinstallBlock. </paragraph>
<paragraph id="P-0432" lvl="7"><number>&lsqb;0432&rsqb;</number> Note: Little endian format is used for all the fields spanning more than 1 byte. Also, BlockNumber specifies blocks of 4K byte size. </paragraph>
<paragraph id="P-0433" lvl="1"><number>&lsqb;0433&rsqb;</number> 1. Header Section: </paragraph>
<paragraph id="P-0434" lvl="2"><number>&lsqb;0434&rsqb;</number> The header section <highlight><bold>3103</bold></highlight> contains the basic information about this AppinstallBlock. This includes the versioning information, application identification, and index into other sections of the file. </paragraph>
<paragraph id="P-0435" lvl="2"><number>&lsqb;0435&rsqb;</number> Core Header Structure: </paragraph>
<paragraph id="P-0436" lvl="3"><number>&lsqb;0436&rsqb;</number> AibVersion &lsqb;4 bytes&rsqb;: Magic number or AppInstallBlock version number (which identifies the version of the appInstallBlock structure rather than the contents). </paragraph>
<paragraph id="P-0437" lvl="3"><number>&lsqb;0437&rsqb;</number> AppID &lsqb;16 bytes&rsqb;: this is an application identifier unique for each application. On Windows, this identifier is the GUID generated from the &lsquo;guidgen&rsquo; program. AppID for Word on Win98 will be different from Word on WinNT if it turns out that Word binaries are different between NT and 98. </paragraph>
<paragraph id="P-0438" lvl="3"><number>&lsqb;0438&rsqb;</number> VersionNo &lsqb;4 bytes&rsqb;: Version number. This allows us to inform the client that the appInstallBlock has changed for a particular appId. This is useful for changes to the AppinstallBlock due to minor patch upgrades in the application. </paragraph>
<paragraph id="P-0439" lvl="3"><number>&lsqb;0439&rsqb;</number> ClientOSBitMap &lsqb;4 bytes&rsqb;: Client OS supported bitmap or ID: for Win2K, Win98, WinNT (and generally for other and multiple OSs). </paragraph>
<paragraph id="P-0440" lvl="3"><number>&lsqb;0440&rsqb;</number> ClientOSServicePack &lsqb;4 bytes&rsqb;: For optional storage of the service pack level of the OS for which this appInstallBlock has been created. Note that when this field is set, the multiple OS bits in the above field ClientOSBitMap are not used. </paragraph>
<paragraph id="P-0441" lvl="3"><number>&lsqb;0441&rsqb;</number> Flags &lsqb;4 bytes&rsqb;: Flags pertaining to AppinstallBlock </paragraph>
<paragraph id="P-0442" lvl="4"><number>&lsqb;0442&rsqb;</number> Bit 0: Reboot&mdash;If set, the SAS client needs to reboot the machine after installing the AppinstallBlock on the client machine. </paragraph>
<paragraph id="P-0443" lvl="4"><number>&lsqb;0443&rsqb;</number> Bit 1: Unicode&mdash;If set, the string characters are 2 bytes wide instead of 1 byte. </paragraph>
<paragraph id="P-0444" lvl="3"><number>&lsqb;0444&rsqb;</number> HeaderSize &lsqb;2 bytes&rsqb;: Total size in bytes of the header section. </paragraph>
<paragraph id="P-0445" lvl="3"><number>&lsqb;0445&rsqb;</number> Reserved &lsqb;32 bytes&rsqb;: Reserved spaces for future. </paragraph>
<paragraph id="P-0446" lvl="3"><number>&lsqb;0446&rsqb;</number> NumberOfSections &lsqb;1 byte&rsqb;: Number of sections in the index table. This determines the number of entries in the index table structure described below: </paragraph>
<paragraph id="P-0447" lvl="2"><number>&lsqb;0447&rsqb;</number> Index Table Structure: (variable number of entries) </paragraph>
<paragraph id="P-0448" lvl="3"><number>&lsqb;0448&rsqb;</number> SectionType &lsqb;1 bytes&rsqb;: The type of data described in section. 0&equals;file section, 1&equals;variable section, 2&equals;prefetch section, 3&equals;profile section, 4&equals;comment section, 5&equals;code section. </paragraph>
<paragraph id="P-0449" lvl="3"><number>&lsqb;0449&rsqb;</number> SectionOffset &lsqb;4 bytes&rsqb;: The offset from the beginning of the file indicates the beginning of section. </paragraph>
<paragraph id="P-0450" lvl="3"><number>&lsqb;0450&rsqb;</number> SectionSize &lsqb;4 bytes&rsqb;: The size in bytes of section. </paragraph>
<paragraph id="P-0451" lvl="2"><number>&lsqb;0451&rsqb;</number> Variable Structure: </paragraph>
<paragraph id="P-0452" lvl="3"><number>&lsqb;0452&rsqb;</number> ApplicationNameIsAnsi &lsqb;1 byte&rsqb;: 1 if ansi, 0 if Unicode. </paragraph>
<paragraph id="P-0453" lvl="3"><number>&lsqb;0453&rsqb;</number> ApplicationNameLength &lsqb;4 bytes&rsqb;: Byte size of the application name </paragraph>
<paragraph id="P-0454" lvl="3"><number>&lsqb;0454&rsqb;</number> ApplicationName &lsqb;X bytes&rsqb;: Null terminating name of the application </paragraph>
<paragraph id="P-0455" lvl="1"><number>&lsqb;0455&rsqb;</number> 2. File Section: </paragraph>
<paragraph id="P-0456" lvl="2"><number>&lsqb;0456&rsqb;</number> The file section <highlight><bold>3102</bold></highlight> contains a subset of the list of files needed by the application to run properly. This section does not enumerate files located in the standard application program directory. It consists of information about files copied into an &lsquo;unusual&rsquo; directory during the installation of an application. If the file content is small (typically less than 1 MB), the file is copied to the client machine. Otherwise, the file is relocated to the standard program directory suitable for streaming. The file section data is a list of trees stored in a contiguous sequence of address spaces according to the pre-order traversal of the trees. A node in the tree can correspond to one or more levels of directories. A parent-child node pair is combined into a single node if the parent node has only a single child. Parsing the tree from the root of the tree to a leaf node results in a fully legal Windows pathname including the drive letter. Each entry of the node in the tree consists of the following structure: </paragraph>
<paragraph id="P-0457" lvl="2"><number>&lsqb;0457&rsqb;</number> Directory Structure: (variable number of entries) </paragraph>
<paragraph id="P-0458" lvl="3"><number>&lsqb;0458&rsqb;</number> Flags &lsqb;4 byte&rsqb;: Bit 0 is set if this entry is a directory </paragraph>
<paragraph id="P-0459" lvl="3"><number>&lsqb;0459&rsqb;</number> NumberOfChildren &lsqb;2 bytes&rsqb;: Number of nodes in this directory </paragraph>
<paragraph id="P-0460" lvl="3"><number>&lsqb;0460&rsqb;</number> DirectoryNameLength &lsqb;4 bytes&rsqb;: Length of the directory name </paragraph>
<paragraph id="P-0461" lvl="3"><number>&lsqb;0461&rsqb;</number> DirectoryName &lsqb;X bytes&rsqb;: Null terminating directory name </paragraph>
<paragraph id="P-0462" lvl="2"><number>&lsqb;0462&rsqb;</number> Leaf Structure: (variable number of entries) </paragraph>
<paragraph id="P-0463" lvl="2"><number>&lsqb;0463&rsqb;</number> Flags &lsqb;4 byte&rsqb;: Bit 1 is set to 1 if this entry is a spoof or copied file name </paragraph>
<paragraph id="P-0464" lvl="2"><number>&lsqb;0464&rsqb;</number> FileVersion &lsqb;8 bytes&rsqb;: Version of the file GetFileVersionInfo( ) if the file is win32 file image. Need variable file version size returned by GetFileVersionInfoSize( ). Otherwise use file size or file modified time to compare which file is the later version. </paragraph>
<paragraph id="P-0465" lvl="2"><number>&lsqb;0465&rsqb;</number> FileNameLength &lsqb;4 bytes&rsqb;: Byte size of the file name </paragraph>
<paragraph id="P-0466" lvl="2"><number>&lsqb;0466&rsqb;</number> FileName &lsqb;X bytes&rsqb;: Null terminating file name </paragraph>
<paragraph id="P-0467" lvl="2"><number>&lsqb;0467&rsqb;</number> DataLength &lsqb;4 bytes&rsqb;: Byte size of the data. If spoof file, then data is the string of the spoof directory. If copied file, then data is the content of the file </paragraph>
<paragraph id="P-0468" lvl="2"><number>&lsqb;0468&rsqb;</number> Data &lsqb;X bytes&rsqb;: Either the spoof file name or the content of the copied file </paragraph>
<paragraph id="P-0469" lvl="1"><number>&lsqb;0469&rsqb;</number> 3. Add Variable and Remove Variable Sections: </paragraph>
<paragraph id="P-0470" lvl="2"><number>&lsqb;0470&rsqb;</number> The add and remove variable sections <highlight><bold>3103</bold></highlight> contain the system variable changes needed to run the application. In a Windows system, each section consists of several number of registry subtrees. Each tree is stored in a contiguous sequence of address spaces according to the pre-order traversal of the tree. A node in the tree can correspond to one or more levels of directory in the registry. A parent-child node pair is combined into a single node if the parent node has only a single child. Parsing the tree from the root of the tree to a leaf node results in a fully legal key name. The order of the trees is shown here. </paragraph>
<paragraph id="P-0471" lvl="2"><number>&lsqb;0471&rsqb;</number> a. Registry Subsection: </paragraph>
<paragraph id="P-0472" lvl="3"><number>&lsqb;0472&rsqb;</number> 1. &ldquo;HKCR&rdquo;: HKEY_CLASSES_ROOT </paragraph>
<paragraph id="P-0473" lvl="3"><number>&lsqb;0473&rsqb;</number> 2. &ldquo;HKCU&rdquo;: HKEY_CURRENT_USER </paragraph>
<paragraph id="P-0474" lvl="3"><number>&lsqb;0474&rsqb;</number> 3. &ldquo;HKLM&rdquo;: HKEY_LOCAL_MACHINE </paragraph>
<paragraph id="P-0475" lvl="3"><number>&lsqb;0475&rsqb;</number> 4. &ldquo;HKUS&rdquo;: HKEY_USERS </paragraph>
<paragraph id="P-0476" lvl="3"><number>&lsqb;0476&rsqb;</number> 5. &ldquo;HKCC&rdquo;: HKEY_CURRENT_CONFIG </paragraph>
<paragraph id="P-0477" lvl="3"><number>&lsqb;0477&rsqb;</number> Tree Structure: (5 entries) </paragraph>
<paragraph id="P-0478" lvl="4"><number>&lsqb;0478&rsqb;</number> ExistFlag &lsqb;1 byte&rsqb;: Set to 1 if this tree exist, 0 otherwise. </paragraph>
<paragraph id="P-0479" lvl="4"><number>&lsqb;0479&rsqb;</number> Key or Value Structure entries &lsqb;X bytes&rsqb;: Serialization of the tree into variable number key or value structures described below. </paragraph>
<paragraph id="P-0480" lvl="3"><number>&lsqb;0480&rsqb;</number> Key Structure: (variable number of entries) </paragraph>
<paragraph id="P-0481" lvl="4"><number>&lsqb;0481&rsqb;</number> KeyFlag &lsqb;1 byte&rsqb;: Set to 1 if this entry is a key or 0 if it&apos;s a value structure </paragraph>
<paragraph id="P-0482" lvl="4"><number>&lsqb;0482&rsqb;</number> NumberOfSubchild &lsqb;4 bytes&rsqb;: Number of subkeys and values in this key directory </paragraph>
<paragraph id="P-0483" lvl="4"><number>&lsqb;0483&rsqb;</number> KeyNameLength &lsqb;4 bytes&rsqb;: Byte size of the key name </paragraph>
<paragraph id="P-0484" lvl="4"><number>&lsqb;0484&rsqb;</number> KeyName &lsqb;X bytes&rsqb;: Null terminating key name </paragraph>
<paragraph id="P-0485" lvl="3"><number>&lsqb;0485&rsqb;</number> Value Structure: (variable number of entries) </paragraph>
<paragraph id="P-0486" lvl="4"><number>&lsqb;0486&rsqb;</number> KeyFlag &lsqb;1 byte&rsqb;: Set to 1 if this entry is a key or 0 if it&apos;s a value structure </paragraph>
<paragraph id="P-0487" lvl="4"><number>&lsqb;0487&rsqb;</number> ValueType &lsqb;4 byte&rsqb;: Type of values from the Win32 API function RegQueryValueEx( ): REG_SZ, REG_BINARY, REG_DWORD, REG_LINK, REG_NONE, etc . . . </paragraph>
<paragraph id="P-0488" lvl="4"><number>&lsqb;0488&rsqb;</number> ValueNameLength &lsqb;4 bytes&rsqb;: Byte size of the value name </paragraph>
<paragraph id="P-0489" lvl="4"><number>&lsqb;0489&rsqb;</number> ValueName &lsqb;X bytes&rsqb;: Null terminating value name </paragraph>
<paragraph id="P-0490" lvl="4"><number>&lsqb;0490&rsqb;</number> ValueDataLength &lsqb;4 bytes&rsqb;: Byte size of the value data </paragraph>
<paragraph id="P-0491" lvl="4"><number>&lsqb;0491&rsqb;</number> ValueData &lsqb;X bytes&rsqb;: Value of the Data </paragraph>
<paragraph id="P-0492" lvl="3"><number>&lsqb;0492&rsqb;</number> In addition to registry changes, an installation in a Windows system may involve changes to the ini files. The following structure is used to communicate the ini file changes needed to be done on the SAS client machine. The ini entries are appended to the end of the variable section after the five registry trees are enumerated. </paragraph>
<paragraph id="P-0493" lvl="2"><number>&lsqb;0493&rsqb;</number> b. INI Subsection: </paragraph>
<paragraph id="P-0494" lvl="3"><number>&lsqb;0494&rsqb;</number> NumFiles &lsqb;4 bytes&rsqb;: Number of INI files modified. </paragraph>
<paragraph id="P-0495" lvl="3"><number>&lsqb;0495&rsqb;</number> File Structure: (variable number of entries) </paragraph>
<paragraph id="P-0496" lvl="4"><number>&lsqb;0496&rsqb;</number> FileNameLength &lsqb;4 bytes&rsqb;: Byte length of the file name </paragraph>
<paragraph id="P-0497" lvl="4"><number>&lsqb;0497&rsqb;</number> FileName &lsqb;X bytes&rsqb;: Name of the INI file </paragraph>
<paragraph id="P-0498" lvl="4"><number>&lsqb;0498&rsqb;</number> NumSection &lsqb;4 bytes&rsqb;: Number of sections with the changes </paragraph>
<paragraph id="P-0499" lvl="3"><number>&lsqb;0499&rsqb;</number> Section Structure: (variable number of entries) </paragraph>
<paragraph id="P-0500" lvl="4"><number>&lsqb;0500&rsqb;</number> SectionNameLength &lsqb;4 bytes&rsqb;: Byte length of the section name </paragraph>
<paragraph id="P-0501" lvl="4"><number>&lsqb;0501&rsqb;</number> SectionName &lsqb;X bytes&rsqb;: Section name of an INI file </paragraph>
<paragraph id="P-0502" lvl="4"><number>&lsqb;0502&rsqb;</number> NumValues &lsqb;4 bytes&rsqb;: Number of values in this section </paragraph>
<paragraph id="P-0503" lvl="3"><number>&lsqb;0503&rsqb;</number> Value Structure: (variable number of entries) </paragraph>
<paragraph id="P-0504" lvl="4"><number>&lsqb;0504&rsqb;</number> ValueLength &lsqb;4 bytes&rsqb;: Byte length of the value data </paragraph>
<paragraph id="P-0505" lvl="4"><number>&lsqb;0505&rsqb;</number> ValueData &lsqb;X bytes&rsqb;: Content of the value data </paragraph>
<paragraph id="P-0506" lvl="1"><number>&lsqb;0506&rsqb;</number> 4. Prefetch Section: </paragraph>
<paragraph id="P-0507" lvl="2"><number>&lsqb;0507&rsqb;</number> The prefetch section <highlight><bold>3104</bold></highlight> contains a list of file blocks. The Builder profiler determines the set of file blocks critical for the initial run of the application. This data includes the code to start and terminate the application. It includes the file blocks containing frequently used commands. For example, opening and saving of documents are frequently used commands and should be prefetched if possible. Another type of block to include in the prefetch section are the blocks associated with frequently accessed directories and file metadata in this directory. The prefetch section is divided into two subsections. One part contains the critical blocks that are used during startup of the streamed application. The second part consists of the blocks accessed for common user operations like opening and saving of document. The format of the data is described below: </paragraph>
<paragraph id="P-0508" lvl="2"><number>&lsqb;0508&rsqb;</number> a. Critical Block Subsection: </paragraph>
<paragraph id="P-0509" lvl="3"><number>&lsqb;0509&rsqb;</number> NumCriticalBlocks &lsqb;4 bytes&rsqb;: Number of critical blocks. </paragraph>
<paragraph id="P-0510" lvl="2"><number>&lsqb;0510&rsqb;</number> Block Structure: (variable number of entries) </paragraph>
<paragraph id="P-0511" lvl="3"><number>&lsqb;0511&rsqb;</number> FileNumber &lsqb;4 bytes&rsqb;: File Number of the file containing the block to prefetch </paragraph>
<paragraph id="P-0512" lvl="3"><number>&lsqb;0512&rsqb;</number> BlockNumber &lsqb;4 bytes&rsqb;: Block Number of the file block to prefetch </paragraph>
<paragraph id="P-0513" lvl="2"><number>&lsqb;0513&rsqb;</number> b. Common Block Subsection: </paragraph>
<paragraph id="P-0514" lvl="3"><number>&lsqb;0514&rsqb;</number> NumCommonBlocks &lsqb;4 bytes&rsqb;: Number of critical blocks. </paragraph>
<paragraph id="P-0515" lvl="2"><number>&lsqb;0515&rsqb;</number> Block Structure: (variable number of entries) </paragraph>
<paragraph id="P-0516" lvl="3"><number>&lsqb;0516&rsqb;</number> FileNumber &lsqb;4 bytes&rsqb;: File Number of the file containing the block to prefetch </paragraph>
<paragraph id="P-0517" lvl="3"><number>&lsqb;0517&rsqb;</number> BlockNumber &lsqb;4 bytes&rsqb;: Block Number of the file block to prefetch </paragraph>
<paragraph id="P-0518" lvl="1"><number>&lsqb;0518&rsqb;</number> 5. Profile Section: </paragraph>
<paragraph id="P-0519" lvl="2"><number>&lsqb;0519&rsqb;</number> The profile section <highlight><bold>3105</bold></highlight> consists of a reference sequence of file blocks accessed by the application at runtime. Conceptually, the profile data is a two dimensional matrix. Each entry &lsqb;row, column&rsqb; of the matrix is the frequency, a block row is followed by a block column. In any realistic applications of fair size, this matrix is very large and sparse. The proper data structure must be selected to store this sparse matrix efficiently in required storage space and minimize the overhead in accessing this data structure access. </paragraph>
<paragraph id="P-0520" lvl="2"><number>&lsqb;0520&rsqb;</number> The section is constructed from two basic structures: row and column structures. Each row structure is followed by N column structures specified in the NumberColumns field. Note that this is an optional section. But with appropriate profile data, the SAS client prefetcher performance can be increased. </paragraph>
<paragraph id="P-0521" lvl="2"><number>&lsqb;0521&rsqb;</number> Row Structure: (variable number of entries) </paragraph>
<paragraph id="P-0522" lvl="3"><number>&lsqb;0522&rsqb;</number> FileNumber &lsqb;4 bytes&rsqb;: File Number of the row block </paragraph>
<paragraph id="P-0523" lvl="3"><number>&lsqb;0523&rsqb;</number> BlockNumber &lsqb;4 bytes&rsqb;: Block Number of the row block </paragraph>
<paragraph id="P-0524" lvl="3"><number>&lsqb;0524&rsqb;</number> NumberColumns &lsqb;4 bytes&rsqb;: number of blocks that follows this block. This field determines the number of column structures following this field. </paragraph>
<paragraph id="P-0525" lvl="2"><number>&lsqb;0525&rsqb;</number> Column Structure: (variable number of entries) </paragraph>
<paragraph id="P-0526" lvl="3"><number>&lsqb;0526&rsqb;</number> FileNumber &lsqb;4 bytes&rsqb;: File Number of the column block </paragraph>
<paragraph id="P-0527" lvl="3"><number>&lsqb;0527&rsqb;</number> BlockNumber &lsqb;4 bytes&rsqb;: Block Number of the column block </paragraph>
<paragraph id="P-0528" lvl="3"><number>&lsqb;0528&rsqb;</number> Frequency &lsqb;4 bytes&rsqb;: frequency the row block is followed by column block </paragraph>
<paragraph id="P-0529" lvl="1"><number>&lsqb;0529&rsqb;</number> 6. Comment Section: </paragraph>
<paragraph id="P-0530" lvl="2"><number>&lsqb;0530&rsqb;</number> The comment section <highlight><bold>3106</bold></highlight> is used by the Builder to describe this AppinstallBlock in more detail. </paragraph>
<paragraph id="P-0531" lvl="3"><number>&lsqb;0531&rsqb;</number> CommentLengthIsAnsi &lsqb;1 byte&rsqb;: 1 if string is ansi, 0 if Unicode format. </paragraph>
<paragraph id="P-0532" lvl="3"><number>&lsqb;0532&rsqb;</number> CommentLength &lsqb;4 bytes&rsqb;: Byte size of the comment string </paragraph>
<paragraph id="P-0533" lvl="3"><number>&lsqb;0533&rsqb;</number> Comment &lsqb;X bytes&rsqb;: Null terminating comment string </paragraph>
<paragraph id="P-0534" lvl="1"><number>&lsqb;0534&rsqb;</number> 7. Code Section: </paragraph>
<paragraph id="P-0535" lvl="2"><number>&lsqb;0535&rsqb;</number> The code section <highlight><bold>3107</bold></highlight> consists of the application-specific initialization code needed to run on the SAS client to setup the client machine for this particular application. This section may be empty if the default initialization procedure in the SAS client is able to setup the client machine without requiring any application-specific instructions. On the Windows system, the code is a DLL file containing two exported function calls: Install( ), Uninstall( ). The SAS client loads the DLL and invokes the appropriate function calls. </paragraph>
<paragraph id="P-0536" lvl="3"><number>&lsqb;0536&rsqb;</number> CodeLength &lsqb;4 bytes&rsqb;: Byte size of the code </paragraph>
<paragraph id="P-0537" lvl="3"><number>&lsqb;0537&rsqb;</number> Code &lsqb;X bytes&rsqb;: Binary file containing the application-specific initialization code. On Windows, this is just a DLL file. </paragraph>
<paragraph id="P-0538" lvl="1"><number>&lsqb;0538&rsqb;</number> 8. LicenseAgreement Section: </paragraph>
<paragraph id="P-0539" lvl="2"><number>&lsqb;0539&rsqb;</number> The Builder creates the license agreement section <highlight><bold>3108</bold></highlight>. The SAS client displays the license agreement text to the end-user before the application is started for the first time. The end-user must agree to all licensing agreement set by the software vendor in order to use the application. </paragraph>
<paragraph id="P-0540" lvl="3"><number>&lsqb;0540&rsqb;</number> LicenseTextIsAnsi &lsqb;1 byte&rsqb;: 1 if ansi, 0 if Unicode format. </paragraph>
<paragraph id="P-0541" lvl="3"><number>&lsqb;0541&rsqb;</number> LicenseTextLength &lsqb;4 bytes&rsqb;: Byte size of the license text </paragraph>
<paragraph id="P-0542" lvl="3"><number>&lsqb;0542&rsqb;</number> LicenseAgreement &lsqb;X bytes&rsqb;: Null terminating license agreement string </paragraph>
</section>
<section>
<heading lvl="1">Client Installation and Execution of Streamed Applications </heading>
</section>
<section>
<heading lvl="1">Summary </heading>
<paragraph id="P-0543" lvl="0"><number>&lsqb;0543&rsqb;</number> This section describes the process of installing and uninstalling streamed application on the client machine. With respect to <cross-reference target="DRAWINGS">FIG. 32</cross-reference>, the lifecycle of the Application Install Block is shown. The Application Stream Builder <highlight><bold>3202</bold></highlight> takes original application files <highlight><bold>3201</bold></highlight> and produces a corresponding Application Install Block and Stream Application Set <highlight><bold>3203</bold></highlight>. These two files get installed onto the application servers <highlight><bold>3206</bold></highlight>. On the right side of the drawing, it shows how either the administrator or the user can subscribe to the application from either the client computer <highlight><bold>3208</bold></highlight> or an administration computer <highlight><bold>3207</bold></highlight>. Once the user logons onto the client computer <highlight><bold>3208</bold></highlight>, the license and the AIB <highlight><bold>3203</bold></highlight> are acquired from the license <highlight><bold>3205</bold></highlight> and application servers <highlight><bold>3206</bold></highlight>, respectively. </paragraph>
<paragraph id="P-0544" lvl="0"><number>&lsqb;0544&rsqb;</number> The following are features of a preferred embodiment of the invention: </paragraph>
<paragraph id="P-0545" lvl="2"><number>&lsqb;0545&rsqb;</number> 1. The streamed application installation process installs just the description of the application, not the total content of the application. After installing such description, the client system looks and feels similar to having installed the same app using a non-streamed method. This has the following benefits: </paragraph>
<paragraph id="P-0546" lvl="3"><number>&lsqb;0546&rsqb;</number> a. Takes a very small fraction of the time to install the application. </paragraph>
<paragraph id="P-0547" lvl="3"><number>&lsqb;0547&rsqb;</number> b. Takes a very small fraction of the disk space. </paragraph>
<paragraph id="P-0548" lvl="3"><number>&lsqb;0548&rsqb;</number> c. Client does not have to wait for the entire application to be downloaded. This is particularly important to users with slow network connections. </paragraph>
<paragraph id="P-0549" lvl="2"><number>&lsqb;0549&rsqb;</number> &emsp;The application description is subsequently un-installed without requiring deleting the total contents of the application. This has the benefit that it takes a very small fraction of the time to uninstall the application. </paragraph>
<paragraph id="P-0550" lvl="2"><number>&lsqb;0550&rsqb;</number> 2. Enhancing streamed application&apos;s performance by: </paragraph>
<paragraph id="P-0551" lvl="3"><number>&lsqb;0551&rsqb;</number> a. Copying small portions of application&apos;s code and data (pages) that are critical to performance. </paragraph>
<paragraph id="P-0552" lvl="3"><number>&lsqb;0552&rsqb;</number> b. Providing client with the initial profile data that can be used to perform pre-fetching. </paragraph>
<paragraph id="P-0553" lvl="3"><number>&lsqb;0553&rsqb;</number> This has the following benefits: </paragraph>
<paragraph id="P-0554" lvl="4"><number>&lsqb;0554&rsqb;</number> 1. User experiences smooth and predictable application launch. </paragraph>
<paragraph id="P-0555" lvl="4"><number>&lsqb;0555&rsqb;</number> 2. Scalability of Application servers increases by reducing the number of client connections. </paragraph>
<paragraph id="P-0556" lvl="2"><number>&lsqb;0556&rsqb;</number> 3. An administrator can arrange applications to be installed automatically on client computers. Administrator can also arrange the installation on various client computers simultaneously without being physically present on each client computer. This has the following benefits: </paragraph>
<paragraph id="P-0557" lvl="3"><number>&lsqb;0557&rsqb;</number> a. Users are not burdened with the process of installing streamed applications. </paragraph>
<paragraph id="P-0558" lvl="3"><number>&lsqb;0558&rsqb;</number> b. Reduced administration expense. </paragraph>
<paragraph id="P-0559" lvl="1"><number>&lsqb;0559&rsqb;</number> Overview of Components Relevant to the Install Process </paragraph>
<paragraph id="P-0560" lvl="2"><number>&lsqb;0560&rsqb;</number> Subscription Server <highlight><bold>3204</bold></highlight>: allows users to create accounts &amp; to rent. </paragraph>
<paragraph id="P-0561" lvl="2"><number>&lsqb;0561&rsqb;</number> License Server <highlight><bold>3205</bold></highlight>: authenticates users &amp; determines licensing rights to applications. </paragraph>
<paragraph id="P-0562" lvl="2"><number>&lsqb;0562&rsqb;</number> Application Server <highlight><bold>3206</bold></highlight>: provides application bits to licensed users securely &amp; efficiently. </paragraph>
<paragraph id="P-0563" lvl="2"><number>&lsqb;0563&rsqb;</number> Application Install Manager&mdash;a component installed on the streaming client that is responsible for installing and uninstalling streamed applications. </paragraph>
<paragraph id="P-0564" lvl="2"><number>&lsqb;0564&rsqb;</number> Application Install Block (AIB) <highlight><bold>3203</bold></highlight>&mdash;a representation of what gets installed on the client machine when a streamed application is installed. It contains portions of the application that are responsible for registering the application with the client operating system and other data that enhances the execution of streamed application. </paragraph>
<paragraph id="P-0565" lvl="2"><number>&lsqb;0565&rsqb;</number> Application Stream Builder <highlight><bold>3202</bold></highlight>&mdash;preprocesses apps &amp; prepares files to be installed on Application Server and data, such as AIB, to be installed by Client Application Installer. </paragraph>
<paragraph id="P-0566" lvl="2"><number>&lsqb;0566&rsqb;</number> Stream Application Set <highlight><bold>3203</bold></highlight>&mdash;a method of representing the total content of the application in a format that is optimal for streaming. </paragraph>
<paragraph id="P-0567" lvl="2"><number>&lsqb;0567&rsqb;</number> Client Streaming File System&mdash;integrates client exec with paging from a special file system backed by remote network-accessed server-based store </paragraph>
</section>
<section>
<heading lvl="1">Application Install Block (AIB) </heading>
<paragraph id="P-0568" lvl="0"><number>&lsqb;0568&rsqb;</number> Installing and un-installing a stream application requires an understanding of what AIB is and how it gets manipulated by the various components in the overall streaming system. AIB is physically represented as a data file with various different sections. Its contents include: </paragraph>
<paragraph id="P-0569" lvl="2"><number>&lsqb;0569&rsqb;</number> Streamed application name and identification number. </paragraph>
<paragraph id="P-0570" lvl="2"><number>&lsqb;0570&rsqb;</number> Software License Agreement. </paragraph>
<paragraph id="P-0571" lvl="2"><number>&lsqb;0571&rsqb;</number> Registry spoof set. </paragraph>
<paragraph id="P-0572" lvl="2"><number>&lsqb;0572&rsqb;</number> File spoof set. </paragraph>
<paragraph id="P-0573" lvl="2"><number>&lsqb;0573&rsqb;</number> Small number of application pages&mdash;initial cache contents. </paragraph>
<paragraph id="P-0574" lvl="2"><number>&lsqb;0574&rsqb;</number> Application Profile Data. </paragraph>
</section>
<section>
<heading lvl="1">AIB Lifecycle </heading>
<paragraph id="P-0575" lvl="0"><number>&lsqb;0575&rsqb;</number> The following describes the AIB lifecycle: </paragraph>
<paragraph id="P-0576" lvl="2"><number>&lsqb;0576&rsqb;</number> 1. Using the process described in the section above concerning converting apps for stream delivery and subsequent execution, an application install block is created by the Application Stream Builder. Initially, there will be one AIB per application, however, as the application evolves via patches and service packs, new AIBs may need to be generated. </paragraph>
<paragraph id="P-0577" lvl="2"><number>&lsqb;0577&rsqb;</number> 2. Using a process described in the section above regarding server-side performance optimization, AIB will get hosted by the application servers. </paragraph>
<paragraph id="P-0578" lvl="2"><number>&lsqb;0578&rsqb;</number> 3. &ldquo;Subscribing&rdquo; the application by communicating with the subscription server. Subscribing to an application requires a valid account with the ASP. Either the user or an administrator acting on the user&apos;s behalf can subscribe the application. In addition, the application can be subscribed to from any computer on the Internet, not just the client machine where the application will be eventually installed. This allows an administrator to subscribe applications for a group of users without worrying about individual client machines. </paragraph>
<paragraph id="P-0579" lvl="2"><number>&lsqb;0579&rsqb;</number> 4. The client machine acquires the license for the application from the license server. If the application was subscribed from the client machine itself, this step will happen automatically after subscribing to the application. If the subscription happened from a different machine, e.g., the administrator&apos;s machine, this step will happen when the user logs on the client machine. As an acknowledgment of having a valid license, the license server gives the client an encrypted access token. </paragraph>
<paragraph id="P-0580" lvl="2"><number>&lsqb;0580&rsqb;</number> 5. Fetch the contents of AIB from the application server. This step is transparent and happens immediately after the preceding step. Since application server requires the client to possess a valid access token, it ensures that only subscribed and licensed users can install the streamed application. </paragraph>
<paragraph id="P-0581" lvl="2"><number>&lsqb;0581&rsqb;</number> 6. The Application Install Manager (AIM) performs the act of installing the application information, as specified by the AIB, on the client system. </paragraph>
</section>
<section>
<heading lvl="1">Installing a Streamed Application </heading>
<paragraph id="P-0582" lvl="0"><number>&lsqb;0582&rsqb;</number> AIM downloads AIB from the application server and takes the necessary steps in installing the application description on the client system. It extracts pieces of information from AIB and sends messages to various other components (described later) to perform the installation. AIM also creates an Install-Log that can be used when un-installing the streamed application. </paragraph>
<paragraph id="P-0583" lvl="2"><number>&lsqb;0583&rsqb;</number> 1. Display a license agreement to the user and wait for the user to agree to it. </paragraph>
<paragraph id="P-0584" lvl="2"><number>&lsqb;0584&rsqb;</number> 2. Extract File Spoof Data and communicate that to the Client File Spoofer. The list of files being spoofed will be recorded in the Install-Log. </paragraph>
<paragraph id="P-0585" lvl="2"><number>&lsqb;0585&rsqb;</number> 3. Extract Registry Spoof Data and communicate that to the Client Registry Spoofer. The list of Registries being spoofed will be recorded in the Install-Log. </paragraph>
<paragraph id="P-0586" lvl="2"><number>&lsqb;0586&rsqb;</number> 4. Extract Initial Cache Content and communicate that to the Client Prefetch Unit. </paragraph>
<paragraph id="P-0587" lvl="2"><number>&lsqb;0587&rsqb;</number> 5. Extract Profile Data and communicate that to the Client Prefetch Unit. </paragraph>
<paragraph id="P-0588" lvl="2"><number>&lsqb;0588&rsqb;</number> 6. Save the Install-Log in persistent storage. </paragraph>
</section>
<section>
<heading lvl="1">Un-Installing a Streamed Application </heading>
<paragraph id="P-0589" lvl="0"><number>&lsqb;0589&rsqb;</number> Un-installation process relies on the Install-Log to know what specific items to un-install. Following steps are performed when un-installing and application: </paragraph>
<paragraph id="P-0590" lvl="2"><number>&lsqb;0590&rsqb;</number> 1. Communicate with the Client Registry Spoofer to remove all registries being spoofed for the application being un-installed. </paragraph>
<paragraph id="P-0591" lvl="2"><number>&lsqb;0591&rsqb;</number> 2. Communicate with the Client File Spoofer to disable all files being spoofed for the application being un-installed. </paragraph>
<paragraph id="P-0592" lvl="2"><number>&lsqb;0592&rsqb;</number> 3. Communicate with the Client Prefetch Unit to remove all Profile Data for the application being un-installed. </paragraph>
<paragraph id="P-0593" lvl="2"><number>&lsqb;0593&rsqb;</number> 4. Communicate with the Client Cache Manager to remove all pages being cached for the application being un-installed. </paragraph>
<paragraph id="P-0594" lvl="2"><number>&lsqb;0594&rsqb;</number> 5. Delete the Install-Log. </paragraph>
</section>
<section>
<heading lvl="1">Client File Spoofer </heading>
<paragraph id="P-0595" lvl="0"><number>&lsqb;0595&rsqb;</number> A file spoofer component is installed on the client machine and is responsible for redirecting file accesses from a local file system to the streaming file system. The spoofer operates on a file spoof database that is stored persistently on the client system; it contains a number of file maps with following format:</paragraph>
<paragraph lvl="0"><in-line-formula>&lsqb;Original path of a local file&rsqb;&larr;&rarr; &lsqb;New path of a file on streaming drive&rsqb;</in-line-formula></paragraph>
<paragraph id="P-0596" lvl="7"><number>&lsqb;0596&rsqb;</number> Where &ldquo;&larr;&rarr;&rdquo; indicates a bidirectional mapping between the two sides of the relationship shown. </paragraph>
<paragraph id="P-0597" lvl="0"><number>&lsqb;0597&rsqb;</number> When a streamed application is installed, the list of new files to spoof (found in AIB) is added to the file spoof database. Similarly, when a streamed application is un-installed, a list of files being spoofed for that application is removed from the file spoof database. </paragraph>
<paragraph id="P-0598" lvl="0"><number>&lsqb;0598&rsqb;</number> On clients running the Windows 2000 Operating System, the file spoofer is a kernel-mode driver and the spoof database is stored in the registry. </paragraph>
</section>
<section>
<heading lvl="1">Client Registry Spoofer </heading>
<paragraph id="P-0599" lvl="0"><number>&lsqb;0599&rsqb;</number> The Registry Spoofer intercepts all registry calls being made on the client system and re-directs calls manipulating certain registries to an alternate path. Effectively, it is mapping the original registry to an alternate registry transparently. Similar to the client file spoofer, the registry spoofer operates on a registry spoof database consisting entries old/new registry paths. The database must be stored in persistent storage. </paragraph>
<paragraph id="P-0600" lvl="0"><number>&lsqb;0600&rsqb;</number> When a streamed application is installed, the list of new registries to spoof (found in AIB) is added to the registry spoof database. Upon un-installation of a streamed application, its list of spoofed registries is removed from the registry spoof database. </paragraph>
<paragraph id="P-0601" lvl="0"><number>&lsqb;0601&rsqb;</number> On clients running the Windows 2000 Operating System, the registry spoofer is a kernel-mode driver and the registry spoof database is stored in the registry. </paragraph>
</section>
<section>
<heading lvl="1">Client Prefetch Unit </heading>
<paragraph id="P-0602" lvl="0"><number>&lsqb;0602&rsqb;</number> In a streaming system, it is often a problem that the initial invocation of the application takes a lot of time because the necessary application pages are not present on the client system when needed. A key aspect of the client install is that by using a client prefetch unit, a system in accordance with the present invention significantly reduces the performance hit associated with fetching. The Client Prefetch Unit performs two main tasks: </paragraph>
<paragraph id="P-0603" lvl="2"><number>&lsqb;0603&rsqb;</number> 1. Populate Initial Cache Content, </paragraph>
<paragraph id="P-0604" lvl="2"><number>&lsqb;0604&rsqb;</number> 2. Prefetch Application Pages. </paragraph>
</section>
<section>
<heading lvl="1">Initial Cache Content </heading>
<paragraph id="P-0605" lvl="0"><number>&lsqb;0605&rsqb;</number> The Application Stream Builder determines the set of pages critical for the initial invocation and packages them as part of the AIB. These pages, also known as initial cache content, include: </paragraph>
<paragraph id="P-0606" lvl="2"><number>&lsqb;0606&rsqb;</number> Pages required to start and stop the application, </paragraph>
<paragraph id="P-0607" lvl="2"><number>&lsqb;0607&rsqb;</number> Contents of frequently accessed directories, </paragraph>
<paragraph id="P-0608" lvl="2"><number>&lsqb;0608&rsqb;</number> Application pages performing some of the most common operations within application. For example, if Microsoft Word is being streamed, these operations include: opening &amp; saving document files &amp; running a spell checker. </paragraph>
<paragraph id="P-0609" lvl="0"><number>&lsqb;0609&rsqb;</number> When the Stream Application is installed on the client, these pages are put into the client cache; later, when the streamed application is invoked, these pages will be present locally and network latency is avoided. </paragraph>
<paragraph id="P-0610" lvl="0"><number>&lsqb;0610&rsqb;</number> In preparing the Prefetch data, it is critical to manage the trade off of how many pages to put into AIB and what potential benefits it brings to the initial application launch. The more pages that are put into prefetch data, the smoother the initial application launch will be; however, since the AIB will get bigger (as a result of packing more pages in it), users will have to wait longer when installing the streamed application. In a preferred embodiment of the invention, the size of the AIB is limited to approximately 250 KB. </paragraph>
<paragraph id="P-0611" lvl="0"><number>&lsqb;0611&rsqb;</number> In an alternative embodiment of the invention the AIB initially includes only the page/file numbers and not the pages themselves. The client then goes through the page/file numbers and does paging requests to fetch the indicated pages from the server. </paragraph>
</section>
<section>
<heading lvl="1">Prefetch Application Pages </heading>
<paragraph id="P-0612" lvl="0"><number>&lsqb;0612&rsqb;</number> When the streaming application executes, it will generate paging requests for pages that are not present in the client cache. The client cache manager must contact the application server and request the page in question. The invention takes advantage of this opportunity to also request additional pages that the application may need in the future. This not only reduces the number of connections to the application server, and overhead related to that, but also hides the latency of cache misses. </paragraph>
<paragraph id="P-0613" lvl="0"><number>&lsqb;0613&rsqb;</number> The application installation process plays a role in the pre-fetching by communicating the profile data present in the AIB to the Client Prefetch Unit when the application is installed. Upon un-installation, profile data for the particular application will be removed. </paragraph>
</section>
<section>
<heading lvl="1">Caching of Streamed Application Pages Within the Network </heading>
</section>
<section>
<heading lvl="1">Summary </heading>
<paragraph id="P-0614" lvl="0"><number>&lsqb;0614&rsqb;</number> This section describes how collaborative caching is employed to substantially improve the performance of a client server system in accordance with the other aspects of the present invention. Specifically, particular caching configurations and an intelligent way to combine these caching configurations are detailed. </paragraph>
<paragraph id="P-0615" lvl="1"><number>&lsqb;0615&rsqb;</number> Collaborative Caching Features: </paragraph>
<paragraph id="P-0616" lvl="2"><number>&lsqb;0616&rsqb;</number> Using another client&apos;s cache to get required pages/packets (Peer Caching) </paragraph>
<paragraph id="P-0617" lvl="2"><number>&lsqb;0617&rsqb;</number> Using an intermediate proxy or node to get required pages/packets (Proxy Caching) </paragraph>
<paragraph id="P-0618" lvl="2"><number>&lsqb;0618&rsqb;</number> Using a broadcasting or multicasting mechanism to make a request (Multicast) </paragraph>
<paragraph id="P-0619" lvl="2"><number>&lsqb;0619&rsqb;</number> Using a packet based protocol to send requested pages/packets rather than a stream based one. (Packet Protocol) </paragraph>
<paragraph id="P-0620" lvl="2"><number>&lsqb;0620&rsqb;</number> Using concurrency to request a page through all three means (Peer Caching or Proxy Caching or the actual server) to improve performance (Concurrent Requesting). </paragraph>
<paragraph id="P-0621" lvl="2"><number>&lsqb;0621&rsqb;</number> Using heuristical algorithms to use all three ways to get the required pages (Smart Requesting). </paragraph>
<paragraph id="P-0622" lvl="1"><number>&lsqb;0622&rsqb;</number> These features have the following advantages: </paragraph>
<paragraph id="P-0623" lvl="2"><number>&lsqb;0623&rsqb;</number> These ideas potentially improve the performance of the client, i.e., they reduce the time a client takes to download a page (Client Performance). </paragraph>
<paragraph id="P-0624" lvl="2"><number>&lsqb;0624&rsqb;</number> These ideas improve the scalability of the server because the server gets fewer requests, i.e., requests which are fulfilled by a peer or a proxy don&apos;t get sent to the server. (Server Scalability) </paragraph>
<paragraph id="P-0625" lvl="2"><number>&lsqb;0625&rsqb;</number> These allow a local caching mechanism without needing any kind of modification of local proxy nodes or routers or even the servers. The peer-to-peer caching is achieved solely through the co-operation of two clients. (Client Only Implementation) </paragraph>
<paragraph id="P-0626" lvl="2"><number>&lsqb;0626&rsqb;</number> These ideas allow a client to potentially operate &ldquo;offline&rdquo; i.e., when it is not getting any responses from the server (Offline Client Operation). </paragraph>
<paragraph id="P-0627" lvl="2"><number>&lsqb;0627&rsqb;</number> These ideas allow the existing network bandwidth to be used more effectively and potentially reduce the dependency of applications on higher bandwidth (Optimal Use of Bandwidth). </paragraph>
<paragraph id="P-0628" lvl="2"><number>&lsqb;0628&rsqb;</number> These ideas when used in an appropriate configuration allow each client to require a smaller local cache but without substantially sacrificing the performance that you get by local caching. An example is when each client &ldquo;specializes&rdquo; in caching pages of a certain kind, e.g., a certain application. (Smaller Local Cache). </paragraph>
<paragraph id="P-0629" lvl="0"><number>&lsqb;0629&rsqb;</number> These ideas involve new interrelationships&mdash;peer-to-peer communication for cache accesses; or new configurations&mdash;collaborative caching. The reason this is called collaborative is because a group of clients can collaborate in caching pages that each of them needs. </paragraph>
<paragraph id="P-0630" lvl="1"><number>&lsqb;0630&rsqb;</number> Aspects of Collaborative Caching </paragraph>
<paragraph id="P-0631" lvl="2"><number>&lsqb;0631&rsqb;</number> 1. Peer Caching: A client X getting its pages from another client Y&apos;s local cache rather than its (X&apos;s) own or from the server seems to be a new idea. Major advantages: client performance, server scalability, client only implementation, offline client operation, optimal use of bandwidth, smaller local cache. </paragraph>
<paragraph id="P-0632" lvl="2"><number>&lsqb;0632&rsqb;</number> 2. Proxy Caching: The client getting its pages from an intermediate proxy which either serves the page from the local cache or from another intermediate proxy or the remote server (if none of the intermediate proxies has the page) is unique, at a minimum, for the pages of a streamed application. Major advantages: client performance, server scalability, offline client operation (to some extent), optimal use of bandwidth, smaller local cache. </paragraph>
<paragraph id="P-0633" lvl="2"><number>&lsqb;0633&rsqb;</number> 3. Multicast: Using multicasting (or selective broadcasting) considerably reduces peer-to-peer communication. For every cache request there is only one packet on the network and for every cache response there is potentially only one packet on the network in some configurations. This definitely helps reduce network congestion. Major advantages: client performance, server scalability, client only implementation, offline client operation, optimal use of bandwidth </paragraph>
<paragraph id="P-0634" lvl="2"><number>&lsqb;0634&rsqb;</number> 4. Packet Protocol: Because only datagram packets are used to request or respond to cache pages this saves the overhead of opening stream-based connections such as a TCP connection or an HTTP connection. Major advantages: client performance, client only implementation, offline client operation, and optimal use of bandwidth. </paragraph>
<paragraph id="P-0635" lvl="2"><number>&lsqb;0635&rsqb;</number> 5. Concurrent Requesting: If concurrent or intelligently staggered requests through all three means are issued to request a single page, the client will be able to receive the page through the fastest means possible for that particular situation. Major advantages: client performance, server scalability, offline client operation, and optimal use of bandwidth </paragraph>
<paragraph id="P-0636" lvl="2"><number>&lsqb;0636&rsqb;</number> 6. Smart Requesting: An adaptive or &ldquo;smart&rdquo; algorithm can be used to further enhance the overall performance of the client-server system. In this algorithm, the client uses the data of how past requests were processed to &ldquo;tune&rdquo; new requests. For example, if the client&apos;s past requests were predominantly served by another client, i.e., Peer Caching worked, then for new page requests the client would first try to use Peer Caching, and wait some time before resorting to either Proxy Caching or direct server request. This wait time can again be calculated in an adaptive fashion. Major advantages: client performance, server scalability, client only implementation, offline client operation, and optimal use of bandwidth. </paragraph>
<paragraph id="P-0637" lvl="0"><number>&lsqb;0637&rsqb;</number> The concepts illustrated herein can be applied to many different problem areas. In all client-server implementations where a server is serving requests for static data, e.g., code pages of a streamed application or static HTML pages from a Website, the approaches taught herein can be applied to improve the overall client-server performance. Even if some of the protocols or configurations described in this document are not supported by the underlying network, it does not preclude the application of other ideas described herein that do not depend on such features. For example, if multicast (or selective broadcast) is not supported, ideas such as Concurrent Requesting or Smart Requesting can still be used with respect to multiple servers instead of the combination of a server, peer, and proxy. Also the use of words like Multicast does not restrict the application of these ideas to multicast based protocols. These ideas can be used in all those cases where a multicast like mechanism, ie., selective broadcasting is available. Also note that the description of these ideas in the context of LAN or intranet environment does not restrict their application to such environments. The ideas described here are applicable to any environment where peers and proxies, because of their network proximity, offer significant performance advantages by using Peer Caching or Proxy Caching over a simple client-server network communication. In that respect, the term LAN or local area network should be understood to mean more generally as a collection of nodes that can communicate with each other faster than with a node outside of that collection. No geographical or physical locality is implied in the use of the term local area network or LAN. </paragraph>
</section>
<section>
<heading lvl="1">Peer Caching </heading>
<paragraph id="P-0638" lvl="0"><number>&lsqb;0638&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 33</cross-reference>, how multiple peers collaborate in caching pages that are required by some or all of them is shown. </paragraph>
<paragraph id="P-0639" lvl="0"><number>&lsqb;0639&rsqb;</number> The main elements shown are: </paragraph>
<paragraph id="P-0640" lvl="2"><number>&lsqb;0640&rsqb;</number> Client <highlight><bold>1</bold></highlight> <highlight><bold>3301</bold></highlight> through Client <highlight><bold>6</bold></highlight> <highlight><bold>3306</bold></highlight> in an Ethernet LAN <highlight><bold>3310</bold></highlight>. </paragraph>
<paragraph id="P-0641" lvl="2"><number>&lsqb;0641&rsqb;</number> Router <highlight><bold>1</bold></highlight> and the local proxy serving as the Internet gateway <highlight><bold>3307</bold></highlight>. Note that it does not matter whether Router <highlight><bold>1</bold></highlight> and the proxy are one computer or two different ones. </paragraph>
<paragraph id="P-0642" lvl="2"><number>&lsqb;0642&rsqb;</number> Other routers from router <highlight><bold>2</bold></highlight> through router N <highlight><bold>3308</bold></highlight> that are needed to connect the LAN <highlight><bold>3310</bold></highlight> to the Internet <highlight><bold>3311</bold></highlight>. </paragraph>
<paragraph id="P-0643" lvl="2"><number>&lsqb;0643&rsqb;</number> A remote server <highlight><bold>3309</bold></highlight> (that is reachable only by going over the Internet <highlight><bold>3311</bold></highlight>) that is serving the pages that the above mentioned clients need. </paragraph>
<paragraph id="P-0644" lvl="2"><number>&lsqb;0644&rsqb;</number> A cloud that symbolizes the complexity of the Internet <highlight><bold>3311</bold></highlight> and potentially long paths taken by packets. </paragraph>
<paragraph id="P-0645" lvl="0"><number>&lsqb;0645&rsqb;</number> Client <highlight><bold>2</bold></highlight> <highlight><bold>3302</bold></highlight> needs a page that it does not find in its local cache. It then decides to use the mechanism of Peer Caching before attempting to get the page from the local proxy (or the actual server through the proxy). The actual sequence of events is as follows: </paragraph>
<paragraph id="P-0646" lvl="2"><number>&lsqb;0646&rsqb;</number> 1. Client <highlight><bold>2</bold></highlight> <highlight><bold>3302</bold></highlight> sends a request for the page it needs. This request is sent as a multicast packet to a predetermined multicast address and port combination. Lets call this multicast address and port combination as M. </paragraph>
<paragraph id="P-0647" lvl="2"><number>&lsqb;0647&rsqb;</number> 2. The multicast packet is received by all the clients that have joined the group M. In this case all six clients have joined the group M. </paragraph>
<paragraph id="P-0648" lvl="2"><number>&lsqb;0648&rsqb;</number> 3. Client <highlight><bold>5</bold></highlight> <highlight><bold>3305</bold></highlight> receives the request and it records the sender&apos;s, i.e., Client <highlight><bold>2</bold></highlight>&apos;s <highlight><bold>3302</bold></highlight>, address and port combination. Let&apos;s assume this address and port combination is A. Client <highlight><bold>5</bold></highlight> <highlight><bold>3305</bold></highlight> processes the request and looks up the requested page in its own cache. It finds the page. </paragraph>
<paragraph id="P-0649" lvl="2"><number>&lsqb;0649&rsqb;</number> 4. Client <highlight><bold>5</bold></highlight> <highlight><bold>3305</bold></highlight> sends the page to address A (which belongs to Client <highlight><bold>2</bold></highlight> <highlight><bold>3302</bold></highlight>) as a packet. </paragraph>
<paragraph id="P-0650" lvl="2"><number>&lsqb;0650&rsqb;</number> 5. Client <highlight><bold>2</bold></highlight> <highlight><bold>3302</bold></highlight> receives the page it needs and hence does not need to request the server for the page. </paragraph>
</section>
<section>
<heading lvl="1">Proxy Caching </heading>
<paragraph id="P-0651" lvl="0"><number>&lsqb;0651&rsqb;</number> With respect to <cross-reference target="DRAWINGS">FIG. 43, a</cross-reference> transparent proxy and how clients use it to get pages is shown. Again the elements here are the same as in the previous figure: </paragraph>
<paragraph id="P-0652" lvl="2"><number>&lsqb;0652&rsqb;</number> Client <highlight><bold>1</bold></highlight> <highlight><bold>3401</bold></highlight> through Client <highlight><bold>6</bold></highlight> <highlight><bold>3406</bold></highlight> in an Ethernet LAN <highlight><bold>3410</bold></highlight>. </paragraph>
<paragraph id="P-0653" lvl="2"><number>&lsqb;0653&rsqb;</number> Router <highlight><bold>1</bold></highlight> and the local proxy serving as the Internet gateway <highlight><bold>3407</bold></highlight>. Note that it does not matter whether Router <highlight><bold>1</bold></highlight> and the proxy are one computer or two different ones. </paragraph>
<paragraph id="P-0654" lvl="2"><number>&lsqb;0654&rsqb;</number> Other routers from router <highlight><bold>2</bold></highlight> through router N <highlight><bold>3408</bold></highlight> that are needed to connect the LAN <highlight><bold>3410</bold></highlight> to the Internet <highlight><bold>3411</bold></highlight>. </paragraph>
<paragraph id="P-0655" lvl="2"><number>&lsqb;0655&rsqb;</number> A remote server <highlight><bold>3409</bold></highlight> (that is reachable only by going over the Internet <highlight><bold>3411</bold></highlight>) that is serving the pages that the above mentioned clients need. </paragraph>
<paragraph id="P-0656" lvl="2"><number>&lsqb;0656&rsqb;</number> A cloud that symbolizes the complexity of the Internet <highlight><bold>3411</bold></highlight> and potentially long paths taken by packets. </paragraph>
<paragraph id="P-0657" lvl="0"><number>&lsqb;0657&rsqb;</number> Assume Peer Caching is either not enabled or did not work for this case. When Client <highlight><bold>2</bold></highlight> <highlight><bold>3402</bold></highlight> needs a page, it makes a request to the proxy <highlight><bold>3407</bold></highlight>. The proxy <highlight><bold>3407</bold></highlight> finds the page in its local cache and returns it to Client <highlight><bold>2</bold></highlight> <highlight><bold>3402</bold></highlight>. Because of this, the request did not go to the remote server <highlight><bold>3409</bold></highlight> over the Internet <highlight><bold>3411</bold></highlight>. </paragraph>
</section>
<section>
<heading lvl="1">Multicast and Packet Protocol within a LAN </heading>
<paragraph id="P-0658" lvl="0"><number>&lsqb;0658&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 35</cross-reference>, the role played by multicast and unicast packets in Peer Caching is shown. The example of the drawing &ldquo;Peer Caching&rdquo; is used to explain multicast. Here Client <highlight><bold>2</bold></highlight> <highlight><bold>3502</bold></highlight> has the IP address 10.0.0.2 and it opens port <highlight><bold>3002</bold></highlight> for sending and receiving packets. When Client <highlight><bold>2</bold></highlight> <highlight><bold>3502</bold></highlight> needs a page and wants to use Peer Caching to get it, it forms a request and sends it to the multicast address and port 239.0.0.1:2001. All the other clients in the LAN <highlight><bold>3508</bold></highlight> that support Peer Caching have already joined the group 239.0.0.1:2001 so they all receive this packet. </paragraph>
<paragraph id="P-0659" lvl="0"><number>&lsqb;0659&rsqb;</number> Client <highlight><bold>5</bold></highlight> <highlight><bold>3505</bold></highlight> receives this packet and it records the sender address (10.0.0.2:3002 in this case). It looks up the requested page and finds it in its local cache. It sends the page as a response packet to the address 10.0.0.2:3002. </paragraph>
<paragraph id="P-0660" lvl="0"><number>&lsqb;0660&rsqb;</number> Client <highlight><bold>2</bold></highlight> <highlight><bold>3502</bold></highlight> receives this response packet since it was waiting at this port after sending the original multicast request. After ensuring the validity of the response, it retrieves the page it needs. </paragraph>
<paragraph id="P-0661" lvl="0"><number>&lsqb;0661&rsqb;</number> Note that more than one client can respond to the original multicast request. However Client <highlight><bold>2</bold></highlight> <highlight><bold>3502</bold></highlight> can discard all the later responses, since it has already received the page it needed. </paragraph>
</section>
<section>
<heading lvl="1">Concurrent Requesting&mdash;Proxy First </heading>
<paragraph id="P-0662" lvl="0"><number>&lsqb;0662&rsqb;</number> With respect to <cross-reference target="DRAWINGS">FIG. 36</cross-reference>, one particular case of how Concurrent Requesting is used is shown. This is a timeline of events that take place in the client. When a client first needs a page, it does not know whether it is going to get any responses through Peer Caching or not. Hence it issues a request to the proxy (or the server through the proxy) as soon as it needs the page. Then it issues a request using the Peer Caching mechanism. If there is indeed a peer that can return the page requested, the peer presumably could return the page faster than the proxy or the server. If this happens, the client may decide to use Peer Caching mechanism before attempting to get the page from the proxy or the server. The timeline essentially describes the following sequence of events: </paragraph>
<paragraph id="P-0663" lvl="2"><number>&lsqb;0663&rsqb;</number> 1. At time t&equals;0, a page p is needed by the client <highlight><bold>3601</bold></highlight>. </paragraph>
<paragraph id="P-0664" lvl="2"><number>&lsqb;0664&rsqb;</number> 2. The client looks up its local cache, and it doesn&apos;t find page p. </paragraph>
<paragraph id="P-0665" lvl="2"><number>&lsqb;0665&rsqb;</number> 3. At time t&equals;T<highlight><bold>1</bold></highlight>, it decides to send a request to the proxy to get the page <highlight><bold>3602</bold></highlight>. </paragraph>
<paragraph id="P-0666" lvl="2"><number>&lsqb;0666&rsqb;</number> 4. After a delay of amount Dp <highlight><bold>3603</bold></highlight>, at time t&equals;T<highlight><bold>2</bold></highlight> it also sends a request for the page p through the mechanism of Peer Caching <highlight><bold>3604</bold></highlight>. Note that D<highlight><subscript>p </subscript></highlight><highlight><bold>3603</bold></highlight> can be zero, in which case T<highlight><bold>1</bold></highlight>&equals;T<highlight><bold>2</bold></highlight>. </paragraph>
<paragraph id="P-0667" lvl="2"><number>&lsqb;0667&rsqb;</number> 5. At time t&equals;T<highlight><bold>3</bold></highlight>, a response is received from another peer that contains the page p that this client needs <highlight><bold>3606</bold></highlight>. Thus the response time of the Peer Caching mechanism is R<highlight><subscript>p</subscript></highlight>&equals;T<highlight><bold>3</bold></highlight>&minus;T<highlight><bold>2</bold></highlight> <highlight><bold>3605</bold></highlight>. </paragraph>
<paragraph id="P-0668" lvl="2"><number>&lsqb;0668&rsqb;</number> 6. At time t&equals;T<highlight><bold>4</bold></highlight>, a response from the proxy/server is received that contains the page p <highlight><bold>3608</bold></highlight>. Hence the response time of the proxy/server is R<highlight><subscript>s</subscript></highlight>&equals;T<highlight><bold>4</bold></highlight>&minus;T<highlight><bold>1</bold></highlight> <highlight><bold>3607</bold></highlight>. </paragraph>
<paragraph id="P-0669" lvl="0"><number>&lsqb;0669&rsqb;</number> Note that since, R<highlight><subscript>p</subscript></highlight>&lt;R<highlight><subscript>s</subscript></highlight>, the client will increase the weighting for Peer Caching in all of its future queries. That means it will decrease D<highlight><subscript>p</subscript></highlight>, and if D<highlight><subscript>p </subscript></highlight>is already zero, it will increase D<highlight><subscript>s </subscript></highlight>(the delay before requesting proxy/server). On the other hand, if R<highlight><subscript>p</subscript></highlight>&gt;R<highlight><subscript>s </subscript></highlight>or if R<highlight><subscript>p </subscript></highlight>were infinity, it will increase its weighting for proxy/server requesting. This is part of Smart Requesting that is explained elsewhere in this document. </paragraph>
</section>
<section>
<heading lvl="1">Concurrent Requesting&mdash;Peer Caching First </heading>
<paragraph id="P-0670" lvl="0"><number>&lsqb;0670&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 37</cross-reference>, in contrast to the previous figure, the client has decided to use Peer Caching before requesting the proxy. So the sequence of events is as follows: </paragraph>
<paragraph id="P-0671" lvl="2"><number>&lsqb;0671&rsqb;</number> 1. At time t&equals;0, a page p is needed by the client <highlight><bold>3701</bold></highlight>. </paragraph>
<paragraph id="P-0672" lvl="2"><number>&lsqb;0672&rsqb;</number> 2. The client looks up its local cache, and it doesn&apos;t find page p. </paragraph>
<paragraph id="P-0673" lvl="2"><number>&lsqb;0673&rsqb;</number> 3. At time t&equals;T<highlight><bold>5</bold></highlight>, it decides to send a request for the page p through the mechanism of Peer Caching <highlight><bold>3702</bold></highlight>. </paragraph>
<paragraph id="P-0674" lvl="2"><number>&lsqb;0674&rsqb;</number> 4. After a delay of amount D<highlight><subscript>s </subscript></highlight><highlight><bold>3703</bold></highlight>, at time t&equals;T<highlight><bold>6</bold></highlight> it also sends a request for the page p to the proxy/server. Note that D<highlight><subscript>s </subscript></highlight>can be zero, in which case T<highlight><bold>5</bold></highlight>&equals;T<highlight><bold>6</bold></highlight>. </paragraph>
<paragraph id="P-0675" lvl="2"><number>&lsqb;0675&rsqb;</number> 5. At time t&equals;T<highlight><bold>7</bold></highlight>, a response is received from another peer that contains the page p that this client needs <highlight><bold>3706</bold></highlight>. Thus the response time of the Peer Caching mechanism is R<highlight><subscript>p</subscript></highlight>&equals;T<highlight><bold>7</bold></highlight>&minus;T<highlight><bold>5</bold></highlight> <highlight><bold>3705</bold></highlight>. </paragraph>
<paragraph id="P-0676" lvl="2"><number>&lsqb;0676&rsqb;</number> 6. At time t&equals;T<highlight><bold>8</bold></highlight>, a response from the proxy/server is received that contains the page p <highlight><bold>3708</bold></highlight>. Hence the response time of the proxy/server is R<highlight><subscript>s</subscript></highlight>&equals;T<highlight><bold>8</bold></highlight>&minus;T<highlight><bold>6</bold></highlight> <highlight><bold>3707</bold></highlight>. </paragraph>
<paragraph id="P-0677" lvl="0"><number>&lsqb;0677&rsqb;</number> As described in the previous drawing, the client increases the weighting of Peer Caching even more because it got a response through Peer Caching long before it got a response from the proxy/server. As a result of the increases weighting the delay D<highlight><subscript>s </subscript></highlight>is increased even more. </paragraph>
</section>
<section>
<heading lvl="1">Concurrent Requesting&mdash;Peer Caching Only </heading>
<paragraph id="P-0678" lvl="0"><number>&lsqb;0678&rsqb;</number> With respect to <cross-reference target="DRAWINGS">FIG. 38</cross-reference>, in contrast with <cross-reference target="DRAWINGS">FIG. 37</cross-reference>, the client has increased D<highlight><subscript>s </subscript></highlight><highlight><bold>3805</bold></highlight> (the delay before requesting a proxy/server) so much, that if a page is received before the expiry of the delay D<highlight><subscript>s </subscript></highlight><highlight><bold>3805</bold></highlight>, the client does not even make a request to the proxy/server. The shaded area <highlight><bold>3806</bold></highlight> shows the events that do not take place because of this. </paragraph>
</section>
<section>
<heading lvl="1">Client-Server System with Peer and Proxy Caching </heading>
<paragraph id="P-0679" lvl="0"><number>&lsqb;0679&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 39, a</cross-reference> system level drawing that gives a system context for all the other figures and discussion in this document is shown. This drawing illustrates all three ways in which a client gets its page requests fulfilled. </paragraph>
<paragraph id="P-0680" lvl="7"><number>&lsqb;0680&rsqb;</number> Note that: </paragraph>
<paragraph id="P-0681" lvl="2"><number>&lsqb;0681&rsqb;</number> Client <highlight><bold>2</bold></highlight> <highlight><bold>3902</bold></highlight> gets its page request fulfilled through Peer Caching, i.e., multicast request. </paragraph>
<paragraph id="P-0682" lvl="2"><number>&lsqb;0682&rsqb;</number> Client <highlight><bold>1</bold></highlight> <highlight><bold>3901</bold></highlight> gets its page request fulfilled through Proxy Caching, i.e., the proxy <highlight><bold>3907</bold></highlight> finds the page in its cache and returns it. </paragraph>
<paragraph id="P-0683" lvl="2"><number>&lsqb;0683&rsqb;</number> Client <highlight><bold>3</bold></highlight> <highlight><bold>3903</bold></highlight> has to go to the server <highlight><bold>3909</bold></highlight> over the Internet <highlight><bold>3908</bold></highlight> to get its page request fulfilled. </paragraph>
</section>
<section>
<heading lvl="1">Collaborative Caching Details </heading>
<paragraph id="P-0684" lvl="0"><number>&lsqb;0684&rsqb;</number> In a typical client-server model, caching could be used to improve the performance of clients and scalability of servers. This caching could be: </paragraph>
<paragraph id="P-0685" lvl="2"><number>&lsqb;0685&rsqb;</number> Local to the client where the client itself locally stores the pages it had received from the server in the past. Then the client would not need to request the proxy/server for any page that resides in the local cache as long as the locally cached page is &ldquo;valid&rdquo; from the server point of view. </paragraph>
<paragraph id="P-0686" lvl="2"><number>&lsqb;0686&rsqb;</number> On a proxy node that can be any node along the path taken by a packet that goes from the client to the server. The closer this proxy node is to the client the more improvement in the performance you get. </paragraph>
<paragraph id="P-0687" lvl="2"><number>&lsqb;0687&rsqb;</number> On a peer node, that is on another client. In this case, the two clients (the requesting client as well as the serving client) are on the same LAN or intranet, so that the travel time of a packet between the two nodes is considerably smaller as compared to the travel time of the packet from one of the clients to the server. </paragraph>
<paragraph id="P-0688" lvl="0"><number>&lsqb;0688&rsqb;</number> As far as caching is concerned, this section details the new ideas of Peer Caching and Proxy Caching. In addition, it also details the new ideas of Concurrent Requesting and Smart Requesting. The preferred approaches for implementing these ideas are also described here and these are Multicast and Packet Protocol. </paragraph>
<paragraph id="P-0689" lvl="0"><number>&lsqb;0689&rsqb;</number> The idea of Peer Caching is nothing but a client X taking advantage of the fact that a peer, e.g., say another client Y, on its LAN had, in the past, requested a page that X is going to request from its server. If the peer Y has that page cached locally on its machine, then X could theoretically get it much faster from Y than getting it from the server itself. If an efficient mechanism is provided for the two clients X and Y to collaborate on this kind of cache access, then that will offer many advantages such as: Client Performance, Server Scalability, Client Only Implementation, Offline Client Operation, Optimal Use of Bandwidth, Smaller Local Cache. Note that two clients were considered only as an example, the idea of Peer Caching is applicable to any number of peers on a LAN. </paragraph>
<paragraph id="P-0690" lvl="0"><number>&lsqb;0690&rsqb;</number> The idea of Multicast is to use the multicast protocol in the client making a Peer Caching request. Multicast can be briefly described as &ldquo;selective broadcasting&rdquo;&mdash;similar to radio. A radio transmitter transmits &ldquo;information&rdquo; on a chosen frequency, and any receiver (reachable by the transmitter, of course) can receive that information by tuning to that frequency. In the realm of multicast, the equivalent of a radio frequency is a multicast or class D IP address and port. Any node on the net can send datagram packets to a multicast IP address&plus;port. Another node on the net can &ldquo;join&rdquo; that IP address&plus;port (which is analogous to tuning to a radio frequency), and receive those packets. That node can also &ldquo;leave&rdquo; the IP address&plus;port and thereby stop receiving multicast packets on that IP address&plus;port. </paragraph>
<paragraph id="P-0691" lvl="0"><number>&lsqb;0691&rsqb;</number> Note that multicast is based on IP (Internet Protocol) and is vendor neutral. Also, it is typically available on the Ethernet LAN and, if routers supported it, it can also go beyond the LAN. If all the routers involved in a node&apos;s connection to the Internet backbone supported multicast routing, multicast packets theoretically could go to the whole Internet except the parts of the Internet that do not support multicast routing. </paragraph>
<paragraph id="P-0692" lvl="0"><number>&lsqb;0692&rsqb;</number> The use of multicast allows a client to not have to maintain a directory of peers that can serve its page requests. Also because of multicast there is only one packet per page request. Any peer that receives the request could potentially serve that request, so by using a multicast based request there are multiple potential servers created for a page request but only one physical packet on the network. This contributes substantially in reducing network bandwidth, but at the same time increasing peer accessibility to all the peers. When implemented properly, the packet traffic due to Peer Caching will be proportional to the number of clients on the network participating in Peer Caching. </paragraph>
<paragraph id="P-0693" lvl="0"><number>&lsqb;0693&rsqb;</number> An idea related to Multicast is Packet Protocol. Note that Multicast itself is a packet-based protocol as opposed to connection based. The idea of Peer Caching here is described using Multicast and Packet Protocol. The Peer Caching request is sent as a multicast request and the response from a peer to such a request is also sent as a packet (not necessarily a multicast packet). Sending packets is much faster than sending data through a connection-based protocol such as TCP/IP, although using packet-based protocol is not as reliable as using connection-based one. The lack of reliability in Packet Protocol is acceptable since Peer Caching is used only to improve overall performance of the Client-Server system rather than as a primary mechanism for a client to get its pages. The underlying assumption made here is that a client could always get its pages from the server, if Peer Caching or Proxy Caching does not work for any reason. </paragraph>
<paragraph id="P-0694" lvl="0"><number>&lsqb;0694&rsqb;</number> The ideas of Concurrent Requesting and Smart Requesting describe how Peer Caching, Proxy Caching and client-server access could be combined in an intelligent fashion to achieve optimal performance of the whole Client-Server system. As part of Concurrent Requesting, a client is always prepared to make concurrent requests to get the page it needs in the fastest way possible. Concurrent Requesting would require the use of objects such as threads or processes that would allow one to programmatically implement Concurrent Programming. This document assumes the use of threads to describe a possible and preferred way to implement Concurrent Requesting. </paragraph>
<paragraph id="P-0695" lvl="0"><number>&lsqb;0695&rsqb;</number> The idea of Smart Requesting includes using an adaptive algorithm to intelligently stagger or schedule requests so that a client, even while using Concurrent Requesting, would not unnecessarily attempt to get a page through more than one means. An example of this is when a client has consistently gotten its page requests fulfilled through Peer Caching in the past. It would come to depend on Peer Caching for future page requests more than the other possible means. On the other hand, if Peer Caching has not worked for that client for some time, it would schedule a proxy request before a Peer Caching request. Smart Requesting involves dynamically calculating the delays D<highlight><subscript>p </subscript></highlight>and D<highlight><subscript>s </subscript></highlight>based how well Peer Caching and Proxy Caching has worked for the client. Please see <cross-reference target="DRAWINGS">FIGS. 36 through 38</cross-reference>. </paragraph>
<paragraph id="P-0696" lvl="0"><number>&lsqb;0696&rsqb;</number> The following is an algorithmic description using pseudo-code of an illustrative embodiment. </paragraph>
<paragraph id="P-0697" lvl="0"><number>&lsqb;0697&rsqb;</number> startOurClient is a function that is invoked initially when the client is started.  
<table-cwu id="TABLE-US-00001">
<number>1</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
</section>
<section>
<heading lvl="1">requestProxy function </heading>
<paragraph id="P-0698" lvl="0"><number>&lsqb;0698&rsqb;</number> The function requestProxy sends a page request to the proxy and starts a thread that waits for the page response (or times out). The function proxyResponse is the thread function that waits for the response based on the arguments passed to it.  
<table-cwu id="TABLE-US-00002">
<number>2</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>void requestProxy(pageId) &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="7PT" align="left"/>
<colspec colname="1" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Send a page request for pageId to a predefined proxy/server as per</entry>
</row>
<row>
<entry></entry>
<entry>the proxy/server protocol;</entry>
</row>
<row>
<entry></entry>
<entry>Start a thread with the thread function proxyResponse that waits for</entry>
</row>
<row>
<entry></entry>
<entry>the response to the request - the function proxyResponse is passed</entry>
</row>
<row>
<entry></entry>
<entry>arguments: the socket X where it should wait and pageId.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>&rcub;</entry>
</row>
<row>
<entry>void proxyResponse(socket X, pageId) &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="7PT" align="left"/>
<colspec colname="1" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Wait at the socket X for a response with a timeout of time TY;</entry>
</row>
<row>
<entry></entry>
<entry>If a response was received at socket X &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Uncompress the packet if necessary;</entry>
</row>
<row>
<entry></entry>
<entry>Validate the packet and ensure that this is a</entry>
</row>
<row>
<entry></entry>
<entry>valid response to the request and has the page requested (i.e.,</entry>
</row>
<row>
<entry></entry>
<entry>match the pageId);</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="7PT" align="left"/>
<colspec colname="1" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>else &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>// this is time out: didn&apos;t receive any</entry>
</row>
<row>
<entry></entry>
<entry>// response in time TY</entry>
</row>
<row>
<entry></entry>
<entry>Set appropriate indicator to indicate time-out;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="7PT" align="left"/>
<colspec colname="1" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>Signal an event to signify completion of this thread;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>&rcub;</entry>
</row>
<row>
<entry>requestPeer and peerResponse functions</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0699" lvl="0"><number>&lsqb;0699&rsqb;</number> The function requestPeer is similar to requestProxy except that it sends a page request to peers and starts a thread that waits for the page response (or times out). The function peerResponse is the thread function that waits for the response based on the arguments passed to it. </paragraph>
<paragraph id="P-0700" lvl="1"><number>&lsqb;0700&rsqb;</number> Void requestPeer(pageId) &lcub;</paragraph>
<paragraph id="P-0701" lvl="2"><number>&lsqb;0701&rsqb;</number> Create a UDP socket X bound to port <highlight><bold>3002</bold></highlight>; </paragraph>
<paragraph id="P-0702" lvl="1"><number>&lsqb;0702&rsqb;</number> &emsp;Compose a packet that consists of: </paragraph>
<paragraph id="P-0703" lvl="3"><number>&lsqb;0703&rsqb;</number> a code indicating that this is a request for a page </paragraph>
<paragraph id="P-0704" lvl="3"><number>&lsqb;0704&rsqb;</number> Some kind of an identifier that uniquely identifies the page wanted such as the URL </paragraph>
<paragraph id="P-0705" lvl="3"><number>&lsqb;0705&rsqb;</number> other info such as security information or access validators </paragraph>
<paragraph id="P-0706" lvl="2"><number>&lsqb;0706&rsqb;</number> Send this packet as a multicast packet to 239.0.0.1:2001 through the socket X created above; </paragraph>
<paragraph id="P-0707" lvl="2"><number>&lsqb;0707&rsqb;</number> Create a thread with the thread function peerResponse and pass socket X and pageId as arguments to it;  
<table-cwu id="TABLE-US-00003">
<number>3</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>&rcub;</entry>
</row>
<row>
<entry>Void peerResponse(socket X, pageId) &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="7PT" align="left"/>
<colspec colname="1" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Wait at the socket X for a response with a timeout of time TX;</entry>
</row>
<row>
<entry></entry>
<entry>If a packet was received at socket X &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Uncompress the packet if necessary;</entry>
</row>
<row>
<entry></entry>
<entry>Validate the packet and ensure that this is a</entry>
</row>
<row>
<entry></entry>
<entry>valid response to the request and has the page requested (i.e.,</entry>
</row>
<row>
<entry></entry>
<entry>match the pageId);</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="7PT" align="left"/>
<colspec colname="1" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>else &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>// this is time out: didn&apos;t receive any</entry>
</row>
<row>
<entry></entry>
<entry>// response in time TX</entry>
</row>
<row>
<entry></entry>
<entry>Set appropriate indicator to indicate time-out;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="7PT" align="left"/>
<colspec colname="1" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>Signal an event to signify completion of this thread;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>&rcub;</entry>
</row>
<row>
<entry>peerServer function</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0708" lvl="0"><number>&lsqb;0708&rsqb;</number> The function peerServer described below serves page requests received through Peer Caching as multicast packets. The function below describes how this thread would work:  
<table-cwu id="TABLE-US-00004">
<number>4</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>void peerServer() &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="7PT" align="left"/>
<colspec colname="1" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Create a multicast socket M bound to port 2001;</entry>
</row>
<row>
<entry></entry>
<entry>Have M &ldquo;join&rdquo; the IP address 239.0.0.1;</entry>
</row>
<row>
<entry></entry>
<entry>while (not asked to terminate) &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Wait at M for a multicast packet;</entry>
</row>
<row>
<entry></entry>
<entry>If a packet is received then &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="7PT" align="left"/>
<colspec colname="1" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Store the source IP addr in S along with the source port number in B;</entry>
</row>
<row>
<entry></entry>
<entry>Validate the packet that it is a valid request for a page that can be</entry>
</row>
<row>
<entry></entry>
<entry>served (with valid security credentials);</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="196PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Look up the page id in the local client cache;</entry>
</row>
<row>
<entry></entry>
<entry>If the page is found &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Compose a packet that contains the pageId of the</entry>
</row>
<row>
<entry></entry>
<entry>page as well as the page contents to send;</entry>
</row>
<row>
<entry></entry>
<entry>Optionally compress the packet before sending;</entry>
</row>
<row>
<entry></entry>
<entry>Send this packet to the IP address S at port B;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="196PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="7PT" align="left"/>
<colspec colname="1" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>&rcub;</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
</section>
<section>
<heading lvl="1">Piracy Prevention for Streamed Applications </heading>
</section>
<section>
<heading lvl="1">Summary </heading>
<paragraph id="P-0709" lvl="0"><number>&lsqb;0709&rsqb;</number> The details presented in this section describe new techniques of the invention that have been developed to combat software piracy of applications provided over networks, in situations where an ASP&apos;s clients&apos; machines execute the software applications locally. The remote ASP server must make all the files that constitute an application available to any subscribed user, because it cannot predict with complete accuracy which files are needed at what point in time. Nor is there a reliable and secure method by which the server can be aware of certain information local to the client computer that could be useful at stopping piracy. The process may be a rogue process intent on pirating the data, or it may be a secure process run from an executable provided by the ASP. </paragraph>
</section>
<section>
<heading lvl="1">Aspects of the Invention </heading>
<paragraph id="P-0710" lvl="2"><number>&lsqb;0710&rsqb;</number> 1. Client-side fine-grained filtering of file accesses directed at remotely served files, for anti-piracy purposes. Traditional network filesystems permit or deny file access at the server side, not the client side. Here, the server provides blanket access to a given user to all the files that the user may need during the execution of an application, and makes more intelligent decisions about which accesses to permit or deny. </paragraph>
<paragraph id="P-0711" lvl="2"><number>&lsqb;0711&rsqb;</number> 2. Filtering of file accesses based on where the code for the process that originated the request is stored. Traditional file systems permit or deny file access usually based on the credentials of a user account or process token, not on where the code for the process resides. Here, a filesystem may want to take into account whether the code for the originating process resides in secure remote location or an insecure local location. </paragraph>
<paragraph id="P-0712" lvl="2"><number>&lsqb;0712&rsqb;</number> 3. Identification of crucial portions of served files and filtering file accesses depending on the portion targeted. The smallest level of granularity that traditional file systems can operate on is at the level of files, not at the level of the sections contained in the files (for example, whether or not data from a code section or a resource section is requested). </paragraph>
<paragraph id="P-0713" lvl="2"><number>&lsqb;0713&rsqb;</number> 4. Filtering of file accesses based on the surmised purpose of the file access, as determined by examining the program stack or flags associated with the request. Traditional file systems do not attempt to determine why a file access was issued before permitting or denying the access, e.g., whether the purpose is to copy the data or page in the data as code for execution. </paragraph>
<paragraph id="P-0714" lvl="2"><number>&lsqb;0714&rsqb;</number> 5. Filtering of file accesses based on the surmised purpose of the file access, as determined by examining a history of previous file accesses by the same process. Traditional file systems do not keep around histories of which blocks a given requestor had previously requested from a file. This history can be useful in seeing if the requests match a pattern that suggests a file copy is occurring as opposed to code execution. </paragraph>
</section>
<section>
<heading lvl="1">Benefits of the Anti-Piracy Features of the Present Invention </heading>
<paragraph id="P-0715" lvl="0"><number>&lsqb;0715&rsqb;</number> This is an enabler technology that allows a programmer to build security into a certain type of application delivery system that would otherwise not be possible. Several companies are developing technology that allows an application to be served remotely, but executed locally. Current filesystems provide no way to protect the files that make up this application from being copied and thus pirated. The above techniques are tools that enable a filesystem to allow just those requests that will let the application run normally and block those that are the result of attempts to pirate the application&apos;s code or data. This provides a competitive advantage to those software providers who use this technology, because piracy results in lost revenue and, by preventing this, piracy they can prevent this loss. </paragraph>
<paragraph id="P-0716" lvl="0"><number>&lsqb;0716&rsqb;</number> The techniques described herein were developed for the purpose of preventing the piracy of computer software programs that are served from a remote server, but executed on a local client. However, they can be used by any computer software security solution that would benefit from the ability to filter file accesses with more flexibility than currently provided by most filesystems. </paragraph>
<paragraph id="P-0717" lvl="0"><number>&lsqb;0717&rsqb;</number> When a filesystem receives a request, it must decide whether or not the request should be granted or denied for security reasons. If the target file is local, the filesystem makes the decision by itself, and if the target file is remote, it must ask the server to handle the request for it. The above techniques are ways in which the filesystem can gather more information about the request than it would ordinarily have. It can then use that information to improve the quality of its decisions. Traditional approaches, such as granting a currently logged-in user access to certain files and directories that are marked with his credentials, are not flexible enough for many situations. As for remote files, the server has only a limited amount of information about the client machine. The filesystem at the client side can make grant/deny decisions based on local information before ever asking the server, in order to provide a more intelligent layer of security. </paragraph>
<paragraph id="P-0718" lvl="0"><number>&lsqb;0718&rsqb;</number> For example, it may be desirable to allow the user to execute these files, but not copy them. It may be desirable to grant access to only certain processes run by the user, but not others, because it is judged that some processes to be more secure or well-behaved than others. And it may be desirable to allow the user to access only certain sections of these files and from only certain processes for certain periods of time. The above techniques are tools that are added to a filesystem to give it these abilities. </paragraph>
</section>
<section>
<heading lvl="1">Overview of the Anti-Piracy Features of the Present Invention </heading>
<paragraph id="P-0719" lvl="0"><number>&lsqb;0719&rsqb;</number> With respect to <cross-reference target="DRAWINGS">FIG. 40</cross-reference>, preventing piracy of remotely served, locally executed applications is shown. This figure illustrates the problem of software piracy in an application delivery system, and how it can be stopped using the techniques described in this section. The client computer <highlight><bold>4001</bold></highlight> is connected to a server <highlight><bold>4009</bold></highlight> run by an ASP <highlight><bold>4007</bold></highlight>. The server <highlight><bold>4009</bold></highlight> provides access to application files <highlight><bold>4008</bold></highlight>, out of which the application executable is run by the client <highlight><bold>4001</bold></highlight> locally on his machine. (This is Process &num;<highlight><bold>1</bold></highlight> <highlight><bold>4002</bold></highlight>). However, the user can attempt to access and copy the application files to local storage <highlight><bold>4009</bold></highlight> on his machine, and thus be able to run them without authorization or give them to another person. But since all requests directed at the remote files <highlight><bold>4006</bold></highlight> must first pass through the local network filesystem, this filesystem can be enhanced <highlight><bold>4005</bold></highlight> to deny all such requests that it thinks are the result of an attempt at piracy. </paragraph>
<paragraph id="P-0720" lvl="0"><number>&lsqb;0720&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 41</cross-reference>, the filtering of accesses to remote application files, illustrating New Technique &num;<highlight><bold>1</bold></highlight>, as described above is shown. (Note: the client computer represented here and in all subsequent figures is part of the same client-server system as in <cross-reference target="DRAWINGS">FIG. 40</cross-reference>, but the server/ASP diagram has been omitted to save space.) A user <highlight><bold>4102</bold></highlight> who has been granted access to remotely served files <highlight><bold>4106</bold></highlight> representing an application is attempting to access these files. The local enhanced network filesystem <highlight><bold>4103</bold></highlight> is able to deny access to certain files <highlight><bold>4105</bold></highlight> and grant access to others <highlight><bold>4104</bold></highlight>, for the purpose of protecting critical parts of the application from piracy. </paragraph>
<paragraph id="P-0721" lvl="0"><number>&lsqb;0721&rsqb;</number> With respect to <cross-reference target="DRAWINGS">FIG. 42</cross-reference>, the filtering of accesses to remote files based on process code location, illustrating New Technique &num;<highlight><bold>2</bold></highlight>, as described above, is shown. Here there are two processes on the client computer. Process &num;<highlight><bold>1</bold></highlight> <highlight><bold>4202</bold></highlight> has been run from an executable file <highlight><bold>4206</bold></highlight> that is part of a remotely served application <highlight><bold>4207</bold></highlight>, and process &num;<highlight><bold>2</bold></highlight> <highlight><bold>4203</bold></highlight> has been run from a local executable file <highlight><bold>4204</bold></highlight>. They are both attempting to access a remote data file <highlight><bold>4206</bold></highlight> that is part of the served application <highlight><bold>4207</bold></highlight>. The local enhanced network filesystem <highlight><bold>4205</bold></highlight> is denying Process &num;<highlight><bold>2</bold></highlight> <highlight><bold>4203</bold></highlight> access and granting Process &num;<highlight><bold>1</bold></highlight> <highlight><bold>4202</bold></highlight> access because Process &num;<highlight><bold>2</bold></highlight>&apos;s <highlight><bold>4203</bold></highlight> executable is stored locally, and thus is not secure, while Process &num;<highlight><bold>1</bold></highlight>&apos;s <highlight><bold>4202</bold></highlight> executable is provided by the server <highlight><bold>4207</bold></highlight>, and thus can be vouched for. </paragraph>
<paragraph id="P-0722" lvl="0"><number>&lsqb;0722&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 43</cross-reference>, the filtering of accesses to remote files based on targeted file section, illustrating New Technique &num;<highlight><bold>3</bold></highlight>, as described above, is shown. Here there is a single local process <highlight><bold>4302</bold></highlight> that is attempting to read from a remotely served executable file <highlight><bold>4307</bold></highlight>. The enhanced network filesystem <highlight><bold>4304</bold></highlight> is denying an attempt to read from the code section <highlight><bold>4306</bold></highlight> of the file <highlight><bold>4307</bold></highlight> while granting an attempt to read from a non-code section <highlight><bold>4305</bold></highlight> of the file <highlight><bold>4307</bold></highlight>. This is useful when access to some part of the file must be allowed, but access to other parts should be denied to prevent piracy of the entire file. </paragraph>
<paragraph id="P-0723" lvl="0"><number>&lsqb;0723&rsqb;</number> With respect to <cross-reference target="DRAWINGS">FIG. 44</cross-reference>, the filtering of accesses to remote files based on surmised purpose, illustrating New Technique &num;<highlight><bold>4</bold></highlight> as described above, is shown. Here, two attempts to read from the code section <highlight><bold>4407</bold></highlight> of a remote executable file <highlight><bold>4408</bold></highlight> are being made from a process <highlight><bold>4402</bold></highlight> that was run from this file <highlight><bold>4408</bold></highlight>. However, one request is denied because it originated <highlight><bold>4406</bold></highlight> from the process&apos;s code <highlight><bold>4403</bold></highlight> itself, while another is approved because it originated from code in the Virtual Memory Subsystem <highlight><bold>4404</bold></highlight>. This prevents even a rogue remote process from attempting to pirate its own code, while allowing legitimate requests for the code to be completed. </paragraph>
<paragraph id="P-0724" lvl="0"><number>&lsqb;0724&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 45</cross-reference>, the filtering of accesses to remote files based on past access history. illustrating New Technique &num;<highlight><bold>5</bold></highlight> as described above, is shown. Here, two processes <highlight><bold>4502</bold></highlight>, <highlight><bold>4503</bold></highlight> run from a local executable <highlight><bold>4504</bold></highlight> are attempting to access a remote file <highlight><bold>4508</bold></highlight>. The enhanced network filesystem <highlight><bold>4507</bold></highlight> keeps around a history of previous file accesses by these processes <highlight><bold>4505</bold></highlight>, <highlight><bold>4506</bold></highlight>, which it consults to make decisions about permitting/denying further accesses. Process &num;<highlight><bold>1</bold></highlight>&apos;s <highlight><bold>4502</bold></highlight> access attempt is granted, while Process &num;<highlight><bold>2</bold></highlight>&apos;s <highlight><bold>4503</bold></highlight> is denied, because the filesystem <highlight><bold>4507</bold></highlight> detected a suspicious pattern in Process &num;<highlight><bold>2</bold></highlight>&apos;s <highlight><bold>4503</bold></highlight> previous access history <highlight><bold>4506</bold></highlight>. </paragraph>
</section>
<section>
<heading lvl="1">Anti-Piracy Details of the Invention </heading>
<paragraph id="P-0725" lvl="0"><number>&lsqb;0725&rsqb;</number> Five anti-piracy embodiments are disclosed below that can be used by an ASP-installed network filesystem to combat piracy of remotely served applications. The ASP installs a software component on the client that is able to take advantage of local knowledge, e.g., which process on the client originated a request for data, and permit or deny requests for remote files before sending the requests to the server. That is, a network filesystem is installed on the local user&apos;s computer that manages access to these remote files. All input/output requests to these files must pass through this filesystem, and if the filesystem determines that a given request is suspicious in some way, it has the freedom to deny it. </paragraph>
<paragraph id="P-0726" lvl="0"><number>&lsqb;0726&rsqb;</number> Anti-Piracy Embodiment &num;1: Client-side fine-grained filtering of file accesses directed at remotely served files, for anti-piracy purposes. </paragraph>
<paragraph id="P-0727" lvl="0"><number>&lsqb;0727&rsqb;</number> Referring again to <cross-reference target="DRAWINGS">FIG. 41</cross-reference>, the approach of the first anti-piracy embodiment is that a software component <highlight><bold>4102</bold></highlight> executing locally on a client computer <highlight><bold>4101</bold></highlight> has available to it much more information about the state of this computer than does a server providing access to remote files. Thus, the server can filter access only on a much coarser level that can this client component. An ASP can take advantage of this by installing a network filesystem <highlight><bold>4103</bold></highlight> on the client computer that is designated to handle and forward all requests directed at files located on a given remote server. This filesystem <highlight><bold>4103</bold></highlight> examines each request, and either grants or denies it depending on whether the request is justifiable from a security perspective. It can use information such as the nature of the originating process, the history of previous access by the process, the section of the targeted file being requested, and so on, in order to make its decision. </paragraph>
<paragraph id="P-0728" lvl="0"><number>&lsqb;0728&rsqb;</number> The best way known of implementing this approach is to write a network redirector filesystem component <highlight><bold>4103</bold></highlight> for the operating system that the ASP&apos;s clients&apos; machines will be running. This component will be installed, and will make visible to the system a path that represents the server on which the ASP&apos;s application files are stored. The local computer can now begin accessing these files, and the filesystem <highlight><bold>4103</bold></highlight> will be asked to handle requests for these files. On most operating systems, the filesystem <highlight><bold>4103</bold></highlight> will register dispatch routines to the system that handle common file operations such as open, read, write and close. When a local process <highlight><bold>4102</bold></highlight> makes a request of an ASP-served file, the OS calls one of these dispatch routines with the request. In the dispatch routine, the filesystem <highlight><bold>4103</bold></highlight> examines the request and decides whether to deny it or grant it. If granted, it will forward the request to the remote server and send back the response to the operating system. </paragraph>
<paragraph id="P-0729" lvl="0"><number>&lsqb;0729&rsqb;</number> Anti-Piracy Embodiment &num;2: Filtering of file accesses based on where the code for the process that originated the request is stored. </paragraph>
<paragraph id="P-0730" lvl="0"><number>&lsqb;0730&rsqb;</number> Referring again to <cross-reference target="DRAWINGS">FIG. 42</cross-reference>, when a filesystem <highlight><bold>4205</bold></highlight> receives a request for access to a given file, the request always originates from a given process on the computer. By determining where the executable file that the process was run from is located, the network filesystem <highlight><bold>4205</bold></highlight> can make a more informed decision about the security risk associated with granting the request. For example, if the executable file <highlight><bold>4204</bold></highlight> is located on the local computer <highlight><bold>4202</bold></highlight>, then it may contain any code whatsoever, code that may attempt to copy and store the contents of any remote files it can gain access to. The filesystem <highlight><bold>4205</bold></highlight> can reject requests from these processes as being too risky. However, if the executable file <highlight><bold>4206</bold></highlight> is being served by the ASP&apos;s remote server <highlight><bold>4207</bold></highlight>, then the process can assume to be well-behaved, since it is under the control of the ASP. The filesystem <highlight><bold>4205</bold></highlight> can grant accesses that come from these processes <highlight><bold>4202</bold></highlight> in confidence that the security risks are minimal. </paragraph>
<paragraph id="P-0731" lvl="0"><number>&lsqb;0731&rsqb;</number> The best way known of implementing this approach is to modify a network filesystem <highlight><bold>4205</bold></highlight> to determine the identity of the process that originated a relevant open, read, or write request for a remote file. On some OSes a unique process ID is embedded in the request, and on others, a system call can be made to get this ID. Then, this ID must be used to look up the pathname of the executable file from which the process was run. To do this, upon initialization the filesystem <highlight><bold>4205</bold></highlight> must have registered a callback that is invoked whenever a new process is created. When this callback is invoked, the pathname to the process executable and the new process ID are provided as arguments, data which the filesystem <highlight><bold>4205</bold></highlight> then stores in a data structure. This data structure is consulted while servicing a file request, in order to match the process ID that originated the request with the process&apos;s executable. Then the root of the pathname of that executable is extracted. </paragraph>
<paragraph id="P-0732" lvl="0"><number>&lsqb;0732&rsqb;</number> The root uniquely identifies the storage device or remote server that provides the file. If the root specifies an ASP server that is known to be secure, as opposed to a local storage device that is insecure, then the request can be safely granted. </paragraph>
<paragraph id="P-0733" lvl="0"><number>&lsqb;0733&rsqb;</number> Anti-Piracy Embodiment &num;3: Identification of crucial portions of served files and filtering file access depending on the portion targeted. </paragraph>
<paragraph id="P-0734" lvl="0"><number>&lsqb;0734&rsqb;</number> Referring again to <cross-reference target="DRAWINGS">FIG. 43, a</cross-reference> served application usually consists of many files. In order to steal the application, a pirate would have to copy at least those files that store the code for the application&apos;s primary executable, and perhaps other files as well. This leads to the conclusion that some files are more important that others, and that some portions of some files are most important of all. Ordinarily, the best solution would be to deny access to the primary executable file and its associated executables in its entirety, but this is not usually possible. In order to initially run the application, the filesystem <highlight><bold>4304</bold></highlight> must grant unrestricted access to some portions of the primary executable. In order to prevent piracy, the filesystem <highlight><bold>4304</bold></highlight> can grant access selectively to just those portions that are needed. Additionally, the running application <highlight><bold>4302</bold></highlight> itself does not usually need to read its own code section, but does need to read other sections for purposes such as resource loading. Therefore, additional security can be introduced by denying access to the code sections <highlight><bold>4306</bold></highlight> of ASP-served executables <highlight><bold>4307</bold></highlight> even to those executables themselves. </paragraph>
<paragraph id="P-0735" lvl="0"><number>&lsqb;0735&rsqb;</number> To implement this, modify a network filesystem&apos;s <highlight><bold>4304</bold></highlight> open file dispatch routine to detect when a remotely served executable <highlight><bold>4307</bold></highlight> is being opened. When this is detected, the executable file <highlight><bold>4307</bold></highlight> is examined to determine the offset and length of its code section <highlight><bold>4306</bold></highlight>, and this information is stored in a data structure. On most OSes, executable files contain headers from which this information can be easily read. In the read and write dispatch routines, the network filesystem <highlight><bold>4304</bold></highlight> checks if the request is for a remote executable <highlight><bold>4307</bold></highlight>, and if so, the offset and length of the code section <highlight><bold>4306</bold></highlight> of this executable <highlight><bold>4307</bold></highlight> is read from the data structure in which it was previously stored. Then the offset and length of the request are checked to see if they intersect the code section <highlight><bold>4306</bold></highlight> of this executable <highlight><bold>4307</bold></highlight>. If so, the request can be denied. </paragraph>
<paragraph id="P-0736" lvl="0"><number>&lsqb;0736&rsqb;</number> Anti-Piracy Embodiment &num;4: Filtering of file accesses based on the surmised purpose of the file access, as determined by examining the program stack or flags associated with the request. </paragraph>
<paragraph id="P-0737" lvl="0"><number>&lsqb;0737&rsqb;</number> Referring again to <cross-reference target="DRAWINGS">FIG. 44</cross-reference>, the approach of the fourth embodiment is that identical requests from the same process for a remotely served file can be distinguished based on the reason the request was issued. For example, on a computer with a virtual memory subsystem <highlight><bold>4404</bold></highlight>, the VMS&apos;s own code will be invoked to page in code for a process that attempts to execute code in pages that are not currently present. To do this, the VMS <highlight><bold>4404</bold></highlight> must issue a read request to the filesystem <highlight><bold>4405</bold></highlight> that handles the process&apos; <highlight><bold>4402</bold></highlight> executable file <highlight><bold>4408</bold></highlight>. Since this request is not for any ulterior purpose, such as piracy, and is necessary for the application to execute, the request should be granted. If the filesystem <highlight><bold>4405</bold></highlight> gets the originating process ID for such requests, the process whose code is being paged in will be known. However, this same process ID will also be returned for requests that originate as a result of an attempt by the process itself to read its own code (perhaps for the purpose of piracy). Many applications have loopholes that allow the user to execute a macro, for example, that reads and writes arbitrary files. If the filesystem <highlight><bold>4405</bold></highlight> simply filters requests based on process IDs, it will mistakenly allow users to pirate remotely served applications, as long as they can send the necessary reads and writes from within the remote application itself. </paragraph>
<paragraph id="P-0738" lvl="0"><number>&lsqb;0738&rsqb;</number> However, even if the process IDs are the same for two apparently identical requests, there are ways the filesystem <highlight><bold>4405</bold></highlight> can distinguish them. There are two ways to do this in a manner relevant to combating anti-piracy. The way to implement the first method is to have the filesystem <highlight><bold>4405</bold></highlight>, upon receiving a read request, check for the presence of the paging I/O flag that is supported by several operating systems. If this flag is not present, then the request did not come from the VMS <highlight><bold>4404</bold></highlight>, but from the process itself <highlight><bold>4403</bold></highlight>, and thus the request is risky and not apparently necessary for the application to run. If the flag is present though, the request almost certainly originated from the VMS <highlight><bold>4404</bold></highlight> for the purpose of reading in code to allow the process to execute. The request should be allowed. </paragraph>
<paragraph id="P-0739" lvl="0"><number>&lsqb;0739&rsqb;</number> Another way to make this same determination is to have the filesystem <highlight><bold>4405</bold></highlight> examine the program stack upon receiving a read request. In several operating systems, a process will attempt to execute code that resides in a virtual page regardless of whether the page is present or not. If the page is not present, a page fault occurs, and a structure is placed onto the stack that holds information about the processor&apos;s current state. Then the VMS <highlight><bold>4404</bold></highlight> gets control. The VMS <highlight><bold>4404</bold></highlight> then calls the read routine of the filesystem <highlight><bold>4405</bold></highlight> that handles the process&apos;s executable file to read this code into memory. The filesystem <highlight><bold>4405</bold></highlight> now reads backwards up the stack up to a certain point, searching for the presence of the structure that is placed on the stack as a result of a page fault. If such a structure is found, the execution pointer register stored in the structure is examined. If the pointer is a memory address within the boundary of the virtual memory page that is being paged in, then the filesystem <highlight><bold>4405</bold></highlight> knows the read request is legitimate. </paragraph>
<paragraph id="P-0740" lvl="0"><number>&lsqb;0740&rsqb;</number> Anti-Piracy Embodiment &num;5: Filtering of file accesses based on the surmised purpose of the file access, as determined by examining a history of previous file accesses by the same process. </paragraph>
<paragraph id="P-0741" lvl="0"><number>&lsqb;0741&rsqb;</number> Referring again to <cross-reference target="DRAWINGS">FIG. 45</cross-reference>, if one looks at the series of file requests that are typically made as a result of attempting to copy an executable file, as opposed to those made in the course of executing that file, one can see certain patterns. The copy pattern is usually a sequence of sequentially ordered read requests, while the execution pattern tends to jump around a lot (as the result of code branches into non-present pages). A filesystem can be enhanced to keep around a history of requests made by specific processes on remotely served files. Then, for every subsequent request to such a file, the history for the originating process can be examined to check for certain patterns. If a file-copy pattern is seen, then the pirate may be attempting to steal the file, and the request should be denied. If an execution type pattern is seen, then the user is simply trying to run the application, and the request should be granted. </paragraph>
<paragraph id="P-0742" lvl="0"><number>&lsqb;0742&rsqb;</number> To implement this, a filesystem <highlight><bold>4507</bold></highlight> tells the operating system, via an operating system call, upon initialization, to call it back whenever a new process is created. When it is called back, the filesystem <highlight><bold>4507</bold></highlight> creates a new data structure for the process that will store file access histories <highlight><bold>4505</bold></highlight>, <highlight><bold>4506</bold></highlight>. Then, in its read-file dispatch routines, the filesystem <highlight><bold>4507</bold></highlight> determines the process ID of the originating process, and examines the process&apos;s access history <highlight><bold>4505</bold></highlight>, <highlight><bold>4506</bold></highlight>. It only examines entries in that history <highlight><bold>4505</bold></highlight>, <highlight><bold>4506</bold></highlight> that refer to the file currently being requested. It will then run a heuristic algorithm that tries to determine if the pattern of accesses more closely resembles an attempted file copy than code execution. An effective algorithm is to simply see if the past n read requests to this file have been sequential, where n is some constant. If so, then the request is denied. If not, then the request is granted. In either case, an entry is made to the filesystem&apos;s process access history <highlight><bold>4505</bold></highlight>, <highlight><bold>4506</bold></highlight> that records the file name, offset, and length of the request made by that process to this file. </paragraph>
</section>
<section>
<heading lvl="1">Conclusion </heading>
<paragraph id="P-0743" lvl="0"><number>&lsqb;0743&rsqb;</number> Although the present invention has been described using particular illustrative embodiments, it will be understood that many variations in construction, arrangement and use are possible within the scope of this invention. Other embodiments may use different network protocols, different programming techniques, or different heuristics, in each component block of the invention. Specific examples of variations include: </paragraph>
<paragraph id="P-0744" lvl="2"><number>&lsqb;0744&rsqb;</number> The proxy used in Proxy Caching could be anywhere in the Internet along the network path between a Client and the Server; and </paragraph>
<paragraph id="P-0745" lvl="2"><number>&lsqb;0745&rsqb;</number> Concurrent Requesting and Smart Requesting can be implemented in hardware instead of software. </paragraph>
<paragraph id="P-0746" lvl="0"><number>&lsqb;0746&rsqb;</number> A number of insubstantial variations are possible in the implementation of anti-piracy features of the invention. For example, instead of modifying the filesystem proper to provide anti-piracy features, a network proxy component can be placed on the client computer to filter network requests made by a conventional local network filesystem. These requests generally correspond to requests for remote files made to the filesystem by a local process, and the type of filtering taught by the present invention can be performed on these requests. A filesystem filter component can also be written to implement these methods, instead of modifying the filesystem itself. </paragraph>
<paragraph id="P-0747" lvl="0"><number>&lsqb;0747&rsqb;</number> Although the invention is described herein with reference to the preferred embodiment, one skilled in the art will readily appreciate that other applications may be substituted for those set forth herein without departing from the spirit and scope of the present invention. Accordingly, the invention should only be limited by the claims included below. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A process for the optimized delivery of server-based streamed applications and data to a client and the management of said streamed applications on a server, comprising the steps of: 
<claim-text>providing application set storage means for persistently storing streamed application program sets on said server; </claim-text>
<claim-text>wherein said streamed application sets contain streamed application file pages; </claim-text>
<claim-text>wherein said streamed application file pages are read only; </claim-text>
<claim-text>providing means for receiving client requests for streamed application file pages; </claim-text>
<claim-text>providing validation means for validating whether a client has access privilege to a requested streamed application file page; </claim-text>
<claim-text>providing caching means for storing commonly accessed streamed application file pages in a cache; </claim-text>
<claim-text>wherein said requested streamed application file page is retrieved from said caching means if it is resident in said cache, otherwise said requested streamed application file page is retrieved from said application set storage means; </claim-text>
<claim-text>wherein clients request streamed application file pages using a unique set of numbers common among all servers that store the particular streamed application file pages; and </claim-text>
<claim-text>providing means for sending said requested streamed application file page to said client. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The process of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising the step of: 
<claim-text>providing compression means for compressing said requested streamed application file page before sending said requested streamed application file page to said client. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The process of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, wherein when a client requests multiple streamed application file pages, said server concatenates all of the requested pages and compresses the entire set at once before sending to said client. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The process of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, wherein said commonly accessed streamed application file pages are compressed before being stored in said cache. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The process of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein all of the streamed application file pages in the streamed application sets are compressed before being stored in said application set storage means. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The process of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising the step of: 
<claim-text>providing profiling means for profiling the access patterns of streamed application file pages. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The process of <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference>, wherein said access patterns are sent to said client to guide its prefetching of streamed application file pages. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The process of <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference>, wherein said access patterns are used by said server to pre-package and compress groups of streamed application file pages; and wherein a prepackaged group is sent to a client requesting pages within a set. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The process of <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference>, wherein said access patterns are used by said server to perform prefetching of streamed application file pages for pushing to clients. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The process of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising the step of: 
<claim-text>providing a license server; </claim-text>
<claim-text>wherein said validation means resides on said license server; and </claim-text>
<claim-text>wherein said validation means provides a client with an access token that contains information regarding access rights, the application that it applies to, and an expiration time. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The process of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, further comprising the steps of: 
<claim-text>providing token reception means on said server for receiving an access token from a client; </claim-text>
<claim-text>providing decryption means on said server for decrypting said access token; </claim-text>
<claim-text>providing means for validating the contents of said access token; and </claim-text>
<claim-text>granting access to a client with a valid access token. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The process of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein said decrypting means uses a secret key shared with said license server to decrypt an access token. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The process of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein said server maintains a list of recently approved access tokens and compares incoming access tokens with said list, and wherein incoming access tokens that match an entry on said list are approved without further processing. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The process of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein a client uses a persistent connection over the Internet with said server to make multiple requests from said server, and wherein said server closes persistent connections that have been idle for a predetermined period of time. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The process of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising the step of: 
<claim-text>assigning individual servers a specific set of streamed applications sets to serve to clients; and </claim-text>
<claim-text>wherein the servers across a network are asymmetrically assigned different sets of streamed application sets to improve overall server efficiency. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The process of <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference>, wherein said individual servers are dynamically assigned streamed application sets to match client accesses over time. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The process of <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference>, further comprising the step of: 
<claim-text>providing a central control server; </claim-text>
<claim-text>wherein said individual servers periodically send a summary of their file access patterns to said central control server; and </claim-text>
<claim-text>wherein said central control server reassigns individual servers according to the file access patterns. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The process of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein said server communicates with clients across the Internet. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. An apparatus for the optimized delivery of server-based streamed applications and data to a client and the management of said streamed applications on a server, comprising: 
<claim-text>application set storage means for persistently storing streamed application program sets on said server; </claim-text>
<claim-text>wherein said streamed application sets contain streamed application file pages; </claim-text>
<claim-text>wherein said streamed application file pages are read only; </claim-text>
<claim-text>means for receiving client requests for streamed application file pages; </claim-text>
<claim-text>validation means for validating whether a client has access privilege to a requested streamed application file page; </claim-text>
<claim-text>caching means for storing commonly accessed streamed application file pages in a cache; </claim-text>
<claim-text>wherein said requested streamed application file page is retrieved from said caching means if it is resident in said cache, otherwise said requested streamed application file page is retrieved from said application set storage means; </claim-text>
<claim-text>wherein clients request streamed application file pages using a unique set of numbers common among all servers that store the particular streamed application file pages; and </claim-text>
<claim-text>means for sending said requested streamed application file page to said client. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference>, further comprising: 
<claim-text>compression means for compressing said requested streamed application file page before sending said requested streamed application file page to said client. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 20</dependent-claim-reference>, wherein when a client requests multiple streamed application file pages, said server concatenates all of the requested pages and compresses the entire set at once before sending to said client. </claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 20</dependent-claim-reference>, wherein said commonly accessed streamed application file pages are compressed before being stored in said cache. </claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference>, wherein all of the streamed application file pages in the streamed application sets are compressed before being stored in said application set storage means. </claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference>, further comprising: 
<claim-text>profiling means for profiling the access patterns of streamed application file pages. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 24</dependent-claim-reference>, wherein said access patterns are sent to said client to guide its prefetching of streamed application file pages. </claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 24</dependent-claim-reference>, wherein said access patterns are used by said server to pre-package and compress groups of streamed application file pages; and wherein a pre-packaged group is sent to a client requesting pages within a set. </claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 24</dependent-claim-reference>, wherein said access patterns are used by said server to perform prefetching of streamed application file pages for pushing to clients. </claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference>, further comprising: 
<claim-text>a license server; </claim-text>
<claim-text>wherein said validation means resides on said license server; and </claim-text>
<claim-text>wherein said validation means provides a client with an access token that contains information regarding access rights, the application that it applies to, and an expiration time. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00029">
<claim-text><highlight><bold>29</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 28</dependent-claim-reference>, further comprising: 
<claim-text>token reception means on said server for receiving an access token from a client; </claim-text>
<claim-text>decryption means on said server for decrypting said access token; </claim-text>
<claim-text>means for validating the contents of said access token; and </claim-text>
<claim-text>a module for granting access to a client with a valid access token. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00030">
<claim-text><highlight><bold>30</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 28</dependent-claim-reference>, wherein said decrypting means uses a secret key shared with said license server to decrypt an access token. </claim-text>
</claim>
<claim id="CLM-00031">
<claim-text><highlight><bold>31</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 28</dependent-claim-reference>, wherein said server maintains a list of recently approved access tokens and compares incoming access tokens with said list, and wherein incoming access tokens that match an entry on said list are approved without further processing. </claim-text>
</claim>
<claim id="CLM-00032">
<claim-text><highlight><bold>32</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference>, wherein a client uses a persistent connection over the Internet with said server to make multiple requests from said server, and wherein said server closes persistent connections that have been idle for a predetermined period of time. </claim-text>
</claim>
<claim id="CLM-00033">
<claim-text><highlight><bold>33</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference>, further comprising: 
<claim-text>a module for assigning individual servers a specific set of streamed applications sets to serve to clients; and </claim-text>
<claim-text>wherein the servers across a network are asymmetrically assigned different sets of streamed application sets to improve overall server efficiency. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00034">
<claim-text><highlight><bold>34</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00033">claim 33</dependent-claim-reference>, wherein said individual servers are dynamically assigned streamed application sets to match client accesses over time. </claim-text>
</claim>
<claim id="CLM-00035">
<claim-text><highlight><bold>35</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00033">claim 33</dependent-claim-reference>, further comprising the step of: 
<claim-text>providing a central control server; </claim-text>
<claim-text>wherein said individual servers periodically send a summary of their file access patterns to said central control server; and </claim-text>
<claim-text>wherein said central control server reassigns individual servers according to the file access patterns. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00036">
<claim-text><highlight><bold>36</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference>, wherein said server communicates with clients across the Internet. </claim-text>
</claim>
<claim id="CLM-00037">
<claim-text><highlight><bold>37</bold></highlight>. A program storage medium readable by a computer, tangibly embodying a program of instructions executable by the computer to perform method steps for the optimized delivery of server-based streamed applications and data to a client and the management of said streamed applications on a server, comprising the steps of: 
<claim-text>providing application set storage means for persistently storing streamed application program sets on said server; </claim-text>
<claim-text>wherein said streamed application sets contain streamed application file pages; </claim-text>
<claim-text>wherein said streamed application file pages are read only; </claim-text>
<claim-text>providing means for receiving client requests for streamed application file pages; </claim-text>
<claim-text>providing validation means for validating whether a client has access privilege to a requested streamed application file page; </claim-text>
<claim-text>providing caching means for storing commonly accessed streamed application file pages in a cache; </claim-text>
<claim-text>wherein said requested streamed application file page is retrieved from said caching means if it is resident in said cache, otherwise said requested streamed application file page is retrieved from said application set storage means; </claim-text>
<claim-text>wherein clients request streamed application file pages using a unique set of numbers common among all servers that store the particular streamed application file pages; and </claim-text>
<claim-text>providing means for sending said requested streamed application file page to said client. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00038">
<claim-text><highlight><bold>38</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00033">claim 37</dependent-claim-reference>, further comprising the step of: 
<claim-text>providing compression means for compressing said requested streamed application file page before sending said requested streamed application file page to said client. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00039">
<claim-text><highlight><bold>39</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00033">claim 38</dependent-claim-reference>, wherein when a client requests multiple streamed application file pages, said server concatenates all of the requested pages and compresses the entire set at once before sending to said client. </claim-text>
</claim>
<claim id="CLM-00040">
<claim-text><highlight><bold>40</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00033">claim 38</dependent-claim-reference>, wherein said commonly accessed streamed application file pages are compressed before being stored in said cache. </claim-text>
</claim>
<claim id="CLM-00041">
<claim-text><highlight><bold>41</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00033">claim 37</dependent-claim-reference>, wherein all of the streamed application file pages in the streamed application sets are compressed before being stored in said application set storage means. </claim-text>
</claim>
<claim id="CLM-00042">
<claim-text><highlight><bold>42</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00033">claim 37</dependent-claim-reference>, further comprising the step of: 
<claim-text>providing profiling means for profiling the access patterns of streamed application file pages. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00043">
<claim-text><highlight><bold>43</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00044">claim 42</dependent-claim-reference>, wherein said access patterns are sent to said client to guide its prefetching of streamed application file pages. </claim-text>
</claim>
<claim id="CLM-00044">
<claim-text><highlight><bold>44</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00044">claim 42</dependent-claim-reference>, wherein said access patterns are used by said server to pre-package and compress groups of streamed application file pages; and wherein a pre-packaged group is sent to a client requesting pages within a set. </claim-text>
</claim>
<claim id="CLM-00045">
<claim-text><highlight><bold>45</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00044">claim 42</dependent-claim-reference>, wherein said access patterns are used by said server to perform prefetching of streamed application file pages for pushing to clients. </claim-text>
</claim>
<claim id="CLM-00046">
<claim-text><highlight><bold>46</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00033">claim 37</dependent-claim-reference>, further comprising the step of: 
<claim-text>providing a license server; </claim-text>
<claim-text>wherein said validation means resides on said license server; and </claim-text>
<claim-text>wherein said validation means provides a client with an access token that contains information regarding access rights, the application that it applies to, and an expiration time. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00047">
<claim-text><highlight><bold>47</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00044">claim 46</dependent-claim-reference>, further comprising the steps of: 
<claim-text>providing token reception means on said server for receiving an access token from a client; </claim-text>
<claim-text>providing decryption means on said server for decrypting said access token; </claim-text>
<claim-text>providing means for validating the contents of said access token; and </claim-text>
<claim-text>granting access to a client with a valid access token. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00048">
<claim-text><highlight><bold>48</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00044">claim 46</dependent-claim-reference>, wherein said decrypting means uses a secret key shared with said license server to decrypt an access token. </claim-text>
</claim>
<claim id="CLM-00049">
<claim-text><highlight><bold>49</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00044">claim 46</dependent-claim-reference>, wherein said server maintains a list of recently approved access tokens and compares incoming access tokens with said list, and wherein incoming access tokens that match an entry on said list are approved without further processing. </claim-text>
</claim>
<claim id="CLM-00050">
<claim-text><highlight><bold>50</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00033">claim 37</dependent-claim-reference>, wherein a client uses a persistent connection over the Internet with said server to make multiple requests from said server, and wherein said server closes persistent connections that have been idle for a predetermined period of time. </claim-text>
</claim>
<claim id="CLM-00051">
<claim-text><highlight><bold>51</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00033">claim 37</dependent-claim-reference>, further comprising the step of: 
<claim-text>assigning individual servers a specific set of streamed applications sets to serve to clients; and </claim-text>
<claim-text>wherein the servers across a network are asymmetrically assigned different sets of streamed application sets to improve overall server efficiency. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00052">
<claim-text><highlight><bold>52</bold></highlight>. The method of claim <highlight><bold>51</bold></highlight>, wherein said individual servers are dynamically assigned streamed application sets to match client accesses over time. </claim-text>
</claim>
<claim id="CLM-00053">
<claim-text><highlight><bold>53</bold></highlight>. The method of claim <highlight><bold>51</bold></highlight>, further comprising the step of: 
<claim-text>providing a central control server; </claim-text>
<claim-text>wherein said individual servers periodically send a summary of their file access patterns to said central control server; and </claim-text>
<claim-text>wherein said central control server reassigns individual servers according to the file access patterns. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00054">
<claim-text><highlight><bold>54</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00033">claim 37</dependent-claim-reference>, wherein said server communicates with clients across the Internet.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>1</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030004882A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030004882A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030004882A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030004882A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030004882A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030004882A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030004882A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030004882A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030004882A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00009">
<image id="EMI-D00009" file="US20030004882A1-20030102-D00009.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00010">
<image id="EMI-D00010" file="US20030004882A1-20030102-D00010.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00011">
<image id="EMI-D00011" file="US20030004882A1-20030102-D00011.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00012">
<image id="EMI-D00012" file="US20030004882A1-20030102-D00012.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00013">
<image id="EMI-D00013" file="US20030004882A1-20030102-D00013.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00014">
<image id="EMI-D00014" file="US20030004882A1-20030102-D00014.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00015">
<image id="EMI-D00015" file="US20030004882A1-20030102-D00015.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00016">
<image id="EMI-D00016" file="US20030004882A1-20030102-D00016.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00017">
<image id="EMI-D00017" file="US20030004882A1-20030102-D00017.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00018">
<image id="EMI-D00018" file="US20030004882A1-20030102-D00018.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00019">
<image id="EMI-D00019" file="US20030004882A1-20030102-D00019.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00020">
<image id="EMI-D00020" file="US20030004882A1-20030102-D00020.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00021">
<image id="EMI-D00021" file="US20030004882A1-20030102-D00021.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00022">
<image id="EMI-D00022" file="US20030004882A1-20030102-D00022.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00023">
<image id="EMI-D00023" file="US20030004882A1-20030102-D00023.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00024">
<image id="EMI-D00024" file="US20030004882A1-20030102-D00024.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00025">
<image id="EMI-D00025" file="US20030004882A1-20030102-D00025.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00026">
<image id="EMI-D00026" file="US20030004882A1-20030102-D00026.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00027">
<image id="EMI-D00027" file="US20030004882A1-20030102-D00027.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00028">
<image id="EMI-D00028" file="US20030004882A1-20030102-D00028.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00029">
<image id="EMI-D00029" file="US20030004882A1-20030102-D00029.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00030">
<image id="EMI-D00030" file="US20030004882A1-20030102-D00030.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00031">
<image id="EMI-D00031" file="US20030004882A1-20030102-D00031.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00032">
<image id="EMI-D00032" file="US20030004882A1-20030102-D00032.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00033">
<image id="EMI-D00033" file="US20030004882A1-20030102-D00033.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00034">
<image id="EMI-D00034" file="US20030004882A1-20030102-D00034.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00035">
<image id="EMI-D00035" file="US20030004882A1-20030102-D00035.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00036">
<image id="EMI-D00036" file="US20030004882A1-20030102-D00036.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00037">
<image id="EMI-D00037" file="US20030004882A1-20030102-D00037.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00038">
<image id="EMI-D00038" file="US20030004882A1-20030102-D00038.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00039">
<image id="EMI-D00039" file="US20030004882A1-20030102-D00039.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00040">
<image id="EMI-D00040" file="US20030004882A1-20030102-D00040.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00041">
<image id="EMI-D00041" file="US20030004882A1-20030102-D00041.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00042">
<image id="EMI-D00042" file="US20030004882A1-20030102-D00042.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00043">
<image id="EMI-D00043" file="US20030004882A1-20030102-D00043.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00044">
<image id="EMI-D00044" file="US20030004882A1-20030102-D00044.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00045">
<image id="EMI-D00045" file="US20030004882A1-20030102-D00045.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00046">
<image id="EMI-D00046" file="US20030004882A1-20030102-D00046.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00047">
<image id="EMI-D00047" file="US20030004882A1-20030102-D00047.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
