<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005408A1-20030102-D00000.TIF SYSTEM "US20030005408A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005408A1-20030102-D00001.TIF SYSTEM "US20030005408A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005408A1-20030102-D00002.TIF SYSTEM "US20030005408A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005408A1-20030102-D00003.TIF SYSTEM "US20030005408A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005408A1-20030102-D00004.TIF SYSTEM "US20030005408A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005408A1-20030102-D00005.TIF SYSTEM "US20030005408A1-20030102-D00005.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005408</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10023247</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20011213</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F009/44</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>717</class>
<subclass>110000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>System and method for creating software modifiable without halting its execution</title-of-invention>
</technical-information>
<continuity-data>
<non-provisional-of-provisional>
<document-id>
<doc-number>60302420</doc-number>
<document-date>20010702</document-date>
<country-code>US</country-code>
</document-id>
</non-provisional-of-provisional>
</continuity-data>
<inventors>
<first-named-inventor>
<name>
<given-name>Pradeep</given-name>
<family-name>Tumati</family-name>
</name>
<residence>
<residence-us>
<city>Blacksburg</city>
<state>VA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
</inventors>
<correspondence-address>
<name-1>FLINT &amp; KIM, P.A.</name-1>
<name-2></name-2>
<address>
<address-1>Douglas W. Kim</address-1>
<address-2>P.O. Box 10827</address-2>
<city>Greenville</city>
<state>SC</state>
<postalcode>29603</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">This invention is directed to a computerized system and method for creating a computer file trademarked as a hot pack to be used to modify object code without the need to halt the executing code. The present invention provides a system called a Development Environment (DE) for a computer programmer. The DE allows for source code to be created, segmented into grains and translated into object code. The source code can then be modified to a second version, also having grains that can be mapped onto the grains of the first version to identify the grains of the first object code that needs to be modified according to the second version of object code. </paragraph>
</subdoc-abstract>
<subdoc-description>
<cross-reference-to-related-applications>
<heading lvl="1">FIELD OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> This invention is directed to a computerized system and method for creating a means to modify an executing computer software application without the need to halt the target application. This application claims priority pursuant to 35 U.S.C. &sect; 119 of provisional application No. 302,420 filed on Jul. 02, 2001.</paragraph>
</cross-reference-to-related-applications>
<summary-of-invention>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> From the mid-1980&apos;s to the present there has been an extraordinary adaptation of computers into almost all aspects of business. The unparalleled explosion of the computer software industry and the Internet has led to a high reliance on technology and, particularly, software applications. While there have been astronomical advances in computer hardware, it is the applications themselves at the core of the functionality of computers. Simply said, a computer is useless without software to run it. Nearly a decade ago e-mail was just beginning to enter into the private sector and become adopted by businesses for day to day communications. Today, it is hard to imagine functioning without such advances as e-mail, instant messaging, global communications, file transfers, and other electronic transmissions made possible by advances in computer technology. The side effects of this tremendous acceptance of computerized systems is that individuals and business are becoming more and more reliant upon the systems and, particularly, on the applications running them. It has now reached the point to where applications need to run uninterrupted else they deprive the users of their functionality and dramatically effect the operations of business. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> Applications that must run uninterrupted exist in several areas. For example, business software that provides service for clients 24 hours a day, such as 24-hour stock trading systems, hospital equipment used to maintain patients&apos; health, and radar and air traffic control systems used to control airline flights. Any interruptions to these systems is unacceptable. All cannot tolerate downtime. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> In the case of stock trading, seconds of downtime in today&apos;s volatile stock market can cost millions of dollars. Banking software and many e-businesses need their software running continuously. A period of downtime damages both the profits and goodwill of a company. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> In today&apos;s global economy, there is no time that a piece of business software can be safely offline. Although it may be 3:00 a.m. in the United States, it is 9:00 a.m. in London, and therefore potential as well as existing customers need to access computer systems at all times. Thus, there is no time that is conducive to having a software outage. With the necessity of software applications running 24-hours a day, seven days a week, a problem is created as to how to update or maintain the software of the system. Software development is complicated and can involve millions of lines of code which, inevitably, will need to be updated many times throughout its life-span. Modifications are necessary for both bug correction and to offer new functionality. To compound the problem, it is common practice for a software vendor to issue software with known bugs that are to be corrected later. The &ldquo;first-to-market&rdquo; strategy has created the practice of distributing &ldquo;beta&rdquo; versions and 1.0 versions. This strategy does not allow a software vendor to absolutely perfect the software product before going to market. With the existing technology, software must be halted before an upgrade can be made. Thus, businesses have to choose between downtime (that may cost the business customers and profits) and not upgrading software to offer new functionality or correct bugs. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> More important than profits are health care concerns. Today&apos;s new hospital equipment is mostly computerized and therefore contains software reliant. Presently, hospitals and other health care facilities have to wait for a piece of equipment to be no longer in use before upgrading the residing application. A problem arises, however, when a patient critically needs a piece of equipment at all times and that equipment needs to be upgraded for the benefit of the patient. In this situation, the patient is not able to receive the software since a catch-22 exists as between operating with outdated software or stopping the software for upgrades. Attempts in the past to solve this problem have resulted in maintaining redundant systems that at least double the costs of the systems. While redundant systems are a good practice, they require disconnecting a patient from a piece of equipment, replacing the existing equipment with a new piece of equipment, and performing maintenance on the existing piece of equipment. The ability to update the software without the need to halt the use of the equipment would significantly reduce the number of redundant systems necessary and would allow a backup piece of equipment to service several online systems. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> Also of importance are the computer systems that are used by air traffic controllers and the military. Both of these systems need to run uninterrupted, however, both need periodic upgrades. It would be very beneficial if these systems could be updated without halting the applications. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> Previous attempts to provide for the modification of an executing application have not provided a satisfactory remedy. These attempts fall short in at least three key areas. First, they create a second application in memory that wastes valuable computer resources. Second, if the old application takes a long time to complete execution, then there will be two applications in memory wastefully using resources for an unacceptably long time if not indefinitely. Third, system failures during the modification process severely damage the integrity of the computer system. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> Accordingly, an object of the present invention is to provide a method for creating a set of computer readable instructions that can be used to safely update a currently executing application without halting the application. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> It is another object of this invention to provide a development environment for the development of software that can be modified without halting the application. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> The above objective is accomplished according to the present invention by providing a system coined an Development Environment (DE). The DE allows a computer programmer to create a file, trademarked as a Hot Pack that can be used to update an executing computer application. A Hot Pack is a computer readable file containing instructions called dictums and object code to be used to modify the executing application. Dictums are rules of steps that are to be followed for modifying a target application, specifically a target grains, from a first version to a second version. Dictums also can contain conditions for when to perform a modification as well as when to execute validity operations to insure data and functional integrity during and after modification. Dictums are more fully described below. A set of computer readable instructions, called a hot swapper, reads the Hot Pack modifies the target application accordingly. The hot swapper is located where the target application is present and can be a stand alone application or integrated with the target application. It is understood that multiple client sites can exist and each can have executing applications that can be modified according to the Hot Pack. For purposes of explaining this invention to those skilled in the art, the following terminology is used. </paragraph>
<paragraph id="P-0012" lvl="2"><number>&lsqb;0012&rsqb;</number> &ldquo;Initial Version&rdquo;&mdash;The alpha version of source code, object code, or executable code. This version is created without the existence of any previous versions, and created from scratch. </paragraph>
<paragraph id="P-0013" lvl="2"><number>&lsqb;0013&rsqb;</number> &ldquo;First Version&rdquo;&mdash;A version prior to a subsequent version. The first version can also be the initial version, but is not necessarily the initial version. For example, version 2.0 would be a first version to version 3.0. Normally, the first version is being modified to a second version. </paragraph>
<paragraph id="P-0014" lvl="2"><number>&lsqb;0014&rsqb;</number> &ldquo;Second Version&rdquo;&mdash;A version subsequent to a first version which is a modification of the first version. The second version would, for example, be version 3.0 from 2.0. </paragraph>
<paragraph id="P-0015" lvl="2"><number>&lsqb;0015&rsqb;</number> &ldquo;Source&rdquo; code is a set of human readable instructions generally written as text file that must be translated by a compiler, interpreter, or assembler into object code. </paragraph>
<paragraph id="P-0016" lvl="2"><number>&lsqb;0016&rsqb;</number> &ldquo;Object&rdquo; code is a set of computer or machine readable instructions produced by a compiler, or interpreter, or assembler that can be executed directly by a computer. Object code can include &ldquo;executable code&rdquo; which is a collection of object code that may be linked to libraries in order to produce a finalized program to be executed by a computer. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> In development of software, there are two stages. First, the initial version is created by the computer programmer. This version needs to be able to be modified without halting its execution and therefore created with this invention. Second, the initial version may need to be modified and therefore a second version created. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> In order to achieve the above objections a computerized system for providing an initial version of object code according to an initial version of source code provided by a computer programmer so that the initial version of object code can be modified without halting its execution. Therefore, a computer readable medium containing a set of computer readable instructions embodied in the computer readable medium contains instructions for creating an initial version of source code, storing the initial version of source code within the computer readable medium, segmenting the initial version of source code by initial grain boundaries to create initial grains within the initial version of source code, and translating the initial version of source code to an initial version of object code, the object code having object grain boundaries and object grains corresponding to the initial grain boundaries and the initial grains respectively. The initial grain boundaries can be provided to the computer programmer for inspection and instructions can include instructions for modifying the initial grain boundaries of the initial version of source code so that the initial grains of the initial version of source code can be modified. It is understood that the initial grain boundaries and object code can be stored in the computer readable medium. Additionally, the computer readable instructions can include instructions for verifying the lexical and syntactical information of the initial version of source code so errors may be identified in the source code. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> When the initial source code is to be modified, this invention provides for computer readable instructions that include instructions for retrieving the initial version of source code from the computer readable medium, creating a second version of source code from the first version of computer readable medium having second grain boundaries defining second grains, mapping the initial grain boundaries of the initial version of source code onto the second grain boundaries of the second version of source code so that the initial grains of the first version map on to the second grains of the second version. The compiler or translator can include instructions for presenting varying compiler optimization levels according to the initial grain boundaries of the initial version of source code, and, receiving an optimization level selection for translating the initial version of source code to an initial version of object code. The selected optimization level can be stored within the computer readable medium. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> When a grain is defined within the source and object code, the grain can have an associated crumb. The crumb can have an active and inactive state so that the object grain will be modified when the crumb is in the active state without halting the execution of the object code. The crumb is explained in more detail below. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> When the computer programmer needs to modify a first version of source code to a second version of source code, this invention allows for a set of computer readable instructions embodied within the computer readable medium for retrieving the first version of source code from the computer readable medium, duplicating the first version of source code into a second version of source code within the computer readable medium, creating second grain boundaries associated with the second version of source code defining second grains, mapping the first grains onto the second grains, editing the second version of source code, translating the second version of source code to a second version of object code while maintaining the mapping of the first and second grains, creating a dynamic list of first grains and corresponding second grains for at least those first grains to be modified according to the second version of source code, creating a dictatorial having at least one dictum according to the dynamic list and at least a portion of the second version of object code, and, generating a hot pack according to the dictatorial and at least a portion of the second version of object code so that the hot pack can be distributed in order to modify the first version of object code to the second version of object code without halting the execution of the first version of object code. Additionally, the computer readable instructions include instructions for adding dictums to the dictorial and for modifying the dynamic list.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">DESCRIPTION OF THE DRAWING </heading>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> The construction designed to carry out the invention will hereinafter be described, together with other features thereof. The invention will be more readily understood from a reading of the following specification and by reference to the accompanying drawings forming a part thereof, wherein an example of the invention is shown and wherein: </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a flowchart of the process for creating the initial version of a computer program; </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a flowchart of creating a Hot Pack; </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a schematic showing the data flow; </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a schematic of source code elements; and, </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a schematic illustrating the various stages of grain modification.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DESCRIPTION OF A PREFERRED EMBODIMENT </heading>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> The detailed description that follows may be presented in terms of program procedures executed on a computer or network of computers. These procedural descriptions are representations used by those skilled in the art to most effectively convey the substance of their work to others skilled in the art. These procedures herein described are generally a self-consistent sequence of steps leading to a desired result. These steps require physical manipulations of physical quantities such as electrical or magnetic signals capable of being stored, transferred, combined, compared, or otherwise manipulated. An object or module is a section of computer readable instructions embodied in a computer readable medium that is designed to perform a specific task or tasks. Actual computer or executable code or computer readable code may not be contained within one file or one storage medium but may span several computers or storage mediums. The term &ldquo;host&rdquo; and &ldquo;server&rdquo; may be hardware, software, or combination of hardware and software that provides the functionality described herein. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> The present invention is described below with reference to flowchart illustrations of methods, apparatus (&ldquo;systems&rdquo;) and computer program products according to the invention. It will be understood that each block of a flowchart illustration can be implemented by a set of computer readable instructions or code. These computer readable instructions may be loaded onto a general purpose computer, special purpose computer, or other programmable data processing apparatus to produce a machine such that the instructions will execute on a computer or other data processing apparatus to create a means for implementing the functions specified in the flowchart block or blocks. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> These computer readable instructions may also be stored in a computer readable medium that can direct a computer or other programmable data processing apparatus to function in a particular manner, such that the instructions stored in a computer readable medium produce an article of manufacture including instruction means that implement the functions specified in the flowchart block or blocks. Computer program instructions may also be loaded onto a computer or other programmable apparatus to produce a computer executed process such that the instructions are executed on the computer or other programmable apparatus provide steps for implementing the functions specified in the flowchart block or blocks. Accordingly, elements of the flowchart support combinations of means for performing the special functions, combination of steps for performing the specified functions and program instruction means for performing the specified functions. It will be understood that each block of the flowchart illustrations can be implemented by special purpose hardware based computer systems that perform the specified functions, or steps, or combinations of special purpose hardware or computer instructions. The present invention is now described more fully herein with reference to the drawings in which the preferred embodiment of the invention is shown. This invention may, however, be embodied any many different forms and should not be construed as limited to the embodiment set forth herein. Rather, these embodiments are provided so that this disclosure will be thorough and complete and will fully convey the scope of the invention to those skilled in the art. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> Referring now to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, the first step is to create the initial source code for a new program at step <highlight><bold>10</bold></highlight>. The computer programmer begins by opening an editor in step <highlight><bold>12</bold></highlight> or a set of computer readable instructions for entering or editing source code. The editing module allows for entering the initial version of the source code, modifying the initial version of the source code, and saving the initial version of the source code to a computer readable medium. In step <highlight><bold>14</bold></highlight>, the programmer begins entering the initial version of the source code and contemporaneously in step <highlight><bold>16</bold></highlight>, a granulizing module segments the source code into grains defined by grain boundaries. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> In referring to <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, grains can be a variety of source code elements <highlight><bold>15</bold></highlight> ranging from a statement <highlight><bold>15</bold></highlight><highlight><italic>d </italic></highlight>to an entire program unit <highlight><bold>15</bold></highlight><highlight><italic>a</italic></highlight>. A statement <highlight><bold>15</bold></highlight><highlight><italic>d </italic></highlight>is a set of character sequences arranged in a grammatically defined order of a language with some encapsulated meaning. A block <highlight><bold>15</bold></highlight><highlight><italic>c </italic></highlight>is a set of statements encapsulating the functionality of a set of statements. A function <highlight><bold>15</bold></highlight><highlight><italic>b </italic></highlight>is a set of statements and blocks. The main characteristic of a function is that it encapsulates the scope of all the identifier declarations inside it. For example, function <highlight><bold>18</bold></highlight> shows separate statements such as a&equals;3 and b&equals;(a&plus;x)/ x. The grain boundaries can define a grain as the entire function <highlight><bold>18</bold></highlight> or statements within function <highlight><bold>18</bold></highlight>. Statement <highlight><bold>18</bold></highlight><highlight><italic>b</italic></highlight>, a&equals;3, could be defined as a grain as well. Grains also have a minimum address size when they are created that is maintained in the object code. This minimum size, while partly determined by the implementation of compiler, translator, or assembler, the minimum size is also determined by the object code size of the grain, the crumb, the jump instruction, or all three. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> When the computer programmer is adding or editing the source code with the editing module, the granulizing module is defining grains within the source code by adding and managing grain boundaries. For example, when the computer programmer ends the function <highlight><bold>18</bold></highlight>, the granulizing module may place a grain boundary <highlight><bold>19</bold></highlight><highlight><italic>a </italic></highlight>at the beginning of function <highlight><bold>18</bold></highlight> as well as grain boundary <highlight><bold>19</bold></highlight><highlight><italic>b </italic></highlight>at the end to define function <highlight><bold>18</bold></highlight> as a single grain. It should be noted that grain boundaries can be modified by the computer programmer, through the granulizing module or the editing module. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> Since source code is merely human readable version of object code, both source code and object code fundamentally contain the same functionality. Therefore, the grains of source code segmenting the source code by functionality can be the same logical grains of the object code. While function <highlight><bold>18</bold></highlight> has grain boundaries <highlight><bold>19</bold></highlight><highlight><italic>a </italic></highlight>and <highlight><bold>19</bold></highlight><highlight><italic>b </italic></highlight>shown surrounding source code, the same logical grain boundary definition would exist in the object code version. Once the computer programmer has completed the initial version of the source code, a compiling module translates the initial version of the source code to an initial version of object code at step <highlight><bold>20</bold></highlight>. When compilation or translation is finished, the compiler sends all the compilation information to a version manager at step <highlight><bold>22</bold></highlight>. The version module stores the initial version of source code in the computer readable medium for later retrieval. Upon translation, the object code is distributed at step <highlight><bold>26</bold></highlight> for distribution and execution for a customer. At this point, object code has been created and can be distributed that can be modified without halting its execution. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> It is understood that the compiling module converts source code to object code. However, it is also possible not just to compile, but also to translate or interpret human readable instructions to machine readable instructions. For purposes of this invention, the term translation is used to mean converting from human readable instructions to machine-readable instructions. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> Once the initial object code is distributed and executing at a customer&apos;s site, the initial object code may need to be modified. However, it is advantageous to be able to modify the initial version to a subsequent version without halting the executing object code or target. In order to achieve this advantage, a computer programmer begins with the need to update the target application at step <highlight><bold>28</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 2</cross-reference>. The programmer wishes to create a Hot Pack in order to update the target. First, the programmer retrieves the source code from the computer readable medium in step <highlight><bold>30</bold></highlight>. In the preferred embodiment, this is done by the instantiation-mapping module for retrieving the source code from the version module and creating a copy of the source code thereby creating a second version of source code at step <highlight><bold>32</bold></highlight>. The second version of source code is then placed in the editing module at step <highlight><bold>34</bold></highlight>. Since the second version of source code is a copy of the first version, the second version also has grains defined by grain boundaries. The computer programmer edits the second version of source code at <highlight><bold>35</bold></highlight> the granulizing module executes contemporaneously in step <highlight><bold>36</bold></highlight> and second version of source code into grains according to the grain boundaries. The grain information is provided to the programmer and allows the programmer to modify the grain boundaries and grains. Therefore, if the computer programmer wishes to define a particular segment of the source code into finer grains, the granulizing module allows for the computer programmer to do so. It should be noted that the ability to edit grain boundaries can be performed through the editing module. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> When the second version of source code exists, the instantiation mapping module compares the grain boundaries of the first or initial version of source code with the second grain boundaries of the second version of source code and creates a mapping of the first version grains to the second version grains at step <highlight><bold>38</bold></highlight>. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> A compiling module in step <highlight><bold>40</bold></highlight> translates the second version of source code to a second version of object code according to the modification of the second version of source code. It should be noted that the terms first version and second version are not to be used to exclusively reference versions 1.0 and 2.0, but rather to represent an modification between any two versions of source code. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> The hot spotting module makes necessary adjustments to the grain mapping so that the first version grains map onto the second version grains. Referring to <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, function <highlight><bold>44</bold></highlight> is a modification of function <highlight><bold>18</bold></highlight>. It can be seen that statement <highlight><bold>18</bold></highlight><highlight><italic>c </italic></highlight>(b&equals;a&divide;x )/ x ) of function <highlight><bold>18</bold></highlight> has been modified to statement <highlight><bold>44</bold></highlight><highlight><italic>c </italic></highlight>( b&equals;b&circ; x ) of function <highlight><bold>44</bold></highlight>. Grain boundaries <highlight><bold>43</bold></highlight><highlight><italic>a </italic></highlight>corresponds to grain boundary <highlight><bold>19</bold></highlight><highlight><italic>a </italic></highlight>while grain boundary <highlight><bold>43</bold></highlight><highlight><italic>b </italic></highlight>corresponds to grain boundary <highlight><bold>19</bold></highlight><highlight><italic>b </italic></highlight>so that the mapping of function <highlight><bold>18</bold></highlight> onto function <highlight><bold>44</bold></highlight> is maintained. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> The hot spotter module categorizes the grains into three different categories. The first category contains the new grains that have been created. The second category contains the old grains that have been deleted. The third category contains the modified grains and their corresponding old grains from the first version. The modification of statements <highlight><bold>18</bold></highlight><highlight><italic>c </italic></highlight>to <highlight><bold>44</bold></highlight><highlight><italic>c </italic></highlight>is in this latter category. Using these three categories, the hot spotter can create the mappings of the first grain boundaries to the second grain boundaries necessary for modification. A collection of mappings between first grains and second grains is created and called a dynamic list. The dynamic list is a presented to the computer programmer in step <highlight><bold>46</bold></highlight>. Therefore, the computer programmer can choose whether or not to edit the grain mapping by using the hot spotter interface. If edits are made by the computer programmer to the grain mappings at step <highlight><bold>48</bold></highlight>, the compiler is again executed to regenerate the second version of object code that incorporates the grain boundary edits just made. In an alternate embodiment, the hot spotting module can be executed before the compiling module rather than after. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> Next, the dynamism module of step <highlight><bold>50</bold></highlight> receives the dynamic list and at least a portion of the second version of object code. The dynamism module creates a dictatorial or a second computer readable file that contains at least one dictum or rule for determining the steps to modify the first version of object code to the second version of object code. The dictatorial contains dictums for replacing the first grains with the second grains. For example, a first function <highlight><bold>18</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 4</cross-reference> having grain boundaries <highlight><bold>17</bold></highlight><highlight><italic>a</italic></highlight>-<highlight><bold>17</bold></highlight><highlight><italic>g</italic></highlight>, is modified to function <highlight><bold>52</bold></highlight> having grain boundaries <highlight><bold>53</bold></highlight><highlight><italic>a</italic></highlight>-<highlight><bold>53</bold></highlight><highlight><italic>g</italic></highlight>. Practically, the modification involves the replacement of statement <highlight><bold>54</bold></highlight> with a block of statements <highlight><bold>56</bold></highlight>. Therefore, the dictatorial would contain the grain boundaries <highlight><bold>17</bold></highlight><highlight><italic>d </italic></highlight>and <highlight><bold>17</bold></highlight><highlight><italic>e </italic></highlight>of function <highlight><bold>18</bold></highlight>, the grain boundaries <highlight><bold>53</bold></highlight><highlight><italic>d </italic></highlight>and <highlight><bold>53</bold></highlight><highlight><italic>e </italic></highlight>of function <highlight><bold>52</bold></highlight>, and the instructions and dictums to replace grain <highlight><bold>54</bold></highlight> with grain <highlight><bold>56</bold></highlight>. It is understood that the functionality of the dynamism module can be performed either prior to subsequent to the translation of the source code to object code. In the embodiment when the dynamism module functions prior the translation of the compiler, the hot pack is generated upon execution of the dynamism module after the compiler so that the hot pack will contain the dictums and the object code for updating the target application. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> Once a grain is identified as needing modification, there are two methods for modifying the grain. These two methods can be used separately or in conjunction with each other. Therefore, first is the instantaneous phase. In this phase, dictums that can be executed instantly are executed. These dictums are executed and the associated second grains replace the corresponding first grain upon execution of the hot pack. Under this phase, there was no inconsistency preventing immediate modification of the first grain to the second grain. Second is the incremental phrase. The incremental phase allows for a dictum to be executed subsequent to the initial application of the hot pack since there is some reason not to execute the particular dictum immediately. For example, the instruction pointer may be in that grain or the grain may be in recursion. Thus, the grain must be modified at a subsequent period. When a grain is defined by the computer programmer or granulizer, the compiler translates the grain into computer readable instructions represented as <highlight><bold>58</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 5</cross-reference>. Adjacent to a grain can be a jump instruction <highlight><bold>58</bold></highlight><highlight><italic>b </italic></highlight>and crumb <highlight><bold>58</bold></highlight><highlight><italic>c</italic></highlight>. Crumbs can be placed before or after a grain and can be created by the compiler or can be added by the hot swapper during modification. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> Next instruction <highlight><bold>58</bold></highlight><highlight><italic>d </italic></highlight>executes after first grain <highlight><bold>58</bold></highlight><highlight><italic>a</italic></highlight>. Normally, the first grain, jump instruction and next instruction executes as shown by arrow <highlight><bold>57</bold></highlight>. Jump instruction <highlight><bold>58</bold></highlight><highlight><italic>b </italic></highlight>prevents crumb <highlight><bold>58</bold></highlight><highlight><italic>c </italic></highlight>from executing. However, when the first grain is to be modified into the second grain, the computer readable instructions located at the target includes instructions that convert jump instruction <highlight><bold>58</bold></highlight><highlight><italic>b </italic></highlight>into a no-op instruction <highlight><bold>58</bold></highlight><highlight><italic>e</italic></highlight>. The no-op instructions causes crumb <highlight><bold>58</bold></highlight><highlight><italic>c </italic></highlight>to execute and thereby causes modification instructions <highlight><bold>59</bold></highlight> to also execute. These modification instructions result in new jump instruction <highlight><bold>58</bold></highlight><highlight><italic>f </italic></highlight>being placed in front of the first grain to point to second grain <highlight><bold>60</bold></highlight>. Second grain <highlight><bold>60</bold></highlight> then executes a next instruction command executes. Although not illustrated, second grain <highlight><bold>60</bold></highlight> can also contain a crumb for subsequent modification. The first grain and associated crumb are moved into garbage space and no longer part of the executing object of the target. Therefore, the second grain <highlight><bold>60</bold></highlight> replaces old grain <highlight><bold>58</bold></highlight> and the object code is updated to a second version. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> In an alternative embodiment, a second (new) grain can replace a first (old) grain by use of an indirection table. An indirection table is a small address table within the computer readable medium that contains a list of memory addresses corresponding to the various grains. For example, the first grain would start at address 0x1000h and be X bytes long while the next grain may start at 0x2000h and be Y bytes long. An offset pointer points to the address within the indirection table to show where the grains are located. Whenever a call is made to the first grain, the compiler generates computer readable code so that the address where the first grain is located retrieved from the indirection table and the target executes the instructions at the first grains address. The second grain may be present at another address such as 0x3000h and Z bytes long. Therefore, to modify a first grain to a second grain, the indirection table is updated so that the indirection table contains the starting address of the second grain rather that the first. Therefore, the object code of the executing application goes to address 0x3000h rather than 0x1000h by way of example and the second grain execute instead of the first grain. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> An additional embodiment includes the utilization of both the crumb as well as the indirection table. In this embodiment, crumbs can be associated the addresses within the indirection table and these crumbs, and their associated jump instructions, can be integrated into the indirection table for the address entries and modification of the indirection table can be may through the crumb process. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, in step <highlight><bold>62</bold></highlight>, the computer programmer is given the opportunity to modify the dictums through the dynamism module in the event that it is desired to change the dictatorial. If there are changes to the dictorial, the computer programmer performs the changes in step <highlight><bold>64</bold></highlight> and the compiler regenerates the second version of object code. Next, hot packer receives the dictatorial and at least a portion of the second version of object code at step <highlight><bold>66</bold></highlight> and generates a Hot Pack at step <highlight><bold>68</bold></highlight>. The Hot Pack can then be sent to the customer and executed so that the first version of object code is modified into the second version of object code without halting the execution of the first version. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> Referring now to <cross-reference target="DRAWINGS">FIG. 3</cross-reference>, the data flow between the various modules or among the computer readable instructions is explained. The source code is stored in version module <highlight><bold>70</bold></highlight> at the beginning of the creation process. The source code then travels along data path <highlight><bold>72</bold></highlight> to editing module <highlight><bold>74</bold></highlight>, instantaneous mapping module <highlight><bold>71</bold></highlight> and also through data path <highlight><bold>81</bold></highlight>. The instantaneous mapping module duplicates the first version of source code second version of source code and provides the second version of source code to the computer programmer through editing module <highlight><bold>74</bold></highlight>. While changes are made to the source code, granulizing module <highlight><bold>76</bold></highlight>, by data path <highlight><bold>78</bold></highlight> is aware of the edits being made. Therefore, granulizing module <highlight><bold>76</bold></highlight> automatically generates grain boundaries within the source code thereby defining grains. These grain boundaries are provided to the instantaneous mapping module <highlight><bold>71</bold></highlight> along data path <highlight><bold>80</bold></highlight>. The instantaneous mapping module then transmits the grain boundary information to the version module through path <highlight><bold>81</bold></highlight> and to editing module through path <highlight><bold>83</bold></highlight> while maintaining the mapping between the first version and the second version grains. Once the edits to the source code are complete, compiling module <highlight><bold>82</bold></highlight> receives the source code through data path <highlight><bold>84</bold></highlight>. A dynamism analyzer <highlight><bold>106</bold></highlight> also receives information from dynamism module <highlight><bold>98</bold></highlight> along data path <highlight><bold>108</bold></highlight> and allows for edits to the dictums. Compiling module <highlight><bold>82</bold></highlight> creates object code according to the source code. The object code is transmitted to hot packing module <highlight><bold>86</bold></highlight> via data path <highlight><bold>88</bold></highlight>. Compiling module <highlight><bold>82</bold></highlight> also transmits the object code to version module <highlight><bold>70</bold></highlight> via data path <highlight><bold>90</bold></highlight> and information to dynamism module <highlight><bold>98</bold></highlight> through data path <highlight><bold>105</bold></highlight>. Hot spotting module <highlight><bold>92</bold></highlight> receives grain information from granulizing module <highlight><bold>76</bold></highlight> and generates a dynamic list <highlight><bold>94</bold></highlight> that is transmitted along data path <highlight><bold>96</bold></highlight> to dynamism module <highlight><bold>98</bold></highlight>. The hot spotting module also provides information along data path <highlight><bold>108</bold></highlight> to the editing module. The dynamism module then creates a dictatorial <highlight><bold>100</bold></highlight> that is transmitted along data path <highlight><bold>102</bold></highlight> to hot packing module <highlight><bold>86</bold></highlight> to create a hot pack <highlight><bold>104</bold></highlight>. The hot pack is then transmitted to the customer and used to modify a first version of executable code to a second version of executable code without halting the first version executing code. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> While a preferred embodiment of the invention has been described using specific terms, such description is for illustrative purposes only, and it is to be understood that changes and variations may be made without departing from the spirit or scope of the following claims. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A computerized system for generating an initial version of object code from an initial version of source code created by a computer programmer so that the initial version of object code comprising: 
<claim-text>a computer readable medium; and, </claim-text>
<claim-text>a set of computer readable instructions embodied in said computer readable medium for: 
<claim-text>creating an initial version of source code, </claim-text>
<claim-text>storing said initial version of source code within said computer readable medium, </claim-text>
<claim-text>segmenting said initial version of source code by creating initial grain boundaries that define initial grains having predetermined segments of code within said initial version of source code, and </claim-text>
<claim-text>translating said initial version of source code to an initial version of object code, said object code having object grain boundaries and object grains corresponding to said initial grain boundaries and said initial grains respectively so that initial object code is provided that can be subsequently modified without halting its execution. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein said computer readable instructions include instructions for making available said initial grain boundaries to the computer programmer for inspection and review so that the computer programmer can preview said initial grains. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein said computer readable instructions include instructions for modifying said initial grain boundaries of said initial version of source code so that said initial grains of the initial version of source code can be modified so that the computer programmer can modify said grains. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein said computer readable instructions include instructions for storing said initial grain boundaries and said object code in said computer readable medium for subsequent retrieval when performing modifications to said initial object code. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein said computer readable instructions include instructions for verifying lexical information of said initial version of source code so that lexical errors may be identified in said source code prior to its translation. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein said computer readable instructions include instructions for verifying syntactical information of said initial version of source code so that syntactical errors may be identified in said source code prior to its translation. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein said computer readable instructions include instructions for: 
<claim-text>retrieving said initial version of source code from said computer readable medium, </claim-text>
<claim-text>creating a second version of source code from said initial version of computer readable medium having second grain boundaries defining second grains, and, </claim-text>
<claim-text>mapping said initial grain boundaries of said initial version of source code onto said second grain boundaries of said second version of source code so that differences between said initial grains and said second grains can be determined. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein said computer readable instructions include instructions for: 
<claim-text>presenting varying compiler optimization levels according to said initial grain boundaries of said initial version of source code, and, </claim-text>
<claim-text>receiving an optimization level selection for translating said initial version of source code to an initial version of object code. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference> wherein said computer readable instructions include instructions for storing said selected optimization level within said computer readable medium for subsequent retrieval. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> including a crumb associated with said object grain having an active and inactive state so that said object grain will be modified when said crumb is in said active state without halting the execution of said object code. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. A computerized system for modifying a first version of object code having first grain boundaries and first grains, stored in a computer readable medium, to a second version of object code comprising: 
<claim-text>a set of computer readable instructions embodied within said computer readable medium for: 
<claim-text>retrieving said first version of source code from said computer readable medium, </claim-text>
<claim-text>duplicating said first version of source code into a second version of source code within said computer readable medium, </claim-text>
<claim-text>creating second grain boundaries associated with said second version of source code defining second grains, </claim-text>
<claim-text>mapping said first grains onto said second grains, </claim-text>
<claim-text>editing said second version of source code, </claim-text>
<claim-text>translating said second version of source code to a second version of object code while maintaining said mapping of said first and second grains, </claim-text>
<claim-text>creating a dynamic list of first grains and corresponding second grains for at least those first grains to be modified according to said second version of source code, </claim-text>
<claim-text>creating a dictatorial having at least one dictum according to said dynamic list and at least a portion of said second version of object code, and, </claim-text>
<claim-text>generating a hot pack according to said dictatorial and at least a portion of said second version of object code so that said hot pack can be distributed in order to modify said first version of object code to said second version of object code without halting the execution of said first version of object code. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference> wherein said computer readable instructions include instructions for editing said second grain boundaries so that said second grains can be modified. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference> wherein said computer readable instructions include instructions for verifying lexical information of said second version of source code so that lexical errors may be identified in said second version of source code. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference> wherein said computer readable instructions include instructions for verifying syntactical information of said second version of source code so that syntactical errors may be identified in said second version of source code. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference> wherein said computer readable instructions include instructions for: 
<claim-text>presenting varying compiler optimization levels according to said second grain boundaries; and, </claim-text>
<claim-text>receiving an optimization level selection for translating said second version of source code to a second version of object code. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference> wherein said computer readable instructions include instructions for storing said selected optimization level in said computer readable medium. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference> wherein said computer readable instructions include instructions for adding dictums to said dictorial so that the computer programmer may modify said dictorial. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference> wherein said computer readable instructions include instructions for modifying said dynamic list so that the computer programmer may modify said dynamic list. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. A computerized system for providing an initial version of object code according to an initial version of source code provided by a computer programmer so that the initial version of object code can be modified without halting its execution comprising: 
<claim-text>a means for creating an initial version of source code; </claim-text>
<claim-text>a means for storing said initial version of source code within said computer readable medium; </claim-text>
<claim-text>a means for segmenting said initial version of source code by initial grain boundaries to create initial grains within said initial version of source code; and, </claim-text>
<claim-text>a means for translating said initial version of source code to an initial version of object code with said object code having object grain boundaries and object grains corresponding to said initial grain boundaries and said initial grains respectively. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference> including a means for providing said initial grain boundaries to the computer programmer for inspection and review. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference> including a means for modifying said initial grain boundaries of said initial version of source code. </claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference> including a means for storing said initial grain boundaries in said computer readable medium. </claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference> including a means for verifying the lexical information of said initial version of source code so that lexical errors may be identified in said source code. </claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference> including a means for verifying syntactical information of said initial version of source code so that syntactical errors may be identified in said source code. </claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference> including: 
<claim-text>a means for retrieving said initial version of source code from said computer readable medium; </claim-text>
<claim-text>a means for creating a second version of source code from said first version of computer readable medium having second grain boundaries defining second grains; </claim-text>
<claim-text>a means for mapping said initial grain boundaries of said initial version of source code onto said second grain boundaries of said second version of source code so that said initial grains of said first version map on to said second grains of said second version. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference> including: 
<claim-text>a means for presenting varying compiler optimization levels according to said initial grain boundaries of said initial version of source code; and, </claim-text>
<claim-text>a means for receiving an optimization level selection for translating said initial version of source code to an initial version of object code. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00022">claim 26</dependent-claim-reference> including a means for storing said selected optimization level within said computer readable medium. </claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference> including a means for modifying said initial grain without halting the execution of said object code. </claim-text>
</claim>
<claim id="CLM-00029">
<claim-text><highlight><bold>29</bold></highlight>. A computerized system for modifying a first version of object code having first grain boundaries and first grains, stored in a computer readable medium, to a second version of object code without halting the execution of the first version of object code comprising: 
<claim-text>a means for retrieving said first version of source code from said computer readable medium; </claim-text>
<claim-text>a means for duplicating said first version of source code into a second version of source code within said computer readable medium; </claim-text>
<claim-text>a means for creating second grain boundaries associated with said second version of source code defining second grains; </claim-text>
<claim-text>a means for mapping said first grains onto said second grains; </claim-text>
<claim-text>a means for editing said second version of source code; </claim-text>
<claim-text>a means for translating said second version of source code to a second version of object code while maintaining said mapping of said first and second grains; </claim-text>
<claim-text>a means for creating a dynamic list of first grains and corresponding second grains for at least those first grains to be modified according to said second version of source code; </claim-text>
<claim-text>a means for creating a dictatorial having at least one dictum according to said dynamic list and at least a portion of said second version of object code; and, </claim-text>
<claim-text>a means for generating a hot pack according to said dictatorial and at least a portion of said second version of object code so that said hot pack can be distributed in order to modify said first version of object code to said second version of object code without halting the execution of said first version of object code. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00030">
<claim-text><highlight><bold>30</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00022">claim 29</dependent-claim-reference> including a means for editing said second grain boundaries. </claim-text>
</claim>
<claim id="CLM-00031">
<claim-text><highlight><bold>31</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00022">claim 29</dependent-claim-reference> including: 
<claim-text>a means for presenting varying compiler optimization levels according to said second grain boundaries; and, </claim-text>
<claim-text>a means for receiving an optimization level selection for translating said second version of source code to a second version of object code. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00032">
<claim-text><highlight><bold>32</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00033">claim 31</dependent-claim-reference> including a means for storing said selected optimization level in said computer readable medium. </claim-text>
</claim>
<claim id="CLM-00033">
<claim-text><highlight><bold>33</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00022">claim 29</dependent-claim-reference> including a means for adding dictums to said dictorial. </claim-text>
</claim>
<claim id="CLM-00034">
<claim-text><highlight><bold>34</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00022">claim 29</dependent-claim-reference> including a means for modifying said dynamic list.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>2</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005408A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005408A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005408A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005408A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005408A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005408A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
