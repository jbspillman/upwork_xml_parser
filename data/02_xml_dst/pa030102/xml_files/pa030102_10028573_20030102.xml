<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030003896A1-20030102-D00000.TIF SYSTEM "US20030003896A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030003896A1-20030102-D00001.TIF SYSTEM "US20030003896A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030003896A1-20030102-D00002.TIF SYSTEM "US20030003896A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030003896A1-20030102-D00003.TIF SYSTEM "US20030003896A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030003896A1-20030102-D00004.TIF SYSTEM "US20030003896A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030003896A1-20030102-D00005.TIF SYSTEM "US20030003896A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030003896A1-20030102-D00006.TIF SYSTEM "US20030003896A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030003896A1-20030102-D00007.TIF SYSTEM "US20030003896A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030003896A1-20030102-D00008.TIF SYSTEM "US20030003896A1-20030102-D00008.TIF" NDATA TIF>
<!ENTITY US20030003896A1-20030102-D00009.TIF SYSTEM "US20030003896A1-20030102-D00009.TIF" NDATA TIF>
<!ENTITY US20030003896A1-20030102-D00010.TIF SYSTEM "US20030003896A1-20030102-D00010.TIF" NDATA TIF>
<!ENTITY US20030003896A1-20030102-D00011.TIF SYSTEM "US20030003896A1-20030102-D00011.TIF" NDATA TIF>
<!ENTITY US20030003896A1-20030102-D00012.TIF SYSTEM "US20030003896A1-20030102-D00012.TIF" NDATA TIF>
<!ENTITY US20030003896A1-20030102-D00013.TIF SYSTEM "US20030003896A1-20030102-D00013.TIF" NDATA TIF>
<!ENTITY US20030003896A1-20030102-D00014.TIF SYSTEM "US20030003896A1-20030102-D00014.TIF" NDATA TIF>
<!ENTITY US20030003896A1-20030102-D00015.TIF SYSTEM "US20030003896A1-20030102-D00015.TIF" NDATA TIF>
<!ENTITY US20030003896A1-20030102-D00016.TIF SYSTEM "US20030003896A1-20030102-D00016.TIF" NDATA TIF>
<!ENTITY US20030003896A1-20030102-D00017.TIF SYSTEM "US20030003896A1-20030102-D00017.TIF" NDATA TIF>
<!ENTITY US20030003896A1-20030102-D00018.TIF SYSTEM "US20030003896A1-20030102-D00018.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030003896</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10028573</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20011219</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>H04M001/66</ipc>
</classification-ipc-primary>
<classification-ipc-secondary>
<ipc>H04M001/68</ipc>
</classification-ipc-secondary>
<classification-ipc-secondary>
<ipc>H04M003/16</ipc>
</classification-ipc-secondary>
<classification-ipc-secondary>
<ipc>H04Q007/20</ipc>
</classification-ipc-secondary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>455</class>
<subclass>411000</subclass>
</uspc>
</classification-us-primary>
<classification-us-secondary>
<uspc>
<class>455</class>
<subclass>434000</subclass>
</uspc>
</classification-us-secondary>
</classification-us>
<title-of-invention>Synchronization of encryption in a wireless communication system</title-of-invention>
</technical-information>
<continuity-data>
<non-provisional-of-provisional>
<document-id>
<doc-number>60256668</doc-number>
<document-date>20001219</document-date>
<country-code>US</country-code>
</document-id>
</non-provisional-of-provisional>
</continuity-data>
<inventors>
<first-named-inventor>
<name>
<given-name>Eric</given-name>
<family-name>Klingler</family-name>
</name>
<residence>
<residence-us>
<city>Monroe</city>
<state>WA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Jeffrey</given-name>
<family-name>Tedeschi</family-name>
</name>
<residence>
<residence-us>
<city>Woodinville</city>
<state>WA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<assignee>
<organization-name>AT&amp;T Wireless Services, Inc.</organization-name>
<assignee-type>02</assignee-type>
</assignee>
<correspondence-address>
<name-1>PERKINS COIE LLP</name-1>
<name-2></name-2>
<address>
<address-1>P.O. BOX 2168</address-1>
<city>MENLO PARK</city>
<state>CA</state>
<postalcode>94026</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">Disclosed embodiments include a method for synchronizing a cryptosystem. In one embodiment, the method uses existing control data that is transmitted as part of a connection establishment process in a wireless communication system. In one embodiment, messages that are normally sent between a base station and a remote unit during the setup of both originating and terminating calls are parsed to detect a particular control message that indicates the start of telephony data transmission. Detection of this message indicates a point at which encryption/decryption can begin, and is used to synchronize the cryptosystem. Synchronizing a cryptosystem involves generating an RC4 state space in a keyed-autokey (&ldquo;KEK&rdquo;) encryption system. In one embodiment, Lower Medium Access Channel (&ldquo;LMAC&rdquo;) messages are used according to a wireless communication protocol. This is convenient because the LMAC messages are passed through the same Associated Control Channel (&ldquo;ACC&rdquo;) processing that encrypts and decrypts the telephony data. </paragraph>
</subdoc-abstract>
<subdoc-description>
<cross-reference-to-related-applications>
<heading lvl="1">CROSS-REFERENCE TO RELATED APPLICATION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> This application claims the benefit of U.S. Provisional Patent Application No. 60/256,668, filed Dec. 19, 2000, which is incorporated herein by reference in its entirety.</paragraph>
</cross-reference-to-related-applications>
<summary-of-invention>
<section>
<heading lvl="1">BACKGROUND </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> The disclosed embodiments relate to data transmission in wireless communications systems. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> Data transmissions include telephony data and other data, such as control data. In typical wireless telecommunications environments, it is important to provide security for the telephony data transmitted on a radio frequency (&ldquo;RF&rdquo;) channel between a wireless network subscriber&apos;s mobile unit and a fixed base. Secure communication allows users to be confident their communications are private and guarded from fraud. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> Various techniques for securing telephony data transmitted over the RF channel include encrypting the telephony data for transmission over the RF channel. The telephony data is decrypted when received. Encryption techniques often employ a mathematical algorithm that alters or rearranges the telephony data using a key. A corresponding key must be used to decrypt the telephony data. Keys are usually changed periodically for security. One challenge for designers of such techniques is the need to synchronize the encryption mechanisms for equipment and/or software at the sending and receiving locations. Synchronization includes assuring that the sender and the receiver are using a current key, and the sender and receiver are encrypting and decrypting at an appropriate point in a transmission. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> Synchronization must be established initially and maintained, even through situations in a wireless environment such as signal fading and handoff of an ongoing telephony call from one base station to another. Encryption synchronization in a wireless communication system can be difficult because the base station and remote unit are physically separated, and also because telephony calls (including low-speed modem calls and facsimile calls) are relatively asynchronous (e.g., no connection without an active call). </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> Prior approaches to encryption and synchronization have various disadvantages such as added signal processing overhead and time. For example, one technique used with a secure radiotelephone requires an additional infrared (&ldquo;IR&rdquo;) link to establish and maintain encryption synchronization. Another method involving analog scrambling of the telephony data uses an additional sub-audible signal for continuous synchronization of the scrambled audio signal. One method for resynchronization of the encryption system after a handoff requires a processing delay that is in addition to any normal handoff delay </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> Overall, there is a need for synchronization of encryption that avoids the above disadvantages while providing secure wireless communication.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a block diagram of an embodiment of a telephony system that may employ an encryption method under one embodiment of the invention. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a block diagram of an embodiment of a base station. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a block diagram of a message flow for connection establishment for a terminating call in one embodiment. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a block diagram of a message flow for connection establishment for an originating call in one embodiment. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a diagram of an ACC/traffic channel frame in one embodiment. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is a diagram of an ACC message format in one embodiment. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> is a diagram showing the format of a TCH_CONN_REQ in one embodiment. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> is a diagram illustrating the mapping of pKeySeed to keySeed in the encryption method of an embodiment. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference> is a diagram of a partial airlink DSP software architecture in a fixed wireless system (&ldquo;FWS&rdquo;) of one embodiment. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10</cross-reference> is a diagram of elements of a software architecture of an airlink DSP in one embodiment. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 11</cross-reference> is a diagram of elements of a software architecture of an RC4 software architecture within the airlink DSP in one embodiment. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 12A and 12B</cross-reference> are a flow diagram of an embodiment of encryption synchronization for a terminating call. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 13</cross-reference> is a flow diagram of an embodiment of encryption synchronization for an originating call. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 14 and 15</cross-reference> are block diagrams that further illustrate embodiments of encryption synchronization. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 16</cross-reference> is a diagram of one byte of an encryption key string, illustrating key generation according to an embodiment. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 17</cross-reference> is a diagram of an encryption key string, further illustrating key generation according to an embodiment. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> In the drawings, the same reference numbers identify identical or substantially similar elements or acts. To easily identify the discussion of any particular element or act, the most significant digit or digits in a reference number refer to the figure number in which that element is first introduced (e.g., element <highlight><uline>2</uline></highlight>04 is first introduced and discussed with respect to <cross-reference target="DRAWINGS">FIG. 2</cross-reference>). </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> Note: the headings provided herein are for convenience and do not necessarily affect the scope or interpretation of the invention. </paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION </heading>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> Embodiments of the invention, described below, use existing control data to synchronize a cryptosystem in a wireless communication system. In one embodiment, messages in a standard format that includes control data and payload data are processed, including determining whether the control data contains a particular control message. Messages normally sent between a base station and a remote unit during the setup of both originating and terminating calls are parsed to synchronize an evolving RC4 state space in a keyed-autokey (&ldquo;KEK&rdquo;) encryption system. In one embodiment, Lower Medium Access Channel (&ldquo;LMAC&rdquo;) messages are used according to a wireless communication protocol. This is convenient because the LMAC messages are passed through the same Associated Control Channel (&ldquo;ACC&rdquo;) processing that encrypts and decrypts the telephony data. This is also effective because the particular LMAC messages used are sent each time connection establishment occurs. Once a data connection has been established, each side must know when to start encrypting and decrypting the bit stream. One embodiment includes software that detects a particular LMAC message that is always sent before completing a connection establishment process and just before the transmission of telephony data. This is also the point at which it is desirable to begin encryption synchronization. The LMAC message serves as a trigger that initiates an encryption synchronization process, including starting an encryption synchronization counter that operates to determine the point in the transmission at which encryption synchronization should begin. The particular LMAC messages are sent or resent each time a connection must be established. Thus, encryption is automatically resynchronized for any call initiation or interruption without additional layers of software or hardware. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a block diagram of an embodiment of a telephony system <highlight><bold>100</bold></highlight>. The telephony system <highlight><bold>100</bold></highlight> includes remote units (&ldquo;RUs&rdquo;) <highlight><bold>102</bold></highlight>, <highlight><bold>104</bold></highlight>, and <highlight><bold>106</bold></highlight>, and base stations <highlight><bold>108</bold></highlight> and <highlight><bold>110</bold></highlight>. The number of base stations and RUs is exemplary, and could vary in any particular instance. The RUs <highlight><bold>102</bold></highlight>, <highlight><bold>104</bold></highlight>, and <highlight><bold>106</bold></highlight>, and the base stations <highlight><bold>108</bold></highlight> and <highlight><bold>110</bold></highlight> each contain various electronic circuitry to process control and data signals, such as digital signal processors (&ldquo;DSPs&rdquo;). The base stations <highlight><bold>108</bold></highlight> and <highlight><bold>110</bold></highlight>, and in some embodiments the RUs <highlight><bold>102</bold></highlight>, <highlight><bold>104</bold></highlight>, and <highlight><bold>106</bold></highlight>, further contain a central processing unit (CPU) and one or more memory devices for storing data including software routines executed by the CPU. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> Any of the RUs can establish a telephony data connection with another RU in the system <highlight><bold>100</bold></highlight> or out of the system <highlight><bold>100</bold></highlight> through one of the base stations, such as base stations <highlight><bold>108</bold></highlight> or <highlight><bold>110</bold></highlight>. An RU typically establishes a telephony connection with a base station in closest proximity. During a call, the call may be &ldquo;handed off&rdquo; from one base station to another. For example, RUs <highlight><bold>104</bold></highlight> and <highlight><bold>102</bold></highlight> preferably establish telephony connections with the base station <highlight><bold>108</bold></highlight>. The RU <highlight><bold>106</bold></highlight> preferably establishes a telephony connection with the base station <highlight><bold>108</bold></highlight>, but the call that is establishes could be handed off to the base station <highlight><bold>110</bold></highlight>. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a block diagram of an embodiment of a base station <highlight><bold>200</bold></highlight>. The base station <highlight><bold>200</bold></highlight> includes a telephony DSP <highlight><bold>202</bold></highlight>, an airlink DSP <highlight><bold>204</bold></highlight>, a CPU, <highlight><bold>206</bold></highlight>, and a memory device <highlight><bold>208</bold></highlight>. The memory device <highlight><bold>208</bold></highlight> stores instructions and data, including in one embodiment, instructions for synchronizing encryption. In other embodiments, the instructions for synchronizing encryption are stored in other memory devices, or accessed via a network. As further explained herein, embodiments of the software instructions for synchronizing encryption include a master encryption switch that is active when encryption is to be performed. Embodiments of the software instructions for synchronizing encryption further include an encryption synchronization counter that is loaded with the size of a standard message being sent so that the end of the transmission and the point at which encryption should start can be determined. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> The telephony data exchange involves multiple layers of software and hardware. For example, at a physical layer, the telephony data and other data, such as control data, is processed by an airlink digital signal processor (&ldquo;DSP&rdquo;) for transmission over an established airlink. In one embodiment, encryption of telephony data is performed by a telephony DSP. The encryption as well as the synchronization of encryption is handled at an associated control channel (&ldquo;ACC&rdquo;) software layer. As described in more detail below, existing ACC messages are parsed to provide encryption synchronization in the normal course of connection establishment. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> FIGS. <highlight><bold>3</bold></highlight> and 4 illustrate a message flow in one embodiment for connection establishment for a terminating call and an originating call, respectively. A terminating call is a call in which the RU is the receiver, while the RU is the initiator of an originating call. Referring to <cross-reference target="DRAWINGS">FIGS. 3 and 4</cross-reference>, the respective diagrams each list system layers across the top of the diagram, with base station layers on the left and RU layers on the right. The base station layers and RU layers meet at the physical layer, PHY, as shown. The labeled arrows each represent a message and its direction, that is from base station to RU, or vice versa. The sequence in which the messages occur is illustrated by time advancing from top to bottom in the diagrams. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> During the establishment of a telephony connection, before voice data is being transmitted, it is not necessary to encrypt or decrypt data for security. In any case, if encryption mechanisms are not first synchronized between sender and receiver, the voice data may be unintelligible. Therefore, in one embodiment, a place in the message flow is identified that is common to all telephone calls after the DSP initiates a traffic channel, but before any telephony data exchange. As shown in <cross-reference target="DRAWINGS">FIGS. 3 and 4</cross-reference>, both terminating and originating calls use the &ldquo;set asynchronous balance mode&rdquo; (&ldquo;SABM&rdquo;) and &ldquo;set asynchronous balance mode unnumbered acknowledge&rdquo; (&ldquo;SABMUA&rdquo;) messages in their setup. Moreover, the direction of a SABM message is always from RU to base station, while the direction of a SABMUA message is always from base station to RU. In addition, these are LMAC messages that are passed through the ACC processing on the DSP. In one embodiment, it is the ACC processing that encrypts and decrypts the telephony data using the RC4 methodology. Thus, it is convenient to place the mechanism for cryptosystem synchronization at this level of processing. The RC4 methodology is a known encryption/decryption methodology developed by Ron Rivest, and will be explained further below. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> The nature of typical telephony communication (which includes voice data, low-speed modem data, and fax data) is such that data exchange according to a protocol is always occurring after call establishment, even if no telephony data is being exchanged. This characteristic is used advantageously in keeping the cryptosystem synchronized. There is a chance, in deep fading environments, for a telephony channel to be completely lost. This requires the RU and base station to reestablish a telephony data channel. During the channel reestablishment, transfers of SABM and SABMUA messages occur. The term &ldquo;SABM/SABMUA message&rdquo; will be used to indicate a message that is either a SABM message or a SABMUA message. Because the original SABM/SABMUA messages were used in the original cryptosystem synchronization, it is advantageous to use the SABM/SABMUA messages for resynchronizing the cryptosystem in the case of a reestablishment of a telephony data channel. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> The ACC and its message types will now be briefly discussed only to the extent necessary to explain their role in embodiments of encryption synchronization. In one embodiment, an ACC message encompasses three message types, which are link control channel (&ldquo;LCC&rdquo;) messages, telephony control channel (&ldquo;TCC&rdquo;) messages, and physical control channel (&ldquo;PCC&rdquo;) messages. An airlink DSP in a base station acts as a router. The LCC&apos;s client is a control CPU in the base station. The TCC&apos;s client is a telephony DSP in the base station, and the PCC&apos;s client is a physical management software entity. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a diagram of an ACC/traffic channel frame <highlight><bold>500</bold></highlight>. The ACC/traffic channel frame <highlight><bold>500</bold></highlight> consists of 132 bits. Twelve bits are ACC bits <highlight><bold>502</bold></highlight>, and 120 bits are data payload bits <highlight><bold>504</bold></highlight>. The ACC bits <highlight><bold>502</bold></highlight> are an ACC message that is limited to twelve bits per frame. If an ACC message is longer than twelve bits, additional frames are used to transmit the ACC message. In one embodiment, the frame rate for the traffic channel frame <highlight><bold>500</bold></highlight> is 7.5 ms/frame. Therefore, the amount of time it takes a normal message to complete is equal to the size of the message in bytes times 7.5 ms. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is a diagram of an ACC message format in one embodiment. The ACC frame <highlight><bold>600</bold></highlight> consists of four header bits <highlight><bold>602</bold></highlight>, and 8 payload bits <highlight><bold>604</bold></highlight>. The four header bits <highlight><bold>602</bold></highlight> include a &ldquo;more bit&rdquo;, designated &ldquo;M&rdquo;, and three type bits. The more bit indicates whether or not the message is complete. If the more bit is active, the ACC message continues in the next frame. The three type bits encode a frame type as shown in the frame list <highlight><bold>606</bold></highlight>. Each ACC frame transmitted contains the four header bits <highlight><bold>602</bold></highlight> so that multi-frame messages can be superseded by higher priority messages. For example, this is necessary for TCC messages because the actual data for the TCC message is contained in one of the three 40-bit sub-frames of the traffic data, and cannot be held off. In one embodiment, the frame type defines four values: no message, LCC, TCC, and PCC. When there is no ACC traffic, the frame type is set to 00. While ACC data exists on the channel, the frame type corresponds to the message type (LCC, TCC, or PCC). There are four reserved message types, which may be used to implement a fast channel type message, which may use the 120 bits of payload from the ACC/traffic channel frame <highlight><bold>500</bold></highlight>, if necessary. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> The eight bits of payload are available for each ACC frame. For LCC and PCC messages, the payload is routed to or from the destination or source, respectively. The payload in a TCC message determines which of the three 40-bit frames received/transferred contain TCC messages. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> As will be further explained below, the ACC messages are parsed to determine whether the message being sent is a SABM/SABMUA message. The transmission of a SABM/SABMUA indicates that the process of establishing the connection is being completed, and the next data transmitted will be telephony data that should be encrypted or decrypted. Thus, the SABM/SABMUA messages are used to synchronize encryption between a sender and receiver. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> The encryption methodology of one embodiment will now be discussed. In one embodiment, RUs are provisioned with installation-based encryption keys or, alternatively, per-call encryption keys. Encryption keys for traffic channel data are 128-bit arrays of data and are derived from a message digest. A software application executing on the base station CPU handles the generation of the message digest as well as the derivation of the 128-bit traffic encryption key sequence. Generation of a message digest is based on a secure hash function, such as the Secure Hash Standard (SHS: Federal Information Processing Standard 180-1). </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> The airlink DSP is not involved in the key-exchange and authentication process, but is involved in applying CPU-supplied encryption keys to voice traffic data. The encryption key is passed to the airlink DSP by the CPU via a traffic channel connect request (TCH_CONN_REQ) message. <cross-reference target="DRAWINGS">FIG. 7</cross-reference> shows a format of the TCH_CONN_REQ message, although other formats are possible. The message header <highlight><bold>702</bold></highlight> and message body <highlight><bold>704</bold></highlight> contain conventional information related to the traffic connect request. The encryption information <highlight><bold>706</bold></highlight> gives a current encryption state of the sender, including a current cipher, or encryption, key size and a current cipher key. The cipher key size is the size of the RC4 encryption key in bytes. In one embodiment, the airlink DSP can support unique uplink and downlink cipher keys for each channel. The TCH_CONN_REQ message can only support a single cipher key. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> In one embodiment, Rivest&apos;s Cipher 4, commonly known as RC4, may be used in the cryptosystem. RC4 is a stream cipher that is relatively simple to implement, in part because the software code size is not large compared to other methods. In addition, RC4 offers string encryption and symmetry: the same program code is useable for both encryption and decryption. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> With RC4 there are some caveats on acceptable keys. Some keys have been found vulnerable to brute force attacks, and some statistical evidence was shown to this effect (See http://www.tik.ee.ethz.ch/&tilde;mwa/RC4/WeakKeys.txt). </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> A state box (S-box) for RC4 encryption is an array of data that is key and stream-length dependent. Stream-length dependence is an important contributor to the strength of the cryptosystem. It is not required that the stream size of the transmitter and receiver be the same. However, S-box synchronization is achieved at the beginning of the call. In one embodiment, the airlink DSP contains the encryption implementation rather than the telephony DSP because the airlink DSP has relatively greater program and data memory availability. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> According to the RC4 Algorithm, an 8 X N-bit encryption key is delivered to the RU as part of the traffic channel connect message. An initial state box (S-box) is generated from the N byte encryption key according to the algorithm below expressed in pseudocode. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> PSEUDOCODE FOR RC4 S-BOX INITIALIZATION  
<table-cwu id="TABLE-US-00001">
<number>1</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>For indices from 0 to 255, inclusive</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="center"/>
<colspec colname="3" colwidth="112PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>S-box &lsqb;index&rsqb;</entry>
<entry>&equals;</entry>
<entry>index</entry>
</row>
<row>
<entry></entry>
<entry>K-box &lsqb;index&rsqb;</entry>
<entry>&equals;</entry>
<entry>key &lsqb;index mod N&rsqb;</entry>
</row>
<row>
<entry></entry>
<entry>j-index</entry>
<entry>&equals;</entry>
<entry>0</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>for indices from 0 to 255, inclusive</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="center"/>
<colspec colname="3" colwidth="112PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>j-index</entry>
<entry>&equals;</entry>
<entry>(j-index &plus; S-box&lsqb;index&rsqb; &plus; K-box</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry></entry>
<entry>&lsqb;index&rsqb;)</entry>
</row>
<row>
<entry></entry>
<entry>mod 256</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>swap S-box&lsqb;index&rsqb; with S-box &lsqb;j-index&rsqb;</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> Over time, the S-box evolves with each byte encrypted/decrypted. The run-time RC4 algorithm is: </paragraph>
<paragraph id="P-0047" lvl="2"><number>&lsqb;0047&rsqb;</number> PSEUDOCODE FOR RC4 ENCRYPTION/DECRYPTION </paragraph>
<paragraph id="P-0048" lvl="7"><number>&lsqb;0048&rsqb;</number> For each byte in the specified buffer (buf)  
<table-cwu id="TABLE-US-00002">
<number>2</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="28PT" align="center"/>
<colspec colname="3" colwidth="140PT" align="left"/>
<thead>
<row>
<entry></entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
<entry>i-index</entry>
<entry>&equals;</entry>
<entry>(i-index &plus; 1) mod 256;</entry>
</row>
<row>
<entry></entry>
<entry>j-index</entry>
<entry>&equals;</entry>
<entry>(j-index &plus; S-box&lsqb;i-index&rsqb; mod 256;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>swap S-box &lsqb;i-index&rsqb; with S-box &lsqb;j-index&rsqb; mod 256;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="28PT" align="center"/>
<colspec colname="3" colwidth="140PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>t</entry>
<entry>&equals;</entry>
<entry>(S-box &lsqb;i-index&rsqb; &plus; S-box &lsqb;j-index&rsqb;) mod 256;</entry>
</row>
<row>
<entry></entry>
<entry>ciphbyte</entry>
<entry>&equals;</entry>
<entry>bufXOR S-box&lsqb;t&rsqb;</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> The i-index and j-index are one-time initialized to 0. Their values are saved from function call to function call to ensure a slow S-box shuffle. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> Given the particulars of the algorithm, this function set can provide services to any function requiring strong encryption. Good startup synchronization should be provided between the transmitter and receiver. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> PRIVATE PERSISTENT DATA STRUCTURES </paragraph>
<paragraph id="P-0052" lvl="7"><number>&lsqb;0052&rsqb;</number> A data structure per duplex data stream if the RC4Key may be as follows:  
<table-cwu id="TABLE-US-00003">
<number>3</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="161PT" align="left"/>
<thead>
<row>
<entry></entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
<entry>typedef struct &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="70PT" align="left"/>
<colspec colname="1" colwidth="147PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Rc4KeyOneWay rx;</entry>
</row>
<row>
<entry></entry>
<entry>Rc4KeyOneWay tx;</entry>
</row>
<row>
<entry></entry>
<entry>UINT116 keySeedSize;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub; Rc4Key;</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> The size of the keySeedSize may be limited to 32 bytes. Since the S-Box evolves with each byte input, a key box space is defined for each communications path (receive and transmit).  
<table-cwu id="TABLE-US-00004">
<number>4</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="196PT" align="left"/>
<thead>
<row>
<entry></entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
<entry>typedef struct &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="35PT" align="left"/>
<colspec colname="1" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>UINT8 S &lsqb;256&rsqb;;</entry>
</row>
<row>
<entry></entry>
<entry>UINT8 i;</entry>
</row>
<row>
<entry></entry>
<entry>UINT8 j;</entry>
</row>
<row>
<entry></entry>
<entry>UINT8 keySeed &lsqb;RC4_KEY_SEED_SIZE&rsqb;;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="196PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub; Rc4KeyOneWay;</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> In one embodiment, RC4_KEY_SEED_SIZE is defined to be 32. Although UINT8 is officially a UINT16, it serves as a reminder that quantities in the RC4 function module reference bytes. The user has flexibility to specify different keySeeds for each direction. In one embodiment, the user is a system administrator who sets up the encryption algorithm using a specific software application. In one embodiment, the software application is a traffic application running on the airlink DSP that uses the encryption system. A simplex RC4 key box structure is defined. A simplex RC4 key box structure is inexpensive in terms of memory, and further increases the security of the links. Each encrypted, full-duplex data channel requires 583 words of data memory. All RC4 key sets are maintained by the RC4 function module. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> APPLICATION PROGRAM INTERFACE </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> There are five functions callable by the user: InitRC4, SetKeySize, SetKeySeed, PrepareKey, and RC4. Function prototypes for the RC4 function module are as follows:  
<table-cwu id="TABLE-US-00005">
<number>5</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>void InitRC4 (void);</entry>
</row>
<row>
<entry>RC4Result SetKey Size (Rc4keyType&emsp;keyType,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="91PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="84PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>UINT16</entry>
<entry>keyId,</entry>
</row>
<row>
<entry></entry>
<entry>UINT16</entry>
<entry>keySize);</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="182PT" align="left"/>
<colspec colname="2" colwidth="35PT" align="left"/>
<tbody valign="top">
<row>
<entry>RC4Result SetKeySeed (Rc4KeyType</entry>
<entry>keyType,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="91PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="84PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>UINT16</entry>
<entry>keyId,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="91PT" align="left"/>
<colspec colname="1" colwidth="126PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Rc4KeyDirection key Dir,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="91PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="84PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>UINT16</entry>
<entry>*pKeySeed);</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="182PT" align="left"/>
<colspec colname="2" colwidth="35PT" align="left"/>
<tbody valign="top">
<row>
<entry>RC4Result Preparekey (Rc4KeyType</entry>
<entry>keyType,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="91PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="84PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>UINT16</entry>
<entry>keyId,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="91PT" align="left"/>
<colspec colname="1" colwidth="126PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Rc4KeyDirection key Dir);</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="133PT" align="left"/>
<colspec colname="2" colwidth="84PT" align="left"/>
<tbody valign="top">
<row>
<entry>RC4Result RC4 (Rc4KeyType</entry>
<entry>keyType,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="91PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="84PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>UINT16</entry>
<entry>keyID,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="91PT" align="left"/>
<colspec colname="1" colwidth="126PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Rc4KeyDirection keyDir,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="91PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="84PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>UINT8</entry>
<entry>*pBuffer,</entry>
</row>
<row>
<entry></entry>
<entry>UINT16</entry>
<entry>bufferLen);</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> The next three subsections describe input and output data types. The subsections following the I/O data types describe the interfaces and conditions of the five user callable functions above (i.e. the RC4 function module). </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> RC4RESULT </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> The first data type, RC4Result, is an enumerated data type the user may exploit to determine the execution of most of the public RC4 functions. An example of a data structure for RC4Result is as follows:  
<table-cwu id="TABLE-US-00006">
<number>6</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<thead>
<row>
<entry></entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
<entry>typedef enum &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>RC4_KEY_OK,</entry>
</row>
<row>
<entry></entry>
<entry>RC4_KEY_INVALID,</entry>
</row>
<row>
<entry></entry>
<entry>RC4_KEY_WEAK,</entry>
</row>
<row>
<entry></entry>
<entry>RC4_BUFFER_LENGTH_0,</entry>
</row>
<row>
<entry></entry>
<entry>RC4_KEY_TRUNCATED,</entry>
</row>
<row>
<entry></entry>
<entry>RC4_BAD_DIRECTION</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub; RC4Result;</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> An explanation of each of these results is given with the appropriate access function. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> RC4KEYTYPE </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> The second data type, Rc4KeyType describes the type of key to use. Under one embodiment, the only type of key used is for voice traffic, although alternative embodiments may define key types for other traffic.  
<table-cwu id="TABLE-US-00007">
<number>7</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="77PT" align="left"/>
<colspec colname="1" colwidth="140PT" align="left"/>
<thead>
<row>
<entry></entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
<entry>typedef enum &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="91PT" align="left"/>
<colspec colname="1" colwidth="126PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>TrafficRc4Key,</entry>
</row>
<row>
<entry></entry>
<entry>MaxKeyTypes</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="77PT" align="left"/>
<colspec colname="1" colwidth="140PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub; Rc4KeyType;</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> RC4KEYDIRECTION </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> Because each key set is comprised of two key boxes (receive and transmit), this third enumerated data type spells out those directions explicitly.  
<table-cwu id="TABLE-US-00008">
<number>8</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="161PT" align="left"/>
<thead>
<row>
<entry></entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
<entry>typedef enum &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="70PT" align="left"/>
<colspec colname="1" colwidth="147PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Rc4Receive,</entry>
</row>
<row>
<entry></entry>
<entry>Rc4Transmit,</entry>
</row>
<row>
<entry></entry>
<entry>MaxRc4KeyDirections</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub; Rc4KeyDirection;</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> RC41NIT </paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> The first user callable function, RC4INIT, is an initialization function that takes no inputs or outputs. It initializes all RC4 function module key sets. This function must be called before any other access functions. Additionally, it may be used only for one-time initialization since it does initialize all supported key sets. In one embodiment, two voice traffic channels are supported, although alternative embodiments may support additional voice channels, or voice channels and channels for other data. </paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> SETKEYSIZE </paragraph>
<paragraph id="P-0068" lvl="0"><number>&lsqb;0068&rsqb;</number> With reference to Table 1, as the name suggests, the key size of a key set is set by the second user callable function, SETKEYSIZE. The key size is shared with both transmit and receive paths. The function attempts to retrieve a specified key set. If the key set is retrieved, then the function sets the keySeedSize field to the smaller of the specified keySize or RC4_KEY_SEED_SIZE.  
<table-cwu id="TABLE-US-00009">
<number>9</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center">TABLE 1</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>RC4Result Output of SetKeySize</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="70PT" align="left"/>
<colspec colname="2" colwidth="147PT" align="left"/>
<tbody valign="top">
<row>
<entry>RC4Result</entry>
<entry>Interpretation</entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
<row>
<entry>RC4_KEY_OK</entry>
<entry>All is well, the keySize was accepted for the</entry>
</row>
<row>
<entry></entry>
<entry>specified keytype and keyId.</entry>
</row>
<row>
<entry>RC4_KEY_</entry>
<entry>The specified keyType and/or keyId is not valid.</entry>
</row>
<row>
<entry>INVALID</entry>
<entry>The keyType must be TrafficRc4Key. The</entry>
</row>
<row>
<entry></entry>
<entry>keyId must also be appropriate: TCHA or</entry>
</row>
<row>
<entry></entry>
<entry>TCHB.</entry>
</row>
<row>
<entry>RC4_KEY_TRUN-</entry>
<entry>The specified keySize was too large for the</entry>
</row>
<row>
<entry>CATED</entry>
<entry>keySeed array stored in the Rc4KeyOneWay</entry>
</row>
<row>
<entry></entry>
<entry>structure. There it was truncated to the maximum</entry>
</row>
<row>
<entry></entry>
<entry>supported size, RC4_KEY_SEED_SIZE.</entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0069" lvl="0"><number>&lsqb;0069&rsqb;</number> SETKEYSEED </paragraph>
<paragraph id="P-0070" lvl="0"><number>&lsqb;0070&rsqb;</number> With reference to Table 2, this user callable function sets the keySeed array of a specified Rc4OneWay structure using the pKeySeed array as a source. So that the user need not know all the peculiarities of the RC4 function module, the pKeySeed array may be an unsigned array of 16-bit elements. For implementating this function, pKeySeed may be a packed character array. The keySeed is an array of up RC4_KEY_SEED_SIZE bytes. The pKeySeed is an array of 16-bit words. One example of the order in which the pKeySeed bytes are stuffed into the keySeed is shown in <cross-reference target="DRAWINGS">FIG. 8</cross-reference>, &ldquo;Mapping pKeySeed to keySeed&rdquo;. This mapping is done to facilitate S-box preparation. A small increase in complexity here, further decreases the complexity in the PrepareKey access function. </paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> The flow of this access function is to attempt to retrieve the specified key box entry. If the function successfully retrieves the key box entry, then the pKeySeed is mapped as an array of 16-bit values to the keySeed of the key box (as shown in <cross-reference target="DRAWINGS">FIG. 8</cross-reference>, which illustrates mapping pKeySeed to keyseed.  
<table-cwu id="TABLE-US-00010">
<number>10</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center">TABLE 2</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>RC4Result Output of SetKeySeed</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="77PT" align="left"/>
<colspec colname="2" colwidth="140PT" align="left"/>
<tbody valign="top">
<row>
<entry>RC4Result</entry>
<entry>Interpretation</entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
<row>
<entry>RC4_KEY_OK</entry>
<entry>The keySeed was copied to the specified key</entry>
</row>
<row>
<entry></entry>
<entry>box successfully.</entry>
</row>
<row>
<entry>RC4_KEY_INVALID</entry>
<entry>The specified keyType, keyId, or keyDir was</entry>
</row>
<row>
<entry></entry>
<entry>not valid for setting the seed. keyType must be</entry>
</row>
<row>
<entry></entry>
<entry>TrafficRc4Key. keyId must be TCHA or</entry>
</row>
<row>
<entry></entry>
<entry>TCHB. keyDir must be either Rc4Receive or</entry>
</row>
<row>
<entry></entry>
<entry>Rc4Transmit.</entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> PREPAREKEY </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> Referring to Table 3, this function initializes a specified key box according to its keySeed. Like most of the access functions, the output is returned as an RC4Result.  
<table-cwu id="TABLE-US-00011">
<number>11</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center">TABLE 3</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>RC4Result Output of PrepareKey</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="77PT" align="left"/>
<colspec colname="2" colwidth="140PT" align="left"/>
<tbody valign="top">
<row>
<entry>RC4Result</entry>
<entry>Interpretation</entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
<row>
<entry>RC4_KEY_OK</entry>
<entry>Everything occurred correctly. The key box</entry>
</row>
<row>
<entry></entry>
<entry>specified is ready for use.</entry>
</row>
<row>
<entry>RC4_KEY_INVALID</entry>
<entry>The key set specified by keyType, keyId, or</entry>
</row>
<row>
<entry></entry>
<entry>keyDir is not valid. KeyType must be TCHA or</entry>
</row>
<row>
<entry></entry>
<entry>TCHB. KeyDir must be either Rc4Receive or</entry>
</row>
<row>
<entry></entry>
<entry>Rc4Transmit.</entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0074" lvl="0"><number>&lsqb;0074&rsqb;</number> PrepareKey must be called for each direction in a key set. </paragraph>
<paragraph id="P-0075" lvl="0"><number>&lsqb;0075&rsqb;</number> RC4 </paragraph>
<paragraph id="P-0076" lvl="0"><number>&lsqb;0076&rsqb;</number> The RC4 function is the encryption/decryption implementation of the RC4 algorithm. Given a key box and a buffer to operate upon, RC4 churns out the ciphertext or plaintext (depends on a value of the key direction &ldquo;keyDir&rdquo;). Note, the pBuffer has a UINT8 type specification. This means that the pBuffer must be a least-significant-byte-justified array of bytes in order to work properly. RC4 does not check to make sure the pBuffer is zero padded in the most significant bytes of the array. A keyDir of Rc4Receive will take a ciphertext pBuffer of length bufferLen, and replace the contents of pBuffer with its plaintext version. Similarly, a keyDir of Rc4Transmit will replace a plaintext pBuffer of bufferLen with its ciphertext version. Meanwhile, for valid bufferLens, the S-box is evolving with the RC4 algorithm. </paragraph>
<paragraph id="P-0077" lvl="0"><number>&lsqb;0077&rsqb;</number> VOICE ENCRYPTION SOFTWARE ARCHITECTURE </paragraph>
<paragraph id="P-0078" lvl="0"><number>&lsqb;0078&rsqb;</number> The way in which the RC4 function module fits into the general airlink software architecture will now be discussed Basically, the ACC and control level traffic channel (&ldquo;TCH&rdquo;) tasks handle all of the relevant RC4 interfacing. <cross-reference target="DRAWINGS">FIG. 9</cross-reference> is a representation of a partial airlink DSP software architecture <highlight><bold>900</bold></highlight> in one embodiment of a fixed wireless system (&ldquo;FWS&rdquo;). The architecture <highlight><bold>900</bold></highlight> is a generalized model of a processing core of a two-channel voice system. The details are that of the ACC and the relevant portion of the TCH tasks. The CPU <highlight><bold>902</bold></highlight> communicates with an airlink DSP <highlight><bold>906</bold></highlight> through a host port interface (&ldquo;HPI&rdquo;) pipe interface, and with a telephony DSP <highlight><bold>904</bold></highlight> through an HPI mailbox interface. The DSPs <highlight><bold>904</bold></highlight> and <highlight><bold>906</bold></highlight> communicate with each other through a time division multiplex (&ldquo;TDM&rdquo;) inter-DSP interface. Reference number <highlight><bold>1000</bold></highlight> indicates the airlink DSP <highlight><bold>906</bold></highlight> and its immediate environment in the software architecture as illustrated in further detail in <cross-reference target="DRAWINGS">FIG. 10</cross-reference>. </paragraph>
<paragraph id="P-0079" lvl="0"><number>&lsqb;0079&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 10</cross-reference>, further detail of the airlink DSP <highlight><bold>906</bold></highlight> and it immediate environment in the software architecture <highlight><bold>1000</bold></highlight> of one embodiment are shown. The airlink DSP <highlight><bold>906</bold></highlight> includes an HPI driver <highlight><bold>1004</bold></highlight> through which a high-speed data (&ldquo;HSD&rdquo;) signal <highlight><bold>1012</bold></highlight>, a network access controller (&ldquo;NAC&rdquo;) signal <highlight><bold>1010</bold></highlight>, a TCH signal <highlight><bold>1008</bold></highlight>, and an ACC signal <highlight><bold>1006</bold></highlight> access the HPI pipe interface. A tone driver <highlight><bold>1014</bold></highlight> receives tones from a TDM tone bus interface. The received tones are translated into an HSD signal <highlight><bold>1012</bold></highlight>, a NAC signal <highlight><bold>1010</bold></highlight>, and a TCH signal <highlight><bold>1008</bold></highlight>. Processing the TCH signal <highlight><bold>1008</bold></highlight> yields the ACC signal <highlight><bold>1006</bold></highlight>, which goes to a TDM driver <highlight><bold>1002</bold></highlight>. Between the TCH signal <highlight><bold>1010</bold></highlight> and the HPI driver <highlight><bold>1004</bold></highlight> is a TCH service access point (&ldquo;SAP&rdquo;). Between the ACC signal <highlight><bold>1006</bold></highlight> and the HPI driver <highlight><bold>1004</bold></highlight> is a ACC SAP. The TDM driver <highlight><bold>1002</bold></highlight> communicates with a TDM inter-DSP interface. The software architecture <highlight><bold>1016</bold></highlight> that includes the ACC signal <highlight><bold>1006</bold></highlight> and the TCH signal <highlight><bold>1008</bold></highlight> is further illustrated in <cross-reference target="DRAWINGS">FIG. 11</cross-reference>. </paragraph>
<paragraph id="P-0080" lvl="0"><number>&lsqb;0080&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 11</cross-reference> is a diagram of an embodiment of the software architecture <highlight><bold>1016</bold></highlight> that illustrates how the RC4 software module fits into the ACC and TCH signals. The software architecture <highlight><bold>1016</bold></highlight> includes an ACC function module <highlight><bold>1102</bold></highlight>, a TCH SAP function module <highlight><bold>1104</bold></highlight>, and an RC4 function module <highlight><bold>1106</bold></highlight>. The RC4 function module <highlight><bold>1106</bold></highlight> includes the functions SetKeySize, SetKeySeed, PrepareKey, and RC4 described above. </paragraph>
<paragraph id="P-0081" lvl="0"><number>&lsqb;0081&rsqb;</number> The SetKeySize and SetKeySeed functions are callable by the TCH function module <highlight><bold>1104</bold></highlight> via direct control lines to perform voice encryption set up. The TCH function module, in the idle state, reacts to a TCH_CONN_REQ message, which requests a connection, by calling an encryption set up function <highlight><bold>1108</bold></highlight>. The encryption set up function <highlight><bold>1108</bold></highlight> accesses the RC4 function module <highlight><bold>1106</bold></highlight> to set the encryption key size and to set the encryption key seed. When the idle state is reentered, an encryption tear off function <highlight><bold>1116</bold></highlight> is called, terminating the set up process. </paragraph>
<paragraph id="P-0082" lvl="0"><number>&lsqb;0082&rsqb;</number> The PrepareKey and RC4 functions are callable by an ACC TDM management entity <highlight><bold>1110</bold></highlight> and an ACC traffic management entity <highlight><bold>1112</bold></highlight> of the ACC function module <highlight><bold>1102</bold></highlight>. As seen as pseudo code in the ACC traffic management entity <highlight><bold>1112</bold></highlight>, if the receive side of voiceSecure is on and the SABM/SABMUA message is detected, the entity <highlight><bold>1112</bold></highlight> can initiate synchronization of the cryptosystem by calling the PrepareKey and RC4 functions. In one embodiment, voiceSecure is a variable that indicates whose purpose is to signify when the encryption synchronization is complete so that a next block of data to be transmitted or received will be encrypted. As shown in the ACC CPU management entity <highlight><bold>1114</bold></highlight>, if the SABM/SABMUA message is detected in the incoming message, RC4 synchronization can be started. The ACC CPU management entity <highlight><bold>1114</bold></highlight> communicates with the ACC TDM management entity <highlight><bold>1110</bold></highlight>, which checks for voiceSecure on (master encryption switch on). The ACC TDM management entity <highlight><bold>1110</bold></highlight> further checks for an LCC airlink packet with a transmit flag on. If the transmit flag is on, the encryption synchronization counter is decremented. If the encryption synchronization counter is zero, the ACC TDM management entity <highlight><bold>1110</bold></highlight> initializes the encryption synchronization by calling the PrepareKey function and the RC4 function. </paragraph>
<paragraph id="P-0083" lvl="0"><number>&lsqb;0083&rsqb;</number> RC4 KEY BOX SYNCHRONIZATION </paragraph>
<paragraph id="P-0084" lvl="0"><number>&lsqb;0084&rsqb;</number> The present state of an RC4 S-box depends on the keySeed and the length of the data stream (in bytes); an RC4 S-box can be any one of about 2<highlight><superscript>1700 </superscript></highlight>states. Therefore, proper synchronization is to be maintained for the duration of a data channel. The RU to base synchronization is a well-behaved software package in most existing wireless networks, so only strict synchronization on data channel startup is required. </paragraph>
<paragraph id="P-0085" lvl="0"><number>&lsqb;0085&rsqb;</number> VOICE CHANNEL SYNCHRONIZATION </paragraph>
<paragraph id="P-0086" lvl="0"><number>&lsqb;0086&rsqb;</number> In the illustrated embodiments, RC4 synchronization is achieved through the use of existing messaging related to connection establishment, or voice traffic setup. The RC4 function module is logically close to the ACC function module, so some known portion of its messaging may be used for RC4 synchronization. ACC communicates with the LMAC of the base station and the RU. This message SAP is peer-to-peer, meaning that it passes messages between the RU and the base station over the allocated airlink. The usefulness of this communication is clear when applied to initial synchronization of the voice security algorithms. </paragraph>
<paragraph id="P-0087" lvl="0"><number>&lsqb;0087&rsqb;</number> Because of the desire to start encryption as close to the start of the traffic channel as possible, (after examining the originating and terminating call setup flows of <cross-reference target="DRAWINGS">FIGS. 3 and 4</cross-reference>) synchronizing each link on the SABM/SABMUA messaging is possible. Uplink is synchronized on SABM, while downlink is synchronized on SABMUA. Any call setup requires the SABM/SABMUA message transfer. This facilitates the RC4 synchronization maintenance. </paragraph>
<paragraph id="P-0088" lvl="0"><number>&lsqb;0088&rsqb;</number> By synchronizing the encryption on the SABM/SABMUA signaling, special handling of quadrature phase shift keying (&ldquo;QPSK&rdquo;) handover can be neglected because, as far as the airlink is concerned, a new voice call is generated. The RC4 functional module is integrated with the ACC function module. Putting the encryption module as close (in a data flow sense) to the data source (the telephony DSP) as possible, simplifies the handling of encryption. Conveniently, the ACC is also responsible for passing the SABM/SABMUA messages to the CPU. This makes for clean integration with minimal external effects to be compensated for. In other embodiments, other messages that occur predictably can be used to synchronize encryption. A system architecture determines the specific protocols used for establishing a connection. Therefore, any call establishment that uses a predictable message or series of messages can use an embodiment of the invention. </paragraph>
<paragraph id="P-0089" lvl="0"><number>&lsqb;0089&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 12A and 12B</cross-reference> are a flow diagram of an embodiment of encryption synchronization for a terminating call, or a call in which a base station establishes a connection with an RU. At block <highlight><bold>1202</bold></highlight>, the base station CPU begins transmitting a LCC message to an airlink DSP. In one embodiment, the instructions stored on the memory device <highlight><bold>208</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 2</cross-reference>) include a software program for synchronizing encryption. The software program includes a master encryption switch that indicates whether encryption is required or not. The software program further includes an encryption synchronization counter that assures that encryption/decryption is synchronized, as will be explained below. </paragraph>
<paragraph id="P-0090" lvl="0"><number>&lsqb;0090&rsqb;</number> At block <highlight><bold>1204</bold></highlight>, it is determined whether the master encryption switch is active. The master encryption switch is set at call set up when the host directs a traffic channel to be started. In one embodiment, the DSP makes the determinations referred to. If the master encryption switch is not active, no encryption/decryption is currently required, and the LCC message is queued for traffic processing at block <highlight><bold>1209</bold></highlight>. If the master encryption switch is active, it is then determined at block <highlight><bold>1206</bold></highlight> whether the message currently being sent is a SABM/SABMUA message. If the message is not a SABM/SABMUA message, the LCC message is queued for traffic processing at block <highlight><bold>1209</bold></highlight>. The SABM/SABMUA messages occur at a recognizable point in connection establishment, and indicate when telephony data will be sent. In particular, the SABM/SABMUA message is the last message sent before the telephony data. The LCC message is not encrypted, but the telephony data is encrypted. Because data is transmitted in blocks, and because the size of the LCC message is variable, it is necessary to determine where the LCC message stops and the telephony data starts. The encryption synchronization counter is therefore loaded with the number of LCC message bytes to be transmitted, including the SABM/SABMUA message. When the encryption synchronization counter is zero, encryption/decryption can begin. </paragraph>
<paragraph id="P-0091" lvl="0"><number>&lsqb;0091&rsqb;</number> If the message is a SABM/SABMUA message, at block <highlight><bold>1207</bold></highlight> the number of LCC message bytes to transmit (including the size of the SABM/SABMUA message) is put into the encryption synchronization counter, and the encryption synchronization counter is started. This is the beginning of encryption synchronization. The LCC the message is queued for traffic processing at block <highlight><bold>1209</bold></highlight>. </paragraph>
<paragraph id="P-0092" lvl="0"><number>&lsqb;0092&rsqb;</number> Traffic processing begins with block <highlight><bold>1208</bold></highlight>. When <highlight><bold>120</bold></highlight> bits of telephony (payload) data have been assembled, an ACC message byte is retrieved and prioritized at block <highlight><bold>1208</bold></highlight>. These messages have priority, as previously described, and can preempt LCC messages. At block <highlight><bold>1210</bold></highlight>, if the master encryption switch is on and the encryption synchronization counter is started, it is determined at block <highlight><bold>1212</bold></highlight> whether the message is an LCC message. If the message is not an LCC message, then processing passes to block <highlight><bold>1220</bold></highlight>, where an airlink packet is created. If the message is an LCC message, the encryption synchronization counter is decremented by one at block <highlight><bold>1213</bold></highlight>. If the encryption synchronization counter is zero at block <highlight><bold>1214</bold></highlight>, an RC4 state box is generated at block <highlight><bold>1216</bold></highlight>, using a current key. If the encryption synchronization counter is not zero at block <highlight><bold>1214</bold></highlight>, an airlink packet is created at block <highlight><bold>1220</bold></highlight>. When the RC4 state box has been generated, encryption has been synchronized and the system can begin encrypting and decrypting data. The encryption synchronization counter is stopped at block <highlight><bold>1218</bold></highlight>, and an airlink packet is created at block <highlight><bold>1220</bold></highlight>. </paragraph>
<paragraph id="P-0093" lvl="0"><number>&lsqb;0093&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 13</cross-reference> is a flow diagram of an embodiment of encryption synchronization for an originating call, or a call in which an RU establishes a connection with a base station. An ACC message is parsed from a received airlink packet at block <highlight><bold>1302</bold></highlight>. As discussed with reference to <cross-reference target="DRAWINGS">FIGS. 5 and 6</cross-reference>, and further below, 132 bits are received. 12 bits of the 132 bits are ACC bits and 120 bits are payload bits. At block <highlight><bold>1304</bold></highlight>, if the master encryption switch is not on, an LCC packet is created to be sent to the base station CPU. If the master encryption switch is on at block <highlight><bold>1304</bold></highlight>, it is determined whether the current message is a SABM/SABMUA message at block <highlight><bold>1306</bold></highlight>. If the message is not a SABM/SABMUA message, an LCC packet is created to be sent to the base station CPU. If the message is a SABM/SABMUA message, an RC4 state box is generated at block <highlight><bold>1310</bold></highlight>, and an LCC packet is created at block <highlight><bold>1310</bold></highlight>. </paragraph>
<paragraph id="P-0094" lvl="0"><number>&lsqb;0094&rsqb;</number> At this point, the synchronization should be with a &ldquo;new&rdquo; RC4 key. If an &ldquo;old&rdquo; RC4 key is used, the system could be attacked. In one embodiment, an additional algorithm is used to generate a new RC4 key. Both the RU and the base station know the algorithm, and may use it to generate a new key. The SABM/SABMUA message synchronize the new RC4 state boxes, and transmission continues. RC4 key generation will be discussed in more detail below. </paragraph>
<paragraph id="P-0095" lvl="0"><number>&lsqb;0095&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 14 and 15</cross-reference> are block diagrams that further illustrate embodiments of encryption synchronization. In one embodiment, <cross-reference target="DRAWINGS">FIGS. 14 and 15</cross-reference> are a block diagram of the ACC function with respect to encryption synchronization. <cross-reference target="DRAWINGS">FIGS. 14 and 15</cross-reference> group the function into 3 sections: section <highlight><bold>1402</bold></highlight> is LCC message receipt from the CPU by the airlink DSP; section <highlight><bold>1404</bold></highlight> is traffic processing by the airlink DSP; and section <highlight><bold>1502</bold></highlight> is generation of the RC4 state box by a telephony TDM transceiver. The arrangement of functions and entities in the figures is exemplary, and other arrangements of functions and entities are contemplated within the scope of the invention. </paragraph>
<paragraph id="P-0096" lvl="0"><number>&lsqb;0096&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 14</cross-reference>, LCC message receipt function <highlight><bold>1402</bold></highlight> and traffic processing function <highlight><bold>1404</bold></highlight> are shown in the airlink DSP. In the transmit direction, an LCC message is received from the CPU. If the master encryption switch is on and the LCC message is a SABM/SABMUA message, then the number of LCC message bytes to transmit is counted, including the size of the SABM/SABMUA message, and loaded into the encryption synchronization counter. This begins the encryption synchronization process. </paragraph>
<paragraph id="P-0097" lvl="0"><number>&lsqb;0097&rsqb;</number> Referring to traffic processing function <highlight><bold>1404</bold></highlight>, when 120 bits of telephony data have been assembled, an ACC message byte is retrieved. ACC message bytes have priority as previously discussed. Only TCC messages can preempt LCC messages. </paragraph>
<paragraph id="P-0098" lvl="0"><number>&lsqb;0098&rsqb;</number> If the master encryption switch is on and the encryption synchronization counter was started, then the encryption synchronization counter is decremented by one. If the encryption synchronization counter is zero, then a transmit RC4 state box is generated at block <highlight><bold>1506</bold></highlight>, and the encryption is considered synched. The encryption synchronization counter is stopped, and an airlink packet is created. </paragraph>
<paragraph id="P-0099" lvl="0"><number>&lsqb;0099&rsqb;</number> In the other direction of transmission, upon receipt of a 132 bit airlink packet <highlight><bold>1406</bold></highlight> from the airlink, the ACC is parsed from the packet. </paragraph>
<paragraph id="P-0100" lvl="0"><number>&lsqb;0100&rsqb;</number> If the master encryption switch is on and the ACC contains a SABM/SABMUA LCC message, then a receive state box is generated at block <highlight><bold>1508</bold></highlight>, and the receive cryptosystem is considered synchronized. An LCC packet is created for transmission to the CPU. </paragraph>
<paragraph id="P-0101" lvl="0"><number>&lsqb;0101&rsqb;</number> At this point, the resynchronization may use a &ldquo;new&rdquo; RC4 key. Not to do so could open the system to attack. Therefore, an additional algorithm is used to generate a resend key. In one embodiment, a switch-tail shift register is used to generate a new key. Both the RU and the base station know this algorithm, and use it to generate a new key. New key generation is discussed more fully below, but first state box generation will be discussed with reference to <cross-reference target="DRAWINGS">FIGS. 14 and 15</cross-reference>. </paragraph>
<paragraph id="P-0102" lvl="0"><number>&lsqb;0102&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 15</cross-reference> is a block diagram showing aspects of a state box generation function <highlight><bold>1502</bold></highlight> that performs state box generation in a telephony TDM transceiver on the airlink DSP. A generate RC4 function <highlight><bold>1506</bold></highlight> generates the transmit state box, while a generate RC4 function <highlight><bold>1508</bold></highlight> generates the receive state box. On the receive end, an airlink packet <highlight><bold>1406</bold></highlight> is received from the telephony DSP and parsed to separate 12 ACC bits &ldquo;Z&rdquo; from the 40 payload bits &ldquo;Y&rdquo; (the 120 payload bits are sent in three blocks of 40 payload bits each). If the master encryption switch is active and encryption is synched (this means that the encryption synchronization counter is zero), the RC4 state box is generated at block <highlight><bold>1508</bold></highlight> according to the method described above. The payload data is encrypted by exclusive-ORing it with the state box data as previously described, and the result, &ldquo;B&rdquo;, is used to create an airlink packet. If the master encryption switch is not active or the encryption is not synched, the payload data is not encrypted. </paragraph>
<paragraph id="P-0103" lvl="0"><number>&lsqb;0103&rsqb;</number> On the transmit end, telephony data from the base station is parsed. The 12 bits of ACC data &ldquo;A&rdquo; are sent to traffic processing <highlight><bold>1404</bold></highlight>. If the master encryption switch is active and the encryption is synched, then the RD4 state box is generated, and the payload data is encrypted as previously described. If the If the master encryption switch is not active or the encryption is not synched, the payload data is not encrypted. </paragraph>
<paragraph id="P-0104" lvl="0"><number>&lsqb;0104&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 16 and 17</cross-reference> illustrated an embodiment of RC4 key generation that occurs on encryption resynchronization. The process uses a Mobius strip function to generate new key bytes in each place of the key string. In one embodiment, the specific polynomial used on each byte of the key is x<highlight><superscript>7</superscript></highlight>&plus;x<highlight><superscript>4</superscript></highlight>&plus;x<highlight><superscript>3</superscript></highlight>&plus;x&plus;1. This is shown in <cross-reference target="DRAWINGS">FIG. 16</cross-reference>, which is a diagram of one byte of the key string with the bits labeled 0 through 7. Using the first bit, each bit corresponding to the polynomial is exclusive-ORed with the first bit. Then, each bit is shifted up in the array. The exclusive-OR operations occur before the shifting operations. </paragraph>
<paragraph id="P-0105" lvl="0"><number>&lsqb;0105&rsqb;</number> To further obfuscate the key, the same process is applied to the whole key. The key is shown in <cross-reference target="DRAWINGS">FIG. 17</cross-reference>. The key includes 16 bytes, with byte 0 shown at the top of the diagram. Using the first key byte, each byte corresponding to the polynomial is exclusive-ORed with the first key byte (byte 0). After which, each key byte is shifted up in the array. The exclusive-OR operations occur before the shifting operations. </paragraph>
<paragraph id="P-0106" lvl="0"><number>&lsqb;0106&rsqb;</number> Unless the context clearly requires otherwise, throughout the description and the claims, the words &ldquo;comprise,&rdquo; &ldquo;comprising,&rdquo; and the like are to be construed in an inclusive sense as opposed to an exclusive or exhaustive sense; that is to say, in a sense of &ldquo;including, but not limited to.&rdquo; Words using the singular or plural number also include the plural or singular number respectively. Additionally, the words &ldquo;herein,&rdquo; &ldquo;hereunder,&rdquo; &ldquo;above&rdquo;, &ldquo;below,&rdquo; and words of similar import, when used in this application, shall refer to this application as a whole and not to any particular portions of this application. </paragraph>
<paragraph id="P-0107" lvl="0"><number>&lsqb;0107&rsqb;</number> The above detailed descriptions of embodiments of the invention are not intended to be exhaustive or to limit the invention to the precise form disclosed above. While specific embodiments of, and examples for, the invention are described above for illustrative purposes, various equivalent modifications are possible within the scope of the invention, as those skilled in the relevant art will recognize. For example, while steps are presented in a given order, alternative embodiments may perform routines having steps in a different order. The teachings of the invention provided herein can be applied to other systems, not necessarily the wireless communication system described herein. The various embodiments described herein can be combined to provide further embodiments. These and other changes can be made to the invention in light of the detailed description. </paragraph>
<paragraph id="P-0108" lvl="0"><number>&lsqb;0108&rsqb;</number> Any references and U.S. patents and applications listed above are incorporated herein by reference. Aspects of the invention can be modified, if necessary, to employ the systems, functions and concepts of any patents and applications described above to provide yet further embodiments of the invention. </paragraph>
<paragraph id="P-0109" lvl="0"><number>&lsqb;0109&rsqb;</number> These and other changes can be made to the invention in light of the above detailed description. In general, the terms used in the following claims, should not be construed to limit the invention to the specific embodiments disclosed in the specification, unless the above detailed description explicitly defines such terms. Accordingly, the actual scope of the invention encompasses the disclosed embodiments and all equivalent ways of practicing or implementing the invention under the claims. </paragraph>
<paragraph id="P-0110" lvl="0"><number>&lsqb;0110&rsqb;</number> While certain aspects of the invention are presented below in certain claim forms, the inventors contemplate the various aspects of the invention in any number of claim forms. For example, while only one aspect of the invention is recited as embodied in a computer-readable medium, other aspects may likewise be embodied in a computer-readable medium. Accordingly, the inventors reserve the right to add additional claims after filing the application to pursue such additional claim forms for other aspects of the invention. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">I/we claim: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method for synchronizing a cryptosystem in a wireless communication system, the method comprising: 
<claim-text>processing a message for transmission, wherein the message includes control data and payload data, and wherein the control data is not encrypted; </claim-text>
<claim-text>determining whether the control data contains a particular control message; </claim-text>
<claim-text>if the control data contains the particular control message, loading an encryption synchronization counter with a number of control message bytes to be transmitted and initializing the encryption synchronization counter; </claim-text>
<claim-text>when the encryption synchronization counter is decremented to zero, indicating that the entire message has been transmitted, initializing the cryptosystem using a key; </claim-text>
<claim-text>using the cryptosystem to encrypt the message; </claim-text>
<claim-text>creating an encrypted airlink packet for transmission over an airlink; </claim-text>
<claim-text>receiving an encrypted message, including control data and payload data, over the airlink; </claim-text>
<claim-text>parsing the message to separate the control data from the payload data; </claim-text>
<claim-text>determining whether the control data contains the particular control message; </claim-text>
<claim-text>if the control data contains the particular control message, initializing the cryptosystem using the key; and </claim-text>
<claim-text>using the cryptosystem to decrypt the message. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the particular control message is a final link control channel (&ldquo;LCC&rdquo;) message transmitted before the transmission of payload data begins, and wherein transmission of the final link control channel occurs each time a call over an airlink channel is set up. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein initializing the cryptosystem includes operating on a state box using the key. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein initializing the cryptosystem comprises: 
<claim-text>performing a mathematical operation on the key to alter the key for security, wherein the key is an array of data; and </claim-text>
<claim-text>operating on a state box using the altered key, wherein the state box is an array of data. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the cryptosystem includes an RC4 state box and an RC4 key, and wherein the payload data is operated on using the RC4 state box for encryption and decryption. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. A method for synchronizing a cryptosystem between a sender and a receiver in a wireless network comprising at least one base station and at least one remote unit, the method comprising: 
<claim-text>detecting a particular control message at an associated control channel (&ldquo;ACC&rdquo;) level that is sent each time an airlink channel is set up; and </claim-text>
<claim-text>in response to detecting the particular control message, determining a point in the transmission at which to begin operating the cryptosystem, including changing an encryption key that is used by the base station and the remote unit. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference>, wherein the particular control message is a final control message sent before payload data is sent </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference>, further comprising using the changed encryption key to generate a state box that is used by the base station and the remote unit to perform encryption and decryption. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference>, wherein the operation of the cryptosystem occurs at the ACC level. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference>, further comprising: 
<claim-text>loading an encryption synchronization counter with a size of an ACC message that contains the particular control message, wherein the ACC message is transmitted in blocks; </claim-text>
<claim-text>decrementing the encryption synchronization counter to zero when a last block of the ACC message has been transmitted; and </claim-text>
<claim-text>when the particular control message has been detected and the encryption synchronization counter is zero, initializing the cryptosystem. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference>, wherein the particular control message is either a &ldquo;set asynchronous balance mode&rdquo; (&ldquo;SABM&rdquo;) message or a &ldquo;set asynchronous balance mode unnumbered acknowledge&rdquo; (&ldquo;SABMUA&rdquo;) message. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference>, wherein the cryptosystem includes an RC4 state box that is generated by the encryption key. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. A wireless communication system, comprising: 
<claim-text>at least one remote unit comprising, at least one digital signal processor (&ldquo;DSP&rdquo;); </claim-text>
<claim-text>a central processing unit; and </claim-text>
<claim-text>a memory device, wherein the at least one remote unit is configured to receive data from and send data to at least one base station; and </claim-text>
<claim-text>at least one base station comprising, at least one DSP; </claim-text>
<claim-text>a central processing unit; and </claim-text>
<claim-text>a memory device, wherein the at least one base station is configured to detect a particular control message in a data transmission and, in response, initiate an encryption/decryption process, wherein the particular control message is an associated control channel (&ldquo;ACC&rdquo;) message that occurs just before the transmission of telephony data. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference>, wherein initiating the encryption decryption process includes the base station transmitting an encryption key via a traffic channel request message, and wherein the encryption key is used by the remote unit and the base station to generate a state box. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference>, wherein the at least one DSP of the base station comprises an airlink DSP including a memory that contains a software architecture, the software architecture comprising: 
<claim-text>an ACC function module; and </claim-text>
<claim-text>a traffic channel (&ldquo;TCH&rdquo;) function module, wherein initiating the encryption/decryption process includes the ACC function module and the TCH function module accessing an encryption/decryption function module to prepare an encryption key and begin the encryption/decryption process using an encryption/decryption algorithm. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference>, wherein the encryption/decryption algorithm is an RC4 algorithm. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference>, wherein the particular control message is selected from a group comprising a &ldquo;set asynchronous balance mode&rdquo; (&ldquo;SABM&rdquo;) message and a &ldquo;set asynchronous balance mode unnumbered acknowledge&rdquo; (&ldquo;SABMUA&rdquo;) message. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. A computer-readable medium whose contents cause a transmitter in a communications system to perform a method for synchronizing encryption/decryption of transmitted data, the method comprising creating a packet for transmission over a link, including: 
<claim-text>sending messages in blocks of data from a central processing unit (&ldquo;CPU&rdquo;) to a communication link digital signal processor; </claim-text>
<claim-text>detecting a particular control message in the blocks of data; </claim-text>
<claim-text>in response to detecting, loading a size of a message into a counter, wherein the counter reaches zero when all of the blocks in the message have been sent; </claim-text>
<claim-text>when the counter reaches zero, initiating an encryption/decryption synchronization process, including generating a state box using an encryption key; and </claim-text>
<claim-text>encrypting transmissions following the message for the packet. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The computer readable medium of <dependent-claim-reference depends_on="CLM-00011">claim 18</dependent-claim-reference>, wherein the method further comprises creating a control message packet for sending to the CPU, including, receiving an airlink packet; 
<claim-text>parsing the airlink packet to separate payload data from control data; </claim-text>
<claim-text>detecting a particular control message in the airlink packet; </claim-text>
<claim-text>in response to detecting, initiating an encryption/decryption synchronization process, including generating a state box using an encryption key; and </claim-text>
<claim-text>decrypting data following the particular control message. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The computer readable medium of <dependent-claim-reference depends_on="CLM-00011">claim 18</dependent-claim-reference>, wherein the packet comprises the encryption key. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The computer readable medium of <dependent-claim-reference depends_on="CLM-00011">claim 18</dependent-claim-reference>, wherein initiating the encryption/decryption synchronization process further includes changing the encryption key according to a predetermined algorithm, and operating on the state box using the changed encryption key. </claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The computer readable medium of <dependent-claim-reference depends_on="CLM-00011">claim 18</dependent-claim-reference>, wherein the method is performed at an associated control channel level of processing. </claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The computer readable medium of <dependent-claim-reference depends_on="CLM-00011">claim 18</dependent-claim-reference>, wherein the method is performed each time the base station participates in setting up an airlink channel. </claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The computer readable medium of <dependent-claim-reference depends_on="CLM-00011">claim 18</dependent-claim-reference>, wherein the particular control message is a link control channel (&ldquo;LCC&rdquo;) message that is a &ldquo;set asynchronous balance mode&rdquo; (&ldquo;SABM&rdquo;) message and a &ldquo;set asynchronous balance mode unnumbered acknowledge&rdquo; (&ldquo;SABMUA&rdquo;) message. </claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. An apparatus for synchronizing an encryption /decryption process in a wireless communication network, comprising: 
<claim-text>at least one digital signal processing means; </claim-text>
<claim-text>at least one central processing means; and </claim-text>
<claim-text>encryption synchronization means configured to detect a particular control message in a data transmission and, in response, initiate an encryption/decryption process, wherein the particular control message occurs just before the transmission of telephony data. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>, wherein the encryption synchronization means is further configured to provide a current encryption key to receiving devices and sending devices in the wireless communication network. </claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>, wherein the encryption synchronization means is further configured to count data blocks in a message being transmitted to determine when to begin encryption/decryption. </claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 26</dependent-claim-reference>, wherein initiating the encryption/decryption process comprises using the current encryption key to generate a current state box, wherein the current state box is used to operate on the telephony data. </claim-text>
</claim>
<claim id="CLM-00029">
<claim-text><highlight><bold>29</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>, wherein the encryption synchronization means and the encryption/decryption process operates at an associated control channel level in the wireless communication network. </claim-text>
</claim>
<claim id="CLM-00030">
<claim-text><highlight><bold>30</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>, wherein the initiation of the encryption/decryption process occurs each time a wireless connection is set up, comprising initial connection, connection hand off, and connection reestablishment after unexpected connection loss. </claim-text>
</claim>
<claim id="CLM-00031">
<claim-text><highlight><bold>31</bold></highlight>. A cryptographic method, comprising: 
<claim-text>detecting a particular trigger upon establishment of a wireless telephony communication link between at least one wireless transmitter and one wireless receiver, wherein the communication link is established under at least one known wireless protocol, and wherein the particular trigger is at a know time or location under the communication link establishment of the known wireless protocol; and </claim-text>
<claim-text>in response to detecting the particular trigger, determining a point in the transmission at which to begin applying a stream cipher. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00032">
<claim-text><highlight><bold>32</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00033">claim 31</dependent-claim-reference>, wherein the particular trigger is either a &ldquo;set asynchronous balance mode&rdquo; (&ldquo;SABM&rdquo;) message or a &ldquo;set asynchronous balance mode unnumbered acknowledge&rdquo; (&ldquo;SABMUA&rdquo;) message sent at an associated control channel (&ldquo;ACC&rdquo;) level each time an airlink channel is established. </claim-text>
</claim>
<claim id="CLM-00033">
<claim-text><highlight><bold>33</bold></highlight>. A method of synchronizing an encryption data array at a transmitter to a decryption data array at receiver in a wireless communication network, the method comprising: 
<claim-text>establishing a call between the transmitter and the receiver using a call establishment message transmitted from the transmitter to the receiver; </claim-text>
<claim-text>parsing the call establishment message to produce a parsed call establishment message; </claim-text>
<claim-text>determining an encryption state of the transmitter based on the parsed call establishment message; and </claim-text>
<claim-text>synchronizing the decryption data array at the receiver based to the encryption data array at the transmitter based on the encryption state of the transmitter.</claim-text>
</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>12A</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030003896A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030003896A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030003896A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030003896A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030003896A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030003896A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030003896A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030003896A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030003896A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00009">
<image id="EMI-D00009" file="US20030003896A1-20030102-D00009.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00010">
<image id="EMI-D00010" file="US20030003896A1-20030102-D00010.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00011">
<image id="EMI-D00011" file="US20030003896A1-20030102-D00011.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00012">
<image id="EMI-D00012" file="US20030003896A1-20030102-D00012.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00013">
<image id="EMI-D00013" file="US20030003896A1-20030102-D00013.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00014">
<image id="EMI-D00014" file="US20030003896A1-20030102-D00014.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00015">
<image id="EMI-D00015" file="US20030003896A1-20030102-D00015.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00016">
<image id="EMI-D00016" file="US20030003896A1-20030102-D00016.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00017">
<image id="EMI-D00017" file="US20030003896A1-20030102-D00017.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00018">
<image id="EMI-D00018" file="US20030003896A1-20030102-D00018.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
