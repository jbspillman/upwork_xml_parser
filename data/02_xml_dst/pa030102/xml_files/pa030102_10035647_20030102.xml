<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005014A1-20030102-D00000.TIF SYSTEM "US20030005014A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005014A1-20030102-D00001.TIF SYSTEM "US20030005014A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005014A1-20030102-D00002.TIF SYSTEM "US20030005014A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005014A1-20030102-D00003.TIF SYSTEM "US20030005014A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005014A1-20030102-D00004.TIF SYSTEM "US20030005014A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005014A1-20030102-D00005.TIF SYSTEM "US20030005014A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030005014A1-20030102-D00006.TIF SYSTEM "US20030005014A1-20030102-D00006.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005014</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10035647</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20011228</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F007/44</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>708</class>
<subclass>504000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Floating point divider with embedded status information</title-of-invention>
</technical-information>
<continuity-data>
<non-provisional-of-provisional>
<document-id>
<doc-number>60293173</doc-number>
<document-date>20010525</document-date>
<country-code>US</country-code>
</document-id>
</non-provisional-of-provisional>
</continuity-data>
<inventors>
<first-named-inventor>
<name>
<given-name>Guy</given-name>
<middle-name>L.</middle-name>
<family-name>Steele</family-name>
<name-suffix>JR.</name-suffix>
</name>
<residence>
<residence-us>
<city>Lexington</city>
<state>MA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
</inventors>
<assignee>
<organization-name>Sun Microsystems, Inc.</organization-name>
<assignee-type>02</assignee-type>
</assignee>
<correspondence-address>
<name-1>Finnegan, Henderson, Farabow,</name-1>
<name-2>Garrett &amp; Dunner, L.L.P</name-2>
<address>
<address-1>1300 I Street, N.W.</address-1>
<city>Washington</city>
<state>DC</state>
<postalcode>20005-3315</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A system for providing a floating point division comprises an analyzer circuit configured to determine a first status of a first floating point operand and a second status of a second floating point operand based upon data within the first floating point operand and data within the second floating point operand respectively. In addition, the system comprises a results circuit coupled to the analyzer circuit. The results circuit is configured to assert a resulting floating point operand containing the result of the division of the first floating point operand by the second floating point operand. Additionally, the results circuit provides resulting status embedded within the resulting floating point operand. </paragraph>
</subdoc-abstract>
<subdoc-description>
<cross-reference-to-related-applications>
<heading lvl="1">RELATED APPLICATIONS </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> U.S. Patent Application Serial No. ______,filed on even date herewith in the name of Guy L. Steele Jr. and entitled &ldquo;Floating Point System That Represents Status Flag Information Within a Floating Point Operand,&rdquo; assigned to the assignee of the present application, is hereby incorporated by reference.</paragraph>
</cross-reference-to-related-applications>
<summary-of-invention>
<section>
<heading lvl="1">DESCRIPTION OF THE INVENTION </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> 1. Field of the Invention </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> The invention relates generally to systems and methods for performing floating point operations, and more particularly to systems and methods for performing floating point division with embedded status information associated with a floating point operand. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> 2. Background of the Invention </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> Digital electronic devices, such as digital computers, calculators and other devices, perform arithmetic calculations on values in integer, or &ldquo;fixed point,&rdquo; format, in fractional, or &ldquo;floating point&rdquo; format, or both. Institute of Electrical and Electronic Engineers (IEEE) Standard 754, (hereinafter &ldquo;IEEE Std. 754&rdquo; or &ldquo;the Standard&rdquo;) published in 1985 and adopted by the American National Standards Institute (ANSI), defines several standard formats for expressing values in floating point format and a number of aspects regarding behavior of computation in connection therewith. In accordance with IEEE Std. 754, a representation in floating point format comprises a plurality of binary digits, or &ldquo;bits,&rdquo; having the structure </paragraph>
<paragraph id="P-0006" lvl="2"><number>&lsqb;0006&rsqb;</number> se<highlight><subscript>msb </subscript></highlight>. . .e<highlight><subscript>lsb</subscript></highlight>f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight></paragraph>
<paragraph id="P-0007" lvl="7"><number>&lsqb;0007&rsqb;</number> where bit &ldquo;s&rdquo; is a sign bit indicating whether the entire value is positive or negative, bits &ldquo;e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb</subscript></highlight>&rdquo; comprise an exponent field that represents the exponent &ldquo;e&rdquo; in unsigned binary biased format, and bits &ldquo;f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb</subscript></highlight>&rdquo; comprise a fraction field that represents the fractional portion &ldquo;f&rdquo; in unsigned binary format (&ldquo;msb&rdquo; represents &ldquo;most significant bit&rdquo; and &ldquo;lsb&rdquo; represents &ldquo;least significant bit&rdquo;). The Standard defines two general formats. A &ldquo;single&rdquo; format comprises thirty-two bits while a &ldquo;double&rdquo; format comprises sixty-four bits. In the single format, there is one sign bit &ldquo;s,&rdquo; eight bits &ldquo;e<highlight><subscript>7 </subscript></highlight>. . . e<highlight><subscript>0</subscript></highlight>&rdquo; comprising the exponent field and twenty-three bits &ldquo;f<highlight><subscript>22 </subscript></highlight>. . . f<highlight><subscript>0</subscript></highlight>&rdquo; comprising the fraction field. In the double format, there is one sign bit &ldquo;s,&rdquo; eleven bits &ldquo;e<highlight><subscript>10 </subscript></highlight>. . . e<highlight><subscript>0</subscript></highlight>&rdquo; comprising the exponent field and fifty-two bits &ldquo;f<highlight><subscript>51 </subscript></highlight>. . . f<highlight><subscript>0</subscript></highlight>&rdquo; comprising the fraction field. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> As indicated above, the exponent field of the floating point representation &ldquo;e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb</subscript></highlight>&rdquo; represents the exponent &ldquo;E&rdquo; in biased format. The biased format provides a mechanism by which the sign of the exponent is implicitly indicated. In particular, the bits &ldquo;e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb</subscript></highlight>&rdquo; represent a binary encoded value &ldquo;e&rdquo; such that &ldquo;e&equals;E&plus;bias.&rdquo; This allows the exponent E to extend from &minus;126 to &plus;127, in the eight-bit &ldquo;single&rdquo; format, and from &minus;1022 to &plus;1023 in the eleven-bit &ldquo;double&rdquo; format, and provides for relatively easy manipulation of the exponents in multiplication and division operations, in which the exponents are added and subtracted, respectively. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> IEEE Std. 754 provides for several different formats with both the single and double formats which are generally based on the bit patterns of the bits &ldquo;e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb</subscript></highlight>&rdquo; comprising the exponent field and the bits &ldquo;f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb</subscript></highlight>&rdquo; comprising the fraction field. If a number is represented such that all of the bits &ldquo;e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb</subscript></highlight>&rdquo; of the exponent field are binary one&apos;s (i.e., if the bits represent a binary-encoded value of &ldquo;255&rdquo; in the single format or &ldquo;2047&rdquo; in the double format) and all of the bits &ldquo;f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb</subscript></highlight>&rdquo; of the fraction field are binary zeros, then the value of the number is positive or negative infinity, depending on the value of the sign bit &ldquo;s.&rdquo; In particular, the value &ldquo;v&rdquo; is v&equals;(&minus;1)<highlight><superscript>s</superscript></highlight>&infin;, where &ldquo;&infin;&rdquo; represents the value &ldquo;infinity.&rdquo; On the other hand, if all of the bits &ldquo;e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb</subscript></highlight>&rdquo; of the exponent field are binary one&apos;s and if the bits &ldquo;f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb</subscript></highlight>&rdquo; of the fraction field are not all zero&apos;s, then the value that is represented is deemed &ldquo;not a number,&rdquo; which is abbreviated in the Standard by &ldquo;NaN.&rdquo;</paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> If a number has an exponent field in which the bits &ldquo;e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb</subscript></highlight>&rdquo; are neither all binary ones nor all binary zeros (i.e., if the bits represent a binary-encoded value between 1 and 254 in the single format or between 1 and 2046 in the double format), the number is said to be a &ldquo;normalized&rdquo; format. For a number in the normalized format, the value represented by the number is v&equals;(&minus;1)<highlight><superscript>S </superscript></highlight>2<highlight><superscript>e&minus;bias </superscript></highlight>(1.&verbar;f<highlight><subscript>msb </subscript></highlight>. . . f . . . <highlight><subscript>lsb</subscript></highlight>) where &ldquo;&verbar;&rdquo; represents a concatenation operation. Effectively, in the normalized format, there is an implicit most significant digit having the value &ldquo;one,&rdquo; so that the twenty-three digits in the fraction field of the single format, or the fifty-two digits in the fraction field of the double format, will effectively represent a value having twenty-four digits or fifty-three digits of precision, respectively, where the value is less than two, but not less than one. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> On the other hand, if a number has an exponent field in which the bits &ldquo;e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb</subscript></highlight>&rdquo; are all binary zeros, representing the binary-encoded value of &ldquo;zero,&rdquo; and a fraction field in which the bits f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>are not all zero, the number is said to be a &ldquo;de-normalized&rdquo; format. For a number in the de-normalized format, the value represented by the number is v&equals;(&minus;1)<highlight><superscript>s</superscript></highlight>2<highlight><superscript>e&minus;bas&plus;1 </superscript></highlight>(0.&verbar;f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb</subscript></highlight>). It will be appreciated that the range of values of numbers that can be expressed in the de-normalized format is disjoint from the range of values of numbers that can be expressed in the normalized format, for both the single and double formats. Finally, if a number has an exponent field in which the bits &ldquo;e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb</subscript></highlight>&rdquo; are all binary zeros, representing the binary-encoded value of &ldquo;zero,&rdquo; and a fraction field in which the bits f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>are all zero, the number has the value &ldquo;zero&rdquo;. It will be appreciated that the value &ldquo;zero&rdquo; may be positive zero or negative zero, depending on the value of the sign bit. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> Generally, circuits or devices that perform floating point computations or operations (generally referred to as floating point units) conforming to IEEE Std. 754 are designed to generate a result in three steps: </paragraph>
<paragraph id="P-0013" lvl="2"><number>&lsqb;0013&rsqb;</number> (a) In the first step, an approximation calculation step, an approximation to the absolutely accurate mathematical result (assuming that the input operands represent the specific mathematical values as described by IEEE Std. 754) is calculated that is sufficiently precise as to allow this accurate mathematical result to be summarized. The summarized result is usually represented by a sign bit, an exponent (typically represented using more bits than are used for an exponent in the standard floating-point format), and some number &ldquo;N&rdquo; of bits of the presumed result fraction, plus a guard bit and a sticky bit. The value of the exponent will be such that the value of the fraction generated in step (a) consists of a 1 before the binary point and a fraction after the binary point. The bits are commonly calculated so as to obtain the same result as the following conceptual procedure (which is impossible under some circumstances to carry out in practice): calculate the mathematical result to an infinite number of bits of precision in binary scientific notation, and in such a way that there is no bit position in the significand such that all bits of lesser significance are 1-bits (this restriction avoids the ambiguity between, for example, 1.100000 . . . and 1.011111 . . . as representations of the value &ldquo;one-and-one-half&rdquo;); let the N most significant bits of the infinite significand be used as the intermediate result significand; let the next bit of the infinite significand be the guard bit; and let the sticky bit be 0 if and only if ALL remaining bits of the infinite significant are 0-bits (in other words, the sticky bit is the logical OR of all remaining bits of the infinite fraction after the guard bit). </paragraph>
<paragraph id="P-0014" lvl="2"><number>&lsqb;0014&rsqb;</number> (b) In the second step, a rounding step, the guard bit, the sticky bit, perhaps the sign bit, and perhaps some of the bits of the presumed significand generated in step (a) are used to decide whether to alter the result of step (a). For conventional rounding modes defined by IEEE Std. 754, this is a decision as to whether to increase the magnitude of the number represented by the presumed exponent and fraction generated in step (a). Increasing the magnitude of the number is done by adding 1 to the significand in its least significant bit position, as if the significand were a binary integer. It will be appreciated that, if the significand is all 1-bits, then the magnitude of the number is &ldquo;increased&rdquo; by changing it to a high-order 1-bit followed by all O-bits and adding 1 to the exponent. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> Regarding the rounding modes, it will be further appreciated that, </paragraph>
<paragraph id="P-0016" lvl="2"><number>&lsqb;0016&rsqb;</number> (i) if the result is a positive number, and </paragraph>
<paragraph id="P-0017" lvl="3"><number>&lsqb;0017&rsqb;</number> (a) if the decision is made to increase, effectively the decision has been made to increase the value of the result, thereby rounding the result up (i.e., towards positive infinity), but </paragraph>
<paragraph id="P-0018" lvl="3"><number>&lsqb;0018&rsqb;</number> (b) if the decision is made not to increase, effectively the decision has been made to decrease the value of the result, thereby rounding the result down (i.e., towards negative infinity); and </paragraph>
<paragraph id="P-0019" lvl="2"><number>&lsqb;0019&rsqb;</number> (ii) if the result is a negative number, and </paragraph>
<paragraph id="P-0020" lvl="3"><number>&lsqb;0020&rsqb;</number> (a) if the decision is made to increase, effectively the decision has been made to decrease the value of the result, thereby rounding the result down, but </paragraph>
<paragraph id="P-0021" lvl="3"><number>&lsqb;0021&rsqb;</number> (b) if the decision is made not to increase, effectively the decision has been made to increase the value of the result, thereby rounding the result up. </paragraph>
<paragraph id="P-0022" lvl="2"><number>&lsqb;0022&rsqb;</number> (c) In the third step, a packaging step, a result is packaged into a standard floating-point format. This may involve substituting a special representation, such as the representation defined for infinity or NaN if an exceptional situation (such as overflow, underflow, or an invalid operation) was detected. Alternatively, this may involve removing the leading 1-bit (if any) of the fraction, because such leading 1-bits are implicit in the standard format. As another alternative, this may involve shifting the fraction in order to construct a denormalized number. As a specific example, it is assumed that this is the step that forces the result to be a NaN if any input operand is a NaN. In this step, the decision is also made as to whether the result should be an infinity. It will be appreciated that, if the result is to be a NaN or infinity from step (b), the original result will be discarded and an appropriate representation will be provided as the result. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> In addition in the packaging step, floating point status information is generated, which is stored in a floating point status register. The floating point status information generated for a particular floating point operation includes indications, for example, as to whether </paragraph>
<paragraph id="P-0024" lvl="2"><number>&lsqb;0024&rsqb;</number> (i) a particular operand is invalid for the operation to be performed (&ldquo;invalid operation&rdquo;); </paragraph>
<paragraph id="P-0025" lvl="2"><number>&lsqb;0025&rsqb;</number> (ii) if the operation to be performed is division, the divisor is zero (&ldquo;division-by-zero&rdquo;); </paragraph>
<paragraph id="P-0026" lvl="2"><number>&lsqb;0026&rsqb;</number> (iii) an overflow occurred during the operation (&ldquo;overflow&rdquo;); </paragraph>
<paragraph id="P-0027" lvl="2"><number>&lsqb;0027&rsqb;</number> (iv) an underflow occurred during the operation (&ldquo;underflow&rdquo;); and </paragraph>
<paragraph id="P-0028" lvl="2"><number>&lsqb;0028&rsqb;</number> (v) the rounded result of the operation is not exact (&ldquo;inexact&rdquo;). </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> These conditions are typically represented by flags that are stored in the floating point status register. The floating point status information can be used to dynamically control the operations in response to certain instructions, such as conditional branch, conditional move, and conditional trap instructions that may be in the instruction stream subsequent to the floating point instruction. Also, the floating point status information may enable processing of a trap sequence, which will interrupt the normal flow of program execution. In addition, the floating point status information may be used to affect certain ones of the functional unit control signals that control the rounding mode. IEEE Std. 754 also provides for accumulating floating point status information from, for example, results generated for a series or plurality of floating point operations. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> IEEE Std. 754 has brought relative harmony and stability to floating-point computation and architectural design of floating-point units. Moreover, its design was based on some important principles, and rests on a sensible mathematical semantics that eases the job of programmers and numerical analysts. It also supports the implementation of interval arithmetic, which may prove to be preferable to simple scalar arithmetic for many tasks. Nevertheless, IEEE Std. 754 has some serious drawbacks, including: </paragraph>
<paragraph id="P-0031" lvl="2"><number>&lsqb;0031&rsqb;</number> (i) Modes (e.g., the rounding modes and traps enabled/disabled mode), flags (e.g., flags representing the status information), and traps required to implement IEEE Std. 754 introduce implicit serialization issues. Implicit serialization is essentially the need for serial control of access (read/write) to and from globally used registers, such as a floating point status register. Under IEEE Std. 754, implicit serialization may arise between (1) different concurrent floating-point instructions and (2) between floating point instructions and the instructions that read and write the flags and modes. Furthermore, rounding modes may introduce implicit serialization because they are typically indicated as global state, although in some microprocessor architectures, the rounding mode is encoded as part of the instruction operation code, which will alleviate this problem to that extent. Thus, the potential for implicit serialization makes the Standard difficult to implement coherently and efficiently in today&apos;s superscalar and parallel processing architectures without loss of performance. </paragraph>
<paragraph id="P-0032" lvl="2"><number>&lsqb;0032&rsqb;</number> (ii) The implicit side effects of a procedure that can change the flags or modes can make it very difficult for compilers to perform optimizations on floating point code. As a result, compilers for most languages usually assume that every procedure call is an optimization barrier in order to be safe. This unfortunately may lead to further loss of performance. </paragraph>
<paragraph id="P-0033" lvl="2"><number>&lsqb;0033&rsqb;</number> (iii) Global flags, such as those that signal certain modes, make it more difficult to do instruction scheduling where the best performance is provided by interleaving instructions of unrelated computations. Thus, instructions from regions of code governed by different flag settings or different flag detection requirements cannot easily be interleaved when they must share a single set of global flag bits. </paragraph>
<paragraph id="P-0034" lvl="2"><number>&lsqb;0034&rsqb;</number> (iv) Furthermore, traps have been difficult to integrate efficiently into computing architectures and programming language designs for fine-grained control of algorithmic behavior. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> Thus, there is a need for a system that avoids such problems when performing floating point operations and, in particular, when performing floating point division with embedded status information associated with a floating point operand. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> Consistent with the current invention, a floating point divider with embedded status information method and system are provided that avoid the problems associated with prior art floating point divider systems as discussed herein above. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> In one aspect, a system for providing a floating point division comprises an analyzer circuit configured to determine a first status of a first floating point operand and a second status of a second floating point operand based upon data within the first floating point operand and the second floating point operand respectively. In addition, the system comprises a results circuit coupled to the analyzer circuit. The results circuit is configured to assert a resulting floating point operand containing the result of the division of the first floating point operand by the second floating point operand and a resulting status embedded within the resulting floating point operand. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> In another aspect, a method for providing a floating point division comprises determining a first status of a first floating point operand and a second status of a second floating point operand based upon data within the first floating point operand and the second floating point operand respectively. In addition, the method comprises asserting a resulting floating point operand containing the result of the division of the first floating point operand by the second floating point operand and a resulting status embedded within the resulting floating point operand. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> In yet another aspect, a computer-readable medium on which is stored a set of instructions for providing a floating point division, which when executed perform stages comprising determining a first status of a first floating point operand and a second status of a second floating point operand based upon data within the first floating point operand and the second floating point operand respectively. In addition, stages of the instruction set comprises asserting a resulting floating point operand containing the result of the division of the first floating point operand by the second floating point operand and a resulting status embedded within the resulting floating point operand. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> Both the foregoing general description and the following detailed description are exemplary and are intended to provide further explanation of the invention as claimed. </paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> The accompanying drawings provide a further understanding of the invention and, together with the detailed description, explain the principles of the invention. In the drawings: </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a functional block diagram of an exemplary system for providing a floating point division consistent with an embodiment of the present invention; </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> illustrates exemplary formats for representations of floating point values generated by the system of <cross-reference target="DRAWINGS">FIG. 1</cross-reference> consistent with an embodiment of the present invention; </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> illustrates a table useful in understanding the operations of the exemplary system of <cross-reference target="DRAWINGS">FIG. 1</cross-reference> consistent with an embodiment of the present invention; and </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 4A through 4C</cross-reference> depict exemplary patterns of input and output signals received and generated by a divider decision table logic circuit used in the exemplary system of <cross-reference target="DRAWINGS">FIG. 1</cross-reference> consistent with an embodiment of the present invention.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DESCRIPTION OF THE EMBODIMENTS </heading>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> Reference will now be made to various embodiments according to this invention, examples of which are shown in the accompanying drawings and will be obvious from the description of the invention. In the drawings, the same reference numbers represent the same or similar elements in the different drawings whenever possible. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> Related U.S. Patent Application Serial No. ______, which has previously been incorporated by reference, describes an exemplary floating point unit in which floating point status information is encoded in the representations of the results generated thereby. The exemplary floating point unit includes a plurality of functional units, including an adder unit, a multiplier unit, a divider unit, a square root unit, a maximum/minimum unit, a comparator unit, a remainder unit and a tester unit, all of which operate under control of functional unit control signals provided by a control unit. The present application is directed to an exemplary divider unit that can be used in floating point operations with the floating point unit described in related U.S. Patent Application Serial No. ______. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a functional block diagram of an exemplary divider unit <highlight><bold>10</bold></highlight> constructed in accordance with an embodiment of the invention. Generally, the divider unit <highlight><bold>10</bold></highlight> receives two floating point operands and generates therefrom a result and, in some cases, floating point status information, with the floating point status information being encoded in and comprising part of the floating point representation of the result. Since the floating point status information comprises part of the floating point representation of the result, instead of being separate and apart from the result as in prior art divider units, the implicit serialization that is required by maintaining the floating point status information separate and apart from the result can be obviated. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> The divider unit <highlight><bold>10</bold></highlight> encodes the floating point status information in results that are generated in certain formats. This will be illustrated in connection with <cross-reference target="DRAWINGS">FIG. 2</cross-reference>. <cross-reference target="DRAWINGS">FIG. 2</cross-reference> depicts exemplary formats of floating point operands that the divider unit <highlight><bold>10</bold></highlight> may receive, and of results that it generates. With reference to the embodiment illustrated in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, seven formats are depicted, including a zero format <highlight><bold>70</bold></highlight>, an underflow format <highlight><bold>71</bold></highlight>, a denormalized format <highlight><bold>72</bold></highlight>, a normalized non-zero format <highlight><bold>73</bold></highlight>, an overflow format <highlight><bold>74</bold></highlight>, an infinity format <highlight><bold>75</bold></highlight> and a not-a-number (NaN) format <highlight><bold>76</bold></highlight>. The zero format <highlight><bold>70</bold></highlight> is used to represent the values &ldquo;zero,&rdquo; or, more specifically, positive or negative zero, depending on the value of &ldquo;s,&rdquo; the sign bit. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> The underflow format <highlight><bold>71</bold></highlight> provides a mechanism by which the divider unit <highlight><bold>10</bold></highlight> can indicate that the result of a computation is an underflow. In the underflow format, the sign bit &ldquo;s&rdquo; indicates whether the result is positive or negative, the bits e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb </subscript></highlight>of the exponent field are all binary zero&apos;s, and the bits f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb&plus;1 </subscript></highlight>of the fraction field, except for the least significant bit, are all binary zero&apos;s. The least significant bit f<highlight><subscript>lsb </subscript></highlight>of the fraction field is a binary one. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> The denormalized format <highlight><bold>72</bold></highlight> and normalized non-zero format <highlight><bold>73</bold></highlight> are used to represent finite non-zero floating point values substantially along the lines of that described above in connection with IEEE Std. 754. In both formats <highlight><bold>72</bold></highlight> and <highlight><bold>73</bold></highlight>, the sign bit &ldquo;s&rdquo; indicates whether the result is positive or negative. The bits e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb </subscript></highlight>of the exponent field of the denormalized format <highlight><bold>72</bold></highlight> are all binary zero&apos;s, whereas the bits e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb </subscript></highlight>of the exponent field of the normalized non-zero format <highlight><bold>73</bold></highlight> are mixed one&apos;s and zero&apos;s, except that the exponent field of the normalized non-zero format <highlight><bold>73</bold></highlight> will not have a pattern in which bits e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb&plus;1 </subscript></highlight>are all binary ones and the least significant bit e<highlight><subscript>lsb </subscript></highlight>zero and all of the bits f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field are all binary one&apos;s. In both formats <highlight><bold>72</bold></highlight> and <highlight><bold>73</bold></highlight>, the bit f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field are not all binary zero&apos;s. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> The overflow format <highlight><bold>74</bold></highlight> provides a mechanism by which the divider unit <highlight><bold>10</bold></highlight> can indicate that the result of a computation is an overflow. In the overflow format <highlight><bold>74</bold></highlight>, the sign bit &ldquo;s&rdquo; indicates whether the result is positive or negative, the bits e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb&plus;1 </subscript></highlight>of the exponent field are all binary ones, with the least significant bit e<highlight><subscript>lsb </subscript></highlight>being zero. The bits f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field are all binary ones. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> The infinity format <highlight><bold>75</bold></highlight> provides a mechanism by which the divider unit <highlight><bold>10</bold></highlight> can indicate that the result is infinite. In the infinity format <highlight><bold>75</bold></highlight>, the sign bit &ldquo;s&rdquo; indicates whether the result is positive or negative, the bits e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb </subscript></highlight>of the exponent field are all binary ones, and the bits f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb&plus;5 </subscript></highlight>of the fraction field are all binary zero&apos;s. The five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field are flags, which will be described below. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> The NaN format <highlight><bold>76</bold></highlight> provides a mechanism by which the divider unit can indicate that the result is not a number. In the NaN format the sign bit &ldquo;s&rdquo; can be any value, the bits e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb </subscript></highlight>of the exponent field are all binary ones, and the bits f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb&plus;5 </subscript></highlight>of the fraction field are not all binary zero&apos;s. The five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field are flags, which will be described below. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> As noted above, in values represented in the infinity format <highlight><bold>75</bold></highlight> and the NaN format <highlight><bold>76</bold></highlight>, the five low order bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field are flags. In the formats used with the divider unit <highlight><bold>10</bold></highlight>, the five flags include the flags that are defined by IEEE Std. 754, including an invalid operation flag &ldquo;n,&rdquo; an overflow flag &ldquo;o,&rdquo; an underflow flag &ldquo;u,&rdquo; a division-by-zero flag &ldquo;z,&rdquo; and an inexact flag &ldquo;x.&rdquo; For example, a value in the NaN format <highlight><bold>76</bold></highlight> in which both the overflow flag &ldquo;o&rdquo; and the division-by-zero flag &ldquo;z&rdquo; are set indicates that the value represents a result of a computation that involved an overflow (this from the overflow flag &ldquo;o&rdquo;), as well as an attempt to divide by zero (this from the division-by-zero flag &ldquo;z&rdquo;). It should be noted that the flags provide the same status information as provided by, for example, information stored in a floating point status register in a conventional floating point unit, but, since the information is provided as part of the result and stored therewith in registers in which the result is ultimately stored, multiple instructions can be contemporaneously executed. This is because the floating point status information that may be generated during execution of one instruction, when stored, will not over-write previously-stored floating point status information generated during execution of another instruction. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> In addition to including status information in the five low-order bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field for values in the NaN format <highlight><bold>76</bold></highlight>, other information can also be encoded in the next five low-order bits f<highlight><subscript>lsb&plus;9 </subscript></highlight>. . . f<highlight><subscript>lsb&plus;5</subscript></highlight>. If the value in the NaN format <highlight><bold>76</bold></highlight> is the result of an operation, the other information indicates the operation and types of operands that gave rise to the result. In one embodiment, the other information is associated with binary encoded values (BEV) of those bits f<highlight><subscript>lsb&plus;9 </subscript></highlight>. . . f<highlight><subscript>lsb&plus;5 </subscript></highlight>as follows:  
<table-cwu id="TABLE-US-00001">
<number>1</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="119PT" align="left"/>
<colspec colname="2" colwidth="70PT" align="left"/>
<colspec colname="3" colwidth="91PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Bit Pattern Of Result</entry>
<entry>BEV of f<highlight><subscript>lsb&plus;9</subscript></highlight>. . . f<highlight><subscript>lsb&plus;5</subscript></highlight></entry>
<entry>Meaning</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
<entry>0 or 1</entry>
<entry>no specific meaning</entry>
</row>
<row>
<entry>s 111111111 00000000000000010nouzx</entry>
<entry>2</entry>
<entry>infinity minus infinity</entry>
</row>
<row>
<entry>s 111111111 00000000000000011nouzx</entry>
<entry>3</entry>
<entry>OV minus OV</entry>
</row>
<row>
<entry>s 111111111 00000000000000100nouzx</entry>
<entry>4</entry>
<entry>zero times infinity</entry>
</row>
<row>
<entry>s 111111111 00000000000000101nouzx</entry>
<entry>5</entry>
<entry>UN times OV</entry>
</row>
<row>
<entry></entry>
<entry>6 or 7</entry>
<entry>no specific meaning</entry>
</row>
<row>
<entry>s 111111111 00000000000001000nouzx</entry>
<entry>8</entry>
<entry>zero divided by zero</entry>
</row>
<row>
<entry>s 111111111 00000000000001001nouzx</entry>
<entry>9</entry>
<entry>infinity divided by infinity</entry>
</row>
<row>
<entry>s 111111111 00000000000001010nouzx</entry>
<entry>10</entry>
<entry>UN divided by UN</entry>
</row>
<row>
<entry>s 111111111 00000000000001011nouzx</entry>
<entry>11</entry>
<entry>OV divided by OV</entry>
</row>
<row>
<entry>s 111111111 00000000000001100nouzx</entry>
<entry>12</entry>
<entry>square root of less than zero</entry>
</row>
<row>
<entry></entry>
<entry>13-16</entry>
<entry>no specific meaning</entry>
</row>
<row>
<entry>s 111111111 00000000000010001nouzx</entry>
<entry>17</entry>
<entry>remainder by zero</entry>
</row>
<row>
<entry>s 111111111 00000000000010010nouzx</entry>
<entry>18</entry>
<entry>remainder by UN</entry>
</row>
<row>
<entry>s 111111111 00000000000010011nouzx</entry>
<entry>19</entry>
<entry>remainder by OV</entry>
</row>
<row>
<entry>s 111111111 00000000000010100nouzx</entry>
<entry>20</entry>
<entry>remainder of infinity</entry>
</row>
<row>
<entry>s 111111111 00000000000010101nouzx</entry>
<entry>21</entry>
<entry>remainder of infinity by zero</entry>
</row>
<row>
<entry>s 111111111 00000000000010110nouzx</entry>
<entry>22</entry>
<entry>remainder of infinity by UN</entry>
</row>
<row>
<entry>s 111111111 00000000000010111nouzx</entry>
<entry>23</entry>
<entry>remainder of infinity by OV</entry>
</row>
<row>
<entry>s 111111111 00000000000011000nouzx</entry>
<entry>24</entry>
<entry>remainder of OV</entry>
</row>
<row>
<entry>s 111111111 00000000000011001nouzx</entry>
<entry>25</entry>
<entry>remainder of OV by zero</entry>
</row>
<row>
<entry>s 111111111 00000000000011010nouzx</entry>
<entry>26</entry>
<entry>remainder of OV by UN</entry>
</row>
<row>
<entry>s 111111111 00000000000011011nouzx</entry>
<entry>27</entry>
<entry>remainder of OV by OV</entry>
</row>
<row>
<entry></entry>
<entry>28-31</entry>
<entry>no specific meaning</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0057" lvl="7"><number>&lsqb;0057&rsqb;</number> In the following, it will be assumed that the formats represent thirty-two bit values; extension to, for example, sixty-four bit values or values represented in other numbers of bits will be readily apparent to those skilled in the art. Additionally, &ldquo;OV&rdquo; refers to an operand in the overflow format <highlight><bold>74</bold></highlight>, &ldquo;UN&rdquo; refers to an operand in the underflow format <highlight><bold>71</bold></highlight> and &ldquo;infinity&rdquo; refers to an operand in the infinity format <highlight><bold>75</bold></highlight>. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> In addition, it will be convenient in the following to have names for the finite nonzero numbers that are adjacent to &plus;OV (a value in the overflow pattern with the sign bit &ldquo;s&rdquo; having the value &ldquo;zero&rdquo; indicating a positive value), &minus;OV (a value in the overflow pattern with the sign bit &ldquo;s&rdquo; having the value &ldquo;one,&rdquo; indicating a negative value), &plus;UN (a value in the underflow pattern with the sign bit &ldquo;s&rdquo; having the value &ldquo;zero,&rdquo; indicting a positive value), and &minus;UN (a value in the underflow pattern with the sign bit &ldquo;s&rdquo; having the value &ldquo;one,&rdquo; indicating a negative value), as follows:  
<table-cwu id="TABLE-US-00002">
<number>2</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="161PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<thead>
<row>
<entry></entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lsqb;055&rsqb; 0 00000000 00000000000000000000010</entry>
<entry>&plus;TINY</entry>
</row>
<row>
<entry></entry>
<entry>&lsqb;056&rsqb; 1 00000000 00000000000000000000010</entry>
<entry>&minus;TINY</entry>
</row>
<row>
<entry></entry>
<entry>&lsqb;057&rsqb; 0 11111110 11111111111111111111110</entry>
<entry>&plus;HUGE</entry>
</row>
<row>
<entry></entry>
<entry>&lsqb;058&rsqb; 1 11111110 11111111111111111111110</entry>
<entry>&minus;HUGE</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> Generally, &plus;OV can be deemed to refer to &ldquo;some (or any) value that is strictly between &plus;HUGE and &plus;&infin;&rdquo; and &plus;UN can be deemed to refer to &ldquo;some (or any) value that is strictly between &plus;0 and &plus;TINY&rdquo;. Similarly, &minus;OV can be deemed to refer to &ldquo;some (or any) value that is strictly between &minus;HUGE and &minus;&infin;&rdquo; and &minus;UN can be deemed to refer to &ldquo;some (or any) value that is strictly between &minus;0 and &minus;TINY.&rdquo;</paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> With this background, the structure and operation of the exemplary divider unit <highlight><bold>10</bold></highlight> will be described in connection with <cross-reference target="DRAWINGS">FIG. 1</cross-reference> and consistent with an embodiment of the invention. With reference to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, the exemplary divider unit <highlight><bold>10</bold></highlight> includes two operand buffers <highlight><bold>11</bold></highlight>A and <highlight><bold>11</bold></highlight>B, respective operand analysis circuits <highlight><bold>12</bold></highlight>A and <highlight><bold>12</bold></highlight>B, a divider core <highlight><bold>13</bold></highlight>, a result assembler <highlight><bold>14</bold></highlight> and a divider decision table logic circuit <highlight><bold>15</bold></highlight>. The operand buffers <highlight><bold>11</bold></highlight>A and <highlight><bold>11</bold></highlight>B receive and store respective operands from, for example, a set of registers (not shown) in a conventional manner. The divider core <highlight><bold>13</bold></highlight> receives the operands from the operand buffers <highlight><bold>11</bold></highlight>A and <highlight><bold>11</bold></highlight>B, except as described below, and rounding mode information from, for example, a rounding mode store <highlight><bold>16</bold></highlight>. The divider core <highlight><bold>13</bold></highlight> then generates a result in accordance with IEEE Std. 754. Divider core <highlight><bold>13</bold></highlight> is conventional and will not be described in detail herein. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> Each operand analysis circuit <highlight><bold>12</bold></highlight>A, <highlight><bold>12</bold></highlight>B analyzes the operand in the respective buffers <highlight><bold>11</bold></highlight>A, <highlight><bold>11</bold></highlight>B and generates signals providing information relating thereto, which signals are provided to the divider decision table logic circuit <highlight><bold>15</bold></highlight>. The result assembler <highlight><bold>14</bold></highlight> receives information from a number of sources, including the operand buffers <highlight><bold>11</bold></highlight>A and <highlight><bold>11</bold></highlight>B, divider core <highlight><bold>13</bold></highlight> and several predetermined value stores as described below. Under control of control signals from the divider decision table logic circuit <highlight><bold>15</bold></highlight>, the result assembler <highlight><bold>14</bold></highlight> assembles the result which is provided on a result bus <highlight><bold>17</bold></highlight>. The result bus <highlight><bold>17</bold></highlight>, in turn, may deliver the result to any convenient destination, such as a register in a register set (not shown), for storage or other use. </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> The system for providing a floating point division may comprise an analyzer circuit configured to determine a first status of a first floating point operand and a second status of a second floating point operand based upon data within the first floating point operand and the second floating point operand, respectively. In one embodiment, the analyzer circuit includes buffers <highlight><bold>11</bold></highlight>A, <highlight><bold>11</bold></highlight>B and analysis circuits <highlight><bold>12</bold></highlight>A, <highlight><bold>12</bold></highlight>B. In addition, the system for providing a floating point division includes a results circuit coupled to the analyzer circuit and is responsive to at least one control signal. The results circuit is configured to assert a resulting floating point operand containing the results of a division of the first floating point operand and the second floating point operand and a resulting status embedded within the resulting floating point operand. The results circuit may be implemented with a divider circuit (comprising the divider core <highlight><bold>13</bold></highlight>), the divider decision logic table circuit <highlight><bold>15</bold></highlight>, and result assembler <highlight><bold>14</bold></highlight>. </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> Those skilled in the art will appreciate that the invention may be practiced in an electrical circuit comprising discrete electronic elements, packaged or integrated electronic chips containing logic gates, a circuit utilizing a microprocessor, or on a single chip containing electronic elements or microprocessors. It may also be provided using other technologies capable of performing logical operations such as, for example, AND, OR, and NOT, including but not limited to mechanical, optical, fluidic, and quantum technologies. In addition, the invention may be practiced within a general purpose computer or in any other circuits or systems as are known by those skilled in the art. </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> As noted above, each operand analysis circuit <highlight><bold>12</bold></highlight>A, <highlight><bold>12</bold></highlight>B analyzes the operand in the respective buffers <highlight><bold>11</bold></highlight>A, <highlight><bold>11</bold></highlight>B and generates signals providing information relating thereto. These signals are provided to the divider decision table logic circuit <highlight><bold>15</bold></highlight>. In the exemplary embodiment, each operand analysis circuit <highlight><bold>12</bold></highlight>A, <highlight><bold>12</bold></highlight>B is implemented with a number of comparators, including: </paragraph>
<paragraph id="P-0065" lvl="2"><number>&lsqb;0065&rsqb;</number> (i) a comparator <highlight><bold>20</bold></highlight>A, <highlight><bold>20</bold></highlight>B that generates an asserted signal if the bits e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb </subscript></highlight>of the exponent field of the operand in respective buffers <highlight><bold>11</bold></highlight>A, <highlight><bold>11</bold></highlight>B are all binary one&apos;s, which will be the case if the operand is in the infinity format <highlight><bold>75</bold></highlight> or the NaN format <highlight><bold>76</bold></highlight>; </paragraph>
<paragraph id="P-0066" lvl="2"><number>&lsqb;0066&rsqb;</number> (ii) a comparator <highlight><bold>21</bold></highlight>A, <highlight><bold>21</bold></highlight>B that generates an asserted signal if the bits e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb&plus;1 </subscript></highlight>of the exponent field of the operand in the respective buffers <highlight><bold>11</bold></highlight>A, <highlight><bold>11</bold></highlight>B are all binary one&apos;s and the bit e<highlight><subscript>lsb </subscript></highlight>is a binary zero, which will be the case if the operand is in the overflow format <highlight><bold>74</bold></highlight>; </paragraph>
<paragraph id="P-0067" lvl="2"><number>&lsqb;0067&rsqb;</number> (iii) a comparator <highlight><bold>22</bold></highlight>A, <highlight><bold>22</bold></highlight>B that generates an asserted signal if the bits e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb&plus;1 </subscript></highlight>of the exponent field of the operand in respective buffers <highlight><bold>11</bold></highlight>A, <highlight><bold>11</bold></highlight>B are all binary one&apos;s and the bit e<highlight><subscript>lsb </subscript></highlight>is either a binary one or a binary zero, which will be the case if the operand is in the overflow format <highlight><bold>74</bold></highlight>, infinity format <highlight><bold>75</bold></highlight> or the NaN format <highlight><bold>76</bold></highlight>; </paragraph>
<paragraph id="P-0068" lvl="2"><number>&lsqb;0068&rsqb;</number> (iv) a comparator <highlight><bold>23</bold></highlight>A, <highlight><bold>23</bold></highlight>B that generates an asserted signal if the bit e<highlight><subscript>msb </subscript></highlight>of the exponent field of the operand in respective buffers <highlight><bold>11</bold></highlight>A, <highlight><bold>11</bold></highlight>B is a binary one and respective bits e<highlight><subscript>msb&minus;1 </subscript></highlight>. . . e<highlight><subscript>lsb </subscript></highlight>are either binary one or a binary zero, which may be the case if the operand is in the normalized non-zero format <highlight><bold>73</bold></highlight>, and will be the case if the operand is in the overflow format <highlight><bold>74</bold></highlight>, infinity format <highlight><bold>75</bold></highlight> or NaN format <highlight><bold>76</bold></highlight>; </paragraph>
<paragraph id="P-0069" lvl="2"><number>&lsqb;0069&rsqb;</number> (v) a comparator <highlight><bold>24</bold></highlight>A, <highlight><bold>24</bold></highlight>B that generates an asserted signal if the bit e<highlight><subscript>msb </subscript></highlight>of the exponent field of the operand in respective buffers <highlight><bold>11</bold></highlight>A, <highlight><bold>11</bold></highlight>B is a binary zero and bits e<highlight><subscript>msb&minus;1 </subscript></highlight>. . . e<highlight><subscript>lsb </subscript></highlight>are all binary one&apos;s, which may be the case if the operand is in the normalized non-zero format <highlight><bold>73</bold></highlight> and will be the case if the operand has the value &plus;1.0 or &minus;1.0; </paragraph>
<paragraph id="P-0070" lvl="2"><number>&lsqb;0070&rsqb;</number> (vi) a comparator <highlight><bold>25</bold></highlight>A, <highlight><bold>25</bold></highlight>B that generates an asserted signal if the bit e<highlight><subscript>msb </subscript></highlight>of the exponent field of the operand in respective buffers <highlight><bold>11</bold></highlight>A, <highlight><bold>11</bold></highlight>B is a binary zero and respective bits e<highlight><subscript>msb&minus;1 </subscript></highlight>. . . e<highlight><subscript>lsb </subscript></highlight>are either binary one or binary zero, which will be the case if the operand is in the zero format <highlight><bold>70</bold></highlight>, underflow format <highlight><bold>71</bold></highlight> or denormalized format <highlight><bold>72</bold></highlight>, and may be the case if the operand is in the normalized non-zero format <highlight><bold>73</bold></highlight>; </paragraph>
<paragraph id="P-0071" lvl="2"><number>&lsqb;0071&rsqb;</number> (vii) a comparator <highlight><bold>26</bold></highlight>A, <highlight><bold>26</bold></highlight>B that generates an asserted signal if the bit e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb </subscript></highlight>of the exponent field of the operand in respective buffers <highlight><bold>11</bold></highlight>A, <highlight><bold>11</bold></highlight>B are all binary zero&apos;s, which will be the case if the operand is in the zero format <highlight><bold>70</bold></highlight>, underflow format <highlight><bold>71</bold></highlight>, or denormalized format <highlight><bold>72</bold></highlight>; </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> (viii) a comparator <highlight><bold>30</bold></highlight>A, <highlight><bold>30</bold></highlight>B that generates an asserted signal if the bits f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb&plus;5 </subscript></highlight>of the fraction field of the operand in the respective buffers <highlight><bold>11</bold></highlight>A, <highlight><bold>11</bold></highlight>B are all binary one&apos;s, which may be the case if the operand is in the denormalized format <highlight><bold>72</bold></highlight>, normalized non-zero format <highlight><bold>73</bold></highlight>, overflow format <highlight><bold>74</bold></highlight>, or NaN format <highlight><bold>76</bold></highlight>; </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> (ix) a comparator <highlight><bold>31</bold></highlight>A, <highlight><bold>31</bold></highlight>B that generates an asserted signal if the bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb&plus;5 </subscript></highlight>of the fraction field of the operand in the respective buffers <highlight><bold>11</bold></highlight>A, <highlight><bold>11</bold></highlight>B are all binary zero&apos;s, which may be the case if the operand is in the zero format <highlight><bold>70</bold></highlight>, underflow format <highlight><bold>72</bold></highlight>, denormalized format <highlight><bold>72</bold></highlight>, normalized non-zero format <highlight><bold>73</bold></highlight> or infinity format <highlight><bold>75</bold></highlight>; </paragraph>
<paragraph id="P-0074" lvl="2"><number>&lsqb;0074&rsqb;</number> (x) a comparator <highlight><bold>32</bold></highlight>A, <highlight><bold>32</bold></highlight>B that generates an asserted signal if the bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the operand in the respective buffers <highlight><bold>11</bold></highlight>A, <highlight><bold>11</bold></highlight>B are all binary one&apos;s, which may be the case if the operand is in the denormalized format <highlight><bold>72</bold></highlight> or normalized non-zero format <highlight><bold>73</bold></highlight> and which will be the case if the operand is in the overflow format <highlight><bold>74</bold></highlight>, or if all of the flags &ldquo;n,&rdquo; &ldquo;o,&rdquo; &ldquo;u,&rdquo; &ldquo;z,&rdquo; and &ldquo;x&rdquo; are set in the infinity format <highlight><bold>75</bold></highlight> or NaN format <highlight><bold>76</bold></highlight>; </paragraph>
<paragraph id="P-0075" lvl="2"><number>&lsqb;0075&rsqb;</number> (xi) a comparator <highlight><bold>33</bold></highlight>A, <highlight><bold>33</bold></highlight>B that generates an asserted signal if the bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb&plus;1 </subscript></highlight>of the fraction field of the operand in the respective buffers <highlight><bold>11</bold></highlight>A, <highlight><bold>11</bold></highlight>B are all binary zero&apos;s and if the bit f<highlight><subscript>lsb </subscript></highlight>of the fraction field is either a binary &ldquo;zero&rdquo; or &ldquo;one,&rdquo; which will be the case if the operand is in the zero format <highlight><bold>70</bold></highlight> or underflow format <highlight><bold>71</bold></highlight> and which may be the case if the operand is in the denormalized format <highlight><bold>72</bold></highlight>, normalized non-zero format <highlight><bold>73</bold></highlight>, overflow format <highlight><bold>74</bold></highlight>, or if the flags &ldquo;n,&rdquo; &ldquo;o&rdquo; &ldquo;u,&rdquo; and &ldquo;z&rdquo; are clear and the flag &ldquo;x&rdquo; is either set or clear in the infinity format <highlight><bold>75</bold></highlight> or NaN format <highlight><bold>76</bold></highlight>; </paragraph>
<paragraph id="P-0076" lvl="2"><number>&lsqb;0076&rsqb;</number> (xii) a comparator <highlight><bold>34</bold></highlight>A, <highlight><bold>34</bold></highlight>B that generates an asserted signal if the bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb&plus;1 </subscript></highlight>of the fraction field of the operand in the respective buffers <highlight><bold>11</bold></highlight>A, <highlight><bold>11</bold></highlight>B are binary zero&apos;s and if the bit f<highlight><subscript>lsb </subscript></highlight>of the fraction field is a binary &ldquo;one,&rdquo; which will be the case if the operand is in the underflow format <highlight><bold>71</bold></highlight> and which may be the case if the operand is in the denormalized format <highlight><bold>72</bold></highlight>, normalized non-zero format <highlight><bold>73</bold></highlight>, overflow format <highlight><bold>74</bold></highlight>, or if the flags &ldquo;n,&rdquo; &ldquo;o,&rdquo; &ldquo;u,&rdquo; and &ldquo;z&rdquo; are clear and the flag &ldquo;x&rdquo; is set in infinity format <highlight><bold>75</bold></highlight> or NaN format <highlight><bold>76</bold></highlight>; and </paragraph>
<paragraph id="P-0077" lvl="2"><number>&lsqb;0077&rsqb;</number> (xiii) a comparator <highlight><bold>35</bold></highlight>A, <highlight><bold>35</bold></highlight>B that generates an asserted signal if all of the bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb&plus;1 </subscript></highlight>of the fraction field of the operand in the respective buffers <highlight><bold>11</bold></highlight>A, <highlight><bold>11</bold></highlight>B are binary zero&apos;s which will be the case if the operand is in the zero format <highlight><bold>70</bold></highlight>, and which may be the case if the operand is in the denormalized format <highlight><bold>72</bold></highlight> normalized non-zero format <highlight><bold>73</bold></highlight>, overflow format <highlight><bold>74</bold></highlight>, or if the flags &ldquo;n,&rdquo; &ldquo;o,&rdquo; &ldquo;u,&rdquo; &ldquo;z&rdquo; and &ldquo;x&rdquo; are clear in the infinity format 75 or NaN format 76. </paragraph>
<paragraph id="P-0078" lvl="0"><number>&lsqb;0078&rsqb;</number> In the illustrated embodiment, each exemplary operand analysis circuit <highlight><bold>12</bold></highlight>A, <highlight><bold>12</bold></highlight>B also includes combinatorial logic elements that receive selected ones of the signals from the comparators and generate characteristic signals to provide indications as to certain characteristics of the respective operand. In more detail, such combinatorial logic elements include: </paragraph>
<paragraph id="P-0079" lvl="2"><number>&lsqb;0079&rsqb;</number> (xiv) an AND gate <highlight><bold>50</bold></highlight>A, <highlight><bold>50</bold></highlight>B, which will generate an asserted signal if comparators <highlight><bold>31</bold></highlight>A, <highlight><bold>31</bold></highlight>B, and <highlight><bold>35</bold></highlight>A, <highlight><bold>35</bold></highlight>B, are both generating asserted signals, which will be the case if the bits f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the operand in the respective operand buffers <highlight><bold>11</bold></highlight>A, <highlight><bold>11</bold></highlight>B have the bit pattern 00000000000000000000000; </paragraph>
<paragraph id="P-0080" lvl="2"><number>&lsqb;0080&rsqb;</number> (xv) an AND gate <highlight><bold>51</bold></highlight>A, <highlight><bold>51</bold></highlight>B, which will generate an asserted signal if comparators <highlight><bold>31</bold></highlight>A, <highlight><bold>31</bold></highlight>B, and <highlight><bold>34</bold></highlight>A, <highlight><bold>34</bold></highlight>B, are both generating asserted signals, which will be the case if the bit f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the operand in the respective operand buffers <highlight><bold>11</bold></highlight>A, <highlight><bold>11</bold></highlight>B have the bit pattern 00000000000000000000001; </paragraph>
<paragraph id="P-0081" lvl="2"><number>&lsqb;0081&rsqb;</number> (xvi) an AND gate <highlight><bold>52</bold></highlight>A, <highlight><bold>52</bold></highlight>B, which will generate an asserted signal if comparators <highlight><bold>30</bold></highlight>A, <highlight><bold>30</bold></highlight>B, and <highlight><bold>32</bold></highlight>A, <highlight><bold>32</bold></highlight>B are both generating asserted signals, which will be the case if the bits f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the operand in the respective operand buffers <highlight><bold>11</bold></highlight>A, <highlight><bold>11</bold></highlight>B have the bit pattern 1111111111111111111111; </paragraph>
<paragraph id="P-0082" lvl="2"><number>&lsqb;0082&rsqb;</number> (xvii) an AND gate <highlight><bold>40</bold></highlight>A, <highlight><bold>40</bold></highlight>B that generates an asserted signal if the signals generated by both comparator <highlight><bold>31</bold></highlight>A, <highlight><bold>31</bold></highlight>B and comparator <highlight><bold>33</bold></highlight>A, <highlight><bold>33</bold></highlight>B are asserted, which will be the case if the respective operand is in the zero format <highlight><bold>70</bold></highlight> or underflow format <highlight><bold>71</bold></highlight> and which may be the case if the operand is in the denormalized format <highlight><bold>72</bold></highlight>, normalized non-zero format <highlight><bold>73</bold></highlight>, or if the flags &ldquo;n,&rdquo; &ldquo;o,&rdquo; &ldquo;u,&rdquo; and &ldquo;z&rdquo; are clear and the flag &ldquo;x&rdquo; is either set or clear in the infinity format <highlight><bold>75</bold></highlight>; otherwise stated, AND gate <highlight><bold>40</bold></highlight>A, <highlight><bold>40</bold></highlight>B will generate an asserted signal if the value of the bits f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the operand in the respective operand buffers <highlight><bold>11</bold></highlight>A, <highlight><bold>11</bold></highlight>B has the bit pattern 00000000000000000000001 or 00000000000000000000000; </paragraph>
<paragraph id="P-0083" lvl="2"><number>&lsqb;0083&rsqb;</number> (xviii) a NAND gate <highlight><bold>41</bold></highlight>A, <highlight><bold>41</bold></highlight>B that generates an asserted signal if the signal generated by comparator <highlight><bold>26</bold></highlight>A, <highlight><bold>26</bold></highlight>B is asserted and the signal generated by AND gate <highlight><bold>40</bold></highlight>A and <highlight><bold>40</bold></highlight>B is negated, which will be the case if the respective operand is in the denormalized format <highlight><bold>72</bold></highlight>; otherwise stated, NAND gate <highlight><bold>41</bold></highlight>A, <highlight><bold>41</bold></highlight>B will generate an asserted signal if the bits e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb </subscript></highlight>of the exponent field of the operand in the respective operand buffers <highlight><bold>11</bold></highlight>A, <highlight><bold>11</bold></highlight>B have the pattern 00000000 and a bit of the fraction field, other than the low order bit f<highlight><subscript>lsb</subscript></highlight>, is a &ldquo;one;&rdquo;</paragraph>
<paragraph id="P-0084" lvl="2"><number>&lsqb;0084&rsqb;</number> (xix) a NAND gate <highlight><bold>42</bold></highlight>A, <highlight><bold>42</bold></highlight>B that generates an asserted signal if the signal generated by comparator <highlight><bold>24</bold></highlight>A, <highlight><bold>24</bold></highlight>B is negated and the signal generated by comparator <highlight><bold>25</bold></highlight>A, <highlight><bold>25</bold></highlight>B is asserted and the signal generated by comparator <highlight><bold>26</bold></highlight>A, <highlight><bold>26</bold></highlight>B is negated which will be the case if the respective operand is in the normalized format <highlight><bold>73</bold></highlight> and its magnitude is less than 1.0; otherwise stated, NAND gate <highlight><bold>42</bold></highlight>A, <highlight><bold>42</bold></highlight>B will generate an asserted signal if the high-order bit e<highlight><subscript>msb </subscript></highlight>of the exponent field of the operand in the respective operand buffers <highlight><bold>11</bold></highlight>A, <highlight><bold>11</bold></highlight>B is a &ldquo;zero,&rdquo; but the bits e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb </subscript></highlight>of the exponent field of the operand in the respective operand buffers <highlight><bold>11</bold></highlight>A, <highlight><bold>11</bold></highlight>B do not have the bit pattern 00000000 or 01111111; </paragraph>
<paragraph id="P-0085" lvl="2"><number>&lsqb;0085&rsqb;</number> (xx) an OR gate <highlight><bold>43</bold></highlight>A, <highlight><bold>43</bold></highlight>B that generates an asserted signal if either NAND gate <highlight><bold>41</bold></highlight>A, <highlight><bold>41</bold></highlight>B or NAND gate <highlight><bold>42</bold></highlight>A, <highlight><bold>42</bold></highlight>B is asserted, which will be the case if the bits e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb </subscript></highlight>of the exponent field of the operand in the respective operand buffers <highlight><bold>11</bold></highlight>A, <highlight><bold>11</bold></highlight>B have the pattern 00000000 and a bit of the fraction field, other than the low order bit f<highlight><subscript>msb </subscript></highlight>is a &ldquo;zero&rdquo; (NAND gate <highlight><bold>41</bold></highlight>A, <highlight><bold>41</bold></highlight>B) or if the high-order bit e<highlight><subscript>msb </subscript></highlight>of the exponent field is a &ldquo;one,&rdquo; and the bits e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb </subscript></highlight>of the exponent field of the operand in the respective operand buffers <highlight><bold>11</bold></highlight>A, <highlight><bold>11</bold></highlight>B do not have the bit pattern 00000000 or 01111111 (NAND gate <highlight><bold>42</bold></highlight>A, <highlight><bold>42</bold></highlight>B); </paragraph>
<paragraph id="P-0086" lvl="2"><number>&lsqb;0086&rsqb;</number> (xxi) an AND gate <highlight><bold>44</bold></highlight>A, <highlight><bold>44</bold></highlight>B that generates an asserted signal if comparator <highlight><bold>24</bold></highlight>A, <highlight><bold>24</bold></highlight>B is generating an asserted signal and AND gate <highlight><bold>50</bold></highlight>A, <highlight><bold>50</bold></highlight>B is generating an asserted signal, which will be the case if the bits e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb </subscript></highlight>of the exponent field of the operand in the same operand buffers <highlight><bold>11</bold></highlight>A, <highlight><bold>11</bold></highlight>B have the bit pattern 01111111 and the bits f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the operand in the respective operand buffers <highlight><bold>11</bold></highlight>A, <highlight><bold>11</bold></highlight>B have the bit pattern 0000000000000000000000; </paragraph>
<paragraph id="P-0087" lvl="2"><number>&lsqb;0087&rsqb;</number> (xxii) a NAND gate <highlight><bold>45</bold></highlight>A, <highlight><bold>45</bold></highlight>B that generates an asserted signal if comparator <highlight><bold>24</bold></highlight>A, <highlight><bold>24</bold></highlight>B is generating an asserted signal and AND gate <highlight><bold>50</bold></highlight>A, <highlight><bold>50</bold></highlight>B is generating a negated signal, which will be the case if the bits e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb </subscript></highlight>of the exponent field of the operand in law respective operand buffers <highlight><bold>11</bold></highlight>A, <highlight><bold>11</bold></highlight>B have the bit pattern 01111111 and at least one bit f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the operand in the respective operand buffers <highlight><bold>11</bold></highlight>A, <highlight><bold>11</bold></highlight>B is &ldquo;one;&rdquo;</paragraph>
<paragraph id="P-0088" lvl="2"><number>&lsqb;0088&rsqb;</number> (xxiii) a NAND gate <highlight><bold>46</bold></highlight>A, <highlight><bold>46</bold></highlight>B that generates an asserted signal if comparator <highlight><bold>23</bold></highlight>A, <highlight><bold>23</bold></highlight>B is generating an asserted signal and comparator <highlight><bold>22</bold></highlight>A, <highlight><bold>22</bold></highlight>B is generating a negated signal, which will be the case if the bits e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb </subscript></highlight>of the exponent field of the operand in the respective operand buffers <highlight><bold>11</bold></highlight>A, <highlight><bold>11</bold></highlight>B does not have either bit pattern 11111110 or 11111111, but the high-order bit of the e<highlight><subscript>msb </subscript></highlight>exponent field of the operand in the respective operand buffers <highlight><bold>11</bold></highlight>A, <highlight><bold>11</bold></highlight>B is &ldquo;one;&rdquo;</paragraph>
<paragraph id="P-0089" lvl="2"><number>&lsqb;0089&rsqb;</number> (xxiv) a NAND gate <highlight><bold>47</bold></highlight>A, <highlight><bold>47</bold></highlight>B, which will generate an asserted signal if comparator <highlight><bold>21</bold></highlight>A, <highlight><bold>21</bold></highlight>B is generating an asserted signal and AND gate <highlight><bold>52</bold></highlight>A, <highlight><bold>52</bold></highlight>B is generating a negated signal, which will be the case if the bits e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb </subscript></highlight>of the exponent field of the operand in the respective operand buffers <highlight><bold>11</bold></highlight>A, <highlight><bold>11</bold></highlight>B have a bit pattern 11111110 and not all bits f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the operand in the respective operand buffers <highlight><bold>11</bold></highlight>A, <highlight><bold>11</bold></highlight>B are &ldquo;one,&rdquo; so that the NAND gate <highlight><bold>47</bold></highlight>A, <highlight><bold>47</bold></highlight>B will generate an asserted signal if the bits e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb </subscript></highlight>of the exponent field of the operand in the respective operand buffers <highlight><bold>11</bold></highlight>A, <highlight><bold>11</bold></highlight>B have the bit pattern 11111110 and at least one of the bits f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the operand in the respective operand buffers <highlight><bold>11</bold></highlight>A, <highlight><bold>11</bold></highlight>B is &ldquo;zero;&rdquo; and </paragraph>
<paragraph id="P-0090" lvl="2"><number>&lsqb;0090&rsqb;</number> (xxv) an OR gate <highlight><bold>48</bold></highlight>A, <highlight><bold>48</bold></highlight>B, which will generate an asserted signal if one or more of NAND gate <highlight><bold>45</bold></highlight>A, <highlight><bold>45</bold></highlight>B and NAND gate <highlight><bold>46</bold></highlight>A, <highlight><bold>46</bold></highlight>B and NAND gate <highlight><bold>47</bold></highlight>A, <highlight><bold>47</bold></highlight>B generates an asserted signal. </paragraph>
<paragraph id="P-0091" lvl="0"><number>&lsqb;0091&rsqb;</number> In addition, the combinatorial logic in the illustrated embodiment includes a comparator <highlight><bold>53</bold></highlight> that generates an asserted signal if the bits f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb&plus;5 </subscript></highlight>of the fraction field of the operand in operand buffer <highlight><bold>11</bold></highlight>A represent a binary-encoded value that is larger than the binary-encoded value represented by bits f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb&plus;5 </subscript></highlight>of the fraction field of the operand in operand buffer <highlight><bold>11</bold></highlight>B. The combinatorial logic also includes an XOR gate <highlight><bold>54</bold></highlight> that generates an asserted signal if the sign bits &ldquo;s&rdquo; of the operands in the operand buffers <highlight><bold>11</bold></highlight>A and <highlight><bold>11</bold></highlight>B have different values. </paragraph>
<paragraph id="P-0092" lvl="0"><number>&lsqb;0092&rsqb;</number> Each exemplary operand analysis circuit <highlight><bold>12</bold></highlight>A, <highlight><bold>12</bold></highlight>B provides signals to the divider decision table logic <highlight><bold>15</bold></highlight> as shown in the following table:  
<table-cwu id="TABLE-US-00003">
<number>3</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<thead>
<row>
<entry></entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
<entry>(a) the signal generated by comparator 26A, 26B</entry>
</row>
<row>
<entry></entry>
<entry>(b) the signal generated by the comparator 21A, 21B</entry>
</row>
<row>
<entry></entry>
<entry>(c) the signal generated by the comparator 20A, 20B</entry>
</row>
<row>
<entry></entry>
<entry>(d) the signal generated by comparator 31A, 31B</entry>
</row>
<row>
<entry></entry>
<entry>(e) the signal generated by AND gate 50A, 50B</entry>
</row>
<row>
<entry></entry>
<entry>(f) the signal generated by AND gate 51A, 51B</entry>
</row>
<row>
<entry></entry>
<entry>(g) the signal generated by AND gate 52A 52B</entry>
</row>
<row>
<entry></entry>
<entry>(h) the signal generated by the OR gate 43A, 43B</entry>
</row>
<row>
<entry></entry>
<entry>(i) the signal generated by the AND gate 44A, 44B</entry>
</row>
<row>
<entry></entry>
<entry>(j) the signal generated by the OR gate 48A, 48B</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0093" lvl="0"><number>&lsqb;0093&rsqb;</number> In addition, the signal generated by comparator <highlight><bold>53</bold></highlight> is provided to the divider decision table logic <highlight><bold>15</bold></highlight>, as are signals from rounding mode store <highlight><bold>16</bold></highlight> representative of the rounding mode and the signal generated by the XOR gate <highlight><bold>54</bold></highlight>. </paragraph>
<paragraph id="P-0094" lvl="0"><number>&lsqb;0094&rsqb;</number> In addition, the divider core <highlight><bold>13</bold></highlight> generates an overflow signal and an underflow signal, which are also provided to the divider decision table logic <highlight><bold>15</bold></highlight>. The underflow signal is asserted if and only if the mathematical quotient should be nonzero but the divider core produces a zero result (those skilled in the art will appreciate that this differs from the IEEE 754 definition of underflow). In the illustrated embodiment, the divider decision table logic <highlight><bold>15</bold></highlight> generates control signals for controlling the result assembler <highlight><bold>14</bold></highlight>. In addition, control signals generated by the divider decision table logic <highlight><bold>15</bold></highlight> control sets of XOR gates <highlight><bold>67</bold></highlight>A, <highlight><bold>67</bold></highlight>B; <highlight><bold>68</bold></highlight>A, <highlight><bold>68</bold></highlight>B that control toggling of one or both of the two least significant bits f<highlight><subscript>lsb</subscript></highlight>, . . . f<highlight><subscript>lsb&plus;1 </subscript></highlight>of the fraction field of the operands before they are provided to the divider core <highlight><bold>13</bold></highlight>. </paragraph>
<paragraph id="P-0095" lvl="0"><number>&lsqb;0095&rsqb;</number> As noted above, the result assembler <highlight><bold>14</bold></highlight> receives information from a number of sources, including the XOR gate <highlight><bold>54</bold></highlight>, the operand buffers <highlight><bold>11</bold></highlight>A and <highlight><bold>11</bold></highlight>B, divider core <highlight><bold>13</bold></highlight> and several predetermined value stores as described below. Under control of control signals from the divider decision table logic circuit <highlight><bold>15</bold></highlight>, the result assembler <highlight><bold>14</bold></highlight> assembles the appropriate result, representing a quotient of the two operands, onto a result bus <highlight><bold>17</bold></highlight>. In general, the result assembler <highlight><bold>14</bold></highlight> essentially assembles the result in four segments, including a sign segment that represents the sign bit of the result, an exponent segment that represents the exponent field of the result, a high-order fraction segment that represents the bits f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb&plus;5 </subscript></highlight>of the fraction field of the result, and a low-order fraction segment that represents the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the result. It will be appreciated that the low-order fraction segment in results in the infinity format <highlight><bold>75</bold></highlight> and NaN format <highlight><bold>76</bold></highlight> corresponds to the flags &ldquo;n,&rdquo; &ldquo;o,&rdquo; &ldquo;u,&rdquo; &ldquo;z&rdquo; and &ldquo;x.&rdquo; One or more of these segments will represent an embedded resulting status of the resulting floating point operand. </paragraph>
<paragraph id="P-0096" lvl="0"><number>&lsqb;0096&rsqb;</number> In the illustrated embodiment, the result assembler includes four elements, including a link from XOR gate <highlight><bold>54</bold></highlight>, an exponent field selector <highlight><bold>60</bold></highlight>, a high-order fraction field selector <highlight><bold>61</bold></highlight> and low-order fraction field combiner <highlight><bold>62</bold></highlight>. The link from XOR gate <highlight><bold>54</bold></highlight> provides the sign of the result. As is conventional, the sign of the result is positive, in which case the sign bit would have the value &ldquo;zero,&rdquo; if the sign bits of the operands in both operand buffers <highlight><bold>11</bold></highlight>A, <highlight><bold>11</bold></highlight>B are the same. On the other hand, the sign of the result is negative, in which case the sign bit would have the value &ldquo;one,&rdquo; if the sign bits of the operands in the operand buffers <highlight><bold>11</bold></highlight>A, <highlight><bold>11</bold></highlight>B differ. It will be appreciated that the XOR gate <highlight><bold>54</bold></highlight> generates a signal of the appropriate value for the sign bit for the result, which signal is coupled onto the result bus <highlight><bold>17</bold></highlight>. </paragraph>
<paragraph id="P-0097" lvl="0"><number>&lsqb;0097&rsqb;</number> As noted above, the exemplary selector <highlight><bold>60</bold></highlight> couples exponent value signals representative of the exponent field of the result to the result bus <highlight><bold>17</bold></highlight>. In this embodiment, the selector <highlight><bold>60</bold></highlight> receives four sets of exponent field value signals, namely, the signals from the divider core <highlight><bold>13</bold></highlight> associated with the exponent field, as well as three sets of signals representative of three predetermined exponent field bit patterns, such as the patterns depicted in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. It will be appreciated that these predetermined exponent field bit patterns correspond to the exponent fields associated with the zero format <highlight><bold>70</bold></highlight>, underflow format <highlight><bold>71</bold></highlight>, overflow format <highlight><bold>74</bold></highlight>, infinity format <highlight><bold>75</bold></highlight> and NaN format <highlight><bold>76</bold></highlight>. In addition, the selector <highlight><bold>60</bold></highlight> receives four exponent field control signals from the divider decision table logic <highlight><bold>15</bold></highlight>. One of these control signals is associated with the signals from the divider core <highlight><bold>13</bold></highlight> that are associated with the exponent field. The rest of these control signals are associated with each of the sets of exponent field value signals, respectively. In enabling the result assembler <highlight><bold>14</bold></highlight> to assemble the result, the divider decision table logic <highlight><bold>15</bold></highlight> will assert one of the four exponent field control signals. Additionally, the selector <highlight><bold>60</bold></highlight> will couple the set of exponent field value signals associated with the asserted exponent field control signal to the result bus <highlight><bold>17</bold></highlight> to provide the exponent field of the result. </paragraph>
<paragraph id="P-0098" lvl="0"><number>&lsqb;0098&rsqb;</number> The exemplary selector <highlight><bold>61</bold></highlight> couples high-order fraction field signals representative of the high-order fraction field bits f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb&plus;5 </subscript></highlight>of the fraction field of the result to the result bus <highlight><bold>17</bold></highlight>. In the illustrated embodiment, the selector <highlight><bold>61</bold></highlight> receives nine sets of high-order fraction field value signals, namely, the signals from the divider core <highlight><bold>13</bold></highlight> associated with the high-order fraction field, signals representative of bits f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb&plus;5 </subscript></highlight>of the fraction field of the operand in buffer <highlight><bold>11</bold></highlight>A, signals representative of bits f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb&plus;5 </subscript></highlight>of the fraction field of the operand in buffer <highlight><bold>11</bold></highlight>B, as well as six sets of signals representative of six predetermined high-order fraction field bit patterns such as the patterns depicted in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. It will be appreciated that these predetermined high-order fraction field bit patterns correspond to the high-order fraction fields associated with the zero format <highlight><bold>70</bold></highlight>, underflow format <highlight><bold>71</bold></highlight>, overflow format <highlight><bold>74</bold></highlight>, infinity format <highlight><bold>75</bold></highlight> and NaN format <highlight><bold>76</bold></highlight>. In addition, the selector <highlight><bold>61</bold></highlight> receives nine high-order fraction field control signals from the divider decision table logic <highlight><bold>15</bold></highlight>. One of these control signals is associated with the divider core <highlight><bold>13</bold></highlight>. The rest of these control signals are associated with each of the sets of high-order fraction field value signals, respectively. It will be appreciated that the control signal associated with the divider core <highlight><bold>13</bold></highlight> is the same control signal that controls the selector <highlight><bold>60</bold></highlight>. In enabling the result assembler <highlight><bold>14</bold></highlight> to assemble the result, the divider decision table logic will assert one of the nine high-order fraction field control signals, and the selector <highlight><bold>61</bold></highlight> will couple the set of high-order fraction field value signals associated with the asserted high-order fraction field control signal to the result bus <highlight><bold>17</bold></highlight> to provide bits f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb&plus;5 </subscript></highlight>of the fraction field of the result. </paragraph>
<paragraph id="P-0099" lvl="0"><number>&lsqb;0099&rsqb;</number> Similarly, the exemplary combiner <highlight><bold>62</bold></highlight> couples low-order fraction field value signals representative of the low-order fraction field bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result to the result bus <highlight><bold>17</bold></highlight>. The combiner <highlight><bold>62</bold></highlight> receives four sets of low-order fraction field signals, namely, the signals from the divider core <highlight><bold>13</bold></highlight> associated with the low-order fraction field, signals representative of bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the operand in buffer <highlight><bold>11</bold></highlight>A, signals representative of bits f<highlight><subscript>lsb </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the operand in buffer <highlight><bold>11</bold></highlight>B, and one set of signals from the divider decision table logic <highlight><bold>15</bold></highlight>. It will be appreciated that in the illustrated embodiment, the set of signals provided by the divider decision table logic <highlight><bold>15</bold></highlight> are used in controlling the condition of flags &ldquo;n,&rdquo; &ldquo;o,&rdquo; &ldquo;u,&rdquo; &ldquo;z,&rdquo; and &ldquo;x,&rdquo; for those formats in which the low order bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>represent flags. In addition, the sets of signals provided by the operands in buffers <highlight><bold>11</bold></highlight>A and <highlight><bold>11</bold></highlight>B may also represent the flags &ldquo;n,&rdquo; &ldquo;o,&rdquo; &ldquo;u,&rdquo; &ldquo;z,&rdquo; and &ldquo;x.&rdquo; In addition, the combiner <highlight><bold>62</bold></highlight> receives three low-order fraction field control signals from the divider decision table logic <highlight><bold>15</bold></highlight>. One control signal is associated with the set of low-order fraction field value signals provided by the divider core <highlight><bold>13</bold></highlight> and the two others are associated with the sets of signals provided by the buffers <highlight><bold>11</bold></highlight>A and <highlight><bold>11</bold></highlight>B. </paragraph>
<paragraph id="P-0100" lvl="0"><number>&lsqb;0100&rsqb;</number> In enabling the result assembler <highlight><bold>14</bold></highlight> to assemble the result, the divider decision table logic <highlight><bold>15</bold></highlight> may provide signals representative of the low-order fraction field and negate all of the low-order fraction field control signals. When this occurs, the signals representative of the low order fraction field provided by the divider decision table logic <highlight><bold>15</bold></highlight> will be coupled to the result bus <highlight><bold>13</bold></highlight> to provide bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result. </paragraph>
<paragraph id="P-0101" lvl="0"><number>&lsqb;0101&rsqb;</number> Alternatively, the divider decision table logic <highlight><bold>15</bold></highlight> may negate all of the low-order fraction field value signals provided thereby and assert one of the three low-order fraction field control signals. When this occurs, the combiner <highlight><bold>62</bold></highlight> will couple the set of low-order fraction field value signals associated with the asserted low-order fraction field control signal to the result bus <highlight><bold>17</bold></highlight> to provide bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result. As a further alternative, the divider decision table logic <highlight><bold>15</bold></highlight> may negate all of the low-order fraction field value signals provided thereby and assert more than one of the three low-order fraction field control signals. As a result, the combiner <highlight><bold>62</bold></highlight> will couple the bit-wise OR of the sets of low-order fraction field value signals associated with the asserted low-order fraction field control signals to the result bus <highlight><bold>17</bold></highlight> to provide bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result. As yet another alternative, the divider decision table logic <highlight><bold>15</bold></highlight> may assert one or more of the low-order fraction field value signals provided thereby and assert one or more of the three low-order fraction field control signals. As a result, the combiner <highlight><bold>62</bold></highlight> will couple the bit-wise OR of the sets of low-order fraction field value signals associated with the asserted low-order fraction field control signals and the low-order fraction field value signals provided by the divider decision table logic <highlight><bold>15</bold></highlight> to the result bus <highlight><bold>17</bold></highlight> to provide bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result. </paragraph>
<paragraph id="P-0102" lvl="0"><number>&lsqb;0102&rsqb;</number> In more detail, the exemplary combiner <highlight><bold>62</bold></highlight> in the illustrated embodiment comprises an OR circuit <highlight><bold>63</bold></highlight> and three AND circuits <highlight><bold>64</bold></highlight> through <highlight><bold>66</bold></highlight>. (Each gate in the diagram actually represents five such gates, one for each bit position f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>but for the sake of clarity and to avoid confusion, the diagram illustrates them as a single gate.) The AND circuits <highlight><bold>64</bold></highlight>-<highlight><bold>66</bold></highlight> receive the low-order fraction field value signals from the divider core <highlight><bold>13</bold></highlight> and operand buffers <highlight><bold>11</bold></highlight>A and <highlight><bold>11</bold></highlight>B respectively, as well as the respective low-order fraction field control signal. These AND circuits <highlight><bold>64</bold></highlight>-<highlight><bold>66</bold></highlight> perform a bit-wise AND operation to, if the respective low-order fraction field control signal is asserted, couple the low-order fraction field value signals to a respective input of OR circuit <highlight><bold>63</bold></highlight>. The OR circuit <highlight><bold>63</bold></highlight>, whose output is connected to the result bus <highlight><bold>17</bold></highlight>, performs a bit-wise OR operation in connection with the signals that it receives from the AND circuits <highlight><bold>64</bold></highlight>-<highlight><bold>66</bold></highlight> and the low-order fraction field value signals provided by the divider decision table logic <highlight><bold>15</bold></highlight>. If the divider decision table logic <highlight><bold>15</bold></highlight> negates all of the low-order fraction field control signals, the AND circuits <highlight><bold>64</bold></highlight>-<highlight><bold>66</bold></highlight> will block the low-order fraction field value signals that they receive, and the signals provided by the OR circuit <highlight><bold>63</bold></highlight> will conform to the low-order fraction field value signals provided by the divider decision table logic <highlight><bold>15</bold></highlight>. </paragraph>
<paragraph id="P-0103" lvl="0"><number>&lsqb;0103&rsqb;</number> On the other hand, if the divider decision table logic <highlight><bold>15</bold></highlight> asserts one or more of the low-order fraction field control signals, the AND circuits <highlight><bold>64</bold></highlight>-<highlight><bold>66</bold></highlight> that receive the asserted low-order fraction field control signal will couple the low-order fraction field value signals that they receive to the OR circuit <highlight><bold>63</bold></highlight> and the other AND gates will block the low-order fraction field signal that they receive. As will be described below, under some circumstances, the divider decision table logic <highlight><bold>15</bold></highlight> will assert two low-order fraction field control signals to enable two sets of low-order fraction field value signals to be coupled to the OR circuit <highlight><bold>63</bold></highlight>. In that case, the OR gate will perform a bit-wise OR operation in connection with signals representing respective bits of the low-order fraction field. </paragraph>
<paragraph id="P-0104" lvl="0"><number>&lsqb;0104&rsqb;</number> Thus, divider decision table logic <highlight><bold>15</bold></highlight> will assert two low-order fraction signals if, for example, both operands in operand buffers <highlight><bold>11</bold></highlight>A and <highlight><bold>11</bold></highlight>B are in NaN format to enable the respective flags &ldquo;n&rdquo;, &ldquo;o&rdquo;, &ldquo;u&rdquo;, &ldquo;z&rdquo;, and &ldquo;x&rdquo; to be ORed together. However, if the low-order fraction field value signals provided by the divider decision table logic <highlight><bold>15</bold></highlight> are negated, the low-order fraction field value signals provided by the OR circuit <highlight><bold>63</bold></highlight> will conform to the low-order fraction field signals provided by the AND circuit or circuits that receive the asserted low-order fraction field control signal. </paragraph>
<paragraph id="P-0105" lvl="0"><number>&lsqb;0105&rsqb;</number> As noted above, the divider decision table logic <highlight><bold>15</bold></highlight> generates control signals for controlling the selectors <highlight><bold>60</bold></highlight> and <highlight><bold>61</bold></highlight> and combiner <highlight><bold>62</bold></highlight> comprising the result assembler <highlight><bold>14</bold></highlight> and for controlling the toggling of the signals representing the low-order bits f<highlight><subscript>lsb&plus;1 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>from the operand buffers <highlight><bold>11</bold></highlight>A and <highlight><bold>11</bold></highlight>B before they are presented to the divider core <highlight><bold>13</bold></highlight>. The control signals generated by the divider decision table logic <highlight><bold>15</bold></highlight> are such as to enable the result to be assembled in the desired format <highlight><bold>70</bold></highlight>-<highlight><bold>76</bold></highlight> having status information embedded within the result itself. Before proceeding further, it would be helpful to describe the results that are to be generated by the divider unit <highlight><bold>10</bold></highlight>. </paragraph>
<paragraph id="P-0106" lvl="0"><number>&lsqb;0106&rsqb;</number> Generally, exemplary results generated by the divider unit <highlight><bold>10</bold></highlight> are described in the table depicted in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>. In that table, one skilled in the art will appreciate that &ldquo;&plus;P&rdquo; or &ldquo;&plus;Q&rdquo; means any finite positive representable value greater than &ldquo;one,&rdquo; other than &plus;OV (that is, a value in the overflow format <highlight><bold>74</bold></highlight> with the sign bit &ldquo;s&rdquo; being &ldquo;zero&rdquo;). &ldquo;&minus;P&rdquo; or &ldquo;&minus;Q&rdquo; means any finite negative representable value less than negative-one, other than &minus;OV (that is, a value in the overflow format 74 with the sign bit being &ldquo;s&rdquo; being &ldquo;zero&rdquo;). &ldquo;&plus;R&rdquo; or &ldquo;&plus;S&rdquo; means any positive non-zero representable value less than &ldquo;one,&rdquo; other than &plus;UN (that is, a value in the underflow format <highlight><bold>71</bold></highlight> with the sign bit &ldquo;s&rdquo; being &ldquo;zero&rdquo;). &ldquo;&minus;R&rdquo; or &ldquo;&minus;S&rdquo; means any negative non-zero representable value greater than negative-one, other than &minus;UN (that is, a value in the underflow format <highlight><bold>71</bold></highlight>, with the sign bit being &ldquo;one&rdquo;). Finally, those skilled in the art will appreciate that &ldquo;NaN&rdquo; means any value whose exponent field is 11111111, other than one of the values represented by &plus;&infin; (that is, a value in the infinity format <highlight><bold>75</bold></highlight>, with the sign bit &ldquo;s&rdquo; being &ldquo;zero&rdquo;) and &minus;&infin; (that is, a value in the infinity format <highlight><bold>75</bold></highlight>, with the sign bit &ldquo;s&rdquo; being &ldquo;one&rdquo;). </paragraph>
<paragraph id="P-0107" lvl="0"><number>&lsqb;0107&rsqb;</number> Key to symbols in the table with exemplary results depicted in <cross-reference target="DRAWINGS">FIG. 3</cross-reference> are as follows: </paragraph>
<paragraph id="P-0108" lvl="2"><number>&lsqb;0108&rsqb;</number> (a) For &ldquo;round toward plus infinity,&rdquo; the result is &plus;&infin; with the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field being equal to the bit wise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction fields of the two operands. For &ldquo;round toward minus infinity,&rdquo; the result is &plus;0. For all other rounding modes, the result is a positive NaN value 0 11111111 100000000000001001 1ouzx (to indicate &ldquo;infinity divided by infinity&rdquo; with the invalid operation flag set), where ouzx is the bitwise OR of the four least significant bits f<highlight><subscript>lsb&plus;3 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction fields of the operands; </paragraph>
<paragraph id="P-0109" lvl="2"><number>&lsqb;0109&rsqb;</number> (b) The result is &plus;&infin;, with the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result being equal to the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>the fraction field of the infinite operand with 01001 (to indicate overflow and inexact); </paragraph>
<paragraph id="P-0110" lvl="2"><number>&lsqb;0110&rsqb;</number> (c) The result is &plus;&infin;, with the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result being equal to the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb</subscript></highlight>, of the fraction field of the infinite operand; </paragraph>
<paragraph id="P-0111" lvl="2"><number>&lsqb;0111&rsqb;</number> (d) The result is &plus;&infin;, with the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result being the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the infinite operand with 00101 (to indicate underflow and inexact); </paragraph>
<paragraph id="P-0112" lvl="2"><number>&lsqb;0112&rsqb;</number> (e) The result is &minus;&infin;, with the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result being equal to the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the infinite operand; </paragraph>
<paragraph id="P-0113" lvl="2"><number>&lsqb;0113&rsqb;</number> (f) The result is &minus;&infin;,with the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result being the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the infinite operand with 00101 (to indicate underflow and inexact); </paragraph>
<paragraph id="P-0114" lvl="2"><number>&lsqb;0114&rsqb;</number> (g) The result is &minus;&infin;, with the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result being the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the infinite operand with 01001 (to indicate overflow and inexact); </paragraph>
<paragraph id="P-0115" lvl="2"><number>&lsqb;0115&rsqb;</number> (h) For &ldquo;round toward plus infinity,&rdquo; the result is &minus;0. For &ldquo;round toward minus infinity,&rdquo; the result is &minus;&infin; with the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field being equal to the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb</subscript></highlight>, of the fraction fields of the two operands. For all other rounding modes, the result is a negative NaN value 1 11111111 1000000000000010011 ouzx (to indicate &ldquo;infinity divided by infinity&rdquo; with the invalid operation flag set), where ouzx is the bitwise OR of the four least significant f<highlight><subscript>lsb&plus;3 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction fields of the two operands; </paragraph>
<paragraph id="P-0116" lvl="2"><number>&lsqb;0116&rsqb;</number> (i) The result is a copy of the NaN operand, except that its sign is reversed if the other operand is negative, and the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb</subscript></highlight>, of the fraction field of the result are the bitwise OR of the five least significant f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction fields of the operands; </paragraph>
<paragraph id="P-0117" lvl="2"><number>&lsqb;0117&rsqb;</number> (1) For &ldquo;round toward plus infinity,&rdquo; the result is &plus;OV; for &ldquo;round toward minus infinity,&rdquo; the result is &plus;UN; for all other rounding modes, the result is the positive NaN value 0 11111111 10000000000000101111001 (to indicate &ldquo;OV divided by OV&rdquo; with the invalid operation, overflow, and inexact flags set); </paragraph>
<paragraph id="P-0118" lvl="2"><number>&lsqb;0118&rsqb;</number> (k) For &ldquo;round toward minus infinity,&rdquo; the result is the same as if &minus;OV were replaced by &minus;HUGE; for all other rounding modes, the result is &plus;OV. </paragraph>
<paragraph id="P-0119" lvl="2"><number>&lsqb;0119&rsqb;</number> (l) The result is the &plus;&infin; value 0 11111111 00000000000000000001011 (to indicate overflow, division by zero, and inexact); </paragraph>
<paragraph id="P-0120" lvl="2"><number>&lsqb;0120&rsqb;</number> (m) The result is the &minus;&infin; value 1 11111111 00000000000000000001011 (to indicate overflow, division by zero, and inexact); </paragraph>
<paragraph id="P-0121" lvl="2"><number>&lsqb;0121&rsqb;</number> (n) For &ldquo;round toward plus infinity,&rdquo; the result is the same as if &minus;OV were replaced by &minus;HUGE; for all other rounding modes, the result is &minus;OV. </paragraph>
<paragraph id="P-0122" lvl="0"><number>&lsqb;0122&rsqb;</number> (o) For &ldquo;round toward plus infinity,&rdquo; the result is &minus;UN: for &ldquo;round toward minus infinity,&rdquo; the result is &minus;OV: for all other rounding modes, the result is the negative NaN value 1 11111111 10000000000000101111001 (to indicate &ldquo;OV divided by OV&rdquo; with the invalid operation, overflow, and inexact flags set); </paragraph>
<paragraph id="P-0123" lvl="2"><number>&lsqb;0123&rsqb;</number> (p) The result is a copy of the NaN operand, except that its sign is reversed if the other operand is negative, and the five least significant bits of the fraction field of the result are ORed with 01001 (to indicate overflow and inexact); </paragraph>
<paragraph id="P-0124" lvl="2"><number>&lsqb;0124&rsqb;</number> (q) For &ldquo;round toward plus infinity,&rdquo; the result is the same as if &minus;OV were replaced by &minus;HUGE, except that if underflow occurs and a computation in accordance IEEE Std. 754 would have the result &plus;0, the result is &plus;UN; for all other rounding modes, the result is &plus;UN; </paragraph>
<paragraph id="P-0125" lvl="0"><number>&lsqb;0125&rsqb;</number> (r) As computed in accordance with IEEE Std. 754. However, if overflow occurs or if the rounding mode is &ldquo;round toward plus infinity&rdquo; and the mathematical quotient is greater than &plus;HUGE, the result is &plus;OV. Further, if underflow occurs and a computation in accordance with IEEE Std. 754 would provide the result &plus;0 or if the rounding mode is &ldquo;round toward minus infinity&rdquo; and the mathematical quotient is less than &plus;TINY, the result is &plus;UN; </paragraph>
<paragraph id="P-0126" lvl="2"><number>&lsqb;0126&rsqb;</number> (s) The result is the &plus;&infin; value 0 11111111 00000000000000000000010 (to indicate division by zero). </paragraph>
<paragraph id="P-0127" lvl="2"><number>&lsqb;0127&rsqb;</number> (t) The result is the &minus;&infin; value 1 11111111 00000000000000000000010 (to indicate division by zero); </paragraph>
<paragraph id="P-0128" lvl="2"><number>&lsqb;0128&rsqb;</number> (u) As computed in accordance with IEEE Std. 754. However if overflow occurs, or if the rounding mode is &ldquo;round toward minus infinity&rdquo; and the mathematical quotient is less than &minus;HUGE, the result is &minus;OV. Further, if underflow occurs and a computation in accordance with IEEE Std. 754 would provide the result &minus;0 or if the rounding mode is &ldquo;round toward plus infinity&rdquo; and the mathematical quotient is greater than &minus;TINY, the result is &minus;UN; </paragraph>
<paragraph id="P-0129" lvl="2"><number>&lsqb;0129&rsqb;</number> (v) For &ldquo;round toward minus infinity,&rdquo; the result is the same as if &plus;OV were replaced by &plus;HUGE, except that if underflow occurs and a computation in accordance with IEEE Std. 754 would have result &minus;0, the result is &minus;UN; for all other rounding modes, the result is &minus;UN; </paragraph>
<paragraph id="P-0130" lvl="2"><number>&lsqb;0130&rsqb;</number> (w) The result is a copy of the NaN operand, except that its sign is reversed if the other operand is negative; </paragraph>
<paragraph id="P-0131" lvl="2"><number>&lsqb;0131&rsqb;</number> (x) For &ldquo;round toward minus infinity,&rdquo; the result is the same as if &minus;UN were replaced by &minus;TINY, except that if overflow occurs, the result is &plus;OV; for all other rounding modes, the result is &plus;OV; </paragraph>
<paragraph id="P-0132" lvl="2"><number>&lsqb;0132&rsqb;</number> (y) For &ldquo;round toward plus infinity,&rdquo; the result. is the same as if &plus;UN were replaced by &plus;TINY, except that if overflow occurs, the result is &minus;OV; for all other rounding modes, the result is &minus;OV; </paragraph>
<paragraph id="P-0133" lvl="2"><number>&lsqb;0133&rsqb;</number> (z) For &ldquo;round toward plus infinity,&rdquo; the result is the same as if &minus;UN were replaced by &minus;TINY. For all other rounding modes, the result is &plus;UN; </paragraph>
<paragraph id="P-0134" lvl="2"><number>&lsqb;0134&rsqb;</number> (1) For &ldquo;round forward plus infinity,&rdquo; the result is &plus;OV; for &ldquo;round toward minus infinity,&rdquo; the result is &plus;UN. For all other rounding modes, the result is the positive NaN value 0 11111111 10000000000000101010101 (to indicate &ldquo;UN divided by UN&rdquo; with the invalid operation, underflow, and inexact flags set); </paragraph>
<paragraph id="P-0135" lvl="2"><number>&lsqb;0135&rsqb;</number> (2) The result is the &plus;&infin; value 0 11111111 00000000000000000000111 (to indicate underflow, division by zero, and inexact); </paragraph>
<paragraph id="P-0136" lvl="2"><number>&lsqb;0136&rsqb;</number> (3) The result is the &minus;&infin; value 1 11111111 00000000000000000000111 (to indicate underflow, division by zero, and inexact); </paragraph>
<paragraph id="P-0137" lvl="2"><number>&lsqb;0137&rsqb;</number> (4) For &ldquo;round toward plus infinity,&rdquo; the result is &minus;UN; for &ldquo;round toward minus infinity,&rdquo; the result is &minus;OV; for all other rounding modes, the result is the negative NaN value 1 11111111 10000000000000101010101 (to indicate &ldquo;UN divided by UN&rdquo; with the invalid operation, underflow, and inexact flags set); </paragraph>
<paragraph id="P-0138" lvl="2"><number>&lsqb;0138&rsqb;</number> (5) For &ldquo;round toward minus infinity,&rdquo; the result is the same as if &minus;UN were replaced by &minus;TINY; for all other rounding modes, the result is &minus;UN; </paragraph>
<paragraph id="P-0139" lvl="2"><number>&lsqb;0139&rsqb;</number> (6) The result is a copy of the NaN operand, except that its sign is reversed if the other operand is negative, and the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result are ORed with 00101 (to indicate underflow and inexact); </paragraph>
<paragraph id="P-0140" lvl="2"><number>&lsqb;0140&rsqb;</number> (7) For &ldquo;round toward plus infinity,&rdquo; the result is &plus;&infin; with the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field all having the value zero; for &ldquo;round toward minus infinity,&rdquo; the result is &plus;0; for all other rounding modes, the result is the positive NaN value 0 11111111 10000000000000100010000 (to indicate &ldquo;zero divided by zero&rdquo; with the invalid operation flag set); </paragraph>
<paragraph id="P-0141" lvl="2"><number>&lsqb;0141&rsqb;</number> (8) For &ldquo;round toward plus infinity,&rdquo; the result is &minus;0; for &ldquo;round toward minus infinity,&rdquo; the result is &minus;&infin; with five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field all having the value zero; for all other rounding modes, the result is the negative NaN value 1 11111111 10000000000000100010000 (to indicate &ldquo;zero divided by zero&rdquo; with the invalid operation flag set); </paragraph>
<paragraph id="P-0142" lvl="2"><number>&lsqb;0142&rsqb;</number> (9) For &ldquo;round toward minus infinity,&rdquo; the result is the same as if &plus;UN were replaced by &plus;TINY; for all other rounding modes, the result is &minus;UN; </paragraph>
<paragraph id="P-0143" lvl="2"><number>&lsqb;0143&rsqb;</number> (&commat;) For &ldquo;round toward plus infinity,&rdquo; the result is the same as if &plus;UN were replaced by &plus;TINY; for all other rounding modes, the result is &plus;UN; </paragraph>
<paragraph id="P-0144" lvl="2"><number>&lsqb;0144&rsqb;</number> (&num;) For &ldquo;round toward minus infinity.&rdquo; the result is the same as if &minus;OV were replaced by &minus;HUGE, except that if underflow occurs and a computation in accordance with IEEE Std. 754 would have the result value &minus;0, the result is &minus;UN; for all other rounding modes, the result is &minus;UN. </paragraph>
<paragraph id="P-0145" lvl="2"><number>&lsqb;0145&rsqb;</number> ($) For &ldquo;round toward plus infinity,&rdquo; the result is the same as if &minus;UN were replaced by &minus;TINY, except that if overflow occurs, the result is &minus;OV; for all other rounding modes, the result is &minus;OV; </paragraph>
<paragraph id="P-0146" lvl="2"><number>&lsqb;0146&rsqb;</number> (%) For &ldquo;round toward minus infinity,&rdquo; the result is the same as if &plus;UN were replaced by &plus;TINY, except that if overflow occurs, the result is &plus;OV; for all other rounding modes, the result is &plus;OV; </paragraph>
<paragraph id="P-0147" lvl="2"><number>&lsqb;0147&rsqb;</number> (&circ; ) For &ldquo;round toward plus infinity,&rdquo; the result is the same as if &plus;OV were replaced by &plus;HUGE, except that if underflow, occurs and a computation in accordance with IEEE Std. 754 would have the result &plus;0, the result is &plus;UN; for all other rounding modes, the result is &plus;UN; </paragraph>
<paragraph id="P-0148" lvl="2"><number>&lsqb;0148&rsqb;</number> (&amp;) For &ldquo;round toward plus infinity,&rdquo; the result is the same as if &plus;OV were replaced by &plus;HUGE. For all other rounding modes, the result is &minus;OV; </paragraph>
<paragraph id="P-0149" lvl="2"><number>&lsqb;0149&rsqb;</number> (*) For &ldquo;round toward minus infinity,&rdquo; the result is the same as if &plus;OV were replaced by &plus;HUGE. For all other rounding modes, the result is &plus;OV; and </paragraph>
<paragraph id="P-0150" lvl="2"><number>&lsqb;0150&rsqb;</number> (&tilde;) The result is a copy of the NaN operand that has the larger value in its fraction field, except that the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb</subscript></highlight>, of the fraction field of the result are the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction fields of the operands and the sign bit of the result is 1 if and only if the sign bits of the two NaN operands differ. </paragraph>
<paragraph id="P-0151" lvl="0"><number>&lsqb;0151&rsqb;</number> As noted above, divider decision table logic <highlight><bold>15</bold></highlight> generates control signals for controlling the selectors <highlight><bold>60</bold></highlight>, <highlight><bold>61</bold></highlight> and combiner <highlight><bold>62</bold></highlight> comprising the result assembler <highlight><bold>14</bold></highlight> and for controlling the toggling of the signals representing the low-order bits f<highlight><subscript>lsb&plus;1 </subscript></highlight>and f<highlight><subscript>lsb</subscript></highlight>, from the operand buffers <highlight><bold>11</bold></highlight>A and <highlight><bold>11</bold></highlight>B before they are presented to the divider core <highlight><bold>13</bold></highlight>. The particular signals that the divider decision table logic <highlight><bold>15</bold></highlight> will generate depends on the signals provided thereto by the operand buffers <highlight><bold>11</bold></highlight>A and <highlight><bold>11</bold></highlight>B representing the states of the respective sign bits, the operand analysis circuits <highlight><bold>12</bold></highlight>A and <highlight><bold>12</bold></highlight>B, comparator <highlight><bold>40</bold></highlight>, rounding mode store, <highlight><bold>16</bold></highlight>, and the overflow and underflow signals from the divider core <highlight><bold>13</bold></highlight>. In the illustrated embodiment, the series of input signals received by the divider decision table logic <highlight><bold>15</bold></highlight> are as follows: </paragraph>
<paragraph id="P-0152" lvl="2"><number>&lsqb;0152&rsqb;</number> (a) a signal from comparator <highlight><bold>26</bold></highlight>A that is asserted if the exponent field of the operand in operand buffer <highlight><bold>11</bold></highlight> A has the bit pattern 00000000; </paragraph>
<paragraph id="P-0153" lvl="2"><number>&lsqb;0153&rsqb;</number> (b) a signal from comparator <highlight><bold>21</bold></highlight>A that is asserted if the exponent field of the operand in operand buffer <highlight><bold>11</bold></highlight>A has the bit pattern 111 111 10; </paragraph>
<paragraph id="P-0154" lvl="2"><number>&lsqb;0154&rsqb;</number> (c) a signal from comparator <highlight><bold>20</bold></highlight>A that is asserted if the exponent field of the operand in operand buffer <highlight><bold>11</bold></highlight>A has the bit pattern 11111111; </paragraph>
<paragraph id="P-0155" lvl="2"><number>&lsqb;0155&rsqb;</number> (d) a signal from the comparator <highlight><bold>31</bold></highlight>A that is asserted if the operand in operand buffer <highlight><bold>11</bold></highlight>A has a high order fraction field with all O-bits; </paragraph>
<paragraph id="P-0156" lvl="2"><number>&lsqb;0156&rsqb;</number> (e) a signal from AND gate <highlight><bold>50</bold></highlight>A that is asserted if the operand in operand buffer <highlight><bold>11</bold></highlight>A has high- and low-order fraction fields with the collective bit pattern 00000000000000000000000; </paragraph>
<paragraph id="P-0157" lvl="2"><number>&lsqb;0157&rsqb;</number> (f) a signal from AND gate <highlight><bold>51</bold></highlight>A that is asserted if the operand in operand buffer <highlight><bold>11</bold></highlight>A has high- and low-order fraction fields with the collective bit pattern 00000000000000000000001; </paragraph>
<paragraph id="P-0158" lvl="2"><number>&lsqb;0158&rsqb;</number> (g) a signal from AND gate <highlight><bold>52</bold></highlight>A that is asserted if the operand in operand buffer <highlight><bold>11</bold></highlight>A has high- and low-order fraction fields with the collective bit pattern 11111111111111111111111; </paragraph>
<paragraph id="P-0159" lvl="2"><number>&lsqb;0159&rsqb;</number> (h) a signal from OR gate <highlight><bold>43</bold></highlight>A that is asserted if any of the following signals are asserted: </paragraph>
<paragraph id="P-0160" lvl="3"><number>&lsqb;0160&rsqb;</number> (1) a signal from NAND gate <highlight><bold>41</bold></highlight>A that is asserted if the exponent field of the operand in operand buffer <highlight><bold>11</bold></highlight>A has a bit pattern 00000000 (which will be the case if the signal from comparator <highlight><bold>26</bold></highlight>A is asserted) and the high- and low-order fraction field of the operand in operand buffer <highlight><bold>11</bold></highlight>A has a bit pattern in which at least one bit, other than the least significant bit, is &ldquo;1&rdquo; (which will be the case if the signal from AND gate <highlight><bold>40</bold></highlight>A is negated); </paragraph>
<paragraph id="P-0161" lvl="3"><number>&lsqb;0161&rsqb;</number> (2) a signal from NAND gate <highlight><bold>42</bold></highlight>A that is asserted if the exponent field of the operand in operand buffer <highlight><bold>11</bold></highlight>A does not have a bit pattern 01111111 (which will be the case if the signal from comparator <highlight><bold>24</bold></highlight>A is negated) and also does not have the bit pattern 00000000 (which will be the case if the signal from comparator <highlight><bold>26</bold></highlight>A is negated) but the high-order bit e<highlight><subscript>lsb </subscript></highlight>of the exponent field in operand buffer <highlight><bold>11</bold></highlight>A is &ldquo;0&rdquo; (which will be the case if the signal from comparator <highlight><bold>25</bold></highlight>A is asserted); </paragraph>
<paragraph id="P-0162" lvl="2"><number>&lsqb;0162&rsqb;</number> (i) a signal from AND gate <highlight><bold>44</bold></highlight>A that is asserted if the exponent field of the operand in operand buffer <highlight><bold>11</bold></highlight>A has the bit pattern 01111111 (which will be the case if the signal from comparator <highlight><bold>24</bold></highlight>A is asserted) and the bits of the fraction field of the operand in operand buffer <highlight><bold>11</bold></highlight>A are all &ldquo;0&rdquo; (which will be the case if the signal from AND gate <highlight><bold>50</bold></highlight>A is asserted); </paragraph>
<paragraph id="P-0163" lvl="2"><number>&lsqb;0163&rsqb;</number> (j) a signal from OR gate <highlight><bold>48</bold></highlight>A that is asserted if any of the following signals are asserted: </paragraph>
<paragraph id="P-0164" lvl="3"><number>&lsqb;0164&rsqb;</number> (1) a signal from NAND gate <highlight><bold>45</bold></highlight>A that is asserted if the exponent field of the operand in operand buffer <highlight><bold>11</bold></highlight>A has the bit pattern 01111111 (which will be the case if the signal from comparator <highlight><bold>24</bold></highlight>A is asserted) and at least one bit of the fraction field of the operand in operand buffer <highlight><bold>11</bold></highlight>A is &ldquo;1&rdquo; (which will be the case if the signal from AND gate <highlight><bold>50</bold></highlight>A is negated); </paragraph>
<paragraph id="P-0165" lvl="3"><number>&lsqb;0165&rsqb;</number> (2) a signal from NAND gate <highlight><bold>46</bold></highlight>A that asserted if the exponent field of the operand in operand buffer <highlight><bold>11</bold></highlight> A does not have the bit pattern 11111110 or 11111111 but the high-order bit of the exponent field is 1 (which will be the case if the signal from comparator <highlight><bold>23</bold></highlight>A is asserted and the signal from comparator <highlight><bold>22</bold></highlight>A is negated); and </paragraph>
<paragraph id="P-0166" lvl="3"><number>&lsqb;0166&rsqb;</number> (3) a signal from NAND gate <highlight><bold>47</bold></highlight>A that is asserted if the exponent field of the operand in operand buffer <highlight><bold>11</bold></highlight>A has the bit pattern 11111110 (which will be the case if the signal from comparator <highlight><bold>21</bold></highlight>A is asserted) and at least one bit of the fraction in the fraction field of the operand in operand buffer <highlight><bold>11</bold></highlight>A is &ldquo;0&rdquo; (which will be the case if the signal from AND gate <highlight><bold>52</bold></highlight>A is negated); </paragraph>
<paragraph id="P-0167" lvl="2"><number>&lsqb;0167&rsqb;</number> (k) a signal from comparator <highlight><bold>26</bold></highlight>B that is asserted if the exponent field of the operand in operand buffer <highlight><bold>11</bold></highlight>B has the bit pattern 00000000; </paragraph>
<paragraph id="P-0168" lvl="2"><number>&lsqb;0168&rsqb;</number> (l) a signal from comparator <highlight><bold>21</bold></highlight>B that is asserted if the exponent field of the operand in operand buffer <highlight><bold>11</bold></highlight>B has the bit pattern 11111110; </paragraph>
<paragraph id="P-0169" lvl="2"><number>&lsqb;0169&rsqb;</number> (m) a signal from comparator <highlight><bold>20</bold></highlight>B that is asserted if the exponent field of the operand in operand buffer <highlight><bold>11</bold></highlight>B has the bit pattern 11111111; </paragraph>
<paragraph id="P-0170" lvl="2"><number>&lsqb;0170&rsqb;</number> (n) a signal from the comparator <highlight><bold>31</bold></highlight>B that is asserted if the operand in operand buffer <highlight><bold>11</bold></highlight>B has a high order fraction field with all 0-bits; </paragraph>
<paragraph id="P-0171" lvl="2"><number>&lsqb;0171&rsqb;</number> (o) a signal from AND gate <highlight><bold>50</bold></highlight>B that is asserted if the operand in operand buffer <highlight><bold>11</bold></highlight>B has high- and low-order fraction fields with the collective bit pattern 00000000000000000000000; </paragraph>
<paragraph id="P-0172" lvl="2"><number>&lsqb;0172&rsqb;</number> (p) a signal from AND gate <highlight><bold>51</bold></highlight>B that is asserted if the operand in operand buffer <highlight><bold>11</bold></highlight>B has high- and low-order fraction fields with the collective bit pattern 00000000000000000000001; </paragraph>
<paragraph id="P-0173" lvl="2"><number>&lsqb;0173&rsqb;</number> (q) a signal from AND gate <highlight><bold>52</bold></highlight>B that is asserted if the operand in operand buffer <highlight><bold>11</bold></highlight>B has high- and low-order fraction fields with the collective bit pattern </paragraph>
<paragraph id="P-0174" lvl="2"><number>&lsqb;0174&rsqb;</number> (r) a signal from OR gate <highlight><bold>43</bold></highlight>B that is asserted if any of the following signals are asserted: </paragraph>
<paragraph id="P-0175" lvl="3"><number>&lsqb;0175&rsqb;</number> (1) a signal from NAND gate <highlight><bold>41</bold></highlight>B that is asserted if the exponent field of the operand in operand buffer <highlight><bold>11</bold></highlight>B has a bit pattern 00000000 (which will be the case if the signal from comparator <highlight><bold>26</bold></highlight>B is asserted) and the high- and low-order fraction field of the operand in operand buffer <highlight><bold>11</bold></highlight>B has a bit pattern in which at least one bit, other than the least significant bit, is &ldquo;1&rdquo; (which will be the case if the signal from AND gate <highlight><bold>40</bold></highlight>B is negated); </paragraph>
<paragraph id="P-0176" lvl="2"><number>&lsqb;0176&rsqb;</number> (2) a signal from NAND gate <highlight><bold>42</bold></highlight>B that is asserted if the exponent field of the operand in operand buffer <highlight><bold>11</bold></highlight>B does not have a bit pattern 01111111 (which will be the case if the signal from comparator <highlight><bold>24</bold></highlight>B is negated) and also does not have the bit pattern 00000000 (which will be the case if the signal from comparator <highlight><bold>26</bold></highlight>B is negated) but the high-order bit e<highlight><subscript>msb</subscript></highlight>, of the exponent field in operand buffer <highlight><bold>11</bold></highlight>B is &ldquo;0&rdquo; (which will be the case if the signal from comparator <highlight><bold>25</bold></highlight>B is asserted); </paragraph>
<paragraph id="P-0177" lvl="2"><number>&lsqb;0177&rsqb;</number> (s) a signal from AND gate <highlight><bold>44</bold></highlight>B that is asserted if the exponent field of the operand in operand buffer <highlight><bold>11</bold></highlight>B has the bit pattern 01111111 (which will be the case if the signal from comparator <highlight><bold>24</bold></highlight>B is asserted) and the bits of the fraction field of the operand in operand buffer <highlight><bold>11</bold></highlight>B are all &ldquo;0&rdquo; (which will be the case if the signal from AND gate <highlight><bold>50</bold></highlight>B is asserted); </paragraph>
<paragraph id="P-0178" lvl="2"><number>&lsqb;0178&rsqb;</number> (t) a signal from OR gate <highlight><bold>48</bold></highlight>B that is asserted if any of the following signals are asserted: </paragraph>
<paragraph id="P-0179" lvl="3"><number>&lsqb;0179&rsqb;</number> (1) a signal from NAND gate <highlight><bold>45</bold></highlight>B that is asserted if the exponent field of the operand in operand buffer <highlight><bold>11</bold></highlight>B has the bit pattern 01111111 (which will be the cast if the signal from comparator <highlight><bold>24</bold></highlight>B is asserted) and at least one bit of the fraction field of the operand in operand buffer <highlight><bold>11</bold></highlight>B is &ldquo;1&rdquo; (which will be the case if the signal from AND gate <highlight><bold>50</bold></highlight>B is negated); </paragraph>
<paragraph id="P-0180" lvl="3"><number>&lsqb;0180&rsqb;</number> (2) a signal from NAND gate <highlight><bold>46</bold></highlight>B that asserted if the exponent field of the operand in operand buffer <highlight><bold>11</bold></highlight>B does not have the bit pattern 11111110 or 11111111 but the high-order bit of the exponent field is 1 (which will be the case if the signal from comparator <highlight><bold>23</bold></highlight>B is asserted and the signal from comparator <highlight><bold>22</bold></highlight>B is negated); and </paragraph>
<paragraph id="P-0181" lvl="3"><number>&lsqb;0181&rsqb;</number> (3) a signal from NAND gate <highlight><bold>47</bold></highlight>B that is asserted if the exponent field of the operand in operand buffer <highlight><bold>11</bold></highlight>B has the bit pattern 11111110 (which will be the case if the signal from comparator <highlight><bold>21</bold></highlight>B is asserted) and at least one bit of the fraction in the fraction field of the operand in operand buffer <highlight><bold>11</bold></highlight>B is &ldquo;0&rdquo; (which will be the case if the signal from AND gate <highlight><bold>52</bold></highlight>B is negated); </paragraph>
<paragraph id="P-0182" lvl="2"><number>&lsqb;0182&rsqb;</number> (u) a signal from comparator <highlight><bold>53</bold></highlight> that is asserted if the binary-encoded, value of the bits comprising the high-order fraction field of the operand in operand buffer <highlight><bold>11</bold></highlight>A is greater than the binary-encoded value of the bits comprising the high-order fraction field of the operand in operand buffer <highlight><bold>11</bold></highlight>B; </paragraph>
<paragraph id="P-0183" lvl="2"><number>&lsqb;0183&rsqb;</number> (v) a signal from the rounding mode store <highlight><bold>16</bold></highlight> that is asserted if the rounding mode is either &ldquo;round toward plus infinity&rdquo; or &ldquo;round toward minus infinity&rdquo;; </paragraph>
<paragraph id="P-0184" lvl="2"><number>&lsqb;0184&rsqb;</number> (w) a signal from the rounding mode store <highlight><bold>16</bold></highlight> that is asserted if the rounding mode is either &ldquo;round toward zero&rdquo; or &ldquo;round toward minus infinity&rdquo;; </paragraph>
<paragraph id="P-0185" lvl="2"><number>&lsqb;0185&rsqb;</number> (x) a signal from XOR gate <highlight><bold>54</bold></highlight> that is asserted if the sign bits &ldquo;s&rdquo; of the operands in operand buffers <highlight><bold>11</bold></highlight>A and <highlight><bold>11</bold></highlight>B differ, </paragraph>
<paragraph id="P-0186" lvl="2"><number>&lsqb;0186&rsqb;</number> (y) an &ldquo;overflow&rdquo; signal from the divider core <highlight><bold>13</bold></highlight>; and </paragraph>
<paragraph id="P-0187" lvl="2"><number>&lsqb;0187&rsqb;</number> (z) an &ldquo;underflow&rdquo; signal from the divider core <highlight><bold>13</bold></highlight>. </paragraph>
<paragraph id="P-0188" lvl="0"><number>&lsqb;0188&rsqb;</number> In response to these signals, the exemplary divider decision logic table <highlight><bold>15</bold></highlight> generates the following: </paragraph>
<paragraph id="P-0189" lvl="2"><number>&lsqb;0189&rsqb;</number> (<highlight><bold>1</bold></highlight>) a signal that, if asserted, enables the second least-significant bit of the operand in operand buffer <highlight><bold>11</bold></highlight>A to be toggled before being presented to the divider core <highlight><bold>13</bold></highlight>; </paragraph>
<paragraph id="P-0190" lvl="2"><number>&lsqb;0190&rsqb;</number> (<highlight><bold>2</bold></highlight>) a signal that, if asserted, enables the least significant bit of the operand in operand buffer <highlight><bold>11</bold></highlight>A to be toggled before being presented to the divider core <highlight><bold>13</bold></highlight>; </paragraph>
<paragraph id="P-0191" lvl="2"><number>&lsqb;0191&rsqb;</number> (<highlight><bold>3</bold></highlight>) a signal that, if asserted, enables the second-least significant bit of the operand in operand buffer <highlight><bold>11</bold></highlight>B to be toggled before being presented to the divider core <highlight><bold>13</bold></highlight>; </paragraph>
<paragraph id="P-0192" lvl="2"><number>&lsqb;0192&rsqb;</number> (<highlight><bold>4</bold></highlight>) a signal that, if asserted enables the least significant bit of the operand in operand buffer <highlight><bold>11</bold></highlight>B to be toggled before being presented to the divider core <highlight><bold>13</bold></highlight>; </paragraph>
<paragraph id="P-0193" lvl="2"><number>&lsqb;0193&rsqb;</number> (<highlight><bold>5</bold></highlight>) a signal that, if asserted, enables the exponent field and the high-part of the fraction of the result to be provided by the divider core <highlight><bold>13</bold></highlight>, and moreover, the five least-significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the output provided by the divider core <highlight><bold>13</bold></highlight> will contribute to the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the result; </paragraph>
<paragraph id="P-0194" lvl="2"><number>&lsqb;0194&rsqb;</number> (<highlight><bold>6</bold></highlight>) a signal that, if asserted, will enable the exponent field of the result to have the bit pattern 00000000; </paragraph>
<paragraph id="P-0195" lvl="2"><number>&lsqb;0195&rsqb;</number> (<highlight><bold>7</bold></highlight>) a signal that, if asserted, will enable the exponent field of the result to have the bit pattern 11111110; </paragraph>
<paragraph id="P-0196" lvl="2"><number>&lsqb;0196&rsqb;</number> (<highlight><bold>8</bold></highlight>) a signal that, if asserted, will enable the exponent field of the result to have the bit pattern 11111111; </paragraph>
<paragraph id="P-0197" lvl="2"><number>&lsqb;0197&rsqb;</number> (<highlight><bold>9</bold></highlight>) a signal that, if asserted, will enable the high-order fraction of the result to correspond to the high-order portion of the fraction of the operand in operand buffer <highlight><bold>11</bold></highlight>A; </paragraph>
<paragraph id="P-0198" lvl="2"><number>&lsqb;0198&rsqb;</number> (<highlight><bold>10</bold></highlight>) a signal that if asserted, will enable the high-order fraction of the result to correspond to the high-order portion of the fraction of the operand in operand buffer <highlight><bold>11</bold></highlight>B; </paragraph>
<paragraph id="P-0199" lvl="2"><number>&lsqb;0199&rsqb;</number> (<highlight><bold>11</bold></highlight>) a signal that, if asserted, will enable the high-order fraction of the result to correspond to the bit pattern 000000000000000000; </paragraph>
<paragraph id="P-0200" lvl="2"><number>&lsqb;0200&rsqb;</number> (<highlight><bold>12</bold></highlight>) a signal that, if asserted, will enable the high-order fraction of the result to correspond to the bit pattern 111111111111111111. </paragraph>
<paragraph id="P-0201" lvl="2"><number>&lsqb;0201&rsqb;</number> (<highlight><bold>13</bold></highlight>) a signal that, if asserted, will enable the high-order fraction of the result to correspond to the bit pattern 100000000000001000 (to represent a NaN value &ldquo;zero divided by zero&rdquo;). </paragraph>
<paragraph id="P-0202" lvl="2"><number>&lsqb;0202&rsqb;</number> (<highlight><bold>14</bold></highlight>) a signal that if asserted, will enable the high-order fraction of the result to correspond to the bit pattern 100000000000001001 (to represent a NaN value &ldquo;infinity divided by infinity&rdquo;). </paragraph>
<paragraph id="P-0203" lvl="2"><number>&lsqb;0203&rsqb;</number> (<highlight><bold>15</bold></highlight>) a signal that, if asserted, will enable the high-order fraction of the result to correspond to the bit pattern 100000000000001010 (to represent a NaN value &ldquo;underflow divided by underflow&rdquo;). </paragraph>
<paragraph id="P-0204" lvl="2"><number>&lsqb;0204&rsqb;</number> (<highlight><bold>16</bold></highlight>) a signal that, if asserted, will enable the high-order fraction of the result to correspond to the bit pattern 100000000000001011 (to represent a NaN value &ldquo;overflow divided by overflow&rdquo;). </paragraph>
<paragraph id="P-0205" lvl="2"><number>&lsqb;0205&rsqb;</number> (<highlight><bold>17</bold></highlight>) a signal that, if asserted, will enable the low-order fraction field of the operand in output buffer <highlight><bold>11</bold></highlight>A to contribute to the five least-significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result; </paragraph>
<paragraph id="P-0206" lvl="2"><number>&lsqb;0206&rsqb;</number> (<highlight><bold>18</bold></highlight>) a signal that, if asserted, will enable the low-order fraction field of the operand in output buffer <highlight><bold>11</bold></highlight>B to contribute to the five least-significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result, and </paragraph>
<paragraph id="P-0207" lvl="2"><number>&lsqb;0207&rsqb;</number> (<highlight><bold>19</bold></highlight>)-(<highlight><bold>23</bold></highlight>) signals that always contribute to the five least-significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result. </paragraph>
<paragraph id="P-0208" lvl="0"><number>&lsqb;0208&rsqb;</number> The specific patterns of output signals (<highlight><bold>1</bold></highlight>) through (<highlight><bold>23</bold></highlight>) generated by the exemplary divider decision table logic <highlight><bold>15</bold></highlight> in response to patterns of input signals (a) through (z) are depicted in <cross-reference target="DRAWINGS">FIGS. 4A through 4C</cross-reference>. Generally, in FIGS. <highlight><bold>4</bold></highlight>A-<highlight><bold>4</bold></highlight>C, each row represents conditions of the output signals (<highlight><bold>1</bold></highlight>) through (<highlight><bold>23</bold></highlight>) that are generated by the divider decision table logic <highlight><bold>15</bold></highlight> in response to one pattern of input signals (a) through (v). In each row, indicia to the left of the asterisk (*) represent the pattern of input signals (a) through (v) and the indicia to the right of the asterisk represent the pattern of output signals (<highlight><bold>1</bold></highlight>) through (<highlight><bold>23</bold></highlight>), with a &ldquo;1&rdquo; indicating that the respective input or output signal is asserted, a &ldquo;0&rdquo; indicating that the respective input or output signal is negated, and a &ldquo;&minus;&rdquo; indicating that the respective input signal may be either negated or asserted. Each row is further annotated with an indication as to the respective format <highlight><bold>70</bold></highlight> through <highlight><bold>76</bold></highlight> of the operand in the respective operand buffers <highlight><bold>11</bold></highlight>A and <highlight><bold>11</bold></highlight>B and the format of the result. </paragraph>
<paragraph id="P-0209" lvl="0"><number>&lsqb;0209&rsqb;</number> Referring now to <cross-reference target="DRAWINGS">FIG. 4A, a</cross-reference> discussion of the first row of input signal values and corresponding output signal values follows. </paragraph>
<paragraph id="P-0210" lvl="2"><number>&lsqb;0210&rsqb;</number> (A) for the three input patterns to the left of the asterisk: </paragraph>
<paragraph id="P-0211" lvl="3"><number>&lsqb;0211&rsqb;</number> (i) the first pattern &ldquo;--10------&rdquo; indicates that signal (c) is asserted, signal (d) is negated, and signals (a), (b), and (e) through (j) may be either asserted or negated, with the pattern indicating a value in the NaN format <highlight><bold>76</bold></highlight> (&ldquo;&lsqb;NaN&rsqb;&rdquo;); </paragraph>
<paragraph id="P-0212" lvl="3"><number>&lsqb;0212&rsqb;</number> (ii) the second pattern &ldquo;-10------&rdquo; indicates that signal (m) is asserted, signal (n) is negated, and signals (k), (l) and (o) through (t) may be either asserted or negated, with the pattern indicating a value in the NaN format <highlight><bold>76</bold></highlight> with a negative sign (&ldquo;&lsqb;&minus;NaN&rsqb;&rdquo;); and </paragraph>
<paragraph id="P-0213" lvl="3"><number>&lsqb;0213&rsqb;</number> (iii) the third pattern &ldquo;1 -- - --&rdquo; indicates signal (u) is asserted indicating that the binary-encoded value of the high-order bits f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb&plus;5 </subscript></highlight>of the fraction field of the operand in operand buffer <highlight><bold>11</bold></highlight>A is greater than the binary-encoded value of the high-order bits f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb&plus;5 </subscript></highlight>of the fraction field of the operand in operand buffer <highlight><bold>11</bold></highlight>B, and the signals (v) through (z) may be either asserted or negated; and </paragraph>
<paragraph id="P-0214" lvl="2"><number>&lsqb;0214&rsqb;</number> (B) for the six output patterns to the right of the asterisk: </paragraph>
<paragraph id="P-0215" lvl="3"><number>&lsqb;0215&rsqb;</number> (i) the pattern &ldquo;0000&rdquo; to the immediate right of the asterisk indicates that the signals provided to XOR gates <highlight><bold>67</bold></highlight>A, <highlight><bold>68</bold></highlight>A, <highlight><bold>67</bold></highlight>B and <highlight><bold>68</bold></highlight>B, which control the toggling of the low-order bits f<highlight><subscript>lsb&plus;1</subscript></highlight>, and f<highlight><subscript>lsb </subscript></highlight>of the fraction fields of the operands in operand buffers <highlight><bold>11</bold></highlight>A and <highlight><bold>11</bold></highlight>B before being presented to divider core <highlight><bold>13</bold></highlight>, are all negated; </paragraph>
<paragraph id="P-0216" lvl="3"><number>&lsqb;0216&rsqb;</number> (ii) the next &ldquo;0&rdquo; indicates that the signal provided to selectors <highlight><bold>60</bold></highlight> and <highlight><bold>61</bold></highlight> and AND circuit <highlight><bold>64</bold></highlight>, is negated thereby to ensure that the output from divider core <highlight><bold>13</bold></highlight> will not contribute the result; </paragraph>
<paragraph id="P-0217" lvl="3"><number>&lsqb;0217&rsqb;</number> (iii) the next pattern &ldquo;001&rdquo; indicates that the signal will be asserted that will enable selector <highlight><bold>60</bold></highlight> to couple signals representative of the pattern 11111111 to the result bus <highlight><bold>17</bold></highlight>, and the signals associated with the other patterns 00000000 and 11111110 will be negated; </paragraph>
<paragraph id="P-0218" lvl="3"><number>&lsqb;0218&rsqb;</number> (iv) the next pattern &ldquo;10000000&rdquo; indicates selector <highlight><bold>61</bold></highlight> is enabled to couple the signals associated with the bits f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb&plus;5 </subscript></highlight>(comprising the high-order fraction field of the operand in buffer <highlight><bold>11</bold></highlight>A) to the result bus <highlight><bold>17</bold></highlight> as the bits f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb&plus;5 </subscript></highlight>of the fraction field of the result; </paragraph>
<paragraph id="P-0219" lvl="3"><number>&lsqb;0219&rsqb;</number> (v) the next pattern &ldquo;11&rdquo; indicates that the signals provided by the divider decision table logic <highlight><bold>15</bold></highlight> will provide asserted signals to both AND circuits <highlight><bold>65</bold></highlight> and <highlight><bold>66</bold></highlight>, enabling both AND gates to couple signals received thereby from both operand buffers <highlight><bold>11</bold></highlight>A and <highlight><bold>11</bold></highlight>B to the OR circuit <highlight><bold>63</bold></highlight>; and </paragraph>
<paragraph id="P-0220" lvl="3"><number>&lsqb;0220&rsqb;</number> (vi) the last pattern &ldquo;00000&rdquo; indicates that the signals provided by the divider decision table logic <highlight><bold>15</bold></highlight> to the OR circuit <highlight><bold>63</bold></highlight> are all negated. With such a last pattern, the OR gate will perform a bit-wise OR operation in connection with those signals and the signals provided thereto by AND circuits <highlight><bold>65</bold></highlight> and <highlight><bold>66</bold></highlight>. Further, the negated signal described in (B)(ii) provides that the signals provided by AND circuit <highlight><bold>64</bold></highlight> are also negated, in which case the signals coupled by OR circuit <highlight><bold>63</bold></highlight> to result bus 17 will correspond to the OR of the bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>from the fraction fields of the operands in operand buffers <highlight><bold>11</bold></highlight>A and <highlight><bold>11</bold></highlight>B. </paragraph>
<paragraph id="P-0221" lvl="0"><number>&lsqb;0221&rsqb;</number> On the right hand side of the first row in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>A, the legend &ldquo;&lsqb;NaN op1 f1&verbar;f2&rsqb;&rdquo; indicates that the result value is in the NaN format <highlight><bold>76</bold></highlight>, with the bits f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb&plus;5 </subscript></highlight>of the fraction field of the result corresponding to bits f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb&plus;5 </subscript></highlight>of the fraction field of the operand in operand buffer <highlight><bold>11</bold></highlight>A and the bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the result corresponding to the OR of the bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction fields of the operands in both operand buffers <highlight><bold>11</bold></highlight>A and <highlight><bold>11</bold></highlight>B. It should be noted that this corresponds to the result represented by symbol (&tilde;) in the table depicted in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>. </paragraph>
<paragraph id="P-0222" lvl="0"><number>&lsqb;0222&rsqb;</number> In the context of the above discussion, the other rows of <cross-reference target="DRAWINGS">FIG. 4</cross-reference>A and the rows in FIGS. <highlight><bold>4</bold></highlight>B-<highlight><bold>4</bold></highlight>C will be apparent to those skilled in the art. </paragraph>
<paragraph id="P-0223" lvl="0"><number>&lsqb;0223&rsqb;</number> As described above, the sign of the result is provided directly by the XOR gate <highlight><bold>54</bold></highlight>. </paragraph>
<paragraph id="P-0224" lvl="0"><number>&lsqb;0224&rsqb;</number> Divider decision table logic <highlight><bold>15</bold></highlight> may be implemented by many different circuit elements that will be apparent to those skilled in the art, including, but not limited to programmable logic arrays, ASIC circuits, general memory registers, other addressable memory storage devices, or a combination thereof. </paragraph>
<paragraph id="P-0225" lvl="0"><number>&lsqb;0225&rsqb;</number> One of ordinary skill in the art will recognize that other formats and bit patterns could be used to represent the floating point operand formats without departing from the principles of the present invention. One of ordinary skill in the art will also recognize that the floating point status information contained in the operands could easily be represented by other bit combinations (not shown) without departing from the principles of the present invention. For example, more or fewer bits could be used, a subset or superset of the exemplary status bits could be used, or the most significant bits of an operand (or some other subset of bits) could be used to indicate the floating point status information, instead of the least significant bits illustrated. </paragraph>
<paragraph id="P-0226" lvl="0"><number>&lsqb;0226&rsqb;</number> It will be appreciated that a system in accordance with an embodiment of the invention can be constructed in whole or in part from special purpose hardware or a general purpose computer system, or any combination thereof. Any portion of such a system may be controlled by a suitable program. Any program may in whole or in part comprise part of or be stored on the system in a conventional manner, or it may in whole or in part be provided in to the system over a network or other mechanism for transferring information in a conventional manner. In addition, it will be appreciated that the system may be operated and/or otherwise controlled by means of information provided by an operator using operator input elements (not shown) which may be connected directly to the system or which may transfer the information to the system over a network or other mechanism for transferring information in a conventional manner. </paragraph>
<paragraph id="P-0227" lvl="0"><number>&lsqb;0227&rsqb;</number> The foregoing description has been limited to a specific embodiment of this invention. It will be apparent, however, that various variations and modifications may be made to the invention, with the attainment of some or all of the advantages of the invention. It is the object of the appended claims to cover these and such other variations and modifications as come within the true spirit and scope of the invention. </paragraph>
<paragraph id="P-0228" lvl="0"><number>&lsqb;0228&rsqb;</number> Other embodiments of the invention will be apparent to those skilled in the art from consideration of the specification and practice of the invention disclosed herein. It is intended that the specification and examples be considered as exemplary only, with a true scope and spirit of the invention being indicated by the following claims. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A system for providing a floating point division, comprising: 
<claim-text>an analyzer circuit configured to determine a first status of a first floating point operand and a second status of a second floating point operand based upon data within the first floating point operand and data within the second floating point operand respectively; and </claim-text>
<claim-text>a results circuit coupled to the analyzer circuit and configured to assert a resulting floating point operand containing the result of the division of the first floating point operand by the second floating point operand and a resulting status embedded within the resulting floating point operand. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The system for providing a floating point division of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the analyzer circuit further comprises: 
<claim-text>a first operand buffer configured to store the first floating point operand; </claim-text>
<claim-text>a second operand buffer configured to store the second floating point operand; </claim-text>
<claim-text>a first operand analysis circuit coupled to the first operand buffer, the first operand analysis circuit configured to generate a first characteristic signal having information relating to the first status; and </claim-text>
<claim-text>a second operand analysis circuit coupled to the second operand buffer, the second operand analysis circuit configured to generate a second characteristic signal having information relating to the second status. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The system for providing a floating point division of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, wherein the first status and the second status are determined without regard to memory storage external to the first operand buffer and the second operand buffer. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The system for providing a floating point division of <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference>, wherein the memory storage external to the first operand buffer and the second operand buffer is a floating point status register. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The system for providing a floating point division of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the results circuit further comprises: 
<claim-text>a divider circuit coupled to the analyzer circuit, the divider circuit configured to produce the result of the division of the first floating point operand by the second floating point operand; </claim-text>
<claim-text>a divider logic circuit coupled to the analyzer circuit and configured to produce the resulting status based upon the first status and the second status; and </claim-text>
<claim-text>a result assembler coupled to the divider circuit and the divider logic circuit, the result assembler configured to assert the resulting floating point operand and embed the resulting status within the resulting floating point operand. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The system for providing a floating point division of <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference>, wherein the divider logic circuit is organized according to the structure of a decision table. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The system for providing a floating point division of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the first status, the second status, and the resulting status are each one of the following: an invalid operation status, an overflow status, an underflow status, a division by zero status, an infinity status, and an inexact status. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The system for providing a floating point division of <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference>, wherein the overflow status represents one in a group of a &plus;ON status and a &minus;ON status. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The system for providing a floating point division of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference>, wherein the overflow status is represented as a predetermined non-infinity numerical value. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The system for providing a floating point division of <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference>, wherein the underflow status represents one in a group of a &plus;UN status and a &minus;UN status. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The system for providing a floating point divider of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein the underflow status is represented as a predetermined non-zero numerical value. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The system for providing a floating point division of <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference>, wherein the invalid status represents a not-a-number (NaN) status due to an invalid operation. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The system for providing a floating point division of <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference>, wherein the infinity status represents one in a group of a positive infinity status and a negative infinity status. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. A method for providing a floating point division, comprising: 
<claim-text>determining a first status of a first floating point operand and a second status of a second floating point operand based upon data within the first floating point operand and data within the second floating point operand respectively; and </claim-text>
<claim-text>asserting a resulting floating point operand containing the result of the division of the first floating point operand by the second floating point operand and a resulting status embedded within the resulting floating point operand. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The method for providing a floating point division of <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference>, wherein the determining stage further comprises: 
<claim-text>storing the first floating point operand in a first operand buffer; </claim-text>
<claim-text>storing the second floating point operand in a second operand buffer; </claim-text>
<claim-text>generating a first characteristic signal representative of the first status; and </claim-text>
<claim-text>generating a second characteristic signal representative of the second status. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The method for providing a floating point division of <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference>, wherein the first characteristic signal and the second characteristic signal are generated without regard to memory storage external to the first operand buffer and the second operand buffer. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The method for providing a floating point division of <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, wherein the memory storage external to the first operand buffer and the second operand buffer is a floating point status register. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The method for providing a floating point division of <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference>, wherein the asserting stage further comprises: 
<claim-text>producing the result of the division of the first floating point operand by the second floating point operand; and </claim-text>
<claim-text>asserting the resulting floating point operand having the resulting status embedded within the resulting floating point operand. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The method for providing a floating point division of <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference>, wherein the first status, the second status, and the resulting status are each one of the following: an invalid operation status, an overflow status, an underflow status, a division by zero status, an infinity status, and an inexact status. </claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The method for providing a floating point division of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference>, wherein the overflow status represents one in a group of a &plus;OV status and a &minus;OV status. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The method for providing a floating point division of <dependent-claim-reference depends_on="CLM-00022">claim 20</dependent-claim-reference>, wherein the overflow status is represented as a predetermined non-infinity numerical value. </claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The method for providing a floating point division of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference>, wherein the underflow status represents one in a group of a &plus;UN status and a &minus;UN status. </claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The method for providing a floating point division of <dependent-claim-reference depends_on="CLM-00022">claim 22</dependent-claim-reference>, wherein the underflow status is represented as a predetermined non-zero numerical value. </claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The method for providing a floating point division of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference>, wherein the invalid status represents a not-a-number (NaN) status due to an invalid operation. </claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. The method for providing a floating point division of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference>, wherein the infinity status represents one in a group of a positive infinity status and a negative infinity status. </claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. A computer-readable medium on which is stored a set of instructions for providing a floating point division, which when executed perform stages comprising: 
<claim-text>determining a first status of a first floating point operand and a second status of a second floating point operand based upon data within the first floating point operand and data within the second floating point operand respectively; and </claim-text>
<claim-text>asserting a resulting floating point operand containing the result of the division of the first floating point operand by the second floating point operand and a resulting status embedded within the resulting floating point operand. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00022">claim 26</dependent-claim-reference>, wherein the determining stage further comprises: 
<claim-text>storing the first floating point operand in a first operand buffer; </claim-text>
<claim-text>storing the second floating point operand in a second operand buffer; </claim-text>
<claim-text>generating a first characteristic signal representative of the first status; and </claim-text>
<claim-text>generating a second characteristic signal representative of the second status. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00022">claim 27</dependent-claim-reference>, wherein the first characteristic signal and the second characteristic signal are generated without regard to memory storage external to the first operand buffer and the second operand buffer. </claim-text>
</claim>
<claim id="CLM-00029">
<claim-text><highlight><bold>29</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00022">claim 28</dependent-claim-reference>, wherein the memory storage external to the first operand buffer and the second operand buffer is a floating point status register. </claim-text>
</claim>
<claim id="CLM-00030">
<claim-text><highlight><bold>30</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00022">claim 26</dependent-claim-reference>, wherein the asserting stage further comprises: 
<claim-text>producing the result of the division of the first floating point operand by the second floating point operand; and </claim-text>
<claim-text>asserting the resulting floating point operand having the resulting status embedded within the resulting floating point operand. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00031">
<claim-text><highlight><bold>31</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00022">claim 26</dependent-claim-reference>, wherein the first status, the second status, and the resulting status are each one of the following: an invalid operation status, an overflow status, an underflow status, a division by zero status, an infinity status, and an inexact status. </claim-text>
</claim>
<claim id="CLM-00032">
<claim-text><highlight><bold>32</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00033">claim 31</dependent-claim-reference>, wherein the overflow status represents one in a group of a &plus;OV status and a &minus;OV status. </claim-text>
</claim>
<claim id="CLM-00033">
<claim-text><highlight><bold>33</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00033">claim 32</dependent-claim-reference>, wherein the overflow status is represented as a predetermined non-infinity numerical value. </claim-text>
</claim>
<claim id="CLM-00034">
<claim-text><highlight><bold>34</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00033">claim 31</dependent-claim-reference>, wherein the underflow status represents one in a group of a &plus;UN status and a &minus;UN status. </claim-text>
</claim>
<claim id="CLM-00035">
<claim-text><highlight><bold>35</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00033">claim 34</dependent-claim-reference>, wherein the underflow status is represented as a predetermined non-zero numerical value. </claim-text>
</claim>
<claim id="CLM-00036">
<claim-text><highlight><bold>36</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00033">claim 31</dependent-claim-reference>, wherein the invalid status represents a not-a-number (NaN) status due to an invalid operation. </claim-text>
</claim>
<claim id="CLM-00037">
<claim-text><highlight><bold>37</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00033">claim 31</dependent-claim-reference>, wherein the infinity status represents one in a group of a positive infinity status and a negative infinity status.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>1</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005014A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005014A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005014A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005014A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005014A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005014A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030005014A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
