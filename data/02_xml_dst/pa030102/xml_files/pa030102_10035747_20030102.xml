<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005013A1-20030102-D00000.TIF SYSTEM "US20030005013A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005013A1-20030102-D00001.TIF SYSTEM "US20030005013A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005013A1-20030102-D00002.TIF SYSTEM "US20030005013A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005013A1-20030102-D00003.TIF SYSTEM "US20030005013A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005013A1-20030102-D00004.TIF SYSTEM "US20030005013A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005013A1-20030102-D00005.TIF SYSTEM "US20030005013A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030005013A1-20030102-D00006.TIF SYSTEM "US20030005013A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030005013A1-20030102-D00007.TIF SYSTEM "US20030005013A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030005013A1-20030102-D00008.TIF SYSTEM "US20030005013A1-20030102-D00008.TIF" NDATA TIF>
<!ENTITY US20030005013A1-20030102-D00009.TIF SYSTEM "US20030005013A1-20030102-D00009.TIF" NDATA TIF>
<!ENTITY US20030005013A1-20030102-D00010.TIF SYSTEM "US20030005013A1-20030102-D00010.TIF" NDATA TIF>
<!ENTITY US20030005013A1-20030102-D00011.TIF SYSTEM "US20030005013A1-20030102-D00011.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005013</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10035747</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20011228</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F007/38</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>708</class>
<subclass>495000</subclass>
</uspc>
</classification-us-primary>
<classification-us-secondary>
<uspc>
<class>708</class>
<subclass>525000</subclass>
</uspc>
</classification-us-secondary>
</classification-us>
<title-of-invention>Floating point system that represents status flag information within a floating point operand</title-of-invention>
</technical-information>
<continuity-data>
<non-provisional-of-provisional>
<document-id>
<doc-number>60293173</doc-number>
<document-date>20010525</document-date>
<country-code>US</country-code>
</document-id>
</non-provisional-of-provisional>
</continuity-data>
<inventors>
<first-named-inventor>
<name>
<given-name>Guy</given-name>
<middle-name>L.</middle-name>
<family-name>Steele</family-name>
<name-suffix>JR.</name-suffix>
</name>
<residence>
<residence-us>
<city>Lexington</city>
<state>MA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
</inventors>
<assignee>
<organization-name>Sun Microsystems, Inc.</organization-name>
<assignee-type>02</assignee-type>
</assignee>
<correspondence-address>
<name-1>Finnegan, Henderson, Farabow,</name-1>
<name-2>Garrett &amp; Dunner, L.L.P.</name-2>
<address>
<address-1>1300 I Street, N.W.</address-1>
<city>Washington</city>
<state>DC</state>
<postalcode>20005-3315</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A floating point unit generates results in which status information generated for an operation is encoded within the resulting operand, instead of requiring a separate floating point status register for the status information. In one embodiment, a floating point operand data structure comprises a first portion having floating point operand data and a second portion having embedded status information associated with at least one status condition of the operand data. The status condition may be determined from only the embedded status information. The status condition may also be associated with at least one floating point operation that generated the operand data structure. The outcome of a conditional floating point instruction may be based on the embedded status information without regard to contents of the floating point status register. The second portion of the data structure may also have at least one bit indicative of the status condition, such as an invalid operation status, an overflow status, an underflow status, a division by zero status, an infinity status, and an inexact status. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">DESCRIPTION OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> 1. Field of the Invention </paragraph>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> The invention generally relates to systems and methods for performing floating point arithmetic computations, and more particularly to systems and methods for performing floating point computations which conform to behavior specified in IEEE Standard (&ldquo;Std.&rdquo;) 754 using a modified or enhanced format for the floating point operand. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> 2. Background of the Invention </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> Digital electronic devices, such as digital computers, calculators, and other devices, perform arithmetic calculations on values in integer, or &ldquo;fixed point,&rdquo; format, in fractional, or &ldquo;floating point&rdquo; format, or both. Those skilled in the art will appreciate that IEEE Standard 754 (hereinafter &ldquo;IEEE Std. 754&rdquo; or &ldquo;the Standard&rdquo;) is a conventional standard that was published in 1985 by the Institute of Electrical and Electronic Engineers, and adopted by the American National Standards Institute (ANSI). IEEE Std. 754 defines several standard formats for expressing values in floating point format, and a number of aspects regarding behavior of computation in connection therewith. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> Fundamentally and in accordance with IEEE Std. 754, a value in representation in floating point format comprises a plurality of binary digits, or &ldquo;bits,&rdquo; having the structure</paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>se</italic></highlight><highlight><subscript>msb </subscript></highlight><highlight><italic>. . . e</italic></highlight><highlight><subscript>lsb</subscript></highlight><highlight><italic>f</italic></highlight><highlight><subscript>msb </subscript></highlight><highlight><italic>. . . f</italic></highlight><highlight><subscript>lsb</subscript></highlight></in-line-formula></paragraph>
<paragraph id="P-0006" lvl="7"><number>&lsqb;0006&rsqb;</number> where bit &ldquo;s&rdquo; is a sign bit indicating whether the entire value is positive or negative. Bits &ldquo;e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb</subscript></highlight>&rdquo; comprise an exponent field representing the exponent &ldquo;e&rdquo; in unsigned binary biased format. Finally, bits &ldquo;f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb</subscript></highlight>&rdquo; comprise a fraction field that represents the fractional portion &ldquo;f&rdquo; in unsigned binary format (&ldquo;msb&rdquo; represents &ldquo;most significant bit&rdquo; and &ldquo;lsb&rdquo; represents &ldquo;least significant bit&rdquo;). The Standard defines two general formats, namely, a &ldquo;single&rdquo; format which comprises thirty-two bits, and a &ldquo;double format which comprises sixty-four bits. In the single format, there is one sign bit &ldquo;s,&rdquo; eight bits &ldquo;e<highlight><subscript>7 </subscript></highlight>. . . e<highlight><subscript>0</subscript></highlight>&rdquo; comprising the exponent field and twenty-three bits &ldquo;f<highlight><subscript>22 </subscript></highlight>. . . f<highlight><subscript>0</subscript></highlight>&rdquo; comprising the fraction field. In the double format, there is one sign bit &ldquo;s,&rdquo; eleven bits &ldquo;e<highlight><subscript>10 </subscript></highlight>. . . e<highlight><subscript>0</subscript></highlight>&rdquo; comprising the exponent field and fifty-two bits &ldquo;f<highlight><subscript>51 </subscript></highlight>. . . f<highlight><subscript>0</subscript></highlight>&rdquo; comprising the fraction field. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> As indicated above, the exponent field of the floating point representation &ldquo;e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb</subscript></highlight>&rdquo; represents the exponent &ldquo;E&rdquo; in biased format. The biased format provides a mechanism by which the sign of the exponent is implicitly indicated. Those skilled in the art will appreciate that the bits &ldquo;e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb</subscript></highlight>&rdquo; represent a binary encoded value &ldquo;e&rdquo; such that &ldquo;e&equals;E&plus;bias.&rdquo; This allows the exponent E to extend from &minus;126 to &plus;127, in the eight-bit &ldquo;single&rdquo; format, and from &minus;1022 to &plus;1023 in the eleven-bit &ldquo;double&rdquo; format, and provides for relatively easy manipulation of the exponents in multiplication and division operations, in which the exponents are added and subtracted, respectively. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> IEEE Std. 754 provides for several different formats with both the single and double formats which are generally based on the bit patterns of the bits &ldquo;e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb</subscript></highlight>&rdquo; comprising the exponent field and the bits &ldquo;f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb</subscript></highlight>&rdquo; comprising the fraction field. The formats are generally depicted in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>. If a number is represented such that all of the bits &ldquo;e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb</subscript></highlight>&rdquo; of the exponent field are binary one&apos;s (i.e., if the bits represent a binary-encoded value of &ldquo;255&rdquo; in the single format or &ldquo;2047&rdquo; in the double format) and all of the bits &ldquo;f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb</subscript></highlight>&rdquo; of the fraction field are binary zeros, then the value of the number is positive or negative infinity, depending on the value of the sign bit &ldquo;s.&rdquo; In particular, the value &ldquo;v&rdquo; is v&equals;(&minus;1)<highlight><superscript>s</superscript></highlight>&infin;, where &ldquo;&infin;&rdquo; represents the value &ldquo;infinity&rdquo; (reference format <highlight><bold>33</bold></highlight>). On the other hand, if all of the bits &ldquo;e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb</subscript></highlight>&rdquo; of the exponent field are binary one&apos;s and if the bits &ldquo;f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb</subscript></highlight>&rdquo; of the fraction field are not all zero&apos;s, then the value that is represented is conventionally deemed &ldquo;not a number&rdquo; and abbreviated in the Standard as &ldquo;NaN&rdquo; (reference format <highlight><bold>34</bold></highlight>). </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> If a number has an exponent field in which the bits &ldquo;e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb</subscript></highlight>&rdquo; are neither all binary ones nor all binary zeros (i.e., if the bits represent a binary-encoded value between 1 and 254 in the single format or between 1 and 2046 in the double format), the number is said to be in a &ldquo;normalized&rdquo; format (reference format <highlight><bold>32</bold></highlight>). For a number in the normalized format, the value represented by the number is v&equals;(&minus;1)<highlight><superscript>s</superscript></highlight>2<highlight><superscript>e&minus;bias</superscript></highlight>(1.&verbar;f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb</subscript></highlight>), where &ldquo;&verbar;&rdquo; represents a concatenation operation. In the normalized format, there is an implicit most significant digit having the value &ldquo;one.&rdquo; In this manner, 23 digits in the fraction field of the single format or 52 digits in the fraction field of the double format will effectively represent a value having 24 digits or 53 digits of precision, respectively, where the value is less than 2, but not less than 1. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> On the other hand, if a number has an exponent filed in which the bits &ldquo;e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb</subscript></highlight>&rdquo; are all binary zeros, representing the binary-encoded value of &ldquo;zero,&rdquo; and a fraction field in which the bits f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb</subscript></highlight>&rdquo; are not all zero, the number is said to be in a &ldquo;de-normalized&rdquo; format (reference format <highlight><bold>31</bold></highlight>). For a number in the de-normalized format, the value represented by the number is v&equals;(&minus;1)<highlight><superscript>s</superscript></highlight>2<highlight><superscript>e&minus;bias&plus;1</superscript></highlight>(0.&verbar;f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb</subscript></highlight>). For both single and double formats, it will be appreciated that the range of values of numbers that can be expressed in the de-normalized format is disjoint from the range of values of numbers that can be expressed in the normalized format. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> Finally, if a number has an exponent field in which the bits &ldquo;e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb</subscript></highlight>&rdquo; are all binary zeros, representing the binary-encoded value of &ldquo;zero,&rdquo; and a fraction field in which the bits &ldquo;f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb</subscript></highlight>&rdquo; are all zero, the number has the value &ldquo;zero&rdquo; (reference format <highlight><bold>30</bold></highlight>). Depending on the value of the sign bit, it will be appreciated that the value &ldquo;zero&rdquo; may be positive zero or negative zero. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> Generally, circuits or devices that perform floating point computations or operations (generally referred to as floating point units) conforming to IEEE Std. 754 are designed to generate a result in three steps: </paragraph>
<paragraph id="P-0013" lvl="2"><number>&lsqb;0013&rsqb;</number> (a) In the first step, an approximation calculation step, an approximation to the absolutely accurate mathematical result (assuming that the input operands represent the specific mathematical values as described by IEEE Std. 754) is calculated that is sufficiently precise as to allow this accurate mathematical result to be summarized. The summarized result is usually represented by a sign bit, an exponent (typically represented using more bits than are used for an exponent in the standard floating-point format), and some number &ldquo;N&rdquo; of bits of the presumed result fraction, plus a guard bit and a sticky bit. The value of the exponent will be such that the value of the fraction generated in step (a) consists of a 1 before the binary point and a fraction after the binary point. The bits are commonly calculated so as to obtain the same result as the following conceptual procedure (which is impossible under some circumstances to carry out in practice): calculate the mathematical result to an infinite number of bits of precision in binary scientific notation, and in such a way that there is no bit position in the significand such that all bits of lesser significance are 1-bits (this restriction avoids the ambiguity between, for example, 1.100000 . . . and 1.011111 . . . as representations of the value &ldquo;one-and-one-half&rdquo;); let the N most significant bits of the infinite significand be used as the intermediate result significand; let the next bit of the infinite significand be the guard bit; and let the sticky bit be 0 if and only if ALL remaining bits of the infinite significant are 0-bits (in other words, the sticky bit is the logical OR of all remaining bits of the infinite fraction after the guard bit). </paragraph>
<paragraph id="P-0014" lvl="2"><number>&lsqb;0014&rsqb;</number> (b) In the second step, a rounding step, the guard bit, the sticky bit, perhaps the sign bit, and perhaps some of the bits of the presumed significand generated in step (a) are used to decide whether to alter the result of step (a). For conventional rounding modes defined by IEEE Std. 754, this is a decision as to whether to increase the magnitude of the number represented by the presumed exponent and fraction generated in step (a). Increasing the magnitude of the number is done by adding 1 to the significand in its least significant bit position, as if the significand were a binary integer. It will be appreciated that, if the significand is all 1-bits, the magnitude of the number is &ldquo;increased&rdquo; by changing it to a high-order 1-bit followed by all 0-bits and adding 1 to the exponent. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> Regarding the rounding modes, it will be further appreciated that, </paragraph>
<paragraph id="P-0016" lvl="2"><number>&lsqb;0016&rsqb;</number> (i) if the result is a positive number, and </paragraph>
<paragraph id="P-0017" lvl="3"><number>&lsqb;0017&rsqb;</number> (a) if the decision is made to increase, effectively the decision has been made to increase the value of the result, thereby rounding the result up (i.e., towards positive infinity), but </paragraph>
<paragraph id="P-0018" lvl="3"><number>&lsqb;0018&rsqb;</number> (b) if the decision is made not to increase, effectively the decision has been made to decrease the value of the result, thereby rounding the result down (i.e., towards negative infinity); and </paragraph>
<paragraph id="P-0019" lvl="2"><number>&lsqb;0019&rsqb;</number> (ii) if the result is a negative number, and </paragraph>
<paragraph id="P-0020" lvl="3"><number>&lsqb;0020&rsqb;</number> (a) if the decision is made to increase, effectively the decision has been made to decrease the value of the result, thereby rounding the result down, but </paragraph>
<paragraph id="P-0021" lvl="3"><number>&lsqb;0021&rsqb;</number> (b) if the decision is made not to increase, effectively the decision has been made to increase the value of the result, thereby rounding the result up. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> For example, IEEE Std. 754 defines a round-toward-nearest mode in which the least significant bit (lsb) of the significand, the guard bit, and the sticky bit are examined to decide if an increase is made according to the following decision table:  
<table-cwu id="TABLE-US-00001">
<number>1</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="5">
<colspec colname="1" colwidth="56PT" align="center"/>
<colspec colname="2" colwidth="21PT" align="center"/>
<colspec colname="3" colwidth="56PT" align="center"/>
<colspec colname="4" colwidth="14PT" align="center"/>
<colspec colname="5" colwidth="70PT" align="center"/>
<thead>
<row>
<entry namest="1" nameend="5" align="center">TABLE 1</entry>
</row>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="5" align="center" rowsep="1"></entry>
</row>
<row>
<entry>lsb</entry>
<entry>guard</entry>
<entry>sticky</entry>
<entry>*</entry>
<entry>increase&quest;</entry>
</row>
<row><entry namest="1" nameend="5" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>0</entry>
<entry>0</entry>
<entry>0</entry>
<entry>*</entry>
<entry>no</entry>
</row>
<row>
<entry>0</entry>
<entry>0</entry>
<entry>1</entry>
<entry>*</entry>
<entry>no</entry>
</row>
<row>
<entry>0</entry>
<entry>1</entry>
<entry>0</entry>
<entry>*</entry>
<entry>no</entry>
</row>
<row>
<entry>0</entry>
<entry>1</entry>
<entry>1</entry>
<entry>*</entry>
<entry>yes</entry>
</row>
<row>
<entry>1</entry>
<entry>0</entry>
<entry>0</entry>
<entry>*</entry>
<entry>no</entry>
</row>
<row>
<entry>1</entry>
<entry>0</entry>
<entry>1</entry>
<entry>*</entry>
<entry>no</entry>
</row>
<row>
<entry>1</entry>
<entry>1</entry>
<entry>0</entry>
<entry>*</entry>
<entry>yes</entry>
</row>
<row>
<entry>1</entry>
<entry>1</entry>
<entry>1</entry>
<entry>*</entry>
<entry>yes</entry>
</row>
<row><entry namest="1" nameend="5" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0023" lvl="7"><number>&lsqb;0023&rsqb;</number> where &ldquo;sign&rdquo; bit, &ldquo;guard&rdquo; refers to the guard bit, and &ldquo;sticky&rdquo; refers to the sticky bit, and &ldquo;increase&quest;&rdquo; refers to the decision as to whether to increase the magnitude of the number generated in step (a). This may also be described by the Boolean expression &ldquo;guard AND (lsb OR sticky).&rdquo;</paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> IEEE Std. 754 defines a round-toward-minus-infinity mode in which the decision as to whether to increase is made according to the following decision table:  
<table-cwu id="TABLE-US-00002">
<number>2</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="5">
<colspec colname="1" colwidth="56PT" align="center"/>
<colspec colname="2" colwidth="21PT" align="center"/>
<colspec colname="3" colwidth="56PT" align="center"/>
<colspec colname="4" colwidth="14PT" align="center"/>
<colspec colname="5" colwidth="70PT" align="center"/>
<thead>
<row>
<entry namest="1" nameend="5" align="center">TABLE 2</entry>
</row>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="5" align="center" rowsep="1"></entry>
</row>
<row>
<entry>sign</entry>
<entry>guard</entry>
<entry>sticky</entry>
<entry>*</entry>
<entry>increase&quest;</entry>
</row>
<row><entry namest="1" nameend="5" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>0</entry>
<entry>0</entry>
<entry>0</entry>
<entry>*</entry>
<entry>no</entry>
</row>
<row>
<entry>0</entry>
<entry>0</entry>
<entry>1</entry>
<entry>*</entry>
<entry>no</entry>
</row>
<row>
<entry>0</entry>
<entry>1</entry>
<entry>0</entry>
<entry>*</entry>
<entry>no</entry>
</row>
<row>
<entry>0</entry>
<entry>1</entry>
<entry>1</entry>
<entry>*</entry>
<entry>no</entry>
</row>
<row>
<entry>1</entry>
<entry>0</entry>
<entry>0</entry>
<entry>*</entry>
<entry>no</entry>
</row>
<row>
<entry>1</entry>
<entry>0</entry>
<entry>1</entry>
<entry>*</entry>
<entry>yes</entry>
</row>
<row>
<entry>1</entry>
<entry>1</entry>
<entry>0</entry>
<entry>*</entry>
<entry>yes</entry>
</row>
<row>
<entry>1</entry>
<entry>1</entry>
<entry>1</entry>
<entry>*</entry>
<entry>yes</entry>
</row>
<row><entry namest="1" nameend="5" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0025" lvl="7"><number>&lsqb;0025&rsqb;</number> This may also be described by the Boolean expression &ldquo;(guard OR sticky) AND sign.&rdquo;</paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> IEEE Std. 754 defines a round-toward-plus-infinity mode in which the decision as to whether to increase is made according to the following decision table:  
<table-cwu id="TABLE-US-00003">
<number>3</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="5">
<colspec colname="1" colwidth="56PT" align="center"/>
<colspec colname="2" colwidth="21PT" align="center"/>
<colspec colname="3" colwidth="56PT" align="center"/>
<colspec colname="4" colwidth="14PT" align="center"/>
<colspec colname="5" colwidth="70PT" align="center"/>
<thead>
<row>
<entry namest="1" nameend="5" align="center">TABLE 3</entry>
</row>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="5" align="center" rowsep="1"></entry>
</row>
<row>
<entry>sign</entry>
<entry>guard</entry>
<entry>sticky</entry>
<entry>*</entry>
<entry>increase&quest;</entry>
</row>
<row><entry namest="1" nameend="5" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>0</entry>
<entry>0</entry>
<entry>0</entry>
<entry>*</entry>
<entry>no</entry>
</row>
<row>
<entry>0</entry>
<entry>0</entry>
<entry>1</entry>
<entry>*</entry>
<entry>yes</entry>
</row>
<row>
<entry>0</entry>
<entry>1</entry>
<entry>0</entry>
<entry>*</entry>
<entry>yes</entry>
</row>
<row>
<entry>0</entry>
<entry>1</entry>
<entry>1</entry>
<entry>*</entry>
<entry>yes</entry>
</row>
<row>
<entry>1</entry>
<entry>0</entry>
<entry>0</entry>
<entry>*</entry>
<entry>no</entry>
</row>
<row>
<entry>1</entry>
<entry>0</entry>
<entry>1</entry>
<entry>*</entry>
<entry>no</entry>
</row>
<row>
<entry>1</entry>
<entry>1</entry>
<entry>0</entry>
<entry>*</entry>
<entry>no</entry>
</row>
<row>
<entry>1</entry>
<entry>1</entry>
<entry>1</entry>
<entry>*</entry>
<entry>no</entry>
</row>
<row><entry namest="1" nameend="5" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0027" lvl="7"><number>&lsqb;0027&rsqb;</number> This may also be described by the Boolean expression &ldquo;(guard OR sticky) AND NOT sign. &rdquo;</paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> Finally IEEE Std. 754 defines a round-toward-zero mode in which the decision as to whether to increase is made according to the following decision table:  
<table-cwu id="TABLE-US-00004">
<number>4</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="5">
<colspec colname="1" colwidth="56PT" align="center"/>
<colspec colname="2" colwidth="21PT" align="center"/>
<colspec colname="3" colwidth="56PT" align="center"/>
<colspec colname="4" colwidth="14PT" align="center"/>
<colspec colname="5" colwidth="70PT" align="center"/>
<thead>
<row>
<entry namest="1" nameend="5" align="center">TABLE 4</entry>
</row>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="5" align="center" rowsep="1"></entry>
</row>
<row>
<entry>sign</entry>
<entry>guard</entry>
<entry>sticky</entry>
<entry>*</entry>
<entry>increase&quest;</entry>
</row>
<row><entry namest="1" nameend="5" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>0</entry>
<entry>0</entry>
<entry>0</entry>
<entry>*</entry>
<entry>no</entry>
</row>
<row>
<entry>0</entry>
<entry>0</entry>
<entry>1</entry>
<entry>*</entry>
<entry>no</entry>
</row>
<row>
<entry>0</entry>
<entry>1</entry>
<entry>0</entry>
<entry>*</entry>
<entry>no</entry>
</row>
<row>
<entry>0</entry>
<entry>1</entry>
<entry>1</entry>
<entry>*</entry>
<entry>no</entry>
</row>
<row>
<entry>1</entry>
<entry>0</entry>
<entry>0</entry>
<entry>*</entry>
<entry>no</entry>
</row>
<row>
<entry>1</entry>
<entry>0</entry>
<entry>1</entry>
<entry>*</entry>
<entry>no</entry>
</row>
<row>
<entry>1</entry>
<entry>1</entry>
<entry>0</entry>
<entry>*</entry>
<entry>no</entry>
</row>
<row>
<entry>1</entry>
<entry>1</entry>
<entry>1</entry>
<entry>*</entry>
<entry>no</entry>
</row>
<row><entry namest="1" nameend="5" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0029" lvl="7"><number>&lsqb;0029&rsqb;</number> This may also be described by the Boolean expression &ldquo;FALSE.&rdquo; It will be appreciated that, in the &ldquo;round toward zero&rdquo; mode, the decision is made never to increase. </paragraph>
<paragraph id="P-0030" lvl="2"><number>&lsqb;0030&rsqb;</number> (c) In the third step, a packaging step, a result is packaged into a standard floating-point format. This may involve substituting a special representation, such as the representation defined for infinity or NaN if an exceptional situation (such as overflow, underflow, or an invalid operation) was detected. Alternatively, this may involve removing the leading 1-bit (if any) of the fraction, because such leading 1-bits are implicit in the standard format. As another alternative, this may involve shifting the fraction in order to construct a denormalized number. As a specific example, it is assumed that this is the step that forces the result to be a NaN if any input operand is a NaN. In this step, the decision is also made as to whether the result should be an infinity. It will be appreciated that, if the result is to be a NaN or infinity, the original result will be discarded and an appropriate representation will be provided as the result. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> depicts the typical organization for a floating point unit <highlight><bold>10</bold></highlight> for a conventional prior art microprocessor capable of performing the floating point operations described above. With reference to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, the floating point unit includes a number of circuits commonly referred to as functional units. These functional units include an adder <highlight><bold>11</bold></highlight>, a multiplier <highlight><bold>12</bold></highlight>, a divider <highlight><bold>13</bold></highlight>, a square-root unit <highlight><bold>14</bold></highlight>, a maximum/minimum unit <highlight><bold>15</bold></highlight> that delivers the larger or smaller of two operands, a comparator <highlight><bold>16</bold></highlight> that typically delivers one bit or a few bits describing a numerical relationship between two operands, and a tester <highlight><bold>17</bold></highlight> that examines just one operand and delivers one bit or a few bits describing numerical properties of the operand. The functional units are controlled by a control unit <highlight><bold>20</bold></highlight> that interprets program instructions, enables operands to be coupled from a set of floating point registers <highlight><bold>21</bold></highlight> onto respective operand buses <highlight><bold>22</bold></highlight> and <highlight><bold>23</bold></highlight>, generates functional unit control signals that enable respective ones of the functional units <highlight><bold>11</bold></highlight> through <highlight><bold>17</bold></highlight> to receive the operand or operands and perform their respective operations to generate a result. If the functional unit control signals enable one of the functional units <highlight><bold>11</bold></highlight> through <highlight><bold>16</bold></highlight> to operate, the result is coupled onto a result bus <highlight><bold>24</bold></highlight> and stored in the floating point registers <highlight><bold>21</bold></highlight>. In addition, if the functional unit control signals enable the comparator <highlight><bold>16</bold></highlight> or the tester <highlight><bold>17</bold></highlight> to operate, the result will be coupled to the control unit <highlight><bold>20</bold></highlight>. Some functional units may be capable of delivering a result to the result bus in the same clock cycle that operands are presented to it. However, other functional units may be pipelined, in which case results are delivered during a clock cycle that is later than the clock cycle during which the corresponding operands were presented to the functional unit. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> Functional units <highlight><bold>11</bold></highlight> through <highlight><bold>14</bold></highlight> also generate floating-point status information, which is typically coupled to a floating point status register <highlight><bold>25</bold></highlight> over floating-point status bus <highlight><bold>26</bold></highlight> for storage therein. The floating point status information is stored and/or accumulated in the floating point status register <highlight><bold>25</bold></highlight>. The floating point status information generated for a particular floating point operation includes indications, for example, as to whether: </paragraph>
<paragraph id="P-0033" lvl="2"><number>&lsqb;0033&rsqb;</number> (i) a particular operand is invalid for the operation to be performed (&ldquo;invalid operation&rdquo;); </paragraph>
<paragraph id="P-0034" lvl="2"><number>&lsqb;0034&rsqb;</number> (ii) if the operation to be performed is division, the divisor is zero (&ldquo;division-by-zero&rdquo;); </paragraph>
<paragraph id="P-0035" lvl="2"><number>&lsqb;0035&rsqb;</number> (iii) an overflow occurred during the operation (&ldquo;overflow&rdquo;); </paragraph>
<paragraph id="P-0036" lvl="2"><number>&lsqb;0036&rsqb;</number> (iv) an underflow occurred during the operation (&ldquo;underflow&rdquo;); and </paragraph>
<paragraph id="P-0037" lvl="2"><number>&lsqb;0037&rsqb;</number> (v) the rounded result of the operation is not exact (&ldquo;inexact&rdquo;). </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> These conditions are typically represented by flags that are stored in the floating point status register <highlight><bold>25</bold></highlight>. The floating point status information can be read from the floating point status register <highlight><bold>25</bold></highlight> by the control unit <highlight><bold>20</bold></highlight> in the same manner as result bits from the comparator or tester, and this information can be used to dynamically control the operations performed by the floating point unit <highlight><bold>10</bold></highlight> in response to certain conditional floating point instructions, such as conditional branch, conditional move, and conditional trap instructions. The outcome of such conditional instructions typically relies upon accessing the floating point status information from the floating point status register <highlight><bold>25</bold></highlight>. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> Also, the floating point status information read from the floating point status register <highlight><bold>25</bold></highlight> may enable the control unit <highlight><bold>20</bold></highlight> to initiate processing of a trap sequence, which will interrupt the normal flow of program execution. In addition, status bits read from the floating point status register <highlight><bold>25</bold></highlight> may be used by the control unit <highlight><bold>20</bold></highlight> to affect certain ones of the functional unit control signals that it sends to the functional units, such as the functional unit control signals that control the rounding mode. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> IEEE Std. 754 has brought relative harmony and stability to floating-point computation and architectural design of floating-point units. Moreover, its design was based on some important principles, and rests on a sensible mathematical semantics that eases the job of programmers and numerical analysts. It also supports the implementation of interval arithmetic, which may prove to be preferable to simple scalar arithmetic for many tasks. Nevertheless, IEEE Std. 754 has some serious drawbacks, including: </paragraph>
<paragraph id="P-0041" lvl="2"><number>&lsqb;0041&rsqb;</number> (i) Modes (e.g., the rounding modes and traps enabled/disabled mode), flags (e.g., flags representing the status information stored in floating point status register <highlight><bold>25</bold></highlight>), and traps required to implement IEEE Std. 754 introduce implicit serialization issues. Implicit serialization is essentially the need for serial control of access (read/write) to and from globally used registers, such as the floating point status register <highlight><bold>25</bold></highlight>. Under IEEE Std. 754, implicit serialization may arise between (1) different concurrent floating-point instructions and (2) between floating point instructions and the instructions that read and write the flags and modes. Furthermore, rounding modes may introduce implicit serialization because they are typically indicated as global state, although in some microprocessor architectures, the rounding mode is encoded as part of the instruction operation code, which will alleviate this problem to that extent. Thus, the potential for implicit serialization makes the Standard difficult to implement coherently and efficiently in today&apos;s superscalar and parallel processing architectures without loss of performance. </paragraph>
<paragraph id="P-0042" lvl="2"><number>&lsqb;0042&rsqb;</number> (ii) The implicit side effects of a procedure that can change the flags or modes can make it very difficult for compilers to perform optimizations on floating point code. As a result, compilers for most languages usually assume that every procedure call is an optimization barrier in order to be safe. This unfortunately may lead to further loss of performance. </paragraph>
<paragraph id="P-0043" lvl="2"><number>&lsqb;0043&rsqb;</number> (iii) Global flags, such as those that signal certain modes, make it more difficult to do instruction scheduling where the best performance is provided by interleaving instructions of unrelated computations. Thus, instructions from regions of code governed by different flag settings or different flag detection requirements cannot easily be interleaved when they must share a single set of global flag bits. </paragraph>
<paragraph id="P-0044" lvl="2"><number>&lsqb;0044&rsqb;</number> (iv) Furthermore, traps have been difficult to integrate efficiently into computing architectures and programming language designs for fine-grained control of algorithmic behavior. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> As noted above, the rounding mode may be eliminated as a global state by statically encoding the rounding mode as part of the instruction operation code. However, there is no existing architecture that eliminates flags and the trap enabled/disabled mode as global state while still supporting similar exception detection capabilities. Thus, there is a need for a system that allows for more efficient processing of floating point operands which eliminates the need to separately access status information separate from the floating point operand data structure itself. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> Methods, systems, data structures and articles of manufacture consistent with the present invention overcome these shortcomings with a new and improved type of floating point operand that advantageously and efficiently eliminates flags as global states while still supporting exception detection capabilities. In brief summary, a floating point unit supporting such an enhanced operand generates results in which floating point status information generated for an operation may be encoded in the result of the operation, i.e., within parts of the operand, and subsequently stored therewith in the floating point register set, instead of requiring a separate floating point status register to receive the status information. Since the floating point status information relating to a floating point operation is in the result generated for the operation, implicit serialization required by maintaining the floating point status information separate and apart therefrom can be advantageously obviated. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> More particularly stated, a floating point operand data structure consistent with the present invention is broadly described herein. The floating point operand data structure can be used in floating point computations and processing within a processing device. The floating point data structure comprises a first portion having floating point operand data and a second portion having embedded status information associated with at least one status condition of the floating point operand data. The status condition may be determined from the embedded status information without regard to memory storage (such as a dedicated floating point status register) external to the data structure. The status condition may also be associated with at least one floating point operation that generated the enhanced floating point operand data structure. The outcome of a conditional floating point instruction may be based on the embedded status information without regard to contents of the floating point status register. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> The second portion of the data structure may also have at least one bit that is indicative of the status condition from the group of an invalid operation status, an overflow status, an underflow status, a division by zero status, an infinity status, and an inexact status. More specifically, the overflow status may represent one in a group of a &plus;OV status and a &minus;OV status and may also represent a predetermined non-infinity numerical value. The underflow status may represent one in a group of a &plus;UV status and a &minus;UV status and may also represent a predetermined non-zero numerical value. The invalid status may represent a not-a-number (NaN) status due to an invalid operation. The infinity status may represent one in a group of a positive infinity status and a negative infinity status. The second portion of the data structure may also include bits indicative of a predetermined type of operand condition resulting in the NaN status or another type of operand condition resulting in the infinity status. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> Using such an enhanced type of data structure for a floating point operand, it will be appreciated that addition, multiplication, maximum and minimum floating point operations on the data structure are commutative. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> In still another aspect of the present invention, a floating point system is broadly described that is consistent with an embodiment of the present invention. The system is associated with a processing device, such as a microprocessor, for performing at least one floating point operation on a floating point operand. The system includes an operand memory storage, a control unit and a first functional unit. The operand memory storage device maintains the floating point operand. The control unit is in communication with the operand memory storage device and receives the floating point instruction associated with the floating point operation to generate at least one control signal related to the floating point operation. The first functional processing unit is in communication with the operand memory storage device and the control unit. The first functional processing unit is capable processing the floating point operand and storing status information within the processed floating point operand. Typically, the status information has at least one bit that is indicative of an operand status condition from the group of an invalid operation status, an overflow status, an underflow status, a division by zero status, an infinity status, and an inexact status. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> In still another aspect of the present invention, a method for encoding a floating point operand with status information is described that is consistent with an embodiment of the present invention. The method begins by determining a status condition of the floating point operand prior to execution of a floating point operation on the floating point operand. The method stores an updated status condition of the floating point operand within the floating point operand after execution of the floating point operation on the floating point operand. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> In more detail, determining the status condition may include identifying the status condition of the floating point operand from only embedded status information within the floating point operand. The status condition is typically from the group of an invalid operation status, an overflow status, an underflow status, a division by zero status, an infinity status, and an inexact status. Furthermore, storing the updated status condition may include embedding updated status information within the floating point operand after execution of the floating point operation. Such updated status information typically represents the updated status condition of the processed floating point operand. The updated status condition is typically from the group of an invalid operation status, an overflow status, an underflow status, a division by zero status, an infinity status, and an inexact status. The updated status condition may be indicative of a previous floating point operation that resulted in the floating point operand. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> The method may also include conditioning a subsequent floating point operation based only upon the updated status information within the floating point operand. Additionally, the method may include processing an additional floating point operand and storing updated status information related to the additional floating point operand within the additional floating point operand while the updated status information related to the other floating point operand is preserved. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> In still another aspect of the present invention, a computer-readable medium is described that is consistent with an embodiment of the present invention. The medium stores a set of instructions for encoding a floating point operand with status information. When executed, the instructions perform the encoding method as described above. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> Additional advantages of the invention will be set forth in part in the description which follows, and in part will be obvious from the description, or may be learned by practice of the invention. The advantages of the invention will be realized and attained by means of the elements and combinations particularly pointed out in the appended claims. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> It is to be understood that both the foregoing general description and the following detailed description are exemplary and explanatory only and are not restrictive of the invention, as claimed. </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> The accompanying drawings, which are incorporated in and constitute a part of this specification, illustrate embodiments of the invention and together with the description, serve to explain the principles of the invention. </paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> The scope of the present invention is pointed out with particularity in the appended claims. The above and further advantages of this invention may be better understood by referring to the following description taken in conjunction with the accompanying drawings, in which: </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a functional block diagram of a prior art floating point unit; </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> depicts prior art formats for representations of floating point values generated by the floating point unit depicted in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>; </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a functional block diagram of an exemplary floating point unit consistent with an embodiment of the present invention; </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> depicts exemplary floating point operand data structure formats for representations of floating point operand values generated by the exemplary floating point unit depicted in <cross-reference target="DRAWINGS">FIG. 3</cross-reference> and consistent with an embodiment of the present invention; and </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 5 through 11</cross-reference> depict exemplary tables that are useful in understanding the operations of exemplary functional units of the floating point unit depicted in <cross-reference target="DRAWINGS">FIG. 3</cross-reference> and consistent with an embodiment of the present invention.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DESCRIPTION OF THE EMBODIMENTS </heading>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> Reference will now be made in detail to exemplary embodiments of the present invention, examples of which are illustrated in the accompanying drawings. Wherever possible, the same reference numbers will be used throughout the drawings to refer to the same or like parts. </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a functional block diagram of an exemplary floating point unit <highlight><bold>40</bold></highlight> consistent with an embodiment of the present invention. With reference to <cross-reference target="DRAWINGS">FIG. 3</cross-reference>, floating point unit <highlight><bold>40</bold></highlight> includes plurality of exemplary functional units. In the exemplary embodiment, these functional units include an adder unit <highlight><bold>41</bold></highlight>, a multiplier unit <highlight><bold>42</bold></highlight>, a divider unit <highlight><bold>43</bold></highlight>, a square root unit <highlight><bold>44</bold></highlight>, a maximum/minimum unit <highlight><bold>45</bold></highlight>, a comparator unit <highlight><bold>46</bold></highlight> and a tester unit <highlight><bold>47</bold></highlight>, all of which operate under control of functional unit control signals provided by a control unit <highlight><bold>50</bold></highlight>. As with the floating point unit <highlight><bold>10</bold></highlight> depicted in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, the control unit <highlight><bold>50</bold></highlight> can enable one or two operands to be coupled from at least one of floating point registers <highlight><bold>51</bold></highlight> onto respective operand buses. In the exemplary embodiment, two operand buses <highlight><bold>52</bold></highlight> and <highlight><bold>53</bold></highlight> are illustrated and provide the operands to operand inputs of the respective functional units <highlight><bold>41</bold></highlight> through <highlight><bold>47</bold></highlight>. Those skilled in the art will recognize that the principles of the present invention contemplate alternative embodiments using single or multiple operand communication pathways in a variety of alternative communication pathway architectures. </paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> The adder <highlight><bold>41</bold></highlight> receives two operands &ldquo;x&rdquo; and &ldquo;y&rdquo; and generates the result of the sum S(x,y)&equals;x&plus;y of the operands. The multiplier <highlight><bold>42</bold></highlight> also receives two operands and generates the result as the multiplicative product P(x,y)&equals;x*y of the values represented by the operands. The divider <highlight><bold>43</bold></highlight> can perform two types of operations. In one type of operation, which will be referred to as &ldquo;division,&rdquo; the divider <highlight><bold>43</bold></highlight> receives two operands and generates the result as the quotient Q(x,y)&equals;x/y of one operand divided by the other operand. In a second operation, which will be referred to as &ldquo;remainder,&rdquo; the divider receives two operands and generates the result as the remainder REM(x,y)&equals;x&minus;(y*n), where &ldquo;n&rdquo; is an integer nearest the value x/y. The square root unit <highlight><bold>44</bold></highlight> receives one operand and generates a result as the square root SR(x)&equals;sqrt(x) of the operand. The maximum/minimum unit <highlight><bold>45</bold></highlight> receives two operands and couples one of the maximum MAX(x,y) or minimum MIN(x,y) of the two operands. The comparator unit <highlight><bold>46</bold></highlight> also receives two operands and identifies which, if either, operand is greater than the other (or equivalently, which operand is less than the other). The tester unit <highlight><bold>47</bold></highlight> receives one operand and provides a result comprising one bit or a few bits describing numerical properties of the operand, as will be described below. </paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> As noted above, the exemplary control unit <highlight><bold>50</bold></highlight> generates functional unit control signals that control exemplary functional units <highlight><bold>41</bold></highlight> through <highlight><bold>47</bold></highlight>. The exemplary control unit <highlight><bold>50</bold></highlight> operates in response to floating point instructions provided thereto by a conventional arrangement not depicted in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>, but which will be familiar to those skilled in the art. In response to the floating point instructions and conventional status signals (not shown, but which will also be apparent to those skilled in the art), the control unit <highlight><bold>50</bold></highlight> generates register control signals that enable the operands to be coupled from the registers <highlight><bold>51</bold></highlight> onto one or more operand buses <highlight><bold>52</bold></highlight> and <highlight><bold>53</bold></highlight>. Examples of such &ldquo;status signals&rdquo; may include results from the comparator and tester as well as status signals (such as zero, negative, carry, or overflow) from an integer unit or &ldquo;I/O transfer complete&rdquo; from an input/output unit. </paragraph>
<paragraph id="P-0068" lvl="0"><number>&lsqb;0068&rsqb;</number> The control unit also generates functional unit control signals that enable respective ones of the functional units <highlight><bold>41</bold></highlight> through <highlight><bold>47</bold></highlight> to receive the operands from the operand buses <highlight><bold>52</bold></highlight> and <highlight><bold>53</bold></highlight>, process the operands accordingly and generate results based upon such processing. In addition, except for results generated by functional unit <highlight><bold>47</bold></highlight> (the tester unit), control unit <highlight><bold>50</bold></highlight> generates register control signals that enable the results to be stored in registers <highlight><bold>51</bold></highlight>. In the embodiment with functional units <highlight><bold>41</bold></highlight> through <highlight><bold>46</bold></highlight>, the results are coupled onto a result bus <highlight><bold>54</bold></highlight>, which transfers the results to the registers <highlight><bold>51</bold></highlight> for storage therein. In this manner, control unit <highlight><bold>50</bold></highlight> is indirectly provided with the resulting operands having updated status information encoded or embedded within the operand itself. </paragraph>
<paragraph id="P-0069" lvl="0"><number>&lsqb;0069&rsqb;</number> The results generated by the comparator unit <highlight><bold>46</bold></highlight> and tester unit <highlight><bold>47</bold></highlight> are typically directly coupled to the control unit <highlight><bold>50</bold></highlight> for use thereby in a conventional manner. In the embodiment illustrated in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>, comparator unit <highlight><bold>46</bold></highlight> is also connected to result bus <highlight><bold>54</bold></highlight> so that results may also be indirectly coupled to control unit <highlight><bold>50</bold></highlight> via register <highlight><bold>51</bold></highlight>. Further, it is contemplated that another embodiment of the present invention may be implemented such that results generated by tester unit <highlight><bold>47</bold></highlight> may be indirectly coupled to control unit <highlight><bold>50</bold></highlight> via result bus <highlight><bold>54</bold></highlight>. </paragraph>
<paragraph id="P-0070" lvl="0"><number>&lsqb;0070&rsqb;</number> It should be noted that floating point unit <highlight><bold>40</bold></highlight> does not include a floating point status register for storing floating point status information, which is provided in the prior art floating point unit <highlight><bold>10</bold></highlight> depicted in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. Instead, the functional units advantageously encode the floating point status information in results (e.g., enhanced or modified floating point operand data structures) that are generated in certain formats. These data structure formats will be illustrated in connection with <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, which depicts floating point formats of operands that the functional units <highlight><bold>41</bold></highlight>-<highlight><bold>47</bold></highlight> may receive and formats of results that they generate. With reference to <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, seven formats are depicted, including a zero format <highlight><bold>60</bold></highlight>, an underflow format <highlight><bold>61</bold></highlight>, a denormalized format <highlight><bold>62</bold></highlight>, a normalized non-zero format <highlight><bold>63</bold></highlight>, and overflow format <highlight><bold>64</bold></highlight>, an infinity format <highlight><bold>65</bold></highlight> and a not-a-number (NaN) format <highlight><bold>66</bold></highlight>. </paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> The zero format <highlight><bold>60</bold></highlight>, which has the same format as conventional zero format <highlight><bold>30</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 2</cross-reference>), is used to represent the values &ldquo;zero.&rdquo; More specifically, the zero format <highlight><bold>60</bold></highlight> represents positive or negative zero, depending on the value of &ldquo;s,&rdquo; the sign bit. </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> The underflow format <highlight><bold>61</bold></highlight> provides a mechanism by which a functional unit, such as units <highlight><bold>41</bold></highlight> through <highlight><bold>45</bold></highlight>, can indicate that the result of a computation is an underflow. In the embodiment illustrated in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, the underflow format has a sign bit &ldquo;s&rdquo; that indicates whether the result is positive or negative, bits e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb </subscript></highlight>of the exponent field that are all binary zero&apos;s, and bits f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb&plus;1 </subscript></highlight>of the fraction field, except for the least significant bit, that are all binary zero&apos;s. The least significant bit f<highlight><subscript>lsb </subscript></highlight>of the fraction field is a binary one. </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> The denormalized format <highlight><bold>62</bold></highlight>, except in the case of the values represented by the underflow format <highlight><bold>61</bold></highlight>, and normalized non-zero format <highlight><bold>63</bold></highlight> have the same format as the prior art denormalized and normalized non-zero formats <highlight><bold>31</bold></highlight> and <highlight><bold>32</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 2</cross-reference>) and are used to represent substantially the same range of values. </paragraph>
<paragraph id="P-0074" lvl="0"><number>&lsqb;0074&rsqb;</number> The overflow format <highlight><bold>64</bold></highlight> provides a mechanism by which a functional unit, such as units <highlight><bold>41</bold></highlight> through <highlight><bold>45</bold></highlight>, can indicate that the result of a computation is an overflow. In the embodiment illustrated in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, the overflow format <highlight><bold>64</bold></highlight> has a sign bit &ldquo;s&rdquo; that indicates whether the result is positive or negative and bits e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb&plus;1 </subscript></highlight>of the exponent field that are all binary ones, with the least significant bit e<highlight><subscript>lsb </subscript></highlight>being zero. The bits f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field are all binary ones. </paragraph>
<paragraph id="P-0075" lvl="0"><number>&lsqb;0075&rsqb;</number> The infinity format <highlight><bold>65</bold></highlight> provides a mechanism by which a functional unit, such as units <highlight><bold>41</bold></highlight> through <highlight><bold>45</bold></highlight>, can indicate that the result is infinite. In the embodiment illustrated in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, the infinity format <highlight><bold>65</bold></highlight> has a sign bit &ldquo;s&rdquo; that indicates whether the result is positive or negative, bits e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb </subscript></highlight>of the exponent field that are all binary ones, and bits f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb&plus;5 </subscript></highlight>of the fraction field that are all binary zero&apos;s. The five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field are flags, which will be described below. </paragraph>
<paragraph id="P-0076" lvl="0"><number>&lsqb;0076&rsqb;</number> The NaN (not-a-number) format <highlight><bold>66</bold></highlight> provides a mechanism by which a functional unit, such as units <highlight><bold>41</bold></highlight> through <highlight><bold>45</bold></highlight>, can indicate that the result is not a number. In the embodiment illustrated in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, the NaN format has a sign bit &ldquo;s&rdquo; that can be any value, the bits e<highlight><subscript>msb </subscript></highlight>. . . e<highlight><subscript>lsb </subscript></highlight>of the exponent field are all binary ones, and bits f<highlight><subscript>msb </subscript></highlight>. . . f<highlight><subscript>lsb&plus;5 </subscript></highlight>of the fraction field that are not all binary zero&apos;s. The five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field are flags, which will be described below. </paragraph>
<paragraph id="P-0077" lvl="0"><number>&lsqb;0077&rsqb;</number> As noted above, in both values represented in the infinity format <highlight><bold>65</bold></highlight> and the NaN format <highlight><bold>66</bold></highlight>, the five low order bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field are deemed to be flags. In the illustrated embodiment, the five flags include the flags that are defined by IEEE Std. 754, including an invalid operation flag &ldquo;n,&rdquo; an overflow flag &ldquo;o,&rdquo; an underflow flag &ldquo;u,&rdquo; a division-by-zero flag &ldquo;z,&rdquo; and an inexact flag &ldquo;x.&rdquo; For example, a value in the NaN format <highlight><bold>66</bold></highlight> in which both the overflow flag &ldquo;o&rdquo; and the division-by-zero flag &ldquo;z&rdquo; are set, indicates that the resulting operand value represents a result of a computation that caused an overflow (this from the overflow flag &ldquo;o&rdquo;) as well as an attempt to divide by zero (this from the division-by-zero flag &ldquo;z&rdquo;). It should be noted that the flags provide the same status information as provided by prior art floating point status register <highlight><bold>24</bold></highlight> in prior art floating point unit <highlight><bold>10</bold></highlight>. However, the status information is provided as an embedded part of the result and stored therewith in the registers <highlight><bold>51</bold></highlight>. As a result, the control unit <highlight><bold>50</bold></highlight> can advantageously enable multiple instructions to be contemporaneously executed because the floating point status information generated and stored during execution of one instruction will not over-write previously-stored floating point status information generated during execution of another instruction. In this manner, the floating point status information for each floating point operation is advantageously preserved from being over-written and lost in a computationally intensive computing architecture. </paragraph>
<paragraph id="P-0078" lvl="0"><number>&lsqb;0078&rsqb;</number> In addition to including status information in the five low-order bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field for values in the NaN format <highlight><bold>66</bold></highlight>, other information may also be encoded in the next five low-order bits f<highlight><subscript>lsb&plus;9 </subscript></highlight>. . . f<highlight><subscript>lsb&plus;5</subscript></highlight>. If the value in the NaN format <highlight><bold>66</bold></highlight> is the result of an operation, the other information may indicate the operation and types of operands that gave rise to the result. In one embodiment, the other information is associated with binary encoded values (BEV) of the those bits f<highlight><subscript>lsb&plus;5 </subscript></highlight>. . . f<highlight><subscript>lsb</subscript></highlight><highlight><subscript><highlight><subscript>&mdash;</subscript></highlight></subscript></highlight><highlight><subscript>5 </subscript></highlight>as follows in Table 5.  
<table-cwu id="TABLE-US-00005">
<number>5</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="119PT" align="left"/>
<colspec colname="2" colwidth="70PT" align="center"/>
<colspec colname="3" colwidth="91PT" align="left"/>
<thead>
<row>
<entry namest="1" nameend="3" align="center">TABLE 5</entry>
</row>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Bit Pattern Of Result</entry>
<entry>REV of <highlight><superscript>&fnof;lsb&plus;9 . . . &fnof;lsb&plus;5</superscript></highlight></entry>
<entry>Meaning</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
<entry>0 or 1</entry>
<entry>no specific meaning</entry>
</row>
<row>
<entry>s 11111111 100000000000000010nouzx</entry>
<entry>&ensp;2</entry>
<entry>infinity minus infinity</entry>
</row>
<row>
<entry>s 11111111 100000000000000011nouzx</entry>
<entry>&ensp;3</entry>
<entry>OV minus OV</entry>
</row>
<row>
<entry>s 11111111 100000000000000100nouzx</entry>
<entry>&ensp;4</entry>
<entry>zero times infinity</entry>
</row>
<row>
<entry>s 11111111 100000000000000101nouzx</entry>
<entry>&ensp;5</entry>
<entry>UN times OV</entry>
</row>
<row>
<entry></entry>
<entry>6 or 7</entry>
<entry>no specific meaning</entry>
</row>
<row>
<entry>s 11111111 100000000000001000nouzx</entry>
<entry>&ensp;8</entry>
<entry>zero divided by zero</entry>
</row>
<row>
<entry>s 11111111 100000000000001001nouzx</entry>
<entry>&ensp;9</entry>
<entry>infinity divided by infinity</entry>
</row>
<row>
<entry>s 11111111 100000000000001010nouzx</entry>
<entry>10</entry>
<entry>UN divided by UN</entry>
</row>
<row>
<entry>s 11111111 100000000000001011nouzx</entry>
<entry>11</entry>
<entry>OV divided by OV</entry>
</row>
<row>
<entry>s 11111111 100000000000001100nouzx</entry>
<entry>12</entry>
<entry>square root of less than zero</entry>
</row>
<row>
<entry></entry>
<entry>13-16</entry>
<entry>no specific meaning</entry>
</row>
<row>
<entry>s 11111111 100000000000010001nouzx</entry>
<entry>17</entry>
<entry>remainder by zero</entry>
</row>
<row>
<entry>s 11111111 100000000000010010nouzx</entry>
<entry>18</entry>
<entry>remainder by UN</entry>
</row>
<row>
<entry>s 11111111 100000000000010011nouzx</entry>
<entry>19</entry>
<entry>remainder by OV</entry>
</row>
<row>
<entry>s 11111111 100000000000010100nouzx</entry>
<entry>20</entry>
<entry>remainder of infinity</entry>
</row>
<row>
<entry>s 11111111 100000000000010101nouzx</entry>
<entry>21</entry>
<entry>remainder of infinity by zero</entry>
</row>
<row>
<entry>s 11111111 100000000000010110nouzx</entry>
<entry>22</entry>
<entry>remainder if infinity by UN</entry>
</row>
<row>
<entry>s 11111111 100000000000010111nouzx</entry>
<entry>23</entry>
<entry>remainder of infinity by OV</entry>
</row>
<row>
<entry>s 11111111 100000000000011000nouzx</entry>
<entry>24</entry>
<entry>remainder of OV</entry>
</row>
<row>
<entry>s 11111111 100000000000011001nouzx</entry>
<entry>25</entry>
<entry>remainder of OV by zero</entry>
</row>
<row>
<entry>s 11111111 100000000000011010nouzx</entry>
<entry>26</entry>
<entry>remainder of OV by UN</entry>
</row>
<row>
<entry>s 11111111 100000000000011011nouzx</entry>
<entry>27</entry>
<entry>remainder of OV by OV</entry>
</row>
<row>
<entry></entry>
<entry>28-31</entry>
<entry>no specific meaning</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0079" lvl="0"><number>&lsqb;0079&rsqb;</number> In Table 5, &ldquo;OV&rdquo; refers to an operand in the overflow format <highlight><bold>64</bold></highlight>, &ldquo;UN&rdquo; refers to an operand in the underflow format <highlight><bold>61</bold></highlight> and &ldquo;infinity&rdquo; refers to an operand in the infinity format <highlight><bold>65</bold></highlight>. Further, it will be assumed that the above listed formats represent thirty-two bit values. Those skilled in the art will readily appreciate that such formats are easily extended to, for example, sixty-four bit values or values represented in other numbers of bits. </paragraph>
<paragraph id="P-0080" lvl="0"><number>&lsqb;0080&rsqb;</number> It will also be appreciated that, by including the floating point status information relating to a floating point operation embedded within the result generated for the operation, the implicit serialization required by maintaining the floating point status information separate and apart therefrom can be advantageously obviated. </paragraph>
<paragraph id="P-0081" lvl="0"><number>&lsqb;0081&rsqb;</number> With this background, exemplary functional units <highlight><bold>41</bold></highlight>-<highlight><bold>47</bold></highlight> for use in connection with exemplary floating point operand data structure formats <highlight><bold>60</bold></highlight> through <highlight><bold>66</bold></highlight> will be described in detail in connection with <cross-reference target="DRAWINGS">FIGS. 5 through 11</cross-reference>. Before proceeding to those descriptions, it will be convenient to define certain terms. The term &plus;OV generally represents a value in the overflow pattern with the sign bit &ldquo;s&rdquo; having the value &ldquo;zero,&rdquo; indicating a positive value. The term &minus;OV generally represents a value in the in the overflow pattern with the sign bit &ldquo;s&rdquo; having the value &ldquo;one,&rdquo; indicating a negative value. The term &plus;UN generally represents a value in the underflow pattern with the sign bit &ldquo;s&rdquo; having the value &ldquo;zero,&rdquo; indicating a positive value. Finally, the term &minus;UN generally represents a value in the underflow pattern with the sign bit &ldquo;s&rdquo; having the value &ldquo;one,&rdquo; indicating a negative value. </paragraph>
<paragraph id="P-0082" lvl="0"><number>&lsqb;0082&rsqb;</number> Additionally, the following table defines certain other finite nonzero numbers, such as &plus;TINY, &minus;TINY, &plus;HUGE, and &minus;HUGE as follows:  
<table-cwu id="TABLE-US-00006">
<number>6</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="147PT" align="left"/>
<colspec colname="2" colwidth="49PT" align="left"/>
<thead>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center">TABLE 6</entry>
</row>
<row>
<entry></entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
<entry>0 00000000 00000000000000000000010</entry>
<entry>&plus;TINY</entry>
</row>
<row>
<entry></entry>
<entry>1 00000000 00000000000000000000010</entry>
<entry>&minus;TINY</entry>
</row>
<row>
<entry></entry>
<entry>0 11111110 11111111111111111111110</entry>
<entry>&plus;HUGE</entry>
</row>
<row>
<entry></entry>
<entry>1 11111110 11111111111111111111110</entry>
<entry>&minus;HUGE</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0083" lvl="0"><number>&lsqb;0083&rsqb;</number> The numbers &plus;TINY, &minus;TINY, &plus;HUGE, and &minus;HUGE are helpful in further defining &plus;OV, &minus;OV, &plus;UN, and &minus;UN. For example, &plus;OV can be deemed to refer to &ldquo;some (or any) value that is strictly between &plus;HUGE and &plus;&infin;&rdquo; and &plus;UN can be deemed to refer to &ldquo;some (or any) value that is strictly between &plus;0 and &plus;TINY.&rdquo; Similarly, &minus;OV can be deemed to refer to &ldquo;some (or any) value that is strictly between &minus;HUGE and &minus;&infin;&rdquo; and &minus;UN can be deemed to refer to &ldquo;some (or any) value that is strictly between &minus;0 and &minus;TINY.&rdquo; These names will be used in the following description to aid in the description of how the exemplary functional units <highlight><bold>41</bold></highlight>-<highlight><bold>47</bold></highlight> operate and process a floating point operand having status information embedded within it. </paragraph>
<paragraph id="P-0084" lvl="7"><number>&lsqb;0084&rsqb;</number> Adder Unit <highlight><bold>41</bold></highlight> </paragraph>
<paragraph id="P-0085" lvl="0"><number>&lsqb;0085&rsqb;</number> An illustrative circuit for use as adder unit <highlight><bold>41</bold></highlight> is described in U.S. patent applications Ser. No. ______, filed on even date herewith in the name of Guy L. Steele Jr., and entitled &ldquo;Floating Point Adder Circuit And Method&rdquo;, assigned to the assignee of the present application and hereby incorporated by reference. The exemplary adder unit <highlight><bold>41</bold></highlight> performs several types of operations, which may include but is not limited to addition of two operands, negation of one operand, subtraction of one operand from another operand, and absolute value of one operand. Generally, the negation operation is not affected by the rounding mode, and the result is always a copy of the operand with its sign reversed, even if the operand is in the NaN format <highlight><bold>66</bold></highlight>. In the subtraction operation, the adder unit <highlight><bold>41</bold></highlight> generates the result as the sum of the operand that is the minuend and the negative of the operand that is the subtrahend. Essentially, the negative of the operand that is the subtrahend being the result of the negation operation. Effectively, the adder unit <highlight><bold>41</bold></highlight> performs a subtraction operation by performing a negation operation on the operand that is the subtrahend and an addition operation in connection with the operand that is the minuend and the result of the negation operation. The absolute value operation is also not affected by the rounding mode, and the result is a copy of the operand with its sign made positive, even if the operand is a NaN. </paragraph>
<paragraph id="P-0086" lvl="0"><number>&lsqb;0086&rsqb;</number> Generally, results generated by the adder unit <highlight><bold>41</bold></highlight> in connection with an addition operation are described in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>. In the table depicted in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>, &ldquo;&plus;P&rdquo; or &ldquo;&plus;Q&rdquo; means any finite positive nonzero representable value other than &plus;UN and &plus;OV. The label &ldquo;&minus;P&rdquo; or &ldquo;&minus;Q&rdquo; means any finite negative nonzero representable value other than &minus;UN and &minus;OV. Additionally, &ldquo;NaN&rdquo; means any value whose exponent field is 11111111, other than one of the values represented by &plus;&infin; and &minus;&infin;. </paragraph>
<paragraph id="P-0087" lvl="0"><number>&lsqb;0087&rsqb;</number> Furthermore, the following is a key to symbols in the table depicted in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>: </paragraph>
<paragraph id="P-0088" lvl="2"><number>&lsqb;0088&rsqb;</number> (a) The result is &minus;&infin;, with the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result being the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction fields of the two operands. </paragraph>
<paragraph id="P-0089" lvl="2"><number>&lsqb;0089&rsqb;</number> (b) The result &minus;&infin;, with the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the result being the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction of the infinite operand with bit pattern 01001 (to indicate overflow and inexact conditions). </paragraph>
<paragraph id="P-0090" lvl="2"><number>&lsqb;0090&rsqb;</number> (c) The result is &minus;&infin;, with the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result equal to the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the infinite operand. If the other operand is &minus;UN or &plus;UN, it is intentional in the present embodiment that the low five bits of the &minus;&infin; operand not be OR-ed with 0010 to indicate underflow and inexact conditions. </paragraph>
<paragraph id="P-0091" lvl="2"><number>&lsqb;0091&rsqb;</number> (d) For &ldquo;round toward positive infinity,&rdquo; the result is &plus;&infin;; for &ldquo;round toward negative infinity,&rdquo; the result is &minus;&infin;. In either of these two cases, the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result are the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction fields of the two operands. For all other rounding modes, the result is the positive NaN value 0 11111111 1000000000000000101ouzx (to indicate &ldquo;infinity minus infinity&rdquo; with the invalid operation flag set). The four least significant bits f<highlight><subscript>lsb&plus;3 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result are the bitwise OR of the four least significant bits f<highlight><subscript>lsb&plus;3 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction fields of the two operands. </paragraph>
<paragraph id="P-0092" lvl="2"><number>&lsqb;0092&rsqb;</number> (e) The result is a copy of the NaN operand, except that the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result are the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction fields of the two operands. </paragraph>
<paragraph id="P-0093" lvl="2"><number>&lsqb;0093&rsqb;</number> (f) For &ldquo;round toward plus infinity,&rdquo; the result is the same as if &minus;OV were replaced by &minus;HUGE and &plus;UN were replaced by &plus;TINY, i.e., the result will be 1 1111110 11111111111111111111110). For all other rounding modes, the result is &minus;OV. </paragraph>
<paragraph id="P-0094" lvl="2"><number>&lsqb;0094&rsqb;</number> (g) For &ldquo;round toward plus infinity,&rdquo; the result is the same as if &minus;OV were replaced by &minus;HUGE. For all other rounding modes, the result is &minus;OV. </paragraph>
<paragraph id="P-0095" lvl="2"><number>&lsqb;0095&rsqb;</number> (h) For &ldquo;round toward plus infinity,&rdquo; the result is &plus;OV. For &ldquo;round toward minus infinity,&rdquo; the result is &minus;OV. For all other rounding modes, the result is the positive NaN value 0 11111111 10000000000000001111001, which indicates &ldquo;OV minus OV&rdquo; with the invalid operation &ldquo;n,&rdquo; overflow &ldquo;o,&rdquo; and inexact &ldquo;x&rdquo; flags set. </paragraph>
<paragraph id="P-0096" lvl="2"><number>&lsqb;0096&rsqb;</number> (i) The result is &plus;&infin;, with the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result being the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the infinite operand with 01001 (to indicate overflow and inexact conditions). </paragraph>
<paragraph id="P-0097" lvl="2"><number>&lsqb;0097&rsqb;</number> (j) The result is a copy of the NaN operand, except that the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result are the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the NaN operand with 01001 (to indicate overflow and inexact conditions). </paragraph>
<paragraph id="P-0098" lvl="2"><number>&lsqb;0098&rsqb;</number> (k) As computed in accordance with IEEE Std. 754, except that the result is &minus;OV if overflow occurs or if the rounding mode is &ldquo;round toward minus infinity&rdquo; and the mathematical sum is less than &minus;HUGE. </paragraph>
<paragraph id="P-0099" lvl="2"><number>&lsqb;0099&rsqb;</number> (l) For &ldquo;round toward plus infinity,&rdquo; the result is the same as if &minus;UN were replaced by &minus;0; for &ldquo;round toward minus infinity,&rdquo; the result is the same as if &minus;UN were replaced by &minus;TINY. For all other rounding modes, the result is as computed in accordance with IEEE Std. 754. </paragraph>
<paragraph id="P-0100" lvl="2"><number>&lsqb;0100&rsqb;</number> (m) For &ldquo;round toward plus infinity,&rdquo; the result is the same as if &plus;UN were replaced by &plus;TINY. For &ldquo;round toward minus infinity,&rdquo; the result is the same as if &plus;UN were replaced by &plus;0. For all other rounding modes, the result is as computed in accordance with IEEE Std. 754. </paragraph>
<paragraph id="P-0101" lvl="2"><number>&lsqb;0101&rsqb;</number> (n) As computed in accordance with IEEE Std. 754. If IEEE Std. 754 would compute the result as 1 00000000 00000000000000000000001, then an embodiment of the present invention would do the same. However, the embodiment of the present invention calls this &minus;UN and considers it to be underflow. If IEEE Std. 754 would compute the result as 0 00000000 00000000000000000000001, then an embodiment of the present invention would do the same. However, the embodiment of the present invention calls this &plus;UN and considers it to be underflow. </paragraph>
<paragraph id="P-0102" lvl="2"><number>&lsqb;0102&rsqb;</number> (o) For &ldquo;round toward minus infinity,&rdquo; the result is the same as if &plus;OV were replaced by &plus;HUGE. For all other rounding modes, the result is &plus;OV. </paragraph>
<paragraph id="P-0103" lvl="2"><number>&lsqb;0103&rsqb;</number> (p) The result is &plus;&infin; with the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result being equal to the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the infinite operand. If the other operand is &minus;UN or &plus;UN, it is intentional in this embodiment that the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the &plus;&infin; operand not be OR-ed with 00101 to indicate underflow and inexact conditions. </paragraph>
<paragraph id="P-0104" lvl="2"><number>&lsqb;0104&rsqb;</number> (q) The result is a copy of the NaN operand. </paragraph>
<paragraph id="P-0105" lvl="2"><number>&lsqb;0105&rsqb;</number> (r) For &ldquo;round toward minus infinity,&rdquo; the result is the same as if each &minus;UN were replaced by &minus;TINY (i.e., the result will be &minus;2*TINY). For all other rounding modes, the result is &minus;UN. </paragraph>
<paragraph id="P-0106" lvl="2"><number>&lsqb;0106&rsqb;</number> (s) For &ldquo;round toward minus infinity,&rdquo; the result is &minus;UN. For all other rounding modes, the result is &plus;UN. </paragraph>
<paragraph id="P-0107" lvl="2"><number>&lsqb;0107&rsqb;</number> (t) For &ldquo;round toward minus infinity,&rdquo; the result is the same as if &plus;OV were replaced by &plus;HUGE and &minus;UN were replaced by &minus;TINY, i.e., the result will be 0 11111110 11111111111111111111110. For all other rounding modes, the result is &plus;OV. </paragraph>
<paragraph id="P-0108" lvl="2"><number>&lsqb;0108&rsqb;</number> (u) The result is a copy of the NaN operand, except that the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result are the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field NaN operand with 00101 (to indicate underflow and inexact conditions). </paragraph>
<paragraph id="P-0109" lvl="2"><number>&lsqb;0109&rsqb;</number> (v) For &ldquo;round toward minus infinity,&rdquo; the result is &minus;0. For all other rounding modes, the result is &plus;0. This is as in accordance with IEEE Std. 754. </paragraph>
<paragraph id="P-0110" lvl="2"><number>&lsqb;0110&rsqb;</number> (w) For &ldquo;round toward plus infinity,&rdquo; the result is the same as if each &plus;UN were replaced by &plus;TINY, i.e., the result will be &plus;2*TINY. For all other rounding modes, the result is &plus;UN. </paragraph>
<paragraph id="P-0111" lvl="2"><number>&lsqb;0111&rsqb;</number> (x) As computed in accordance with IEEE Std. 754, except that if overflow occurs, or if the rounding mode is &ldquo;round toward plus infinity&rdquo; and the mathematical sum is greater than &plus;HUGE, the result is &plus;OV. </paragraph>
<paragraph id="P-0112" lvl="2"><number>&lsqb;0112&rsqb;</number> (y) The result is &plus;&infin;, with the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result being the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction fields of the operands. </paragraph>
<paragraph id="P-0113" lvl="2"><number>&lsqb;0113&rsqb;</number> (z) The result is a copy of the NaN operand that has the larger value in its fraction field, except that the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result are the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the operands. Additionally, the sign bit &ldquo;s&rdquo; of the result is &ldquo;one&rdquo; if and only if the sign bits of the two NaN operands are both &ldquo;ones.&rdquo;</paragraph>
<paragraph id="P-0114" lvl="0"><number>&lsqb;0114&rsqb;</number> It will be appreciated by one with skill in the art that, with exemplary adder unit <highlight><bold>41</bold></highlight> operating according to the table depicted in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>, addition is commutative, even those cases where one or both operands are NaN values. </paragraph>
<paragraph id="P-0115" lvl="7"><number>&lsqb;0115&rsqb;</number> Multiplier Unit <highlight><bold>42</bold></highlight> </paragraph>
<paragraph id="P-0116" lvl="0"><number>&lsqb;0116&rsqb;</number> An illustrative circuit for use as multiplier unit <highlight><bold>42</bold></highlight> is described in U.S. patent application Ser. No. ______, filed on even date herewith in the name of Guy L. Steele Jr., and entitled &ldquo;Floating Point Multiplier Circuit And Method,&rdquo; assigned to the assignee of the present application and hereby incorporated by reference. Generally, results generated by the exemplary multiplier <highlight><bold>42</bold></highlight> are described in the table depicted in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>. In the table of <cross-reference target="DRAWINGS">FIG. 6</cross-reference>, the term &ldquo;&plus;P&rdquo; or &ldquo;&plus;Q&rdquo; means any finite positive representable value greater than &ldquo;one,&rdquo; other than &plus;OV. The term &ldquo;&minus;P&rdquo; or &ldquo;&minus;Q&rdquo; means any finite negative representable value less than negative-one, other than &minus;OV. The term &ldquo;&plus;R&rdquo; or &ldquo;&plus;S&rdquo; means any positive non-zero value less than &ldquo;one,&rdquo; other than &plus;UN. The term &ldquo;&minus;R&rdquo; or &ldquo;&minus;S&rdquo; means any negative non-zero representable value greater than negative-one, other than &minus;UN. Finally, &ldquo;NaN&rdquo; means any value whose exponent field is 11111111, other than one of the values represented by &plus;&infin; and &minus;&infin;. </paragraph>
<paragraph id="P-0117" lvl="0"><number>&lsqb;0117&rsqb;</number> Furthermore, the following is a key to symbols in the table depicted in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>: </paragraph>
<paragraph id="P-0118" lvl="2"><number>&lsqb;0118&rsqb;</number> (a) The result is &plus;&infin;, with the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result being the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction fields of the two operands. </paragraph>
<paragraph id="P-0119" lvl="2"><number>&lsqb;0119&rsqb;</number> (b) The result is &plus;&infin;, with the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result being the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the infinite operand with 01001 (to indicate overflow and inexact conditions). </paragraph>
<paragraph id="P-0120" lvl="2"><number>&lsqb;0120&rsqb;</number> (c) The result is &plus;&infin;, with the five least significant bits f<highlight><subscript>lsb&plus;4</subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result being equal to the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the infinite operand. </paragraph>
<paragraph id="P-0121" lvl="2"><number>&lsqb;0121&rsqb;</number> (d) The result is &plus;&infin;, with five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result being the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the infinite operand with 00101 (to indicate underflow and inexact conditions). </paragraph>
<paragraph id="P-0122" lvl="2"><number>&lsqb;0122&rsqb;</number> (e) For &ldquo;round toward plus infinity,&rdquo; the result is &plus;&infin;, with the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result being equal to the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the infinite operand. For &ldquo;round toward minus infinity,&rdquo; the result is &plus;0. For all other rounding modes, the result is a positive NaN value 0 11111111 1000000000000001001ouzx (to indicate &ldquo;zero times infinity&rdquo; with the invalid operation flag set), where &ldquo;ouzx&rdquo; are the four least significant bits f<highlight><subscript>lsb&plus;3 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the infinite operand. </paragraph>
<paragraph id="P-0123" lvl="2"><number>&lsqb;0123&rsqb;</number> (f) For &ldquo;round toward plus infinity,&rdquo; the result is &minus;0. For &ldquo;round toward minus infinity,&rdquo; the result is &minus;&infin;, with five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field being equal to the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the infinite operand. For all other rounding modes, the result is a negative NaN value 1 11111111 1000000000000001001ouzx (to indicate &ldquo;zero times infinity&rdquo; with the invalid operation flag set), where &ldquo;ouzx&rdquo; are the four least significant bits f<highlight><subscript>lsb&plus;3 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the infinite operand. </paragraph>
<paragraph id="P-0124" lvl="2"><number>&lsqb;0124&rsqb;</number> (g) The result is &minus;&infin;, with five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result being the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the infinite operand with 00101 (to indicate underflow and inexact conditions). </paragraph>
<paragraph id="P-0125" lvl="2"><number>&lsqb;0125&rsqb;</number> (h) The result is &minus;&infin;, with the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result being equal to the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the infinite operand. </paragraph>
<paragraph id="P-0126" lvl="2"><number>&lsqb;0126&rsqb;</number> (i) The result is &minus;&infin;, with the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result being the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the infinite operand with 01001 (to indicate overflow and inexact conditions). </paragraph>
<paragraph id="P-0127" lvl="2"><number>&lsqb;0127&rsqb;</number> (j) The result is &minus;&infin;, with the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result being the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction fields of the operands. </paragraph>
<paragraph id="P-0128" lvl="2"><number>&lsqb;0128&rsqb;</number> (k) The result is a copy of the NaN operand, except that its sign is reversed if the other operand is negative, and the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result being the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction fields of the operands. </paragraph>
<paragraph id="P-0129" lvl="2"><number>&lsqb;0129&rsqb;</number> (l) For &ldquo;round toward minus infinity,&rdquo; the result is the same as if &minus;OV were replaced by &minus;HUGE. For all other rounding modes, the result is &plus;OV. </paragraph>
<paragraph id="P-0130" lvl="2"><number>&lsqb;0130&rsqb;</number> (m) For &ldquo;round toward plus infinity,&rdquo; the result is &plus;OV. For &ldquo;round toward minus infinity,&rdquo; the result is &plus;UN; for all other rounding modes, the result is the positive NaN value 0 11111111 1000000000000010111101 (to indicate &ldquo;UN times OV&rdquo; with the invalid operation, overflow, underflow, and inexact flags set). </paragraph>
<paragraph id="P-0131" lvl="2"><number>&lsqb;0131&rsqb;</number> (n) For &ldquo;round toward plus infinity,&rdquo; the result is &minus;UN. For &ldquo;round toward minus infinity,&rdquo; the result is &minus;OV. For all other rounding modes, the result is the negative NaN value 1 11111111 10000000000000010111101 (to indicate &ldquo;UN times OV&rdquo; with the invalid operations, overflow, underflow, and inexact flags set). </paragraph>
<paragraph id="P-0132" lvl="2"><number>&lsqb;0132&rsqb;</number> (o) For &ldquo;round toward plus infinity,&rdquo; the result is the same as if &minus;OV were replaced by &minus;HUGE . For all other rounding modes, the result is &minus;OV. </paragraph>
<paragraph id="P-0133" lvl="2"><number>&lsqb;0133&rsqb;</number> (p) The result is a copy of the NaN operand, except that its sign is reversed if the other operand is negative and the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result are OR-ed with 01001 (to indicate overflow and inexact conditions). </paragraph>
<paragraph id="P-0134" lvl="2"><number>&lsqb;0134&rsqb;</number> (q) As computed in accordance with IEEE Std. 754, except that if overflow occurs or if the rounding mode is &ldquo;round toward plus infinity&rdquo; and the mathematical product is greater than &plus;HUGE, the result is &plus;OV. If underflow occurs and a computation in accordance with IEEE Std. 754 would result in the value &plus;0 or if the rounding mode is &ldquo;round toward minus infinity&rdquo; and the mathematical product is less than &plus;TINY, the result is &plus;UN. </paragraph>
<paragraph id="P-0135" lvl="2"><number>&lsqb;0135&rsqb;</number> (r) For &ldquo;round toward plus infinity,&rdquo; the result is the same as if &minus;UN were replaced by &minus;TINY. For all other rounding modes, the result is as computed in accordance with IEEE Std. 754. </paragraph>
<paragraph id="P-0136" lvl="2"><number>&lsqb;0136&rsqb;</number> (s) For &ldquo;round toward minus infinity,&rdquo; the result is the same as if &plus;UN were replaced by &plus;TINY. For all other rounding modes, the result is as computed in accordance with IEEE Std. 754. </paragraph>
<paragraph id="P-0137" lvl="2"><number>&lsqb;0137&rsqb;</number> (t) As computed in accordance with IEEE Std. 754, except that if overflow occurs or if the rounding mode is &ldquo;round toward minus infinity&rdquo; and the mathematical product is less than &minus;HUGE, the result is &minus;OV. Additionally, if underflow occurs and a computation in accordance with IEEE Std. 754 would provide the result &minus;0 or if the rounding mode is &ldquo;round toward plus infinity&rdquo; and the mathematical product is greater than &minus;TINY, the result is &minus;UN. </paragraph>
<paragraph id="P-0138" lvl="2"><number>&lsqb;0138&rsqb;</number> (u) The result is a copy of the NaN operand, except that its sign is reversed if the other operand is negative. </paragraph>
<paragraph id="P-0139" lvl="2"><number>&lsqb;0139&rsqb;</number> (v) For &ldquo;round toward plus infinity,&rdquo; the result is the same as if &plus;OV were replaced by &plus;HUGE. For all other rounding modes, the result is &minus;OV. </paragraph>
<paragraph id="P-0140" lvl="2"><number>&lsqb;0140&rsqb;</number> (w) For &ldquo;round toward minus infinity,&rdquo; the result is the same as if &minus;UN were replaced by &minus;TINY. For all other rounding modes, the result is as computed in accordance with IEEE Std. 754. </paragraph>
<paragraph id="P-0141" lvl="2"><number>&lsqb;0141&rsqb;</number> (x) The result is a copy of the NaN operand, except that its sign is reversed if the other operand is negative, and the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result are OR-ed with 00101 (to indicate underflow and inexact conditions). </paragraph>
<paragraph id="P-0142" lvl="2"><number>&lsqb;0142&rsqb;</number> (y) For &ldquo;round toward plus infinity,&rdquo; the result is the same as if &plus;UN were replaced by &plus;TINY. For all other rounding modes, the result is as computed in accordance with IEEE Std. 754. </paragraph>
<paragraph id="P-0143" lvl="2"><number>&lsqb;0143&rsqb;</number> (z) For &ldquo;round toward minus infinity,&rdquo; the result is the same as if &plus;OV were replaced by &plus;HUGE. For all other rounding modes, the result is &plus;OV. </paragraph>
<paragraph id="P-0144" lvl="3"><number>&lsqb;0144&rsqb;</number> (&commat;) The result is a copy of the NaN operand that has the larger value in the fraction field, except that the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result are the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the operands. Additionally, the sign bit of the result is 1, indicating a negative result, if and only if the sign bits of the two NaN operands differ. </paragraph>
<paragraph id="P-0145" lvl="0"><number>&lsqb;0145&rsqb;</number> It will be appreciated by one skilled in the art that, with the exemplary multiplier unit <highlight><bold>42</bold></highlight> operating according to the table depicted in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>, multiplication is commutative, even those cases where one or both operands are NaN values. </paragraph>
<paragraph id="P-0146" lvl="7"><number>&lsqb;0146&rsqb;</number> Divider Unit <highlight><bold>43</bold></highlight> </paragraph>
<paragraph id="P-0147" lvl="0"><number>&lsqb;0147&rsqb;</number> As noted above, the exemplary divider unit <highlight><bold>43</bold></highlight> can perform two types of operations. A division operation is one in which the result Q&equals;x/y, where &ldquo;x&rdquo; and &ldquo;y&rdquo; are operands. A remainder operation is one in which the result REM (x,y)&equals;x&minus;(y/n), where &ldquo;n&rdquo; is the integer nearest to the value x/y. An illustrative floating point divider circuit for use in performing division operations is described in U.S. patent application Ser. No. ______, filed on an even date herewith in the name of Guy L. Steele Jr., and entitled &ldquo;Floating Point Divider Circuit And Method,&rdquo; assigned to the assignee of the present application and hereby incorporated by reference. An illustrative floating point remainder circuit for use in performing remainder operations is described in U.S. patent application Ser. No. ______, filed on even date herewith in the name of Guy L. Steele Jr., and entitled &ldquo;Floating Point Remainder Circuit And Method,&rdquo; assigned to the assignee of the present application and hereby incorporated by reference. </paragraph>
<paragraph id="P-0148" lvl="0"><number>&lsqb;0148&rsqb;</number> Generally, results generated by the exemplary divider <highlight><bold>43</bold></highlight> in connection with division operations are described in the table depicted in <cross-reference target="DRAWINGS">FIG. 7</cross-reference> and results generated by the exemplary divider <highlight><bold>43</bold></highlight> in connection with remainder operations are described in the table depicted in <cross-reference target="DRAWINGS">FIG. 8</cross-reference>. In one or both of those tables, the term &ldquo;&plus;P&rdquo; or &ldquo;&plus;Q&rdquo; means any finite positive representable value greater than &ldquo;one,&rdquo; other than &plus;OV. The term &ldquo;&minus;P&rdquo; or &ldquo;&minus;Q&rdquo; means any finite negative representable value less than negative-one, other than &minus;OV. The term &ldquo;&plus;R&rdquo; or &ldquo;&plus;S&rdquo; means any positive non-zero value less than &ldquo;one,&rdquo; other than &plus;UN. The term &ldquo;&minus;R&rdquo; or &ldquo;&minus;S&rdquo; means any negative non-zero representable value greater than negative-one, other than &minus;UN. Finally, the term &ldquo;NaN&rdquo; means any value whose exponent field is 11111111, other than one of the values represented by &plus;&infin; and &minus;&infin;. </paragraph>
<paragraph id="P-0149" lvl="0"><number>&lsqb;0149&rsqb;</number> Furthermore, the following is a key to symbols in the table depicted in <cross-reference target="DRAWINGS">FIG. 7</cross-reference> (division operations): </paragraph>
<paragraph id="P-0150" lvl="2"><number>&lsqb;0150&rsqb;</number> (a) For &ldquo;round toward plus infinity,&rdquo; the result is &plus;&infin; with the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field being equal to the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction fields of the two operands. For &ldquo;round toward minus infinity,&rdquo; the result is &plus;0. For all other rounding modes, the result is a positive NaN value 0 11111111 1000000000000001001ouzx (to indicate &ldquo;infinity divided by infinity&rdquo; with the invalid operation flag set), where ouzx is the bitwise OR of the four least significant bits f<highlight><subscript>lsb&plus;3 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction fields of the operands. </paragraph>
<paragraph id="P-0151" lvl="2"><number>&lsqb;0151&rsqb;</number> (b) The result is &plus;&infin;, with the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result being equal to the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the infinite operand with 01001 (to indicate overflow and inexact conditions). </paragraph>
<paragraph id="P-0152" lvl="2"><number>&lsqb;0152&rsqb;</number> (c) The result is &plus;&infin;, with the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result being equal to the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the infinite operand. </paragraph>
<paragraph id="P-0153" lvl="2"><number>&lsqb;0153&rsqb;</number> (d) The result is &plus;&infin;, with the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result being the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the infinite operand with 00101 (to indicate underflow and inexact conditions). </paragraph>
<paragraph id="P-0154" lvl="2"><number>&lsqb;0154&rsqb;</number> (e) The result is &minus;&infin;, with the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result being equal to the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of tine infinite operand. </paragraph>
<paragraph id="P-0155" lvl="2"><number>&lsqb;0155&rsqb;</number> (f) The result is &minus;&infin;, with the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result being the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the infinite operand with 00101 (to indicate underflow and inexact conditions). </paragraph>
<paragraph id="P-0156" lvl="2"><number>&lsqb;0156&rsqb;</number> (g) The result is &minus;&infin;, with five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result being the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the infinite operand with 01001 (to indicate overflow and inexact conditions). </paragraph>
<paragraph id="P-0157" lvl="2"><number>&lsqb;0157&rsqb;</number> (h) For &ldquo;round toward plus infinity,&rdquo; the result is &minus;0. For &ldquo;round toward minus infinity,&rdquo; the result is &minus;&infin; with the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field being equal to the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction fields of the two operands. For all other rounding modes, the result is a negative NaN value 1 11111111 1000000000000001001ouzx (to indicate &ldquo;infinity divided by infinity&rdquo; with the invalid operation flag set), where &ldquo;ouzx&rdquo; is the bitwise OR of the four least significant bits f<highlight><subscript>lsb&plus;3 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction fields of the two operands. </paragraph>
<paragraph id="P-0158" lvl="2"><number>&lsqb;0158&rsqb;</number> (i) The result is a copy of the NaN operand, except that its sign is reversed if the other operand is negative, and the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result are the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction fields of the operands. </paragraph>
<paragraph id="P-0159" lvl="2"><number>&lsqb;0159&rsqb;</number> (j) For &ldquo;round toward plus infinity,&rdquo; the result is &plus;OV. For &ldquo;round toward minus infinity,&rdquo; the result is &plus;UN. For all other rounding modes, the result is the positive NaN value 0 11111111 10000000000000101111001 to indicate &ldquo;OV divided by OV&rdquo; with the invalid operation, overflow, and inexact flags set. </paragraph>
<paragraph id="P-0160" lvl="2"><number>&lsqb;0160&rsqb;</number> (k) For &ldquo;round toward minus infinity,&rdquo; the result is the same as if &minus;OV were replaced by &minus;HUGE. For all other rounding modes, the result is &plus;OV. </paragraph>
<paragraph id="P-0161" lvl="2"><number>&lsqb;0161&rsqb;</number> (l) The result is the &plus;&infin; value 0 11111111 00000000000000000001011 to indicate overflow, division by zero, and inexact. </paragraph>
<paragraph id="P-0162" lvl="2"><number>&lsqb;0162&rsqb;</number> (m) The result is the &minus;&infin; value 1 1111111 000000000000000000001011 to indicate overflow, division by zero, and inexact. </paragraph>
<paragraph id="P-0163" lvl="2"><number>&lsqb;0163&rsqb;</number> (n) For &ldquo;round toward plus infinity,&rdquo; the result is the same as if &minus;OV were replaced by &minus;HUGE. For all other rounding modes, the result is &minus;OV. </paragraph>
<paragraph id="P-0164" lvl="2"><number>&lsqb;0164&rsqb;</number> (o) For &ldquo;round toward plus infinity,&rdquo; the result is &minus;UN; for &ldquo;round toward minus infinity,&rdquo; the result is &minus;OV. For all other rounding modes, the result is the negative NaN value 1 11111111 10000000000000101111001 to indicate &ldquo;OV divided by OV&rdquo; with the invalid operation, overflow, and inexact flags set. </paragraph>
<paragraph id="P-0165" lvl="2"><number>&lsqb;0165&rsqb;</number> (p) The result is a copy of the NaN operand, except that its sign is reversed if the other operand is negative, and the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the results are OR-ed with 01001 (to indicate overflow and inexact conditions). </paragraph>
<paragraph id="P-0166" lvl="2"><number>&lsqb;0166&rsqb;</number> (q) For &ldquo;round toward plus infinity,&rdquo; the result is the same as if &minus;OV were replaced by &minus;HUGE, except that if underflow occurs and a computation in accordance with IEEE Std. 754 would have the result &plus;0, the result is &plus;UN. For all other rounding modes, the result is &plus;UN. </paragraph>
<paragraph id="P-0167" lvl="2"><number>&lsqb;0167&rsqb;</number> (r) As computed in accordance with IEEE Std. 754, except that if overflow occurs or if the rounding mode is &ldquo;round toward plus infinity&rdquo; and the mathematical quotient is greater than &plus;HUGE, the result is &plus;OV. If underflow occurs and a computation in accordance with IEEE Std. 754 would provide the result &plus;0, or if the rounding mode is &ldquo;round toward minus infinity&rdquo; and the mathematical quotient is less than &plus;TINY, the result is &plus;UN. </paragraph>
<paragraph id="P-0168" lvl="2"><number>&lsqb;0168&rsqb;</number> (s) The result is the &plus;&infin; value 0 11111111 00000000000000000000010 to indicate division by zero. </paragraph>
<paragraph id="P-0169" lvl="2"><number>&lsqb;0169&rsqb;</number> (t) The result is the &minus;&infin; value 1 11111111 00000000000000000000010 to indicate division by zero. </paragraph>
<paragraph id="P-0170" lvl="2"><number>&lsqb;0170&rsqb;</number> (u) As computed in accordance with IEEE Std. 754, except that if overflow occurs, or if the rounding mode is &ldquo;round toward minus infinity&rdquo; and the mathematical quotient is less than &minus;HUGE, the result is &minus;OV. If underflow occurs and a computation in accordance with IEEE Std. 754 would provide the result &minus;0, or if the rounding mode is &ldquo;round toward plus infinity&rdquo; and the mathematical quotient is greater then &minus;TINY, the result is &minus;UN. </paragraph>
<paragraph id="P-0171" lvl="2"><number>&lsqb;0171&rsqb;</number> (v) For &ldquo;round toward minus infinity,&rdquo; the result is the same as if &plus;OV were replaced by &plus;HUGE, except that if underflow occurs and a computation in accordance with IEEE Std. 754 would have result &minus;0, the result is &minus;UN. For all other rounding modes, the result is &mdash;UN. </paragraph>
<paragraph id="P-0172" lvl="2"><number>&lsqb;0172&rsqb;</number> (w) The result is a copy of the NaN operand, except that its sign is reversed if the other operand is negative. </paragraph>
<paragraph id="P-0173" lvl="2"><number>&lsqb;0173&rsqb;</number> (x) For &ldquo;round toward minus infinity,&rdquo; the result is the same as if &minus;UN were replaced by &minus;TINY, except that if overflow occurs, the result is &plus;OV. For all other rounding modes, the result is &plus;OV. </paragraph>
<paragraph id="P-0174" lvl="2"><number>&lsqb;0174&rsqb;</number> (y) For &ldquo;round toward plus infinity,&rdquo; the result is the same as if &plus;UN were replaced by &plus;TINY, except that if overflow occurs, the result is &minus;OV. For all other rounding modes, the result is &minus;OV. </paragraph>
<paragraph id="P-0175" lvl="2"><number>&lsqb;0175&rsqb;</number> (z) For &ldquo;round toward plus infinity,&rdquo; the result is the same as if &minus;UN were replaced by &minus;TINY. For all other rounding modes, the result is &plus;UN. </paragraph>
<paragraph id="P-0176" lvl="2"><number>&lsqb;0176&rsqb;</number> (1) For &ldquo;round toward plus infinity,&rdquo; the result is &plus;OV; for &ldquo;round toward minus infinity,&rdquo; the result is &plus;UN. For all other rounding modes, the result is the positive NaN value 0 11111111 10000000000000101010101 to indicate &ldquo;UN divided by UN&rdquo; with the invalid operation, underflow, and inexact flags set. </paragraph>
<paragraph id="P-0177" lvl="2"><number>&lsqb;0177&rsqb;</number> (2) The result is the &plus;&infin; value 0 11111111 00000000000000000000111 to indicate underflow, division by zero, and inexact conditions. </paragraph>
<paragraph id="P-0178" lvl="2"><number>&lsqb;0178&rsqb;</number> (3) The result is the value 1 11111111 00000000000000000000111 to indicate underflow, division by zero, and inexact conditions. </paragraph>
<paragraph id="P-0179" lvl="2"><number>&lsqb;0179&rsqb;</number> (4) For &ldquo;rounding toward plus infinity,&rdquo; the result is &minus;UN; for &ldquo;round toward minus infinity,&rdquo; the result is &minus;OV. For all other rounding modes, the result is the negative NaN value 1 11111111 10000000000000101010101 to indicate &ldquo;UN divided by UN&rdquo; with the invalid operation, underflow, and inexact flags set. </paragraph>
<paragraph id="P-0180" lvl="2"><number>&lsqb;0180&rsqb;</number> (5) For &ldquo;round toward minus infinity,&rdquo; the result is the same as if &minus;UN were replaced by &minus;TINY. For all other rounding modes, the result is &minus;UN. </paragraph>
<paragraph id="P-0181" lvl="2"><number>&lsqb;0181&rsqb;</number> (6) The result is a copy of the NaN operand, except that its sign is reversed if the other operand is negative, and the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result are OR-ed with 00101 to indicate underflow and inexact conditions. </paragraph>
<paragraph id="P-0182" lvl="2"><number>&lsqb;0182&rsqb;</number> (7) For &ldquo;round toward plus infinity,&rdquo; the result is &plus;&infin; with the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field all having the value zero; for &ldquo;round toward minus infinity,&rdquo; the result is &plus;0. For all other rounding modes, the result is the positive NaN value 0 11111111 10000000000000100010000 to indicate &ldquo;zero divided by zero&rdquo; with the invalid operation flag set. </paragraph>
<paragraph id="P-0183" lvl="2"><number>&lsqb;0183&rsqb;</number> (8) For &ldquo;round toward plus infinity,&rdquo; the result is &minus;0. For &ldquo;round toward minus infinity,&rdquo; the result is &minus;&infin; with five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field all having the value zero. For all other rounding modes, the result is the negative NaN value 1 11111111 1000000000000100010000 to indicate &ldquo;zero divided by zero&rdquo; with the invalid operation flag set. </paragraph>
<paragraph id="P-0184" lvl="2"><number>&lsqb;0184&rsqb;</number> (9) For &ldquo;round toward minus infinity,&rdquo; the result is the same as if &plus;UN were replaced by &plus;TINY. For all other rounding modes, the result is &minus;UN. </paragraph>
<paragraph id="P-0185" lvl="2"><number>&lsqb;0185&rsqb;</number> (&commat;) For &ldquo;round toward plus infinity,&rdquo; the result is the same as if &plus;UN were replaced by &plus;TINY. For all other rounding modes, the result is &plus;UN. </paragraph>
<paragraph id="P-0186" lvl="2"><number>&lsqb;0186&rsqb;</number> (&num;) For &ldquo;round toward minus infinity,&rdquo; the result is the same as if &minus;OV were replaced by &minus;HUGE, except that if underflow occurs and a computation in accordance with IEEE Std. 754 would have the result value &minus;0, the result is &minus;UN. For all other rounding modes, the result is &minus;UN. </paragraph>
<paragraph id="P-0187" lvl="2"><number>&lsqb;0187&rsqb;</number> ($) For &ldquo;round toward plus infinity,&rdquo; the result is the same as if &minus;UN were replaced by &minus;TINY, except that if overflow occurs, the result is &minus;OV. For all other rounding modes, the result is &minus;OV. </paragraph>
<paragraph id="P-0188" lvl="2"><number>&lsqb;0188&rsqb;</number> (%) For &ldquo;round toward minus infinity,&rdquo; the result is the same as if &plus;UN were replaced by &plus;TINY, except that if overflow occurs, the result is &plus;OV. For all other rounding modes, the result is &plus;OV. </paragraph>
<paragraph id="P-0189" lvl="2"><number>&lsqb;0189&rsqb;</number> (&circ; ) For &ldquo;round toward plus infinity,&rdquo; the result is the same as if &plus;OV were replaced by &plus;HUGE, except that if underflow occurs and a computation in accordance with IEEE Std. 754 would have the result &plus;0, the result is &plus;UN. For all other rounding modes, the result is &plus;UN. </paragraph>
<paragraph id="P-0190" lvl="2"><number>&lsqb;0190&rsqb;</number> (&amp;) For &ldquo;round toward plus infinity,&rdquo; the result is the same as if &plus;OV were replaced by &plus;HUGE. For all other rounding modes, the result is &minus;OV. </paragraph>
<paragraph id="P-0191" lvl="2"><number>&lsqb;0191&rsqb;</number> (*) For &ldquo;round toward minus infinity,&rdquo; the result is the same as if &plus;OV were replaced by &plus;HUGE; for all other rounding modes, the result is &plus;OV. </paragraph>
<paragraph id="P-0192" lvl="2"><number>&lsqb;0192&rsqb;</number> (&tilde;) The result is a copy of the NaN operand that has the larger value in its fraction field, except that the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result are the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction fields of the operands. Additionally, the sign bit of the result is 1 if and only if the sign bits of the two NaN operands differ. </paragraph>
<paragraph id="P-0193" lvl="0"><number>&lsqb;0193&rsqb;</number> Preliminarily, remainder operations are not affected by the rounding mode. The following is a key to symbols in the table depicted in <cross-reference target="DRAWINGS">FIG. 8</cross-reference> (remainder operations) as follows: </paragraph>
<paragraph id="P-0194" lvl="2"><number>&lsqb;0194&rsqb;</number> (a) The result is a NaN value s 11111111 1000000000000101001ouzx (to indicate &ldquo;remainder of infinity&rdquo; with the invalid operation flag set), where &ldquo;ouzx&rdquo; is the bitwise OR of the four least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction fields of the operand. The sign of the result is the same as the sign of the first operand. </paragraph>
<paragraph id="P-0195" lvl="2"><number>&lsqb;0195&rsqb;</number> (b) The result is a NaN value s 11111111 100000000000010111nouzx (to indicate &ldquo;remainder of infinity by OV&rdquo;), where &ldquo;nouzx&rdquo; is the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the infinite operand with 11001 (to indicate invalid operation, overflow, and inexact conditions). The sign of the result is the same as the sign of the first operand. </paragraph>
<paragraph id="P-0196" lvl="2"><number>&lsqb;0196&rsqb;</number> (c) The result is a NaN value s 11111111 1000000000000101001ouzx (to indicate &ldquo;remainder of infinity&rdquo; with the invalid operation flag set), where &ldquo;ouzx&rdquo; is the low four bits of the infinite operand. The sign of the result is the same as the sign of the first operand. </paragraph>
<paragraph id="P-0197" lvl="2"><number>&lsqb;0197&rsqb;</number> (d) The result is a NaN value s 11111111 1000000000000010110nouzx (to indicate &ldquo;remainder of infinity by UN&rdquo;), where &ldquo;nouzx&rdquo; is the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the infinite operand with 10101 (to indicate invalid operation, underflow, and inexact conditions). The sign of the result is the same as the sign of the first operand. </paragraph>
<paragraph id="P-0198" lvl="2"><number>&lsqb;0198&rsqb;</number> (e) The result is a NaN value s 11111111 1000000000000101011ouzx (to indicate &ldquo;remainder of infinity by zero&rdquo; with the invalid operation flag set), where &ldquo;ouzx&rdquo; is the four least significant bits f<highlight><subscript>lsb&plus;3 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the infinite operand. The sign of the result is the same as the sign of the first operand. </paragraph>
<paragraph id="P-0199" lvl="2"><number>&lsqb;0199&rsqb;</number> (f) The result is a copy of the NaN operand, except that the sign of the result is the same as the sign of the first operand, and the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result are the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction fields of the two operands. </paragraph>
<paragraph id="P-0200" lvl="2"><number>&lsqb;0200&rsqb;</number> (g) The result is a copy of the first operand (either &minus;OV or &plus;OV). One might expect the result to be a NaN value s 11111111 100000000000011000nouzx (to indicate &ldquo;remainder of OV&rdquo;), where &ldquo;nouzx&rdquo; is the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the infinite operand with 11001 (to indicate invalid operation, overflow, and inexact), and where the sign of the result is the same as the sign of the first operand. However, the actual result is preferably a copy of the first operand, in order to preserve an important numerical identity, which is that REM(x, &plus;Inf)&equals;REM(x, &minus;Inf)&equals;x. </paragraph>
<paragraph id="P-0201" lvl="2"><number>&lsqb;0201&rsqb;</number> (h) The result is a NaN value s 11111111 10000000000001101111001 (to indicate &ldquo;remainder of OV by OV&rdquo; with the invalid operation, overflow, and inexact flags set). The sign of the result is the same as the sign of the first operand. </paragraph>
<paragraph id="P-0202" lvl="2"><number>&lsqb;0202&rsqb;</number> (i) The result is a NaN value s 11111111 10000000000001100011001 (to indicate &ldquo;remainder of OV&rdquo; with the invalid operation, overflow, and inexact flags set). The sign of the result is the same as the sign of the first operand. </paragraph>
<paragraph id="P-0203" lvl="2"><number>&lsqb;0203&rsqb;</number> (j) The result is a NaN value s 11111111 10000000000001101011101 (to indicate &ldquo;remainder of OV by UN&rdquo; with the invalid operation, overflow, underflow, and inexact flags set). The sign of the result is the same as the sign of the first operand. </paragraph>
<paragraph id="P-0204" lvl="2"><number>&lsqb;0204&rsqb;</number> (k) The result is a NaN value s 11111111 10000000000001100111001 (to indicate &ldquo;remainder of OV by zero&rdquo; with the invalid operation, overflow, and inexact flags set). The sign of the result is the same as the sign of the first operand. </paragraph>
<paragraph id="P-0205" lvl="2"><number>&lsqb;0205&rsqb;</number> (l) The result is a copy of the NaN operand, except that the sign of the result is the same as the sign of the first operand, and the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result are OR-ed with 01001 (to indicate overflow and inexact conditions). </paragraph>
<paragraph id="P-0206" lvl="2"><number>&lsqb;0206&rsqb;</number> (m) The result is a NaN value s 11111111 10000000000001001111001 (to indicate &ldquo;remainder by OV&rdquo; with the invalid operation, overflow, and inexact flags set). The sign of the result is the same as the sign of the first operand. </paragraph>
<paragraph id="P-0207" lvl="2"><number>&lsqb;0207&rsqb;</number> (n) The result is calculated in accordance with IEEE Std. 754. In this case, the sign of the result is not necessarily the same as the sign of the first operand. </paragraph>
<paragraph id="P-0208" lvl="2"><number>&lsqb;0208&rsqb;</number> (o) The result is a NaN value s 11111111 10000000000001001010101 (to indicate &ldquo;remainder by UN&rdquo; with the invalid operation, underflow, and inexact flags set). The sign of the result is the same as the sign of the first operand. </paragraph>
<paragraph id="P-0209" lvl="2"><number>&lsqb;0209&rsqb;</number> (p) The result is a NaN value s 11111111 10000000000001000110000 (to indicate &ldquo;remainder by zero&rdquo; with the invalid operation flag set). The sign of the result is the same as the sign of the first operand. </paragraph>
<paragraph id="P-0210" lvl="2"><number>&lsqb;0210&rsqb;</number> (q) The result is a copy of the NaN operand, except that the sign of the result is the same as the sign of the first operand. </paragraph>
<paragraph id="P-0211" lvl="2"><number>&lsqb;0211&rsqb;</number> (r) The result is a NaN value s 11111111 10000000000001001111011 (to indicate &ldquo;remainder by OV&rdquo; with the invalid operation, overflow, underflow, and inexact flags set). The sign of the result is the same as the sign of the first operand. </paragraph>
<paragraph id="P-0212" lvl="2"><number>&lsqb;0212&rsqb;</number> (s) The result is a NaN value s 11111111 10000000000001000110101 (to indicate &ldquo;remainder by zero&rdquo; with the invalid operation, underflow, and inexact flags set). The sign of the result is the same as the sign of the first operand. </paragraph>
<paragraph id="P-0213" lvl="2"><number>&lsqb;0213&rsqb;</number> (t) The result is a copy of the NaN operand, except that the sign of the result is the same as the sign of the first operand, and the low five bits of the result are OR-ed with 00101 (to indicate underflow and inexact conditions). </paragraph>
<paragraph id="P-0214" lvl="2"><number>&lsqb;0214&rsqb;</number> (u) The result is a copy of the NaN operand, except that the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result are the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction fields of the operands. </paragraph>
<paragraph id="P-0215" lvl="2"><number>&lsqb;0215&rsqb;</number> (v) The result is a copy of the NaN operand, except that the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result are OR-ed with 01001 (to indicate overflow and inexact conditions). </paragraph>
<paragraph id="P-0216" lvl="2"><number>&lsqb;0216&rsqb;</number> (w) The result is a copy of the NaN operand. </paragraph>
<paragraph id="P-0217" lvl="2"><number>&lsqb;0217&rsqb;</number> (x) The result is a copy of the NaN operand, except that the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result are OR-ed with 00101 (to indicate underflow and inexact conditions). </paragraph>
<paragraph id="P-0218" lvl="2"><number>&lsqb;0218&rsqb;</number> (y) The result is a copy of the NAN operand whose fraction field represents the larger value, except that the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result are the bitwise OR of the low five bits of each operand and the sign of the result is the same as the sign of the first operand. </paragraph>
<paragraph id="P-0219" lvl="7"><number>&lsqb;0219&rsqb;</number> Square Root Unit <highlight><bold>44</bold></highlight> </paragraph>
<paragraph id="P-0220" lvl="0"><number>&lsqb;0220&rsqb;</number> An illustrative circuit for use as exemplary square root unit <highlight><bold>44</bold></highlight> is described in U.S. patent application Ser. No. ______, filed on even date herewith in the name of Guy L. Steele Jr., and entitled &ldquo;Floating Point Square Root Circuit And Method,&rdquo; assigned to the assignee of the present application and hereby incorporated by reference. Results generated by the exemplary square root unit are described in the table depicted in <cross-reference target="DRAWINGS">FIG. 9</cross-reference>. In the table of <cross-reference target="DRAWINGS">FIG. 9</cross-reference>, the term &ldquo;&plus;P&rdquo; means any finite positive nonzero representable value other than &plus;UN and &plus;OV. The term &ldquo;&minus;P&rdquo; means any finite negative nonzero representable value other than &minus;UN and &minus;OV. Finally, the term &ldquo;NaN&rdquo; means any value whose exponent field is 11111111, other than one of the values represented by &plus;&infin; AND &minus;&infin;. </paragraph>
<paragraph id="P-0221" lvl="7"><number>&lsqb;0221&rsqb;</number> Maximum/Minimum Unit <highlight><bold>45</bold></highlight> </paragraph>
<paragraph id="P-0222" lvl="0"><number>&lsqb;0222&rsqb;</number> An illustrative circuit for use as exemplary maximum/minimum unit <highlight><bold>45</bold></highlight> is described in U.S. patent application Ser. No. ______, filed on even date herewith in the name of Guy L. Steele Jr., and entitled &ldquo;Floating Point Maximum/Minimum Circuit And Method,&rdquo; assigned to the assignee of the present application and hereby incorporated by reference. Generally, results generated by the exemplary maximum/minimum unit <highlight><bold>45</bold></highlight> in connection with a maximum operation, in which the unit <highlight><bold>45</bold></highlight> determines the maximum of two operands, are described in the table depicted in <cross-reference target="DRAWINGS">FIG. 10</cross-reference>. Results generated in connection with a minimum operation, in which the unit <highlight><bold>45</bold></highlight> determines the minimum of two operands, are described in the table depicted in FIG. <highlight><bold>11</bold></highlight>. In those tables, &ldquo;&plus;P&rdquo; or &ldquo;&plus;Q&rdquo; means any finite positive nonzero representable value other than &plus;UN and &plus;OV. Additionally, &ldquo;&minus;P&rdquo; or &ldquo;&minus;Q&rdquo; means any finite negative nonzero representable value other than &minus;UN and &minus;OV. Further, &ldquo;NaN&rdquo; means any value whose exponent field is 1111111, other than one of the values represented by &plus;&infin; and &minus;&infin;. </paragraph>
<paragraph id="P-0223" lvl="0"><number>&lsqb;0223&rsqb;</number> In an embodiment of the present invention, neither the maximum operation nor the minimum operation is affected by the rounding mode. In addition, both the maximum operation and the minimum operation are commutative, even when one or both operands are NaN value. </paragraph>
<paragraph id="P-0224" lvl="0"><number>&lsqb;0224&rsqb;</number> The following is a key to symbols in the table depicted in <cross-reference target="DRAWINGS">FIG. 10</cross-reference> (the maximum operation): </paragraph>
<paragraph id="P-0225" lvl="2"><number>&lsqb;0225&rsqb;</number> (a) The result is &minus;&infin; with the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result being the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the two operands. </paragraph>
<paragraph id="P-0226" lvl="2"><number>&lsqb;0226&rsqb;</number> (b) The result is &plus;&infin; with the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result being the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the &plus;&infin; operand. The other operand does not affect the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result. </paragraph>
<paragraph id="P-0227" lvl="2"><number>&lsqb;0227&rsqb;</number> (c) The result is a copy of the NaN operand, except that the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result are the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the two operands. </paragraph>
<paragraph id="P-0228" lvl="2"><number>&lsqb;0228&rsqb;</number> (d) The result is a copy of the Nan operand, except that the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result are the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the NaN operand with 01001 (to indicate overflow and inexact conditions). </paragraph>
<paragraph id="P-0229" lvl="2"><number>&lsqb;0229&rsqb;</number> (e) The result is a copy of whichever operand has the smaller magnitude. </paragraph>
<paragraph id="P-0230" lvl="2"><number>&lsqb;0230&rsqb;</number> (f) The result is a copy of the Nan operand. </paragraph>
<paragraph id="P-0231" lvl="2"><number>&lsqb;0231&rsqb;</number> (g) The result is a copy of the NaN operand, except that the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result are the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the NaN operand with 00101 (to indicate underflow and inexact conditions). </paragraph>
<paragraph id="P-0232" lvl="2"><number>&lsqb;0232&rsqb;</number> (h) The result is a copy of whichever operand has the larger magnitude. </paragraph>
<paragraph id="P-0233" lvl="2"><number>&lsqb;0233&rsqb;</number> (i) The result is &plus;&infin; with the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result being the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction fields of the two operands. </paragraph>
<paragraph id="P-0234" lvl="2"><number>&lsqb;0234&rsqb;</number> (j) The result is a copy of whichever NaN operand has the larger fraction, except that the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result are the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction fields of the two operands. The sign of the result is the sign of whichever operand has the larger fraction but, if the fractions of the two NaN operands are the same and their signs differ, the sign of the result is </paragraph>
<paragraph id="P-0235" lvl="0"><number>&lsqb;0235&rsqb;</number> The following is a key to symbols in the table depicted in <cross-reference target="DRAWINGS">FIG. 11</cross-reference> (the minimum operation): </paragraph>
<paragraph id="P-0236" lvl="2"><number>&lsqb;0236&rsqb;</number> (a) The result is &minus;&infin; with the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field bits of the result being the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction fields of the two operands. </paragraph>
<paragraph id="P-0237" lvl="2"><number>&lsqb;0237&rsqb;</number> (b) The result is &minus;&infin; with the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result being equal to the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the operand. The other operand does not affect the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result. </paragraph>
<paragraph id="P-0238" lvl="2"><number>&lsqb;0238&rsqb;</number> (c) The result is a copy of the &minus;&infin; NaN operand, except that the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result are the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction fields of the two operands. </paragraph>
<paragraph id="P-0239" lvl="2"><number>&lsqb;0239&rsqb;</number> (d) The result is a copy of the NaN operand, except that the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result are the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the NaN operand with 01001 (to indicate overflow and inexact conditions). </paragraph>
<paragraph id="P-0240" lvl="2"><number>&lsqb;0240&rsqb;</number> (e) The result is a copy of whichever operand has the larger magnitude. </paragraph>
<paragraph id="P-0241" lvl="2"><number>&lsqb;0241&rsqb;</number> (f) The result is a copy of the NaN operand. </paragraph>
<paragraph id="P-0242" lvl="2"><number>&lsqb;0242&rsqb;</number> (g) The result is a copy of the NaN operand, except that the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result are the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the NaN operand with 00101 (to indicate underflow and inexact conditions). </paragraph>
<paragraph id="P-0243" lvl="2"><number>&lsqb;0243&rsqb;</number> (h) The result is a copy of whichever operand has the smaller magnitude. </paragraph>
<paragraph id="P-0244" lvl="2"><number>&lsqb;0244&rsqb;</number> (i) The result is &plus;&infin; with the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result being the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the two operands. </paragraph>
<paragraph id="P-0245" lvl="2"><number>&lsqb;0245&rsqb;</number> (j) The result is a copy of whichever NaN operand has the larger (not smaller) fraction, except that the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the result are the bitwise OR of the five least significant bits f<highlight><subscript>lsb&plus;4 </subscript></highlight>. . . f<highlight><subscript>lsb </subscript></highlight>of the fraction field of the two operands. The sign of the result is the sign of whichever operand has the larger fraction. However, if the fractions of the two NaN operands are the same and their signs differ, the sign of the result is &minus;. </paragraph>
<paragraph id="P-0246" lvl="7"><number>&lsqb;0246&rsqb;</number> Comparator Unit <highlight><bold>46</bold></highlight> </paragraph>
<paragraph id="P-0247" lvl="0"><number>&lsqb;0247&rsqb;</number> An illustrative circuit for use as exemplary comparator unit <highlight><bold>46</bold></highlight> is described in U.S. patent application Ser. No. ______, filed on even date herewith in the name of Guy L. Steel Jr., and entitled &ldquo;Floating Point Comparator Circuit and Method,&rdquo; assigned to the assignee of the present application and hereby incorporated by reference. As noted above, exemplary comparator unit <highlight><bold>46</bold></highlight> receives two operands and generates a result that indicates whether the operands are equal, and, if not, which operand is larger. Generally, the comparison is not affected by the rounding mode. In a comparison operation consistent with an embodiment of the present invention, </paragraph>
<paragraph id="P-0248" lvl="2"><number>&lsqb;0248&rsqb;</number> (i) two positive operands in the infinity format <highlight><bold>65</bold></highlight> are equal regardless of the values of the flags &ldquo;nouzx,&rdquo;</paragraph>
<paragraph id="P-0249" lvl="2"><number>&lsqb;0249&rsqb;</number> (ii) a positive operand in the infinity format <highlight><bold>65</bold></highlight> is greater than an operand in any other format, except for an operand that is in the NaN format <highlight><bold>66</bold></highlight>, </paragraph>
<paragraph id="P-0250" lvl="2"><number>&lsqb;0250&rsqb;</number> (iii) two negative operands in the infinity format <highlight><bold>65</bold></highlight> are equal regardless of the values of the flags &ldquo;nouzx,&rdquo;</paragraph>
<paragraph id="P-0251" lvl="2"><number>&lsqb;0251&rsqb;</number> (iv) a negative operand in the infinity format <highlight><bold>65</bold></highlight> is less than an operand in any other format, except for an operand that is in the NaN format <highlight><bold>66</bold></highlight>. </paragraph>
<paragraph id="P-0252" lvl="2"><number>&lsqb;0252&rsqb;</number> (v) an operand in the NaN format <highlight><bold>66</bold></highlight> is unordered (i.e., neither greater than, less than, nor equal to) another operand in any format, including another operand in the NaN format <highlight><bold>66</bold></highlight>, and </paragraph>
<paragraph id="P-0253" lvl="2"><number>&lsqb;0253&rsqb;</number> (vi) operands in the format other than the infinity format <highlight><bold>65</bold></highlight> and NaN format <highlight><bold>66</bold></highlight> compare in accordance with IEEE Std. 754. Thus, &plus;UN is greater than &plus;0 and less than &plus;TINY; &plus;OV is greater than &plus;HUGE and less than &plus;&infin;; and so on. </paragraph>
<paragraph id="P-0254" lvl="2"><number>&lsqb;0254&rsqb;</number> Tester Unit <highlight><bold>47</bold></highlight> </paragraph>
<paragraph id="P-0255" lvl="0"><number>&lsqb;0255&rsqb;</number> An illustrative circuit for use as exemplary tester unit <highlight><bold>47</bold></highlight> is described in U.S. patent application Ser. No. ______, filed on even date herewith in the name of Guy L. Steele Jr., and entitled &ldquo;Floating Point Tester Circuit And Method,&rdquo; assigned to the assignee of the present application and hereby incorporated by reference. The tester unit <highlight><bold>47</bold></highlight> receives a single floating-point operand and determines whether it has one of a selected set of status conditions. Based upon the determination, the tester unit <highlight><bold>47</bold></highlight> produces a signal to indicate whether or not the selected condition holds. In one embodiment of the present invention, the conditions include: </paragraph>
<paragraph id="P-0256" lvl="2"><number>&lsqb;0256&rsqb;</number> (i) the operand is in the NaN format <highlight><bold>66</bold></highlight>; </paragraph>
<paragraph id="P-0257" lvl="2"><number>&lsqb;0257&rsqb;</number> (ii) the operand is in the infinity format <highlight><bold>65</bold></highlight>; </paragraph>
<paragraph id="P-0258" lvl="2"><number>&lsqb;0258&rsqb;</number> (iii) the operand is in either the infinity format <highlight><bold>65</bold></highlight> or the NaN format <highlight><bold>66</bold></highlight>; </paragraph>
<paragraph id="P-0259" lvl="2"><number>&lsqb;0259&rsqb;</number> (iv) the operand is in the overflow format <highlight><bold>64</bold></highlight>; </paragraph>
<paragraph id="P-0260" lvl="2"><number>&lsqb;0260&rsqb;</number> (v) the operand is in the overflow format <highlight><bold>64</bold></highlight> or contains a set overflow flag &ldquo;o&rdquo;; </paragraph>
<paragraph id="P-0261" lvl="2"><number>&lsqb;0261&rsqb;</number> (vi) the operand is in the underflow format <highlight><bold>61</bold></highlight>; </paragraph>
<paragraph id="P-0262" lvl="2"><number>&lsqb;0262&rsqb;</number> (vii) the operand is in the underflow format <highlight><bold>61</bold></highlight> or contains a set underflow flag &ldquo;u&rdquo;; </paragraph>
<paragraph id="P-0263" lvl="2"><number>&lsqb;0263&rsqb;</number> (viii) the operand is in the zero format <highlight><bold>60</bold></highlight>; </paragraph>
<paragraph id="P-0264" lvl="2"><number>&lsqb;0264&rsqb;</number> (ix) the operand is in the zero format <highlight><bold>60</bold></highlight> and the sign bit &ldquo;s&rdquo; is &ldquo;zero&rdquo; (representing value &plus;0); </paragraph>
<paragraph id="P-0265" lvl="2"><number>&lsqb;0265&rsqb;</number> (x) the operand is in the zero format <highlight><bold>60</bold></highlight> and the sign bit &ldquo;s&rdquo; is &ldquo;one&rdquo; (representing value &minus;0); </paragraph>
<paragraph id="P-0266" lvl="2"><number>&lsqb;0266&rsqb;</number> (xi) the operand represents a non-zero number whose magnitude is less than 2<highlight><superscript>&minus;126</superscript></highlight>; </paragraph>
<paragraph id="P-0267" lvl="2"><number>&lsqb;0267&rsqb;</number> (xii) the operand contains a set invalid-operation flag &ldquo;n&rdquo;; </paragraph>
<paragraph id="P-0268" lvl="2"><number>&lsqb;0268&rsqb;</number> (xiii) the operand contains a set divide-by-zero flag &ldquo;z&rdquo;; </paragraph>
<paragraph id="P-0269" lvl="2"><number>&lsqb;0269&rsqb;</number> (xiv) the operand represents a numerical value strictly between &minus;OV and &plus;OV; </paragraph>
<paragraph id="P-0270" lvl="2"><number>&lsqb;0270&rsqb;</number> (xv) the operand represents a numerical value strictly between &minus;OV and &plus;OV but is not &plus;UN or &minus;UN; </paragraph>
<paragraph id="P-0271" lvl="2"><number>&lsqb;0271&rsqb;</number> (xvi) the operand is in any format <highlight><bold>60</bold></highlight> through <highlight><bold>66</bold></highlight> and contains a sign bit &ldquo;s&rdquo; that is &ldquo;one&rdquo;; and </paragraph>
<paragraph id="P-0272" lvl="2"><number>&lsqb;0272&rsqb;</number> (xvii) all 11 non-trivial disjunctions (&ldquo;OR&rdquo;) of subsets of: </paragraph>
<paragraph id="P-0273" lvl="3"><number>&lsqb;0273&rsqb;</number> a&equals;(the operand is in overflow format <highlight><bold>64</bold></highlight> or contains a set overflow flag &ldquo;o&rdquo;) </paragraph>
<paragraph id="P-0274" lvl="3"><number>&lsqb;0274&rsqb;</number> b&equals;(the operand is in underflow format <highlight><bold>61</bold></highlight> or contains a set underflow flag &ldquo;u&rdquo;) </paragraph>
<paragraph id="P-0275" lvl="3"><number>&lsqb;0275&rsqb;</number> c&equals;(the operand contains a set invalid operation flag &ldquo;n&rdquo;) </paragraph>
<paragraph id="P-0276" lvl="3"><number>&lsqb;0276&rsqb;</number> d&equals;(the operand contains a set divide-by-zero flag &ldquo;z&rdquo;) </paragraph>
<paragraph id="P-0277" lvl="0"><number>&lsqb;0277&rsqb;</number> In other words, the subsets include (a OR b), (a OR c), (a OR d), (b OR c), (b OR d), (c OR d), (a OR b OR c), (a OR b OR d), (a OR c OR d), (b OR c OR d) and (a OR b OR c OR d). </paragraph>
<paragraph id="P-0278" lvl="0"><number>&lsqb;0278&rsqb;</number> The exemplary tester unit <highlight><bold>47</bold></highlight> can generate one or more result signals representing each of those conditions, which signals will be provided to the control unit <highlight><bold>50</bold></highlight>. In one embodiment, the result signal is provided directly back to control unit <highlight><bold>50</bold></highlight>. In an alternative embodiment, the tester unit <highlight><bold>47</bold></highlight> provides the result signal on a result bus to register <highlight><bold>51</bold></highlight> for future access by the control unit <highlight><bold>50</bold></highlight>. In another embodiment, the control unit <highlight><bold>50</bold></highlight> can select one of these signals and use the value of the selected signal to control the future behavior of the program. For example, the control unit <highlight><bold>50</bold></highlight> may control a functional unit&apos;s operation on one or more operands and use the result of the operation to complete processing of a conditional floating point operation. Examples of conditional floating point operations include but are not limited to conditional trap instructions and conditional branch instructions with multiple possible outcomes that dynamically depend upon the basis of the results of the conditional operations being processed. </paragraph>
<paragraph id="P-0279" lvl="0"><number>&lsqb;0279&rsqb;</number> It will be appreciated that a number of modifications may be made to the exemplary floating point unit <highlight><bold>40</bold></highlight> described above. For example, the exemplary floating point unit <highlight><bold>40</bold></highlight> may include additional or fewer functional units than those described herein. In addition, although reference has been made to circuits described in other patent applications as being useful in the floating point unit <highlight><bold>40</bold></highlight>, it will be appreciated that other circuits may be used to implement the principles of the present invention. Furthermore, although particular floating point status flags &ldquo;n,&rdquo; &ldquo;o,&rdquo; &ldquo;u,&rdquo; &ldquo;z&rdquo; and &ldquo;x&rdquo; have been indicated as being provided, it will be appreciated that not all flags need to be provided, and that other flags, representing other conditions, may be used in addition or instead. </paragraph>
<paragraph id="P-0280" lvl="0"><number>&lsqb;0280&rsqb;</number> The foregoing description has been limited to one or more specific embodiments of this invention. It will be appreciated that a system in accordance with the invention can be constructed in whole or in part from special purpose hardware or a general purpose computer system, or any combination thereof. Data structures used by such a system and described herein are illustrative and may be implemented in a variety of different ways in accordance with alternative embodiments of the present invention. Any portion of the system may also be controlled by a suitable program. Any program controlling such a system may, in whole or in part, comprise part of or be stored on the system in a conventional manner. Further, the program may, in whole or in part, be provided to the system over a network or other mechanism for transferring information in a conventional manner. In addition, it will be appreciated that the system may be operated and/or otherwise controlled by means of information provided by an operator using operator input elements (not shown) which may be connected directly to the system or which may transfer the information to the system over a network or other mechanism for transferring information in a conventional manner. </paragraph>
<paragraph id="P-0281" lvl="0"><number>&lsqb;0281&rsqb;</number> Furthermore, those skilled in the art will appreciate that variations and modifications may be made to the invention, with the attainment of some or all of the advantages of the invention. </paragraph>
<paragraph id="P-0282" lvl="0"><number>&lsqb;0282&rsqb;</number> Other embodiments of the invention will be apparent to those skilled in the art from consideration of the specification and practice of the invention as defined solely by the following appended claims. Therefore, a true scope and spirit of the invention is indicated by the following claims. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A floating point operand data structure used in floating point computations and processing within a processing device, comprising: 
<claim-text>a first portion of the data structure having floating point operand data; and </claim-text>
<claim-text>a second portion of the data structure having embedded status information associated with at least one status condition of the floating point operand data. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The floating point operand data structure of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the at least one status condition is determined from the embedded status information without regard to memory storage external to the data structure. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The floating point operand data structure of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, wherein the memory storage external to the data structure is a floating point status register. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The enhanced floating point operand data structure of <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference>, wherein the outcome of a conditional floating point instruction is based on the embedded status information without regard to contents of the floating point status register. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The floating point operand data structure of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the second portion of the data structure comprises at least one bit that is indicative of the at least one status condition from the group of an invalid operation status, an overflow status, an underflow status, a division by zero status, an infinity status, and an inexact status. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The floating point operand data structure of <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference>, wherein the overflow status represents one in a group of a &plus;OV status and a &minus;OV status. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The floating point operand data structure of <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference>, wherein the overflow status is represented as a predetermined non-infinity numerical value. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The floating point operand data structure of <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference>, wherein the underflow status represents one in a group of a &plus;UV status and a &minus;UV status. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The floating point operand data structure of <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference>, wherein the underflow status is represented as a predetermined non-zero numerical value. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The floating point operand data structure of <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference>, wherein the invalid status represents a not-a-number (NaN) status due to an invalid operation. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The floating point operand data structure of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein the second portion of the data structure comprises a plurality of bits indicative of a predetermined type of operand condition resulting in the NaN status. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The floating point operand data structure of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein addition, multiplication, maximum and minimum floating point operations on the data structure are commutative. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The floating point operand data structure of <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference>, wherein the infinity status represents one in a group of a positive infinity status and a negative infinity status. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The floating point operand data structure of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the second portion of the data structure comprises a plurality of bits indicative of a predetermined type of operand condition resulting in the infinity status. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The floating point operand data structure of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the at least one status condition is associated with at least one floating point operation that generated the enhanced floating point operand data structure. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. A floating point operand data structure used by a processing device when performing floating point operations, the data structure comprising: 
<claim-text>a first data field having sign information associated with the floating point operand; </claim-text>
<claim-text>a second data field having exponent information associated with the floating point operand; and </claim-text>
<claim-text>a third data field having fractional information associated with the floating point operand, wherein at least one of the first data field, the second data field and the third data field further includes embedded status information associated with at least one operand status condition. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The floating point operand data structure of <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, wherein the at least one operand status condition is determined from the embedded status information without regard to a floating point status register that is separate from an operand memory storage device for maintaining the floating point operand data structure. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The floating point operand data structure of <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference>, wherein the outcome of a conditional floating point instruction is based on the embedded status information without regard to contents of the floating point status register. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The floating point operand data structure of <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, wherein the embedded status information comprises at least one bit that is indicative of the at least one operand status condition from the group of an invalid operation status, an overflow status, an underflow status, a division by zero status, an infinity status, and an inexact status. </claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The floating point operand data structure of <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, wherein the at least one operand status condition is indicative of at least one floating point operation that generated the floating point operand data structure. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. A floating point system associated with a processing device for performing at least one floating point operation on a floating point operand, the system comprising: 
<claim-text>an operand memory storage device for maintaining the floating point operand; </claim-text>
<claim-text>a control unit in communication with the operand memory storage device, the control unit receiving at least one floating point instruction associated with the at least one floating point operation and generating at least one control signal related to the at least one floating point operation; and </claim-text>
<claim-text>a first functional processing unit in communication with the operand memory storage device and the control unit, the first functional processing unit capable processing the floating point operand and storing status information within the processed floating point operand. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The floating point system of <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference>, wherein the status information comprises at least one bit that is indicative of an operand status condition from the group of an invalid operation status, an overflow status, an underflow status, a division by zero status, an infinity status, and an inexact status. </claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The floating point system of <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference>, wherein the first functional processing unit is capable of embedding the status information related to the processed floating point operand within predetermined fields of the processed floating point operand. </claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The floating point system of <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference>, wherein the first functional processing unit is capable of providing the processed floating point operand to the operand memory storage device without storing the status information to a separate status memory device. </claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. The floating point system of <dependent-claim-reference depends_on="CLM-00022">claim 24</dependent-claim-reference>, wherein the control unit is operative to condition the outcome of the floating point instruction based upon the status information within the processed floating point operand without accessing the separate status memory device. </claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. The floating point system of <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference> further comprising a second functional processing unit in communication with the memory storage device and the control unit, the second functional processing unit being capable of processing a second floating point operand and storing status information related to the second floating point operand while the status information related to the first floating point operand is preserved. </claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. A floating point processing system for performing at least one floating point operation on a floating point operand, the system comprising: 
<claim-text>an operand memory register for maintaining the floating point operand; and </claim-text>
<claim-text>a functional processing unit in communication with the operand memory register, the functional processing unit being operative to: 
<claim-text>receive the floating point operand from the operand memory register, </claim-text>
<claim-text>process the floating point operand to determine status information related to the processed floating point operand, and </claim-text>
<claim-text>embed the status information within the processed floating point operand. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. The floating point system of <dependent-claim-reference depends_on="CLM-00022">claim 27</dependent-claim-reference>, wherein the status information comprises at least one bit that is indicative of an operand status condition from the group of an invalid operation status, an overflow status, an underflow status, a division by zero status, an infinity status, and an inexact status. </claim-text>
</claim>
<claim id="CLM-00029">
<claim-text><highlight><bold>29</bold></highlight>. The floating point system of <dependent-claim-reference depends_on="CLM-00022">claim 27</dependent-claim-reference>, wherein the functional processing unit is further operable to embed the status information within at least one predetermined field of the processed floating point operand. </claim-text>
</claim>
<claim id="CLM-00030">
<claim-text><highlight><bold>30</bold></highlight>. The floating point system of <dependent-claim-reference depends_on="CLM-00022">claim 27</dependent-claim-reference>, wherein the functional processing unit is capable of storing the processed floating point operand in the operand memory register without storing the status information in a floating point status register separate from the operand memory register. </claim-text>
</claim>
<claim id="CLM-00031">
<claim-text><highlight><bold>31</bold></highlight>. The floating point system of <dependent-claim-reference depends_on="CLM-00022">claim 27</dependent-claim-reference> further comprising a control unit in communication with the operand memory register and the functional processing unit, the control unit being operative to condition the outcome of the floating point instruction based only upon the status information within the processed floating point operand. </claim-text>
</claim>
<claim id="CLM-00032">
<claim-text><highlight><bold>32</bold></highlight>. The floating point system of <dependent-claim-reference depends_on="CLM-00033">claim 31</dependent-claim-reference> further comprising an additional functional processing unit in communication with the operand memory register and the control unit, the additional functional processing unit being capable of concurrently processing an additional floating point operand and storing status information related to the additional floating point operand within the additional floating point operand while the status information related to the other floating point operand is preserved within the other floating point operand. </claim-text>
</claim>
<claim id="CLM-00033">
<claim-text><highlight><bold>33</bold></highlight>. A method of encoding a floating point operand with status information without maintaining the status information in a floating point status register, comprising: 
<claim-text>determining a status condition of the floating point operand as part of processing the floating point operand in association with a floating point operation; and </claim-text>
<claim-text>representing an updated status condition of the floating point operand within the floating point operand. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00034">
<claim-text><highlight><bold>34</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00033">claim 33</dependent-claim-reference>, wherein the determining step further comprises identifying the status condition and the updated status condition from only embedded status information within the floating point operand. </claim-text>
</claim>
<claim id="CLM-00035">
<claim-text><highlight><bold>35</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00033">claim 33</dependent-claim-reference>, wherein the status condition and the updated status condition are from the group of an invalid operation status, an overflow status, an underflow status, a division by zero status, an infinity status, and an inexact status. </claim-text>
</claim>
<claim id="CLM-00036">
<claim-text><highlight><bold>36</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00033">claim 33</dependent-claim-reference>, wherein the representing step further comprises embedding updated status information within the floating point operand after execution of the floating point operation, the updated status information representing the updated status condition. </claim-text>
</claim>
<claim id="CLM-00037">
<claim-text><highlight><bold>37</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00033">claim 33</dependent-claim-reference>, wherein the updated status condition is indicative of a previous floating point operation that resulted in the floating point operand. </claim-text>
</claim>
<claim id="CLM-00038">
<claim-text><highlight><bold>38</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00033">claim 33</dependent-claim-reference> further comprising conditioning a subsequent floating point operation based only upon the updated status information within the floating point operand. </claim-text>
</claim>
<claim id="CLM-00039">
<claim-text><highlight><bold>39</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00033">claim 33</dependent-claim-reference> further comprising processing an additional floating point operand and representing updated status information related to the additional floating point operand within the additional floating point operand while the updated status information related to the other floating point operand is preserved. </claim-text>
</claim>
<claim id="CLM-00040">
<claim-text><highlight><bold>40</bold></highlight>. A method of encoding a floating point operand with status information related to a status of the floating point operand without maintaining the status information in a floating point status register, comprising: 
<claim-text>receiving a floating point instruction; </claim-text>
<claim-text>accessing a floating point operand to be processed as part of processing the floating point instruction; 
<claim-text>decoding an initial status condition of the floating point operand from only status information embedded within the floating point operand; and </claim-text>
<claim-text>encoding a resulting status condition from execution of the floating point instruction on the floating point operand as updated status information within the floating point operand. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00041">
<claim-text><highlight><bold>41</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00044">claim 40</dependent-claim-reference> further comprising conditioning execution of a subsequent floating point instruction based only on the updated status information within the floating point operand. </claim-text>
</claim>
<claim id="CLM-00042">
<claim-text><highlight><bold>42</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00044">claim 40</dependent-claim-reference>, wherein the initial status condition and resulting status condition are from the group of an invalid operation status, an overflow status, an underflow status, a division by zero status, an infinity status, and an inexact status. </claim-text>
</claim>
<claim id="CLM-00043">
<claim-text><highlight><bold>43</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00044">claim 40</dependent-claim-reference> further comprising processing an additional floating point operand and encoding an updated status information into the additional floating point operand while the updated status information related to the other floating point operand is preserved. </claim-text>
</claim>
<claim id="CLM-00044">
<claim-text><highlight><bold>44</bold></highlight>. A computer-readable medium on which is stored a set of instructions for encoding a floating point operand with status information without maintaining the status information in a floating point status register, which when executed perform steps comprising: 
<claim-text>determining a status condition of the floating point operand as part of processing the floating point operand in association with a floating point operation; and </claim-text>
<claim-text>representing an updated status condition of the floating point operand within the floating point operand. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00045">
<claim-text><highlight><bold>45</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00044">claim 44</dependent-claim-reference>, wherein the determining step further comprises identifying the status condition and the updated status condition from only embedded status information within the floating point operand. </claim-text>
</claim>
<claim id="CLM-00046">
<claim-text><highlight><bold>46</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00044">claim 44</dependent-claim-reference>, wherein the status condition and the updated status condition are from the group of an invalid operation status, an overflow status, an underflow status, a division by zero status, an infinity status, and an inexact status. </claim-text>
</claim>
<claim id="CLM-00047">
<claim-text><highlight><bold>47</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00044">claim 44</dependent-claim-reference>, wherein the representing step further comprises embedding updated status information within the floating point operand after execution of the floating point operation, the updated status information representing the updated status condition. </claim-text>
</claim>
<claim id="CLM-00048">
<claim-text><highlight><bold>48</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00044">claim 44</dependent-claim-reference>, wherein the updated status condition is indicative of a previous floating point operation that resulted in the floating point operand. </claim-text>
</claim>
<claim id="CLM-00049">
<claim-text><highlight><bold>49</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00044">claim 44</dependent-claim-reference> further comprising conditioning a subsequent floating point operation based only upon the updated status information within the floating point operand. </claim-text>
</claim>
<claim id="CLM-00050">
<claim-text><highlight><bold>50</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00044">claim 44</dependent-claim-reference> further comprising processing an additional floating point operand and representing updated status information related to the additional floating point operand within the additional floating point operand while the updated status information related to the other floating point operand is preserved. </claim-text>
</claim>
<claim id="CLM-00051">
<claim-text><highlight><bold>51</bold></highlight>. A computer-readable medium on which is stored a set of instructions for encoding a floating point operand with status information related to a status of the floating point operand without maintaining the status information in a floating point status register, which when executed perform steps comprising: 
<claim-text>receiving a floating point instruction; </claim-text>
<claim-text>accessing a floating point operand to be processed as part of processing the floating point instruction; </claim-text>
<claim-text>decoding an initial status condition of the floating point operand from only status information embedded within the floating point operand; and </claim-text>
<claim-text>encoding a resulting status condition from execution of the floating point instruction on the floating point operand as updated status information within the floating point operand. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00052">
<claim-text><highlight><bold>52</bold></highlight>. The computer-readable medium of claim <highlight><bold>51</bold></highlight> further comprising conditioning execution of a subsequent floating point instruction based only on the updated status information within the floating point operand. </claim-text>
</claim>
<claim id="CLM-00053">
<claim-text><highlight><bold>53</bold></highlight>. The computer-readable medium of claim <highlight><bold>51</bold></highlight>, wherein the initial status condition and resulting status condition are from the group of an invalid operation status, an overflow status, an underflow status, a division by zero status, an infinity status, and an inexact status. </claim-text>
</claim>
<claim id="CLM-00054">
<claim-text><highlight><bold>54</bold></highlight>. The computer-readable medium of claim <highlight><bold>51</bold></highlight> further comprising processing an additional floating point operand and encoding an updated status information into the additional floating point operand while the updated status information related to the other floating point operand is preserved.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>4</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005013A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005013A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005013A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005013A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005013A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005013A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030005013A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030005013A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030005013A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00009">
<image id="EMI-D00009" file="US20030005013A1-20030102-D00009.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00010">
<image id="EMI-D00010" file="US20030005013A1-20030102-D00010.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00011">
<image id="EMI-D00011" file="US20030005013A1-20030102-D00011.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
