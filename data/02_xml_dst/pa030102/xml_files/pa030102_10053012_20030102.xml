<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005122A1-20030102-D00000.TIF SYSTEM "US20030005122A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005122A1-20030102-D00001.TIF SYSTEM "US20030005122A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005122A1-20030102-D00002.TIF SYSTEM "US20030005122A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005122A1-20030102-D00003.TIF SYSTEM "US20030005122A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005122A1-20030102-D00004.TIF SYSTEM "US20030005122A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005122A1-20030102-D00005.TIF SYSTEM "US20030005122A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030005122A1-20030102-D00006.TIF SYSTEM "US20030005122A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030005122A1-20030102-D00007.TIF SYSTEM "US20030005122A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030005122A1-20030102-D00008.TIF SYSTEM "US20030005122A1-20030102-D00008.TIF" NDATA TIF>
<!ENTITY US20030005122A1-20030102-D00009.TIF SYSTEM "US20030005122A1-20030102-D00009.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005122</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10053012</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20020118</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F015/16</ipc>
</classification-ipc-primary>
<classification-ipc-secondary>
<ipc>G06F015/173</ipc>
</classification-ipc-secondary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>709</class>
<subclass>225000</subclass>
</uspc>
</classification-us-primary>
<classification-us-secondary>
<uspc>
<class>709</class>
<subclass>217000</subclass>
</uspc>
</classification-us-secondary>
</classification-us>
<title-of-invention>In-kernel content-aware service differentiation</title-of-invention>
</technical-information>
<continuity-data>
<non-provisional-of-provisional>
<document-id>
<doc-number>60301292</doc-number>
<document-date>20010627</document-date>
<country-code>US</country-code>
</document-id>
</non-provisional-of-provisional>
</continuity-data>
<inventors>
<first-named-inventor>
<name>
<given-name>Douglas</given-name>
<middle-name>Morgan</middle-name>
<family-name>Freimuth</family-name>
</name>
<residence>
<residence-us>
<city>New York</city>
<state>NY</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Ashish</given-name>
<family-name>Mehra</family-name>
</name>
<residence>
<residence-us>
<city>Mountain View</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Renu</given-name>
<family-name>Tewari</family-name>
</name>
<residence>
<residence-us>
<city>San Jose</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Thiemo</given-name>
<family-name>Voigt</family-name>
</name>
<residence>
<residence-non-us>
<city>Uppsale</city>
<country-code>SE</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<assignee>
<organization-name>International Business Machines Corporation</organization-name>
<address>
<city>Armonk</city>
<state>NY</state>
</address>
<assignee-type>02</assignee-type>
</assignee>
<correspondence-address>
<name-1>IBM CORPORATION</name-1>
<name-2>INTELLECTUAL PROPERTY LAW DEPT.</name-2>
<address>
<address-1>P.O. BOX 218</address-1>
<city>YORKTOWN HEIGHTS</city>
<state>NY</state>
<postalcode>10598</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">The increasing number of Internet users and innovative new services such as e-commerce are placing new demands on Web servers. It is becoming essential for Web servers to provide performance isolation, have fast recovery times, and provide continuous service during overload at least to preferred customers. The invention describes a kernel-based architecture for content-aware service differentiation that protects Web servers against overload by controlling the amount and rate of work entering the system. We have invented a mechanism that provides admission control and service differentiation based on connection and application level information. The application header-based connection control uses application-level information (such as URIs and cookies for HTTP) to define different service differentiation actions. The present invention provides the kernel mechanisms that are more efficient and scalable than application level controls implemented in current Web servers. </paragraph>
</subdoc-abstract>
<subdoc-description>
<cross-reference-to-related-applications>
<heading lvl="1">PRIORITY </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> This application claims priority from Provisional Application, filed, Jun. 27, 2001, DOCKET NUMBER: YOR920010561US1, assigned Serial No. 60/301,292.</paragraph>
</cross-reference-to-related-applications>
<summary-of-invention>
<section>
<heading lvl="1">FIELD OF THE INVENTION </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> This invention is directed to the field of operating systems and computer networking. It is more particularly directed to enable content-aware service differentiation in servers which communicate with clients over a network. </paragraph>
</section>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> Application service providers and Web hosting services that co-host multiple customer sites on the same server cluster or large SMP&apos;s are becoming increasingly common in the current Internet infrastructure. The increasing growth of e-commerce on the web means that any server down time that affects the clients being serviced will result in a corresponding loss of revenue. Additionally, the unpredictability of flash crowds can overwhelm a hosting server and bring down multiple customer sites simultaneously, affecting the performance of a large number of clients. It becomes essential, therefore, for hosting services to provide performance isolation, fast recovery times, and continuous operation under overload conditions at least to preferred customers. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> Each of the co-hosted customers sites may have different quality-of-service (QoS) goals based on the price of the service and the application requirements. Furthermore, each customer site may require different services during overload based on the client&apos;s identity (preferred gold client) and the content they access (e.g., a client with a buy order versus a browsing request). When providing service differentiation during overload it is important to know who the request was from and what it is intended to do. The current techniques of using the incoming connections network header values to differentiate requests is not sufficient. The network headers (IP address and port numbers) only identify the origin client machine and the destination client machine and the receiving application at the destination port. With clients behind a proxy all clients will share the same network and cannot be distinguished. Similarly the type of request that can be determined from the port number as being an FTP transfer vs. an HTTP transfer but cannot distinguish a browse order from a buy order. Current commercial switches and routers use a simple threshold-based request discard policy (e.g., a TCP SYN drop mode) to discard the incoming, oldest or any random connection to control overload. Such techniques may delay or control overload but pay a penalty by discarding a high priority gold customer request instead of an ordinary request. These content-unaware approaches are not adequate as they do not distinguish between the individual QoS requirements. For example, a majority of the load is caused by a few CGI requests and most of the bytes transferred belong to a small set of large files. It has been shown in earlier studies that 90% of the web requests are for 10% of the pages at a site. But 10% of the requests account for 80% of the data transferred. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> Consider for example, a news site with a small size main page which is accessed by a majority of the customers. Few customers will download a large audio/video news segment which will cause a high load on the server and the network. If all the small page requests were dropped they would possibly not reduce the server load as much as the single video segment request. This suggests that targeting specific information and client identities (e.g., URIs, types of URIs, cookie information, SSL session ids) for service differentiation can have a wide impact during overload. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> One approach to do content-aware service differentiation is to do it within the application or in user space. Clearly when content-based control is performed it requires that the application is modified and is aware of service differentiation functions during overload. This does not achieve application transparency. Modifying legacy applications is difficult. Secondly, control is handed to the application at a much later stage compared to when the operating system kernel processing begins. In such a case low priority requests or requests that will be discarded subsequently will use precious server resources during overload for no useful work. The service differentiation during overload should follow the &ldquo;early discard&rdquo; policy. In this case prioritizing a request or deciding to discard or delay a request should be done as soon as the request is received by the kernel. This implies that an ideal location of content-aware service differentiation is within the operating system kernel. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> To overcome these problems, the present invention embodies new kernel mechanisms that enable Web servers to provide content-aware service differentiation functions such as policing actions, request dropping, request prioritization, request rate control, and request scheduling, during overload based on client identity and application-specific information. The industry focus on QoS has been network centric but our invention resides on the server allowing for tighter integration with applications and application data like URI&apos;s and cookies. Outbound QoS traffic controls alone are not enough to provide the necessary service differentiation required in the current Web server environment. The level of service differentiation required can be provided with integrated outbound and inbound traffic control kernel mechanisms which classify requests based on applicaton content. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> In this invention we describe methods, systems and apparatus for content-aware service differentiation for overloaded servers within the server operating system. One service-differentiation police action includes silently dropping a communication request received based on the request content. An alternate action is to send a specific message to the client informing that the service is unavailable. In an alternate action the communication request received is scheduled in the kernel based on the request content to determine the order in which the requests are accepted. Different scheduling policies can be specified for this action. In one scheduling policy a priority ordering can be used where a higher priority request is serviced first by the application. A second policy is to use a weighted round-robin ordering where the weights are determined by the service differentiation requirement. In an alternate action the communication request is rate controlled based on the request content. The rate control action limits the rate of new requests entering the system and the number of concurrent requests that are allowed to enter the system. In an alternate action the statistics of the incoming requests are monitored and recorded based on the request content. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> Thus, the present invention introduces kernel mechanisms in the networking stack of the operating system to support content-aware service differentiation and admission control based on client attributes (IP address, SSL session id, port etc.), server attributes (IP address, type), and the request content (e.g., URI accessed, CGI request information, cookie attributes etc.). </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> An advantage of a kernel-based approach is that it provides lower overhead and better performance for service differentiation as it is placed in the request processing path of the kernel (in the networking stack). It enables &ldquo;informed early discard&rdquo; where control can be enforced in the early stages of a request lifetime without consuming system resources but with full knowledge of the request type and client identity. Secondly, it can be implemented easily in any commercial operating system without any complex change to the underlying architectures. Finally, it can be deployed in both the server as well as any external switch or router that controls a cluster of server machines.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> These and other aspects, features, and advantages of the present invention will become apparent upon further consideration of the following detailed description of the present invention when read in conjunction with the drawing figures, in which: </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a diagram that shows the header format of a standard IP packet, a TCP packet and an HTTP message; </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is an example diagram that shows the components of the system architecture of the networking stack for HTTP header based service differentiation, which includes a classifier, an incoming connection queue (also called SYN queue or partial listen queue), an HTTP header classifier, the service differentiation rule table having classification rules and action rules and their processing engine, and a queue of accepted connections (also called accept queue or listen queue), along with the incoming TCP connections and the receiving processes and an external policy agent, in accordance with the present invention; </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is an example block diagram that delineates the steps taken by the kernel to execute the associated service differentiation action rule after matching a particular application header-based classification rule in accordance with the present invention; </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is an example block diagram that delineates the steps taken by the kernel when the desired action rule is to DROP an incoming connection that matched a particular application header-based rule, in accordance with the present invention; </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is an example block diagram that delineates the steps taken by the kernel when the desired action rule is to RATE CONTROL an incoming connection that matched a particular application header-based rule, in accordance with the present invention; </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is an example block diagram that delineates the steps taken by the kernel when the desired action rule is to SCHEDULE ORDER an incoming connection that matched a particular application header-based rule, in accordance with the present invention; </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> is an example diagram that shows the format of the rules tables that include a selector field and the corresponding action, in accordance with the present invention; </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> is an example diagram that delineates the different components of the service differentiation module in the kernel, in accordance with the present invention; and </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference> is an example diagram that delineates the different components of the policy agent and its communication with the kernel, in accordance with the present invention.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DESCRIPTION OF THE INVENTION </heading>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> The present invention provides methods, systems and apparatus to efficiently perform content-aware service differentiation in the kernel for overloaded servers based on application layer information. In a first example embodiment of the present invention we leverage the fact that the majority of traffic received by servers from external clients uses the HTTP protocol which in turn is sent over a TCP transport connection. The HTTP header information can be used to identify the type of request, the client identity and other client specific information that can be used to perform informed service differentiation. With the increasing deployment of e-commerce sites, sessions or Web transactions are widely used where web servers exploit cookies in the HTTP header to identify session state. These cookies include attribute value pairs that can also be used to uniquely identify a client and the nature and type of the request. In this embodiment the information in the HTTP headers (URI name or type, cookie attribute-value pairs or other header tags) are used to provide content-aware service differentiation. An alternate embodiment provides application header-based service differentiation, that enables content-aware service differentiation by examining information in any application header sent over a transport protocol. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> The service differentiation mechanisms are placed in the kernel&apos;s networking stack to transparently intercept the data packets of a new TCP connection to parse the layer headers, classify the attributes in the header based on the classifier rules and find a matching rule and then apply the associated service differentiation action rules that include but are not limited to: </paragraph>
<paragraph id="P-0023" lvl="2"><number>&lsqb;0023&rsqb;</number> (i) controlling the rate and burst of new incoming requests, </paragraph>
<paragraph id="P-0024" lvl="2"><number>&lsqb;0024&rsqb;</number> (ii) dropping (or terminating) a new request, </paragraph>
<paragraph id="P-0025" lvl="2"><number>&lsqb;0025&rsqb;</number> (iii) scheduling request accept order (i.e., ordering requests based on priority or a weighted round-robin order in the accept queue), </paragraph>
<paragraph id="P-0026" lvl="2"><number>&lsqb;0026&rsqb;</number> (iv) monitoring and recording request statistics. </paragraph>
<paragraph id="P-0027" lvl="7"><number>&lsqb;0027&rsqb;</number> The classifier involves parsing the (HTTP in this example) header in the kernel and applying an action rule includes waking the sleeping server process only after a decision on how to service the connection is made based on the action rule. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> shows the formats of a standard HTTP message that includes a IP (<highlight><bold>101</bold></highlight>) and TCP (<highlight><bold>102</bold></highlight>) packet headers and the HTTP (<highlight><bold>103</bold></highlight>) header with the HTTP payload (<highlight><bold>104</bold></highlight>). The IP header (<highlight><bold>101</bold></highlight>) includes in particular the source and destination IP addresses. The TCP packet header (<highlight><bold>102</bold></highlight>) includes the port numbers. The HTTP header (<highlight><bold>103</bold></highlight>) includes in particular the HTTP command, the URI being accessed and the list of cookies. The HTTP header is terminated by two CR control characters. The kernel detects the HTTP header semantics by parsing the data stream to detect the delimiter for the header. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> shows the architecture for application header-based service differentiation. The incoming TCP connection (<highlight><bold>201</bold></highlight>) is classified using a SYN classifier (<highlight><bold>202</bold></highlight>) and placed in the SYN queue (<highlight><bold>203</bold></highlight>) that includes new connections that are not yet established (i.e., the TCP 3-way handshake is not yet been completed). After the TCP handshake completes and data is received to determine the HTTP header (<highlight><bold>204</bold></highlight>), the kernel classifies the request based on the header values (<highlight><bold>206</bold></highlight>). Such a classification matches the incoming connection values (e.g., URIs and cookies) to a set of classification rules and their associated action rules. These together are called the service differentiation rules are stored in rule table (<highlight><bold>211</bold></highlight>) which are populated by a user level policy agent (<highlight><bold>212</bold></highlight>) using any standard mechanism to communicate with the kernel (socket or system calls). Once the request is classified the corresponding action rule is applied to it (<highlight><bold>207</bold></highlight>). Based on the type of action, further TCP post processing of the request is performed (<highlight><bold>208</bold></highlight>) and the request is placed in a queue of accepted connections (<highlight><bold>209</bold></highlight>), also called the accept queue or listen queue. The process (<highlight><bold>210</bold></highlight>) sleeping on a listen socket is woken up to service the request at the head of the queue. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is an example block diagram that delineates the steps taken by the kernel for providing a service differentiation action. The data in the new established TCP connection (<highlight><bold>301</bold></highlight>) is parsed to detect the application header and its attributes (<highlight><bold>302</bold></highlight>). For the HTTP example, this includes determining the URI and cookies. The URI is the 3rd string in the HTTP header and the cookies start with a cookie delimiter as defined in the HTTP protocol in RFC 2068. The parsed header is then matched against the rule table to find a matching classification rule (<highlight><bold>303</bold></highlight>). The associated action rule is found (<highlight><bold>304</bold></highlight>) which is then executed (<highlight><bold>305</bold></highlight>) and the required processing done (<highlight><bold>306</bold></highlight>). After that the standard TCP processing continues (<highlight><bold>307</bold></highlight>) and the sleeping server process is then woken to continue processing the data (<highlight><bold>308</bold></highlight>). </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is an example block diagram that delineates the steps taken by the kernel when the matching action rule is a connection &ldquo;drop&rdquo;. The data in the new established TCP connection (<highlight><bold>401</bold></highlight>) is parsed to detect the application header (<highlight><bold>402</bold></highlight>). For HTTP this includes determining the URI and cookies. The URI is the 3rd string in the HTTP header and the cookies start with a cookie delimiter as defined in the HTTP protocol in RFC 2068. The parsed header is then matched against the rule table to find a matching classification rule (<highlight><bold>403</bold></highlight>). When the associated action rule is to discard the connection (by a DROP action in <highlight><bold>404</bold></highlight>) a TCP RST is sent back to the client (<highlight><bold>405</bold></highlight>) and a cleanup is performed (<highlight><bold>406</bold></highlight>). Alternately, instead of <highlight><bold>405</bold></highlight>, for HTTP, an HTTP packet is sent back with a return code for the server being busy as defined in the HTTP protocol in RFC 2068. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is an example block diagram that delineates the steps taken by the kernel when the matching action rule is a connection &ldquo;rate control&rdquo;. The data in the new established TCP connection (<highlight><bold>501</bold></highlight>) is parsed to detect the application header (<highlight><bold>502</bold></highlight>). The parsed header is then matched against the rule table to find a matching classification rule (<highlight><bold>503</bold></highlight>). When the associated action rule is to rate limit the connection (by a RATE CONTROL action in <highlight><bold>504</bold></highlight>) a compliance check is made against a set of token bucket parameters of (rate and burst) ( as shown in <highlight><bold>504</bold></highlight>). The rate control parameters include a rate value which is the rate of new connections that are admitted, and a burst value that is the maximum number of concurrent connections that are admitted. A token bucket with depth equal to the burst parameter and a token regeneration rate set to the rate parameter is used to perform the rate control compliance check. If a token is available in the bucket (<highlight><bold>508</bold></highlight>), it is consumed and the connection is inserted in the queue of accepted connections (<highlight><bold>506</bold></highlight>) in the desired order. After which the standard processing of the TCP connection continues (<highlight><bold>507</bold></highlight>). If a token was not available (<highlight><bold>508</bold></highlight>), that is the connection is not compliant, the connection is to be discarded and a TCP RST is sent back to the client (<highlight><bold>509</bold></highlight>) and the cleanup is performed (<highlight><bold>510</bold></highlight>). Alternately instead of <highlight><bold>509</bold></highlight>, for HTTP an HTTP packet is sent back with a return code for the server being busy as defined in the HTTP protocol in RFC 2068. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is an example block diagram that delineates the steps taken by the kernel when the matching action rule is a connection &ldquo;schedule order&rdquo;. The data in the new established TCP connection (<highlight><bold>601</bold></highlight>) is parsed to detect the application header (<highlight><bold>602</bold></highlight>). The parsed header is then matched against the rule table to find a matching classification rule (<highlight><bold>603</bold></highlight>). When the associated action rule is a schedule ordering (<highlight><bold>604</bold></highlight>), the scheduling policy and it&apos;s parameters described in the action rule (<highlight><bold>605</bold></highlight>) are used to determine the location of the connection in the queue of accepted connections. Any scheduling policy can be used for this purpose. <cross-reference target="DRAWINGS">FIG. 6</cross-reference> shows the case when the policy is priority-based scheduling. For priority policy, based on the value of the priority assigned to the connection it is inserted in the list of accepted connections (<highlight><bold>606</bold></highlight>) in the highest priority first order, where all connections of higher priority are ahead in the queue and all connections with the same priority are inserted in the FCFS (first come first served) order. After which the standard TCP processing continues (<highlight><bold>607</bold></highlight>). By ordering connections by priority, a higher priority request (e.g., a buy order) is serviced first by the web server, instead of a lower priority request (e.g., a browse request), as it is placed earlier in the queue of accepted connections. Another policy example is the weighted round-robin scheduler that defines a weight for each class and determines the number of requests that are selected from each class based on the weight and proceeds in a round-robin fashion. The weights are assigned based on an external administrative policy or dynamically by the kernel. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> shows an example service differentiation rule table which includes a classification rule and action rule pairs. The classification rule could include a URI string (<highlight><bold>701</bold></highlight>) with an associated action rule to DROP (<highlight><bold>701</bold></highlight>) all connections whose HTTP header included the said URI string. The classification rule could also be a cookie attribute value pair (<highlight><bold>703</bold></highlight>) and the action rule including schedule order a priority value (<highlight><bold>703</bold></highlight>). In <highlight><bold>704</bold></highlight>, the classification rule includes a URI string with a combined action of rate control along with schedule order with a priority value. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> shows an example of components of the service differentiation module that includes a parser (<highlight><bold>802</bold></highlight>) that parses the application headers from the incoming connection (<highlight><bold>801</bold></highlight>) and a classifier (<highlight><bold>803</bold></highlight>) that classifies the connection based on the classification rules. The selector (<highlight><bold>804</bold></highlight>) finds the associated action rule and the performer executes the desired action. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference> shows the interaction between the user space policy agent (<highlight><bold>901</bold></highlight>) and the kernel components. The communicator (<highlight><bold>902</bold></highlight>) uses an API to communicate with the policy agent. The initialiser (<highlight><bold>903</bold></highlight>) sets up the service differentiation rule table (<highlight><bold>905</bold></highlight>) and initializes the rules. The manager (<highlight><bold>904</bold></highlight>) adds new rules and deletes and updates existing rules based on the policy agent commands. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> Thus the invention also includes a method comprising forming a rule. The step of forming often includes the steps of: communicating from a user space to a kernel with an application interface; instantiating service differentiation rules for an application tag within the kernel which include classification and action rules; and deleting and adding rules based upon a user request. In some embodiments the method further includes updating rules based upon a user request. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> The present invention can be realized in hardware, software, or a combination of hardware and software. A visualization tool according to the present invention can be realized in a centralized fashion in one computer system, or in a distributed fashion where different elements are spread across several interconnected computer systems. Any kind of computer system&mdash;or other apparatus adapted for carrying out the methods and/or functions described herein&mdash;is suitable. A typical combination of hardware and software could be a general purpose computer system with a computer program that, when being loaded and executed, controls the computer system such that it carries out the methods described herein. The present invention can also be embedded in a computer program product, which comprises all the features enabling the implementation of the methods described herein, and which&mdash;when loaded in a computer system&mdash;is able to carry out these methods. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> Computer program means or computer program in the present context include any expression, in any language, code or notation, of a set of instructions intended to cause a system having an information processing capability to perform a particular function either directly or after conversion to another language, code or notation, and/or reproduction in a different material form. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> Thus the present invention includes an article of manufacture which comprises a computer usable medium having computer readable program code means embodied therein for causing a function described above. The computer readable program code means in the article of manufacture comprises computer readable program code means for causing a computer to effect the steps of a method of this invention. Similarly, the present invention may be implemented as a computer program product comprising a computer usable medium having computer readable program code means embodied therein for causing a a function described above. The computer readable program code means in the computer program product comprising computer readable program code means for causing a computer to effect one or more functions of this invention. Furthermore, the present invention may be implemented as a program storage device readable by machine, tangibly embodying a program of instructions executable by the machine to perform method steps for causing one or more functions of this invention. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> It is noted that the foregoing has outlined some of the more pertinent objects and embodiments of the present invention. This invention may be used for many applications. Thus, although the description is made for particular arrangements and methods, the intent and concept of the present invention is suitable and applicable to other arrangements and applications. For example, although the description is with regard to HTTP on top of TCP/IP, the concepts of the present invention may similarly be employed for other protocols. It will be clear to those skilled in the art that modifications to the disclosed embodiments can be effected without departing from the spirit and scope of the present invention. The described embodiments ought to be construed to be merely illustrative of some of the more prominent features and applications of the present invention. Other beneficial results can be realized by applying the disclosed invention in a different manner or modifying the present invention in ways known to those familiar with the art. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">Having thus described our invention, what we claim as new and desire to secure by Letters Patent is as follows: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method comprising: 
<claim-text>differentiating at least one service class in a kernel to perform service differentiation based on content in at least one data packet, including the steps of: 
<claim-text>capturing said at least one data packet until a complete application header is detected; </claim-text>
<claim-text>parsing said complete application header to determine at least one application tag; </claim-text>
<claim-text>matching said at least one application tag to at least one matching rule; </claim-text>
<claim-text>determining a presence of at least one match with said at least one matching rule; and </claim-text>
<claim-text>performing service differentiation action based on said at least one matching rule. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. A method as in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein said at least one application tag includes at least one tag taken from a group of tags including: URI, cookie, request method, HTTP version, a tag in an application protocol, and a tag in a communication protocol. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. A method as in <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, wherein the URI is the second string in a HTTP header and the cookie starts with a cookie delimiter as defined in an application protocol. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. A method as in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising employing a table having said at least one matching rule. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. A method as in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the step of determining includes finding a best match. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. A method as in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein said step of performing service differentiation action includes at least one action taken from a group of actions including: dropping, rate controlling, scheduling connections, monitoring, request prioritization, and a policing action. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. A method as in <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference>, wherein said action of dropping includes discarding a connection. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. A method as in <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference>, wherein said action includes at least one act taken from a group of acts including: sending a reset message, sending an application return code, determining compliance with a given rate and/or burst, prioritization, weighted round robin, round robin, ordering, recording statistics, performing a cleanup, and protocol control. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. A method as in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising installing at least one matching rule. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. A method as in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising detecting establishment of a new connection. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. A method as in <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein said step of detecting includes establishing of a new TCP connection. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. A method as in <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, wherein said step of establishing of a new TCP connection includes: receiving SYN packet; sending SYN-ACK packet; deferring accept; receiving ACK for SYN-ACK packet; and deferring notification of data packet. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. A method as in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein said step of capturing includes detecting application header delimiters for said at least one data packet. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. An apparatus comprising a service differentiation module including: 
<claim-text>a parser to parse a client Web request; </claim-text>
<claim-text>a classifier to classify the request based on application headers and assigning a request class within a kernel; </claim-text>
<claim-text>a selector to determine an action rule based on the request class; and </claim-text>
<claim-text>a performer to apply the action rule based on the request class. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. An apparatus comprising a policy agent, said policy agent including: 
<claim-text>a communicator to communicate from a user space to a kernel with an application interface; </claim-text>
<claim-text>an initializer to instantiate service differentiation rules for an application tag within the kernel which include classification and action rules; and </claim-text>
<claim-text>a manager to delete and update rules on a user request. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. A method comprising: 
<claim-text>forming a rule, including the steps of: 
<claim-text>communicating from a user space to a kernel with an application interface; </claim-text>
<claim-text>instantiating service differentiation rules for an application tag within the kernel which include classification and action rules; and </claim-text>
<claim-text>deleting and adding rules based upon a user request. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. A method as in <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, further comprising updating rules based upon a user request. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. An article of manufacture comprising a computer usable medium having computer readable program code means embodied therein for causing service differentiation, the computer readable program code means in said article of manufacture comprising computer readable program code means for causing a computer to effect the steps of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. A program storage device readable by machine, tangibly embodying a program of instructions executable by the machine to perform method steps for service differentiation, said method steps comprising the steps of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>. </claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. A computer program product comprising a computer usable medium having computer readable program code means embodied therein for causing service differentiation, the computer readable program code means in said computer program product comprising computer readable program code means for causing a computer to effect the functions of <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference>. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. A computer program product comprising a computer usable medium having computer readable program code means embodied therein for causing rule installation, the computer readable program code means in said computer program product comprising computer readable program code means for causing a computer to effect the functions of claim <highlight><bold>15</bold></highlight>.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>2</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005122A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005122A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005122A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005122A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005122A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005122A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030005122A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030005122A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030005122A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00009">
<image id="EMI-D00009" file="US20030005122A1-20030102-D00009.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
