<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005103A1-20030102-C00001.CDX SYSTEM "US20030005103A1-20030102-C00001.CDX" NDATA CDX>
<!ENTITY US20030005103A1-20030102-C00001.MOL SYSTEM "US20030005103A1-20030102-C00001.MOL" NDATA MOL>
<!ENTITY US20030005103A1-20030102-C00001.TIF SYSTEM "US20030005103A1-20030102-C00001.TIF" NDATA TIF>
<!ENTITY US20030005103A1-20030102-C00002.CDX SYSTEM "US20030005103A1-20030102-C00002.CDX" NDATA CDX>
<!ENTITY US20030005103A1-20030102-C00002.MOL SYSTEM "US20030005103A1-20030102-C00002.MOL" NDATA MOL>
<!ENTITY US20030005103A1-20030102-C00002.TIF SYSTEM "US20030005103A1-20030102-C00002.TIF" NDATA TIF>
<!ENTITY US20030005103A1-20030102-C00003.CDX SYSTEM "US20030005103A1-20030102-C00003.CDX" NDATA CDX>
<!ENTITY US20030005103A1-20030102-C00003.MOL SYSTEM "US20030005103A1-20030102-C00003.MOL" NDATA MOL>
<!ENTITY US20030005103A1-20030102-C00003.TIF SYSTEM "US20030005103A1-20030102-C00003.TIF" NDATA TIF>
<!ENTITY US20030005103A1-20030102-C00004.CDX SYSTEM "US20030005103A1-20030102-C00004.CDX" NDATA CDX>
<!ENTITY US20030005103A1-20030102-C00004.MOL SYSTEM "US20030005103A1-20030102-C00004.MOL" NDATA MOL>
<!ENTITY US20030005103A1-20030102-C00004.TIF SYSTEM "US20030005103A1-20030102-C00004.TIF" NDATA TIF>
<!ENTITY US20030005103A1-20030102-C00005.CDX SYSTEM "US20030005103A1-20030102-C00005.CDX" NDATA CDX>
<!ENTITY US20030005103A1-20030102-C00005.MOL SYSTEM "US20030005103A1-20030102-C00005.MOL" NDATA MOL>
<!ENTITY US20030005103A1-20030102-C00005.TIF SYSTEM "US20030005103A1-20030102-C00005.TIF" NDATA TIF>
<!ENTITY US20030005103A1-20030102-C00006.CDX SYSTEM "US20030005103A1-20030102-C00006.CDX" NDATA CDX>
<!ENTITY US20030005103A1-20030102-C00006.MOL SYSTEM "US20030005103A1-20030102-C00006.MOL" NDATA MOL>
<!ENTITY US20030005103A1-20030102-C00006.TIF SYSTEM "US20030005103A1-20030102-C00006.TIF" NDATA TIF>
<!ENTITY US20030005103A1-20030102-C00007.CDX SYSTEM "US20030005103A1-20030102-C00007.CDX" NDATA CDX>
<!ENTITY US20030005103A1-20030102-C00007.MOL SYSTEM "US20030005103A1-20030102-C00007.MOL" NDATA MOL>
<!ENTITY US20030005103A1-20030102-C00007.TIF SYSTEM "US20030005103A1-20030102-C00007.TIF" NDATA TIF>
<!ENTITY US20030005103A1-20030102-D00000.TIF SYSTEM "US20030005103A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005103A1-20030102-D00001.TIF SYSTEM "US20030005103A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005103A1-20030102-D00002.TIF SYSTEM "US20030005103A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005103A1-20030102-D00003.TIF SYSTEM "US20030005103A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005103A1-20030102-D00004.TIF SYSTEM "US20030005103A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005103A1-20030102-D00005.TIF SYSTEM "US20030005103A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030005103A1-20030102-D00006.TIF SYSTEM "US20030005103A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030005103A1-20030102-D00007.TIF SYSTEM "US20030005103A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030005103A1-20030102-D00008.TIF SYSTEM "US20030005103A1-20030102-D00008.TIF" NDATA TIF>
<!ENTITY US20030005103A1-20030102-D00009.TIF SYSTEM "US20030005103A1-20030102-D00009.TIF" NDATA TIF>
<!ENTITY US20030005103A1-20030102-D00010.TIF SYSTEM "US20030005103A1-20030102-D00010.TIF" NDATA TIF>
<!ENTITY US20030005103A1-20030102-D00011.TIF SYSTEM "US20030005103A1-20030102-D00011.TIF" NDATA TIF>
<!ENTITY US20030005103A1-20030102-D00012.TIF SYSTEM "US20030005103A1-20030102-D00012.TIF" NDATA TIF>
<!ENTITY US20030005103A1-20030102-D00013.TIF SYSTEM "US20030005103A1-20030102-D00013.TIF" NDATA TIF>
<!ENTITY US20030005103A1-20030102-D00014.TIF SYSTEM "US20030005103A1-20030102-D00014.TIF" NDATA TIF>
<!ENTITY US20030005103A1-20030102-D00015.TIF SYSTEM "US20030005103A1-20030102-D00015.TIF" NDATA TIF>
<!ENTITY US20030005103A1-20030102-D00016.TIF SYSTEM "US20030005103A1-20030102-D00016.TIF" NDATA TIF>
<!ENTITY US20030005103A1-20030102-D00017.TIF SYSTEM "US20030005103A1-20030102-D00017.TIF" NDATA TIF>
<!ENTITY US20030005103A1-20030102-D00018.TIF SYSTEM "US20030005103A1-20030102-D00018.TIF" NDATA TIF>
<!ENTITY US20030005103A1-20030102-D00019.TIF SYSTEM "US20030005103A1-20030102-D00019.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005103</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10059770</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20020128</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F015/173</ipc>
</classification-ipc-primary>
<classification-ipc-secondary>
<ipc>G06F015/16</ipc>
</classification-ipc-secondary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>709</class>
<subclass>223000</subclass>
</uspc>
</classification-us-primary>
<classification-us-secondary>
<uspc>
<class>709</class>
<subclass>201000</subclass>
</uspc>
</classification-us-secondary>
</classification-us>
<title-of-invention>Cumulative status of arithmetic operations</title-of-invention>
</technical-information>
<continuity-data>
<continuations>
<continuation-of>
<parent-child>
<child>
<document-id>
<doc-number>10059770</doc-number>
<kind-code>A1</kind-code>
<document-date>20020128</document-date>
</document-id>
</child>
<parent>
<document-id>
<doc-number>09283662</doc-number>
<document-date>19990401</document-date>
<country-code>US</country-code>
</document-id>
</parent>
<parent-status>PENDING</parent-status>
</parent-child>
</continuation-of>
</continuations>
<continuations>
<continuation-of>
<parent-child>
<child>
<document-id>
<doc-number>09283662</doc-number>
<document-date>19990401</document-date>
<country-code>US</country-code>
</document-id>
</child>
<parent>
<document-id>
<doc-number>09097858</doc-number>
<document-date>19980615</document-date>
<country-code>US</country-code>
</document-id>
</parent>
<parent-status>GRANTED</parent-status>
<parent-patent>
<document-id>
<doc-number>6157955</doc-number>
<country-code>US</country-code>
</document-id>
</parent-patent>
</parent-child>
</continuation-of>
</continuations>
</continuity-data>
<inventors>
<first-named-inventor>
<name>
<given-name>Charles</given-name>
<middle-name>E.</middle-name>
<family-name>Narad</family-name>
</name>
<residence>
<residence-us>
<city>Santa Clara</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Kevin</given-name>
<family-name>Fall</family-name>
</name>
<residence>
<residence-us>
<city>Berkeley</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Neil</given-name>
<family-name>MacAvoy</family-name>
</name>
<residence>
<residence-us>
<city>Redwood City</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Pradip</given-name>
<family-name>Shankar</family-name>
</name>
<residence>
<residence-us>
<city>Fremont</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Leonard</given-name>
<middle-name>M.</middle-name>
<family-name>Rand</family-name>
</name>
<residence>
<residence-us>
<city>San Francisco</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Jerry</given-name>
<middle-name>J.</middle-name>
<family-name>Hall</family-name>
</name>
<residence>
<residence-us>
<city>Santa Clara</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>BLAKELY, SOKOLOFF, TAYLOR &amp; ZAFMAN LLP</name-1>
<name-2></name-2>
<address>
<address-1>Seventh Floor</address-1>
<address-2>12400 Wilshire Boulevard</address-2>
<city>Los Angeles</city>
<state>CA</state>
<postalcode>90025-1030</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">The present invention relates to a general-purpose programmable packet-processing platform for accelerating network infrastructure applications which have been structured so as to separate the stages of classification and action. Network packet classification, execution of actions upon those packets, management of buffer flow, encryption services, and management of Network Interface Controllers are accelerated through the use of a multiplicity of specialized modules. A language interface is defined for specifying both stateless and stateful classification of packets and to associate actions with classification results in order to efficiently utilize these specialized modules. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">FIELD OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> The present invention relates to computer networks and, more particularly, to a general purpose programmable platform for acceleration of network infrastructure applications. </paragraph>
</section>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> Computer networks have become a key part of the corporate infrastructure. Organizations have become increasingly dependent on intranets and the Internet and are demanding much greater levels of performance from their network infrastructure. The network infrastructure is being viewed: (1) as a competitive advantage; (2) as mission critical; (3) as a cost center. The infrastructure itself is transitioning from 10 Mb/s (megabits per second) capability to 100 Mb/s capability. Soon, infrastructure capable of 1 Gb/s (gigabits per second) will start appearing on server connections, trunks and backbones. As more and more computing equipment gets deployed, the number of nodes within an organization has also grown. There has been a doubling of users, and a ten-fold increase in the amount of traffic every year. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> Network infrastructure applications monitor, manage and manipulate network traffic in the fabric of computer networks. The high demand for network bandwidth and connectivity has led to tremendous complexity and performance requirements for this class of application. Traditional methods of dealing with these problems are no longer adequate. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> Several sophisticated software applications that provide solutions to the problems encountered by the network manager have emerged. The main areas for such applications are Security, Quality of Service (QoS)/Class of Service (CoS) and Network Management. Examples are: Firewalls; Intrusion Detection; Encryption; Virtual Private Networks (VPN); enabling services for ISPs (load balancing and such); Accounting; Web billing; Bandwidth Optimization; Service Level Management; Commerce; Application Level Management; Active Network Management. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> There are three conventional ways in which these applications are deployed: </paragraph>
<paragraph id="P-0006" lvl="2"><number>&lsqb;0006&rsqb;</number> (1) On general purpose computers. </paragraph>
<paragraph id="P-0007" lvl="2"><number>&lsqb;0007&rsqb;</number> (2) Using single function boxes. </paragraph>
<paragraph id="P-0008" lvl="2"><number>&lsqb;0008&rsqb;</number> (3) On switches and routers. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> It is instructive to examine the issues related to each of these deployment techniques. </paragraph>
</section>
<section>
<heading lvl="1">1. General Purpose Computers </heading>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> General Purpose computers, such as PCs running NT/Windows or workstations running Solaris/HP-UX, etc. are a common method for deploying network infrastructure applications. The typical configuration consists of two or more network interfaces each providing a connection to a network segment. The application runs on the main processor (Pentium/SPARC etc.) and communicates with the Network Interface Controller (NIC) card either through (typically) the socket interface or (in some cases) a specialized driver &ldquo;shim&rdquo; in the operating system (OS). The &ldquo;shim&rdquo; approach allows access to &ldquo;raw&rdquo; packets, which is necessary for many of the packet oriented applications. Applications that are end-point oriented, such as proxies can interface to the top of the IP (Internet Protocol) or other protocol stack. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> The advantages of running the application on a general purpose computer include: a full development environment; all he OS services (IPC, file system, memory management threads, I/O etc); low cost due to ubiquity of the platform; stability of the APIs; and assurance that performance will increase with each new generation of the general purpose computer technology. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> There are, however, many disadvantages of running the application on a general purpose computer. First, the I/O subsystem on a general purpose computer is optimized to provide a standard connection to a variety of peripherals at reasonable cost and, hence, reasonable performance. 32b/33 MHz PCI (&ldquo;Peripheral Connection Interface&rdquo;, the dominant I/O connection on common general purpose platforms today) has an effective bandwidth in the 50-75 MB/s range. While this is adequate for a few interfaces to high performance networks, it does not scale. Also, there is significant latency involved in accesses to the card. Therefore, any kind of non-pipelined activity results in a significant performance impact. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> Another disadvantage is that general purpose computers do not typically have good interrupt response time and context switch characteristics (as opposed to real-time operating systems used in many embedded applications). While this is not a problem for most computing environments, it is far from ideal for a network infrastructure application. Network infrastructure applications have to deal with network traffic operating at increasingly higher speeds and less time between packets. Small interrupt response times and small context switch times are very necessary. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> Another disadvantage is that general purpose platforms do not have any specialized hardware that assist with network infrastructure applications. With rare exception, none of the instruction sets for general purpose computers are optimized for network infrastructure applications. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> Another disadvantage is that, on a general purpose computer, typical network applications are built on top of the TCP/IP stack. This severely limits the packet processing capability of the application. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> Another disadvantage is that packets need to be pulled into the processor cache for processing. Cache fills and write backs become a severe bottleneck for high bandwidth networks. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> Finally, general purpose platforms use general purpose operating systems (OS&apos;s). These operating systems are generally not known for having quick reboots on power-cycle or other wiring-closet appliance oriented characteristics important for network infrastructure applications. </paragraph>
</section>
<section>
<heading lvl="1">2. Fixed-Function Appliances </heading>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> There are a couple of different ways to build single function appliances. The first way is to take a single board computer, add in a couple of NIC cards, and run an executive program on the main processor. This approach avoids some of the problems that a general purpose OS brings, but the performance is still limited to that of the base platform architecture (as described above). </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> A way to enhance the performance is to build special purpose hardware that performs functions required by the specific application very well. Therefore, from a performance standpoint, this can be a very good approach. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> There are, however, a couple of key issues with special function appliances. For example, they are not expandable by their very nature. If the network manager needs a new application, he/she will need to procure a new appliance. Contrast this with loading a new application on a desktop PC. In the case of a PC, a new appliance is not needed with every new application. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> Finally, if the solution is not completely custom, it is unlikely that the solution is scalable. Using a PC or other single board computer as the packet processor for each location at which that application is installed is not cost-effective. </paragraph>
</section>
<section>
<heading lvl="1">3. Switches and Routers </heading>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> Another approach is to deploy a scaled down version of an application on switches and routers which comprise the fabric of the network. The advantages of this approach are that: (1) no additional equipment is required for the deployment of the application; and (2) all of the segments in a network are visible at the switches. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> There are a number of problems with this approach. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> One disadvantage is that the processing power available at a switch or router is limited. Typically, this processing power is dedicated to the primary business of the switch/router&mdash;switching or routing. When significant applications have to be run on these switches or routers, their performance drops. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> Another disadvantage is that not all nodes in a network need to be managed in the same way. Putting significant processing power on all the ports of a switch or router is not cost-effective. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> Another disadvantage is that, even if processing power became so cheap as to be deployed freely at every port of a switch or router, a switch or router is optimized to move frames/packets from port to port. It is not optimized to process packets, for applications. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> Another disadvantage is that a typical switch or router does not provide the facilities that are necessary for the creation and deployment of sophisticated network infrastructure applications. The services required can be quite extensive and porting an application to run on a switch or router can be very difficult. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> Finally, replacing existing network switching equipment with new versions that support new applications can be difficult. It is much more effective to &ldquo;add applications&rdquo; to the network where needed. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> What is needed is an optimized platform for the deployment of sophisticated software applications in a network environment. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY </heading>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> The present invention relates to a general-purpose programmable packet processing platform for accelerating network infrastructure applications which have been structured so as to separate the stages of classification and action. A wide variety of embodiments of the present invention are possible and will be understood by those skilled in the art based on the present patent application. In certain embodiments, acceleration is achieved by one or more of the following: </paragraph>
<paragraph id="P-0031" lvl="2"><number>&lsqb;0031&rsqb;</number> Dividing the steps of packet processing into a multiplicity of pipeline stages and providing different functional units for different stages, thus allowing more processing time per packet and also providing concurrency in the processing of multiple packets, </paragraph>
<paragraph id="P-0032" lvl="2"><number>&lsqb;0032&rsqb;</number> Providing custom, specialized Classification Engines which are micro-programmed processors optimized for the various functions common in predicate analysis and table searches for these sort of applications, and are each used as pipeline stages in different flows, </paragraph>
<paragraph id="P-0033" lvl="2"><number>&lsqb;0033&rsqb;</number> Providing a general-purpose microprocessor for executing the arbitrary actions desired by these applications, </paragraph>
<paragraph id="P-0034" lvl="2"><number>&lsqb;0034&rsqb;</number> Providing a tightly-coupled encryption coprocessor to accelerate common network encryption functions, </paragraph>
<paragraph id="P-0035" lvl="2"><number>&lsqb;0035&rsqb;</number> Reducing or eliminating the need for the applications to examine the actual contents of the packet, thus minimizing the movement of packet data and the effects of that data movement on the processor&apos;s cache/bus/memory subsystem, and </paragraph>
<paragraph id="P-0036" lvl="2"><number>&lsqb;0036&rsqb;</number> Either eliminating or providing special hardware to accelerate system overheads common to embedded network applications run on general purpose platforms; this includes special support for managing buffer pools, for communication among units and the passing of buffers between them, and for managing the network interface MACs (media access controllers) without the need for heavyweight device driver programs. </paragraph>
<paragraph id="P-0037" lvl="2"><number>&lsqb;0037&rsqb;</number> Recognizing a common policy enforcement module for network infrastructure applications </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> Certain specific embodiments are implemented with one or more of the following features: </paragraph>
<paragraph id="P-0039" lvl="2"><number>&lsqb;0039&rsqb;</number> a policy enforcement module consisting of Classification and associated Action </paragraph>
<paragraph id="P-0040" lvl="2"><number>&lsqb;0040&rsqb;</number> both stateless classification and stateful classification which uses sets </paragraph>
<paragraph id="P-0041" lvl="2"><number>&lsqb;0041&rsqb;</number> Provision of a high level interface to packet level Classification and Action (Action and Classification Engine&mdash;ACE) </paragraph>
<paragraph id="P-0042" lvl="2"><number>&lsqb;0042&rsqb;</number> Provision of the high level interface within common operating environments </paragraph>
<paragraph id="P-0043" lvl="2"><number>&lsqb;0043&rsqb;</number> Policy can be changed dynamically </paragraph>
<paragraph id="P-0044" lvl="2"><number>&lsqb;0044&rsqb;</number> Application partitioned into an AP module running on the AP (Application Processor) and a PE (Policy Engine) module running on the PE </paragraph>
<paragraph id="P-0045" lvl="2"><number>&lsqb;0045&rsqb;</number> AP can run operating systems with full services to facilitate application development </paragraph>
<paragraph id="P-0046" lvl="2"><number>&lsqb;0046&rsqb;</number> PE functionality embodied as software running on AP as well as hardware and software running on the hardware PE </paragraph>
<paragraph id="P-0047" lvl="2"><number>&lsqb;0047&rsqb;</number> A language interface to describe Classification and to associate Actions with the results of the Classification </paragraph>
<paragraph id="P-0048" lvl="2"><number>&lsqb;0048&rsqb;</number> Language (NetBoost Classification Language-NCL) for Classification/Action </paragraph>
<paragraph id="P-0049" lvl="3"><number>&lsqb;0049&rsqb;</number> Object oriented (extensible) </paragraph>
<paragraph id="P-0050" lvl="3"><number>&lsqb;0050&rsqb;</number> Specific to Classification and hence very simple </paragraph>
<paragraph id="P-0051" lvl="3"><number>&lsqb;0051&rsqb;</number> Built-in intrinsics such as checksum </paragraph>
<paragraph id="P-0052" lvl="3"><number>&lsqb;0052&rsqb;</number> Language constructs make it easy to describe layered protocols and protocol fields </paragraph>
<paragraph id="P-0053" lvl="3"><number>&lsqb;0053&rsqb;</number> Rule construct to associate Classification and Actions </paragraph>
<paragraph id="P-0054" lvl="3"><number>&lsqb;0054&rsqb;</number> Predicate construct which is a function of packet contents at any layer of any protocol and/or of hash search results </paragraph>
<paragraph id="P-0055" lvl="3"><number>&lsqb;0055&rsqb;</number> Set construct to describe hash tables and multiple searches on the same hash table </paragraph>
<paragraph id="P-0056" lvl="2"><number>&lsqb;0056&rsqb;</number> Action code </paragraph>
<paragraph id="P-0057" lvl="3"><number>&lsqb;0057&rsqb;</number> Written in high level language </paragraph>
<paragraph id="P-0058" lvl="3"><number>&lsqb;0058&rsqb;</number> Complex packet processing possible </paragraph>
<paragraph id="P-0059" lvl="3"><number>&lsqb;0059&rsqb;</number> Can avail of Application Services Library (ASL) providing services useful for packet processing </paragraph>
<paragraph id="P-0060" lvl="3"><number>&lsqb;0060&rsqb;</number> ASL consists of packet management, memory management, time and event management, link level services, packet timestamp service, cryptographic services, communication services to AP module plus extensions </paragraph>
<paragraph id="P-0061" lvl="3"><number>&lsqb;0061&rsqb;</number> TCP/IP extensions include services such as Network Address Translation (NAT) for IP, TCP and UDP, Checksums, IP fragment reassembly and TCP segment reassembly </paragraph>
<paragraph id="P-0062" lvl="2"><number>&lsqb;0062&rsqb;</number> System components include </paragraph>
<paragraph id="P-0063" lvl="3"><number>&lsqb;0063&rsqb;</number> library implementing API (DLL under Windows NT) </paragraph>
<paragraph id="P-0064" lvl="3"><number>&lsqb;0064&rsqb;</number> a management process called Resolver </paragraph>
<paragraph id="P-0065" lvl="3"><number>&lsqb;0065&rsqb;</number> an incremental compiler for NCL </paragraph>
<paragraph id="P-0066" lvl="3"><number>&lsqb;0066&rsqb;</number> linker for NCL code </paragraph>
<paragraph id="P-0067" lvl="3"><number>&lsqb;0067&rsqb;</number> dynamic linker for action code </paragraph>
<paragraph id="P-0068" lvl="3"><number>&lsqb;0068&rsqb;</number> operating-system specific drivers which communicate with both hardware and software PEs </paragraph>
<paragraph id="P-0069" lvl="3"><number>&lsqb;0069&rsqb;</number> software Policy Engine that executes Classification and Action code </paragraph>
<paragraph id="P-0070" lvl="3"><number>&lsqb;0070&rsqb;</number> ASL for Action code </paragraph>
<paragraph id="P-0071" lvl="3"><number>&lsqb;0071&rsqb;</number> management services (Resolver and Plumber) for both application developer and the end-user </paragraph>
<paragraph id="P-0072" lvl="3"><number>&lsqb;0072&rsqb;</number> development environment for AP and PE code including compilers, and other software development tools familiar to those skilled in the art </paragraph>
<paragraph id="P-0073" lvl="2"><number>&lsqb;0073&rsqb;</number> ACE </paragraph>
<paragraph id="P-0074" lvl="3"><number>&lsqb;0074&rsqb;</number> C&plus;&plus; object which abstracts the packet processing associated with an application or sub-application </paragraph>
<paragraph id="P-0075" lvl="3"><number>&lsqb;0075&rsqb;</number> Provides a context for Classification and Action </paragraph>
<paragraph id="P-0076" lvl="3"><number>&lsqb;0076&rsqb;</number> Contains one or more Target objects, including drop and default, which represent packet destinations </paragraph>
<paragraph id="P-0077" lvl="3"><number>&lsqb;0077&rsqb;</number> Provides a context for upcalls and downcalls between the AP and the PE modules </paragraph>
<paragraph id="P-0078" lvl="3"><number>&lsqb;0078&rsqb;</number> Targets of an ACE are connected to other ACEs or interfaces using the Plumber (graphical and programmatic interfaces) to specify the serialization of ACE processing </paragraph>
<paragraph id="P-0079" lvl="2"><number>&lsqb;0079&rsqb;</number> Operating environment for action code </paragraph>
<paragraph id="P-0080" lvl="3"><number>&lsqb;0080&rsqb;</number> Invokes actions automatically when associated classification succeeds </paragraph>
<paragraph id="P-0081" lvl="3"><number>&lsqb;0081&rsqb;</number> Implements an ACE context </paragraph>
<paragraph id="P-0082" lvl="3"><number>&lsqb;0082&rsqb;</number> Low overhead (soft real-time) environment </paragraph>
<paragraph id="P-0083" lvl="3"><number>&lsqb;0083&rsqb;</number> Handles communication between AP and PE </paragraph>
<paragraph id="P-0084" lvl="3"><number>&lsqb;0084&rsqb;</number> Performs dynamic linking of action code when ACEs are loaded with new Classification code </paragraph>
<paragraph id="P-0085" lvl="2"><number>&lsqb;0085&rsqb;</number> Resolver </paragraph>
<paragraph id="P-0086" lvl="3"><number>&lsqb;0086&rsqb;</number> Maintains namespace of applications, interfaces and ACEs </paragraph>
<paragraph id="P-0087" lvl="3"><number>&lsqb;0087&rsqb;</number> Maps ACEs to PEs automatically </paragraph>
<paragraph id="P-0088" lvl="3"><number>&lsqb;0088&rsqb;</number> Contains the compiler for NCL and does dynamic compilation of NCL </paragraph>
<paragraph id="P-0089" lvl="3"><number>&lsqb;0089&rsqb;</number> Provides the interfaces for management of applications, ACEs and interfaces </paragraph>
<paragraph id="P-0090" lvl="2"><number>&lsqb;0090&rsqb;</number> Compiler for NCL </paragraph>
<paragraph id="P-0091" lvl="3"><number>&lsqb;0091&rsqb;</number> Generates code for multiple processors (AP and PE) </paragraph>
<paragraph id="P-0092" lvl="3"><number>&lsqb;0092&rsqb;</number> Allows incremental compilation of rules </paragraph>
<paragraph id="P-0093" lvl="2"><number>&lsqb;0093&rsqb;</number> Plumber </paragraph>
<paragraph id="P-0094" lvl="3"><number>&lsqb;0094&rsqb;</number> Allows interconnection of ACEs </paragraph>
<paragraph id="P-0095" lvl="3"><number>&lsqb;0095&rsqb;</number> Allow binding to interfaces </paragraph>
<paragraph id="P-0096" lvl="3"><number>&lsqb;0096&rsqb;</number> Supports secure remote access </paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0097" lvl="0"><number>&lsqb;0097&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a block diagram of a system in accordance with the present invention. </paragraph>
<paragraph id="P-0098" lvl="0"><number>&lsqb;0098&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a block diagram showing packet flow according to an embodiment of the present invention. </paragraph>
<paragraph id="P-0099" lvl="0"><number>&lsqb;0099&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a Policy Engine ASIC block diagram according to the present invention. </paragraph>
<paragraph id="P-0100" lvl="0"><number>&lsqb;0100&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a sample system-level block diagram related to the present invention. </paragraph>
<paragraph id="P-0101" lvl="0"><number>&lsqb;0101&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> shows a ring array in memory related to the present invention. </paragraph>
<paragraph id="P-0102" lvl="0"><number>&lsqb;0102&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> shows an RX Ring Structure related to the present invention. </paragraph>
<paragraph id="P-0103" lvl="0"><number>&lsqb;0103&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> shows a receive buffer format related to the present invention. </paragraph>
<paragraph id="P-0104" lvl="0"><number>&lsqb;0104&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> shows a TX Ring Structure related to the present invention. </paragraph>
<paragraph id="P-0105" lvl="0"><number>&lsqb;0105&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference> shows a transmit buffer format related to the present invention. </paragraph>
<paragraph id="P-0106" lvl="0"><number>&lsqb;0106&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10</cross-reference> shows a reclassify ring structure related to the present invention. </paragraph>
<paragraph id="P-0107" lvl="0"><number>&lsqb;0107&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 11</cross-reference> shows a Crypto Ring and COM&lsqb;4:0&rsqb; Rings Structure related to the present invention. </paragraph>
<paragraph id="P-0108" lvl="0"><number>&lsqb;0108&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 12</cross-reference> shows a DMA Ring Structure related to the present invention. </paragraph>
<paragraph id="P-0109" lvl="0"><number>&lsqb;0109&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 13</cross-reference> is a classification engine block diagram related to the present invention. </paragraph>
<paragraph id="P-0110" lvl="0"><number>&lsqb;0110&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 14</cross-reference> is a pipeline timing diagram for the classification engine related to the present invention. </paragraph>
<paragraph id="P-0111" lvl="0"><number>&lsqb;0111&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 15</cross-reference> is an application structure diagram related to the present invention. </paragraph>
<paragraph id="P-0112" lvl="0"><number>&lsqb;0112&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 16</cross-reference> is a diagram showing an Action Classification Engine (ACE) related to the present invention. </paragraph>
<paragraph id="P-0113" lvl="0"><number>&lsqb;0113&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 17</cross-reference> shows a cascade of ACEs related to the present invention. </paragraph>
<paragraph id="P-0114" lvl="0"><number>&lsqb;0114&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 18</cross-reference> shows a system architecture related to the present invention. </paragraph>
<paragraph id="P-0115" lvl="0"><number>&lsqb;0115&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 19</cross-reference> shows an application deploying six ACEs related to the present invention.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF PREFERRED EMBODIMENTS </heading>
<paragraph id="P-0116" lvl="0"><number>&lsqb;0116&rsqb;</number> Network infrastructure applications generally contain both time-critical and non-time-critical sections. The non-time-critical sections generally deal with setup, configuration, user interface and policy management. The time-critical sections generally deal with policy enforcement. The policy enforcement piece generally has to run at network speeds. The present invention pertains to an efficient architecture for policy enforcement that enables application of complex policy at network rates. </paragraph>
<paragraph id="P-0117" lvl="0"><number>&lsqb;0117&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> shows a Network Infrastructure Application, called Application <highlight><bold>2</bold></highlight>, being deployed on an Application Processor (AP) <highlight><bold>4</bold></highlight> running a standard operating system. The policy enforcement section of the Application <highlight><bold>2</bold></highlight>, called Wire Speed Policy <highlight><bold>3</bold></highlight> runs on the Policy Engine (PE) <highlight><bold>6</bold></highlight>. The Policy Engine <highlight><bold>6</bold></highlight> transforms the inbound Packet Stream <highlight><bold>8</bold></highlight> into the outbound Packet Stream <highlight><bold>10</bold></highlight> per the Wire Speed Policy <highlight><bold>3</bold></highlight>. Communications from the Application Processor <highlight><bold>4</bold></highlight> to the Policy Engine <highlight><bold>6</bold></highlight>, in addition to the Wire Speed Policy <highlight><bold>3</bold></highlight>, consists of control, policy modifications and packet data as desired the Application <highlight><bold>2</bold></highlight>. Communication from the Policy Engine <highlight><bold>3</bold></highlight> to the Application Processor <highlight><bold>4</bold></highlight> consists of status, exception conditions and packet data as desired by the Application <highlight><bold>2</bold></highlight>. </paragraph>
<paragraph id="P-0118" lvl="0"><number>&lsqb;0118&rsqb;</number> In a preferred embodiment of a Policy Engine (PE) according to the present invention, the PE provides a highly programmable platform for classifying network packets and implementing policy decisions about those packets at wire speed. Certain embodiments provide two Fast Ethernet ports and implement a pipelined dataflow architecture with store-and-forward. Packets are run through a Classification Engine (CE) which executes a programmed series of hardware assist operations such as chained field comparisons and generation of checksums and hash table pointers, then are handed to a microprocessor (&ldquo;Policy Processor&rdquo; or PP) for execution of policy decisions such as Pass, Drop, Enqueue/Delay, (de/en)capsulate, and (de/en)crypt based on the results from the CE. Some packets which require higher level processing may be sent to the host computer system (&ldquo;Application Processor&rdquo; or AP). (See <cross-reference target="DRAWINGS">FIG. 4</cross-reference>.) An optional cryptographic (&ldquo;Crypto&rdquo;) Processor is provided for accelerating such functions as encryption and key management. </paragraph>
<paragraph id="P-0119" lvl="0"><number>&lsqb;0119&rsqb;</number> Third-party applications such as firewalls, rate shaping, QoS/CoS, network management and others can be implemented to take advantage of this three-tiered approach to filtering packets. Support for easy encapsulation without copies combined with encryption support allows for VPNs (&ldquo;Virtual Private Networks&rdquo;) and other applications that require security services. </paragraph>
<paragraph id="P-0120" lvl="0"><number>&lsqb;0120&rsqb;</number> A large parity-protected synchronous DRAM (SDRAM) buffer memory is provided, along with a PCI interface that is used for communication with the host (AP) and potentially for peer-to-peer communication among Policy Engines, e.g. for applications which route and switch. </paragraph>
<paragraph id="P-0121" lvl="0"><number>&lsqb;0121&rsqb;</number> In certain embodiments the Policy Engine ASIC can be used on a PCI card both for application software development and for use in a PC or workstation as a two interface product, and can also be used in a multiple-segment appliance with a plurality of PE&apos;s along with an embedded Application Processor for a stand-alone product. </paragraph>
<paragraph id="P-0122" lvl="0"><number>&lsqb;0122&rsqb;</number> In certain embodiments, when used in an appliance, the PE&apos;s reside on PCI segments connected together through a plurality of PCI-to-PCI bridges which connect to the host PCI bus on the Application Processor. The PCI bus is 64-bit for all agents in order to provide sufficient bandwidth for applications which route or switch. </paragraph>
<paragraph id="P-0123" lvl="0"><number>&lsqb;0123&rsqb;</number> A sample system level block diagram is shown in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>. </paragraph>
<paragraph id="P-0124" lvl="0"><number>&lsqb;0124&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> shows an application processor <highlight><bold>302</bold></highlight> which contains a host interface <highlight><bold>304</bold></highlight> to a PCI bus <highlight><bold>324</bold></highlight>. Fanout of the PCI bus <highlight><bold>324</bold></highlight> to a larger number of loads is accomplished with PCI-to-PCI Bridge devices <highlight><bold>306</bold></highlight>, <highlight><bold>308</bold></highlight>, <highlight><bold>310</bold></highlight>, and <highlight><bold>312</bold></highlight>; each of those controls an isolated segment on a &ldquo;child&rdquo; PCI bus <highlight><bold>326</bold></highlight>, <highlight><bold>328</bold></highlight>, <highlight><bold>330</bold></highlight>, and <highlight><bold>332</bold></highlight> respectively. On three of these isolated segments <highlight><bold>326</bold></highlight>, <highlight><bold>328</bold></highlight>, and <highlight><bold>330</bold></highlight> is a number of Policy Engines <highlight><bold>322</bold></highlight>; each Policy Engine <highlight><bold>322</bold></highlight> connects to two Ethernet ports <highlight><bold>320</bold></highlight> which connects the Policy Engine <highlight><bold>322</bold></highlight> to a network segment. </paragraph>
<paragraph id="P-0125" lvl="0"><number>&lsqb;0125&rsqb;</number> One of the PCI-to-PCI Bridges <highlight><bold>312</bold></highlight> controls child PCI bus <highlight><bold>322</bold></highlight>, which provides the Application Processor <highlight><bold>302</bold></highlight> with connection to standard I/O devices <highlight><bold>314</bold></highlight> and optionally to PCI expansion slots <highlight><bold>316</bold></highlight> into which additional PCI devices can be connected. </paragraph>
<paragraph id="P-0126" lvl="0"><number>&lsqb;0126&rsqb;</number> In a smaller configuration of the preferred embodiment of the invention the number of Policy Engines <highlight><bold>322</bold></highlight> does not exceed the maximum load allowed on a PCI bus <highlight><bold>324</bold></highlight>; in that case the PCI-to-PCI bridges <highlight><bold>306</bold></highlight>, <highlight><bold>308</bold></highlight>, and <highlight><bold>310</bold></highlight> are eliminated and up to four Policy Engines <highlight><bold>322</bold></highlight> are connected directly to the host PCI bus <highlight><bold>324</bold></highlight>, each connecting also to two Ethernet ports <highlight><bold>320</bold></highlight>. This smaller configuration may still have the PCI-to-PCI Bridge <highlight><bold>312</bold></highlight> present to isolate Local I/O <highlight><bold>314</bold></highlight> and expansion slots <highlight><bold>316</bold></highlight> from the PCI bus <highlight><bold>324</bold></highlight>, or the Bridge <highlight><bold>312</bold></highlight> may also be eliminated and the devices <highlight><bold>314</bold></highlight> and expansion <highlight><bold>316</bold></highlight> may also be connected directly to the host PCI bus <highlight><bold>324</bold></highlight>. </paragraph>
</section>
<section>
<heading lvl="1">I. Packet Flow </heading>
<paragraph id="P-0127" lvl="0"><number>&lsqb;0127&rsqb;</number> In certain embodiments, the PE utilizes two Fast Ethernet MAC&apos;s (Media Access Controllers) with IEEE 802.3 standard Media Independent Interface (&ldquo;MII&rdquo;) connections to external physical media (PHY) devices which attach to Ethernet segments. Each Ethernet MAC receives packets into buffers addressed by buffer pointers obtained from a producer-consumer ring and then passes the buffer (that is, passes the buffer pointer) to a Classification Engine for processing, and from there to the Policy Processor. The &ldquo;buffer pointer&rdquo; is a data structure comprising the address of a buffer and a software-assigned &ldquo;tag&rdquo; field containing other information about that buffer. The &ldquo;buffer pointer&rdquo; is a fundamental unit of communication among the various hardware and software modules comprising a PE. From the PP, there are many paths the packet can take, depending on what the application(s) running on the PP decide is the proper disposition of that packet. It can be transmitted, sent to Crypto, delayed in memory, passed through a Classification Engine again for further processing, or copied from the PE&apos;s memory over the PCI bus to the host&apos;s memory or to a peer device&apos;s memory, using the DMA engine. The PP may also gather statistics on that packet into records in a hash table or in general memory. A pointer to the buffer containing both the packet and data structures describing that packet is passed around among the various modules. </paragraph>
<paragraph id="P-0128" lvl="0"><number>&lsqb;0128&rsqb;</number> The PP may choose to drop a packet, to modify the contents of the packet, or to forward the packet to the AP or to a different network segment over the PCI Bus (e.g. for routing.) The AP or PP can create packets of its own for transmission. A 3rd-party NIC (Network Interface Card) on the PCIbus can use the PE memory for receiving packets, and the PP and AP can then cooperate to feed those packets into the classification stream, effectively providing acceleration for packets from arbitrary networks. When doing so, adjacent 2 KB buffers can be concatenated to provide buffers of any size needed for a particular protocol. </paragraph>
<paragraph id="P-0129" lvl="0"><number>&lsqb;0129&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> illustrates packet flow according to certain embodiments of the present invention. Each box represents a process which is applied to a packet buffer and/or the contents of a packet buffer <highlight><bold>620</bold></highlight> as shown in <cross-reference target="DRAWINGS">FIG. 7</cross-reference>. The buffer management process involves buffer allocation <highlight><bold>102</bold></highlight> and the recovery of retired buffers <highlight><bold>118</bold></highlight>. When buffer allocation <highlight><bold>102</bold></highlight> into an RX Ring <highlight><bold>402</bold></highlight> or <highlight><bold>404</bold></highlight> occurs, the Policy Processor <highlight><bold>244</bold></highlight> enqueues a buffer pointer into the RX Ring <highlight><bold>402</bold></highlight> or <highlight><bold>404</bold></highlight> and thus allocates the buffer <highlight><bold>620</bold></highlight> to the receive MAC <highlight><bold>216</bold></highlight> or <highlight><bold>230</bold></highlight>, respectively. Upon receiving a packet, the RX MAC controller <highlight><bold>220</bold></highlight> or <highlight><bold>228</bold></highlight> uses the buffer pointer at the entry in the RX ring structure of <cross-reference target="DRAWINGS">FIG. 6</cross-reference> which is pointed to by MFILL <highlight><bold>516</bold></highlight> to identify a 2 KB section of memory <highlight><bold>260</bold></highlight> that it can use to store the newly received packet. This process of receiving a packet and placing it into a buffer <highlight><bold>620</bold></highlight> is represented by physical receive <highlight><bold>104</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>. </paragraph>
<paragraph id="P-0130" lvl="0"><number>&lsqb;0130&rsqb;</number> The RX MAC controller <highlight><bold>220</bold></highlight> or <highlight><bold>228</bold></highlight> increments the MFILL pointer <highlight><bold>516</bold></highlight> modulo ring size to signal that the buffer <highlight><bold>620</bold></highlight> whose pointer is in the RX Ring <highlight><bold>402</bold></highlight> or <highlight><bold>404</bold></highlight> has been filled with a new packet <highlight><bold>610</bold></highlight> and <highlight><bold>612</bold></highlight> plus receive status <highlight><bold>600</bold></highlight> and <highlight><bold>602</bold></highlight>. The Ring Translation Unit <highlight><bold>264</bold></highlight> detects a difference between MFILL <highlight><bold>516</bold></highlight> and MCCONS <highlight><bold>514</bold></highlight> and signals to the classification engine <highlight><bold>238</bold></highlight> or <highlight><bold>242</bold></highlight>, respectively, for RX Ring <highlight><bold>402</bold></highlight> or <highlight><bold>404</bold></highlight>, that a newly received packet is ready for processing. The Classification Engine <highlight><bold>238</bold></highlight> or <highlight><bold>242</bold></highlight> applies Classification <highlight><bold>106</bold></highlight> to that packet and creates a description of the packet which is placed in the packet buffer software area <highlight><bold>614</bold></highlight>, then increments MCCONS <highlight><bold>514</bold></highlight> to indicate that it has completed classification <highlight><bold>106</bold></highlight> of that packet. The Ring Translation Unit <highlight><bold>264</bold></highlight> detects a difference between MCCONS <highlight><bold>514</bold></highlight> and MPCONS <highlight><bold>512</bold></highlight> and signals to the Policy Processor <highlight><bold>244</bold></highlight> that a classified packet is ready for action processing <highlight><bold>108</bold></highlight>. </paragraph>
<paragraph id="P-0131" lvl="0"><number>&lsqb;0131&rsqb;</number> The Policy Processor <highlight><bold>244</bold></highlight> obtains the buffer pointer from the ring location pointed to by <highlight><bold>512</bold></highlight> by dequeueing that pointer from the RX Ring <highlight><bold>402</bold></highlight> or <highlight><bold>404</bold></highlight>, and executes application-specific action code <highlight><bold>108</bold></highlight> to determine the disposition of the packet. The action code <highlight><bold>108</bold></highlight> may choose to send the packet to an Ethernet Transmit MAC <highlight><bold>218</bold></highlight> or <highlight><bold>234</bold></highlight> by enqueueing the buffer pointer on a TX Ring <highlight><bold>406</bold></highlight> or <highlight><bold>408</bold></highlight>, respectively; the packet may or may not have been modified by the action code <highlight><bold>108</bold></highlight> prior to this. Alternatively the action code <highlight><bold>108</bold></highlight> may choose to send the packet to the attached cryptographic processor (Crypto) <highlight><bold>246</bold></highlight> for encryption, decryption, compression, decompression, security key management, parsing of IPSEC headers, or other associated functions; this entire bundle of functions is described by Crypto <highlight><bold>112</bold></highlight>. Alternatively the action code <highlight><bold>108</bold></highlight> may choose to copy the packet to a PCI peer <highlight><bold>322</bold></highlight> or <highlight><bold>314</bold></highlight> or <highlight><bold>316</bold></highlight>, or to the host memory <highlight><bold>330</bold></highlight>, both paths being accomplished by the process <highlight><bold>114</bold></highlight> of creating a DMA descriptor as shown in Table 3 and then enqueuing the pointer to that descriptor into DMA Ring <highlight><bold>418</bold></highlight> by writing that pointer to DMA_PROD <highlight><bold>1116</bold></highlight>, which triggers the DMA Unit <highlight><bold>210</bold></highlight> to initiate a transfer Alternatively the action code <highlight><bold>118</bold></highlight> can choose to temporarily enqueue the packet for delay <highlight><bold>110</bold></highlight> in memory <highlight><bold>260</bold></highlight> that is managed by the action code <highlight><bold>118</bold></highlight>. Finally, the action code <highlight><bold>108</bold></highlight> can choose to send a packet for further classification <highlight><bold>106</bold></highlight> on any of the Classification Engines <highlight><bold>208</bold></highlight>, <highlight><bold>212</bold></highlight>, <highlight><bold>238</bold></highlight>, or <highlight><bold>242</bold></highlight>, either because the packet has been modified or because there is additional classification which can be run on the packet which the action code <highlight><bold>108</bold></highlight> can command the Classification process <highlight><bold>106</bold></highlight> to execute via flags in the RX Status Word <highlight><bold>600</bold></highlight>, through the buffer&apos;s software area <highlight><bold>614</bold></highlight>, or by use of tag bits in the 32-bit buffer pointer reserved for that use. </paragraph>
<paragraph id="P-0132" lvl="0"><number>&lsqb;0132&rsqb;</number> Packets can arrive at the classification process <highlight><bold>106</bold></highlight> from additional sources besides physical receive <highlight><bold>104</bold></highlight>. Classification <highlight><bold>106</bold></highlight> may receive a packet from the output of the Crypto processing <highlight><bold>112</bold></highlight>, from the Application Processor <highlight><bold>302</bold></highlight> or from a PCI peer <highlight><bold>322</bold></highlight> or <highlight><bold>314</bold></highlight> or <highlight><bold>316</bold></highlight>, or from the application code <highlight><bold>108</bold></highlight>. </paragraph>
<paragraph id="P-0133" lvl="0"><number>&lsqb;0133&rsqb;</number> Packets can arrive at the action code <highlight><bold>108</bold></highlight> from classification <highlight><bold>106</bold></highlight>, from the Application Processor <highlight><bold>302</bold></highlight>, from a PCI peer <highlight><bold>322</bold></highlight> or <highlight><bold>314</bold></highlight> or <highlight><bold>316</bold></highlight>, from the output of the Crypto processing <highlight><bold>112</bold></highlight>, and from a delay queue <highlight><bold>110</bold></highlight>. Additionally the action code <highlight><bold>108</bold></highlight> can create a packet. The disposition options for these packets are the same as those described for the receive path, above. </paragraph>
<paragraph id="P-0134" lvl="0"><number>&lsqb;0134&rsqb;</number> The Crypto processing <highlight><bold>112</bold></highlight> can receive a packet from the Policy Processor <highlight><bold>244</bold></highlight> as described above. The Application Processor <highlight><bold>302</bold></highlight> or a PCI peer <highlight><bold>322</bold></highlight> or <highlight><bold>314</bold></highlight> or <highlight><bold>316</bold></highlight> can also enqueue the pointer to a buffer onto the Crypto Ring <highlight><bold>420</bold></highlight> to schedule that packet for Crypto processing <highlight><bold>112</bold></highlight>. </paragraph>
<paragraph id="P-0135" lvl="0"><number>&lsqb;0135&rsqb;</number> The TX MAC <highlight><bold>218</bold></highlight> or <highlight><bold>234</bold></highlight> transmits packets whose buffer pointer have been enqueued on the TX Ring <highlight><bold>406</bold></highlight> or <highlight><bold>408</bold></highlight>, respectively. Those pointers may have been enqueued by the action code <highlight><bold>106</bold></highlight> running on the Policy Processor <highlight><bold>244</bold></highlight>, by the Crypto processing <highlight><bold>112</bold></highlight>, by the Application Processor <highlight><bold>302</bold></highlight>, or by a PCI peer <highlight><bold>322</bold></highlight> or <highlight><bold>314</bold></highlight> or <highlight><bold>316</bold></highlight>. When the TX MAC controller <highlight><bold>222</bold></highlight> or <highlight><bold>232</bold></highlight> has retired a buffer either by successfully transmitting the packet it contains, or abandoning the transmit due to transmit termination conditions, it will optionally write back TX status <highlight><bold>806</bold></highlight> and TX Timestamp <highlight><bold>808</bold></highlight> if programmed to do so, then will increment MTCONS <highlight><bold>714</bold></highlight> to indicate that this buffer <highlight><bold>840</bold></highlight> has been retired. The Ring Translation Unit <highlight><bold>264</bold></highlight> detects that there is a difference between MTCONS <highlight><bold>714</bold></highlight> and MTRECOV <highlight><bold>712</bold></highlight> and signals to the Policy Processor <highlight><bold>244</bold></highlight> that the TX Ring <highlight><bold>406</bold></highlight> or <highlight><bold>408</bold></highlight> has at least one retired buffer to recover; this triggers the buffer recovery process <highlight><bold>118</bold></highlight>, which will dequeue the buffer pointer from the TX ring <highlight><bold>406</bold></highlight> or <highlight><bold>408</bold></highlight> and either send the buffer pointer to Buffer Allocation <highlight><bold>102</bold></highlight> or will add the recovered buffer to a software-managed free list for later use by Buffer Allocation <highlight><bold>102</bold></highlight>. </paragraph>
<paragraph id="P-0136" lvl="0"><number>&lsqb;0136&rsqb;</number> It is also possible for a device in the PCI expansion slot <highlight><bold>316</bold></highlight> to play the role defined for the attached Crypto processor <highlight><bold>246</bold></highlight> performing crypto processing <highlight><bold>112</bold></highlight> via DMA <highlight><bold>114</bold></highlight> in this flow. </paragraph>
<paragraph id="P-0137" lvl="7"><number>&lsqb;0137&rsqb;</number> 1. Communication and Buffer Management </paragraph>
<paragraph id="P-0138" lvl="0"><number>&lsqb;0138&rsqb;</number> In certain embodiments, the buffer memory consists of 16 to 128 MB of parity-protected SDRAM. It is used for packet buffers, for code and data structures for the microprocessor, as a staging area for Classification Engine microcode loading, and for buffers used in communicating with the AP and other PCI agents. The following uses of memory are defined by the architecture of the Policy Engine: </paragraph>
<paragraph id="P-0139" lvl="2"><number>&lsqb;0139&rsqb;</number> Buffer Pointer rings for RX_MAC_A RX_MAC_B, TX_MAC_A, TX_MAC_B (where &ldquo;RX&rdquo; denotes &ldquo;receive&rdquo;, &ldquo;TX&rdquo; denotes &ldquo;transmit&rdquo;, and &ldquo;_A&rdquo; and &ldquo;_B&rdquo; indicate which instance of the MAC is being described.) </paragraph>
<paragraph id="P-0140" lvl="2"><number>&lsqb;0140&rsqb;</number> A pool of 2 KB-aligned buffers used for holding packets that are being processed in this chip as well as information about those packets; larger buffers can be created by concatenating these 2 KB buffers if needed for processing larger packets from other media. </paragraph>
<paragraph id="P-0141" lvl="2"><number>&lsqb;0141&rsqb;</number> &ldquo;Reclassification&rdquo; pointer rings for each of the four Classification Engines; these are used to schedule packets for processing on that CE, when the classification of the packet is being scheduled by an agent other than an RX MAC. </paragraph>
<paragraph id="P-0142" lvl="2"><number>&lsqb;0142&rsqb;</number> A ring containing pointers to DMA descriptors used to schedule transfers using the DMA engine; data copies between PCI and memory in either direction are scheduled by enqueuing descriptor pointers on this ring </paragraph>
<paragraph id="P-0143" lvl="2"><number>&lsqb;0143&rsqb;</number> A pool of memory allocated for use as DMA descriptors. </paragraph>
<paragraph id="P-0144" lvl="2"><number>&lsqb;0144&rsqb;</number> A pointer ring for scheduling packets for processing on the Crypto unit. </paragraph>
<paragraph id="P-0145" lvl="2"><number>&lsqb;0145&rsqb;</number> An area that contains instructions for the microprocessor, including the boot sequence </paragraph>
<paragraph id="P-0146" lvl="2"><number>&lsqb;0146&rsqb;</number> An area for staging microcode to be loaded into the control store of the four Classification Engines. </paragraph>
<paragraph id="P-0147" lvl="2"><number>&lsqb;0147&rsqb;</number> Page tables for the Policy Processor MMU </paragraph>
<paragraph id="P-0148" lvl="2"><number>&lsqb;0148&rsqb;</number> 16 words dedicated to mailbox communications; writes to these words from the PCIbus also set the corresponding mailbox bit in the mailbox status register which signals to the processor that the indicated mailbox has a new message. </paragraph>
<paragraph id="P-0149" lvl="2"><number>&lsqb;0149&rsqb;</number> A pool of 2 KB buffers that belong to the AP and are used for scheduling transmits of packets that have been handed to the AP for processing or that originate at the AP. In addition to these uses, parts of the memory may be allocated to the applications running on the PP for storing data such as local variables, counters, hash tables and the data structures they contain, AP to PP and PP to AP application-level communications areas, external coprocessor communication and transmit buffers, etc. </paragraph>
<paragraph id="P-0150" lvl="0"><number>&lsqb;0150&rsqb;</number> The Policy Engine takes advantage of the fact that buffers are 2 KB-aligned, and has the hardware ignore the lower 11 bits of each buffer base pointer, thus enabling software to use those pointer bits as tags. </paragraph>
<paragraph id="P-0151" lvl="0"><number>&lsqb;0151&rsqb;</number> A simple and lightweight mechanism for buffer allocation and recovery is provided. Hardware support for atomic enqueue and dequeue of buffers through producer-consumer rings, along with detection of completed (retired) buffers enables buffer management in only a few instructions. In the realtime executive loop run on the PP, a short section is devoted to reclaimation of free buffers into the free list from those rings which indicate to the PP that they have retired buffers available for recovery. The RX pools of allocated, empty buffers maintained in the RX Rings can be replenished from the freelist each time a filled, classified RX buffer is dequeued from that ring, thus maintaining the pool size. A simple linked list of buffers or other method well-known to those versed in the art can be used to implement a software-managed freelist from which to feed the pools. </paragraph>
<paragraph id="P-0152" lvl="0"><number>&lsqb;0152&rsqb;</number> In order to support atomic enqueueing/dequeueing of buffer pointers and of DMA descriptor pointers, a standard memory-based producer/consumer ring structure is supported in hardware for many purposes (as represented by the circle-with-arrow symbols in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>). In most cases one or more of the consumers is also a producer for the next consumer, so the rings have a series of index pointers which chase each other in sequence; for example the MAC RX Rings have a Produce Pointer for the allocation of empty buffers, a MAC FILL Pointer for the RXMAC to consume empty buffers and produce full buffers, a Classification Engine Consume Pointer for the CE to consume freshly received buffers and to produce classified buffers, and a Policy Processor Consume Pointer for the PP to consume classified packets as shown in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>. The leading producer accesses the ring through an &ldquo;enqueue&rdquo; register, and the end consumer accesses the ring through a &ldquo;dequeue&rdquo; register, obviating the need for mutexes (mutual exclusion locks) or (slow) memory accesses in managing shared ring structures. Interim consumer-producers fetch a buffer pointer through a ring index, then increment that index later to signal that they have finished processing the referenced buffer and that it is available for the next consumer. </paragraph>
<paragraph id="P-0153" lvl="0"><number>&lsqb;0153&rsqb;</number> This serialized multiple-producer/multiple-consumer ring structure allows for one ring to support a compelled series of steps with much less hardware than would be required to support a separate FIFO between each producer and consumer, and eliminates the need for each consumer-producer to write pointers to the next ring; every cycle saved in a real-time system such as this can be significant. </paragraph>
<paragraph id="P-0154" lvl="0"><number>&lsqb;0154&rsqb;</number> Hardware detects when there is a difference between a producer&apos;s ring index and the ring index for the next consumer in that communication sequence, and signals to the consumer that there is at least one buffer pointer in its ring for processing; thus the presence of work to do wakes up the associated unit, implementing a dataflow architecture through the use of hardware-managed rings. </paragraph>
<paragraph id="P-0155" lvl="0"><number>&lsqb;0155&rsqb;</number> Ring overflow, underflow, and threshold conditions are detected and reported to the ring users and the PP as appropriate. </paragraph>
<paragraph id="P-0156" lvl="7"><number>&lsqb;0156&rsqb;</number> 2. Memory and Ring Translated Memory </paragraph>
<paragraph id="P-0157" lvl="0"><number>&lsqb;0157&rsqb;</number> 2.1 Memory </paragraph>
<paragraph id="P-0158" lvl="0"><number>&lsqb;0158&rsqb;</number> Main memory in the preferred embodiment consists of up to 128 MB of synchronous DRAM (SDRAM) in two DIMM&apos;s (Dual In-line Memory Modules) or one double-sided DIMM. Detecting the presence of the DIMMs and their attributes uses the standard Serial Presence Detect interface, using the SPD register to manage accesses to the serial PROM. (The same interface is used to access a serial PROM containing MAC addresses, ASIC configuration parameters, and manufacturing information.) Depending on the size of DIMM&apos;s installed, memory might not be contiguous; each socket is allocated 64 MB of address space, and will alias within that 64 MB space if a smaller DIMM is used. Alternatively one 128 MB DIMM is supported, in one socket only. </paragraph>
<paragraph id="P-0159" lvl="7"><number>&lsqb;0159&rsqb;</number> 2.2 Ring Translated Memory </paragraph>
<paragraph id="P-0160" lvl="0"><number>&lsqb;0160&rsqb;</number> The pointer rings associated with various units are simply a region of memory which is accessed through a translation unit. The translation unit implements the rings as a base register (which is used to assign an arbitrary memory location to be used for the rings) plus a set of index registers which each point to an array entry relative to the base address. Reads and writes to the address associated with a particular index register actually access memory at the ring entry pointed to by that index register; that is, such accesses are indirect. Some index registers are automatically incremented after an access (for atomic enqueue and dequeue operations), issued by leading producers or end consumers while others are incremented specifically by their owner (generally an interim consumer-producer) to indicate that the referenced buffer has been processed and is now available for the next consumer down the chain. Pairs of pointers have a producer-consumer relationship, and a difference between them indicates to the consumer that there is work to do; that difference is detected in hardware and is signaled to the appropriate unit. </paragraph>
<paragraph id="P-0161" lvl="0"><number>&lsqb;0161&rsqb;</number> There are 15 rings in the preferred embodiment, each 4 KB in size (1K entries of 4 bytes each); the 60 KB array of 15 rings resides on a 64 KB boundary in memory. The base of this array is pointed to by the Ring Base Register. The rings themselves are not accessed directly; instead they appear to the users as a set of &ldquo;registers&rdquo; which are read or written to access the entries in memory that are pointed to by the associated index register. For addressing purposes each ring is assigned a number, which is used as an index both into the array in memory and into the Ring Translation Unit (RTU) register map. </paragraph>
<paragraph id="P-0162" lvl="0"><number>&lsqb;0162&rsqb;</number> Writes to a ring will cause the data (which is generally a buffer pointer, or in the case of the DMA Ring, a pointer to a DMA descriptor) to be stored at the location in memory pointed to by &lsqb;(RingArray&lsqb;Ring &num;&rsqb;)&plus;(RTU index register used)&rsqb;, and then that index register is incremented modulo ring size. Reads from a ring will return the data (buffer pointer or descriptor pointer) pointed to by &lsqb;(RingArray&lsqb;Ring &num;&rsqb;)&plus;(RTU index register used)&rsqb;; if that register is an auto-increment register then it will increment modulo ring size after the read operation. A read attempted via a consumer index register which matches its corresponding produce pointer (that is, there was no work to do) will return zero and the index pointer will not increment. Registers which are not auto-increment are incremented explicitly by that register&apos;s owner when the referenced buffer has been processed; the increment is done via a hardware signal, not by register access. </paragraph>
<paragraph id="P-0163" lvl="0"><number>&lsqb;0163&rsqb;</number> Ring underflow/overflow and near-empty/near-full threshold status (as appropriate) are reported through the CRISIS register to the PP and the AP. </paragraph>
</section>
<section>
<heading lvl="1">II. Policy Engine </heading>
<paragraph id="P-0164" lvl="0"><number>&lsqb;0164&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> shows a Policy Engine ASIC block diagram according to certain embodiments of the present invention. </paragraph>
<paragraph id="P-0165" lvl="0"><number>&lsqb;0165&rsqb;</number> The ASIC <highlight><bold>290</bold></highlight> contains an interface <highlight><bold>206</bold></highlight> to an external RISC microprocessor which is known as the Policy Processor <highlight><bold>244</bold></highlight>. Internal to the RISC Processor Interface <highlight><bold>206</bold></highlight> are registers for all units in the ASIC <highlight><bold>290</bold></highlight> to signal status to the RISC Processor <highlight><bold>244</bold></highlight>. </paragraph>
<paragraph id="P-0166" lvl="0"><number>&lsqb;0166&rsqb;</number> There is an interface <highlight><bold>204</bold></highlight> to a host PCI Bus <highlight><bold>280</bold></highlight> which is used for movement of data into and out of the memory <highlight><bold>260</bold></highlight>, and is also used for external access to control registers throughout the ASIC <highlight><bold>290</bold></highlight>. The DMA unit <highlight><bold>210</bold></highlight> is the Policy Engine <highlight><bold>322</bold></highlight>&apos;s agent for master activity on the PCI bus <highlight><bold>280</bold></highlight> Transactions by DMA <highlight><bold>210</bold></highlight> are scheduled through the DMA Ring <highlight><bold>418</bold></highlight>. The Memory Controller <highlight><bold>240</bold></highlight> receives memory access requests from all agents in the ASIC and translates them to transactions sent to the Synchronous DRAM Memory <highlight><bold>260</bold></highlight>. Addresses issued to the Memory Controller <highlight><bold>240</bold></highlight> will be translated by the Ring Translation Unit <highlight><bold>264</bold></highlight> if address bit <highlight><bold>27</bold></highlight> is a &lsquo;1&rsquo;, or will be used untranslated by the memory controller <highlight><bold>240</bold></highlight> to access memory <highlight><bold>260</bold></highlight> if address bit <highlight><bold>27</bold></highlight> is a &lsquo;0&rsquo;. Untranslated addresses are also examined by the Mailbox Unit <highlight><bold>262</bold></highlight> and if the address matches the memory address of one of the mailboxes the associated mailbox status bit is set if the transaction is a write, or cleared if the transaction is a read In addition to the dedicated rings in the Ring Translation Unit <highlight><bold>264</bold></highlight> which are described here, the Ring Translation Unit also implements <highlight><bold>5</bold></highlight> general-purpose communications rings COM&lsqb;4:0&rsqb; <highlight><bold>226</bold></highlight> which software can allocate as desired. The memory controller <highlight><bold>240</bold></highlight> also implements an interface to serial PROMs <highlight><bold>270</bold></highlight> for obtaining information about memory configuration, MAC addresses, board manufacturing information, Crypto Daughtercard identification and other information. </paragraph>
<paragraph id="P-0167" lvl="0"><number>&lsqb;0167&rsqb;</number> The ASIC contains two Fast Ethernet MACs MAC_A and MAC_B. Each contains a receive MAC <highlight><bold>216</bold></highlight> or <highlight><bold>230</bold></highlight>, respectively, with associated control logic and an interface to the memory unit <highlight><bold>220</bold></highlight> or <highlight><bold>228</bold></highlight>, respectively; and a transmit MAC <highlight><bold>218</bold></highlight> or <highlight><bold>234</bold></highlight> respectively with associated control logic and an interface to the memory unit <highlight><bold>222</bold></highlight> or <highlight><bold>232</bold></highlight>, respectively. Also associated with each MAC is an RMON counter unit <highlight><bold>224</bold></highlight> or <highlight><bold>236</bold></highlight>, respectively, which counts certain aspects of all packets received and transmitted in support of providing the Ethernet MIB as defined in Internet Engineering Task Force (IETF) standard RFC 1213 and related RFC&apos;s. </paragraph>
<paragraph id="P-0168" lvl="0"><number>&lsqb;0168&rsqb;</number> RX_A Ring <highlight><bold>402</bold></highlight> is used by RX MAC_A controller <highlight><bold>220</bold></highlight> to obtain empty buffers and to pass filled buffers to Classification Engine <highlight><bold>238</bold></highlight>. Similarly RX_B Ring <highlight><bold>404</bold></highlight> is used by RX MAC_B controller <highlight><bold>228</bold></highlight> to obtain empty buffers and to pass filled buffers to Classification Engine <highlight><bold>242</bold></highlight>. TX_A Ring <highlight><bold>406</bold></highlight> is used to schedule packets for transmission on TX MAC_A <highlight><bold>218</bold></highlight>, and TX_B Ring <highlight><bold>408</bold></highlight> is used to schedule packets for transmission on TX MAC_B <highlight><bold>234</bold></highlight>. </paragraph>
<paragraph id="P-0169" lvl="0"><number>&lsqb;0169&rsqb;</number> There are four Classification Engines <highlight><bold>208</bold></highlight>, <highlight><bold>212</bold></highlight>, <highlight><bold>238</bold></highlight>, and <highlight><bold>242</bold></highlight> which are microprogrammed processors optimized for the predicate analysis associated with packet filtering. The classification engines are described in <cross-reference target="DRAWINGS">FIG. 13</cross-reference>. Packets are scheduled for processing by these engines through the use of the Reclassify Rings <highlight><bold>412</bold></highlight>, <highlight><bold>416</bold></highlight>, <highlight><bold>410</bold></highlight>, and <highlight><bold>414</bold></highlight> respectively, plus the RX MAC controllers MAC_A <highlight><bold>220</bold></highlight> and MAC_B <highlight><bold>228</bold></highlight> can schedule packets for processing by Classification Engines <highlight><bold>238</bold></highlight> and <highlight><bold>242</bold></highlight>, respectively, through use of the RX Rings <highlight><bold>402</bold></highlight> and <highlight><bold>404</bold></highlight>, respectively. </paragraph>
<paragraph id="P-0170" lvl="0"><number>&lsqb;0170&rsqb;</number> There is Crypto Processor Interface <highlight><bold>202</bold></highlight> which enables attachment of an encryption processor <highlight><bold>246</bold></highlight>. The RISC Processor <highlight><bold>244</bold></highlight> can issue reads and writes to the Crypto Processor <highlight><bold>246</bold></highlight> through this interface, and the Crypto Processor <highlight><bold>246</bold></highlight> can access SDRAM <highlight><bold>260</bold></highlight> and control and status registers internal to the interface <highlight><bold>202</bold></highlight> through use of interface <highlight><bold>202</bold></highlight>. </paragraph>
<paragraph id="P-0171" lvl="0"><number>&lsqb;0171&rsqb;</number> A Timestamp counter <highlight><bold>214</bold></highlight> is driven by a stable oscillator <highlight><bold>292</bold></highlight> and is used by the RX MAC logic <highlight><bold>220</bold></highlight> and <highlight><bold>228</bold></highlight>, the TX MAC logic <highlight><bold>222</bold></highlight> and <highlight><bold>232</bold></highlight>, the Classification Engines <highlight><bold>208</bold></highlight>, <highlight><bold>212</bold></highlight>, <highlight><bold>238</bold></highlight>, and <highlight><bold>242</bold></highlight>, the Crypto Processor <highlight><bold>246</bold></highlight>, and the Policy Processor <highlight><bold>244</bold></highlight> to obtain timestamps during processing of packets. </paragraph>
<paragraph id="P-0172" lvl="0"><number>&lsqb;0172&rsqb;</number> Preferably, the Policy Engine Units have the following characteristics: </paragraph>
<paragraph id="P-0173" lvl="7"><number>&lsqb;0173&rsqb;</number> 1. PCI Interface </paragraph>
<paragraph id="P-0174" lvl="2"><number>&lsqb;0174&rsqb;</number> 33 MHz operation. </paragraph>
<paragraph id="P-0175" lvl="2"><number>&lsqb;0175&rsqb;</number> 32/64-bit data path. </paragraph>
<paragraph id="P-0176" lvl="2"><number>&lsqb;0176&rsqb;</number> 32-bit addressing both as a target and as an initiator. </paragraph>
<paragraph id="P-0177" lvl="2"><number>&lsqb;0177&rsqb;</number> Initiator and Target interface. </paragraph>
<paragraph id="P-0178" lvl="2"><number>&lsqb;0178&rsqb;</number> One interrupt output. </paragraph>
<paragraph id="P-0179" lvl="2"><number>&lsqb;0179&rsqb;</number> Up to 32-byte bursts as a master; up to 32-byte bursts to memory (BAR0) as a target (disconnects on 32-byte boundaries), single data-phase operations as a target for Register (BARI) and Ring Translation Unit (BAR2) spaces. </paragraph>
<paragraph id="P-0180" lvl="2"><number>&lsqb;0180&rsqb;</number> Single configuration space for the entire device. </paragraph>
<paragraph id="P-0181" lvl="7"><number>&lsqb;0181&rsqb;</number> 2. RISC Processor Interface </paragraph>
<paragraph id="P-0182" lvl="2"><number>&lsqb;0182&rsqb;</number> Interface to external SA-110 StrongARM processor, running the bus at ASIC core clock or half core clock as programmed in the Processor Control and Status Register. </paragraph>
<paragraph id="P-0183" lvl="2"><number>&lsqb;0183&rsqb;</number> Handles all transaction types for PIO&apos;s (reads and writes of I/O registers), cache fills/spills, and non-cached memory accesses. </paragraph>
<paragraph id="P-0184" lvl="2"><number>&lsqb;0184&rsqb;</number> Low- and high-priority interrupt signals, driven by enabled bits of PISR and PCSR. </paragraph>
<paragraph id="P-0185" lvl="2"><number>&lsqb;0185&rsqb;</number> Boots from main memory; an external agent must initialize memory, download local initialization code etc, and release processor reset to enable operation. </paragraph>
<paragraph id="P-0186" lvl="2"><number>&lsqb;0186&rsqb;</number> Support for remap of the trap/reset vector to any location in PE Memory. </paragraph>
<paragraph id="P-0187" lvl="7"><number>&lsqb;0187&rsqb;</number> 3. Classification Engine </paragraph>
<paragraph id="P-0188" lvl="2"><number>&lsqb;0188&rsqb;</number> Microcoded engine for accelerating comparisons and hash lookups. </paragraph>
<paragraph id="P-0189" lvl="2"><number>&lsqb;0189&rsqb;</number> Runs a set of comparisons on fields extracted from 32-bit words within a packet to offload processor. </paragraph>
<paragraph id="P-0190" lvl="2"><number>&lsqb;0190&rsqb;</number> Operations can be on fields in the packet, or on pairs of result bits from previous comparisons. </paragraph>
<paragraph id="P-0191" lvl="2"><number>&lsqb;0191&rsqb;</number> Produces a result vector of one bit result for each comparison or for each boolean operation on pairs of bits in the vector (selected bits of which are then stored in a data structure in the 2 KB packet buffer). </paragraph>
<paragraph id="P-0192" lvl="2"><number>&lsqb;0192&rsqb;</number> Can also execute one or more hash lookups on one or more tables based on keys extracted from the packet. Optimized for linked list chasing through the use of non-blocking loads and speculative fetch of the next record; searches of hash tables implementing conflict resolution by chaining are thus accelerated. The hash lookup results are also stored in the packet buffer in memory. </paragraph>
<paragraph id="P-0193" lvl="2"><number>&lsqb;0193&rsqb;</number> Arbitrary fields can be extracted from the packet and returned in the packet&apos;s data structure to the PP. Arbitrary computation on extracted fields and result vector bits which yield multi-bit results can also be done in the CE, and the results returned to the PP in the data structure. </paragraph>
<paragraph id="P-0194" lvl="2"><number>&lsqb;0194&rsqb;</number> The above computations could also incorporate operands found in hash table records found during the above hash searches. </paragraph>
<paragraph id="P-0195" lvl="2"><number>&lsqb;0195&rsqb;</number> The contents of hash table records found using keys extracted from the packet can be updated with results of computations such as those described above. </paragraph>
<paragraph id="P-0196" lvl="2"><number>&lsqb;0196&rsqb;</number> Supports fast TCP/IP checksum calculation via use of the &ldquo;split-add&rdquo; unit. </paragraph>
<paragraph id="P-0197" lvl="2"><number>&lsqb;0197&rsqb;</number> Decisions and branches are supported. </paragraph>
<paragraph id="P-0198" lvl="2"><number>&lsqb;0198&rsqb;</number> Comparisons, extractions and computations, and hashing are run speculatively before the packet is handed to the Policy Processor; if the code on the PP (the Action section of the application) needs to run rules against the packet, the comparisons are done and ready for it to use, with single-bit decisions (&ldquo;predicate analysis results&rdquo;) for each policy to apply. Similarly, if the Action code needs to compute or extract information about the packet, the results of that computation are already available in the packet&apos;s data structure. </paragraph>
<paragraph id="P-0199" lvl="2"><number>&lsqb;0199&rsqb;</number> Packets are scheduled for classification from both the RX MAC ring and a reclassification ring for the &ldquo;Inbound&rdquo; CEs, from a reclassification ring alone for &ldquo;Outbound&rdquo; CEs. </paragraph>
<paragraph id="P-0200" lvl="7"><number>&lsqb;0200&rsqb;</number> 4. Ethernet MACs </paragraph>
<paragraph id="P-0201" lvl="2"><number>&lsqb;0201&rsqb;</number> Standard 10/100 Mbit EEE 802.3u-compliant MAC with MII interface to external PHY. </paragraph>
<paragraph id="P-0202" lvl="2"><number>&lsqb;0202&rsqb;</number> Each RX MAC has support for a single unicast address match, multicast hash filter, broadcast packets, and promiscuous mode. </paragraph>
<paragraph id="P-0203" lvl="2"><number>&lsqb;0203&rsqb;</number> Serial MII management interface to PHY. </paragraph>
<paragraph id="P-0204" lvl="2"><number>&lsqb;0204&rsqb;</number> RX MAC inserts packets along with receive status into 2 KB-aligned buffers, with the packet aligned so that the IP header is on a 32-bit boundary; keeping the receive buffer ring replenished with empty buffers is the only processor interaction with the MAC (i.e. there is no run-time device driver needed for the MAC). </paragraph>
<paragraph id="P-0205" lvl="2"><number>&lsqb;0205&rsqb;</number> Transmit MAC follows a ring of buffer pointers; scheduling of transmit buffers from any source is supported through a register which makes enqueuing atomic, thus allowing multiple masters to schedule transmits without mutexes. </paragraph>
<paragraph id="P-0206" lvl="2"><number>&lsqb;0206&rsqb;</number> Mode bit for PASS or DROP of bad ethernet packets (CRC errors etc). </paragraph>
<paragraph id="P-0207" lvl="2"><number>&lsqb;0207&rsqb;</number> Hardware counters to support RMON ETHER statistics gathering. </paragraph>
<paragraph id="P-0208" lvl="2"><number>&lsqb;0208&rsqb;</number> MACs operate on 2.5 MHZ/25 MHz RXCLK and TXCLK from the external Fast Ethernet PHY, each has its own clock domain and a synchronizing interface to the ASIC core. </paragraph>
<paragraph id="P-0209" lvl="7"><number>&lsqb;0209&rsqb;</number> 5. Memory Controller </paragraph>
<paragraph id="P-0210" lvl="2"><number>&lsqb;0210&rsqb;</number> Manages up to two DIMMs of SDRAM. </paragraph>
<paragraph id="P-0211" lvl="2"><number>&lsqb;0211&rsqb;</number> Aggressively schedules two banks independently for high performance. </paragraph>
<paragraph id="P-0212" lvl="2"><number>&lsqb;0212&rsqb;</number> Arbitrates among many agents; priorities are: </paragraph>
<paragraph id="P-0213" lvl="3"><number>&lsqb;0213&rsqb;</number> 1) MAC_A, MAC_B ping-pong (top prio); internal to each MAC, the TX and RX units arbitrate locally for the MAC&apos;s memory interface, with ping-pong priority </paragraph>
<paragraph id="P-0214" lvl="3"><number>&lsqb;0214&rsqb;</number> 2) Round-robin priority among PP, CE_AI, CE_AO, CE_BI, CE_BO, DMA, PCI_Target, Crypto </paragraph>
<paragraph id="P-0215" lvl="4"><number>&lsqb;0215&rsqb;</number> Supports different speed grades of SDRAM, programmable timing. </paragraph>
<paragraph id="P-0216" lvl="4"><number>&lsqb;0216&rsqb;</number> Parity generation and checking. </paragraph>
<paragraph id="P-0217" lvl="4"><number>&lsqb;0217&rsqb;</number> Serial Presence Detect (SPD) interface. </paragraph>
<paragraph id="P-0218" lvl="4"><number>&lsqb;0218&rsqb;</number> Contains the Ring Translation Unit for mapping Ring accesses to Memory addresses. </paragraph>
<paragraph id="P-0219" lvl="4"><number>&lsqb;0219&rsqb;</number> Contains the Mailbox address-matching and status unit. </paragraph>
<paragraph id="P-0220" lvl="7"><number>&lsqb;0220&rsqb;</number> 6. DMA Engine </paragraph>
<paragraph id="P-0221" lvl="2"><number>&lsqb;0221&rsqb;</number> Can be used by PP, Crypto, and also by the host (Application Processor) and PCI peer devices. </paragraph>
<paragraph id="P-0222" lvl="2"><number>&lsqb;0222&rsqb;</number> Moves word-aligned bursts of data between SDRAM and PCIbus. </paragraph>
<paragraph id="P-0223" lvl="2"><number>&lsqb;0223&rsqb;</number> Data is transferred between memory and PCI in byte lane order, for endian-neutral transfers of byte streams. See &ldquo;Endianness&rdquo; in Section 8. </paragraph>
<paragraph id="P-0224" lvl="2"><number>&lsqb;0224&rsqb;</number> Each DMA is controlled by a 16-byte descriptor; the initiator first constructs a descriptor, then enqueues a pointer to that descriptor on the DMA Ring to schedule the transfer. </paragraph>
<paragraph id="P-0225" lvl="2"><number>&lsqb;0225&rsqb;</number> Atomic enqueueing is supported to eliminate locks when scheduling DMAs. </paragraph>
<paragraph id="P-0226" lvl="2"><number>&lsqb;0226&rsqb;</number> At completion of each DMA, the unit can optionally set one of 8 status bits in the PISR (Processor Interrupt Status Register) or one of 8 status bits in the HISR (Host Interrupt Status Register), as indicated in the descriptor. </paragraph>
<paragraph id="P-0227" lvl="2"><number>&lsqb;0227&rsqb;</number> DMA engine ignores lower 11 bits of the SDRAM address, using a separate &ldquo;buffer offset&rdquo; instead. This is to support the buffer tag field in the buffer pointer used by software. </paragraph>
<paragraph id="P-0228" lvl="2"><number>&lsqb;0228&rsqb;</number> Descriptor is defined in &ldquo;DMA Command Queue and Descriptors&rdquo; in Section 6. </paragraph>
<paragraph id="P-0229" lvl="2"><number>&lsqb;0229&rsqb;</number> PCI command code is carried in the descriptor for flexibility. </paragraph>
<paragraph id="P-0230" lvl="7"><number>&lsqb;0230&rsqb;</number> 7. Crypto Control </paragraph>
<paragraph id="P-0231" lvl="2"><number>&lsqb;0231&rsqb;</number> PE ASIC hosts a 32-bit PCI bus for connecting to the Crypto coprocessor(s), with two external request/grant pairs and two interrupt inputs. PP can directly access devices on this bus. </paragraph>
<paragraph id="P-0232" lvl="2"><number>&lsqb;0232&rsqb;</number> 4 BAR&apos;s (&ldquo;Base Address Registers&rdquo;, which are part of the PCI standard) are supported: BAR0 for Memory, BARI for access to the ring status bits, BAR2 for access to the rings, and BAR3 for prefetched access to Memory. </paragraph>
<paragraph id="P-0233" lvl="2"><number>&lsqb;0233&rsqb;</number> Packets are scheduled for encryption by placing a Crypto descriptor in a data structure in the packet buffer in memory, then enqueueing the pointer to that buffer in the Crypto Ring. (Communication Ring 4 is also available for similar use with a second coprocessor.) </paragraph>
<paragraph id="P-0234" lvl="2"><number>&lsqb;0234&rsqb;</number> The Crypto chip will detect queue-not-empty by polling the CSTAT (Crypto Status Register) register and will dequeue the buffer pointer at the head of the queue for processing. Two rings are available so that up to two devices can be supported for this function </paragraph>
<paragraph id="P-0235" lvl="2"><number>&lsqb;0235&rsqb;</number> After processing a packet, the Crypto chip will write the results back to memory and then enqueue the buffer pointer on the specified destination ring (for further classification, for examination on the PP, for DMA to a target on the PCI bus, or for transmit.) </paragraph>
<paragraph id="P-0236" lvl="7"><number>&lsqb;0236&rsqb;</number> 8. Mailbox Unit </paragraph>
<paragraph id="P-0237" lvl="0"><number>&lsqb;0237&rsqb;</number> Monitors 16 word-sized mailboxes in memory space. </paragraph>
<paragraph id="P-0238" lvl="2"><number>&lsqb;0238&rsqb;</number> On address match, sets(clears) the status bit in the Mailbox Status Register associated with the word written(read). Selected status bits contribute to a Mailbox Attention status bit in the PISR. </paragraph>
<paragraph id="P-0239" lvl="7"><number>&lsqb;0239&rsqb;</number> 9. Ring Translation Unit </paragraph>
<paragraph id="P-0240" lvl="0"><number>&lsqb;0240&rsqb;</number> Base pointer to a 64 KB region of memory (only the first 60 KB are used, 4 KB remainder is available for other use). </paragraph>
<paragraph id="P-0241" lvl="2"><number>&lsqb;0241&rsqb;</number> Maintains 15 rings as memory arrays of 1K 32-bit entries each. </paragraph>
<paragraph id="P-0242" lvl="2"><number>&lsqb;0242&rsqb;</number> Reads and writes to rings through the RTU are mapped to locations in these arrays. </paragraph>
<paragraph id="P-0243" lvl="2"><number>&lsqb;0243&rsqb;</number> Some index registers auto-increment, others are incremented by their owner. </paragraph>
<paragraph id="P-0244" lvl="2"><number>&lsqb;0244&rsqb;</number> Delta between producer-consumer index pairs is detected in hardware. Any delta is signaled to the consumer indicating that there is work to do. </paragraph>
<paragraph id="P-0245" lvl="2"><number>&lsqb;0245&rsqb;</number> 10 of the rings have specific assignment as shown in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>. </paragraph>
<paragraph id="P-0246" lvl="2"><number>&lsqb;0246&rsqb;</number> 5 general-purpose rings COM&lsqb;4:0&rsqb; are provided for software to allocate as desired; expected use includes a freelist for DMA descriptors and a freelist of buffers for the AP or peers to use, messages-in to the PP, and others. COM4 can optionally be used as a second Crypto ring. </paragraph>
<paragraph id="P-0247" lvl="2"><number>&lsqb;0247&rsqb;</number> Overflow/underflow and threshold conditions are detected and reported through the CRISIS register in the Policy Processor interface </paragraph>
<paragraph id="P-0248" lvl="7"><number>&lsqb;0248&rsqb;</number> 10. Global TIMER </paragraph>
<paragraph id="P-0249" lvl="2"><number>&lsqb;0249&rsqb;</number> 32-bit up-counter driven from an external, asynchronous clock source. </paragraph>
<paragraph id="P-0250" lvl="2"><number>&lsqb;0250&rsqb;</number> Counts at 1 uS in bit <highlight><bold>3</bold></highlight> (leaving room for finer granularity in future higher speed implementations.) Counter rolls over approximately every 536.87 seconds. </paragraph>
<paragraph id="P-0251" lvl="2"><number>&lsqb;0251&rsqb;</number> Status bit in PISR/HISR sets on every transition (high-low and low-high) in bit&lsqb;30&rsqb; to simplify software extension of the timer value. </paragraph>
<paragraph id="P-0252" lvl="2"><number>&lsqb;0252&rsqb;</number> An Ethernet crystal (buffered copy) is used as the clock source since it is the most stable timebase available. Runs at 25 MHz. </paragraph>
<paragraph id="P-0253" lvl="2"><number>&lsqb;0253&rsqb;</number> In multi-PE implementations, all PE&apos;s receive the same clock source to avoid relative drift in timestamps. In systems using multiple PCI cards each containing a PE they each receive a local, non-aligned clock. </paragraph>
<paragraph id="P-0254" lvl="2"><number>&lsqb;0254&rsqb;</number> Used by MACs, Classification Engines, and PP for marking events; used for monitoring performance and packet arrival order as needed. </paragraph>
<paragraph id="P-0255" lvl="7"><number>&lsqb;0255&rsqb;</number> 11. Serial PROM </paragraph>
<paragraph id="P-0256" lvl="0"><number>&lsqb;0256&rsqb;</number> Support for a 24C02 256-byte serial PROM at serial address 0x7; the memory DIMMs are at addresses 0x0 and 0x1 for slots 0 and 1 (if supported). </paragraph>
<paragraph id="P-0257" lvl="2"><number>&lsqb;0257&rsqb;</number> PROM at 0x7 contains two MAC addresses, full/half-speed control indication for the processor bus, manufacturing information, and other configuration and tracking information. </paragraph>
<paragraph id="P-0258" lvl="2"><number>&lsqb;0258&rsqb;</number> Additional devices on the SPD bus include a Crypto Daughtercard IDPROM at address 0x6, and a thermal sensor at address 0x4. </paragraph>
</section>
<section>
<heading lvl="1">III. Data Structures </heading>
<paragraph id="P-0259" lvl="7"><number>&lsqb;0259&rsqb;</number> 1. Ring Array in Memory </paragraph>
<paragraph id="P-0260" lvl="0"><number>&lsqb;0260&rsqb;</number> The 15 rings are packed into a 60 KB array aligned on a 64 KB boundary in memory. The RING_BASE register points to the start of this array. Each ring is 4 KB in size and can hold up to 1K entries of 32 bits each. </paragraph>
<paragraph id="P-0261" lvl="0"><number>&lsqb;0261&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> illustrates a ring array in memory. </paragraph>
<paragraph id="P-0262" lvl="0"><number>&lsqb;0262&rsqb;</number> The Ring Translation Unit (RTU) <highlight><bold>264</bold></highlight> manages <highlight><bold>15</bold></highlight> arrays in memory <highlight><bold>260</bold></highlight> for communication purposes. Each ring actually consists of 1024 32-bit entries in memory for a total of 4 KB per ring, along with index registers and logic for detecting differences between the index register for a producer and the index register for the associated consumer, which is reported to that consumer as an indication that there is work for it to do. Various near-full-threshold, near-empty-threshold, full, and empty conditions are detected as appropriate to each ring and are reported to the ring users and to the Policy Processor <highlight><bold>244</bold></highlight> as appropriate. The RTU <highlight><bold>264</bold></highlight> translates Ring accesses into both a memory <highlight><bold>260</bold></highlight> access at a translated address, and in some cases into commands to increment specific index pointers after completing that memory access. Each ring is assigned a number for mapping purposes, and that number is used to index into the array of memory <highlight><bold>260</bold></highlight> in which the rings are implemented. The index registers are incremented modulo 4 KB so that FIFO behavior is achieved. Each index register contains one more significant bit than is used for addressing, so that a full ring can be differentiated from an empty ring. </paragraph>
<paragraph id="P-0263" lvl="0"><number>&lsqb;0263&rsqb;</number> A Ring Base Register <highlight><bold>400</bold></highlight> selects the location in memory <highlight><bold>260</bold></highlight> of the base of the 64 KB-aligned array <highlight><bold>440</bold></highlight> represented in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>. The structure is an array of arrays; there is an array of 15 rings indexed by the ring number, and each of those rings is a 4 KB array of 1024 32-bit entries indexed by various index registers used by different agents. </paragraph>
<paragraph id="P-0264" lvl="0"><number>&lsqb;0264&rsqb;</number> RX_A Ring <highlight><bold>402</bold></highlight> and RX_B Ring <highlight><bold>404</bold></highlight> implement the structure described in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>, and are associated with the receive streams from RX MAC_A <highlight><bold>220</bold></highlight> and RX MAC_B <highlight><bold>228</bold></highlight> respectively. TX_A Ring <highlight><bold>406</bold></highlight> and TX_B Ring <highlight><bold>408</bold></highlight> implement the structure of <cross-reference target="DRAWINGS">FIG. 8</cross-reference>, and are associated with the transmit MACs <highlight><bold>222</bold></highlight> and <highlight><bold>232</bold></highlight> respectively. The Reclassify Rings <highlight><bold>410</bold></highlight>, <highlight><bold>412</bold></highlight>, <highlight><bold>414</bold></highlight>, and <highlight><bold>416</bold></highlight> are used to schedule packets for classification on Classification Engines <highlight><bold>238</bold></highlight>, <highlight><bold>208</bold></highlight>, <highlight><bold>242</bold></highlight>, and <highlight><bold>212</bold></highlight> respectively, and implement the structure shown in <cross-reference target="DRAWINGS">FIG. 10</cross-reference>. </paragraph>
<paragraph id="P-0265" lvl="0"><number>&lsqb;0265&rsqb;</number> DMA Ring <highlight><bold>418</bold></highlight> is used to schedule descriptor pointers for consumption by DMA Unit <highlight><bold>210</bold></highlight>, and implements the structure shown in <cross-reference target="DRAWINGS">FIG. 12</cross-reference>. Crypto Ring <highlight><bold>420</bold></highlight> is used to schedule buffers for processing on the Crypto Processor <highlight><bold>246</bold></highlight> and implements the structure shown in <cross-reference target="DRAWINGS">FIG. 11</cross-reference>. The five general purpose communication rings CCM&lsqb;4:0&rsqb; are available for assignment by software and also implement the structure shown in <cross-reference target="DRAWINGS">FIG. 11</cross-reference>. </paragraph>
<paragraph id="P-0266" lvl="7"><number>&lsqb;0266&rsqb;</number> 2. RX Buffer Pointer Ring and Produce/Consume Pointers </paragraph>
<paragraph id="P-0267" lvl="0"><number>&lsqb;0267&rsqb;</number> A ring of buffer pointers resides in the memory for each RX MAC. Associated with this ring are produce and consume index pointers for the various users of these buffers to access specific rings. The Policy Processor allocates free, empty buffers to the MAC by writing them to the associated MPROD address in the Ring Translation Unit (RTU), which writes the buffer address into the ring and increments the MPROD pointer modulo ring size. The RX MAC chases that pointer with the MFILL index which is used to find the next available empty buffer. That pointer is chased by MCCONS which is used by the Classification Engine to identify the next packet to run the classification microcode on. The PP uses a status bit in the PISR to see that there is at least one classified packet to process, then reads the ring through MPCONS in the RTU to identify the next buffer that the PP needs to process. </paragraph>
<paragraph id="P-0268" lvl="0"><number>&lsqb;0268&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> shows an RX Ring Structure related to certain embodiments of the present invention. There are two RX Rings <highlight><bold>402</bold></highlight> and <highlight><bold>404</bold></highlight>. Each is located in the Ring Array in memory <highlight><bold>260</bold></highlight>. Each has four index registers associated with it. <cross-reference target="DRAWINGS">FIG. 6</cross-reference> shows the ring as an array in memory with lower addresses to the top and higher addresses to the bottom of the picture. </paragraph>
<paragraph id="P-0269" lvl="0"><number>&lsqb;0269&rsqb;</number> The ring&apos;s base address <highlight><bold>510</bold></highlight> is a combination of the Ring Base Register <highlight><bold>400</bold></highlight> and the ring number which is used to index into the Ring Array <highlight><bold>440</bold></highlight> as shown in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>. Two instances of the set of four index registers MPCONS <highlight><bold>512</bold></highlight>, MCCONS <highlight><bold>514</bold></highlight>, MFILL <highlight><bold>516</bold></highlight>, and MPROD <highlight><bold>518</bold></highlight> are used to provide an offset from the RX Ring Base <highlight><bold>510</bold></highlight> of the particular ring <highlight><bold>402</bold></highlight> or <highlight><bold>404</bold></highlight>, each of which is a 4 KB array <highlight><bold>520</bold></highlight>. </paragraph>
<paragraph id="P-0270" lvl="0"><number>&lsqb;0270&rsqb;</number> MPROD <highlight><bold>518</bold></highlight> is the lead producer index for this ring. The Policy Processor <highlight><bold>244</bold></highlight> or the Application Processor <highlight><bold>302</bold></highlight> enqueues buffer pointers into the RX Ring <highlight><bold>402</bold></highlight> or <highlight><bold>404</bold></highlight> by writing the buffer pointer to the RTU&apos;s enqueue address for the particular ring <highlight><bold>402</bold></highlight> or <highlight><bold>404</bold></highlight>, which causes the RTU to write the buffer pointer to the location in memory <highlight><bold>260</bold></highlight> referenced by MPROD <highlight><bold>518</bold></highlight>, and then to increment MPROD <highlight><bold>518</bold></highlight> modulo the ring size of 4096 bytes. This process allocates an empty buffer to the RX MAC MAC_A or MAC_B associated with ring <highlight><bold>402</bold></highlight> or <highlight><bold>404</bold></highlight> respectively. </paragraph>
<paragraph id="P-0271" lvl="0"><number>&lsqb;0271&rsqb;</number> MPROD <highlight><bold>518</bold></highlight> and MFILL <highlight><bold>516</bold></highlight> have a producer-consumer relationship. Any time there is a difference between the value of MPROD <highlight><bold>518</bold></highlight> and MFILL <highlight><bold>516</bold></highlight>, the RTU <highlight><bold>264</bold></highlight> signals to the associated RX MAC MAC_A or MAC_B that it has empty buffers available. The region <highlight><bold>506</bold></highlight> in the RX Ring <highlight><bold>402</bold></highlight> or <highlight><bold>404</bold></highlight> represents one or more valid, empty buffers that have been allocated to the associated RX MAC by enqueueing the pointers to those buffers. </paragraph>
<paragraph id="P-0272" lvl="0"><number>&lsqb;0272&rsqb;</number> When the RX MAC MAC_A or MAC_B receives a packet, it obtains the buffer pointer referenced by its associated MFILL pointer <highlight><bold>516</bold></highlight> by reading from the RTU&apos;s MFILL address and then writes the packet and associated RX Status <highlight><bold>600</bold></highlight> and RX Timestamp <highlight><bold>602</bold></highlight> into the buffer pointed to by that buffer pointer. When the RX_MAC has successfully received a packet and has finished transferring it into the buffer, it increments the index MFILL <highlight><bold>516</bold></highlight> by a hardware signal to the RTU which causes the RTU to increment MFILL <highlight><bold>516</bold></highlight> modulo the ring size of 4096 bytes. MFILL <highlight><bold>516</bold></highlight> and MCCONS <highlight><bold>514</bold></highlight> have a producer-consumer relationship; when the RTU <highlight><bold>264</bold></highlight> detects a difference between the value of MFILL <highlight><bold>516</bold></highlight> and MCCONS <highlight><bold>514</bold></highlight> it signals to that ring&apos;s associated Classification Engine <highlight><bold>238</bold></highlight> or <highlight><bold>242</bold></highlight> that it has a freshly received packet to process. The region <highlight><bold>504</bold></highlight> in the ring array contains the buffer pointers to one or more full, unclassified buffers that the RX MAC has passed to the associated Classification Engine. </paragraph>
<paragraph id="P-0273" lvl="0"><number>&lsqb;0273&rsqb;</number> The Classification Engine <highlight><bold>238</bold></highlight> or <highlight><bold>242</bold></highlight> receives a signal if the RTU <highlight><bold>264</bold></highlight> detects full, unclassified packets in RX Ring <highlight><bold>402</bold></highlight> or <highlight><bold>404</bold></highlight>, respectively. When the dispatch microcode on that CE <highlight><bold>238</bold></highlight> or <highlight><bold>242</bold></highlight> tests the ring status and sees this signal from the RTU <highlight><bold>264</bold></highlight>, that CE <highlight><bold>238</bold></highlight> or <highlight><bold>242</bold></highlight> obtains the buffer pointer by reading from the RTU&apos;s MCCONS address for that ring. When the CE <highlight><bold>238</bold></highlight> or <highlight><bold>242</bold></highlight> has finished processing that buffer and has written all results back to memory <highlight><bold>260</bold></highlight>, it signals to the RTU <highlight><bold>264</bold></highlight> to increment its associated MCCONS index <highlight><bold>514</bold></highlight>. Upon receiving this signal the RTU <highlight><bold>264</bold></highlight> increments MCCONS <highlight><bold>514</bold></highlight> modulo the ring size of 4096 bytes. By sending the signal, the CE <highlight><bold>238</bold></highlight> or <highlight><bold>242</bold></highlight> has indicated that it is done processing that packet and that the packet is available for the consumer, which is action code <highlight><bold>108</bold></highlight> running on the Policy Processor <highlight><bold>244</bold></highlight>. The region <highlight><bold>502</bold></highlight> contains the buffer pointers for one or more full, classified packets that the Classification Engine has passed to the Action Code <highlight><bold>108</bold></highlight>. </paragraph>
<paragraph id="P-0274" lvl="0"><number>&lsqb;0274&rsqb;</number> MCCONS <highlight><bold>514</bold></highlight> and MPCONS <highlight><bold>512</bold></highlight> have a producer-consumer relationship. When the CE <highlight><bold>238</bold></highlight> or <highlight><bold>242</bold></highlight> has produced a full, classified packet then that packet is available for consumption by the action code <highlight><bold>108</bold></highlight>. The RTU detects when there is a difference between the values of MCCONS <highlight><bold>514</bold></highlight> and MPCONS <highlight><bold>512</bold></highlight> and signals this to the Policy Processor <highlight><bold>244</bold></highlight> through a status register in the Processor Interface <highlight><bold>206</bold></highlight>. The Policy Processor <highlight><bold>224</bold></highlight> monitors this register, and when dispatch code on the Policy Processor <highlight><bold>224</bold></highlight> determines that it is ready to process a full, classified packet it dequeues the buffer pointer of that packet from the RX Ring <highlight><bold>402</bold></highlight> or <highlight><bold>404</bold></highlight>, as appropriate, by reading the RTU&apos;s dequeue address for that ring. This read causes the RTU to return to the Policy Processor <highlight><bold>244</bold></highlight> the buffer pointer referenced by that ring&apos;s MPCONS index <highlight><bold>512</bold></highlight>, and then to increment MPCONS <highlight><bold>512</bold></highlight> modulo the ring size of 4096 bytes. The act of dequeueing the buffer pointer means that the pointer no longer has any meaning in the RX ring. The contents of the ring in locations between MPCONS <highlight><bold>512</bold></highlight> and MPROD <highlight><bold>518</bold></highlight> have no meaning, and are indicated by the Invalid regions <highlight><bold>500</bold></highlight> and <highlight><bold>508</bold></highlight>. Since this is a ring structure which wraps, <highlight><bold>500</bold></highlight> and <highlight><bold>508</bold></highlight> are actually the same region; in the figure shown, due the current values of the ring index pointers <highlight><bold>512</bold></highlight>, <highlight><bold>514</bold></highlight>, <highlight><bold>516</bold></highlight>, and <highlight><bold>518</bold></highlight> the Invalid regions <highlight><bold>500</bold></highlight> and <highlight><bold>508</bold></highlight> happens to wrap across the start and end of the array containing this ring, but it should be obvious to one skilled in the art that under normal circumstances these ring index pointers can have different values and any of regions <highlight><bold>502</bold></highlight>, <highlight><bold>504</bold></highlight>, or <highlight><bold>506</bold></highlight> could also be region which wraps around the end and beginning of the array <highlight><bold>520</bold></highlight>. </paragraph>
<paragraph id="P-0275" lvl="0"><number>&lsqb;0275&rsqb;</number> 2.1 RX Buffer Structure </paragraph>
<paragraph id="P-0276" lvl="0"><number>&lsqb;0276&rsqb;</number> The receive data buffer is a 2 KB structure which contains an Ethernet packet and information about that packet. A substantially similar format is used for transmitting the packet, as indicated in <cross-reference target="DRAWINGS">FIG. 8</cross-reference>. The packet offset from the base of the buffer is designed so that upon receive the Ether header is offset by two bytes into a word, thus aligning the IP header on a word (32-bit) boundary. Enough space is left before the packet so that encapsulation/encryption headers (e.g., up to 40 bytes for a standard IPv6 header plus AH and ESP) can be inserted for encapsulation of the packet without copying the packet, by just copying the Ethernet header up to make space and then inserting the encapsulation headers. The total pad size is 112 Bytes; if more is needed then the Crypto Coprocessor can realign the packet when writing it back. </paragraph>
<paragraph id="P-0277" lvl="0"><number>&lsqb;0277&rsqb;</number> The RX MAC can be programmed to either drop bad packets or receive them normally; if the latter, then error status is also shown in the buffer RX status field. </paragraph>
<paragraph id="P-0278" lvl="0"><number>&lsqb;0278&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> illustrates the receive buffer format. </paragraph>
<paragraph id="P-0279" lvl="0"><number>&lsqb;0279&rsqb;</number> A packet is passed around the system by placing it into a packet buffer <highlight><bold>620</bold></highlight> and then passing the 2 KB-aligned buffer pointer among units via pointer rings implemented by the RTU <highlight><bold>264</bold></highlight>. The RX Status and Transmit Command Word <highlight><bold>600</bold></highlight> is always located at the word pointed to by the 2 KB-aligned buffer pointer. All hardware in the Policy Engine <highlight><bold>322</bold></highlight> is designed to assume that a buffer pointer is 2 KB-aligned and to ignore bits &lsqb;10:0&rsqb;, which allows software to use bits &lsqb;10:0&rsqb; of the buffer pointer to carry software tag information associated with that buffer. </paragraph>
<paragraph id="P-0280" lvl="0"><number>&lsqb;0280&rsqb;</number> Upon receiving a packet the RX MAC <highlight><bold>220</bold></highlight> or <highlight><bold>228</bold></highlight> places that packet at an offset of (130) bytes from the beginning of a buffer <highlight><bold>620</bold></highlight>, and writes zero to the bytes at byte offset (128) and (129) from the beginning of that buffer; these two bytes are called the Ethernet Header Pad <highlight><bold>618</bold></highlight>. The packet consists of the (14)-byte Ethernet header <highlight><bold>610</bold></highlight> and the payload <highlight><bold>612</bold></highlight> of the Ethernet packet, which are stored contiguously in the buffer <highlight><bold>620</bold></highlight>. The reason for inserting the Ethernet Header Pad is to force protocol headers encapsulated in the Ethernet packet to be word (32-bit) aligned for ease in further processing; encapsulated protocols such as IP, TCP, UDP etc have word-oriented formats. </paragraph>
<paragraph id="P-0281" lvl="0"><number>&lsqb;0281&rsqb;</number> The RX MAC control logic <highlight><bold>220</bold></highlight> or <highlight><bold>228</bold></highlight> then writes the RX Status Word <highlight><bold>600</bold></highlight> into the buffer <highlight><bold>620</bold></highlight> at an offset of (0) from the start of the buffer, and an RX Timestamp <highlight><bold>602</bold></highlight> as a 32-bit word at byte offset (4) from the start of the buffer <highlight><bold>620</bold></highlight>. The RX Status Word has the format shown in Table 1 The timestamp is the value obtained from the Timestamp Register <highlight><bold>214</bold></highlight> at the time the RX status <highlight><bold>600</bold></highlight> is written to the buffer <highlight><bold>620</bold></highlight>. The TX Status Word <highlight><bold>604</bold></highlight> and the TX Timestamp <highlight><bold>606</bold></highlight> are not written at this time, but those locations covering the two 32-bit words at offsets of 8 and 12 bytes, respectively, from the start of the buffer <highlight><bold>620</bold></highlight> are reserved for later use by the TX MAC controllers <highlight><bold>222</bold></highlight> and <highlight><bold>232</bold></highlight>. </paragraph>
<paragraph id="P-0282" lvl="0"><number>&lsqb;0282&rsqb;</number> The format for the RX Status word in Table 1 is such that it can be used directly as a TX Command Word without modification; the fields LENGTH and PKT_OFFSET have the same meaning in both formats. The RX MAC controller <highlight><bold>220</bold></highlight> or <highlight><bold>228</bold></highlight> subtracts (4) bytes from the Ethernet packet&apos;s length before storing the LENGTH field in the RX Status Word <highlight><bold>600</bold></highlight> such that the (4-byte) Ethernet CRC is not counted in LENGTH, so that the buffer can be handed to a TX MAC <highlight><bold>222</bold></highlight> or <highlight><bold>232</bold></highlight> without need for the Policy Processor <highlight><bold>244</bold></highlight> modifying the contents of the buffer. </paragraph>
<paragraph id="P-0283" lvl="0"><number>&lsqb;0283&rsqb;</number> Pad Space <highlight><bold>608</bold></highlight> is left before the start of the packet <highlight><bold>610</bold></highlight> and <highlight><bold>612</bold></highlight> in buffer <highlight><bold>620</bold></highlight> to support the addition of encapsulating protocol headers without copying the entire packet. Up to (112) bytes of encapsulation header(s) can be inserted simply by copying the ethernet header <highlight><bold>610</bold></highlight> (and possibly an associated SNAP encapsulation header in the start of payload <highlight><bold>612</bold></highlight>) upwards into the Pad Space <highlight><bold>608</bold></highlight> by the number of bytes necessary to make room for the inserted headers, which are then written into the location that was opened up for them in areas <highlight><bold>608</bold></highlight>, <highlight><bold>610</bold></highlight>, and <highlight><bold>612</bold></highlight> as needed. If more than (112) bytes of encapsulation header are being inserted then the entire payload <highlight><bold>612</bold></highlight> must be copied to a different location in the buffer to make room for the inserted headers. </paragraph>
<paragraph id="P-0284" lvl="0"><number>&lsqb;0284&rsqb;</number> The per-packet software data structure <highlight><bold>614</bold></highlight> is used by the classification <highlight><bold>106</bold></highlight>, action code <highlight><bold>108</bold></highlight>, encryption processing <highlight><bold>112</bold></highlight>, the host <highlight><bold>302</bold></highlight> and PCI peers <highlight><bold>322</bold></highlight>, <highlight><bold>314</bold></highlight>, and <highlight><bold>316</bold></highlight> to carry information about the packet that is carried in the buffer <highlight><bold>620</bold></highlight>. The location of the software data structure <highlight><bold>614</bold></highlight> and the sizes of the packet header <highlight><bold>610</bold></highlight> and packet payload <highlight><bold>612</bold></highlight>, as well as the total size of the packet buffer <highlight><bold>620</bold></highlight> are not hard limits in the preferred embodiment. The 2 KB-alignment of the RX status word <highlight><bold>600</bold></highlight> and RX Timestamp are enforced by the hardware; but packets from other sources and also from other media besides Ethernet can be injected into the classification flow of <cross-reference target="DRAWINGS">FIG. 2</cross-reference> as follows. The SOURCE field of the RX status word <highlight><bold>600</bold></highlight> as shown in Table 1 has only a few reserved codes; the rest can be assigned by software to identify packets from other sources and also from other media which do not share the packet format or packet size of Ethernet. By software convention larger buffers can be assigned by grouping contiguous 2 KB buffers together and treating them as one buffer; the pointer to this larger buffer <highlight><bold>602</bold></highlight> will still be 2 KB-aligned and the RX Status Word <highlight><bold>600</bold></highlight> and RX Timestamp <highlight><bold>602</bold></highlight> will still reside at that location in the buffer. The packet area <highlight><bold>610</bold></highlight> and <highlight><bold>612</bold></highlight> can be made arbitrarily large to accommodate a packet from a different medium. The location of the software data structure <highlight><bold>614</bold></highlight> can be moved downwards as the larger payload space is allocated. Alternatively the software can choose to allocate buffers so that they have space before the 2 KB-aligned RX Status Word <highlight><bold>600</bold></highlight>, and carry the software data structure <highlight><bold>614</bold></highlight> above the RX Status Word <highlight><bold>600</bold></highlight> rather than below the Payload <highlight><bold>612</bold></highlight> as shown in <cross-reference target="DRAWINGS">FIG. 7</cross-reference>. The advantage of this second approach is that the location of the software data structure is always known to be at a fixed location relative to the RX Status Word <highlight><bold>600</bold></highlight>, rather than having that location be a variable depending on different media and the resulting variations in the size of the packet payload <highlight><bold>612</bold></highlight>. </paragraph>
<paragraph id="P-0285" lvl="0"><number>&lsqb;0285&rsqb;</number> The section marked &ldquo;Available for software use&rdquo; contains transient per-packet information such as the result vector and hash pointers output by the Classification Engine, a command descriptor for the Crypto Unit, buffer reference counts, an optional pointer to an extension buffer, and any other data structures that the software defines. &ldquo;TX Status/TX Timestamp&rdquo; is optionally written by the transmit MAC if it is programmed to do so; that field contains garbage after an RX. </paragraph>
<paragraph id="P-0286" lvl="0"><number>&lsqb;0286&rsqb;</number> The &ldquo;RX Timestamp&rdquo; field contains the 32-bit value of the chip&apos;s TIMER register at the time that the packet was successfully received (approximately the time of receipt of the end of packet) and the RX_STATUS field was written The &ldquo;RX Status&rdquo; field is one 32-bit word with the following format: </paragraph>
<paragraph id="P-0287" lvl="0"><number>&lsqb;0287&rsqb;</number> Note throughout this document that bit &lsqb;31&rsqb; is the left (most significant) bit of a 32-bit word, and bit &lsqb;0&rsqb; is right (least significant). &ldquo;MCSR&rdquo; mentioned in Table 1, below, is the MAC Control and Status Register.  
<table-cwu id="TABLE-US-00001">
<number>1</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="378PT" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center">TABLE 1</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Ethernet RX Status Word and TX Command Word Format</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="63PT" align="left"/>
<colspec colname="3" colwidth="280PT" align="left"/>
<tbody valign="top">
<row>
<entry>Bits</entry>
<entry>Field</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>&lsqb;31&rsqb;</entry>
<entry>BAD_PKT</entry>
<entry>Summary error bit; set if any of &lsqb;30:27, 15:14&rsqb; is set, which can only happen if the MAC is</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>programmed to receive bad frames.</entry>
</row>
<row>
<entry>&lsqb;30&rsqb;</entry>
<entry>CRC_ERR</entry>
<entry>Ethernet frame had incorrect CRC and (MCSR&lsqb;RCV_BAD&rsqb;&equals;&equals;1) for this MAC.</entry>
</row>
<row>
<entry>&lsqb;29&rsqb;</entry>
<entry>RUNT</entry>
<entry>Ethernet frame was smaller than legal and (MCSR&lsqb;RCV_BAD&rsqb;&equals;&equals;1) for this MAC</entry>
</row>
<row>
<entry>&lsqb;28&rsqb;</entry>
<entry>GIANT</entry>
<entry>Ethernet frame was larger than legal and (MCSR&lsqb;RCV_BAD&rsqb;&equals;&equals;l) for this MAC</entry>
</row>
<row>
<entry>&lsqb;27&rsqb;</entry>
<entry>PREAMB_ERR</entry>
<entry>Invalid preamble and (MCSR&lsqb;RCV_BAD&rsqb;1) for this MAC. This error is associated with</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>some previous event, not with the current packet.</entry>
</row>
<row>
<entry>&lsqb;26:16&rsqb;</entry>
<entry>LENGTH</entry>
<entry>For RX, number of bytes in the Ethernet frame including the Ethernet header but not including</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>the Ethernet CRC. For TX, length of packet, including CRC if (MCSR&lsqb;CRC_EN&rsqb;&equals;&equals;0)</entry>
</row>
<row>
<entry>&lsqb;15&rsqb;</entry>
<entry>DRBL_ERR</entry>
<entry>Odd number of nibbles received (dribble) and (MCSR&lsqb;RCV_BAD&rsqb;&equals;&equals;1) for this MAC</entry>
</row>
<row>
<entry>&lsqb;14&rsqb;</entry>
<entry>CODE_ERR</entry>
<entry>4b/5b encoding error and (MCSR&lsqb;RCV_BAD&rsqb;&equals;&equals;1) for this MAC</entry>
</row>
<row>
<entry>&lsqb;13&rsqb;</entry>
<entry>BCAST</entry>
<entry>The received packet was a broadcast packet (destination address is all 1&apos;s)</entry>
</row>
<row>
<entry>&lsqb;12&rsqb;</entry>
<entry>MCAST</entry>
<entry>The received packet was a multicast packet and was passed by the multicast hash filter</entry>
</row>
<row>
<entry>&lsqb;11:08&rsqb;</entry>
<entry>SOURCE</entry>
<entry>This indicates the source of the packet or other source as marked later by software. If the packet</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>was generated at a RX MAC then this field is 0&times;0 for MAC_A or 0&times;1 for MAC_B.</entry>
</row>
<row>
<entry>&lsqb;07:00&rsqb;</entry>
<entry>PKT_OFFSET</entry>
<entry>This is the byte offset from the beginning of the packet buffer to the first byte of the Ethernet</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>header. Other agents may choose to move this offset in order to encapsulate the IP packet or to</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>strip of encapsulation headers. The CE, PP, and AP all use this offset when accessing the frame</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>in this buffer, The RX MAC will always write a value of 0&times;82 into this field, indicating that the</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>Ethernet Frame was received into the buffer starting at byte offset 130 from the start of the</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>buffer.</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0288" lvl="7"><number>&lsqb;0288&rsqb;</number> The same packet buffer format is used for encryption and transmission; for those uses the only meaningful fields are LENGTH, PKT_OFFSET and the contents of the Ethernet frame found at that offset; plus for encryption the encryption descriptor included in the &ldquo;Software&rdquo; area in the buffer. </paragraph>
<paragraph id="P-0289" lvl="7"><number>&lsqb;0289&rsqb;</number> 3. TX Buffer Pointer Rings and Producer/Consumer Pointers </paragraph>
<paragraph id="P-0290" lvl="0"><number>&lsqb;0290&rsqb;</number> A packet gets scheduled for transmission by enqueueing the address of the buffer onto the pointer queue for that transmit MAC, by writing it to MTPROD in the RTU (MAC A and MAC B each have their own ring and associated registers). Any time the produce pointer is not equal to the consume pointer for that ring, the associated MAC will be notified that there is at least one packet to transmit and will follow the pointer to obtain the next buffer to deal with. When the packet has been retired the TX controller will write back status if configured to do so, then increment the consume pointer and continue to the next buffer (if any.) </paragraph>
<paragraph id="P-0291" lvl="0"><number>&lsqb;0291&rsqb;</number> The recover pointer is used to track retired buffers (either successfully transmitted or abandoned due to transmit termination conditions) for return to the buffer pool, or possibly for a retransmit attempt; the PP is signaled by the RTU that there is a delta between MTCONS and MTRECOV, and then reads the Ring through the RTU register MTRECOV to get the pointer to the next buffer to recover. MTPROD, MTCONS, and MTRECOV are duplicated for each instance of a transmit MAC. </paragraph>
<paragraph id="P-0292" lvl="0"><number>&lsqb;0292&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> illustrates the TX Ring Structure according to certain embodiments of the present invention. </paragraph>
<paragraph id="P-0293" lvl="0"><number>&lsqb;0293&rsqb;</number> The TX Rings <highlight><bold>406</bold></highlight> and <highlight><bold>408</bold></highlight> have substantially the same structure as the RX Rings described previously. The fundamental differences are that there is one fewer interim producer-consumer using this ring, and that this ring is assigned for a different function with different agents using it. Each ring <highlight><bold>406</bold></highlight> and <highlight><bold>408</bold></highlight> is a 4096-byte array <highlight><bold>720</bold></highlight> in memory <highlight><bold>260</bold></highlight>. </paragraph>
<paragraph id="P-0294" lvl="0"><number>&lsqb;0294&rsqb;</number> A packet is scheduled for transmit on the TX MACs <highlight><bold>222</bold></highlight> or <highlight><bold>232</bold></highlight> by enqueuing a pointer to the buffer containing the packet onto TX Ring <highlight><bold>406</bold></highlight> or <highlight><bold>408</bold></highlight>, respectively The buffer pointer is enqueued onto <highlight><bold>406</bold></highlight> or <highlight><bold>408</bold></highlight> by any agent, by writing the buffer pointer to the RTU <highlight><bold>264</bold></highlight> enqueue address for that ring. The RTU <highlight><bold>264</bold></highlight> writes the buffer pointer to the location in memory <highlight><bold>260</bold></highlight> referenced by the MTPROD index register <highlight><bold>716</bold></highlight>, and then increments MTPROD <highlight><bold>716</bold></highlight> modulo the ring size of 4096 bytes. There is a producer-consumer relationship between MTPROD <highlight><bold>716</bold></highlight> and MTCONS <highlight><bold>714</bold></highlight>; when the RTU detects a difference in the values of MTPROD <highlight><bold>716</bold></highlight> and MTCONS <highlight><bold>714</bold></highlight> it signals to the associated TX MAC controller <highlight><bold>222</bold></highlight> or <highlight><bold>232</bold></highlight> that there is a packet ready to transmit. The region <highlight><bold>706</bold></highlight> in the TX Ring <highlight><bold>406</bold></highlight> or <highlight><bold>408</bold></highlight> contains one or more buffer pointers for the buffers containing packets scheduled for transmission. </paragraph>
<paragraph id="P-0295" lvl="0"><number>&lsqb;0295&rsqb;</number> The TX MAC controller <highlight><bold>222</bold></highlight> or <highlight><bold>232</bold></highlight> obtains the buffer pointer for the buffer <highlight><bold>206</bold></highlight> containing this packet by reading the RTU&apos;s MTCONS address for TX Ring <highlight><bold>406</bold></highlight> or <highlight><bold>408</bold></highlight>, respectively, which causes the RTU to return to the MAC the buffer pointer in memory <highlight><bold>260</bold></highlight> referenced by MTCONS <highlight><bold>714</bold></highlight>. When the TX MAC <highlight><bold>218</bold></highlight> or <highlight><bold>234</bold></highlight> has successfully transmitted this packet or has abandoned transmitting this packet due to transmit termination conditions, its controller <highlight><bold>222</bold></highlight> or <highlight><bold>232</bold></highlight> respectively will optionally write back TX Status <highlight><bold>806</bold></highlight> and TX Timestamp <highlight><bold>808</bold></highlight> if it has been configured to write status, then retires the buffer by signaling to the RTU <highlight><bold>264</bold></highlight> to increment MTCONS <highlight><bold>714</bold></highlight>. Upon receiving this signal the RTU <highlight><bold>264</bold></highlight> will increment MTCONS <highlight><bold>714</bold></highlight> modulo the ring size of 4096 bytes. </paragraph>
<paragraph id="P-0296" lvl="0"><number>&lsqb;0296&rsqb;</number> Index registers MTCONS <highlight><bold>714</bold></highlight> and MTRECOV <highlight><bold>712</bold></highlight> have a producer-consumer relationship When the RTU detects a difference in their values, it signals to the PP that the associated TX ring <highlight><bold>406</bold></highlight> or <highlight><bold>408</bold></highlight> has a retired buffer to recover. That information is visible to the Policy Processor <highlight><bold>244</bold></highlight> in a status register in Processor Interface <highlight><bold>206</bold></highlight> which the Policy Processor <highlight><bold>244</bold></highlight> polls on occasion to see what work it needs to dispatch. Upon testing the RECOVER status for the TX Ring <highlight><bold>406</bold></highlight> or <highlight><bold>408</bold></highlight> and detecting that there is at least one buffer to recover, the Buffer Recovery code <highlight><bold>118</bold></highlight> reads the RTU&apos;s <highlight><bold>264</bold></highlight> MTRECOV address for that ring to dequeue the buffer pointer from the TX ring <highlight><bold>406</bold></highlight> or <highlight><bold>408</bold></highlight>. The read causes the RTU to return the buffer pointer referenced by MTRECOV <highlight><bold>712</bold></highlight>, and then to increment MTRECOV <highlight><bold>712</bold></highlight> modulo the ring size of 4096 bytes. The region <highlight><bold>704</bold></highlight> contains the buffer pointers of buffers which have been retired by the TX MAC <highlight><bold>222</bold></highlight> or <highlight><bold>232</bold></highlight> but have not yet been recovered by the Buffer Recovery code <highlight><bold>118</bold></highlight>. </paragraph>
<paragraph id="P-0297" lvl="0"><number>&lsqb;0297&rsqb;</number> The regions <highlight><bold>702</bold></highlight> and <highlight><bold>708</bold></highlight> are the same region, which in the figure shown are spanning the end and the beginning of the array <highlight><bold>720</bold></highlight> in memory <highlight><bold>260</bold></highlight> which contains the TX Ring <highlight><bold>406</bold></highlight> or <highlight><bold>408</bold></highlight>. This region contains entries which are neither a buffer pointer to a buffer ready for transmit, nor a buffer pointer to a buffer which the TX MAC <highlight><bold>222</bold></highlight> or <highlight><bold>232</bold></highlight> has retired but the recovery code <highlight><bold>118</bold></highlight> CRC, and the data in <highlight><bold>816</bold></highlight> is sent with the packet for use as the packet&apos;s CRC. This configuration which uses software-generated Ethernet CRC is provided primarily as a diagnostic tool for sending bad packets to other devices on the network. </paragraph>
<paragraph id="P-0298" lvl="0"><number>&lsqb;0298&rsqb;</number> Upon completion or abandonment of a transmit, the TX MAC will write back the TX Status Word <highlight><bold>806</bold></highlight> and the TX Timestamp <highlight><bold>808</bold></highlight> if it is so configured. The TX Status Word <highlight><bold>806</bold></highlight> contains the information and format shown in Table 2. The TX Timestamp <highlight><bold>808</bold></highlight> is written with the value of the Timestamp Register <highlight><bold>214</bold></highlight> at the time the write to TX Timestamp <highlight><bold>808</bold></highlight> is initiated. </paragraph>
<paragraph id="P-0299" lvl="0"><number>&lsqb;0299&rsqb;</number> The software data structure <highlight><bold>820</bold></highlight> which travels in the packet buffer <highlight><bold>840</bold></highlight> along with the packet is the same one <highlight><bold>614</bold></highlight> discussed in the description of an RX buffer <highlight><bold>620</bold></highlight> as shown in <cross-reference target="DRAWINGS">FIG. 7</cross-reference>, and may be relocated by software convention as described in the discussion of <cross-reference target="DRAWINGS">FIG. 7</cross-reference>. </paragraph>
<paragraph id="P-0300" lvl="0"><number>&lsqb;0300&rsqb;</number> The transmit status word <highlight><bold>806</bold></highlight> contains a flag indicating if the transmission was successful, and the reason for failure if the transmit was abandoned. This field is written only if MCSR&lsqb;TX_STAT&rsqb; is set, otherwise the fields <highlight><bold>806</bold></highlight> and <highlight><bold>808</bold></highlight> contain uninitialized data.  
<table-cwu id="TABLE-US-00002">
<number>2</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center">TABLE 2</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Ethernet TX Status Word</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="133PT" align="left"/>
<tbody valign="top">
<row>
<entry>Bits</entry>
<entry>Field</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>&lsqb;31&rsqb;</entry>
<entry>TX_OK</entry>
<entry>Packet was successfully transmitted.</entry>
</row>
<row>
<entry>&lsqb;30&rsqb;</entry>
<entry>LATE_COL</entry>
<entry>Transmit abandoned due to a late collision.</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>(only if (MCSR&lsqb;LATE_COL_RTRY&rsqb; &equals; 0))</entry>
</row>
<row>
<entry>&lsqb;29&rsqb;</entry>
<entry>XS_COL</entry>
<entry>Transmit abandoned due to excessive</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>collisions (16 collisions)</entry>
</row>
<row>
<entry>&lsqb;28&rsqb;</entry>
<entry>XS_DEFER</entry>
<entry>Transmit abandoned due to excessive</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>deferrals</entry>
</row>
<row>
<entry>&lsqb;27&rsqb;</entry>
<entry>UNDERFLOW</entry>
<entry>Transmit abandoned due to slow memory</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>response times.</entry>
</row>
<row>
<entry>&lsqb;26&rsqb;</entry>
<entry>GIANT</entry>
<entry>Packet length was larger than legal</entry>
</row>
<row>
<entry>&lsqb;25:22&rsqb;</entry>
<entry>COL_CNT&lsqb;3:0&rsqb;</entry>
<entry>Number of collisions experienced (never</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>shows more than 15; if XS_COL this value</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>is &lsquo;x&rsquo;)</entry>
</row>
<row>
<entry>&lsqb;21:11&rsqb;</entry>
<entry>reserved</entry>
<entry>MAC writes 0 &times; 0 to this field.</entry>
</row>
<row>
<entry>&lsqb;10:0&rsqb;</entry>
<entry>TX_SIZE&lsqb;10:0&rsqb;</entry>
<entry>Number of bytes transmitted (includes the</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>4-byte Ethernet CRC)</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0301" lvl="7"><number>&lsqb;0301&rsqb;</number> There are 5 possible transmit packet sources sharing the TX MAC; these are </paragraph>
<paragraph id="P-0302" lvl="2"><number>&lsqb;0302&rsqb;</number> The RISC processor (Policy Processor) generating or forwarding a packet has not yet dequeued. For the purposes of a TX Ring <highlight><bold>406</bold></highlight> or <highlight><bold>408</bold></highlight> this region consists of space into which more packets may be scheduled for transmit. One skilled in the art will recognized that region <highlight><bold>704</bold></highlight> or region <highlight><bold>706</bold></highlight> could just as easily be the region wrapping around the array boundary, depending on the values of MTRECOV <highlight><bold>712</bold></highlight>, MTCONS <highlight><bold>714</bold></highlight>, and MTPROD <highlight><bold>716</bold></highlight>. </paragraph>
<paragraph id="P-0303" lvl="0"><number>&lsqb;0303&rsqb;</number> Embedded in the buffer is the packet length in bytes (including the Ethernet header, but not including the CRC since the TX MAC will generate that) and also the byte offset within the buffer where the Ethernet header begins. The offset is necessary since the start of packet might have been moved back (if adding encapsulation headers) or forward (if decapsulating a packet.) The Ethernet header typically starts at byte offset 0x2 within that word, but the TX MAC supports arbitrary byte alignment. PKT_OFFSET and LENGTH are found in the &ldquo;RX Status&rdquo; and &ldquo;TX Command&rdquo; word of the buffer as described in Table 1; for transmit purposes those are the only two meaningful fields in that word. </paragraph>
<paragraph id="P-0304" lvl="0"><number>&lsqb;0304&rsqb;</number> The area labeled &ldquo;TX Status/TX Timestamp&rdquo; is optionally written with one word of transmit status plus the value of TIMER at the time the field is written, if MCSR&lsqb;TX_STAT&rsqb; is set; the content of that word is described in Table 2. </paragraph>
<paragraph id="P-0305" lvl="0"><number>&lsqb;0305&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference> illustrates the transmit buffer format according to certain embodiments of the present invention. </paragraph>
<paragraph id="P-0306" lvl="0"><number>&lsqb;0306&rsqb;</number> When a packet is scheduled through TX Ring <highlight><bold>406</bold></highlight> or <highlight><bold>408</bold></highlight> to be transmitted on a TX MAC <highlight><bold>218</bold></highlight> or <highlight><bold>234</bold></highlight>, respectively, the TX MAC controller <highlight><bold>222</bold></highlight> or <highlight><bold>232</bold></highlight>, respectively, interprets the contents of the packet buffer <highlight><bold>840</bold></highlight> in accordance with the format shown in <cross-reference target="DRAWINGS">FIG. 9</cross-reference>. The RX Status Word and TX Command Word <highlight><bold>802</bold></highlight> is found at the location pointed to by the 2 KB-aligned buffer pointer obtained from the TX Ring <highlight><bold>406</bold></highlight> or <highlight><bold>408</bold></highlight>. The RX Status and TX Command Word <highlight><bold>802</bold></highlight> is in the format specified by Table 1; when this word is interpreted by the TX MAC controller <highlight><bold>222</bold></highlight> or <highlight><bold>232</bold></highlight> only the fields LENGTH and PKT_OFFSET have any meaning and the rest of the word is ignored. PKT_OFFSET indicates the byte offset from the start of the 2 KB-aligned buffer at which the first byte of the Ethernet header is to be found, and LENGTH is the number of bytes to be transmitted not including the (4-byte) Ethernet CRC which the TX MAC <highlight><bold>222</bold></highlight> or <highlight><bold>232</bold></highlight> will generate and append to the packet as it is being transmitted. The RX Timestamp <highlight><bold>804</bold></highlight> was used by previous agents processing this buffer, and is not interpreted by the TX MAC controller <highlight><bold>222</bold></highlight> or <highlight><bold>232</bold></highlight>. </paragraph>
<paragraph id="P-0307" lvl="0"><number>&lsqb;0307&rsqb;</number> The PKT_OFFSET field can legitimately have any value between (16) and (255), allowing the agent that scheduled the transmit to manipulate headers and to relocate the start of the packet header <highlight><bold>812</bold></highlight> as needed. <cross-reference target="DRAWINGS">FIG. 9</cross-reference> shows a zero-filled two-byte pad <highlight><bold>830</bold></highlight> prior to the start of Ether Header <highlight><bold>812</bold></highlight>, but that is not a requirement of the preferred embodiment; the TX MAC <highlight><bold>222</bold></highlight> or <highlight><bold>232</bold></highlight> can transmit a packet which starts at any arbitrary byte alignment in the transmit buffer <highlight><bold>840</bold></highlight>. The two-byte pad <highlight><bold>830</bold></highlight> shown preceding the header <highlight><bold>812</bold></highlight> is shown to illustrate the common case, wherein a received packet was thus aligned and any movement of the ethernet header <highlight><bold>812</bold></highlight> for encapsulation or decapsulation of protocols is in units of words (4 bytes.) Pad Space <highlight><bold>810</bold></highlight> can vary in size from zero bytes to (240) bytes as defined by the value of PKT_OFFSET in the TX Command Word <highlight><bold>802</bold></highlight>. </paragraph>
<paragraph id="P-0308" lvl="0"><number>&lsqb;0308&rsqb;</number> The concatenation of Ether Header <highlight><bold>812</bold></highlight> and Payload <highlight><bold>814</bold></highlight> comprise the packet that is transmitted, along with the generated Ethernet CRC which the TX MAC <highlight><bold>222</bold></highlight> or <highlight><bold>232</bold></highlight> appends during transmit. The Ethernet CRC field <highlight><bold>816</bold></highlight> is not normally used by the TX MAC <highlight><bold>218</bold></highlight> or <highlight><bold>234</bold></highlight>, but was written there during receive by the RX MAC <highlight><bold>220</bold></highlight> or <highlight><bold>228</bold></highlight>. Each TX MAC controller <highlight><bold>222</bold></highlight> and <highlight><bold>232</bold></highlight> has a configuration setting which can instruct it to not generate CRC as it transmits; in that case the LENGTH field in the TX Command Word <highlight><bold>802</bold></highlight> includes the four bytes of Ethernet </paragraph>
<paragraph id="P-0309" lvl="2"><number>&lsqb;0309&rsqb;</number> Crypto generating a modified packet </paragraph>
<paragraph id="P-0310" lvl="2"><number>&lsqb;0310&rsqb;</number> The AP either creating, forwarding, or modifying a packet </paragraph>
<paragraph id="P-0311" lvl="2"><number>&lsqb;0311&rsqb;</number> A device in a PCI expansion slot creating, forwarding, or modifying a packet </paragraph>
<paragraph id="P-0312" lvl="2"><number>&lsqb;0312&rsqb;</number> A peer PE forwarding a packet to a different network segment (e.g. for routing or switching) </paragraph>
<paragraph id="P-0313" lvl="0"><number>&lsqb;0313&rsqb;</number> Atomic enqueueing by multiple sources is supported via writes to RTU&lsqb;MTPROD&rsqb; associated with that MAC&apos;s Transmit Ring. The RTU can detect high-water-mark conditions and signal the situation to the PP and the AP. The MTCONS index pointer is incremented by the MAC whenever a buffer is retired; that is chased by another consume pointer incremented by reads of RTU&lsqb;MTRECOV&rsqb; which is used by the PP for recover of retired packet buffers to the buffer pool and (optionally) checking TX status. </paragraph>
<paragraph id="P-0314" lvl="7"><number>&lsqb;0314&rsqb;</number> 4. Reclassify Rings </paragraph>
<paragraph id="P-0315" lvl="0"><number>&lsqb;0315&rsqb;</number> The Classification Engine receives packets to classify from both the RX MAC (via the RX Ring), and from other sources (PP, AP, Crypto, and potentially other network cards on the PCIbus). A second input ring (Reclassify Ring) is provided for each CE for these other sources to schedule a packet for classification on that CE; each comprises a ring in memory with enqueue and dequeue operations supported through the RTU. The 32-bit entries in the ring are buffer pointers. </paragraph>
<paragraph id="P-0316" lvl="0"><number>&lsqb;0316&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10</cross-reference> shows the reclassify ring structure. </paragraph>
<paragraph id="P-0317" lvl="0"><number>&lsqb;0317&rsqb;</number> The Reclassify Rings <highlight><bold>410</bold></highlight>, <highlight><bold>412</bold></highlight>, <highlight><bold>414</bold></highlight>, and <highlight><bold>416</bold></highlight> serve a very similar purpose to the RX Rings <highlight><bold>402</bold></highlight> and <highlight><bold>404</bold></highlight>, and have substantially the same structure. The substantive differences are that there is one less interim consumer-producer in the Reclassify Rings, and that packets get scheduled through the Reclassify Rings via a different path. Reclassify Rings <highlight><bold>410</bold></highlight>, <highlight><bold>412</bold></highlight>, <highlight><bold>414</bold></highlight>, and <highlight><bold>416</bold></highlight> are used to schedule packets for processing on CE <highlight><bold>238</bold></highlight>, <highlight><bold>208</bold></highlight>, <highlight><bold>242</bold></highlight>, and <highlight><bold>212</bold></highlight> respectively. </paragraph>
<paragraph id="P-0318" lvl="0"><number>&lsqb;0318&rsqb;</number> In the case of the RX Ring <highlight><bold>402</bold></highlight> or <highlight><bold>404</bold></highlight>, buffer pointers are enqueued by the Buffer Allocation process <highlight><bold>102</bold></highlight> running on the Policy Processor <highlight><bold>244</bold></highlight> using MPROD <highlight><bold>518</bold></highlight>, which allocates the referenced buffers as free and empty for the RX MAC <highlight><bold>220</bold></highlight> or <highlight><bold>228</bold></highlight>, respectively, to consume using MFILL <highlight><bold>516</bold></highlight> when receiving a packet and to produce a full, unclassified buffer to the CE <highlight><bold>238</bold></highlight> or <highlight><bold>242</bold></highlight>, respectively. Packets scheduled for classification via the Reclassify Rings <highlight><bold>410</bold></highlight>, <highlight><bold>412</bold></highlight>, <highlight><bold>414</bold></highlight>, and <highlight><bold>416</bold></highlight> come from a source other than the RX MAC&apos;s <highlight><bold>220</bold></highlight> or <highlight><bold>228</bold></highlight>, as illustrated in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>. Full, unclassified buffers get scheduled onto one of the Reclassify Rings when an agent enqueues the buffer pointer onto the ring by writing the buffer pointer to the RTU&apos;s <highlight><bold>264</bold></highlight> enqueue address, which causes the RTU <highlight><bold>264</bold></highlight> to write the buffer pointer to the location in memory <highlight><bold>260</bold></highlight> referenced by RPROD <highlight><bold>916</bold></highlight> and then to increment RPROD <highlight><bold>916</bold></highlight> modulo the ring size of 4096 bytes. </paragraph>
<paragraph id="P-0319" lvl="0"><number>&lsqb;0319&rsqb;</number> From that point onward the description is substantially the same as the description of the RX Ring <highlight><bold>402</bold></highlight> and <highlight><bold>404</bold></highlight>, except that RCCONS <highlight><bold>914</bold></highlight> is used in place of MCCONS <highlight><bold>514</bold></highlight>, RPCONS <highlight><bold>912</bold></highlight> is used in place of MPCONS <highlight><bold>512</bold></highlight>, the invalid region <highlight><bold>902</bold></highlight> and <highlight><bold>908</bold></highlight> substitutes for <highlight><bold>500</bold></highlight> and <highlight><bold>508</bold></highlight>, Full and Classified <highlight><bold>904</bold></highlight> substitutes for <highlight><bold>502</bold></highlight>, and Full Unclassified <highlight><bold>906</bold></highlight> replaces <highlight><bold>504</bold></highlight>. Since this flow has no allocation of empty buffers there is no equivalent to MFILL <highlight><bold>516</bold></highlight> nor to Valid Empty <highlight><bold>506</bold></highlight>. </paragraph>
<paragraph id="P-0320" lvl="0"><number>&lsqb;0320&rsqb;</number> Note that the &ldquo;Outbound&rdquo; classifiers <highlight><bold>208</bold></highlight> and <highlight><bold>212</bold></highlight> each have only a Reclassify Ring <highlight><bold>412</bold></highlight> and <highlight><bold>416</bold></highlight>, respectively, but no RX Ring since they are not associated with an RX MAC. </paragraph>
<paragraph id="P-0321" lvl="7"><number>&lsqb;0321&rsqb;</number> 5. Crypto Command Queue and General Purpose Communications Rings </paragraph>
<paragraph id="P-0322" lvl="0"><number>&lsqb;0322&rsqb;</number> In order to schedule buffers for processing by the external (and optional) encryption engine another memory-based ring containing buffer pointers is implemented, with enqueue and dequeue operations supported through the RTU for the Crypto unit to get the next buffer to process, plus a status bit indicating to Crypto that there is at least one packet buffer pointer in the ring to process. The information about what operations to perform, keys, etc. are embedded in a Crypto Command Descriptor in the software area of the buffer. </paragraph>
<paragraph id="P-0323" lvl="0"><number>&lsqb;0323&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 11</cross-reference> shows the Crypto Ring and COM&lsqb;4:0&rsqb; Rings Structures. </paragraph>
<paragraph id="P-0324" lvl="0"><number>&lsqb;0324&rsqb;</number> The Crypto Ring <highlight><bold>420</bold></highlight>, COM0 Ring <highlight><bold>422</bold></highlight>, COM1 Ring <highlight><bold>424</bold></highlight>, COM2 Ring <highlight><bold>426</bold></highlight>, COM3 Ring <highlight><bold>428</bold></highlight>, and COM4 Ring <highlight><bold>430</bold></highlight> are identical in structure. Any agent can enqueue a buffer pointer or, in the case of the COM Rings, any 32-bit datum, by writing to the RTU&apos;s <highlight><bold>264</bold></highlight> enqueue address associated with the particular ring. This causes the RTU to store the buffer pointer or 32-bit datum to the location in memory <highlight><bold>260</bold></highlight> referenced by the specified PRODUCE Pointer <highlight><bold>1010</bold></highlight> and then to increment PRODUCE <highlight><bold>1010</bold></highlight> modulo the ring size of 4096 bytes. There is a producer-consumer relationship between a particular ring&apos;s PRODUCE pointer <highlight><bold>1010</bold></highlight> and that ring&apos;s CONSUME pointer <highlight><bold>1008</bold></highlight>. When the RTU detects a difference between the values of PRODUCE <highlight><bold>1010</bold></highlight> and CONSUME <highlight><bold>1008</bold></highlight> it signals to the consuming unit that there is at least one entry to be consumed. </paragraph>
<paragraph id="P-0325" lvl="0"><number>&lsqb;0325&rsqb;</number> The consumer dequeues a 32-bit entry from one of these rings by reading from the RTU&apos;s dequeue address associated with that particular ring; this causes the RTU to return the data at the address in memory <highlight><bold>260</bold></highlight> referenced by that CONSUME pointer <highlight><bold>1008</bold></highlight> and then to increment CONSUME <highlight><bold>1008</bold></highlight> modulo the ring size of 4096 bytes. As is illustrated here, the degenerate case of the multiple-producer, multiple-consumer ring structure described in <cross-reference target="DRAWINGS">FIGS. 6, 8</cross-reference>, and <highlight><bold>10</bold></highlight> is a single-producer, single-consumer FIFO with fifo-not-empty status presented to the consumer. The COM rings <highlight><bold>422</bold></highlight>, <highlight><bold>424</bold></highlight>, <highlight><bold>426</bold></highlight>, and <highlight><bold>428</bold></highlight> all report ring-not-empty status and (programmably per ring) either near-full or near-empty threshold status to the Policy Processor <highlight><bold>244</bold></highlight> through status registers in the processor interface <highlight><bold>206</bold></highlight>. These rings can be assigned for any purpose; anticipated uses include a message-in ring for the Policy Processor <highlight><bold>244</bold></highlight>, a ring for allocating buffers for use by remote agents, and a ring for allocating DMA descriptors for use by remote agents scheduling this Policy Engine&apos;s DMA Unit <highlight><bold>210</bold></highlight>. </paragraph>
<paragraph id="P-0326" lvl="0"><number>&lsqb;0326&rsqb;</number> The Crypto Ring <highlight><bold>420</bold></highlight> reports ring-not-empty status to the Crypto Processor <highlight><bold>246</bold></highlight> through a status register in Crypto Interface <highlight><bold>202</bold></highlight>. COM4 <highlight><bold>430</bold></highlight> also reports ring-not-empty status through a similar location, so that COM4 <highlight><bold>430</bold></highlight> can optionally be used to support scheduling packets for processing by a second Crypto Processor <highlight><bold>246</bold></highlight>. The Crypto Processor Interface <highlight><bold>202</bold></highlight> has additional support for a second Crypto Processor <highlight><bold>246</bold></highlight>, which might be added to provide either more bandwidth for encryption processing or additional functionality such as compression. Packets would be scheduled for processing on this second processor <highlight><bold>246</bold></highlight> by enqueueing their buffer pointers onto COM4 <highlight><bold>430</bold></highlight>. Alternatively, both the Crypto Ring <highlight><bold>420</bold></highlight> and COM4 <highlight><bold>430</bold></highlight> can be used to schedule buffers for processing on the one Crypto processor <highlight><bold>246</bold></highlight>. </paragraph>
<paragraph id="P-0327" lvl="0"><number>&lsqb;0327&rsqb;</number> The general purpose communication rings COM&lsqb;4:0&rsqb; <highlight><bold>422</bold></highlight>, <highlight><bold>424</bold></highlight>, <highlight><bold>426</bold></highlight>, <highlight><bold>428</bold></highlight>, and <highlight><bold>430</bold></highlight> are identical in structure to the Crypto Ring <highlight><bold>420</bold></highlight>. </paragraph>
<paragraph id="P-0328" lvl="7"><number>&lsqb;0328&rsqb;</number> 6 DMA Command Queue and Descriptors </paragraph>
<paragraph id="P-0329" lvl="0"><number>&lsqb;0329&rsqb;</number> The DMA engine also uses a ring unit with an Enqueue register for any agent to schedule DMA transfers (DMA_PROD), a Consume register for the DMA engine to get entries from the ring (DMA_CONS), and a Dequeue register for recovering retired descriptors (and the associated buffers) from the ring (DMA_RECOV). </paragraph>
<paragraph id="P-0330" lvl="0"><number>&lsqb;0330&rsqb;</number> The DMA engine is used to move data between the memory and the PCIbus; the source/target on PCI can be host (AP) memory or another PCI device. DMA operations are scheduled by creating a 16-byte descriptor in memory and then enqueueing the address of that descriptor in the DMA engine&apos;s command ring by writing it to DMA_PROD. The PP, the host, a PCI bus peer, and Crypto can atomically schedule use of this engine. </paragraph>
<paragraph id="P-0331" lvl="0"><number>&lsqb;0331&rsqb;</number> DMA is notified by the RTU when the Produce pointer is not equal to the Consume pointer and processes the next descriptor. When that descriptor is retired, DMA increments the Consume pointer; a delta between that and the Recover pointer causes the RTU to signal to the PP that there are DMA descriptors (and the associated buffer pointers) to recover.  
<table-cwu id="TABLE-US-00003">
<number>3</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center">TABLE 3</entry>
</row>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>DMA Descriptor Format</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>PCI_Address &lsqb;31:00&rsqb;</entry>
</row>
<row>
<entry>Flags &lsqb;31:0&rsqb;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="91PT" align="center"/>
<colspec colname="3" colwidth="84PT" align="left"/>
<tbody valign="top">
<row>
<entry>S1&lsqb;31:27&rsqb;</entry>
<entry>Buf_Address &lsqb;26:11&rsqb;</entry>
<entry>S2&lsqb;10:0&rsqb;(pointer tag field)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="77PT" align="left"/>
<colspec colname="3" colwidth="21PT" align="left"/>
<colspec colname="4" colwidth="77PT" align="left"/>
<tbody valign="top">
<row>
<entry>S3&lsqb;15:11&rsqb;</entry>
<entry>Buf_Start_Index &lsqb;10:2&rsqb;</entry>
<entry>0b00</entry>
<entry>Word_Count&lsqb;15:0&rsqb;</entry>
</row>
<row><entry namest="1" nameend="4" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0332" lvl="7"><number>&lsqb;0332&rsqb;</number> The areas labeled &ldquo;S2&rdquo; and &ldquo;S3&rdquo; are available for software use. &ldquo;S1&rdquo; is reserved for future expansion of PE memory size. </paragraph>
<paragraph id="P-0333" lvl="0"><number>&lsqb;0333&rsqb;</number> Upon completion of a transfer, the DMA engine can optionally set a completion status bit in either the Host Interrupt Register or Processor Interrupt Status Register in case the initiating agent wants completion status of a transfer or group of transfers. 8 bits are provided in each so that transfers can be tagged as desired. This allows both AP and PP software to have up to 8 DMA completion events scheduled at one time for tracking when particular groups of transfers have completed, or for the PP to signal to the AP that information has been pushed up to a mailbox or communication ring in AP memory, or for similar signals from the AP to the PP. </paragraph>
<paragraph id="P-0334" lvl="0"><number>&lsqb;0334&rsqb;</number> The Packet Buffer Address field contains the packet buffer pointer in the same format that is used by all other agents in the Policy Engine; this means that bits &lsqb;10:0&rsqb; are ignored by hardware and might contain tag information. The actual memory word address is the concatenation of the 2 KB-aligned Packet_Buffer_Address&lsqb;31:11&rsqb; with Start_Index&lsqb;10:2&rsqb;, with 00 in the lower two bits. Note that the Word_Count allows for a maximum DMA transfer of (64K-1 Words, or 256K-4 Bytes), in case there are transfers larger than normal packet buffer movement (e.g. moving down PP code or CE microcode). </paragraph>
<paragraph id="P-0335" lvl="0"><number>&lsqb;0335&rsqb;</number> The Flags word contains the following fields:  
<table-cwu id="TABLE-US-00004">
<number>4</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="378PT" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center">TABLE 3a</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>DMA Descriptor &ldquo;Flags&rdquo; Word</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="63PT" align="left"/>
<colspec colname="3" colwidth="280PT" align="left"/>
<tbody valign="top">
<row>
<entry>Bits</entry>
<entry>Field</entry>
<entry>Descriptions</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>&lsqb;31:21&rsqb;</entry>
<entry>SOFT&lsqb;10:0&rsqb;</entry>
<entry>Available for software use.</entry>
</row>
<row>
<entry>&lsqb;20&rsqb;</entry>
<entry>TO_MEM</entry>
<entry>Direction: 1 &equals; To Memory (From PCI), 0 &equals; From Memory (To PCI)</entry>
</row>
<row>
<entry>&lsqb;19:16&rsqb;</entry>
<entry>PCI_CMD&lsqb;3:0&rsqb;</entry>
<entry>This is the PCI command code which is used on the PCI bus for these transactions; the most</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>common codes will be 0&times;7 (Memory Write) and 0&times;6 (Memory Read) with some probability</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>of also using 0&times;C (Memory Read Multiple) and 0&times;E (Memory Read Line) if the attached</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>host uses them for prefetch directives.</entry>
</row>
<row>
<entry>&lsqb;15:08&rsqb;</entry>
<entry>SET_HISR&lsqb;7:0&rsqb;</entry>
<entry>Any bit that is set will set the corresponding status bit in the HISR upon retirement of this</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>descriptor. If no bit is set, no status is sent to HISR.</entry>
</row>
<row>
<entry>&lsqb;07:00&rsqb;</entry>
<entry>SET_PISR&lsqb;7:0&rsqb;</entry>
<entry>Any bit that is set will set the corresponding status bit in the PISR upon retirement of this</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>descriptor. If no bit is set, no status is sent to PISR.</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0336" lvl="7"><number>&lsqb;0336&rsqb;</number> Since DMA descriptors are read from memory by the DMA engine, software must ensure either that the descriptors were non-cacheable by the processor, or that they are flushed from the PP cache prior to writing the descriptor&apos;s address to the DMA ring. For descriptors that are generated by the AP or by a PCI peer see &ldquo;Endianness&rdquo; in section 8 for details about descriptor endianness. </paragraph>
<paragraph id="P-0337" lvl="0"><number>&lsqb;0337&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 12</cross-reference> shows the DMA Ring Structure. </paragraph>
<paragraph id="P-0338" lvl="0"><number>&lsqb;0338&rsqb;</number> The DMA Ring <highlight><bold>418</bold></highlight> is substantially the same as the TX Rings <highlight><bold>406</bold></highlight> and <highlight><bold>408</bold></highlight> as described in <cross-reference target="DRAWINGS">FIG. 8</cross-reference>. There is a single enqueue index DMA_PROD <highlight><bold>1116</bold></highlight> used to schedule pointers on the ring <highlight><bold>418</bold></highlight> by any agent, and interim consumer-producer index DMA_CONS <highlight><bold>1114</bold></highlight> used by the DMA Unit <highlight><bold>120</bold></highlight> to consume newly scheduled descriptor pointers and to produce retired descriptor pointers, and a dequeue index DMA_RECOV <highlight><bold>1112</bold></highlight> used by the Policy Processor <highlight><bold>244</bold></highlight> to recover retired descriptors as well as the buffers associated with them using the buffer pointer embedded in the DMA descriptor being recovered. Differences between DMA_PROD <highlight><bold>1116</bold></highlight> and DMA_CONS <highlight><bold>1114</bold></highlight> are detected by the RTU <highlight><bold>264</bold></highlight> and reported to the DMA Unit <highlight><bold>120</bold></highlight>. Differences between DMA_CONS <highlight><bold>1114</bold></highlight> and DMA_RECOV <highlight><bold>1112</bold></highlight> are reported by the RTU <highlight><bold>264</bold></highlight> to the Policy Processor <highlight><bold>244</bold></highlight> through a status bit in the Processor Interface <highlight><bold>206</bold></highlight>. Region <highlight><bold>1106</bold></highlight> contains one or more descriptor pointers which point to DMA descriptors as described in Table 3. Region <highlight><bold>1104</bold></highlight> contains the descriptor pointers of descriptors which have been retired by DMA <highlight><bold>120</bold></highlight> but have not yet been recovered by Buffer Recovery <highlight><bold>118</bold></highlight>. Invalid <highlight><bold>1102</bold></highlight> and <highlight><bold>1108</bold></highlight> are the unused space into which more pointers can be scheduled. </paragraph>
<paragraph id="P-0339" lvl="7"><number>&lsqb;0339&rsqb;</number> 7. Buffer Allocation/Flow </paragraph>
<paragraph id="P-0340" lvl="0"><number>&lsqb;0340&rsqb;</number> At initialization time the software allocates a pool of size-aligned 2 KB buffers in memory. Enough of these are allocated to each of the RX rings (that is, the buffer pointers are enqueued on those rings by writing them to the associated RTU&lsqb;MPROD&rsqb;) to provide the desired elasticity for the RX MAC, and the rest are placed on a freelist (e.g. on a software-managed linked list.) Each time the PP dequeues a buffer from the RX ring it can allocate a new empty buffer from the freelist, thus keeping the pool size constant Buffers that go through Crypto may be enqueued by any agent and are dequeued by the Crypto Processor which will then enqueue them on the specified destination ring after processing. Buffers that are scheduled for DMA are recovered at the same time the associated DMA descriptor is recovered from the ring. Buffers may be temporarily absorbed by an application if it is queueing packets for delay. A reference count can be maintained in buffers which go to multiple readers so that they retire only when all readers have retired them. </paragraph>
<paragraph id="P-0341" lvl="0"><number>&lsqb;0341&rsqb;</number> The goal is that the PP can handle buffer allocation and recovery through the read of status bits in the PISR, reads of RTU recover or dequeue addresses to recover retired buffers when the RTU indicates through the PISR that the particular rings have buffers to recover, and writes to ring RTU enqueue addresses to allocate new buffers. It is a primary goal that copying of buffers is avoided except when absolutely necessary. </paragraph>
<paragraph id="P-0342" lvl="0"><number>&lsqb;0342&rsqb;</number> Rings report threshold warnings to the PP/AP through the CRISIS register when there is danger of under/overflowing (within &frac14; ring-size of a problem situation) and also report full/empty status of rings through bits in the CRISIS Register as appropriate. </paragraph>
<paragraph id="P-0343" lvl="0"><number>&lsqb;0343&rsqb;</number> 7.1 The Life of an RX Packet Buffer </paragraph>
<paragraph id="P-0344" lvl="0"><number>&lsqb;0344&rsqb;</number> Ideally, a packet arrives into a buffer, gets processed, and then gets transmitted out the other port or gets dropped. Processing may include a decision by the application to enqueue the buffer for temporary delay (and possible later dropping), to feed a packet through the local optional Crypto for encryption work, or to pass a packet to the AP or external coprocessor (see <cross-reference target="DRAWINGS">FIG. 4</cross-reference>). The key concept is to think of a packet as being &ldquo;owned&rdquo; by some agent, and that agent taking responsibility for the final disposition of the packet. </paragraph>
<paragraph id="P-0345" lvl="0"><number>&lsqb;0345&rsqb;</number> 7.2 Flow of a Buffer Which Remains Local </paragraph>
<paragraph id="P-0346" lvl="0"><number>&lsqb;0346&rsqb;</number> At the beginning of time the system allocates a number of buffers to an RX MAC by writing their pointers into that RX Ring&apos;s RTU&lsqb;MPROD&rsqb; enqueue register, which presents these buffers to that MAC as empty/allocated. These buffers are now owned by that RX MAC, and cannot be touched by others until the MAC has so indicated. When the RX MAC has filled a buffer with a newly received packet it passes ownership to the associated Classification Engine by moving the MFILL pointer to the next entry (buffer pointer) in the ring. The CE will detect this, then process that packet; when it is done it passes ownership to the PP by incrementing the MCCONS index modulo ring size, and then the application(s) running on the PP will determine what action(s) to take. Ownership of a buffer is always explicitly relinquished by the current owner. </paragraph>
<paragraph id="P-0347" lvl="0"><number>&lsqb;0347&rsqb;</number> The PP can perform any conventional actions with a buffer. Examples of actions for a buffer which remains entirely local are DROP, FORWARD, MODIFY or temporarily ENQUEUE then later FORWARD. </paragraph>
<paragraph id="P-0348" lvl="0"><number>&lsqb;0348&rsqb;</number> DROP: The code running on the PP determines that there are no further uses for the contents of this buffer, so it retires/recovers the buffer. Typically this occurs when the Action portion of the application(s) running on the PP decide that a packet does not meet the criteria for passing it forward. </paragraph>
<paragraph id="P-0349" lvl="0"><number>&lsqb;0349&rsqb;</number> FORWARD: The PP enqueues the pointer onto the appropriate TX ring; TX is fire-and-forget (with optional completion status from the MAC), with the hardware responsible for either completing or abandoning the transmit (that is, the TX MAC owns that buffer). Some time later in the buffer reclaimation code, the PP will recognize that the TX MAC has retired this packet (is done with it) since the RTU indicates that there is a delta between MTCONS and MTRECOV, thus ownership of that buffer has transferred back to the PP. The PP then checks TX completion status (if the application(s) care) and recovers the buffer or reschedules the transmit as appropriate. </paragraph>
<paragraph id="P-0350" lvl="0"><number>&lsqb;0350&rsqb;</number> MODIFY: The application may choose to send the packet through Crypto for processing, may encapsulate/decapsulate the packet, could do address translation, or can do any other modification of the packet that the application directs. </paragraph>
<paragraph id="P-0351" lvl="0"><number>&lsqb;0351&rsqb;</number> ENQUEUE: The application running on the PP determines that it wants to hold on to the packet for some period of time, after which it will either forward or drop it. Ownership of that buffer stays with the application until it relinquishes it by enqueuing the buffer&apos;s pointer on the appropriate TX or Reclassify ring, or by deciding to DROP it, in which case the same path as DROP (above) is followed. In the Enqueue case the average residency of a packet in a memory buffer is much longer than in the simple DROP or FORWARD cases, so if applications are enqueueing packets then care must be taken to allocate a large enough buffer pool. </paragraph>
<paragraph id="P-0352" lvl="0"><number>&lsqb;0352&rsqb;</number> 7.3 Buffer Handling for Packets Sent to the PCI Bus </paragraph>
<paragraph id="P-0353" lvl="0"><number>&lsqb;0353&rsqb;</number> The applications(s) on the PP may decide that a packet should be forwarded to the AP either for further processing or because the packet is actually targeted at the AP as the final destination In either case it is necessary to migrate the packet to buffers in the AP&apos;s memory (e.g. into mbufs in the stack running there or into application-specific storage.) The buffer itself is not migrated, some or all of its contents are copied to a different buffer in host memory; this is done using the DMA engine. </paragraph>
<paragraph id="P-0354" lvl="0"><number>&lsqb;0354&rsqb;</number> Alternatively the application could choose to store the packet locally (that is, maintain ownership of the buffer) and simply pass a pointer and other information up to the AP. In this case the PP cannot reclaim the buffer until the AP has informed the PP that ownership of the buffer has been released back to the PP. </paragraph>
<paragraph id="P-0355" lvl="0"><number>&lsqb;0355&rsqb;</number> Other reasons for sending packets up to the PCI bus include a push-model peer-to-peer copy to a different Policy Engine or external coprocessor, and logging of selected packets at the AP. The latter is interesting because it may involve a fork where a packet takes two paths; one to a MAC transmit queue, and a second to the PCI bus; reclaimation of that buffer would require a convergence of completion, that is, a &ldquo;join&rdquo; function before the buffer can be reclaimed (if copying is to be avoided.) Software can maintain a reference count in the buffer for this purpose. </paragraph>
<paragraph id="P-0356" lvl="0"><number>&lsqb;0356&rsqb;</number> Forwarding a packet to the AP can be in the guise of NIC-like behavior or for application-specific communication. In either case the packet&apos;s buffer pointer is written to a DMA descriptor as the MEM_ADDR, and after the rest of the DMA descriptor is created the pointer to that descriptor is enqueued on the DMA engine&apos;s command queue. As with all other queues described so far, the PP has a trailing recover pointer DMA_RECOV and receives status in the PISR from the RTU when there are retired descriptors to recover. </paragraph>
<paragraph id="P-0357" lvl="0"><number>&lsqb;0357&rsqb;</number> The &ldquo;NIC&rdquo; interface as seen in host memory can be arbitrarily complex, but can be as simple as a memory image consisting of a buffer pool and pointer ring with a produce and a consume pointer, all in host memory; the &ldquo;RX NIC interface&rdquo; can mean reading a pointer to a free buffer, DMAing the entire packet buffer to that location, following that with a DMA of a new value to the &ldquo;Produce&rdquo; pointer associated with it, and an interrupt to the host (using one of the bits HISR&lsqb;DMA DONE&lsqb;7:0&rsqb;&rsqb;) upon completion of that DMA. More efficient host structures can be implemented without much more complexity. Communication down from the AP can also use the DMA engine and can involve a similar software ring structure in either host or PE memory; messages and/or ring indexes are written by the AP into one of the 16 Mailbox locations provided, which write data to PE memory and set a per-mailbox status bit which signals mailbox status through the PISR to the PP. </paragraph>
<paragraph id="P-0358" lvl="0"><number>&lsqb;0358&rsqb;</number> A peer-to-peer routing operation with a push model might require a buffer pool in PE memory to be allocated for each peer that will be doing this; then sending a packet to another Policy Engine for transmit is as simple as scheduling a DMA to copy the data from the local buffer to a buffer in this PE&apos;s buffer pool on the remote PE, followed by a DMA of the pointer to that buffer (in the &ldquo;local&rdquo; pointer format) into RTU&lsqb;MTPROD&rsqb; to schedule it for transmit. Later the remote PP will reclaim the buffer some time after the transmit is done, and will send back the pointer (or a &ldquo;credit&rdquo; message) by DMA&apos;ing it to this PP&apos;s &ldquo;freelist&rdquo; ring for that particular peer. </paragraph>
<paragraph id="P-0359" lvl="0"><number>&lsqb;0359&rsqb;</number> Another more general method of allocating buffers and DMA descriptors to remote masters is to assign one of the generalpurpose COM rings to contain a freelist of buffer pointers, and a second to contain a freelist of DMA descriptor pointers; any remote master desiring to push data could then simply read the two rings to obtain both a target buffer and a DMA descriptor for scheduling a fill of that buffer. </paragraph>
<paragraph id="P-0360" lvl="0"><number>&lsqb;0360&rsqb;</number> A &ldquo;pull&rdquo; model of communication would have the remote master send only a (PCI) pointer or a descriptor down through either a mailbox or a COM ring allocated for this function, and require the PP to select a buffer from its own pool of buffers allocated for this purpose, using DMA to copy the buffer from the remote memory into local memory, then taking whatever actions are specified for that packet. Ownership of the actual buffer in this case always belongs to the PP. </paragraph>
<paragraph id="P-0361" lvl="7"><number>&lsqb;0361&rsqb;</number> 7.4 Placement of the Software Structure in the Buffer </paragraph>
<paragraph id="P-0362" lvl="0"><number>&lsqb;0362&rsqb;</number> While the hardware defines the location of the receive and transmit control and status words and the location of the packet in the packet buffer, it is only by convention that the software structure resides forward from the 2 KB-aligned buffer pointer. A different convention can be used where the software structure of N bytes actually begins N bytes before the 2 KB-aligned buffer pointer; in this case the buffers managed and allocated by software are actually (2 KB&minus;N)-byte aligned, and the RX status word is placed N bytes into the buffer, which lands it precisely on the 2 KB-aligned word where it already goes; hardware doesn&apos;t know the difference, but software can take advantage of such a structure to allow for arbitrary-sized packets from any media, which start forward from the RX status word just like the ethernet packet but may occupy contiguous memory far bigger than an ethernet packet would. By placing the software structure before the RX status word, the structure does not have to be moved to accommodate larger packets. </paragraph>
<paragraph id="P-0363" lvl="7"><number>&lsqb;0363&rsqb;</number> 8. Endianness </paragraph>
<paragraph id="P-0364" lvl="7"><number>&lsqb;0364&rsqb;</number> 8.1 Overview </paragraph>
<paragraph id="P-0365" lvl="0"><number>&lsqb;0365&rsqb;</number> Internal to the Policy Engine ASIC, all agents are big-endian. This includes the MACs, memory, the CEs, the Policy Processor, the Crypto port, and the DMA engine descriptor format. This choice is most convenient for dealing with protocol headers, which are typically big-endian native. The CE itself has no endianness since it works only in units of 32 bits throughout; however, it does deal with multibyte data in the way those words are formatted in memory, thus it sees the big-endian layout of the packet buffer contents and also writes its status words and hash pointers in big-endian format, which is what the PP expects to see. </paragraph>
<paragraph id="P-0366" lvl="0"><number>&lsqb;0366&rsqb;</number> All PIO accesses from PCI to registers (PCI address range recognized by BAR1) are required to be 32-bit access only. The registers connect to the PCI bus so that bit&lt;0&gt; of the host CPU register is bit&lt;0&gt; of the PE register, and bit&lt;31&gt; corresponds to bit&lt;31&gt;. This implies that bit&lt;0&gt; of a register access travels on bit&lt;0&gt; of the PCIbus. Registers are placed on doubleword boundaries but are accessed as words, and the data travels on bits&lt;31:0&gt; of the PCI bus even if the bus is connecting 64-bit agents. As word-only entities the registers have no byte order issue. The same is true of PCI Configuration Register accesses. </paragraph>
<paragraph id="P-0367" lvl="0"><number>&lsqb;0367&rsqb;</number> All transfers between memory and the PCIbus move data by byte lane; this means that byte&lt;0&gt; in memory travels on byte&lt;0&gt; on the PCIbus, byte&lt;1&gt; on byte&lt;1&gt;, etc. This is endian-neutral for byte streams. This applies to all DMA activity, to PIO accesses from the PCIbus to/from memory, and also reads and writes from PCI through the Ring Translation Unit; the rings are simply memory with fancy address translation.  
<table-cwu id="TABLE-US-00005">
<number>5</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="336PT" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center">TABLE 4</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Byte Lane Steering, PCI64-to-Memory</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="8">
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="42PT" align="left"/>
<colspec colname="4" colwidth="42PT" align="left"/>
<colspec colname="5" colwidth="42PT" align="left"/>
<colspec colname="6" colwidth="42PT" align="left"/>
<colspec colname="7" colwidth="42PT" align="left"/>
<colspec colname="8" colwidth="42PT" align="left"/>
<tbody valign="top">
<row>
<entry>(byte 7)</entry>
<entry>(byte 6)</entry>
<entry>(byte 5)</entry>
<entry>(byte 4)</entry>
<entry>(byte 3)</entry>
<entry>(byte 2)</entry>
<entry>(byte 1)</entry>
<entry>(byte 0)</entry>
</row>
<row><entry namest="1" nameend="8" align="center" rowsep="1"></entry>
</row>
<row>
<entry>PCI&lsqb;63:56&rsqb;</entry>
<entry>PCI&lsqb;55:48&rsqb;</entry>
<entry>PCI&lsqb;47:40&rsqb;</entry>
<entry>PCI&lsqb;39:32&rsqb;</entry>
<entry>PCI&lsqb;31:24&rsqb;</entry>
<entry>PCI&lsqb;23:16&rsqb;</entry>
<entry>PCI&lsqb;15:8&rsqb;</entry>
<entry>PCI&lsqb;7:0&rsqb;</entry>
</row>
<row>
<entry>M&lsqb;7:0&rsqb;</entry>
<entry>M&lsqb;15:8&rsqb;</entry>
<entry>M&lsqb;23:16&rsqb;</entry>
<entry>M&lsqb;31:24&rsqb;</entry>
<entry>M&lsqb;39:32&rsqb;</entry>
<entry>M&lsqb;47:40&rsqb;</entry>
<entry>M&lsqb;55:48&rsqb;</entry>
<entry>M&lsqb;63:56&rsqb;</entry>
</row>
<row><entry namest="1" nameend="8" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0368" lvl="0"><number>&lsqb;0368&rsqb;</number>  
<table-cwu id="TABLE-US-00006">
<number>6</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="273PT" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center">TABLE 5</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Byte Lane Steering, PCI32-to-Mem</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="5">
<colspec colname="OFFSET" colwidth="105PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="42PT" align="left"/>
<colspec colname="4" colwidth="42PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>(byte 3)</entry>
<entry>(byte 2)</entry>
<entry>(byte 1)</entry>
<entry>(byte 0)</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="4" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="5">
<colspec colname="1" colwidth="105PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="42PT" align="left"/>
<colspec colname="4" colwidth="42PT" align="left"/>
<colspec colname="5" colwidth="42PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>PCI&lsqb;31:24&rsqb;</entry>
<entry>PCI&lsqb;23:16&rsqb;</entry>
<entry>PCI&lsqb;15:8&rsqb;</entry>
<entry>PCI&lsqb;7:0&rsqb;</entry>
</row>
<row>
<entry>First data phase (or word at 0&times;0)</entry>
<entry>M&lsqb;39:32&rsqb;</entry>
<entry>M&lsqb;47:40&rsqb;</entry>
<entry>M&lsqb;55:48&rsqb;</entry>
<entry>M&lsqb;63:56&rsqb;</entry>
</row>
<row>
<entry>Second data phase (or word at 0x4)</entry>
<entry>M&lsqb;7:0&rsqb;</entry>
<entry>M&lsqb;15:8&rsqb;</entry>
<entry>M&lsqb;23:16&rsqb;</entry>
<entry>M&lsqb;31:24&rsqb;</entry>
</row>
<row><entry namest="1" nameend="5" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0369" lvl="7"><number>&lsqb;0369&rsqb;</number> This byte-lane steering has some interesting implications that need to be understood so that it is clear when software will have to twist data. Four interesting cases will be examined: (a) the host writing a DMA descriptor into memory for the DMA engine to consume, (b) the host writing a message to the PP in memory, (c) the PP writing a message in memory that is DMA&apos;d to host memory, and (d) issues surrounding loading of CMEM in the four CE&apos;s. </paragraph>
<paragraph id="P-0370" lvl="7"><number>&lsqb;0370&rsqb;</number> 8.2 Host Writing a DMA Descriptor in Memory </paragraph>
<paragraph id="P-0371" lvl="0"><number>&lsqb;0371&rsqb;</number> The DMA descriptor is not a byte stream, therefore the endian-neutral PIO from the host to memory is not sufficient. The DMA engine sees the descriptor as a 16-byte, 16-byte-aligned big-endian data structure as shown in Table 3 on page 22. For this example the fields are simplified into a 32-bit PCI address PA, a 32-bit Buffer Address BA, a 16-bit offset OF, a 16-bit Word Count WC, and a 32-bit Flag word F. </paragraph>
<paragraph id="P-0372" lvl="0"><number>&lsqb;0372&rsqb;</number> Here is the big-endian view of that descriptor as it appears in memory and as the DMA engine interprets it:  
<table-cwu id="TABLE-US-00007">
<number>7</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="315PT" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center">TABLE 6</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>DMA Descriptor Byte Order, big endian memory</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="8">
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="42PT" align="left"/>
<colspec colname="4" colwidth="42PT" align="left"/>
<colspec colname="5" colwidth="35PT" align="left"/>
<colspec colname="6" colwidth="35PT" align="left"/>
<colspec colname="7" colwidth="42PT" align="left"/>
<colspec colname="8" colwidth="35PT" align="left"/>
<tbody valign="top">
<row>
<entry>(byte 0)</entry>
<entry>(byte 1)</entry>
<entry>(byte 2)</entry>
<entry>(byte 3)</entry>
<entry>(byte 4)</entry>
<entry>(byte 5)</entry>
<entry>(byte 6)</entry>
<entry>(byte 7)</entry>
</row>
<row><entry namest="1" nameend="8" align="center" rowsep="1"></entry>
</row>
<row>
<entry>PA &lsqb;31:24&rsqb;</entry>
<entry>PA &lsqb;23:16&rsqb;</entry>
<entry>PA &lsqb;15:08&rsqb;</entry>
<entry>PA &lsqb;07:00&rsqb;</entry>
<entry>F&lsqb;31:24&rsqb;</entry>
<entry>F&lsqb;23:16&rsqb;</entry>
<entry>F&lsqb;15:08&rsqb;</entry>
<entry>F&lsqb;07:00&rsqb;</entry>
</row>
<row>
<entry>BA&lsqb;31:24&rsqb;</entry>
<entry>BA&lsqb;23:16&rsqb;</entry>
<entry>BA&lsqb;15:8&rsqb;</entry>
<entry>BA&lsqb;7:0&rsqb;</entry>
<entry>OF&lsqb;15:08&rsqb;</entry>
<entry>OF&lsqb;7:0&rsqb;</entry>
<entry>WC&lsqb;15:08&rsqb;</entry>
<entry>WC&lsqb;7:0&rsqb;</entry>
</row>
<row><entry namest="1" nameend="8" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0373" lvl="0"><number>&lsqb;0373&rsqb;</number> Assuming that the host (AP) will write to this data structure in PE memory using word PIO&apos;s over PCI (for the example shown), the host must pre-scramble those words so that the data will arrive in the correct byte lanes:  
<table-cwu id="TABLE-US-00008">
<number>8</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="273PT" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center">TABLE 7</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>DMA Descriptor Byte Order, little endian register</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="5">
<colspec colname="OFFSET" colwidth="105PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="42PT" align="left"/>
<colspec colname="4" colwidth="42PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>(byte 3)</entry>
<entry>(byte 2)</entry>
<entry>(byte 1)</entry>
<entry>(byte 0)</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="4" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="5">
<colspec colname="1" colwidth="105PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="42PT" align="left"/>
<colspec colname="4" colwidth="42PT" align="left"/>
<colspec colname="5" colwidth="42PT" align="left"/>
<tbody valign="top">
<row>
<entry>First data phase(word at 0&times;0)</entry>
<entry>PA&lsqb;07:00&rsqb;</entry>
<entry>PA&lsqb;15:08&rsqb;</entry>
<entry>PA&lsqb;23:16&rsqb;</entry>
<entry>PA&lsqb;31:24&rsqb;</entry>
</row>
<row>
<entry>Second data phase(word at 0&times;4)</entry>
<entry>F&lsqb;07:00&rsqb;</entry>
<entry>F&lsqb;15:08&rsqb;</entry>
<entry>F&lsqb;23:16&rsqb;</entry>
<entry>F&lsqb;31:24&rsqb;</entry>
</row>
<row>
<entry>Third data phase(word at 0&times;8)</entry>
<entry>BA&lsqb;7:0&rsqb;</entry>
<entry>BA&lsqb;15:8&rsqb;</entry>
<entry>BA&lsqb;23:16&rsqb;</entry>
<entry>BA&lsqb;31:24&rsqb;</entry>
</row>
<row>
<entry>Fourth data phase(word at 0&times;C)</entry>
<entry>WC&lsqb;07:00&rsqb;</entry>
<entry>WC&lsqb;15:08&rsqb;</entry>
<entry>OF&lsqb;7:0&rsqb;</entry>
<entry>OF&lsqb;15:8&rsqb;</entry>
</row>
<row><entry namest="1" nameend="5" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0374" lvl="7"><number>&lsqb;0374&rsqb;</number> and then when the host writes the address of the descriptor into the DMA ring (which is &ldquo;byte-lane&rdquo; memory), that descriptor pointer is written as a word with the following content:  
<table-cwu id="TABLE-US-00009">
<number>9</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259PT" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center">TABLE 8</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Descriptor Pointer Byte Order, little endian register</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="70PT" align="center"/>
<colspec colname="2" colwidth="63PT" align="center"/>
<colspec colname="3" colwidth="63PT" align="center"/>
<colspec colname="4" colwidth="63PT" align="center"/>
<tbody valign="top">
<row>
<entry>(byte 3)</entry>
<entry>(byte2)</entry>
<entry>(byte 1)</entry>
<entry>(byte 0)</entry>
</row>
<row><entry namest="1" nameend="4" align="center" rowsep="1"></entry>
</row>
<row>
<entry>DESC_A&lsqb;07:00&rsqb;</entry>
<entry>DESC_A&lsqb;15:08&rsqb;</entry>
<entry>DESC_A&lsqb;23:16&rsqb;</entry>
<entry>DESC_A&lsqb;31:24&rsqb;</entry>
</row>
<row><entry namest="1" nameend="4" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0375" lvl="7"><number>&lsqb;0375&rsqb;</number> Note that reads and writes through the ring unit are accesses to memory, not to registers, which is why the address_shuffle (where &ldquo;the address&rdquo; is data, as above) is required when the host is writing to the ring-enqueue address. </paragraph>
<paragraph id="P-0376" lvl="7"><number>&lsqb;0376&rsqb;</number> 8.3 Host Writing a Message to the PP in Memory </paragraph>
<paragraph id="P-0377" lvl="0"><number>&lsqb;0377&rsqb;</number> The PP views the memory as big-endian in the same manner as the DMA engine, so the example in 7.8.2 describes this path as well. Messages are either a byte stream, or require the host to manually byte swap larger data. The contents of a mailbox and the contents of any ring entry or other item in memory will follow the same format as shown in Table 8. </paragraph>
<paragraph id="P-0378" lvl="7"><number>&lsqb;0378&rsqb;</number> 8.4 PP Writing a Message in Memory that is DMA&apos;ed to the Host </paragraph>
<paragraph id="P-0379" lvl="0"><number>&lsqb;0379&rsqb;</number> If messages sent up to the host are simply a byte stream then there is no issue, since byte streams travel in an endian-neutral way. If on the other hand the message includes data that are larger than a byte (e.g. a buffer pointer), byte swapping occurs and both ends of the communication must be aware of this. </paragraph>
<paragraph id="P-0380" lvl="0"><number>&lsqb;0380&rsqb;</number> For example, if the PP wants to send a 32-bit address to the host, it must byte swap within that word before sending it. That is, if the PP wants to send the 32-bit word OXDEADBEEF up to the host as a message, then the PP must put it into memory as OXEFBEADDE (see Table 5.) </paragraph>
<paragraph id="P-0381" lvl="7"><number>&lsqb;0381&rsqb;</number> 8.5 Classification Engine CMEM Fills </paragraph>
<paragraph id="P-0382" lvl="0"><number>&lsqb;0382&rsqb;</number> Writing instructions into CMEM in the Classification Engines takes one of two paths; the data is either DMA&apos;ed or PIO&apos;ed into PE memory from the host and then copied from memory to CMEM by the CE (using the CE&apos;s FILL_DMA unit), or the host can PIO data directly into CMEM over the Register interface (CMEM_DIAG access). </paragraph>
<paragraph id="P-0383" lvl="0"><number>&lsqb;0383&rsqb;</number> The CMEM_DIAG path is word-oriented and no twisting occurs, since it is all via the register path. The 32-bit data and addresses seen in the host processor is the same 32-bit data that is seen in the AP&apos;s registers. Diagnostic PIO&apos;s of data are sent to CMEM in the order &lsqb;Least Significant Word, then Most Significant Word&rsqb; to construct the 64-bit instruction. </paragraph>
<paragraph id="P-0384" lvl="0"><number>&lsqb;0384&rsqb;</number> The FILL_DMA path takes 64-bit words from PE memory and writes them into the 64-bit CMEM. The compiler and host software always handle 64-bit instructions in their native (that is, readable) form. CMEM instructions are laid out as native 64-bit units in host memory; the host/compiler does not need to twist them to help the (other-endian) recipient. When the data arrives in PE memory, each 64-bit instruction will arrive byte-swapped due to byte-lane steering; that is, the instruction 0XAABBCCDD_EEFF0123 </paragraph>
<paragraph id="P-0385" lvl="7"><number>&lsqb;0385&rsqb;</number> in host memory will land in PE memory as </paragraph>
<paragraph id="P-0386" lvl="2"><number>&lsqb;0386&rsqb;</number> 0X2301FFEE_DDCCBBAA </paragraph>
<paragraph id="P-0387" lvl="7"><number>&lsqb;0387&rsqb;</number> and the CE CMEM Fill data path is wired as shown in Table 4, so that the bytes land in the correct place. Thus the MSB from PE memory will go to the LSB in CMEM, and vice versa. This works whether the data arrived in PE memory via a PIO from the AP or via a DMA from host memory prior to the FILL_DMA transfer into CMEM. </paragraph>
<paragraph id="P-0388" lvl="0"><number>&lsqb;0388&rsqb;</number> The upshot of all of this is that the CMEM FILL DMA unit views PE memory as little-endian; and it doesn&apos;t matter to anyone using normal paths that CMEM microcode images are byte-swapped while they reside in the staging area in PE memory. This is all hidden from software. </paragraph>
</section>
<section>
<heading lvl="1">IV. Classification Engine </heading>
<paragraph id="P-0389" lvl="0"><number>&lsqb;0389&rsqb;</number> The Classification Engine (CE) is a microprogrammed processor designed to accelerate predicate analysis in network infrastructure applications. The primary functions commonly used in predicate analysis include parsing layers of successively encapsulated headers, table lookups, and checksum verification. </paragraph>
<paragraph id="P-0390" lvl="0"><number>&lsqb;0390&rsqb;</number> Header parsing consists of extracting arbitrary single- or multiple-bit fields from those headers, comparing those fields to one or more constants, then taking the results of these comparisons and doing boolean reductions on multiple extraction results to reduce them finally to a single &ldquo;matches/doesn&apos;t-match&rdquo; status for each complex predicate statement; this single boolean value can then be used to quickly dispatch the appropriate actions at the PP. The size of each header is also determined so that the next level of protocol can be found and parsed in sequence. Applications can also choose to examine packet contents in addition to the headers if desired; the CE does not treat the header portion of a packet any differently from the payload portion. </paragraph>
<paragraph id="P-0391" lvl="0"><number>&lsqb;0391&rsqb;</number> Table lookups can consist of comparing an extracted value against a table of constants, or can involve generating a hash key from extracted values and then doing a lookup in a hash table (content-addressable table) to identify a record associated with packets matching that key; the record can contain arbitrary application-specific information such as permissions, counters, encryption context, etc. </paragraph>
<paragraph id="P-0392" lvl="0"><number>&lsqb;0392&rsqb;</number> Checksum verification involves arithmetic functions across protocol headers and/or packet payloads to determine if the packet contents are valid and thus comprise a valid packet. A special adder parallel to the mask-rotate unit called split-add adds the upper and lower half of a 32-bit operand together and produces a 17-bit result for use as an operand by the ALU; this is used in TCP, UDP, and IP checksum computation. </paragraph>
<paragraph id="P-0393" lvl="0"><number>&lsqb;0393&rsqb;</number> Since one purpose of the CE is to help the PP to avoid needing to touch packet contents and thus fault portions of the packet into the PP&apos;s data cache, the CE can also be programmed to extract arbitrary data fields and optionally do computations on them, then pass the results to the applications running on the PP via the packet buffer&apos;s software data structure. </paragraph>
<paragraph id="P-0394" lvl="0"><number>&lsqb;0394&rsqb;</number> A software structure is carried in the packet buffer along with the packet and the associated MAC status. This structure is written with predicate analysis results, hash table pointers to records found, hash insertion pointers in the case of a failed search, checksum results, a pointer to the base of each protocol found, extracted and computed fields, etc. for use by the application(s) running on the PP. </paragraph>
<paragraph id="P-0395" lvl="0"><number>&lsqb;0395&rsqb;</number> In order to accelerate these functions, the Classification Engine loads some or all of the packet from the PE&apos;s SDRAM-based memory (PE Memory) into a packet memory (PMEM) which it can then access randomly or sequentially to extract fields from the packet. A mask-and-rotate unit allows arbitrary bit fields to be extracted from words of the packet which can then be used as operands in computation or as comparison values for bulk table comparisons. Table comparisons or individual arithmetic and logic operations can set one or more bits in the result vector which is a large, 1-bit wide register file. These RESVEC bits can then be accessed randomly and arbitrary boolean operations can be done on pairs of bits to produce more RESVEC bits, at a rate of up to two boolean bit operations per cycle, eventually reducing sets of bits to single-bit predicate results. Gang operations (GANGOPS) help optimize boolean reduction by doing a logical operation (OR, AND, NOR, or NAND) on any number of selected bits within a 32-bit group of RESVEC bits in a single clock, producing a single RESVEC bit as a result. After boolean reduction is completes some or all of the result vector can then be spilled to the software structure in the packet buffer in PE Memory for use by the Policy Processor. </paragraph>
<paragraph id="P-0396" lvl="0"><number>&lsqb;0396&rsqb;</number> A 32-bit Arithmetic and Logic Unit (ALU) and a set of general-purpose 32-bit registers (GPREG) allow for general computation as well. </paragraph>
<paragraph id="P-0397" lvl="0"><number>&lsqb;0397&rsqb;</number> Program flow control in the branch unit allows the microcode to decide if the next instruction in the microcode control store (CMEM) comes from a sequential location, from a relative-branch value which can be an immediate value in the microword or the contents of a GPREG, or (in the case of a RETURN) from the top of the hardware microstack; microstack values are enqueued when a CALL style of branch is executed, and the microstack is accessed in LIFO (last-in, first-out) fashion to support nested subroutines in the microcode. Branch, Call, and Return operations are all conditional based on any of the rich set of condition codes provided. When the microcode bit &ldquo;BRANCH_EN&rdquo; is set then a Branch, Call, or Return is executed if the selected condition code is true; calls and returns are done if the associated bit CALL or RET is set in the control word when BRANCH_EN is set. Due to pipelining of the microsequencer all program-flow changes have a 1-cycle delay before taking effect, so the instruction following any of program flow control instructions (the &ldquo;branch delay slot&rdquo;) is always executed regardless of the success or failure of the conditional flow control instruction; as a result of this the address stored in the microstack upon a successful CALL is the address of the first instruction following the delay slot. </paragraph>
<paragraph id="P-0398" lvl="0"><number>&lsqb;0398&rsqb;</number> The CE also contains several special purpose registers and also supports execution of many special operations. Special-purpose registers include the interface to PE memory, the condition code register, a memory base pointer register used for base-index access to packet buffers in PE memory, a chip-wide timestamp timer, and instrumentation and diagnostic registers including a counter which monitors execution time and a counter which tracks stall cycles due to various memory interface delays. </paragraph>
<paragraph id="P-0399" lvl="0"><number>&lsqb;0399&rsqb;</number> The memory interface appears to the microcode as 3 FIFO&apos;s; DFIFO_W receives one or more words of data to be packed into a memory burst access for stores, DFIFO_R unpacks requested bursts of data that have been read from memory, and MEM_ADDR receives PE memory addresses along with size and direction information. Reads (or &ldquo;loads&rdquo;) are non-blocking; microcode schedules a load and then can take the data from DFIFO_R at any time later; if the data has not yet arrived then the pipeline will stall until it does. The pipeline will also stall if there is an attempt to write data to DFIFO_W and there is no room or if there is an attempt to schedule another address in MEM_ADDR and there is no room. Both of these conditions are self-cleaning as the fifos drain to the chip&apos;s memory controller. Extensive error-checking logic uses counters to track the state of various parts of the memory interface and will not allow microcode to oversubscribe DFIFO_R nor to issue a write (&ldquo;store&rdquo;) to memory unless precisely the right number of words of data have already been scheduled in DFIFO_W. Memory accesses sizes are 1, 2, 4, or 8 32-bit words. </paragraph>
<paragraph id="P-0400" lvl="0"><number>&lsqb;0400&rsqb;</number> Using the memory interface for a store consists of writing the desired number of words of data to DFIFO_W, then committing the store by scheduling the address into MEM_ADDR along with the appropriate size code and the direction flag for a store. Using it for a load consists of scheduling the address, size, and direction flag for a load into MEM_ADDR, then consuming precisely that many words in order from DFIFO_R at some later time DFIFO_R holds up to 4 maximum-sized bursts or up to 32 words of data scheduled as smaller reads, so properly written microcode can often hide the latency of reading PE Memory by scheduling several loads before consuming the result of the first. Bulk data movement such as filling PMEM with a packet can keep several reads outstanding in a pipelined fashion to move data at the maximum memory bandwidth available. </paragraph>
<paragraph id="P-0401" lvl="0"><number>&lsqb;0401&rsqb;</number> These non-blocking loads help to accelerate hash table searches and linked-list searches; once the header of a record has been fetched, the forward pointer can be used to speculatively fetch the next record before doing any key comparisons with the current one, hiding much of the memory latency and generally overlapping computation and memory access so that hash searches can be done as fast as the records can be fetched from the SDRAM (PE Memory). </paragraph>
<paragraph id="P-0402" lvl="0"><number>&lsqb;0402&rsqb;</number> Special Operations include various administrative functions that the CE uses; these include functions such as incrementing MCCONS and RCCONS in the RTU, flash-clearing the general purpose registers and the result vector, selecting immediate or index-register addressing for PMEM, loading the PMEM index pointer and setting or clearing its sequential access mode, managing a sequential index counter for RESVEC used for table comparisons and result spills, halting the sequencer or putting it into a power-saving sleep mode, managing certain special condition codes, etc. </paragraph>
<paragraph id="P-0403" lvl="0"><number>&lsqb;0403&rsqb;</number> Bulk Table Comparisons (using the cmprn instruction) implement the CE&apos;s only multi-cycle instruction; prior to executing cmprn, one or two 32-bit comparison values are loaded into general purpose registers. In the first cycle of a cmprn instruction one or two general-purpose registers are identified as the A-side and B-side comparison values (both can be the same register if desired), a starting index into RESVEC is set, four special condition codes associated with bulk table comparisons are cleared, an instruction-length counter is initialized to the instruction length &ldquo;N&rdquo;, and the entire processor is set for cmprn mode. The next &ldquo;N&rdquo; 64-bit microcode words are interpreted as pairs of 32-bit values for comparison rather than as microcode; one 32-bit value is compared to the A-side register and the other is compared to the B-side register, and if either matches the associated bit in the (even,odd) bit pair pointed to by the RESVEC_INDEX is set; then the RESVEC_INDEX in incremented to point at the next bit pair, the length counter is decremented, and the next comparison value pair is fetched from CMEM. The process is repeated until the length counter reaches <highlight><bold>0</bold></highlight>. </paragraph>
<paragraph id="P-0404" lvl="0"><number>&lsqb;0404&rsqb;</number> Associated with this process are the four condition-code bits MATCH_A, MATCH_B, MATCH_A_OR_B, and MATCH A_AND_B, which indicate that at least one table value matched on the A-side, on the B-side, on either side, or on A and B-side together (as a 64-bit match), respectively. </paragraph>
<paragraph id="P-0405" lvl="0"><number>&lsqb;0405&rsqb;</number> Given this facility it is possible to compare one extracted value to (2*N) constants or to compare two values to N constants each, in a total of (N&plus;1) cycles. These bulk table lookups are useful for rapidly searching small tables as part of predicate analysis; hash-table lookups are used for larger tables when it becomes more time-efficient to do so. </paragraph>
<paragraph id="P-0406" lvl="0"><number>&lsqb;0406&rsqb;</number> Another special condition-code is &ldquo;Sticky-zero&rdquo; or &ldquo;SZ&rdquo;. It is used to cumulatively check status on a chain of equality comparisons of the form &ldquo;if (A&equals;X) and (B&equals;Y) and (C&equals;Z) and (D&equals;W) then . . . &rdquo; by first setting the SZ bit in the Condition Code Register using a special operation, then doing a series of equality comparisons or other arithmetic functions, then doing a conditional test of SZ; the bit stays set as long as the result of all intervening operations that set conditions codes have the &ldquo;data equals zero&rdquo; status. Any &ldquo;data not equal to zero status&rdquo; result in the series will cause SZ to clear and to stay clear. </paragraph>
<paragraph id="P-0407" lvl="0"><number>&lsqb;0407&rsqb;</number> A messaging facility between the CE and the PP is provided; the CE can set any of 4 status bits which cause status to become visible to the PP (Message-Out bits) and the PP can set any of 4 status bits (Message-In bits) which the CE can test as condition codes. These bits can be used for any messaging purpose as assigned by software. </paragraph>
<paragraph id="P-0408" lvl="0"><number>&lsqb;0408&rsqb;</number> Two other condition code bits are &ldquo;RX_RING_RDY&rdquo; and &ldquo;RECLASS_RING_RDY&rdquo;, which are used by the RTU to indicate to the CE that there is a least one buffer pointer for it to process in the two buffer pointer rings on which it is a consumer; one ring is the &ldquo;RX Ring&rdquo; and always carries packets from the associated RX MAC to this CE, and the other is called the &ldquo;Reclassification Ring&rdquo; through which any party can schedule a packet to be processed on this CE. </paragraph>
<paragraph id="P-0409" lvl="0"><number>&lsqb;0409&rsqb;</number> In summary, the Classification Engine tests the two ring status bits and the 4 message bits in a dispatch loop, and calls the appropriate service routine when a condition is found to be active. (When no conditions are active the dispatch loop sets the CE into &ldquo;sleep mode&rdquo; to reduce power consumption.) The ring service routines fetch a packet buffer pointer from the associated ring, fetch some or all of the packet (only as much as the microcode will need to examine, or all of the packet if checksums are to be validated on the payload), then starts with the first protocol header and executes a series of application-specific operations to extract fields from the packet, identify and process arbitrary protocol headers, do table lookups via bulk comparisons or hash table searches as directed by the application, do checksum verifications as programmed, do boolean reduction on interim results, extract and optionally compute on arbitrary fields in the packet, and finally to write all results to a data structure in the per-packet result area that travels with the packet in the packet buffer in SDRAM. The results written include the set of single-bit predicate analysis results, hash search results (a pointer to the record that matches the key extracted from this packet or a pointer to where a hash record should be inserted if one does not exist and the application wants to create one, for any number of different tables with different keys), plus any extracted or computed values (such as index pointers to the start of each layer of protocol header) desired by the application. Microcode can be loaded into CMEM by the AP or PP, or by the CE itself once it has been loaded with its initial microcode. </paragraph>
<paragraph id="P-0410" lvl="0"><number>&lsqb;0410&rsqb;</number> The following pages include a block diagram of the CE, a table identifying the various microcode control bits, fornats for the microcode, and tables of relevant values </paragraph>
<paragraph id="P-0411" lvl="7"><number>&lsqb;0411&rsqb;</number> 1. CE Block Diagram </paragraph>
<paragraph id="P-0412" lvl="0"><number>&lsqb;0412&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 13</cross-reference> shows a block diagram of the Classification engine. </paragraph>
<paragraph id="P-0413" lvl="7"><number>&lsqb;0413&rsqb;</number> 1.1 Overview of the Classification Engine in <cross-reference target="DRAWINGS">FIG. 13</cross-reference>. </paragraph>
<paragraph id="P-0414" lvl="0"><number>&lsqb;0414&rsqb;</number> The Classification Engine is a pipelined microsequencer. A 64-bit microword is fetched from Control Store CMEM <highlight><bold>1202</bold></highlight> using an address supplied by register PC <highlight><bold>1234</bold></highlight>, and is stored in the instruction register I-REG <highlight><bold>1216</bold></highlight>. This cycle is referred to as the Fetch cycle <highlight><bold>1302</bold></highlight>. </paragraph>
<paragraph id="P-0415" lvl="0"><number>&lsqb;0415&rsqb;</number> The 64-bit microword in 1-Reg <highlight><bold>1216</bold></highlight> has 7 bits each dedicated to enabling the retirement of a result by causing registers to be loaded One of these bits is reserved for future enhancements, while 6 of them have specified functions as described in Table 16. This group of signals are known as the write enables WE&lsqb;6:0&rsqb;. The WE bits also have function-specific names as shown in Table 1; BRANCH_EN, REG_WE, CC_WE, RESVEC_WE, PMEM_WE, and SPECOP_EN. </paragraph>
<paragraph id="P-0416" lvl="0"><number>&lsqb;0416&rsqb;</number> BRANCH_EN enables conditional program flow changes if a condition test is met. It controls units in the Address Generation Unit <highlight><bold>1230</bold></highlight>. </paragraph>
<paragraph id="P-0417" lvl="0"><number>&lsqb;0417&rsqb;</number> REG_WE enables retirement of 32-bit results in the word-oriented half of the machine to all of the general-purpose registers and special registers listed in Table 17. It also has side effects of incrementing the pmem <highlight><bold>1204</bold></highlight> index counter PCNT <highlight><bold>1222</bold></highlight> or dequeuing a word of data from DFIFO_R <highlight><bold>1250</bold></highlight> under certain circumstances. </paragraph>
<paragraph id="P-0418" lvl="0"><number>&lsqb;0418&rsqb;</number> CC_WE enables the writing of the arithmetic result bits in the condition code register. </paragraph>
<paragraph id="P-0419" lvl="0"><number>&lsqb;0419&rsqb;</number> PMEM_WE enables writes into packet memory PMEM <highlight><bold>1204</bold></highlight> RESVEC WE enables stores in the bit-oriented result vector RESVEC <highlight><bold>1208</bold></highlight>. </paragraph>
<paragraph id="P-0420" lvl="0"><number>&lsqb;0420&rsqb;</number> SPECOP_EN enables special operations including writing to PCNT <highlight><bold>1222</bold></highlight>, NCNT <highlight><bold>1224</bold></highlight>, </paragraph>
<paragraph id="P-0421" lvl="0"><number>&lsqb;0421&rsqb;</number> BDST_CNT <highlight><bold>1226</bold></highlight>, and other functions listed in Table 22. </paragraph>
<paragraph id="P-0422" lvl="0"><number>&lsqb;0422&rsqb;</number> The pipeline is 3 stages deep as shown in <cross-reference target="DRAWINGS">FIG. 14</cross-reference>. The Fetch stage <highlight><bold>1302</bold></highlight> has been described above. The Decode stage <highlight><bold>1304</bold></highlight> takes place from the output of I-REG <highlight><bold>1216</bold></highlight> to the inputs of D-REG <highlight><bold>1212</bold></highlight>, PC <highlight><bold>1234</bold></highlight>. and RESVEC <highlight><bold>1208</bold></highlight>. The Execute stage <highlight><bold>1306</bold></highlight> takes place from the output of D-REG <highlight><bold>1212</bold></highlight> to the inputs of all general purpose registers and special purpose registers listed in table <highlight><bold>17</bold></highlight>; ALUOUT can be written to GPREG <highlight><bold>1206</bold></highlight>, MEM_ADDR <highlight><bold>1254</bold></highlight>, DFIFO_W <highlight><bold>1252</bold></highlight>, the CTRL_FILL registers <highlight><bold>1210</bold></highlight>, and the special registers in block <highlight><bold>1270</bold></highlight>. FIG. <highlight><bold>14</bold></highlight> shows in detail what occurs in each stage of the pipeline, and at what stage various types of results are retired. Pipeline stall conditions suppress all of the WE bits so that the same condition holds from once cycle to the next, until the stall condition clears. Since this stall condition affects all microcode-controlled changes of state in the CE, it is implicit in all subsequent discussion of operation of the pipeline and the effect of stalls needs no further discussion. The causes of pipeline stalls are described in subsequent sections. </paragraph>
<paragraph id="P-0423" lvl="7"><number>&lsqb;0423&rsqb;</number> 1.2 Program Flow Control </paragraph>
<paragraph id="P-0424" lvl="0"><number>&lsqb;0424&rsqb;</number> The address generation unit <highlight><bold>1230</bold></highlight> determines what address will be used to fetch the next microword from CMEM. The Program Counter (PC) <highlight><bold>1234</bold></highlight> contains the address of the current instruction being fetched. If BRANCH_EN is a &lsquo;0&rsquo; then the next value of PC is an increment of the current value; with no branches the microsequencer fetches microwords sequentially from CMEM. When BRANCH_EN is asserted a test of condition codes listed in Table 21 is done as selected by bits CCSEL&lsqb;4:0&rsqb; and inverted by FALSE, both fields described in Table 16. If the condition test returns a &ldquo;1&rdquo; then the conditional branch will be taken, otherwise PC <highlight><bold>1234</bold></highlight> will be loaded with the increment of its current value. The bit REG is tested; if it is &lsquo;0&rsquo; then the address PC is added to the value of the bits BRANCH_ADDR&lsqb;9:0&rsqb; to generate the branch value of PC; if it is &lsquo;1&rsquo; then the address PC is added to the value on bus REGB&lsqb;9:0&rsqb; to generate the branch value. The bus REGB carries the output of GPREG <highlight><bold>1206</bold></highlight> port DO1, which carries the value of the general purpose register selected with bits RSRCB&lsqb;2:0&rsqb;. </paragraph>
<paragraph id="P-0425" lvl="0"><number>&lsqb;0425&rsqb;</number> Next bit RET is tested. If it is a &lsquo;1&rsquo; then PC is loaded with the output of the microstack <highlight><bold>1232</bold></highlight>, and the microstack&apos;s stack pointer is decremented by 1. The microstack <highlight><bold>1232</bold></highlight> is a Last-in, First-out LIFO structure used to support micro-subroutines, nested up to 8 deep. If RET was a &lsquo;0&rsquo; then PC is loaded with the calculated branch value described above instead, and CALL is examined. If CALL is a &lsquo;1&rsquo; then the microstack <highlight><bold>1232</bold></highlight> has its stack pointer incremented, and the incremented value of the previous PC is written into the microstack using the new value of the stack pointer. In this way the address stored in the microstack <highlight><bold>1232</bold></highlight> when a CALL is executed is the address of the next instruction that would have been executed sequentially if the branch had not succeeded; thus when calling a subroutine it is the address of the next instruction to return to after executing a RET to terminate the subroutine. </paragraph>
<paragraph id="P-0426" lvl="0"><number>&lsqb;0426&rsqb;</number> Since all program flow control decisions are made in the Decode stage <highlight><bold>1304</bold></highlight>, the sequential instruction which follows is already in the fetch stage and is always executed This means that there is always a 1-cycle delay between fetching a successful BRANCH_EN instruction and its effect on PC. The instruction which follows a branch instruction, and is always executed regardless of the success or failure of the branch, is called a delay-slot instruction. A delay-slot instruction may not have BRANCH_EN set. The return value stored in the microstack <highlight><bold>1232</bold></highlight> after a successful CALL is the address of the instruction following the delay slot instruction of the CALL. </paragraph>
<paragraph id="P-0427" lvl="0"><number>&lsqb;0427&rsqb;</number> The microstack <highlight><bold>1232</bold></highlight> in the preferred embodiment of the invention consists of 8 registers with a multiplexer (mux) selecting one of them as the microstack output A single 3-bit counter is used as the stack pointer; it is decoded in such a way that the read address N is the write address (N&plus;1) so that a read-and-decrement or write-and-increment can be executed in a single cycle. Attempting to execute a CALL when the microstack already has <highlight><bold>8</bold></highlight> valid entries in it, or attempting to execute a RET when the microstack has no valid entries in it, causes the pipeline to halt and signal STACK_ERROR status to the Policy Processor <highlight><bold>244</bold></highlight>. </paragraph>
<paragraph id="P-0428" lvl="0"><number>&lsqb;0428&rsqb;</number> CCSEL, FALSE, BRANCH_ADDR, RSRCB, REG, CALL, and RET are all defined in Table 16. </paragraph>
<paragraph id="P-0429" lvl="7"><number>&lsqb;0429&rsqb;</number> 1.3 32-Bit Operations </paragraph>
<paragraph id="P-0430" lvl="0"><number>&lsqb;0430&rsqb;</number> The Classification Engine has two distinct data domains; one is oriented around 32-bit data, and the other is oriented around 1-bit boolean data in RESVEC <highlight><bold>1208</bold></highlight> and the Bit ALU <highlight><bold>1260</bold></highlight>. There are a few places where data is communicated between these two domains. This section describes the 32-bit domain. </paragraph>
<paragraph id="P-0431" lvl="0"><number>&lsqb;0431&rsqb;</number> The 32-bit domain centers around selecting the A-side and B-side operands which are then fed into AIN and BIN of the ALU <highlight><bold>1214</bold></highlight>. The output ALUOUT from ALU <highlight><bold>1214</bold></highlight> is then written back to one of the 32-bit destinations, and optionally the arithmetic condition codes are set if CC_WE is &lsquo;1&rsquo;. The ALU <highlight><bold>1214</bold></highlight> is a 32-bit Arithmetic and Logic Unit which performs any of the arithmetic functions listed in Table 19 or any of the logic functions listed in Table 20 under control of the bits ALUOP&lsqb;5:0&rsqb; defined in Table 16. </paragraph>
<paragraph id="P-0432" lvl="0"><number>&lsqb;0432&rsqb;</number> GPREG <highlight><bold>1206</bold></highlight> is a 32-bit general-purpose register file comprising 8 32-bit registers. It has two read ports and one write port. Read port DO0 has the contents of the register selected by RSRCA&lsqb;2:0&rsqb;, and read port DO1 has the contents of the register selected by RSRCB&lsqb;2:0&rsqb;. The register selected by RDST&lsqb;2:0&rsqb; is written to with the value of ALU_OUT if RDST&lsqb;3&rsqb; is &lsquo;0&rsquo; and REG_WE is &lsquo;1&rsquo;. In order to make newly-generated register values available in the subsequent instruction, the pipeline delay of writing into GPREG and reading out the new value is squashed through use of Bypass Multiplexers <highlight><bold>1221</bold></highlight> and <highlight><bold>1223</bold></highlight>, which are used to forward ALU_OUT to busses REGA and REGB if RDST of the instruction in the execute stage matches RSRCA or RSRCB, respectively, in the instruction in the decode stage, thus hiding the pipeline delay. The A-side operand is selected among the A-side sources listed in Table 17 by multiplexer <highlight><bold>1225</bold></highlight>. The selected data is then sent into the split-add-mask-and-rotate unit <highlight><bold>1240</bold></highlight>. Bits&lsqb;31:16&rsqb; of the data are added to bits&lsqb;15:0&rsqb; of the data in the adder <highlight><bold>1248</bold></highlight>, and the 17-bit result is concanated with zeros in bits &lsqb;31:17&rsqb; to create the split-add result. The selected data is also sent to the Mask Unit <highlight><bold>1242</bold></highlight> where it is bitwised AND&apos;ed with MASK&lsqb;31:0&rsqb; if MSK&lsqb;1&rsqb; is a &lsquo;1&rsquo;, or is passed through unmodified if MSK&lsqb;1&rsqb; is a &lsquo;0&rsquo;; the result from MASK <highlight><bold>1242</bold></highlight> is sent through the ROTATE barrel-shifter <highlight><bold>1244</bold></highlight> where the data is rotated right by the number of bits specified in ROT&lsqb;4:0&rsqb; in the microword. Finally, MSK&lsqb;0&rsqb; is used to select between the split-add result and the mask-rotate result in multiplexer <highlight><bold>1246</bold></highlight>, and the result is presented to D-REG <highlight><bold>1212</bold></highlight> as the A-side operand for the execute stage <highlight><bold>1306</bold></highlight>. The B-side operand is selected among the B-side sources listed in Table 18 using multiplexer <highlight><bold>1228</bold></highlight>, and is presented to the D-REG <highlight><bold>1212</bold></highlight> as the B-side operand for the execute stage <highlight><bold>1306</bold></highlight>. </paragraph>
<paragraph id="P-0433" lvl="0"><number>&lsqb;0433&rsqb;</number> RSRCA, RSRCB, ALUOP&lsqb;5:0&rsqb;, RDST&lsqb;3:0&rsqb;, MASK&lsqb;31:0&rsqb;, MSK&lsqb;1&rsqb;, MSK&lsqb;0&rsqb;, ROT&lsqb;4:0&rsqb; are all described in Table 16. </paragraph>
<paragraph id="P-0434" lvl="7"><number>&lsqb;0434&rsqb;</number> 1.4 PMEM </paragraph>
<paragraph id="P-0435" lvl="0"><number>&lsqb;0435&rsqb;</number> Packet Memory (PMEM) <highlight><bold>1204</bold></highlight> is a (32-bit by 512-entry) RAM with one read port and one write port used to hold some or all of the packet being processed, and also to hold arbitrary data generated by the program. PMEM <highlight><bold>1204</bold></highlight> can be written from two sources; DFIFO_R <highlight><bold>1250</bold></highlight>, or the REGA bus from the general-purpose registers GPREG <highlight><bold>1206</bold></highlight>, where the register is selected by RSRCA&lsqb;2:0&rsqb;; such writes occur when PMEM_WE is a &lsquo;1&rsquo; in the microword. PMEM is read as one of the A-side sources selectable as one of the &ldquo;special register&rdquo; sources. </paragraph>
<paragraph id="P-0436" lvl="0"><number>&lsqb;0436&rsqb;</number> PMEM <highlight><bold>1204</bold></highlight> addressing depends on the state bit USE_PCNT. When USE_PCNT is &lsquo;0&rsquo;, then PMEM <highlight><bold>1204</bold></highlight> is addressed by PINDEX&lsqb;10:2&rsqb; from the microword. When USE_PCNT is &lsquo;1&rsquo; then the address to PMEM <highlight><bold>1204</bold></highlight>, is provided by the counter/register PCNT <highlight><bold>1222</bold></highlight>. USE_PCNT is set and cleared via special operations. When SPECOP_EN is &lsquo;1&rsquo; and LD_PCNT is &lsquo;1&rsquo;, then PCNT_REG is examined. If it is a &ldquo;1&rdquo; then PCNT is loaded with the value of bits &lsqb;10:2&rsqb; of the general-purpose register in GPREG <highlight><bold>1206</bold></highlight> selected by RSRCB&lsqb;2:0&rsqb;; alternatively if PCNT_REG is a &ldquo;0&rdquo; then PCNT is loaded with the value of PNDEX&lsqb;10:2&rsqb; in the microword. In either case the state bit USE_PCNT is set. Additionally, bit PCNT_INC is examined, if it is a &ldquo;1&rdquo; then PCNT_INC_MODE is set, or if it is a &ldquo;0&rdquo; then PCNT_INC_MODE is cleared. The state bit PCNT_INC_MODE determines if PCNT <highlight><bold>1222</bold></highlight> holds a static value during the PCNT_MODE period, or if increments by one each time PMEM is written to or is used as a register source. USE_PCNT clears when an instruction has SPECOP_EN equal to &ldquo;1&rdquo; and UNLOCK_PCNT also equal to &ldquo;1&rdquo;. </paragraph>
<paragraph id="P-0437" lvl="0"><number>&lsqb;0437&rsqb;</number> DFIFO_R. RSRCA&lsqb;3:0&rsqb;, RSRCB&lsqb;3:0&rsqb;, PINDEX&lsqb;10:2&rsqb; are all defined in Table 16, LD_PCNT, PCNT_REG, PCNT_INC, UNLOCK_PCNT are all defined in Table 22. </paragraph>
<paragraph id="P-0438" lvl="7"><number>&lsqb;0438&rsqb;</number> 1.5 Interface to Memory <highlight><bold>260</bold></highlight> </paragraph>
<paragraph id="P-0439" lvl="0"><number>&lsqb;0439&rsqb;</number> SDRAM Memory <highlight><bold>260</bold></highlight> can be read and written by the microcode. The memory interface visible to the microcode consists of the MEM_ADDR FIFO <highlight><bold>1254</bold></highlight>, the write data FIFO DFIFO_W <highlight><bold>1252</bold></highlight>, and the read data FIFO DFIFO_R <highlight><bold>1250</bold></highlight>. Writes to memory <highlight><bold>260</bold></highlight> are called stores, and reads from memory <highlight><bold>260</bold></highlight> are called loads. Loads and stores can be of size 1, 2, 4, or 8 words of 32-bits each. The address of a memory access must be size-aligned for the specified burst; that is, the address for a 2-word memory access must be on an 8-byte boundary, the address of an 8-word access must be on a 32-byte boundary, etc. </paragraph>
<paragraph id="P-0440" lvl="0"><number>&lsqb;0440&rsqb;</number> To schedule a store, precisely the number of words for the specified size of transfer are written to the special register destination DFIFO_W <highlight><bold>1252</bold></highlight>, then the address (along with control information MEM_SIZE&lsqb;1:0&rsqb; and MEM_DIR&equals;STORE) are written into the address fifo MEM_ADDR <highlight><bold>1254</bold></highlight>, which triggers the memory interface to issue the store. The microsequencer is decoupled from the memory system by the FIFOs <highlight><bold>1252</bold></highlight> and <highlight><bold>1254</bold></highlight>, and thus can continue operation while the memory interface processes the store operation. The FIFOs <highlight><bold>1254</bold></highlight> and <highlight><bold>1252</bold></highlight> can hold up to 8 addresses and 16 words of data, respectively, so that in general more than one store operation can be outstanding without stalling the pipeline. The entire pipeline stalls when the execute stage <highlight><bold>1306</bold></highlight> operation is a write to either MEM_ADDR <highlight><bold>1254</bold></highlight> or to DFIFO_W <highlight><bold>1252</bold></highlight> and the target FIFO does not have room for another word. The situation will clear as the FIFO drains its current operation to memory <highlight><bold>260</bold></highlight> so the stall condition is transient. </paragraph>
<paragraph id="P-0441" lvl="0"><number>&lsqb;0441&rsqb;</number> To schedule a load, the address (along with control information MEM_SIZE&lsqb;1:0&rsqb; and MEM_DIR&equals;LD) is written to special register destination MEM_ADDR, and some time later the microcode can obtain the requested data from the read data FIFO DFIFO_R <highlight><bold>1250</bold></highlight>. Between the time that the microsequencer scheduled the load operation and the time the data is consumed, there is latency to access the memory system <highlight><bold>260</bold></highlight>. The microcode can choose to execute any number of instructions between the time the load is scheduled in MEM_ADDR <highlight><bold>1254</bold></highlight> and the data is consumed from DFIFO_R <highlight><bold>1250</bold></highlight>, since the loads are non-blocking. However, if the microcode attempts to read data from DFIFO_R <highlight><bold>1250</bold></highlight> and there is no data available, the pipeline will stall until such time as requested data has returned from memory <highlight><bold>260</bold></highlight>. More than one load can be scheduled before any data is consumed; DFIFO_R <highlight><bold>1250</bold></highlight> has room for up to 16 doublewords (128 bytes) of data. </paragraph>
<paragraph id="P-0442" lvl="0"><number>&lsqb;0442&rsqb;</number> The microcode is responsible for ensuring that it never attempts to read data from DFIFO_R <highlight><bold>1250</bold></highlight> when no more words of read data have been scheduled, nor to issue a store address to MEM_ADDR <highlight><bold>1254</bold></highlight> when DFIFO_W <highlight><bold>1252</bold></highlight> has not been written with precisely the number of words specified in the size of the store. The microcode is also responsible for never oversubscribing DFIFO_R <highlight><bold>1254</bold></highlight>, that is, scheduling more outstanding words of read data than DFIFO_R <highlight><bold>1254</bold></highlight> has room for. Any of these conditions is detected by error-checking logic in the CE which will halt the CE and report violations to the Policy Processor <highlight><bold>244</bold></highlight> if the memory system is used incorrectly. </paragraph>
<paragraph id="P-0443" lvl="7"><number>&lsqb;0443&rsqb;</number> 1.6 Bit-Oriented Operations </paragraph>
<paragraph id="P-0444" lvl="0"><number>&lsqb;0444&rsqb;</number> RESVEC <highlight><bold>1208</bold></highlight> is a 1-bit by 512-entry register file with special characteristics. It has one write port and <highlight><bold>3</bold></highlight> read ports; this means that in any one instruction 3 bits can be read and one write can be issued. The write can be to one bit, or to an adjacent pair of bits whose address differs only in the least significant bit, referred to here as an even-odd bit pair. For certain operations RESVEC <highlight><bold>1208</bold></highlight> can also be accessed as a 32-bit by 16-entry register file. </paragraph>
<paragraph id="P-0445" lvl="0"><number>&lsqb;0445&rsqb;</number> When RESVEC_WE is a &lsquo;1&rsquo; and the microcode bit 2 BIT is a &lsquo;0&rsquo; then a single bit in RESVEC <highlight><bold>1208</bold></highlight> is written with the data presented on the DIN0 data input port; that data is selected from among <highlight><bold>4</bold></highlight> different sources under control of the RES0_SEL&lsqb;1:0&rsqb; bits in the microword. Alternatively if 2 BIT is a &lsquo;1&rsquo; then the DIN0 data is written to the even-numbered bit in the destination, and DIN1 selected from among two sources by RES1_SEL is written to the odd-numbered bit of the pair. </paragraph>
<paragraph id="P-0446" lvl="0"><number>&lsqb;0446&rsqb;</number> The destination address in RESVEC <highlight><bold>1208</bold></highlight> comes either from RES_BIT_DST&lsqb;9:0&rsqb; if state bit USE_WCNT is &lsquo;0&rsquo;, or from BDST_CNT <highlight><bold>1226</bold></highlight> if USE_WCNT is a &lsquo;1&rsquo;. USE_WCNT is set when SPECOP_EN is &lsquo;1&rsquo; and LD_BDST_CNT is a &lsquo;1&rsquo;. In that case BDST_CNT <highlight><bold>1226</bold></highlight> is written with the value RES_BIT_DST&lsqb;9:1&rsqb;. At the same time BDST_CNT <highlight><bold>1226</bold></highlight> is loaded, the bit BDST_CNT_MODE in the microword is examined. If it is &lsquo;0&rsquo; then BDST_CNT <highlight><bold>1226</bold></highlight> is set to increment by 2, if it is &lsquo;1&rsquo; then BDST_CNT <highlight><bold>1226</bold></highlight> is configured to increment by 32. The former is used in the special instruction CMPRN to sweep across sequential bit pairs in each cycle of the instruction and to write to them, while the latter is used for the RESVEC <highlight><bold>1208</bold></highlight> read address port RA0 to sequentially read 32-bit groups of RESVEC 1208 bits as the B-side special register RES_VEC. </paragraph>
<paragraph id="P-0447" lvl="0"><number>&lsqb;0447&rsqb;</number> The bit-oriented ALU <highlight><bold>1260</bold></highlight> contains two boolean logic units <highlight><bold>1264</bold></highlight> and <highlight><bold>1268</bold></highlight> and one gang operation unit <highlight><bold>1262</bold></highlight>. Boolean logic unit <highlight><bold>1264</bold></highlight> takes the two bits selected by RES_BIT_SRC_A&lsqb;9:0&rsqb; and RES_BIT_SRC_B&lsqb;9:0&rsqb; and applies the boolean operation BITOPAB&lsqb;3:0&rsqb; as specified in table <highlight><bold>20</bold></highlight>. The 1-bit result RES_BIT0 is one of the potential sources for write data port DIN0 on RESVEC <highlight><bold>1208</bold></highlight>. Boolean logic unit <highlight><bold>1268</bold></highlight> similarly takes the operands selected by RES_BIT_SRC_A&lsqb;9:0&rsqb; and RES_BIT_SRC_C&lsqb;9:0&rsqb; and applies BITOPAC&lsqb;3:0&rsqb; in a substantially similar manner, generating the 1-bit result RES_BIT1 which may be selected as the DIN1 write data source if 2 BIT is &lsquo;1&rsquo;. Thus in one cycle up to two bitwise boolean operations can be executed if the two operations have one common operand. The GANGOP unit <highlight><bold>1262</bold></highlight> takes the 32 adjacent bits from RESVEC <highlight><bold>1208</bold></highlight> selected by RES_BIT_SRC_A&lsqb;9:5&rsqb; and treats them as a word operand. MASK&lsqb;31:0&rsqb; is used to select which bits of that word will contribute to the gang results, then an AND, OR, NAND, or NOR operation is performed on all of the selected bits as instructed in GANGOP&lsqb;1:0&rsqb;, and the result bit RES_GANG is presented as one of the possible sources for DIN0 on RESVEC <highlight><bold>1208</bold></highlight>. </paragraph>
<paragraph id="P-0448" lvl="0"><number>&lsqb;0448&rsqb;</number> The condition code selected by CCSEL&lsqb;4:0&rsqb; and optionally inverted with FALSE can also be selected as the data source for port DIN0. </paragraph>
<paragraph id="P-0449" lvl="0"><number>&lsqb;0449&rsqb;</number> The remaining sources for DIN0 and DIN1 on RESVEC <highlight><bold>1208</bold></highlight> are the CMPR_A, CMPR_B result bits from one cycle of a bulk comparison instruction CMPRN, described below. </paragraph>
<paragraph id="P-0450" lvl="0"><number>&lsqb;0450&rsqb;</number> RESVEC <highlight><bold>1208</bold></highlight> address fields for sources and destination are specified as 10 bits, even though only 9 bits are used in the preferred embodiment; the extra bit allows for a doubling of the size of RESVEC <highlight><bold>1208</bold></highlight> in future generations of the device. </paragraph>
<paragraph id="P-0451" lvl="0"><number>&lsqb;0451&rsqb;</number> Writes to RESVEC <highlight><bold>1208</bold></highlight> are retired at the end of the Decode stage <highlight><bold>1304</bold></highlight> and can thus be used immediately as an operand in the subsequent instruction, without need for bypassing as is done with GPREG <highlight><bold>1206</bold></highlight>. </paragraph>
<paragraph id="P-0452" lvl="0"><number>&lsqb;0452&rsqb;</number> 2BIT, RES0_SEL&lsqb;1:0&rsqb;, RES1_SEL, BITOPAB, BITOPAC, GANGOP&lsqb;1:0&rsqb;, RES_BIT_DST&lsqb;9:0&rsqb;, RES_BIT_SRC_A&lsqb;9:0&rsqb;, RES_BIT_SRC_B&lsqb;9:0&rsqb;, RES_BIT_SRC_C&lsqb;9:0&rsqb;, MASK&lsqb;31:0&rsqb;, CCSEL&lsqb;4:0&rsqb;, FALSE are all defined in Table 16. </paragraph>
<paragraph id="P-0453" lvl="0"><number>&lsqb;0453&rsqb;</number> LD_BDST_CNT, BDST_CNT_MODE are specified in Table 22. </paragraph>
<paragraph id="P-0454" lvl="7"><number>&lsqb;0454&rsqb;</number> 1.7 Bulk Comparisons </paragraph>
<paragraph id="P-0455" lvl="0"><number>&lsqb;0455&rsqb;</number> When SPECOP_EN is &lsquo;1&rsquo; and LD_NCNT is also &lsquo;1&rsquo; the instruction cycle counter N_CNT <highlight><bold>1224</bold></highlight> is loaded with the value NCNT&lsqb;6:0&rsqb; (bits&lsqb;22:16&rsqb; of the microword) and the state bit CMPRN is set. LD_BDST_CNT is required to also be a &lsquo;1&rsquo; for this instruction, and BDST_CNT_MODE must be a &lsquo;0&rsquo;. BDST_CNT <highlight><bold>1226</bold></highlight> is loaded with the value RES_BIT_DST&lsqb;9:1&rsqb;. GPREG <highlight><bold>1206</bold></highlight> is locked with the A-side select RSRCA&lsqb;2:0&rsqb; and the B-side select RSRCB&lsqb;2:0&rsqb;. The bit CLEAR_HIT is required to be a &lsquo;1&rsquo; also in this instruction, which has the effect of setting the condition code register bits MTCH_A, MTCH_B, MTCH_AORB, MTCH_AANDB all to zero. </paragraph>
<paragraph id="P-0456" lvl="0"><number>&lsqb;0456&rsqb;</number> For the next N cycles, until N_CNT <highlight><bold>1224</bold></highlight> has decremented to zero, interpretation of the 64-bit microword is suppressed and all 64 bits are treated as data instead. In each of these cycles the microword bits &lsqb;63:32&rsqb; are compared to the selected A-side register value REGA using comparator <highlight><bold>1220</bold></highlight> to produce the result CMPR_A if they are equal; and microword bits &lsqb;31:0&rsqb; are compared to the selected B-side register value REGB using comparator <highlight><bold>1227</bold></highlight> to produce result CMPR_B if they are equal. Daring CMPRN the RESVEC unit <highlight><bold>1208</bold></highlight> is locked into a mode where 2 BIT is true and RES0_SEL and RES1_SEL select CMPR_A, CMPR_B respectively. The results CMPR_A and CMPR_B are stored to the even-odd pair of bits in RESVEC <highlight><bold>1208</bold></highlight> selected by BDST_CNT <highlight><bold>1226</bold></highlight>, then BDST_CNT <highlight><bold>1226</bold></highlight> is incremented, NCNT <highlight><bold>1224</bold></highlight> is decremented, and the process repeats until NCNT <highlight><bold>1224</bold></highlight> equals zero. At that point the state bits USE_BDST_CNT and CMPRN clear and the pipeline goes back to normal operation where every microword is interpreted. </paragraph>
<paragraph id="P-0457" lvl="0"><number>&lsqb;0457&rsqb;</number> During every comparison cycle of the CMPRN instruction, if CMPR_A is a &lsquo;1&rsquo; then the condition code bit MTCH_A will set and will stay set. Similarly if CMPR_B is a &lsquo;1&rsquo; during any of those cycles then bit MTCH_B will set and will stay set. If either CMPR_A or CMPR_B is true during any of these cycles then condition code bit MTCH_AORB will set and will stay set. Finally, if CMPR_A and CMPR_B are both &lsquo;1&rsquo; during a CMPRN compare cycle, then MTCH_AANDB will set and will stay set to indicate that a 64-bit match was encountered. </paragraph>
<paragraph id="P-0458" lvl="0"><number>&lsqb;0458&rsqb;</number> By loading one or two registers in GPREG <highlight><bold>1206</bold></highlight> with comparison values prior to executing the CMPRN instruction, a single value can be compared to (2*N) values in a table, or two different values can each be compared to (N) values, in ((2*N)&plus;1) execution cycles. </paragraph>
<paragraph id="P-0459" lvl="0"><number>&lsqb;0459&rsqb;</number> RES_BIT_DST&lsqb;9:0&rsqb;, RSRCA&lsqb;3:0&rsqb;, RSRCB&lsqb;3:0&rsqb;, 2 BIT, RES0_SEL, RES1_SEL are specified in Table 16. </paragraph>
<paragraph id="P-0460" lvl="0"><number>&lsqb;0460&rsqb;</number> LD_NCNT, LD_BDST_CNT, CLEAR_HIT are specified in Table 22. </paragraph>
<paragraph id="P-0461" lvl="7"><number>&lsqb;0461&rsqb;</number> 1.8 Special Operations </paragraph>
<paragraph id="P-0462" lvl="0"><number>&lsqb;0462&rsqb;</number> In addition to the special operations mentioned so far, there are other administrative functions which are enabled with SPECOP_EN and decoded from the bits specified in Table 22. Decode of these functions and any decode necessary for implementing the instruction set specified take place in the decoder block DCD <highlight><bold>1272</bold></highlight>. </paragraph>
<paragraph id="P-0463" lvl="7"><number>&lsqb;0463&rsqb;</number> 1.9 CMEM Fills </paragraph>
<paragraph id="P-0464" lvl="0"><number>&lsqb;0464&rsqb;</number> The microstore CMEM <highlight><bold>1202</bold></highlight> is filled either via a series of PIO write accesses from the Policy Processor <highlight><bold>244</bold></highlight> or Application Processor <highlight><bold>302</bold></highlight>, or can be loaded by use of the CTRL_FILL unit <highlight><bold>1210</bold></highlight>. The registers in CTRL_FILL <highlight><bold>1210</bold></highlight> are loaded with an address in memory <highlight><bold>260</bold></highlight>, an address in CMEM <highlight><bold>1202</bold></highlight>, and a count of the number of instructions to be loaded. With the CE pipeline halted, the CTRL_FILL unit will execute this transfer. </paragraph>
<paragraph id="P-0465" lvl="0"><number>&lsqb;0465&rsqb;</number> The transfer may be initiated by the Policy Processor <highlight><bold>244</bold></highlight>, the Application Processor <highlight><bold>302</bold></highlight>, or can be initiated by microcode running on the CE, in which case the CTRL_FILL <highlight><bold>1210</bold></highlight> registers appear as special register destinations as shown in Table 17, and the operation is triggered with an instruction which has SPECOP_EN equal to &lsquo;1&rsquo;, and HALT and DO_CMEM_FILL asserted. After the transfer completes, microcode can then continue execution, including the newly downloaded code. The CE can only load and launch itself if microcode to do so is already resident in CMEM <highlight><bold>1202</bold></highlight> and if the host has configured the CE to allow it to do so. </paragraph>
<paragraph id="P-0466" lvl="0"><number>&lsqb;0466&rsqb;</number> HALT and DO_CMEM_FILL are specified in Table 22. </paragraph>
<paragraph id="P-0467" lvl="7"><number>&lsqb;0467&rsqb;</number> 2. CE Programming Languages </paragraph>
<paragraph id="P-0468" lvl="0"><number>&lsqb;0468&rsqb;</number> CE programs can be written directly in binary; however for programmer convenience a microassembly language uasm has been developed which allows a microword to be constructed by declaring fields and their values in a symbolic form. The set of common microwords for the intended use of the CE have also been described in a higher-level CE Assembly Language called masm which allows the programmer to describe operations in a register-transfer format and to describe concurrent operations without having to worry about the details of microcode control of the underlying hardware. Both of these languages can be used by a programmer or can be generated automatically from a compiler which translates CE programs from a higher-level language such as NetBoost Classification Language (NCL). </paragraph>
</section>
<section>
<heading lvl="1">V. Microprogramming Guide </heading>
<paragraph id="P-0469" lvl="0"><number>&lsqb;0469&rsqb;</number> The 64-bit CE instruction word is raw microcode; some bits enable retirement of operations by writing to one or more units, and the rest are used to steer different data paths and to provide control codes to various units in parallel. Depending on which results are retired, the fields in the microword have different meaning. There are 7 different ways that the microword is interpreted; even though all steering is really done in parallel, these 7 instruction formats show which sets of fields can be used without conflict. </paragraph>
<paragraph id="P-0470" lvl="0"><number>&lsqb;0470&rsqb;</number> There are 7 bits that are constant in all formats; these are the bits that enable stores into various units. These bits are &lcub;REG_WE, RESVEC_WE, CC_WE, reserved, PMEM_WE, BRANCH_EN, and SPECOP_EN &rcub;, which are assigned in that order to bits &lsqb;63:57&rsqb; of the microword and are described in Table 16. The remaining bits are assigned to control points as shown in <cross-reference target="DRAWINGS">FIG. 13</cross-reference> and are defined in the following sections. </paragraph>
<paragraph id="P-0471" lvl="0"><number>&lsqb;0471&rsqb;</number> As shown in <cross-reference target="DRAWINGS">FIG. 14</cross-reference>, the CE is implemented as a 3-stage pipeline; each instruction passes through the three stages Fetch <highlight><bold>1302</bold></highlight>, Decode <highlight><bold>1304</bold></highlight>, and Execute <highlight><bold>1306</bold></highlight>; at any time there are three different instructions being processed. The figure shows what processes occur in each stage of the pipeline, and helps illustrate behavior of the pipeline shown in <cross-reference target="DRAWINGS">FIG. 13</cross-reference>. When the pipeline stalls all three stages stall together in lockstep. </paragraph>
<paragraph id="P-0472" lvl="0"><number>&lsqb;0472&rsqb;</number> Most word-oriented operations pass one operand through either the mask/shift unit or the split-add unit and then all word-oriented operations pass through the Execute-stage ALU before being retired. Any consumer of a newly-produced GPREG value actually receives a forwarded copy of the current ALU output via some bypass logic so that there is no delay between creation of a result and use of it in a subsequent operation. Similarly, use of condition codes for BRANCH (conditional flow control) or BSET (setting a selected RESVEC bit to the result of a condition code test), or reads of CC_REG (Condition Code Register) when the bits are being updated requires bypassing. </paragraph>
<paragraph id="P-0473" lvl="0"><number>&lsqb;0473&rsqb;</number> Other registers (e.g. BASE_REG) do not have forwarding so the software must delay one clock after writing them before using the result. </paragraph>
<paragraph id="P-0474" lvl="7"><number>&lsqb;0474&rsqb;</number> 1. Microword Format Definitions </paragraph>
<paragraph id="P-0475" lvl="7"><number>&lsqb;0475&rsqb;</number> 1.1 MOV, ALU, and LDST Operations </paragraph>
<paragraph id="P-0476" lvl="0"><number>&lsqb;0476&rsqb;</number> REG_WE is Set. </paragraph>
<paragraph id="P-0477" lvl="0"><number>&lsqb;0477&rsqb;</number> These instructions select 1 or 2 sources among GPREG and SPREG, do a mask/shift or split-add of the A-side operand, then pass them through the ALU and store the result to an SPREG or GPREG. Condition codes Z, N, V, SZ, and CY are optionally set by this operation if CC_WE is set.  
<table-cwu id="TABLE-US-00010">
<number>10</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="336PT" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center">TABLE 9</entry>
</row>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>MOV and ALU formats</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row>
<entry>
<chemistry-cwu id="CHEM-US-00001">
<number>1</number>
<image id="EMI-C00001" he="63.6174" wi="329.3136" file="US20030005103A1-20030102-C00001.TIF"/>
<chemistry-chemdraw-file id="CHEMCDX-00001" file="US20030005103A1-20030102-C00001.CDX"/>
<chemistry-mol-file id="CHEMMOL-00001" file="US20030005103A1-20030102-C00001.MOL"/>
</chemistry-cwu>
</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0478" lvl="0"><number>&lsqb;0478&rsqb;</number>  
<table-cwu id="TABLE-US-00011">
<number>11</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="322PT" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center">TABLE 10</entry>
</row>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>MOV and ALU formats with PMEM src</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row>
<entry>
<chemistry-cwu id="CHEM-US-00002">
<number>2</number>
<image id="EMI-C00002" he="66.7359" wi="314.9118" file="US20030005103A1-20030102-C00002.TIF"/>
<chemistry-chemdraw-file id="CHEMCDX-00002" file="US20030005103A1-20030102-C00002.CDX"/>
<chemistry-mol-file id="CHEMMOL-00002" file="US20030005103A1-20030102-C00002.MOL"/>
</chemistry-cwu>
</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0479" lvl="0"><number>&lsqb;0479&rsqb;</number> Note that with PMEM&lsqb;immediate_index&rsqb; as a source the ALU is bypassed (except for sign and zero-detect); however mask/rotate or split-add are still available.  
<table-cwu id="TABLE-US-00012">
<number>12</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="336PT" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center">TABLE 11</entry>
</row>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>LDST format</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row>
<entry>
<chemistry-cwu id="CHEM-US-00003">
<number>3</number>
<image id="EMI-C00003" he="63.6174" wi="329.3136" file="US20030005103A1-20030102-C00003.TIF"/>
<chemistry-chemdraw-file id="CHEMCDX-00003" file="US20030005103A1-20030102-C00003.CDX"/>
<chemistry-mol-file id="CHEMMOL-00003" file="US20030005103A1-20030102-C00003.MOL"/>
</chemistry-cwu>
</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0480" lvl="2"><number>&lsqb;0480&rsqb;</number> (a) SIZE&lsqb;1:0&rsqb;</paragraph>
<paragraph id="P-0481" lvl="2"><number>&lsqb;0481&rsqb;</number> (b) DIR </paragraph>
<paragraph id="P-0482" lvl="7"><number>&lsqb;0482&rsqb;</number> 1.2 BIT_OP </paragraph>
<paragraph id="P-0483" lvl="0"><number>&lsqb;0483&rsqb;</number> Bitops and gangops have RESVEC_WE set. These instructions select a bit RES_BIT_DST in RESVEC as a destination to which the RES0 result is written; and if (optionally) 2 BIT is set, then RES_BIT_DST is treated as the pointer to an adjacent pair of bits where the first has an even address and the second has the next (odd) address. With 2 BIT the odd bit is written with the RES1 result. </paragraph>
<paragraph id="P-0484" lvl="0"><number>&lsqb;0484&rsqb;</number> Depending on the value of the field RES0_SEL, the RES0 result may come from a boolean operation BITOPAB performed on the operands selected by RES_BIT_SRC_A and RES_BIT_SRC_B, or the result of a GANG operation performed on bits in the group of 32 RESVEC bits selected by RES_BIT_SRC_A&lsqb;9:5&rsqb; and further selected by the &ldquo;1&rdquo; bits in the 32-bit immediate MASK field, or the selected and optionally inverted condition code bit selected by CCSEL and FALSE, or the A-side result of a bulk table comparison CMPR_A. </paragraph>
<paragraph id="P-0485" lvl="0"><number>&lsqb;0485&rsqb;</number> If RES1 is being written to the odd bit of a pair, the RES1 result is selected by RES1_SEL to be either the result of the arbitrary boolean operation BITOPAC performed on the operands selected by RES_BIT_SRC_A and RES_BIT_SRC_C, or the B-side result of a bulk table comparison CMPR_B.  
<table-cwu id="TABLE-US-00013">
<number>13</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="343PT" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center">TABLE 12</entry>
</row>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>BIT_OP Format</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row>
<entry>
<chemistry-cwu id="CHEM-US-00004">
<number>4</number>
<image id="EMI-C00004" he="80.4006" wi="336.03255" file="US20030005103A1-20030102-C00004.TIF"/>
<chemistry-chemdraw-file id="CHEMCDX-00004" file="US20030005103A1-20030102-C00004.CDX"/>
<chemistry-mol-file id="CHEMMOL-00004" file="US20030005103A1-20030102-C00004.MOL"/>
</chemistry-cwu>
</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0486" lvl="2"><number>&lsqb;0486&rsqb;</number> (a) RES0_SEL&lsqb;1:0&rsqb;</paragraph>
<paragraph id="P-0487" lvl="2"><number>&lsqb;0487&rsqb;</number> (b) 2 BIT </paragraph>
<paragraph id="P-0488" lvl="2"><number>&lsqb;0488&rsqb;</number> (c) RES1_SEL </paragraph>
<paragraph id="P-0489" lvl="2"><number>&lsqb;0489&rsqb;</number> (d) FALSE (selects gender of CCMUX output; 0&equals;as is, I&equals;inverted) </paragraph>
<paragraph id="P-0490" lvl="7"><number>&lsqb;0490&rsqb;</number> 1.3 GANG_OP  
<table-cwu id="TABLE-US-00014">
<number>14</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="364PT" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center">TABLE 13</entry>
</row>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>GANG_OP Format</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row>
<entry>
<chemistry-cwu id="CHEM-US-00005">
<number>5</number>
<image id="EMI-C00005" he="68.40855" wi="355.9626" file="US20030005103A1-20030102-C00005.TIF"/>
<chemistry-chemdraw-file id="CHEMCDX-00005" file="US20030005103A1-20030102-C00005.CDX"/>
<chemistry-mol-file id="CHEMMOL-00005" file="US20030005103A1-20030102-C00005.MOL"/>
</chemistry-cwu>
</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0491" lvl="1"><number>&lsqb;0491&rsqb;</number> (a) GANG_OP&lsqb;1:0&rsqb;</paragraph>
<paragraph id="P-0492" lvl="7"><number>&lsqb;0492&rsqb;</number> 1.4 Branch </paragraph>
<paragraph id="P-0493" lvl="0"><number>&lsqb;0493&rsqb;</number> BRANCH_EN is always set in this format. Note that a register-to-register aluop can be folded into the same instruction as long as there are no other field conflicts.  
<table-cwu id="TABLE-US-00015">
<number>15</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="441PT" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center">TABLE 14</entry>
</row>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Branch Format</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row>
<entry>
<chemistry-cwu id="CHEM-US-00006">
<number>6</number>
<image id="EMI-C00006" he="76.80015" wi="405.405" file="US20030005103A1-20030102-C00006.TIF"/>
<chemistry-chemdraw-file id="CHEMCDX-00006" file="US20030005103A1-20030102-C00006.CDX"/>
<chemistry-mol-file id="CHEMMOL-00006" file="US20030005103A1-20030102-C00006.MOL"/>
</chemistry-cwu>
</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0494" lvl="2"><number>&lsqb;0494&rsqb;</number> (a) FALSE (selects gender of CCMUX output; 0&equals;as is, 1&equals;inverted) </paragraph>
<paragraph id="P-0495" lvl="2"><number>&lsqb;0495&rsqb;</number> (b) CALL </paragraph>
<paragraph id="P-0496" lvl="2"><number>&lsqb;0496&rsqb;</number> (c) RET </paragraph>
<paragraph id="P-0497" lvl="2"><number>&lsqb;0497&rsqb;</number> (d) REG (selects GPREG (&lsquo;1&rsquo;) or immediate value (&lsquo;0&rsquo;) for branch </paragraph>
<paragraph id="P-0498" lvl="7"><number>&lsqb;0498&rsqb;</number> 1.5 SPECOP </paragraph>
<paragraph id="P-0499" lvl="0"><number>&lsqb;0499&rsqb;</number> Special Operation bits (which are all qualified with SPECOP_EN) are defined in Section Table 22 on page 94. The instructions cmprn, setpcnt&lsqb;i&rsqb;, and set_resvec_index also use some specop fields.  
<table-cwu id="TABLE-US-00016">
<number>16</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="385PT" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center">TABLE 15</entry>
</row>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>SPECOP Format</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row>
<entry>
<chemistry-cwu id="CHEM-US-00007">
<number>7</number>
<image id="EMI-C00007" he="97.6941" wi="378.756" file="US20030005103A1-20030102-C00007.TIF"/>
<chemistry-chemdraw-file id="CHEMCDX-00007" file="US20030005103A1-20030102-C00007.CDX"/>
<chemistry-mol-file id="CHEMMOL-00007" file="US20030005103A1-20030102-C00007.MOL"/>
</chemistry-cwu>
</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0500" lvl="2"><number>&lsqb;0500&rsqb;</number> (a) RES0_SEL&lsqb;1:0&rsqb; (for CMPRN) </paragraph>
<paragraph id="P-0501" lvl="2"><number>&lsqb;0501&rsqb;</number> (b) 2 BIT (for CMPRN) </paragraph>
<paragraph id="P-0502" lvl="2"><number>&lsqb;0502&rsqb;</number> (c) RES1_SEL (for CMPRN) </paragraph>
<paragraph id="P-0503" lvl="2"><number>&lsqb;0503&rsqb;</number> (*) The interpretation of these bits is defined in Table 22 of page 94. </paragraph>
<paragraph id="P-0504" lvl="2"><number>&lsqb;0504&rsqb;</number> (&quest;) Undefined but reserved for future special operations </paragraph>
<paragraph id="P-0505" lvl="7"><number>&lsqb;0505&rsqb;</number> 1.6 Control Field Definitions  
<table-cwu id="TABLE-US-00017">
<number>17</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="371PT" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center">TABLE 16</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Control Fields</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="63PT" align="left"/>
<colspec colname="2" colwidth="273PT" align="left"/>
<colspec colname="3" colwidth="35PT" align="left"/>
<tbody valign="top">
<row>
<entry>Signals</entry>
<entry>Function</entry>
<entry>Bits</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>WE&lsqb;6:0&rsqb;</entry>
<entry>These are the fixed-format signals which retire results (unless the pipeline is</entry>
<entry>&lsqb;63:57&rsqb;</entry>
</row>
<row>
<entry></entry>
<entry>stalled); they are:</entry>
</row>
<row>
<entry></entry>
<entry>&lsqb;0&rsqb; SPECOP_EN: enables special ops as defined in 9.2.5.</entry>
</row>
<row>
<entry></entry>
<entry>&lsqb;1&rsqb; BRANCH_EN: Enables a conditional program flow control operation</entry>
</row>
<row>
<entry></entry>
<entry>&lsqb;2&rsqb; PMEM_WE: Enables stores into PMEM</entry>
</row>
<row>
<entry></entry>
<entry>&lsqb;3&rsqb; reserved</entry>
</row>
<row>
<entry></entry>
<entry>&lsqb;4&rsqb; CC_WE: Enables store to CC_Z, CC_CY, CC_SZ, CC_V, CC_N</entry>
</row>
<row>
<entry></entry>
<entry>&lsqb;5&rsqb; RESVEC_WE: Enables stores to the result bit vector</entry>
</row>
<row>
<entry></entry>
<entry>&lsqb;6&rsqb; REG_WE: Enables stores of ALU_OUT into the GPREG file if(RDST&lsqb;3&rsqb; &equals; 0),</entry>
</row>
<row>
<entry></entry>
<entry>or into SPREG&apos;s if(RDST&lsqb;3&rsqb; 1).</entry>
</row>
<row>
<entry>RSRCA&lsqb;3:0&rsqb;</entry>
<entry>Selects a GPREG to drive out on DOUT0 (using &lsqb;2:0&rsqb;) and selects between</entry>
<entry>&lsqb;35:32&rsqb;</entry>
</row>
<row>
<entry></entry>
<entry>GPREG and SPREG sources on the mux to SPLIT-ADD and MASK using &lsqb;3&rsqb;</entry>
</row>
<row>
<entry>RSRCB&lsqb;3:0&rsqb;</entry>
<entry>Selects a GPREG to drive out on DOUT1 (using &lsqb;2:0&rsqb;) and selects between that</entry>
<entry>&lsqb;39 36&rsqb;</entry>
</row>
<row>
<entry></entry>
<entry>and SPREG sources on the ALUB input mux</entry>
</row>
<row>
<entry>RDST&lsqb;3:0&rsqb;</entry>
<entry>Selects which GPREG to enable the WE onto with &lsqb;2:0&rsqb; if &lsqb;3&rsqb;&equals;0; and if &lsqb;3&rsqb; &equals; 1,</entry>
<entry>&lsqb;56:53&rsqb;</entry>
</row>
<row>
<entry></entry>
<entry>&lsqb;2:0&rsqb; is decoded to select which SPREG to write to.</entry>
</row>
<row>
<entry>ROT&lsqb;4:0&rsqb;</entry>
<entry>Steers the 32-bit barrel shifter</entry>
</row>
<row>
<entry>MSK&lsqb;1&rsqb;</entry>
<entry>If &lsqb;1&rsqb; then masking is enabled; if &lsqb;0&rsqb; then pass-thru</entry>
</row>
<row>
<entry>MSK&lsqb;0&rsqb;</entry>
<entry>If &lsqb;1&rsqb; selects MASK/ROTATE output, if &lsqb;0&rsqb; selects SPLIT_ADD output, on ALUA</entry>
<entry>&lsqb;51&rsqb;</entry>
</row>
<row>
<entry></entry>
<entry>input mux.</entry>
</row>
<row>
<entry>ALUOP&lsqb;5:4&rsqb;</entry>
<entry>&lsqb;1x&rsqb; selects ALUA input as ALU_OUT The reason for this is to enable a MOV</entry>
<entry>&lsqb;45:44&rsqb;</entry>
</row>
<row>
<entry></entry>
<entry>from PMEM&lsqb;index&rsqb; with mask and rot; but we lose ALUOP due to bit overlays, so</entry>
</row>
<row>
<entry></entry>
<entry>we can&apos;t use the ALU in the same instruction.</entry>
</row>
<row>
<entry></entry>
<entry>&lsqb;00&rsqb; selects ADDER output</entry>
</row>
<row>
<entry></entry>
<entry>&lsqb;01&rsqb; selects LOGIC output</entry>
</row>
<row>
<entry>ALUOP&lsqb;3:0&rsqb;</entry>
<entry>On LOGIC unit, these 4 bits are the mux Inputs steered by the bit pairs.</entry>
<entry>&lsqb;43:40&rsqb;</entry>
</row>
<row>
<entry>ALUOP&lsqb;1:0&rsqb;</entry>
<entry>Selects CY_IN to ADDER:</entry>
<entry>&lsqb;41:40&rsqb;</entry>
</row>
<row>
<entry></entry>
<entry>&lsqb;00&rsqb; selects &ldquo;0&rdquo;</entry>
</row>
<row>
<entry></entry>
<entry>&lsqb;01&rsqb; selects &ldquo;1&rdquo; (for subtracts)</entry>
</row>
<row>
<entry></entry>
<entry>&lsqb;1x&rsqb; selects CC_REG_CY</entry>
</row>
<row>
<entry>ALUOP&lsqb;2&rsqb;</entry>
<entry>If&lsquo;1&rsquo;, inverts ADDER input on the A port.</entry>
<entry>&lsqb;42&rsqb;</entry>
</row>
<row>
<entry>ALUOP&lsqb;3&rsqb;</entry>
<entry>lf&lsquo;1&rsquo;, inverts ADDER input on the B port.</entry>
<entry>&lsqb;43&rsqb;</entry>
</row>
<row>
<entry>IMMEDIATE</entry>
<entry>32-bit immediate value used on ALUB input path; if (RDST &equals; MEM_ADDR)</entry>
<entry>&lsqb;31:0&rsqb;</entry>
</row>
<row>
<entry></entry>
<entry>then only bits &lsqb;27:0&rsqb; are used</entry>
</row>
<row>
<entry>MASK</entry>
<entry>32-bit immediate value used in MASK and GANG_OP units for bit masking;</entry>
<entry>&lsqb;31:0&rsqb;</entry>
</row>
<row>
<entry></entry>
<entry>AND&apos;ed with the input value</entry>
</row>
<row>
<entry>PINDEX&lsqb;10:2&rsqb;</entry>
<entry>Used to address words in PMEM for MOV operations and for loading PCNT for</entry>
<entry>&lsqb;44:36&rsqb;</entry>
</row>
<row>
<entry></entry>
<entry>sequential pmem operations. a.k.a. INDEX&lsqb;8:0&rsqb;</entry>
</row>
<row>
<entry>MEMSIZE&lsqb;1:0&rsqb;</entry>
<entry>In LDST format, indicates the size to MEM_ADDR:</entry>
<entry>&lsqb;31:30&rsqb;</entry>
</row>
<row>
<entry></entry>
<entry>&lsqb;00&rsqb;: 1 word</entry>
</row>
<row>
<entry></entry>
<entry>&lsqb;01&rsqb;: 2 words (only aligned double-word allowed)</entry>
</row>
<row>
<entry></entry>
<entry>&lsqb;10&rsqb;: 4 words (aligned on a 16-byte boundary)</entry>
</row>
<row>
<entry></entry>
<entry>&lsqb;11&rsqb;: 8-word burst (aligned on an 8-word (32-byte) boundary)</entry>
</row>
<row>
<entry></entry>
<entry>Note that hardware masks the lower address bits to force size-alignment</entry>
</row>
<row>
<entry>MEM_DIR</entry>
<entry>In LDST format, &lsqb;1&rsqb; is a store, &lsqb;0&rsqb; is a load from memory</entry>
<entry>&lsqb;29&rsqb;</entry>
</row>
<row>
<entry>RES_BIT_SRC_A</entry>
<entry>Selects a bit of the 512-bit result vector; bit &lsqb;9&rsqb; is not connected, leaves room for</entry>
<entry>&lsqb;41:32&rsqb;</entry>
</row>
<row>
<entry>&lsqb;9:0&rsqb;</entry>
<entry>future growth. Bits&lsqb;8:5&rsqb; select the word to port W0&lsqb;31:0&rsqb; on the file. Bits&lsqb;4:0&rsqb;</entry>
</row>
<row>
<entry></entry>
<entry>select the bit within the word to port BO</entry>
</row>
<row>
<entry>RES_BIT_SRC_B</entry>
<entry>Same as above, but to word W1 and bit B1.</entry>
<entry>&lsqb;31:22&rsqb;</entry>
</row>
<row>
<entry>&lsqb;9.0&rsqb;</entry>
</row>
<row>
<entry>RES_BIT_SRC_C</entry>
<entry>Same as above, but to word W2 and bit B2.</entry>
<entry>&lsqb;21:12&rsqb;</entry>
</row>
<row>
<entry>&lsqb;9:0&rsqb;</entry>
</row>
<row>
<entry>RES_BIT_DST</entry>
<entry>&lsqb;9&rsqb; is reserved for future growth. &lsqb;8:5&rsqb; are decoded to a row select, and &lsqb;4:0&rsqb; are</entry>
<entry>&lsqb;56:47&rsqb;</entry>
</row>
<row>
<entry>&lsqb;9:0&rsqb;</entry>
<entry>decoded to a column select for enabling the bit write.</entry>
</row>
<row>
<entry>RES0_SEL&lsqb;1:0&rsqb;</entry>
<entry>Mux select for the DIN0 bit to RESVEC;</entry>
<entry>&lsqb;46:45&rsqb;</entry>
</row>
<row>
<entry></entry>
<entry>&lsqb;00&rsqb;: CMPR_A</entry>
</row>
<row>
<entry></entry>
<entry>&lsqb;01&rsqb;: RES_BIT0</entry>
</row>
<row>
<entry></entry>
<entry>&lsqb;10&rsqb;: RES_GANG</entry>
</row>
<row>
<entry></entry>
<entry>&lsqb;11&rsqb;: COND_CODE as selected by &lcub;FALSE, CC_SEL&lsqb;4:0&rsqb;&rcub;</entry>
</row>
<row>
<entry>RESI_SEL</entry>
<entry>Mux select for the DIN1 bit to RESVEC, used if 2BIT is set;</entry>
<entry>&lsqb;43&rsqb;</entry>
</row>
<row>
<entry></entry>
<entry>&lsqb;0&rsqb;: CMPR_B</entry>
</row>
<row>
<entry></entry>
<entry>&lsqb;1&rsqb;: RES_BIT1</entry>
</row>
<row>
<entry>2BIT</entry>
<entry>Enables next-neighbor write to odd-numbered bits in RESVEC, for operations with</entry>
<entry>&lsqb;44&rsqb;</entry>
</row>
<row>
<entry></entry>
<entry>two results (dbitop, cmprn)</entry>
</row>
<row>
<entry>BITOP_AB&lsqb;3:0&rsqb;</entry>
<entry>These bits are selected by &lcub;BIT1, BIT0&rcub; to provide arbitrary boolean functions on</entry>
<entry>&lsqb;7:4&rsqb;</entry>
</row>
<row>
<entry></entry>
<entry>the bits: &lcub;00&rcub;-&gt;&lsqb;01&rsqb;, &lcub;01&rcub;-&gt;&lsqb;1&rsqb;, &lcub;10&rcub;-&gt;&lsqb;2&rsqb;, &lcub;11&rcub;-&gt;&lsqb;3&rsqb;</entry>
</row>
<row>
<entry>GANG_OP&lsqb;1&rsqb;</entry>
<entry>Mux steering. &lsquo;1&rsquo;&equals;AND, &lsquo;0&rsquo;&equals;OR</entry>
<entry>&lsqb;43&rsqb;</entry>
</row>
<row>
<entry>GANG_OP&lsqb;0&rsqb;</entry>
<entry>Inverts result if &lsquo;1&rsquo; to create NAND or NOR</entry>
<entry>&lsqb;42&rsqb;</entry>
</row>
<row>
<entry>BRANCH&lsqb;9:0&rsqb;</entry>
<entry>If BRANCH condition passes, this is the signed relative branch offset in CMEM</entry>
<entry>&lsqb;9:0&rsqb;</entry>
</row>
<row>
<entry>CALL</entry>
<entry>Loads a copy of (PC &plus; 1) into the microstack; timed so that the address saved is one</entry>
<entry>&lsqb;31&rsqb;</entry>
</row>
<row>
<entry></entry>
<entry>past the branch delay slot, and bumps microstack pointer</entry>
</row>
<row>
<entry>RET</entry>
<entry>Forces the contents of the microstack register into the PC reg and decrements the</entry>
<entry>&lsqb;30&rsqb;</entry>
</row>
<row>
<entry></entry>
<entry>microstack pointer</entry>
</row>
<row>
<entry>BRANCH_REG</entry>
<entry>If &lsquo;1&rsquo;, branch to REG_B output on a branch/call: if &lsquo;0&rsquo; branch to the immediate</entry>
<entry>&lsqb;29&rsqb;</entry>
</row>
<row>
<entry></entry>
<entry>value</entry>
</row>
<row>
<entry>FALSE</entry>
<entry>If &lsquo;1&rsquo;, invert the output of the CC_MUX</entry>
<entry>&lsqb;27&rsqb;</entry>
</row>
<row>
<entry>CC_SEL&lsqb;4:0&rsqb;</entry>
<entry>Selects a condition code bit for a branch decision</entry>
<entry>&lsqb;26:22&rsqb;</entry>
</row>
<row>
<entry>Special ops</entry>
<entry>Defined in &ldquo;SPECOP bit assignments&rdquo; on page 46</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0506" lvl="7"><number>&lsqb;0506&rsqb;</number> 2. Register Select Codes </paragraph>
<paragraph id="P-0507" lvl="7"><number>&lsqb;0507&rsqb;</number> 2.1 A-Side Operands and Destination Registers  
<table-cwu id="TABLE-US-00018">
<number>18</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center">TABLE 17</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Register Select Codes for Destinations and for A-side Sources</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="49PT" align="left"/>
<colspec colname="3" colwidth="56PT" align="left"/>
<colspec colname="4" colwidth="77PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>REG&lsqb;3&rsqb; &equals; 0,</entry>
<entry>REG&lsqb;3&rsqb; &equals; 1,</entry>
<entry></entry>
</row>
<row>
<entry>REG&lsqb;2:0&rsqb;</entry>
<entry>Src. or Dst.</entry>
<entry>Dst.</entry>
<entry>REG&lsqb;3&rsqb; &equals; 1, Src.</entry>
</row>
<row><entry namest="1" nameend="4" align="center" rowsep="1"></entry>
</row>
<row>
<entry>0b000</entry>
<entry>GPREG0 (g0)</entry>
<entry>NULL (discard)</entry>
<entry>CC_REG</entry>
</row>
<row>
<entry>0b001</entry>
<entry>GPREG1 (g1)</entry>
<entry>BASE_REG</entry>
<entry>BASE_REG</entry>
</row>
<row>
<entry>0b010</entry>
<entry>GPREG2 (g2)</entry>
<entry>DFIFO_W</entry>
<entry>DFIFO_R</entry>
</row>
<row>
<entry>0b011</entry>
<entry>GPREG3 (g3)</entry>
<entry>MEM_ADDR</entry>
<entry>BASE_REG_MSK</entry>
</row>
<row>
<entry>0b100</entry>
<entry>GPREG4 (g4)</entry>
<entry></entry>
<entry>PMEM</entry>
</row>
<row>
<entry>0b101</entry>
<entry>GPREG5 (gS)</entry>
<entry>CEFADR</entry>
</row>
<row>
<entry>0b110</entry>
<entry>GPREG6 (g6)</entry>
<entry>CESTART</entry>
</row>
<row>
<entry>0b111</entry>
<entry>GPREG7 (g7)</entry>
<entry>CECNT</entry>
</row>
<row><entry namest="1" nameend="4" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0508" lvl="7"><number>&lsqb;0508&rsqb;</number> 2.2 B-Side Operands  
<table-cwu id="TABLE-US-00019">
<number>19</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center">TABLE 18</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Register Select Codes for B-side Sources</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="63PT" align="left"/>
<colspec colname="3" colwidth="98PT" align="left"/>
<tbody valign="top">
<row>
<entry>REG&lsqb;2:0&rsqb;</entry>
<entry>REG&lsqb;3&rsqb; &equals; 0</entry>
<entry>REG&lsqb;3&rsqb; &equals;+09 1</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>0b000</entry>
<entry>GPREG0 (g0)</entry>
<entry>IMMEDIATE</entry>
</row>
<row>
<entry>0b001</entry>
<entry>GPREG1 (g1)</entry>
<entry>IMMED_ADDR&lsqb;27:0&rsqb;</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>(&lsqb;31:28&rsqb; are 0&times;0)</entry>
</row>
<row>
<entry>0b010</entry>
<entry>GPREG2 (g2)</entry>
<entry>DURATION</entry>
</row>
<row>
<entry>0b011</entry>
<entry>GPREG3 (g3)</entry>
<entry>MEM_WAIT</entry>
</row>
<row>
<entry>0b100</entry>
<entry>GPREG4 (g4)</entry>
<entry>TIMER</entry>
</row>
<row>
<entry>0b101</entry>
<entry>GPREG5 (g5)</entry>
<entry>DIAG_REG</entry>
</row>
<row>
<entry>0b110</entry>
<entry>GPREG6 (g6)</entry>
</row>
<row>
<entry>0b111</entry>
<entry>GPREG7 (g7)</entry>
<entry>RESVEC &lsqb;1&rsqb;</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0509" lvl="7"><number>&lsqb;0509&rsqb;</number> &lsqb;1&rsqb; Indirect addressing of RESVEC: RESVEC accesses a word of the result vector pointed to by WCNT (which was loaded via a specop) and then autoincrements the index. After the RESVEC store to dfifo is completed a resvec_index_unlock must be executed to enable random access to RESVEC. </paragraph>
<paragraph id="P-0510" lvl="7"><number>&lsqb;0510&rsqb;</number> 3. ALU and Logic Operations </paragraph>
<paragraph id="P-0511" lvl="7"><number>&lsqb;0511&rsqb;</number> 3.1 Adder Op Codes  
<table-cwu id="TABLE-US-00020">
<number>20</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center">TABLE 19</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>ALUOP Bit Specifications for ADDER (ALUOP&lsqb;4&rsqb;&equals;0)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="98PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="center"/>
<colspec colname="3" colwidth="63PT" align="left"/>
<tbody valign="top">
<row>
<entry>OPERATION</entry>
<entry>ALUOP&lsqb;3:0&rsqb;</entry>
<entry>&lt;ALUop&gt; Name</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>A &plus; B</entry>
<entry>0b0000</entry>
<entry>ADD</entry>
</row>
<row>
<entry>A &plus; B &plus; CY</entry>
<entry>0b0010</entry>
<entry>ADC</entry>
</row>
<row>
<entry>A &plus; B &plus; 1</entry>
<entry>0b0001</entry>
<entry>ADINC</entry>
</row>
<row>
<entry>A &minus; B</entry>
<entry>0b1001</entry>
<entry>SUB</entry>
</row>
<row>
<entry>A &minus; B &minus; {overscore (CY)} (A &plus; {overscore (B)} &plus; CY)</entry>
<entry>0b1010</entry>
<entry>SUBB</entry>
</row>
<row>
<entry>A &minus; B &minus; 1</entry>
<entry>0b1000</entry>
<entry>SBDEC</entry>
</row>
<row>
<entry>B &minus; A</entry>
<entry>0b0101</entry>
<entry>SBR (Reverse)</entry>
</row>
<row>
<entry>B &minus; A &minus; 1</entry>
<entry>0b0100</entry>
<entry>SBRDEC</entry>
</row>
<row>
<entry>B &minus; A &minus; {overscore (CY)} ({overscore (A)} &plus; B &plus; CY)</entry>
<entry>0b0110</entry>
<entry>SBRB</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0512" lvl="7"><number>&lsqb;0512&rsqb;</number> 3.2 Logic Op and BITOP Codes  
<table-cwu id="TABLE-US-00021">
<number>21</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center">TABLE 20</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>ALUOP Bit Specifications for LOGIC (ALUOP&lsqb;4&rsqb; &equals; 1)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="77PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="70PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>OPERATION</entry>
<entry>ALUOP&lsqb;3:0&rsqb;</entry>
<entry>&lt;ALUop&gt; Name</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry></entry>
<entry>AND</entry>
<entry>0b1000</entry>
<entry>AND</entry>
</row>
<row>
<entry></entry>
<entry>OR</entry>
<entry>0b1110</entry>
<entry>OR</entry>
</row>
<row>
<entry></entry>
<entry>XOR</entry>
<entry>0b0110</entry>
<entry>XOR</entry>
</row>
<row>
<entry></entry>
<entry>NAND</entry>
<entry>0b0111</entry>
<entry>NAND</entry>
</row>
<row>
<entry></entry>
<entry>NOR</entry>
<entry>0b0001</entry>
<entry>NOR</entry>
</row>
<row>
<entry></entry>
<entry>XNOR</entry>
<entry>0b1001</entry>
<entry>XNOR</entry>
</row>
<row>
<entry></entry>
<entry>INVERT_A</entry>
<entry>0b0011</entry>
<entry>INVA</entry>
</row>
<row>
<entry></entry>
<entry>INVERT_B</entry>
<entry>0b0101</entry>
<entry>INVB</entry>
</row>
<row>
<entry></entry>
<entry>PASS_A</entry>
<entry>0b1100</entry>
<entry>PASSA</entry>
</row>
<row>
<entry></entry>
<entry>PASS_B</entry>
<entry>0b1010</entry>
<entry>PASSB</entry>
</row>
<row>
<entry></entry>
<entry>ZERO</entry>
<entry>0b0000</entry>
<entry>ZERO</entry>
</row>
<row>
<entry></entry>
<entry>ONES</entry>
<entry>0b1111</entry>
<entry>ONES</entry>
</row>
<row>
<entry></entry>
<entry>A_AND_NOT_B</entry>
<entry>0b0100</entry>
<entry>AANDNB</entry>
</row>
<row>
<entry></entry>
<entry>B_AND_NOT_A</entry>
<entry>0b0010</entry>
<entry>BANDNA</entry>
</row>
<row>
<entry></entry>
<entry>B_OR_NOT_A</entry>
<entry>0b1011</entry>
<entry>BORNA</entry>
</row>
<row>
<entry></entry>
<entry>A_OR_NOT_B</entry>
<entry>0b1101</entry>
<entry>AORNB</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0513" lvl="0"><number>&lsqb;0513&rsqb;</number> BITOP&apos;s and 32-bit Logic operations use the two operand bits as selects into a MUX which select among 4 bits provided in the instruction. The encoding for logic operations uses the value of each pair of operand bits &lcub;A,B&rcub; to select which bit of ALUOP&lsqb;3:0&rsqb; provides the result, When the logic operation is performed on bit operands from RESVEC the bits &lcub;bsrcb, bsrca&rcub; provide the same selection of bits from the BITOP field (that is, for bitopab we use &lcub;b1,b0&rcub; and for bitopac we use &lcub;b2,b0&rcub; as operands:  
<table-cwu id="TABLE-US-00022">
<number>22</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="5">
<colspec colname="1" colwidth="161PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="42PT" align="left"/>
<colspec colname="4" colwidth="42PT" align="left"/>
<colspec colname="5" colwidth="42PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="5" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>Operand &lcub;b1,b0&rcub; or &lcub;b2,b0&rcub; (or bits of &lcub;opA,opB &rcub;)</entry>
<entry>&lcub;1,1&rcub;</entry>
<entry>&lcub;1,0&rcub;</entry>
<entry>&lcub;0,1&rcub;</entry>
<entry>&lcub;0,0&rcub;</entry>
</row>
<row>
<entry>BITOP (or ALUOP) bit selected as the result</entry>
<entry>BITOPAx&lsqb;3&rsqb;</entry>
<entry>BITOPAx&lsqb;2&rsqb;</entry>
<entry>BITOPAx&lsqb;1&rsqb;</entry>
<entry>BITOPAx&lsqb;0&rsqb;</entry>
</row>
<row><entry namest="1" nameend="5" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0514" lvl="7"><number>&lsqb;0514&rsqb;</number> 4. Condition Code Selects </paragraph>
<paragraph id="P-0515" lvl="0"><number>&lsqb;0515&rsqb;</number> Each of these values can be tested true or inverted based on bit &ldquo;F&rdquo; in the instruction.  
<table-cwu id="TABLE-US-00023">
<number>23</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center">TABLE 21</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Condition Code MUX values</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="63PT" align="left"/>
<colspec colname="3" colwidth="119PT" align="left"/>
<tbody valign="top">
<row>
<entry>CC_SEL</entry>
<entry>Bit</entry>
<entry>Notes</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>0b00000</entry>
<entry>TRUE</entry>
<entry>For unconditional branch</entry>
</row>
<row>
<entry>0b00001</entry>
<entry>CY</entry>
<entry>Last saved Carry (or a bypass of it if</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>the preceeding instruction had</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>CC_WE set)</entry>
</row>
<row>
<entry>0b00010</entry>
<entry>Z</entry>
<entry>Last saved Zero (or a bypass of it)</entry>
</row>
<row>
<entry>0b00011</entry>
<entry>N</entry>
<entry>Sign bit of last result (or a bypass of it)</entry>
</row>
<row>
<entry>0b00100</entry>
<entry>V</entry>
<entry>Signed overflow (CY{circumflex over (&thinsp;)}N) of last result</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>(or a bypass of it)</entry>
</row>
<row>
<entry>0b00101</entry>
<entry>GT</entry>
<entry>CY &amp;&amp; Z (unsigned Greater Than)</entry>
</row>
<row>
<entry>0b00110</entry>
<entry>LT</entry>
<entry>CY (unsigned Less Than)</entry>
</row>
<row>
<entry>0b00111</entry>
<entry>GE</entry>
<entry>CY &par; Z (unsigned Greater Than or</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>Equal)</entry>
</row>
<row>
<entry>0b01000</entry>
<entry>LE</entry>
<entry>CY &par; Z (unsigned Less Than or Equal)</entry>
</row>
<row>
<entry>0b01001</entry>
<entry>SZ</entry>
<entry>STICKY_Z, set via a SPECOP. Each</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>time CC_Z is written, this bit will clear</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>if CC_Z_I is &lsquo;0&rsquo;, otherwise it holds its</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>previous value.</entry>
</row>
<row>
<entry>0b01010</entry>
<entry>RX_RING</entry>
<entry>RX Ring has at least one buffer for this</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>CE</entry>
</row>
<row>
<entry>0b01011</entry>
<entry>RECLASS_RING</entry>
<entry>Reclassify Ring has at least one buffer</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>for this CE</entry>
</row>
<row>
<entry>0b01100</entry>
<entry>PEND_RD_WAIT</entry>
<entry>There is a read pending for which some</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>data has not yet arrived in DFIFO_R</entry>
</row>
<row>
<entry>0b01101</entry>
<entry>PEND_WR</entry>
<entry>DFIFO_W has at least one word in it</entry>
</row>
<row>
<entry>0b01110</entry>
<entry>PEND_ADDR</entry>
<entry>MEM_ADDR has at least one address</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>in it</entry>
</row>
<row>
<entry>0b01111</entry>
<entry>RES_BIT</entry>
<entry>Selected bit of Result Vector (using</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>bit2 (port C))</entry>
</row>
<row>
<entry>0b10000</entry>
<entry>MSG_IN_A</entry>
<entry>These are the message bits from the PP</entry>
</row>
<row>
<entry>0b10001</entry>
<entry>MSG_IN_B</entry>
<entry>or AP to the microcode indicating that</entry>
</row>
<row>
<entry>0b10010</entry>
<entry>MSG_IN_C</entry>
<entry>an action is to be taken (CTRL fill, hash</entry>
</row>
<row>
<entry>0b10011</entry>
<entry>MSG_IN_D</entry>
<entry>insert or delete, etc). These are assigned</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>by software convention. Note that when</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>a BRANCH_cc is made on any of</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>these bits the associated CCREG bit</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>will clear when the branch is taken.</entry>
</row>
<row>
<entry>0b10100</entry>
<entry>SGT</entry>
<entry>Z &amp;&amp; N (Signed greater-than)</entry>
</row>
<row>
<entry>0b10101</entry>
<entry>SLT</entry>
<entry>Z &amp;&amp; N (Signed less-than)</entry>
</row>
<row>
<entry>0b10110</entry>
<entry>SGE</entry>
<entry>Z &par; N (Signed greater-than-or-equal)</entry>
</row>
<row>
<entry>0b10111</entry>
<entry>SLE</entry>
<entry>Z &par; N (Signed less-than-or-equal)</entry>
</row>
<row>
<entry>0b11000</entry>
<entry>PEND_RD_DATA</entry>
<entry>At least one word is available in</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>DFIFO_R</entry>
</row>
<row>
<entry>0b11001</entry>
<entry>MTCH_AORB</entry>
<entry>Any A- or B-side operand matched</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>during a cmprn instruction</entry>
</row>
<row>
<entry>0b11010</entry>
<entry>MTCH_A</entry>
<entry>Any A-side operand matched during a</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>cmprn instruction</entry>
</row>
<row>
<entry>0b11011</entry>
<entry>MTCH_B</entry>
<entry>Any B-side operand matched during a</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>cmprn instruction</entry>
</row>
<row>
<entry>0b11100</entry>
<entry>MTCH_AANDB</entry>
<entry>Any 64-bit A-B pair operand matched</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>during a cmprn instruction</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0516" lvl="7"><number>&lsqb;0516&rsqb;</number> 5. Special Operation Fields </paragraph>
<paragraph id="P-0517" lvl="0"><number>&lsqb;0517&rsqb;</number> These bits are enabled by SPECOP_EN.  
<table-cwu id="TABLE-US-00024">
<number>24</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center">TABLE 22</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>SPECOP bit assignments</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="70PT" align="left"/>
<colspec colname="3" colwidth="119PT" align="left"/>
<tbody valign="top">
<row>
<entry>Bit</entry>
<entry>Name</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>&ensp;&lsqb;0&rsqb;</entry>
<entry>unlock_pcnt</entry>
<entry>Puts PCNT counter back into normal</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>immediate-P-index mode</entry>
</row>
<row>
<entry>&ensp;&lsqb;1&rsqb;</entry>
<entry>unlock_resvec_index</entry>
<entry>Puts RESVEC index counter back into</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>normal immediate mode</entry>
</row>
<row>
<entry>&ensp;&lsqb;2&rsqb;</entry>
<entry>inc_rx_index</entry>
<entry>Increments CE_CONS pointer in this</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>CE&apos;s RX ring</entry>
</row>
<row>
<entry>&ensp;&lsqb;3&rsqb;</entry>
<entry>inc_reclassify_index</entry>
<entry>Increments CE_CONS pointer in this</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>CE&apos;s RECLASS ring</entry>
</row>
<row>
<entry>&ensp;&lsqb;4&rsqb;</entry>
<entry>clear_hit</entry>
<entry>Clears CCREG&lsqb;MTCH_A,MTCH_B,</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>MTCH_AORB,MTCH_AANDB&rsqb;</entry>
</row>
<row>
<entry>&ensp;&lsqb;5&rsqb;</entry>
<entry>clear_duration</entry>
<entry>Sets the DURATION counter to 0x0</entry>
</row>
<row>
<entry>&ensp;&lsqb;6&rsqb;</entry>
<entry>reset_gpreg</entry>
<entry>Flash clear of GPREG&lsqb;7:0&rsqb;</entry>
</row>
<row>
<entry>&ensp;&lsqb;7&rsqb;</entry>
<entry>reset_resvec0</entry>
<entry>Flash clear of RESVEC&lsqb;31:0&rsqb;. Allows</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>preservation of up to 32 global bit</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>variables while clearing the rest</entry>
</row>
<row>
<entry>&ensp;&lsqb;8&rsqb;</entry>
<entry>reset_resvec_15_1</entry>
<entry>Flash clear of RESVEC&lsqb;511:32&rsqb;</entry>
</row>
<row>
<entry>&ensp;&lsqb;9&rsqb;</entry>
<entry>setsz</entry>
<entry>Sets CC_REG&lsqb;SZ&rsqb; to &lsquo;1&rsquo; to start a</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>chained-equality compare</entry>
</row>
<row>
<entry>&lsqb;10&rsqb;</entry>
<entry>do_cmem_fill</entry>
<entry>Triggers a CMEM fill sequence</entry>
</row>
<row>
<entry>&lsqb;11&rsqb;</entry>
<entry>halt</entry>
<entry>Sets CSR&lsqb;HALT&rsqb; and freezes the CE</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>pipeline</entry>
</row>
<row>
<entry>&lsqb;15:12&rsqb;</entry>
<entry>set_msg&lsqb;3:0&rsqb;</entry>
<entry>Each bit sets one of the 4 MSG_OUT</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>bits in CE_CSR</entry>
</row>
<row>
<entry>&lsqb;24&rsqb;</entry>
<entry>ld_ncnt</entry>
<entry>loads N-counter for CMPRN instruction</entry>
</row>
<row>
<entry>&lsqb;25&rsqb;</entry>
<entry>ld_bdst_cnt</entry>
<entry>loads BDST counter, sets RESVEC</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>sequential mode (for CMPRN &amp; resvec</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>spills)</entry>
</row>
<row>
<entry>&lsqb;26&rsqb;</entry>
<entry>bdst_cnt_mode</entry>
<entry>&lsquo;0&rsquo; &equals; count-by-2 for CMPRN,</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>&lsquo;1&rsquo; &equals; count-by-32 for resvec spill</entry>
</row>
<row>
<entry>&lsqb;27&rsqb;</entry>
<entry>ld_pcnt</entry>
<entry>Writes either PINDEX&lsqb;10:2&rsqb; or</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>REGB&lsqb;10:2&rsqb; into PCNT and sets PCNT</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>autoincrement mode per PCNT_INC</entry>
</row>
<row>
<entry>&lsqb;28&rsqb;</entry>
<entry>pcnt_reg</entry>
<entry>With ld_pcnt, &lsquo;0&rsquo; &equals; load with</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>immediate, &lsquo;1&rsquo; &equals; load from gpreg on</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>B-side</entry>
</row>
<row>
<entry>&lsqb;29&rsqb;</entry>
<entry>pcnt_inc</entry>
<entry>With ld_pcnt, &lsquo;1&rsquo; &equals; pcnt</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>autoincrements, &lsquo;0&rsquo; &equals; no increments</entry>
</row>
<row>
<entry>&lsqb;30 &rsqb;</entry>
<entry>sleep</entry>
<entry>Freezes pipeline, sets CECSR&lsqb;SLEEP&rsqb;,</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>puts CMEM in power-down mode.</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>Sleep mode persists until any of</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>CECSR&lsqb;RX_RING,RECLASS,</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>MSG_IN&lsqb;D:A&rsqb;&rsqb; causes a wakeup.</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0518" lvl="7"><number>&lsqb;0518&rsqb;</number> 6. Miscellany </paragraph>
<paragraph id="P-0519" lvl="7"><number>&lsqb;0519&rsqb;</number> 6.1 Memory Scheduling Rules </paragraph>
<paragraph id="P-0520" lvl="0"><number>&lsqb;0520&rsqb;</number> A memory access is scheduled by writing the address/size/direction to the MEM_ADDR special register. The following rules apply to scheduling of memory accesses; violation of any of these rules will cause the pipeline to HALT with status of the cause of the error in the CE Control and Status Register (CECSR). </paragraph>
<paragraph id="P-0521" lvl="2"><number>&lsqb;0521&rsqb;</number> 1) There must be at least one intervening instruction between a LD and use of the resulting data if no other read data is outstanding. A load followed by immediate consumption when the outstanding schedule is &lsquo;0&rsquo; will result in a deadlock. </paragraph>
<paragraph id="P-0522" lvl="2"><number>&lsqb;0522&rsqb;</number> 2) A maximum of 16 slots of read data can be scheduled. A slot is a 2-word entry in DFIFO_R. A LD or LD2 consumes 1 slot, a LD4 consumes 2 slots, and a LD8 consumes 4 slots in DFIFO_R. The appropriate number of slots must be available before another &lcub;LD, LD2, LD4, LD8&rcub; is scheduled. </paragraph>
<paragraph id="P-0523" lvl="2"><number>&lsqb;0523&rsqb;</number> 3) A maximum of 32 outstanding words of read data can be scheduled; data must be consumed to make room in DFFO_R before more can be scheduled. </paragraph>
<paragraph id="P-0524" lvl="2"><number>&lsqb;0524&rsqb;</number> 4) Precisely the correct number of words of write data must be written to DFIFO_W prior to scheduling the store of that size. </paragraph>
<paragraph id="P-0525" lvl="7"><number>&lsqb;0525&rsqb;</number> 6.2 Register Write-Use Rules </paragraph>
<paragraph id="P-0526" lvl="0"><number>&lsqb;0526&rsqb;</number> GPREG and RESVEC results can safely be accessed in the instruction after the data is written to them. </paragraph>
<paragraph id="P-0527" lvl="0"><number>&lsqb;0527&rsqb;</number> PCNT, WCNT, and NCNT are all loaded via use of a specop. They can safely be used immediately in the next instruction. </paragraph>
<paragraph id="P-0528" lvl="0"><number>&lsqb;0528&rsqb;</number> The specop unlock_pcnt takes effect immediately, so PMEM immediate index can safely be used in the next instruction. Likewise, specop unlock_resvec_index takes effect immediately, and random access to RESVEC can be used in the next instruction. </paragraph>
<paragraph id="P-0529" lvl="0"><number>&lsqb;0529&rsqb;</number> BASE_REG has a one-cycle write-use delay rule; if it is written to in instruction A, it cannot be used as a source operand in instruction A&plus;1. </paragraph>
<paragraph id="P-0530" lvl="0"><number>&lsqb;0530&rsqb;</number> PMEM has a one cycle write-use delay rule for any particular address. If address addr is written to in instruction A, then addr may not be read in instruction A&plus;1; however it is perfectly safe to read any other location in PMEM in cycle A&plus;1. </paragraph>
<paragraph id="P-0531" lvl="0"><number>&lsqb;0531&rsqb;</number> Data written to special register NULL may not be read back because, well, it&apos;s gone, man. </paragraph>
<paragraph id="P-0532" lvl="7"><number>&lsqb;0532&rsqb;</number> 6.3 PMEM Addressing </paragraph>
<paragraph id="P-0533" lvl="0"><number>&lsqb;0533&rsqb;</number> Packet Memory PMEM can be addressed by an immediate index provided in the microword, indirectly from the PCNT register, or indirectly with auto-increment of PCNT. Immediate indexing is the standard mode; use of PCNT is initiated with the Id_pcnt special operation, which also carries the mode bit pcnt_inc that can optionally be asserted. This special operation sets the state bits USE_PCNT and (optionally) PCNT_INC_MODE. USE_PCNT is cleared by the special operation uniock_pcnt. </paragraph>
<paragraph id="P-0534" lvl="0"><number>&lsqb;0534&rsqb;</number> PCNT can be loaded from an immediate value PINDEX provided in the Id_pcnt special operation, or from bits &lsqb;10:2&rsqb; of any GPREG specified in RSRCB if the specop bit pcnt_reg is set during the Id_pcnt. </paragraph>
<paragraph id="P-0535" lvl="7"><number>&lsqb;0535&rsqb;</number> 6.4 Microstack </paragraph>
<paragraph id="P-0536" lvl="0"><number>&lsqb;0536&rsqb;</number> The microstack is written and the stack pointer is incremented every time a conditional CALL instruction succeeds. It is read and the stack pointer is decremented every time a conditional RET instruction succeeds. The address written is the address of the instruction following the delay slot of the call, since the delay slot is always executed. The microstack holds up to 8 entries. Calling to a depth greater than 8, or returning past the valid number of entries, causes a halt with a report of STACK_ERROR in the CECSR. </paragraph>
</section>
<section>
<heading lvl="1">VI. Programming Model </heading>
<paragraph id="P-0537" lvl="0"><number>&lsqb;0537&rsqb;</number> This section describes the programming model and set of abstractions employed when creating an application for the NetBoost platform (i.e., the platform described in this patent application). An application on the NetBoost platform is to be considered a service, provided within the network, that may require direct knowledge or manipulation of network packets or frames. The programming model provides for direct access to low-level frame data, plus a set of library functions capable of reassembling low-level frame data into higher-layer messages or packets. In addition, the library contains functions capable of performing protocol operations on network or transport-layer messages. </paragraph>
<paragraph id="P-0538" lvl="0"><number>&lsqb;0538&rsqb;</number> An application developed for the NetBoost platform receives link-layer frames from an attached network interface, matches the frames against some set of selection criteria, and determines their disposition. Frame processing takes place as a sequence of serialized processing steps. Each step includes a classification and action phase. During the classification phase, frame data is compared against application-specified matching criteria called rules. When a rule&apos;s matching criteria evaluates true, its action portion specifies the disposition of the frame. Execution of the action portion constitutes the action Phase. Only the actions of rules with true matching criteria are executed. </paragraph>
<paragraph id="P-0539" lvl="0"><number>&lsqb;0539&rsqb;</number> Implementing an application for the NetBoost platform involves partitioning the application into two modules. Modules are a grouping of application code destined to execute in a particular portion of the NetBoost platform. There are two modules required: the application processor (AP) module, and the policy engine (PE) module. Application code in the AP module runs on the host processor, and is most appropriate for processing not requiring wire-speed access to network frames. Application code for the PE module comprises the set of classification rules written in the NetBoost Classification Language (NCL), and an accompanying set of compiled actions (C or C&plus;&plus; functions/objects). PE actions are able to manipulate network frames with minimal overhead, and are thus the appropriate mechanism for implementing fast and simple manipulation of frame data. The execution environment for PE action code is more restricted than that of AP code (no virtual memory or threads), but includes a library providing efficient implementation for common frame manipulation tasks (see Section VIII). A message passing facility allows for communication between PE action code and the AP module. </paragraph>
<paragraph id="P-0540" lvl="7"><number>&lsqb;0540&rsqb;</number> 1. Application Structure </paragraph>
<paragraph id="P-0541" lvl="0"><number>&lsqb;0541&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 15</cross-reference> illustrates the NetBoost application structure. </paragraph>
<paragraph id="P-0542" lvl="0"><number>&lsqb;0542&rsqb;</number> Applications <highlight><bold>1402</bold></highlight> written for the NetBoost platform must be partitioned into the following modules and sub-modules, as illustrated in <cross-reference target="DRAWINGS">FIG. 15</cross-reference>. </paragraph>
<paragraph id="P-0543" lvl="2"><number>&lsqb;0543&rsqb;</number> AP Module (&mdash;application processor (host) module) <highlight><bold>1406</bold></highlight> </paragraph>
<paragraph id="P-0544" lvl="2"><number>&lsqb;0544&rsqb;</number> PE Module (&mdash;policy engine module) <highlight><bold>1408</bold></highlight> </paragraph>
<paragraph id="P-0545" lvl="2"><number>&lsqb;0545&rsqb;</number> Classification rules&mdash;specified in NCL </paragraph>
<paragraph id="P-0546" lvl="2"><number>&lsqb;0546&rsqb;</number> Action implementation&mdash;object code provided by app developer </paragraph>
<paragraph id="P-0547" lvl="0"><number>&lsqb;0547&rsqb;</number> The AP module <highlight><bold>1406</bold></highlight> executes in the programming environment of a standard operating system and has access to all PEs <highlight><bold>1408</bold></highlight> available on the system, plus the conventional APIs implemented in the host operating system. Thus, the AP module <highlight><bold>1406</bold></highlight> has the capability of performing both frame-level processing (in conjunction with the PE), or traditional network processing using a standard API. </paragraph>
<paragraph id="P-0548" lvl="0"><number>&lsqb;0548&rsqb;</number> The PE <highlight><bold>1408</bold></highlight> module is subdivided into a set of classification rules and actions. Classification rules are specified in the NetBoost Classification Language (NCL) and are compiled on-the-fly by a fast incremental compiler provided by NetBoost. Actions are implemented as relocatable object code provided by the application developer. A dynamic linker/loader included with the NetBoost platform is capable of linking and loading the classification rules with the action implementations and loading these either into the host (software implementation) or hardware PE (hardware implementation) for execution. </paragraph>
<paragraph id="P-0549" lvl="0"><number>&lsqb;0549&rsqb;</number> The specific division of functionality between AP and PE modules <highlight><bold>1406</bold></highlight> and <highlight><bold>1408</bold></highlight> in an application is left entirely up to the application designer. Preferably, the AP module <highlight><bold>1406</bold></highlight> should be used to implement initialization and control, user interaction, exception handling, and infrequent processing of frames requiring special attention. The PE module <highlight><bold>1408</bold></highlight> preferably should implement simple processing on frames (possibly including the reconstruction of higher-layer messages) requiring extremely fast execution. PE action code runs in a run-to-completion real-time environment without memory protection, similar to an interrupt handler in most conventional operating systems. Thus, functions requiring lengthy processing times should be avoided, or executed in the AP module <highlight><bold>1406</bold></highlight>. In addition, other functions may be loaded into the PE to support actions, asynchronous execution, timing, or other processing (such as upcalls/downcalls, below). All code loaded into the PE has access to the PE runtime environment, provided by the ASL. </paragraph>
<paragraph id="P-0550" lvl="0"><number>&lsqb;0550&rsqb;</number> The upcall/downcall facility provides for communication between PE actions and AP functions. An application may use upcalls/downcalls for sharing information or signaling between the two modules. The programmer may use the facility to pass memory blocks, frame contents, or other messages constructed by applications in a manner similar to asynchronous remote procedure calls. </paragraph>
<paragraph id="P-0551" lvl="7"><number>&lsqb;0551&rsqb;</number> 2. Basic Building Blocks </paragraph>
<paragraph id="P-0552" lvl="0"><number>&lsqb;0552&rsqb;</number> This section describes the C&plus;&plus; classes needed to develop an application for the NetBoost platform. Two fundamental classes are used to abstract the classification and handling of network frames: </paragraph>
<paragraph id="P-0553" lvl="2"><number>&lsqb;0553&rsqb;</number> ACE, representing classification and action steps </paragraph>
<paragraph id="P-0554" lvl="2"><number>&lsqb;0554&rsqb;</number> Target, representing possible frame destinations </paragraph>
<paragraph id="P-0555" lvl="7"><number>&lsqb;0555&rsqb;</number> 2.1 ACEs </paragraph>
<paragraph id="P-0556" lvl="0"><number>&lsqb;0556&rsqb;</number> The ACE class (short for Action-Classification-Engine) abstracts a set of frame classification criteria and associated actions, upcall/downcall entrypoints, and targets. They are simplex: frame processing is uni-directional. An application may make use of cascaded ACEs to achieve serialization of frame processing. ACEs are local to an application. </paragraph>
<paragraph id="P-0557" lvl="0"><number>&lsqb;0557&rsqb;</number> ACEs provide an abstraction of the execution of classification rules, plus a container for holding the rules and actions. ACEs are instantiated on particular hardware resources either by direct control of the application or by the plumber application. </paragraph>
<paragraph id="P-0558" lvl="0"><number>&lsqb;0558&rsqb;</number> An ACE <highlight><bold>1500</bold></highlight> is illustrated in <cross-reference target="DRAWINGS">FIG. 16</cross-reference>: </paragraph>
<paragraph id="P-0559" lvl="0"><number>&lsqb;0559&rsqb;</number> The ACE is the abstraction of frame classification rules <highlight><bold>1506</bold></highlight> and associated actions <highlight><bold>1508</bold></highlight>, destinations for processed frames, and downcall/upcall entrypoints. An application may employ several ACEs, which are executed in a serial fashion, possibly on different hardware processors. </paragraph>
<paragraph id="P-0560" lvl="0"><number>&lsqb;0560&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 16</cross-reference> illustrates an ACE with two targets <highlight><bold>1502</bold></highlight> and <highlight><bold>1504</bold></highlight>. The targets represent possible destinations for frames and are described in the following section. </paragraph>
<paragraph id="P-0561" lvl="0"><number>&lsqb;0561&rsqb;</number> Frames arrive at an ACE from either a network interface or from an ACE. The ACE classifies the frame according its rules. A rule is a combination of a predicate and action. A rule is said to be &ldquo;true&rdquo; or to &ldquo;evaluate true&rdquo; or to be a &ldquo;matching rule&rdquo; if its predicate portion evaluates true in the Boolean sense for the current frame being processed. The action portion of each matching rule indicates what processing should take place. </paragraph>
<paragraph id="P-0562" lvl="0"><number>&lsqb;0562&rsqb;</number> The application programmer specifies rule predicates within an ACE using Boolean operators, packet header fields, constants, set membership queries, and other operations defined in the NetBoost Classification Language (NCL), a declarative language described in Section VII. A set of rules (an NCL program) may be loaded or unloaded from an ACE dynamically under application control. In certain embodiments, the application developer implements actions in a conventional high level language. Special external declaration statements in NCL indicate the names of actions supplied by the application developer to be called as the action portion for matching rules. </paragraph>
<paragraph id="P-0563" lvl="0"><number>&lsqb;0563&rsqb;</number> Actions are function entry-points implemented according to the calling conventions of the C programming language (static member functions in C&plus;&plus; classes are also supported). The execution environment for actions includes a C and C&plus;&plus; runtime environment with restricted standard libraries appropriate to the PE execution environment. In addition to the C environment, the ASL library provides added functionality for developing network applications. The ASL provides support for handling many TCP/IP functions such as IP fragmentation and re-assembly, Network Address Translation (NAT), and TCP connection monitoring (including stream reconstruction). The ASL also provides support for encryption and basic system services (e.g. timers, memory management). </paragraph>
<paragraph id="P-0564" lvl="0"><number>&lsqb;0564&rsqb;</number> During classification, rules are evaluated first-to-last. When a matching rule is encountered, its action executes and returns a value indicating whether it disposed of the frame. Disposing of a frame corresponds to taking the final desired action on the frame for a single classification step (e.g. dropping it, queueing it, or delivering it to a target). If an action executes but does not dispose of the current frame, it returns a code indicating the frame should undergo further rule evaluations in the current classification step. If any action disposes of the frame, the classification phase terminates. If all rules are evaluated without a disposing action, the frame is delivered to the default target of the ACE. </paragraph>
<paragraph id="P-0565" lvl="7"><number>&lsqb;0565&rsqb;</number> 2.2 Targets </paragraph>
<paragraph id="P-0566" lvl="0"><number>&lsqb;0566&rsqb;</number> Targets specify possible destinations for frames (an ACE or network interface). A target is said to be bound to either an ACE or network interface (in the outgoing direction), otherwise it is unbound. Frames delivered to unbound targets are dropped. Target bindings are manipulated by a plumbing application in accordance with the present invention. </paragraph>
<paragraph id="P-0567" lvl="0"><number>&lsqb;0567&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 17</cross-reference> shows a cascade of ACEs. ACEs use targets as frame destinations. Targets 1 and 2 (illustrated at <highlight><bold>1602</bold></highlight> and <highlight><bold>1604</bold></highlight>) are bound to ACEs 1 and 2 (illustrated at <highlight><bold>1610</bold></highlight> and <highlight><bold>1612</bold></highlight>), respectively. Target 3 (at <highlight><bold>1606</bold></highlight>) is bound to a network interface (<highlight><bold>1620</bold></highlight>) in the outgoing direction. Processing occurs serially from left to right. Ovals indicate ACEs, hexagons indicate network interfaces. Outgoing arcs indicate bound targets. An ACE with multiple outgoing arcs indicates an ACE that performs a demultiplexing function: the set of outgoing arcs represent the set off all frame destinations in the ACE, across all actions. In this example, each ACE has a single destination (the default target). When several hardware resources are available for executing ACEs (e.g. in the case of the NetBoost hardware platform), ACEs may execute more efficiently (using pipelining). Note, however, that when one ACE has finished processing a frame, it is given to another ACE that may execute on the same hardware resource. </paragraph>
<paragraph id="P-0568" lvl="7"><number>&lsqb;0568&rsqb;</number> 3. Complex Configurations </paragraph>
<paragraph id="P-0569" lvl="0"><number>&lsqb;0569&rsqb;</number> As described above, a single application may employ more than one ACE. Generally, processing bidirectional network data will require a minimum of two ACEs. Four ACEs may be a common configuration for a system providing two network interfaces and an application wishing to install ACEs at the input and output for each interface (e.g. in the NetBoost hardware environment with one PE). </paragraph>
<paragraph id="P-0570" lvl="0"><number>&lsqb;0570&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 18</cross-reference> illustrates an application employing six ACEs <highlight><bold>1802</bold></highlight>, <highlight><bold>1804</bold></highlight>, <highlight><bold>1806</bold></highlight>, <highlight><bold>1808</bold></highlight>, <highlight><bold>1810</bold></highlight> and <highlight><bold>1812</bold></highlight>. Shaded circles represent targets. Two directions of processing are depicted, as well as an ACE with more than one output arc and an ACE with more than one input arc. The arcs represent possible destinations for frames. </paragraph>
<paragraph id="P-0571" lvl="0"><number>&lsqb;0571&rsqb;</number> An ACE depicted with more than one outgoing arc may represent the processing of a single frame, or in certain circumstances, the replication (copying) of a frame to be sent to more than one downstream ACE simultaneously. Frame replication is used in implementing broadcast and multicast forwarding (e.g. in layer <highlight><bold>2</bold></highlight> bridging and IP multicast forwarding). The interconnection of targets to downstream objects is typically performed by the plumber application described in the next section. </paragraph>
<paragraph id="P-0572" lvl="7"><number>&lsqb;0572&rsqb;</number> 4. Software Architecture </paragraph>
<paragraph id="P-0573" lvl="0"><number>&lsqb;0573&rsqb;</number> This section describes the major components comprising the NetBoost software implementation. The software architecture provides for the execution of several applications performing frame-layer processing of network data, and includes user-level, kernel-level, and embedded processor-level components (for the hardware platform). The software architecture is illustrated <cross-reference target="DRAWINGS">FIG. 19</cross-reference>. </paragraph>
<paragraph id="P-0574" lvl="0"><number>&lsqb;0574&rsqb;</number> The layers of software comprising the overall architecture are described bottom-up. The first layer is the NetBoost Policy Engine <highlight><bold>2000</bold></highlight> (PE). Each host system may be equipped with one or more PEs. In systems equipped with NetBoost hardware PEs, each PE will be equipped with several frame classifiers and a processor responsible for executing action code. For systems lacking the hardware PE, all PE functionality is implemented in software. The PE includes a set of C&plus;&plus; library functions comprising the Action Services Library (ASL) which may be used by action code in ACE rules to perform messaging, timer-driven event dispatch, network packet reassembly or other processing. </paragraph>
<paragraph id="P-0575" lvl="0"><number>&lsqb;0575&rsqb;</number> The PE interacts with the host system via a device driver <highlight><bold>2010</bold></highlight> and ASL <highlight><bold>2012</bold></highlight> supplied by NetBoost. The device driver is responsible for supporting maintenance operations to NetBoost PE cards. In addition, this driver is responsible for making the network interfaces supplied on NetBoost PE cards available to the host system as standard network interfaces. Also, specialized kernel code is inserted into the host&apos;s protocol stack to intercept frames prior to receipt by the host protocol stack (incoming) or transmission by conventional network interface cards (outgoing). </paragraph>
<paragraph id="P-0576" lvl="0"><number>&lsqb;0576&rsqb;</number> The Resolver <highlight><bold>2008</bold></highlight> is a user-level process started at boot time responsible for managing the status of all applications using the NetBoost facilities In addition, it includes the NCL compiler and PE linker/loader. The process responds to requests from applications to set up ACEs, bind targets, and perform other maintenance operations on the NetBoost hardware or software-emulated PE. </paragraph>
<paragraph id="P-0577" lvl="0"><number>&lsqb;0577&rsqb;</number> The Application Library <highlight><bold>2002</bold></highlight> (having application <highlight><bold>1</bold></highlight>, <highlight><bold>2</bold></highlight> &amp; <highlight><bold>3</bold></highlight> shown at <highlight><bold>2020</bold></highlight>, <highlight><bold>2040</bold></highlight>, <highlight><bold>2042</bold></highlight>) is a set of C&plus;&plus; classes providing the API to the NetBoost system It allows for the creation and configuration of ACEs, binding of targets, passing of messages to/from the PE, and the maintenance of the name-to-object bindings for objects which exist in both the AP and PE modules. </paragraph>
<paragraph id="P-0578" lvl="0"><number>&lsqb;0578&rsqb;</number> The plumber <highlight><bold>2014</bold></highlight> is a management application used to set up or modify the bindings of every ACE in the system (across all applications). It provides a network administrator the ability to specify the serial order of frame processing by binding ACE targets to subsequent ACEs. The plumber is built using a client/server architecture, allowing for both local and remote access to specify configuration control. All remote access is authenticated and encrypted. </paragraph>
</section>
<section>
<heading lvl="1">VII. Classification Language </heading>
<paragraph id="P-0579" lvl="0"><number>&lsqb;0579&rsqb;</number> The NetBoost Classification Language (NCL) is a declarative high level language for defining packet filters. The language has six primary constructs: protocol definitions, predicates, sets, set searches, rules and external actions. Protocol definitions are organized in an object-oriented fashion and describe the position of protocol header fields in packets. Predicates are Boolean functions on protocol header fields and other predicates. Rules consist of a predicate/action pair having a predicate portion and an action portion where an action is invoked if its corresponding predicate is trae. Actions refer to procedure entrypoints implemented external to the language. </paragraph>
<paragraph id="P-0580" lvl="0"><number>&lsqb;0580&rsqb;</number> Individual packets are classified according to the predicate portions of the NCL rules. More than one rule may be true for any single packet classification. The action portion of rules with true predicates are invoked in the order the rules have been specified. Any of these actions invoked may indicate that no further actions are to be invoked. NCL provides a number of operators to access packet fields and execute comparisons of those fields. In addition, it provides a set abstraction, which can be used to determine containment relationships between packets and groups of defined objects (e.g. determining if a particular packet belongs to some TCP/IP flow or set of flows), providing the ability to keep persistent state in the classification process between packets. </paragraph>
<paragraph id="P-0581" lvl="0"><number>&lsqb;0581&rsqb;</number> Standard arithmetic, logical and bit-wise operators are supported and follow their equivalents in the C programming language. These operators provide operations on the fields of the protocols headers and result in scalar or Boolean values. An include directive allows for splitting NCL programs into several files. </paragraph>
<paragraph id="P-0582" lvl="7"><number>&lsqb;0582&rsqb;</number> 1. Names and Data Types </paragraph>
<paragraph id="P-0583" lvl="0"><number>&lsqb;0583&rsqb;</number> The following definitions in NCL constants have names: protocols, predicates, fields, sets, searches on sets, and rules (defined later subsequent sections). A name is formed using any combination of alphanumeric characters and underscores except the first character must be an alphabetic character. Names are case sensitive. For example, </paragraph>
<paragraph id="P-0584" lvl="2"><number>&lsqb;0584&rsqb;</number> set_tcp_udp </paragraph>
<paragraph id="P-0585" lvl="2"><number>&lsqb;0585&rsqb;</number> IsIP </paragraph>
<paragraph id="P-0586" lvl="2"><number>&lsqb;0586&rsqb;</number> isIPv6 </paragraph>
<paragraph id="P-0587" lvl="2"><number>&lsqb;0587&rsqb;</number> set_udp_ports </paragraph>
<paragraph id="P-0588" lvl="7"><number>&lsqb;0588&rsqb;</number> The above examples are all legal names. The following examples are all illegal names: </paragraph>
<paragraph id="P-0589" lvl="2"><number>&lsqb;0589&rsqb;</number> 6_byte_ip </paragraph>
<paragraph id="P-0590" lvl="2"><number>&lsqb;0590&rsqb;</number> set_tcp&plus;udp </paragraph>
<paragraph id="P-0591" lvl="2"><number>&lsqb;0591&rsqb;</number> ip_src&amp;dst </paragraph>
<paragraph id="P-0592" lvl="7"><number>&lsqb;0592&rsqb;</number> The first is illegal because it starts with a numeric character; the other two are illegal because they contain operators. </paragraph>
<paragraph id="P-0593" lvl="0"><number>&lsqb;0593&rsqb;</number> Protocol fields (see Section 6) are declared in byte-oriented units, and used in constructing protocols definitions. All values are big-endian. Fields specify the location and size of portions of a packet header. All offsets are relative to a particular protocol. In this way it is possible to specify a particular header field without knowing the absolute offset of the any particular protocol header. Mask and shift operations support the accessing of non-byte-sized header fields. For example, </paragraph>
<paragraph id="P-0594" lvl="2"><number>&lsqb;0594&rsqb;</number> dst &lcub;ip&lsqb;16:4&rsqb;&rcub;</paragraph>
<paragraph id="P-0595" lvl="2"><number>&lsqb;0595&rsqb;</number> ver &lcub;(ip&lsqb;0:1&rsqb; &amp; 0xf0)&gt;&gt;4&rcub;</paragraph>
<paragraph id="P-0596" lvl="7"><number>&lsqb;0596&rsqb;</number> In the first line, the 4-byte field dst is specified as being at byte offset 16 from the beginning of the IP protocol header In the second example, the field ver is a half-byte sized field at the beginning of the IP header. </paragraph>
<paragraph id="P-0597" lvl="7"><number>&lsqb;0597&rsqb;</number> 2. Operators </paragraph>
<paragraph id="P-0598" lvl="0"><number>&lsqb;0598&rsqb;</number> Arithmetic, logical and bit-wise binary operators are supported Table 23 lists the arithmetic operators and grouping operator supported:  
<table-cwu id="TABLE-US-00025">
<number>25</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center">TABLE 23</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Arithmetic Operators</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="70PT" align="left"/>
<colspec colname="2" colwidth="105PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Operator</entry>
<entry>Description</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
<row>
<entry></entry>
<entry>()</entry>
<entry>Grouping operator</entry>
</row>
<row>
<entry></entry>
<entry>&plus;</entry>
<entry>Addition</entry>
</row>
<row>
<entry></entry>
<entry>&minus;</entry>
<entry>Subtraction</entry>
</row>
<row>
<entry></entry>
<entry>&lt;&lt;</entry>
<entry>Logical left shift</entry>
</row>
<row>
<entry></entry>
<entry>&gt;&gt;</entry>
<entry>Logical right shift</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0599" lvl="7"><number>&lsqb;0599&rsqb;</number> The arithmetic operators result in scalar quantities, which are typically used for comparison. These operators may be used in field and predicate definitions. The shift operations do not support arithmetic shifts. The shift amount is a compile time constant. Multiplication, division and modulo operators are not supported. The addition and subtraction operations are not supported for fields greater than 4 bytes. </paragraph>
<paragraph id="P-0600" lvl="0"><number>&lsqb;0600&rsqb;</number> Logical operators are supported that result in Boolean values. Table 24 provides the logical operators that are supported by the language.  
<table-cwu id="TABLE-US-00026">
<number>26</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center">TABLE 24</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Logical Operators</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="35PT" align="left"/>
<colspec colname="1" colwidth="63PT" align="left"/>
<colspec colname="2" colwidth="119PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Operator</entry>
<entry>Description</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
<row>
<entry></entry>
<entry>&amp;&amp;</entry>
<entry>Logical AND</entry>
</row>
<row>
<entry></entry>
<entry>&par;</entry>
<entry>Logical OR</entry>
</row>
<row>
<entry></entry>
<entry>&excl;</entry>
<entry>Not</entry>
</row>
<row>
<entry></entry>
<entry>&gt;</entry>
<entry>Greater Than</entry>
</row>
<row>
<entry></entry>
<entry>&gt;&equals;</entry>
<entry>Greater Than or Equal To</entry>
</row>
<row>
<entry></entry>
<entry>&lt;</entry>
<entry>Less Than</entry>
</row>
<row>
<entry></entry>
<entry>&lt;&equals;</entry>
<entry>Less Than or Equal To</entry>
</row>
<row>
<entry></entry>
<entry>&equals;&equals;</entry>
<entry>Equal To</entry>
</row>
<row>
<entry></entry>
<entry>&excl;&equals;</entry>
<entry>Not Equal</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0601" lvl="7"><number>&lsqb;0601&rsqb;</number> Bit-wise operators are provided for masking and setting of bits. The operators supported are as follows:  
<table-cwu id="TABLE-US-00027">
<number>27</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center">TABLE 25</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Bit-wise operators</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="35PT" align="left"/>
<colspec colname="1" colwidth="63PT" align="left"/>
<colspec colname="2" colwidth="119PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Operators</entry>
<entry>Description</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
<row>
<entry></entry>
<entry>&amp;</entry>
<entry>Bit-wise AND</entry>
</row>
<row>
<entry></entry>
<entry>&verbar;</entry>
<entry>Bit-wise OR</entry>
</row>
<row>
<entry></entry>
<entry>{circumflex over (&thinsp;)}</entry>
<entry>Bit-wise Exclusive OR</entry>
</row>
<row>
<entry></entry>
<entry>&tilde;</entry>
<entry>Bit-wise One&apos;s Compliment</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0602" lvl="7"><number>&lsqb;0602&rsqb;</number> The precedence and the associativity of all the operators listed above are shown in Table 26. The precedence is listed in decreasing order.  
<table-cwu id="TABLE-US-00028">
<number>28</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center">TABLE 26</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Operator Precedence</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="63PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="70PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Precedence</entry>
<entry>Operators</entry>
<entry>Associativity</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry></entry>
<entry>High</entry>
<entry>()&lsqb;&rsqb;</entry>
<entry>Left to right</entry>
</row>
<row>
<entry></entry>
<entry>.</entry>
<entry>&excl;&tilde;</entry>
<entry>Right to left</entry>
</row>
<row>
<entry></entry>
<entry>.</entry>
<entry>&plus;&minus;</entry>
<entry>Left to right</entry>
</row>
<row>
<entry></entry>
<entry>.</entry>
<entry>&lt;&lt;&gt;&gt;</entry>
<entry>Left to right</entry>
</row>
<row>
<entry></entry>
<entry>.</entry>
<entry>&lt;&lt;&equals;&gt;&gt;&equals;</entry>
<entry>Left to right</entry>
</row>
<row>
<entry></entry>
<entry>.</entry>
<entry>&equals;&equals;&excl;&equals;</entry>
<entry>Left to right</entry>
</row>
<row>
<entry></entry>
<entry>.</entry>
<entry>&amp;</entry>
<entry>Left to right</entry>
</row>
<row>
<entry></entry>
<entry>.</entry>
<entry>{circumflex over (&thinsp;)}</entry>
<entry>Left to right</entry>
</row>
<row>
<entry></entry>
<entry>.</entry>
<entry>&verbar;</entry>
<entry>Left to right</entry>
</row>
<row>
<entry></entry>
<entry>.</entry>
<entry>&amp;&amp;</entry>
<entry>Left to right</entry>
</row>
<row>
<entry></entry>
<entry>Low</entry>
<entry>&par;</entry>
<entry>Left to right</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0603" lvl="7"><number>&lsqb;0603&rsqb;</number> 3. Field Formats </paragraph>
<paragraph id="P-0604" lvl="0"><number>&lsqb;0604&rsqb;</number> The language supports several standard formats, and also domain specific formats, for constants, including the dotted-quad form for IP version 4 addresses and colon-separated hexadecimal for Ethernet and IP version 6 addresses, in addition to conventional decimal and hexadecimal constants Standard hexadecimal constants are defined as they are in the C language, with a leading 0x prefix. </paragraph>
<paragraph id="P-0605" lvl="0"><number>&lsqb;0605&rsqb;</number> For data smaller than 4 bytes in length, unsigned extension to 4 bytes is performed automatically. A few examples are as shown below:  
<table-cwu id="TABLE-US-00029">
<number>29</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center">TABLE 27</entry>
</row>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Constant formats</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="70PT" align="left"/>
<colspec colname="2" colwidth="126PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>0x11223344</entry>
<entry>Hexadecimal form</entry>
</row>
<row>
<entry></entry>
<entry>101.230.135.45</entry>
<entry>Dot separated IP address form</entry>
</row>
<row>
<entry></entry>
<entry>ff:12:34:56:78:9a</entry>
<entry>colon separated MAC address form</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0606" lvl="7"><number>&lsqb;0606&rsqb;</number> 4. Comments </paragraph>
<paragraph id="P-0607" lvl="0"><number>&lsqb;0607&rsqb;</number> C and C&plus;&plus; style comments are supported. One syntax supports multiple lines, the other supports comments terminating with a newline. The syntax for the first form follows the C language comment syntax using /* and */ to demark the start and end of a comment, respectively. The syntax for the second form follows the C&plus;&plus; comment syntax, using // to indicate the start of the comment. Such comments end at the end of the line. Nesting of comments is not allowed in the case of the first form. In the second case, everything is discarded to the end of the line, so nesting of the second form is allowed. Comments can occur anywhere in the program. A few examples of comments are shown below,  
<table-cwu id="TABLE-US-00030">
<number>30</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259PT" align="center"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Diagram 1: Legal comments</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>/* Comment in a single line */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="105PT" align="left"/>
<colspec colname="2" colwidth="112PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>// Second form of the comment:</entry>
<entry>compiler ignores to end-of-line</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>/* Comments across multiple line</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>second line</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>third line */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="49PT" align="left"/>
<colspec colname="1" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>// Legal comment // still ignored to end-of-line</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="49PT" align="left"/>
<colspec colname="3" colwidth="168PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>/*</entry>
<entry>First form</entry>
<entry>// Second form, but OK</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>*/</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0608" lvl="0"><number>&lsqb;0608&rsqb;</number> The examples above are all legal. The examples shown in Diagram 11 (below) are illegal.  
<table-cwu id="TABLE-US-00031">
<number>31</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Diagram 2: Illegal comments</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="119PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>/*</entry>
<entry>space */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="126PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>/</entry>
<entry>new line</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>* Testing */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="5">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="35PT" align="left"/>
<colspec colname="3" colwidth="28PT" align="left"/>
<colspec colname="4" colwidth="84PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>/*</entry>
<entry>Nesting</entry>
<entry>/*</entry>
<entry>Second level */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>*/</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="154PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>/ /</entry>
<entry>space</entry>
</row>
<row>
<entry></entry>
<entry>/</entry>
<entry>new line</entry>
</row>
<row>
<entry></entry>
<entry>/</entry>
</row>
<row>
<entry></entry>
<entry>//</entry>
<entry>/* Nesting</entry>
</row>
<row>
<entry></entry>
<entry>*/</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0609" lvl="7"><number>&lsqb;0609&rsqb;</number> The first comment is illegal because of the space between / and *, and the second one because of the new-line. The third is illegal because of nesting. The fourth is illegal because of the space between the &lsquo;/&rsquo; chars and the next one because of the new-line. The last one is illegal because the /* is ignored, causing the */ to be in error of nesting of the first form of the comment in the second form. </paragraph>
<paragraph id="P-0610" lvl="7"><number>&lsqb;0610&rsqb;</number> 5. Constant Definitions and Include Directives </paragraph>
<paragraph id="P-0611" lvl="0"><number>&lsqb;0611&rsqb;</number> The language provides user-definable symbolic constants. The syntax for the definition is the keyword &num;define, then the name followed by the constant. No spaces are allowed between &num; and define. The constant can be in any of the forms described in the next subsection of this patent application The definition can start at the beginning of a line or any other location on a line as long as the preceding characters are either spaces or tabs. For example,  
<table-cwu id="TABLE-US-00032">
<number>32</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259PT" align="center"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Diagram 3: Sample of constant definition usage</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="91PT" align="left"/>
<colspec colname="3" colwidth="21PT" align="left"/>
<colspec colname="4" colwidth="105PT" align="left"/>
<tbody valign="top">
<row>
<entry>&num;define</entry>
<entry>TELNET PORT_NUM</entry>
<entry>23</entry>
<entry>// Port number for telnet</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="126PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&num;define</entry>
<entry>IP_ADDR</entry>
<entry>10.4.7.18</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="91PT" align="left"/>
<colspec colname="3" colwidth="126PT" align="left"/>
<tbody valign="top">
<row>
<entry>&num;define</entry>
<entry>MAC-HD -13 -L ADDR</entry>
<entry>cd.ee.f0.34.74.93</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0612" lvl="7"><number>&lsqb;0612&rsqb;</number> The language provides the ability to include files within the compilation unit so that pre-existing code can be reused. The keyword &num;include is used, followed by the filename enclosed in double quotes. The &num; must start on a new-line, but may have spaces immediately preceding the keyword. No space are allowed between &num; and the include. The filename is any legal filename supported by the host. For example,  
<table-cwu id="TABLE-US-00033">
<number>33</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Diagram 4: Sample include directives</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="70PT" align="left"/>
<colspec colname="3" colwidth="105PT" align="left"/>
<tbody valign="top">
<row>
<entry>&num;include</entry>
<entry>&ldquo;myproto.def&rdquo;</entry>
<entry>// Could be protocol definitions</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="105PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&num;include</entry>
<entry>&ldquo;stdrules.rul&rdquo;</entry>
<entry>// Some standard rules</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="70PT" align="left"/>
<colspec colname="3" colwidth="105PT" align="left"/>
<tbody valign="top">
<row>
<entry>&num;include</entry>
<entry>&ldquo;newproto.def&rdquo;</entry>
<entry>/* New protocol definitions */</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0613" lvl="7"><number>&lsqb;0613&rsqb;</number> 6. Protocol Definitions </paragraph>
<paragraph id="P-0614" lvl="0"><number>&lsqb;0614&rsqb;</number> NCL provides a convenient method for describing the relationship between multiple protocols and the header fields they contain. A protocol defines fields within a protocol header, intrinsics (built-in functions helpful in processing headers and fields), predicates (Boolean functions on fields and other predicates), and the demultiplexing method to high-layer protocols. The keyword protocol identifies a protocol definition and its name. The name may later be referenced as a Boolean value which evaluates true if the protocol is activated (see 6.2). The declarations for fields, intrinsics and demultiplexing are contained in a protocol definition as illustrated below. </paragraph>
<paragraph id="P-0615" lvl="7"><number>&lsqb;0615&rsqb;</number> 6.1 Fields </paragraph>
<paragraph id="P-0616" lvl="0"><number>&lsqb;0616&rsqb;</number> Fields within the protocol are declared by specifying a field name followed by the offset and field length in bytes. Offsets are always defined relative to a protocol. The base offset is specified by the protocol name, followed by colon separated offset and size enclosed in square brackets. This syntax is as shown below:  
<table-cwu id="TABLE-US-00034">
<number>34</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<thead>
<row>
<entry></entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
<entry>field name&lcub; protocol name&lsqb;offset:size&rsqb; &rcub;</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0617" lvl="7"><number>&lsqb;0617&rsqb;</number> Fields may be defined using a combination of byte ranges within the protocol header and shift/mask or grouping operations. The field definitions act as access methods to the areas within in the protocol header or payload. For example, fields within a protocol named MyProto might be specified as follows:  
<table-cwu id="TABLE-US-00035">
<number>35</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="147PT" align="left"/>
<thead>
<row>
<entry></entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
<entry>dest addr</entry>
<entry>&lcub; MyProto&lsqb;6:4&rsqb; &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>bit flags</entry>
<entry>&lcub; (MyProto&lsqb;10:2&rsqb; &amp; 0x0ff0) &gt;&gt; 8 &rcub;</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0618" lvl="7"><number>&lsqb;0618&rsqb;</number> In the first example, field dest_addr is declared as a field at offset 6 bytes from the start of the protocol MyProto and 4 bytes in size. In the second example, the field bit_flags is a bit field because it crosses a byte boundary, two bytes are used in conjunction with a mask and right shift operation to get the field value. </paragraph>
<paragraph id="P-0619" lvl="7"><number>&lsqb;0619&rsqb;</number> 6.2 Intrinsics </paragraph>
<paragraph id="P-0620" lvl="0"><number>&lsqb;0620&rsqb;</number> Intrinsics are functions listed in a protocol statement, but implemented internally. Compiler-provided intrinsics are declared in the protocol definition (for consistency) using the keyword intrinsic followed by the intrinsic name. Intrinsics provide convenient or highly optimized functions that are not easily expressed using the standard language constructs. One such intrinsic is the IP checksum. Intrinsics may be declared within the scope of a protocol definition or outside, as in the following examples:  
<table-cwu id="TABLE-US-00036">
<number>36</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Diagram 5: Sample intrinsic declarations</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>protocol foo &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="77PT" align="left"/>
<colspec colname="1" colwidth="140PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>field defs</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="70PT" align="left"/>
<colspec colname="1" colwidth="147PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>intrinsic chksumvalid &lcub; &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>intrinsic now</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0621" lvl="0"><number>&lsqb;0621&rsqb;</number> The first example indicates chksumvalid intrinsic is associated with the protocol foo. Thus, the expression foo.chksumvalid could be used in the creation of predicates or expressions defined later. The second example indicates a global intrinsic called now that may be used anywhere within the program. Intrinsics can return Boolean and scalar values. </paragraph>
<paragraph id="P-0622" lvl="0"><number>&lsqb;0622&rsqb;</number> In a protocol definition, predicates are used to define frequently used Boolean results from the fields within the protocol being defined. They are identified by the keyword predicate. Predicates are described in section 7. </paragraph>
<paragraph id="P-0623" lvl="7"><number>&lsqb;0623&rsqb;</number> 6.3 Demux </paragraph>
<paragraph id="P-0624" lvl="0"><number>&lsqb;0624&rsqb;</number> The keyword demux in each protocol statement indicates how demultiplexing should be performed to higher-layer protocols. In effect, it indicates which subsequent protocol is &ldquo;activated&rdquo;, as a function of fields and predicates defined within the current set of activated protocols. </paragraph>
<paragraph id="P-0625" lvl="0"><number>&lsqb;0625&rsqb;</number> Evaluation of the Boolean expressions within a protocol demux statement determines which protocol is activated next. Within a demux statement, the first expression which evaluates to true indicates that the associated protocol is to be activated at a specified offset relative to the first byte of the present protocol. The starting offset of the protocol to be activated is specified using the keyword at. A default protocol may be specified using the keyword default. The first case of the demux to evaluate true indicates which protocol is activated next. All others are ignored. The syntax for the demux is as follows:  
<table-cwu id="TABLE-US-00037">
<number>37</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Diagram 6: Demux syntax sample</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>demux &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>boolean exp &lcub; protocol name at offset &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>default &lcub; protocol name at offset &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0626" lvl="7"><number>&lsqb;0626&rsqb;</number> Diagram 7 shows an example of the demux declaration  
<table-cwu id="TABLE-US-00038">
<number>38</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Diagram 7: Sample protocol demux</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>demux &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="84PT" align="left"/>
<colspec colname="2" colwidth="119PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>(length &equals;&equals; 10)</entry>
<entry>&lcub; proto a at offset a &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>(flags &amp;&amp; predicate_x)</entry>
<entry>&lcub; proto b at offset b &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>default</entry>
<entry>&lcub; proto default at offset default &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>&rcub;</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0627" lvl="0"><number>&lsqb;0627&rsqb;</number> In the above example, protocol proto_a is &ldquo;activated&rdquo; at offset offset_a if the expression length equals ten. Protocol proto_b is activated at offset offset_b if flags is true, predicate x is true and length is not equal to 10. predicate x is a pre-defined Boolean expression. The default protocol is proto_default, which is defined here so that packets not matching the predefined criteria can be processed. The fields and predicates in a protocol are accessed by specifying the protocol and the field or predicate separated by the dot operator. This hierarchical naming model facilitates easy extension to new protocols. Consider the IP protocol example shown below.  
<table-cwu id="TABLE-US-00039">
<number>39</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Diagram 8: Protocol Sample: IP</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>protocol IP &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="154PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>vers</entry>
<entry>&lcub; (ip&lsqb;0:1&rsqb; &amp; 0xf0 &gt;&gt; 4 &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>hlength</entry>
<entry>&lcub; &lsqb;0:1&rsqb; &amp; 0x0f &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>hlength b</entry>
<entry>&lcub; hlength &lt;&lt; 2 &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>tos</entry>
<entry>&lcub; ip&lsqb;1:1&rsqb; &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>length</entry>
<entry>&lcub; ip&lsqb;2:2&rsqb; &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>id</entry>
<entry>&lcub; ip&lsqb;4:2&rsqb; &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>flags</entry>
<entry>&lcub; (ip&lsqb;6:1&rsqb; &amp; 0xe0) &gt;&gt; 5 &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>fragoffset</entry>
<entry>&lcub; ip&lsqb;6:2&rsqb; &amp; 0x1fff &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>ttl</entry>
<entry>&lcub; ip&lsqb;8:1&rsqb; &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>proto</entry>
<entry>&lcub; ip&lsqb;9:1&rsqb; &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>chksum</entry>
<entry>&lcub; ip&lsqb;10:2&rsqb; &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>src</entry>
<entry>&lcub; ip&lsqb;12:4&rsqb; &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>dst</entry>
<entry>&lcub; ip&lsqb;16:4&rsqb; &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="77PT" align="left"/>
<colspec colname="2" colwidth="126PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>intrinsic chksumvalid</entry>
<entry>&lcub;&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>intrinsic genchksum &lcub;&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="70PT" align="left"/>
<colspec colname="2" colwidth="133PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>predicate bcast</entry>
<entry>&lcub; dst &equals;&equals; 255.255.255.255 &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>predicate mcast</entry>
<entry>&lcub; (dst &amp; 0xf0000000) &equals;&equals;0 0xe0000000 &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>predicate frag</entry>
<entry>&lcub; fragoffset &excl;&equals; &verbar;&verbar; (flags &amp; 2) &excl;&equals; 0 &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>demix &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="133PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>( proto &equals;&equals; 6 )</entry>
<entry>&lcub; tcp at hlength b &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>( proto &equals;&equals; 17 )</entry>
<entry>&lcub; udp at hlength b &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>( proto &equals;&equals; 1 )</entry>
<entry>&lcub; icmp at hlength b &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>( proto &equals;&equals; 2 )</entry>
<entry>&lcub; igmp at hlength b &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>default</entry>
<entry>&lcub; unknownIP at hlength b &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>&rcub;</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0628" lvl="0"><number>&lsqb;0628&rsqb;</number> Here, ip is the protocol name being defined. The protocol definition includes a number of fields which correspond to portions of the IP header comprising one or more bytes. The fields vers, hlength, flags and fragoffset have special operations that extract certain bits from the IP header.hlength_b holds the length of the header in bytes computed using the hlength field (which is in units of 32-bit words). </paragraph>
<paragraph id="P-0629" lvl="0"><number>&lsqb;0629&rsqb;</number> bcast,mcast, and fragarepredicates which may be useful in defining other rules or predicates. Predicates are defined in Section 7. </paragraph>
<paragraph id="P-0630" lvl="0"><number>&lsqb;0630&rsqb;</number> This protocol demuxes into four other protocols, excluding the default, under different conditions. In this example, the demultiplexing key is the protocol type specified by the of the IP proto field. All the protocols are activated at offset hlength_b relative to the start of the IP header. </paragraph>
<paragraph id="P-0631" lvl="0"><number>&lsqb;0631&rsqb;</number> When a protocol is activated due to the processing of a lower-layer demux statement, the activated protocol&apos;s name becomes a Boolean that evaluates true (it is otherwise false). Thus, if the IP protocol is activated, the expression ip will evaluate to a true Boolean expression. The fields and predicates in a protocol are accessed by specifying the protocol and the field, predicate or intrinsic separated by the dot operator. For example:  
<table-cwu id="TABLE-US-00040">
<number>40</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Diagram 9: Sample references</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="84PT" align="left"/>
<colspec colname="1" colwidth="133PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>ip.length</entry>
</row>
<row>
<entry></entry>
<entry>ip.bcast</entry>
</row>
<row>
<entry></entry>
<entry>ip.chksumvalid</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0632" lvl="0"><number>&lsqb;0632&rsqb;</number> Users can provide additional declarations for new fields, predicates and demux cases by extending previously-defined protocol elements. Any name conflicts will be resolved by using the newest definitions. This allows user-provided definitions to override system-supplied definitions updates and migration. The syntax for extensions is the protocol name followed by the new element separated by the dot (.) operator. Following the name is the definition enclosed in delimiters as illustrated below:  
<table-cwu id="TABLE-US-00041">
<number>41</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Diagram 10: Sample protocol extension</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="49PT" align="left"/>
<colspec colname="1" colwidth="168PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>xx.newfield &lcub; xx&lsqb;10:4&rsqb; &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>predicate xx.newpred &lcub; xx&lsqb;8:2&rsqb; 1&equals; 10 &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>xx.demux &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="63PT" align="left"/>
<colspec colname="1" colwidth="154PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>(xx&lsqb;6:2&rsqb; &equals;&thinsp;&equals; 5 ) &lcub; newproto at 20 &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="49PT" align="left"/>
<colspec colname="1" colwidth="168PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0633" lvl="0"><number>&lsqb;0633&rsqb;</number> In the first example, a new field called newfield is declared for the protocol xx. In the second, a new predicate called newpred is defined for the protocol xx. In the third example, a new higher-layer protocol newproto is declared as a demultiplexing for the protocol xx. The root of the protocol hierarchy is the reserved protocol frame, which refers to the received data from the link-layer. The redefinition of the protocol frame is not allowed for any protocol definitions, but new protocol demux opertions can be added to it. </paragraph>
<paragraph id="P-0634" lvl="0"><number>&lsqb;0634&rsqb;</number> The intrinsics provided are listed in Table 28:  
<table-cwu id="TABLE-US-00042">
<number>42</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center">TABLE 28</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>List of intrinsics</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry>Intrinsic Name</entry>
<entry>Functionality</entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
<row>
<entry>ip.chksumvalid</entry>
<entry>Check the validity of the ip header checksum, return</entry>
</row>
<row>
<entry></entry>
<entry>boolean value</entry>
</row>
<row>
<entry>tcp.chksumvalid</entry>
<entry>Check the validity of the tcp pseudo checksum,</entry>
</row>
<row>
<entry></entry>
<entry>return boolean value</entry>
</row>
<row>
<entry>udp.chksumvalid</entry>
<entry>Check the validity of udp pseudo checksum, return</entry>
</row>
<row>
<entry></entry>
<entry>boolean value</entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0635" lvl="7"><number>&lsqb;0635&rsqb;</number> 7. Predicates </paragraph>
<paragraph id="P-0636" lvl="0"><number>&lsqb;0636&rsqb;</number> Predicates are named Boolean expressions that use protocol header fields, other Boolean expressions, and previously-defined predicates as operands. The syntax for predicates is as follows: </paragraph>
<paragraph id="P-0637" lvl="2"><number>&lsqb;0637&rsqb;</number> predicate predicate_name &lcub;boolean_expression &rcub;</paragraph>
<paragraph id="P-0638" lvl="7"><number>&lsqb;0638&rsqb;</number> For example, </paragraph>
<paragraph id="P-0639" lvl="2"><number>&lsqb;0639&rsqb;</number> predicate isTcpSyn &lcub;tcp &amp;&amp; (tcp.flags &amp; 0x02)&excl;&equals;0&rcub;</paragraph>
<paragraph id="P-0640" lvl="2"><number>&lsqb;0640&rsqb;</number> predicate isNewTelnet &lcub;isTcpSyn &amp;&amp; (tcp.dport&equals;&equals;23)&rcub;</paragraph>
<paragraph id="P-0641" lvl="7"><number>&lsqb;0641&rsqb;</number> In the second example, the predicate isTcpSyn is used in the expression to evaluate the predicate isNewTelnet. </paragraph>
<paragraph id="P-0642" lvl="7"><number>&lsqb;0642&rsqb;</number> 8. Sets </paragraph>
<paragraph id="P-0643" lvl="0"><number>&lsqb;0643&rsqb;</number> The language supports the notion of sets and named searches on sets, which can be used to efficiently check whether a packet should be considered a member of some application-defined equivalence class. Using sets, classification rules requiring persistent state may be constructed. The classification language only supports the evaluation of set membership; modification to the contents of the sets are handled exclusively by actions in conjunction with the ASL. A named search defines a particular search on a set and its name may be used as a Boolean variable in subsequent Boolean expressions. Named searches are used to tie precomputed lookup results calculated in the classification phase to actions executing in the action phase. </paragraph>
<paragraph id="P-0644" lvl="0"><number>&lsqb;0644&rsqb;</number> A set is defined using the keyword set followed by an identifier specifying the name of the set. The number of keys for any search on the set is specified following the name, between &lt; and &gt;. A set definition may optionally include a hint as to the expected number of members of the set, specified using the keyword size_hint. The syntax is as follows:  
<table-cwu id="TABLE-US-00043">
<number>43</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Diagram 11: Declaring a set</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="49PT" align="left"/>
<colspec colname="1" colwidth="168PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>set set_name &lt; nkeys &gt; &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="63PT" align="left"/>
<colspec colname="1" colwidth="154PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>size_hint &lcub; expected_population &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="49PT" align="left"/>
<colspec colname="1" colwidth="168PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0645" lvl="7"><number>&lsqb;0645&rsqb;</number> The size hint does not place a strict limit on the population of the set, but as the set size grows beyond the hint value, the search time may slowly increase. </paragraph>
<paragraph id="P-0646" lvl="0"><number>&lsqb;0646&rsqb;</number> Predicates and rules may perform named searches (see the following section for a discussion of rules). Named searches are specified using the keyword search followed by the search name and search keys. The search name consists of two parts: the name of the set to search, and the name of the search being defined. The keys may refer to arbitrary expressions, but typically refer to fields in protocols. The number of keys defined in the named search must match the number of keys defined for the set. The named search may be used in subsequent predicates as a Boolean values where &ldquo;true&rdquo; indicates a record is present in the associated set with the specified keys. An optional Boolean expression may be included in a named search using the requires keyword. If the Boolean expression fails to evaluate true, the search result is always &ldquo;false&rdquo;. The syntax for named searches is as follows:  
<table-cwu id="TABLE-US-00044">
<number>44</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Diagram 12: Named search</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>search set_name.search_name (key1, key2) &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>requires &lcub; boolean_expression &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0647" lvl="0"><number>&lsqb;0647&rsqb;</number> Consider the following example defining a set of transport-layer protocol ports (tcp or udp):  
<table-cwu id="TABLE-US-00045">
<number>45</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Diagram 13: Sharing a set definition</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="196PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&num;define MAX_TCP_UDP_PORTS_SET_SZ 200</entry>
</row>
<row>
<entry></entry>
<entry>/* TUPORTS: a set of TCP or UDP ports */</entry>
</row>
<row>
<entry></entry>
<entry>set tuports&lt;1&gt;, &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="35PT" align="left"/>
<colspec colname="1" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>size_hint &lcub; MAX_TCP_UDP_PORTS_SET_SZ &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="196PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>search tuports.tcp_sport (tcp.sport)</entry>
</row>
<row>
<entry></entry>
<entry>search tuports.tcp_dport (tcp.dport)</entry>
</row>
<row>
<entry></entry>
<entry>search tuports.udp_sport (udp.sport)</entry>
</row>
<row>
<entry></entry>
<entry>search tuports.udp_dport (udp.dport)</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0648" lvl="7"><number>&lsqb;0648&rsqb;</number> This example illustrates how one set may be used by multiple searches. The set tuports might contain a collection of port numbers of interest for either protocol, TCP/IP or UDP/IP. The four named searches provide checks as to whether different TCP or UDP source or destination port numbers are present in the set. The results of named searches may be used as Boolean values in expressions, as illustrated below:  
<table-cwu id="TABLE-US-00046">
<number>46</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Diagram 14: Using shared sets</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>predicate tcp_sport_in &lcub;tuports.tcp_sport&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>predicate tcp_port_in &lcub;tuports.tcp_sport &amp;&amp; tuports.tcp_dport &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>predicate udp_sdports_in &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>tuports udp_sport &verbar;&thinsp;&verbar;tuports.udp_dport</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0649" lvl="0"><number>&lsqb;0649&rsqb;</number> In the first example, a predicate tcp_sport_in is defined to be the Boolean result of the named search tuports.tcp_sport, which determines whether or not the tcp.sport field (source port) of a TCP segment is in the set tuports. In the second example, both the source and destination ports of the TCP protocol header are searched using named searches. In the third case, membership of either the source or destination ports of a UDP datagram in the set is determined. </paragraph>
<paragraph id="P-0650" lvl="7"><number>&lsqb;0650&rsqb;</number> 9. Rules and Actions </paragraph>
<paragraph id="P-0651" lvl="0"><number>&lsqb;0651&rsqb;</number> Rules are a named combination of a predicate and action. They are defined using the keyword rule. The predicate portion is a Boolean expression consisting of any combination of individual Boolean subexpressions or other predicate names. The Boolean value of a predicate name corresponds to the Boolean value of its associated predicate portion. The action portion specifies the name of the action which is to be invoked when the predicate portion evaluates &ldquo;true&rdquo; for the current frame. Actions are implemented external to the classifier and supplied by application developers. Arguments can be specified for the action function and may include predicates, named searches on sets, or results of intrinsic functions. The following illustrates the syntax:  
<table-cwu id="TABLE-US-00047">
<number>47</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Diagram 15: Rule syntax</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>rule rule_name &lcub; predicate &rcub; &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>external_action_func (arg1, arg2, ...)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0652" lvl="7"><number>&lsqb;0652&rsqb;</number> The argument list defines the values passed to the action code executed externally to NCL. An arbitrary number of arguments are supported.  
<table-cwu id="TABLE-US-00048">
<number>48</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259PT" align="center"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Diagram 16: Telnet/FTP example</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>set set_ip_tcp_ports &lt;3&gt; &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>size_hint &lcub; 100 &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>set set_ip_udp_ports &lt;3&gt; &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>size_hint &lcub; 100 &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>search set_ip_tcp_ports.tcp_dport ( ip.src, ip.dst, tcp.dport ) &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>requires &lcub;ip &amp;&amp; tcp&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>search set_ip_udp_ports.udp_dport ( ip.src, ip.dst, udp.dport ) &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>requires &lcub;ip &amp;&amp; udp&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>predicate ipValid &lcub; ip &amp;&amp; ip.chksumvalid &amp;&amp; (ip.hlen &gt; 5) &amp;&amp;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>(ip.ver &equals;&thinsp;&equals; 4) &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>predicate newtelnet &lcub; (tcp.flags &amp; 0x02) &amp;&amp; (tcp.dport &equals;&thinsp;&equals; 23) &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>predicate tftp &lcub; (udp.dport &equals;&thinsp;&equals; 21) &amp;&amp; set_ip_udp_ports.udp_ports &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>rule telnetNewCon &lcub; ipValid &amp;&amp; newtelnet &amp;&amp; set_ip_tcp_ports.tcp_dport &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub; start_telnet ( set_ip_tcp_ports.tcp_dport) &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>rule tftppkt &lcub;ipValid &amp;&amp; tftp &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub; is_tftp_pkt ( udp.dport ) &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>rule addnewtelnet &lcub; newtelnet &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub; add_to_tcp_pkt_count ( ) &rcub;</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0653" lvl="0"><number>&lsqb;0653&rsqb;</number> In the above example, two sets are defined. One contains source and destination IP addresses, plus TCP ports. The other set contains IP addresses and UDP ports. Two named searches are defined. The first search uses the IP source and destination addresses and the TCP destination port number as keys. The second search uses the IP source and destination addresses and UDP destination port as keys. The predicate ipValid checks to make sure the packet is an IP packet with valid checksum, has a header of acceptable size, and is IP version 4. The predicate newtelnet determines if the current TCP segment is a SYN packet destined for a telnet port. The predicate tftp determines if the UDP destination port corresponds to the TFTP port number and the combination of IP source and destination addresses and destination UDP port number is in the set ip_udp_ports. The rule telnetNewCon determines if the current segment is a new telnet connection, and specifies that the associated external function start_telnet will be invoked when this rule is true. The function takes the search result as argument. The rule tftppkt checks whether the packet belongs to a TFTP association. If so, the associated action is_tftp_pkt will be invoked with udp.dport as the argument. The third checks if the current segment is a new telnet connection and defines the associated action function add_to_tcp_pkt_count. </paragraph>
<paragraph id="P-0654" lvl="7"><number>&lsqb;0654&rsqb;</number> 10. With Clauses </paragraph>
<paragraph id="P-0655" lvl="0"><number>&lsqb;0655&rsqb;</number> A with clause is a special directive providing for conditional execution of a group of rules or predicates. The syntax is as follows:  
<table-cwu id="TABLE-US-00049">
<number>49</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Diagram 17: With clause syntax sample</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>with boolean_expression &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>predicate pred_name &lcub; any_boolean_exp &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>rule rule_name &lcub; any_boolean_exp &rcub; &lcub; action_reference &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0656" lvl="0"><number>&lsqb;0656&rsqb;</number> If the Boolean expression in the with clause evaluates false, all the enclosed predicates and rules evaluate false. For example, if we want to evaluate the validity of an IP datagram and use it in a set of predicates and rules, these can be encapsulated using the with clause and a conditional, which could be the checksum of the IP header. Nested with clauses are allowed, as illustrated in the following example:  
<table-cwu id="TABLE-US-00050">
<number>50</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Diagram 18: Nested with clauses</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>predicate tcpValid &lcub; tcp &amp;&amp; tcp.chksumalid &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="98PT" align="left"/>
<colspec colname="2" colwidth="28PT" align="left"/>
<colspec colname="3" colwidth="91PT" align="left"/>
<tbody valign="top">
<row>
<entry>&num;define TELNET</entry>
<entry>23</entry>
<entry>// port number for telnet</entry>
</row>
<row>
<entry>with ipValid &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="77PT" align="left"/>
<colspec colname="2" colwidth="126PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>predicate tftp </entry>
<entry>&lcub; (udp.dport &equals;&thinsp;&equals; 21) &amp;&amp;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="98PT" align="left"/>
<colspec colname="1" colwidth="119PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>ip_udp_ports.udp_dport &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="63PT" align="left"/>
<colspec colname="2" colwidth="140PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>with tcpValid &lcub;</entry>
<entry>/* Nested with */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="77PT" align="left"/>
<colspec colname="2" colwidth="112PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>predicate newtelnet</entry>
<entry>&lcub; (tcp.flags &amp; 0x02) &amp;&amp;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="112PT" align="left"/>
<colspec colname="1" colwidth="105PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>tcp.dport &equals;&thinsp;&equals; TELNET &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>rule telnetNewCon &lcub; newtelnet &amp;&amp; ip_tcp_ports.tcp_dport &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub; start_telnet( ip_tcp_sport.tcp_dport) &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>rule tftppkt &lcub; tftp &amp;&amp; ip_udp_ports.udp_dport &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub; is_tftp_pkt ( udp.dport ) &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>&rcub;</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0657" lvl="7"><number>&lsqb;0657&rsqb;</number> 11. Protocol Definitions for TCP/IP </paragraph>
<paragraph id="P-0658" lvl="0"><number>&lsqb;0658&rsqb;</number> The following NCL definitions are used for processing of TCP/IP and related protocols.  
<table-cwu id="TABLE-US-00051">
<number>51</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="315PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>/***************************** FRAME (base unit) *****************************/</entry>
</row>
<row>
<entry>protocol frame &lcub;</entry>
</row>
<row>
<entry>// status words written by NetBoost Ethernet MACs</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="35PT" align="left"/>
<colspec colname="3" colwidth="224PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>rxstatus</entry>
<entry></entry>
<entry>&lcub; frame&lsqb;0x180:4&rsqb; &rcub; // receive status</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="5">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="35PT" align="left"/>
<colspec colname="3" colwidth="14PT" align="left"/>
<colspec colname="4" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>rxstamp</entry>
<entry></entry>
<entry></entry>
<entry>&lcub; frame&lsqb;0x184:4&rsqb; &rcub; // receive time stamp</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="35PT" align="left"/>
<colspec colname="3" colwidth="224PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>txstatus</entry>
<entry></entry>
<entry>&lcub; frame&lsqb;0x188:4&rsqb; &rcub; // xmit status (if sent out)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="5">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="35PT" align="left"/>
<colspec colname="3" colwidth="14PT" align="left"/>
<colspec colname="4" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>txstamp</entry>
<entry></entry>
<entry></entry>
<entry>&lcub; frame&lsqb;0x18C:4&rsqb; &rcub; // xmit time stamp (if sent)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="77PT" align="left"/>
<colspec colname="2" colwidth="14PT" align="left"/>
<colspec colname="3" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>predicate rxerror</entry>
<entry></entry>
<entry>&lcub; (rxstatus &amp; 0x80000000) &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="35PT" align="left"/>
<colspec colname="3" colwidth="14PT" align="left"/>
<colspec colname="4" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>length</entry>
<entry></entry>
<entry>&lcub; (rxstatus &amp; 0x07FF0000) &gt;&gt; 16 &rcub; // frame len</entry>
</row>
<row>
<entry></entry>
<entry>source</entry>
<entry></entry>
<entry>&lcub; (rxstatus &amp; 0x00000F00) &gt;&gt; 8 &rcub; // hardware origin</entry>
</row>
<row>
<entry></entry>
<entry>offset</entry>
<entry></entry>
<entry>&lcub; (rxstatus &amp; 0x000000FF) &rcub; // start of frame</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="5">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="35PT" align="left"/>
<colspec colname="3" colwidth="14PT" align="left"/>
<colspec colname="4" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>predicate</entry>
<entry>txok</entry>
<entry></entry>
<entry>&lcub; (txstatus &amp; 0x80000000) &excl;&equals; 0 &rcub; // tx success</entry>
</row>
<row>
<entry></entry>
<entry>demux &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="35PT" align="left"/>
<colspec colname="3" colwidth="14PT" align="left"/>
<colspec colname="4" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>rxerror</entry>
<entry></entry>
<entry>&lcub; frame_bad at 0 &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>// source 0: NetBoost onboard MAC A ethernet packet</entry>
</row>
<row>
<entry></entry>
<entry>// source 1: NetBoost onboard MAC B ethernet packet</entry>
</row>
<row>
<entry></entry>
<entry>// source 2: Other rxstatus-encodable ethernet packet</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="49PT" align="left"/>
<colspec colname="3" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>(source &lt; 3)</entry>
<entry>&lcub; ether at 0x180 &plus; offset &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="35PT" align="left"/>
<colspec colname="3" colwidth="14PT" align="left"/>
<colspec colname="4" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>default</entry>
<entry></entry>
<entry>&lcub; frame_bad at 0 &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="301PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="315PT" align="left"/>
<tbody valign="top">
<row>
<entry>&rcub;</entry>
</row>
<row>
<entry>protocol frame_bad &lcub;</entry>
</row>
<row>
<entry>&rcub;</entry>
</row>
<row>
<entry>/**************************** ETHERNET **********************************/</entry>
</row>
<row>
<entry>&num;define ETHER_IPTYPE0x0800</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="98PT" align="left"/>
<colspec colname="2" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>&num;define ETHER_ARPTYPE</entry>
<entry>0x0806</entry>
</row>
<row>
<entry>&num;define ETHER_RARPTYPE</entry>
<entry>0x8035</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="315PT" align="left"/>
<tbody valign="top">
<row>
<entry>protocol ether &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="5">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="63PT" align="left"/>
<colspec colname="4" colwidth="147PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>dst</entry>
<entry></entry>
<entry>&lcub; ether&lsqb;0:6&rsqb; &rcub;</entry>
<entry>// source ethernet address</entry>
</row>
<row>
<entry></entry>
<entry>src</entry>
<entry></entry>
<entry>&lcub; ether&lsqb;6:6&rsqb; &rcub;</entry>
<entry>// destination ethernet address</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="5">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="77PT" align="left"/>
<colspec colname="4" colwidth="133PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>typelen</entry>
<entry></entry>
<entry>&lcub; ether&lsqb;12:2&rsqb; &rcub;</entry>
<entry>// length or type, depends on encap</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="105PT" align="left"/>
<colspec colname="3" colwidth="147PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>snap</entry>
<entry>&lcub; ether&lsqb;14:6&rsqb; &rcub;</entry>
<entry>// SNAP code if present</entry>
</row>
<row>
<entry></entry>
<entry>type</entry>
<entry>&lcub; ether&lsqb;20:2&rsqb; &rcub;</entry>
<entry>// type for 8023 encaps</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="301PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>// We are only interested in a specific subset of the possible</entry>
</row>
<row>
<entry></entry>
<entry>// 802.3 encapsulations; specifically, those where the 802.2 LLC area</entry>
</row>
<row>
<entry></entry>
<entry>// contains DSAP&equals;0xAA, SSAP&equals;0xAA, and CNTL&equals;0x03; followed by</entry>
</row>
<row>
<entry></entry>
<entry>// the 802.2 SNAP ar3ea contains the ORG code 0x000000. In this</entry>
</row>
<row>
<entry></entry>
<entry>// case, the 7802.2 SNAP &ldquo;type&rdquo; field contains one of our ETHER</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="154PT" align="left"/>
<colspec colname="2" colwidth="35PT" align="left"/>
<colspec colname="3" colwidth="112PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>// type values defined above.</entry>
<entry></entry>
<entry></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>predicate</entry>
<entry>issnap</entry>
<entry>&lcub; (typelen &lt;&equals; 1500) &amp;&amp; (snap &equals;&thinsp;&equals; 0xAAAA03000000) &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="63PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>offset</entry>
<entry>&lcub; 14 &plus; (issnap &lt;&lt; 3) &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="301PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>demux &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<colspec colname="2" colwidth="112PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>typelen &equals;&thinsp;&equals; ETHER_ARPTYPE</entry>
<entry>&lcub; arp at offset &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>typelen &equals;&thinsp;&equals; ETHER_RARPTYPE</entry>
<entry>&lcub; arp at offset &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<colspec colname="2" colwidth="98PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>typelen &equals;&thinsp;&equals; ETHER_IPTYPE</entry>
<entry>&lcub; ip at offset &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<colspec colname="2" colwidth="112PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>issnap &amp;&amp; (type &equals;&thinsp;&equals; ETHER_ARPTYPE)</entry>
<entry>&lcub; arp at offset &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>issnap &amp;&amp; (type &equals;&thinsp;&equals; ETHER_RARPTYPE)</entry>
<entry>&lcub; arp at offset &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>issnap &amp;&amp; (type &equals;&thinsp;&equals; ETHER_IPTYPE)</entry>
<entry>&lcub; ip at offset &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="140PT" align="left"/>
<colspec colname="2" colwidth="35PT" align="left"/>
<colspec colname="3" colwidth="112PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>default</entry>
<entry></entry>
<entry>&lcub; ether_bad at 0 &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="301PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="315PT" align="left"/>
<tbody valign="top">
<row>
<entry>&rcub;</entry>
</row>
<row>
<entry>protocol ether_bad &lcub;</entry>
</row>
<row>
<entry>&rcub;</entry>
</row>
<row>
<entry>/****************** ARP PROTOCOL ************************/</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="133PT" align="left"/>
<colspec colname="2" colwidth="14PT" align="left"/>
<colspec colname="3" colwidth="168PT" align="left"/>
<tbody valign="top">
<row>
<entry>&num;define ARPHRD_ETHER</entry>
<entry>1</entry>
<entry>/* ethernet hardware format */</entry>
</row>
<row>
<entry>&num;define ARPHRD_FRELAY</entry>
<entry>15</entry>
<entry>/* frame relay hardware format */</entry>
</row>
<row>
<entry>&num;define ARPOP_REQUEST</entry>
<entry>1</entry>
<entry>/* request to resolve address */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="105PT" align="left"/>
<colspec colname="2" colwidth="28PT" align="left"/>
<colspec colname="3" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry>&num;define ARPOP_REPLY</entry>
<entry>2</entry>
<entry>/* response to previous request */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="119PT" align="left"/>
<colspec colname="2" colwidth="28PT" align="left"/>
<colspec colname="3" colwidth="168PT" align="left"/>
<tbody valign="top">
<row>
<entry>&num;define ARPOP_REVREQUEST</entry>
<entry>3</entry>
<entry>/* request protocol address given hardware */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="133PT" align="left"/>
<colspec colname="2" colwidth="14PT" align="left"/>
<colspec colname="3" colwidth="168PT" align="left"/>
<tbody valign="top">
<row>
<entry>&num;define ARPOP_REVREPLY</entry>
<entry>4</entry>
<entry>/* response giving protocol address */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="119PT" align="left"/>
<colspec colname="2" colwidth="28PT" align="left"/>
<colspec colname="3" colwidth="168PT" align="left"/>
<tbody valign="top">
<row>
<entry>&num;define ARPOP_INVREQUEST</entry>
<entry>8</entry>
<entry>/* request to identify peer */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="133PT" align="left"/>
<colspec colname="2" colwidth="14PT" align="left"/>
<colspec colname="3" colwidth="168PT" align="left"/>
<tbody valign="top">
<row>
<entry>&num;define ARPOP_INVREPLY</entry>
<entry>9</entry>
<entry>/* response identifying peer */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="315PT" align="left"/>
<tbody valign="top">
<row>
<entry>protocol arp &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>htype</entry>
<entry>&lcub; arp&lsqb;0:2&rsqb; &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>ptype</entry>
<entry>&lcub; arp&lsqb;2:2&rsqb; &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>hsize</entry>
<entry>&lcub; arp&lsqb;4:1&rsqb; &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>psize</entry>
<entry>&lcub; arp&lsqb;5:1&rsqb; &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>op</entry>
<entry></entry>
<entry>&lcub; arp&lsqb;6:2&rsqb; &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>varhdr</entry>
<entry></entry>
<entry>&lcub; 8 &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>predicate</entry>
<entry>ethip4</entry>
<entry>&lcub; (op &lt;&equals; ARPOP_REVREPLY) &amp;&amp; (htype &equals;&thinsp;&equals; ARPHRD_ETHER) &amp;&amp;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry></entry>
<entry>(ptype &equals;&thinsp;&equals; ETHER_IPTYPE) &amp;&amp; (hsize &equals;&thinsp;&equals; 6) &amp;&amp; (psize &equals;&thinsp;&equals; 4) &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="301PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>demux &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>ethip4</entry>
<entry></entry>
<entry>&lcub; ether_ip4_arp at varhdr &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>default</entry>
<entry></entry>
<entry>&lcub; unimpl_arp at 0 &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="301PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="315PT" align="left"/>
<tbody valign="top">
<row>
<entry>&rcub;</entry>
</row>
<row>
<entry>protocol unimpl_arp &lcub;</entry>
</row>
<row>
<entry>&rcub;</entry>
</row>
<row>
<entry>protocol ether_ip4_arp &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>shaddr</entry>
<entry></entry>
<entry>&lcub; ether_ip4_arp&lsqb;0:6&rsqb; &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>spaddr</entry>
<entry></entry>
<entry>&lcub; ether_ip4_arp&lsqb;6:4&rsqb; &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>thaddr</entry>
<entry>&lcub; ether_ip4_arp&lsqb;10:6&rsqb; &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>tpaddr</entry>
<entry>&lcub; ether_ip4_arp&lsqb;16:4&rsqb; &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="315PT" align="left"/>
<tbody valign="top">
<row>
<entry>&rcub;</entry>
</row>
<row>
<entry>/************************ IP v4 ************************/</entry>
</row>
<row>
<entry>protocol ip &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>verhl</entry>
<entry>&lcub; ip&lsqb;0:1&rsqb; &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>ver</entry>
<entry>&lcub; (verhl &amp; 0xf0) &gt;&gt; 4 &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>hl</entry>
<entry>&lcub; (verhl &amp; 0x0f) &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>hlen</entry>
<entry>&lcub;hl &lt;&lt; 2 &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>tos</entry>
<entry></entry>
<entry>&lcub; ip&lsqb;1:1&rsqb; &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>length</entry>
<entry>&lcub; ip&lsqb;2:2&rsqb; &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>id</entry>
<entry></entry>
<entry>&lcub; ip&lsqb;4:2&rsqb; &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>ffo</entry>
<entry></entry>
<entry>&lcub; ip&lsqb;6:2&rsqb; &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>flags</entry>
<entry>&lcub; (ffo &amp; 0xe000) &gt;&gt; 13 &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>fragoff</entry>
<entry>&lcub; (ffo &amp; 0x1 fff) &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>ttl</entry>
<entry></entry>
<entry>&lcub; ip&lsqb;8:1&rsqb; &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>proto</entry>
<entry>&lcub; ip&lsqb;9:1&rsqb; &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>cksum</entry>
<entry></entry>
<entry>&lcub; ip&lsqb;10:2&rsqb; &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>src</entry>
<entry></entry>
<entry>&lcub; ip&lsqb;12:4&rsqb; &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>dst</entry>
<entry></entry>
<entry>&lcub; ip&lsqb;16:4&rsqb; &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="301PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>// varible length options start at offset 20</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>predicate</entry>
<entry>dbcast</entry>
<entry>&lcub; dst &equals;&thinsp;&equals; 255.255.255.255 &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>predicate</entry>
<entry>sbcast</entry>
<entry>&lcub; src &equals;&thinsp;&equals; 255.255.255.255 &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>predicate</entry>
<entry>smcast</entry>
<entry>&lcub; (src &amp; 0xF0000000) &equals;&thinsp;&equals; 0xE0000000 &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>predicate</entry>
<entry>dmcast</entry>
<entry>&lcub; (dst &amp; 0xF0000000) &equals;&thinsp;&equals; 0xE0000000 &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="5">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="77PT" align="left"/>
<colspec colname="4" colwidth="140PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>predicate</entry>
<entry>dontfr</entry>
<entry>&lcub; (flags &amp; 2) &excl;&equals; 0 &rcub;</entry>
<entry>// &ldquo;do not fragment this packet&rdquo;</entry>
</row>
<row>
<entry></entry>
<entry>predicate</entry>
<entry>morefr</entry>
<entry>&lcub; (flags &amp; 1) &excl;&equals; 0 &rcub;</entry>
<entry>// &ldquo;not last frag in datagram&rdquo;</entry>
</row>
<row>
<entry></entry>
<entry>predicate</entry>
<entry>isfrag</entry>
<entry>&lcub; morefr &par; fragoff &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>predicate</entry>
<entry>options</entry>
<entry>&lcub; hlen &gt; 20 &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>intrinsic</entry>
<entry>chksumvalid</entry>
<entry>&lcub; &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>predicate</entry>
<entry>okhwlen</entry>
<entry>&lcub; (frame.length - ether.offset) &gt;&equals; length &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>predicate</entry>
<entry>invalid</entry>
<entry>&lcub; (ver &excl;&equals; 4) &par; (hlen &lt; 20) &par;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry></entry>
<entry>((frame.length - ether.offset) &lt; length) &par;</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>(length &lt; hlen) &par; &excl;chksumvalid &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>predicate</entry>
<entry>badsrc</entry>
<entry>&lcub; sbcast &par; smcast &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="301PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>demux &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="287PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>// Demux expressions are evaluated in order, and the</entry>
</row>
<row>
<entry></entry>
<entry>// first one that matches causes a demux to the protocol;</entry>
</row>
<row>
<entry></entry>
<entry>// once one matches, no further checks are made, so the</entry>
</row>
<row>
<entry></entry>
<entry>// cases do not have to be precisely mutually exclusive.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="70PT" align="left"/>
<colspec colname="2" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>invalid</entry>
<entry>&lcub; ip_bad at 0 &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>badsrc</entry>
<entry>&lcub; ip_badsrc at 0 &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>(proto &equals;&thinsp;&equals; 1)</entry>
<entry>&lcub; icmp at hlen &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>(proto &equals;&thinsp;&equals; 2)</entry>
<entry>&lcub; igmp at hlen &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>(proto &equals;&thinsp;&equals; 6)</entry>
<entry>&lcub; tcp at hlen &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>(proto &equals;&thinsp;&equals; 17)</entry>
<entry>&lcub; udp at hlen &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>default</entry>
<entry>&lcub; ip_unknown_transport at hlen &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="301PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="315PT" align="left"/>
<tbody valign="top">
<row>
<entry>&rcub;</entry>
</row>
<row>
<entry>protocol ip_bad &lcub;</entry>
</row>
<row>
<entry>&rcub;</entry>
</row>
<row>
<entry>protocol ip_badsrc &lcub;</entry>
</row>
<row>
<entry>&rcub;</entry>
</row>
<row>
<entry>protocol ip_unknown_transport &lcub;</entry>
</row>
<row>
<entry>&rcub;</entry>
</row>
<row>
<entry>/*************************** UDP ********************************/</entry>
</row>
<row>
<entry>protocol udp &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>sport</entry>
<entry>&lcub; udp&lsqb;0:2&rsqb; &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>dport</entry>
<entry>&lcub; udp&lsqb;2:2&rsqb; &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>length</entry>
<entry>&lcub; udp&lsqb;4:2&rsqb; &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>cksum</entry>
<entry>&lcub; udp&lsqb;6:2&rsqb; &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="84PT" align="left"/>
<colspec colname="3" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>intrinsic</entry>
<entry>chksumvalid</entry>
<entry>&lcub; &rcub; /* undefined if a frag */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="5">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="42PT" align="left"/>
<colspec colname="4" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>predicate</entry>
<entry>valid</entry>
<entry></entry>
<entry>&lcub;ip.isfrag &par; chksumvalid &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="42PT" align="left"/>
<colspec colname="4" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry>&rcub;</entry>
<entry></entry>
<entry></entry>
<entry></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="315PT" align="left"/>
<tbody valign="top">
<row>
<entry>/************************** TCP *******************************/</entry>
</row>
<row>
<entry>protocol tcp &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>sport</entry>
<entry>&lcub; tcp&lsqb;0:2&rsqb; &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>dport</entry>
<entry>&lcub; tcp&lsqb;2:2&rsqb; &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>seq</entry>
<entry></entry>
<entry>&lcub; tcp&lsqb;4:4&rsqb; &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>ack</entry>
<entry></entry>
<entry>&lcub; tcp&lsqb;8:4&rsqb; &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>hlf</entry>
<entry></entry>
<entry>&lcub; tcp&lsqb;12:2&rsqb; &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>hl</entry>
<entry>&lcub; (hlf &amp; 0xf000) &gt;&gt; 12 &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>hlen</entry>
<entry>&lcub; hl &lt;&lt; 2 &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>flags</entry>
<entry>&lcub; (hlf &amp; 0x003f) &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>win</entry>
<entry></entry>
<entry>&lcub; tcp&lsqb;14:2&rsqb; &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>cksum</entry>
<entry></entry>
<entry>&lcub; tcp&lsqb;16:2&rsqb; &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>urp</entry>
<entry></entry>
<entry>&lcub; tcp&lsqb;18:2&rsqb; &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="84PT" align="left"/>
<colspec colname="3" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>intrinsic</entry>
<entry>chksumvalid</entry>
<entry>&lcub; &rcub; /* undefined if IP Fragment */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="5">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="42PT" align="left"/>
<colspec colname="4" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>predicate</entry>
<entry>valid</entry>
<entry></entry>
<entry>&lcub; ip.isfrag &par; ((hlen &gt;&equals; 20) &amp;&amp; chksumvalid) &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="84PT" align="left"/>
<colspec colname="3" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>predicate</entry>
<entry>opt_present</entry>
<entry>&lcub; hlen &gt; 20 &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="42PT" align="left"/>
<colspec colname="4" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry>&rcub;</entry>
<entry></entry>
<entry></entry>
<entry></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="315PT" align="left"/>
<tbody valign="top">
<row>
<entry>/************************** ICMP ***********************************/</entry>
</row>
<row>
<entry>protocol icmp &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>type</entry>
<entry>&lcub; icmp&lsqb;0:1&rsqb; &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>code</entry>
<entry>&lcub; icmp&lsqb;1:1&rsqb; &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>cksum</entry>
<entry></entry>
<entry>&lcub; icmp&lsqb;2:2&rsqb; &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="315PT" align="left"/>
<tbody valign="top">
<row>
<entry>&rcub;</entry>
</row>
<row>
<entry>/************************* IGMP ***********************************/</entry>
</row>
<row>
<entry>protocol igmp &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>vertype</entry>
<entry></entry>
<entry>&lcub; igmp&lsqb;0:1&rsqb; &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>ver</entry>
<entry>&lcub; (vertype &amp; 0xf0) &gt;&gt; 4 &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="35PT" align="left"/>
<colspec colname="3" colwidth="224PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>type</entry>
<entry>&lcub; (vertype &amp; 0x0f) &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>reserved</entry>
<entry></entry>
<entry>&lcub; igmp&lsqb;1:1&rsqb; &rcub;</entry>
</row>
<row>
<entry></entry>
<entry>cksum</entry>
<entry></entry>
<entry>&lcub; igmp&lsqb;2:2&rsqb; &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>group</entry>
<entry>&lcub; igmp&lsqb;4:4&rsqb; &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="315PT" align="left"/>
<tbody valign="top">
<row>
<entry>&rcub;</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
</section>
<section>
<heading lvl="1">VIII. ASL </heading>
<paragraph id="P-0659" lvl="0"><number>&lsqb;0659&rsqb;</number> The Application Services Library (ASL) provides a set of library functions available to action code that are useful for packet processing. The complete environment available to action code includes: the ASL; a restricted C/C&plus;&plus; library and runtime environment; one or more domain specific extensions such as TCP/IP. </paragraph>
<paragraph id="P-0660" lvl="7"><number>&lsqb;0660&rsqb;</number> The Restricted C/C&plus;&plus;Libraries And Runtime Environment </paragraph>
<paragraph id="P-0661" lvl="0"><number>&lsqb;0661&rsqb;</number> Action code may be implemented in either the ANSI C or C&plus;&plus; programming languages. A library supporting most of the functions defined in the ANSI C and C&plus;&plus; libraries is provided. These libraries are customized for the NetBoost PE hardware environment, and as such differ slightly from their equivalents in a standard host operating system. Most notably, file operations are restricted to the standard error and output streams (which are mapped into upcalls). </paragraph>
<paragraph id="P-0662" lvl="0"><number>&lsqb;0662&rsqb;</number> In addition to the C and C&plus;&plus; libraries available to action code, NetBoost supplies a specialized C and C&plus;&plus; runtime initialization object module which sets up the C and C&plus;&plus; run-time environments by initializing the set of environment variables and, in the case of C&plus;&plus;, executing constructors for static objects. </paragraph>
<paragraph id="P-0663" lvl="7"><number>&lsqb;0663&rsqb;</number> 1. ASL Functions </paragraph>
<paragraph id="P-0664" lvl="0"><number>&lsqb;0664&rsqb;</number> The ASL contains class definitions of potential use to any action code executing in the PE. It includes memory allocation, management of API objects (ACEs, targets), upcall/downcall support, set manipulation, timers, and a namespace support facility. The components comprising the ASL library are as follows: </paragraph>
<paragraph id="P-0665" lvl="2"><number>&lsqb;0665&rsqb;</number> Basic Scalar Types </paragraph>
<paragraph id="P-0666" lvl="0"><number>&lsqb;0666&rsqb;</number> The library contains basic type definitions that include the number of bits represented. These include int8 (8 bit integers), int16 (16 bit integers), int32 (32 bit integers), and int64 (64 bit integers). In addition, unsigned values (uint8, uint16, uint32, uint64) are also supported. </paragraph>
<paragraph id="P-0667" lvl="7"><number>&lsqb;0667&rsqb;</number> Special Endian-Sensitive Scalar Types </paragraph>
<paragraph id="P-0668" lvl="0"><number>&lsqb;0668&rsqb;</number> The ASL is commonly used for manipulating the contents of packets which are generally in network byte order. The ASL provides type definitions similar to the basic scalar types, but which represent data in network byte order. Types in network byte order as declared in the same fashion as the basic scalar types but with a leading n prefix (e.g. nuint16 refers to an unsigned 16 bit quantity in network byte order). The following functions are used to convert between the basic types (host order) and the network order types: </paragraph>
<paragraph id="P-0669" lvl="2"><number>&lsqb;0669&rsqb;</number> uint32 ntohl(nuint32 n); // network to host (32 bit) </paragraph>
<paragraph id="P-0670" lvl="2"><number>&lsqb;0670&rsqb;</number> uint16 ntohs(nuint16 n); // network to host (16 bit) </paragraph>
<paragraph id="P-0671" lvl="2"><number>&lsqb;0671&rsqb;</number> nuint32 htonl(uint32 h); // host to network (32 bit) </paragraph>
<paragraph id="P-0672" lvl="2"><number>&lsqb;0672&rsqb;</number> nuint16 htons(uint16 h); // host to network (16 bit) </paragraph>
<paragraph id="P-0673" lvl="7"><number>&lsqb;0673&rsqb;</number> Macros and Classes for Handling Errors and Exceptions in the ASL </paragraph>
<paragraph id="P-0674" lvl="0"><number>&lsqb;0674&rsqb;</number> The ASL contains a number of C/C&plus;&plus; macro definitions used to aid in debugging and code development (and mark fatal error conditions). These are listed below: </paragraph>
<paragraph id="P-0675" lvl="2"><number>&lsqb;0675&rsqb;</number> ASSERT Macros (asserts boolean expression, halts on failure) </paragraph>
<paragraph id="P-0676" lvl="2"><number>&lsqb;0676&rsqb;</number> CHECK Macros (asserts boolean, returns from current real-time loop on failure) </paragraph>
<paragraph id="P-0677" lvl="2"><number>&lsqb;0677&rsqb;</number> STUB Macros (gives message, c&plus;&plus;file name and line number) </paragraph>
<paragraph id="P-0678" lvl="2"><number>&lsqb;0678&rsqb;</number> SHO Macros (used to monitor value of a variable/expression during execution) </paragraph>
<paragraph id="P-0679" lvl="7"><number>&lsqb;0679&rsqb;</number> Exceptions </paragraph>
<paragraph id="P-0680" lvl="0"><number>&lsqb;0680&rsqb;</number> The ASL contains a number of functions available for use as exception handlers. Exceptions are a programming construct used to delivery error information up the call stack The following functions are provided for handling exceptions: </paragraph>
<paragraph id="P-0681" lvl="2"><number>&lsqb;0681&rsqb;</number> NBaction_err and NBaction_warn functions to be invoked when exceptions are thrown. </paragraph>
<paragraph id="P-0682" lvl="0"><number>&lsqb;0682&rsqb;</number> OnError class, used to invoke functions during exception handling, mostly for debugger breakpoints. </paragraph>
<paragraph id="P-0683" lvl="7"><number>&lsqb;0683&rsqb;</number> ACE Support </paragraph>
<paragraph id="P-0684" lvl="0"><number>&lsqb;0684&rsqb;</number> Ace objects in the ASL contain the per-Ace state information. To facilitate common operations, the base Ace class&apos; pass and drop targets are provided by the base class and built when an Ace instance is constructed. If no write action is taken on a buffer that arrives at the Ace (i.e. none of the actions of matching rules indicates it took ownership), the buffer is sent to the pass target. The pass and drop functions (i.e. target take functions, below) may be used directly as actions within the NCL application description, or they may be called by other actions. Member functions of the Ace class include: pass( ), drop( ), enaRule( )&mdash;enable a rule, disRule( )&mdash;disable a rule. </paragraph>
<paragraph id="P-0685" lvl="7"><number>&lsqb;0685&rsqb;</number> Action Support: </paragraph>
<paragraph id="P-0686" lvl="0"><number>&lsqb;0686&rsqb;</number> The init_actions( ) call is the primary entry point into the application&apos;s Action code. It is used by the ASL startup code to initialize the PE portion of the Network Application. It is responsible for constructing an Ace object of the proper class, and typically does nothing else. Example syntax: </paragraph>
<paragraph id="P-0687" lvl="2"><number>&lsqb;0687&rsqb;</number> INITF init_actions(void* id, char* names Image* obj)  
<table-cwu id="TABLE-US-00052">
<number>52</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="35PT" align="left"/>
<colspec colname="1" colwidth="182PT" align="left"/>
<thead>
<row>
<entry></entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>return new ExampleAce(id, name, obj);</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="35PT" align="left"/>
<colspec colname="1" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0688" lvl="7"><number>&lsqb;0688&rsqb;</number> The function should return a pointer to an object subclassed from the Ace class, or a NULL pointer if an Ace could not be constructed. Throwing an NBaction_err or NBaction_warn exception may also be appropriate and will be caught by the initialization code. Error conditions will be reported back to the Resolver as a failure to create the Ace. </paragraph>
<paragraph id="P-0689" lvl="7"><number>&lsqb;0689&rsqb;</number> Return Values from Action Code/Handlers </paragraph>
<paragraph id="P-0690" lvl="0"><number>&lsqb;0690&rsqb;</number> When a rule&apos;s action portion is invoked because the rule predication portion evaluated true, the action function must return a code indicating how processing should proceed. The action may return a code indicating it has disposed of the frame (ending the classification phase), or it may indicate it did not dispose of the frame, and further classification (rule evaluations) should continue. A final option available is for the action to return a defer code, indicating that it wishes to modify a frame, but that the frame is in use elsewhere. The return values are defined as C/C&plus;&plus; pre-processor definitions: </paragraph>
<paragraph id="P-0691" lvl="1"><number>&lsqb;0691&rsqb;</number> &num;define RULE DONE . . . </paragraph>
<paragraph id="P-0692" lvl="2"><number>&lsqb;0692&rsqb;</number> Actions should return RULE_DONE to terminate processing of rules and actions within the context of the current Ace; for instance, when a buffer has been sent to a target, or stored for later processing. </paragraph>
<paragraph id="P-0693" lvl="1"><number>&lsqb;0693&rsqb;</number> &num;define RULE_CONT . . . </paragraph>
<paragraph id="P-0694" lvl="2"><number>&lsqb;0694&rsqb;</number> Actions should return RULE_CONT if they have merely observed the buffer and wish for additional rules and actions within the context of the current ace to be processed. </paragraph>
<paragraph id="P-0695" lvl="1"><number>&lsqb;0695&rsqb;</number> &num;define RULE_DEFER . . . </paragraph>
<paragraph id="P-0696" lvl="2"><number>&lsqb;0696&rsqb;</number> Actions should return RULE_DEFER if they wish to modify a packet within a buffer but the buffer notes that the packet is currently busy elsewhere. </paragraph>
<paragraph id="P-0697" lvl="7"><number>&lsqb;0697&rsqb;</number> Predefined Actions </paragraph>
<paragraph id="P-0698" lvl="0"><number>&lsqb;0698&rsqb;</number> The common cases of disposing of a frame by either dropping it or sending it on to the next classification entity for processing is supported by two helper functions available to NCL code and result in calling the functions Ace::pass( ) or Ace::drop( ) within the ASL: action_pass (predefined action), passes frame to &lsquo;pass target&rsquo;, always returns RULE_DONE action_drop (predefined action), passes frame to &lsquo;drop target&rsquo;, always returns RULE_DONE </paragraph>
<paragraph id="P-0699" lvl="7"><number>&lsqb;0699&rsqb;</number> User-Defined Actions </paragraph>
<paragraph id="P-0700" lvl="0"><number>&lsqb;0700&rsqb;</number> Most often, user-defined actions are used in an Ace. Such actions are implemented with the following calling structure. </paragraph>
<paragraph id="P-0701" lvl="0"><number>&lsqb;0701&rsqb;</number> The ACTNF return type is used to set up linkage. Action handlers take two arguments: pointer to the current buffer being processed, and the Ace associated with this action. Example:  
<table-cwu id="TABLE-US-00053">
<number>53</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>ACTNF do_mcast (Buffer *buf ExAce *ace) &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>ace&minus;&gt;mcast_ct &plus;&plus;;</entry>
</row>
<row>
<entry></entry>
<entry>cout &lt;&lt; ace&minus;&gt;name() &lt;&lt; &Prime;: &Prime; &lt;&lt; ace&minus;&gt;mcast_ct &lt;&lt; endl;</entry>
</row>
<row>
<entry></entry>
<entry>return ace&minus;&gt;drop(buf);</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>&rcub;</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0702" lvl="7"><number>&lsqb;0702&rsqb;</number> Thus, the Buffer* and ExAce* types are passed to the handler. In this case, ExAce is derived from the base Ace class:  
<table-cwu id="TABLE-US-00054">
<number>54</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="196PT" align="left"/>
<thead>
<row>
<entry></entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
<entry>&num;include &Prime;NBaction/NBaction.h&Prime;</entry>
</row>
<row>
<entry></entry>
<entry>class ExAce : public Ace &lcub;</entry>
</row>
<row>
<entry></entry>
<entry>public:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="35PT" align="left"/>
<colspec colname="1" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&ensp;ExAce(Moduleld id, char *name, Image *obj)</entry>
</row>
<row>
<entry></entry>
<entry>: Ace(id, name, obj), mcast_ct(O) &lcub;</entry>
</row>
<row>
<entry></entry>
<entry>&ensp;int mcast_ct;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="196PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;;</entry>
</row>
<row>
<entry></entry>
<entry>INITF init_actions (void *id, char *name, Image *obj) &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="35PT" align="left"/>
<colspec colname="1" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&ensp;return new ExAce(id, name, obj) ;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="196PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0703" lvl="7"><number>&lsqb;0703&rsqb;</number> Buffer Management (Buffer Class) </paragraph>
<paragraph id="P-0704" lvl="0"><number>&lsqb;0704&rsqb;</number> The basic unit of processing in the ASL is the Buffer. All data received from the network is received in buffers, and all data to be transmitted must be properly formatted into buffers. Buffers are reference-counted. Contents are typed (more specifically, the type of the first header has a certain type &lsqb;an integer/enumerated type&rsqb;). Member functions of the Buffer class support common trimming operations (trim head, trim tail) plus additions (prepend and append date). Buffers are assigned a time stamp upon arrival and departure (if they are transmitted). The member function rxTime( ) returns receipt time stamp of the frame contained in the buffer. The txTime( ) gives transmission complete time stamp of the buffer if the frame it contains has been transmitted. Several additional member functions and operators are supported: new( )&mdash;allocates buffer from pool structure (see below), headerBase( )&mdash;location of first network header, headeroffset( )&mdash;reference to byte offset from start of storage to first network header, packetSize( )&mdash;number of bytes in frame, headerType( )&mdash;type of first header, packetPadHeadSize( )&mdash;free space before net packet, packetPadTailSize( )&mdash;free space after net packet, prepend( )&mdash;add data to beginning, append( )&mdash;add data to end, trim_head( )&mdash;remove data from head, trim_tail( )&mdash;remove data from end, &lcub;rx, tx&rcub; Time( )&mdash;see above, next( )&mdash;reference to next buffer on chain, incref( )&mdash;bump reference count, decref( )&mdash;decrement reference count, busy( )&mdash;indicates buffer being processed, log( )&mdash;allows for adding info the &lsquo;transaction log&rsquo; of a buffer which can indicate what has processed it. </paragraph>
<paragraph id="P-0705" lvl="7"><number>&lsqb;0705&rsqb;</number> Targets </paragraph>
<paragraph id="P-0706" lvl="0"><number>&lsqb;0706&rsqb;</number> Target objects within an Ace indicate the next hardware or software resource that will classify a buffer along a selected path. Targets are bound to another Ace within the same application, an Ace within a different application, or a built in resource such as decryption. Bindings for Targets are set up by the plumber (see above). The class includes the member function take( ) which sends a buffer to the next downstream entity for classification. </paragraph>
<paragraph id="P-0707" lvl="0"><number>&lsqb;0707&rsqb;</number> Targets have an associated module and Ace (specified by a &ldquo;ModuleId&rdquo; object and an Ace*). They also have a name in the name space contained in the resolver, which associates Aces to applications. </paragraph>
<paragraph id="P-0708" lvl="7"><number>&lsqb;0708&rsqb;</number> Upcall </paragraph>
<paragraph id="P-0709" lvl="0"><number>&lsqb;0709&rsqb;</number> An upcall is a form of procedure call initiated in the PE module and handled in the AP module. Upcalls provide communication between the &ldquo;inline&rdquo; portion of an application and its &ldquo;slower path&rdquo; executing in the host environment. Within the ASL, the upcall facility sends messages to the AP. Messages are defined below. The upcall class contains the member function call( )&mdash;which takes objects of type Message* and sends them asynchronously to AP module. </paragraph>
<paragraph id="P-0710" lvl="7"><number>&lsqb;0710&rsqb;</number> DowncallHandler </paragraph>
<paragraph id="P-0711" lvl="0"><number>&lsqb;0711&rsqb;</number> A downcall is a form of procedure call initiated in the AP module and handled in the PE module. Downcalls provide the opposite direction of communication than upcalls. The class contains the member function direct( ) which provides a pointer to the member function of the Ace class that is to be invoked when the associated downcall is requested in the AP. The Ace member function pointed to takes a Message * type as argument. </paragraph>
<paragraph id="P-0712" lvl="7"><number>&lsqb;0712&rsqb;</number> Message </paragraph>
<paragraph id="P-0713" lvl="0"><number>&lsqb;0713&rsqb;</number> Messages contain zero, one, or two blocks of message data, which are independently constructed using the MessageBlock constructors (below). Uninitialized blocks will appear at the Upcall handler in the AP module as zero length messages. Member functions of the Message class include: msg1( ), msg2( ), len1( ), len2( )&mdash;returns addresses and lengths of the messages &lsqb;if present&rsqb;. Other member functions: clr1( ), clr2( ), done( )&mdash;acknowledge receipt of a message and free resources. </paragraph>
<paragraph id="P-0714" lvl="7"><number>&lsqb;0714&rsqb;</number> MessageBlock </paragraph>
<paragraph id="P-0715" lvl="0"><number>&lsqb;0715&rsqb;</number> The MessageBlock class is used to encapsulate a region of storage within the Policy Engine memory that will be used in a future Upcall Message. It also includes a method to be called when the service software has copied the data out of that storage and no longer needs it to be stable (and can allow it to be recycled). Constructor syntax is as follows: </paragraph>
<paragraph id="P-0716" lvl="2"><number>&lsqb;0716&rsqb;</number> MessageBlock(char *msg, int len&equals;0, DoneFp done&equals;0); </paragraph>
<paragraph id="P-0717" lvl="2"><number>&lsqb;0717&rsqb;</number> MessageBlock(Buffer *buf); </paragraph>
<paragraph id="P-0718" lvl="2"><number>&lsqb;0718&rsqb;</number> MessageBlock(int len, int off&equals;0); </paragraph>
<paragraph id="P-0719" lvl="7"><number>&lsqb;0719&rsqb;</number> The first form specifies an existing data area to be used as the data source. If the completion callback function (DoneFp) is specified, it will be called when the data has been copied out of the source area. Otherwise, no callback is made and no special actions are taken after the data is copied out of the message block. If no length is specified, then the base pointer is assumed to point to a zero-terminated string; the length is calculated to include the null termination. The second form specifies a Buffer object; the data transferred is the data contained within the buffer, and the relative alignment of the data within the 32-bit word is retained. The reference count on the buffer is incremented when the MessageBlock is created, and the callback function is set to decrement the reference count when the copy out is complete. This will have the effect of marking the packet as &ldquo;busy&rdquo; for any actions that check for busy buffers, as well as preventing the buffer from being recycled before the copy out is complete. The third form requests that MessageBlock handle dynamic allocation of a region of memory large enough to hold a message of a specified size. Optionally, a second parameter can be specified that gives the offset from the 32-bit word alignment boundary where the data should start. The data block will retain this relative byte offset throughout its transfer to the Application Processor. This allows, for instance, allocating a 1514-byte data area with 2-byte offset, building an Ethernet frame within it, and having any IP headers included in the packet land properly aligned on 32-bit alignment boundaries. </paragraph>
<paragraph id="P-0720" lvl="7"><number>&lsqb;0720&rsqb;</number> Sets </paragraph>
<paragraph id="P-0721" lvl="0"><number>&lsqb;0721&rsqb;</number> Sets are an efficient way to track a large number of equivalence classes of packets, so that state can be kept for all packets that have the same values in specific fields. For instance, the programmer might wish to count the number of packets that flow between any two specific IP address pairs, or keep state for each TCP stream. Sets represent collections of individual members, each one of which matches buffers with a specific combination of field values. If the programmer instead wishes to form sets of the form &ldquo;the set of all packets with IP header lengths greater than twenty bytes,&rdquo; then the present form of sets are not appropriate; instead, a Classification Predicate should be used. </paragraph>
<paragraph id="P-0722" lvl="0"><number>&lsqb;0722&rsqb;</number> In NCL, the only information available regarding a set is whether or not a set contained a record corresponding to a vector of search keys. Within the ASL, all other set operations are supported: searches, insertions, and removals. For searches conducted in the CE, the ASL provides access to additional information obtained during the search operation: specifically, a pointer to the actual element located (for successful searches), and other helpful information such as an insertion pointer (on failure). The actual elements stored in each set are of a class constructed by the compiler, or are of a class that the software vendor has subclassed from that class. The hardware environment places strict requirements on the alignment modulus and alignment offset for each set element. </paragraph>
<paragraph id="P-0723" lvl="0"><number>&lsqb;0723&rsqb;</number> As shown in the NCL specification, a single set may be searched by several vectors of keys, resulting in multiple search results that share the same target element records. Each of these directives results in the construction of a function that fills the key fields of the suitable Element subclass from a buffer. </paragraph>
<paragraph id="P-0724" lvl="0"><number>&lsqb;0724&rsqb;</number> Within the ASL, the class set is used to abstract a set. It serves as a base class for compiler generated classes specific to the sets specified in the NCL program (see below). </paragraph>
<paragraph id="P-0725" lvl="7"><number>&lsqb;0725&rsqb;</number> Search </paragraph>
<paragraph id="P-0726" lvl="0"><number>&lsqb;0726&rsqb;</number> The Search class is the data type returned by all set searching operations, whether provided directly by the ASL or executed within the classification engine. Member functions: ran( )&mdash;true if the CE executed this search on a set, hit( )&mdash;true if the CE found a match using this search, miss( )&mdash;inverse of hit( ) but can return a cookie making inserts faster, toElement( )&mdash;converts successful search result to underlying object, inserts&mdash;insert an object at the place the miss( ) function indicates we should. </paragraph>
<paragraph id="P-0727" lvl="7"><number>&lsqb;0727&rsqb;</number> Element </paragraph>
<paragraph id="P-0728" lvl="0"><number>&lsqb;0728&rsqb;</number> Contents of sets are called elements, and the NCL compiler generates a collection of specialized classes derived from the Element base class to contain user-specified data within set elements. Set elements may have an associated timeout value, indicating the maximum amount of time the set element should be maintained. After the time out is reached, the set element is automatically removed from the set. The time out facility is useful for monitoring network activity such as packet flows that should eventually be cleared due to inactivity. </paragraph>
<paragraph id="P-0729" lvl="7"><number>&lsqb;0729&rsqb;</number> Compiler_Generated Elt_&lt;setname&gt; Classes </paragraph>
<paragraph id="P-0730" lvl="0"><number>&lsqb;0730&rsqb;</number> For each set directive in the NCL program, the NCL compiler produces an adjusted subclassoftheElement class called Elt_&lt;setname&gt;, substituting the name of the set for &lt;setname&gt;. This class is used to define the type of elements of the specified set Because each set declaration contains the number of keys needed to search the set, this compiler-generated class is specialized from the element base class for the number of words of search key being used. </paragraph>
<paragraph id="P-0731" lvl="7"><number>&lsqb;0731&rsqb;</number> Compiler-Generated Set_&lt;setname&gt; Classes </paragraph>
<paragraph id="P-0732" lvl="0"><number>&lsqb;0732&rsqb;</number> For each set directive in the NCL program, the NCL compiler produces an adjusted subclass of the Element class called Set_&lt;setname&gt;, substituting the name of the set for &lt;setname&gt;. This class is used to define the lookup functions of the specified set. The NCL compiler uses the number of words of key information to customize the parameter list for the lookup function; the NCL size_hint is used to adjust a protected field within the class. Aces that needing to manipulate sets should include an object of the customized Set class as a member of their Ace. </paragraph>
<paragraph id="P-0733" lvl="7"><number>&lsqb;0733&rsqb;</number> Events </paragraph>
<paragraph id="P-0734" lvl="0"><number>&lsqb;0734&rsqb;</number> The Event class provides for execution of functions at arbitrary times in the future, with efficient rescheduling of the event and the ability to cancel an event without destroying the event marker itself. A calendar queue is used to implement the event mechanism. When constructing objects of the Event class, two optional parameters may be specified: the function to be called (which must be a member function of a class based on Event), and an initial scheduled time (how long in the future, expressed as a Time object). When both parameters are specified, the event&apos;s service function is set and the event is scheduled. If the Time parameter is not specified, the Event&apos;s service function is still set but the event is not scheduled. If the service function is not set, it is assumed that the event will be directed to a service function before it is scheduled in the future. Member functions of this class include: direct( )&mdash;specifies what function to be executed at expiry, schedule( )&mdash;indicates how far in the future for event to trigger, cancel( )&mdash;unschedule event, curr( )&mdash;get time of currently running event. </paragraph>
<paragraph id="P-0735" lvl="7"><number>&lsqb;0735&rsqb;</number> Rate </paragraph>
<paragraph id="P-0736" lvl="0"><number>&lsqb;0736&rsqb;</number> The Rate class provides a simple way to track event rates and bandwidths in order to watch for rates exceeding desired values. The Rate constructor allows the application to specify arbitrary sampling periods. The application can (optionally) specify how finely to divide the sampling period. Larger divisors result in more precise rate measurement but require more overhead, since the Rate object schedules Events for each of the shorter periods while there are events within the longer period. Member functions of this class include: clear( )&mdash;reset internal state, add( )&mdash;bumps event count, count( )&mdash;gives best estimate of current trailing rate of events over last/longer period </paragraph>
<paragraph id="P-0737" lvl="7"><number>&lsqb;0737&rsqb;</number> Time </paragraph>
<paragraph id="P-0738" lvl="0"><number>&lsqb;0738&rsqb;</number> The Time class provides a common format for carrying around a time value. Absolute, relative, and elapsed times are all handled identically. As conversions to and from int64 (a sixty-four bit unsigned integer value) are provided, all scalar operators are available for use; in addition, the assignment operators are explicitly provided. Various other classes use Time objects to specify absolute times and time intervals. For maximum future flexibility in selection of storage formats, the actual units of the scalar time value are not specified; instead, they are stored as a class variable. Extraction of meaningful data should be done via the appropriate access methods rather than by direct arithmetic on the Time object. </paragraph>
<paragraph id="P-0739" lvl="0"><number>&lsqb;0739&rsqb;</number> Class methods are available to construct Time objects for specified numbers of standard time units (microseconds, milliseconds, seconds, minutes, hours, days and weeks); also, methods are provided for extraction of those standard time periods from any Time object. Member functions include: curr( )&mdash;returns current real time, operators: &plus;&equals;, &minus;&equals;, *&equals;, /&equals;, %&equals;, &lt;&lt;&equals;, &gt;&gt;&equals;, &verbar;&equals;, &circ; &equals;, &amp;&equals;, accessors&plus;builders: usec( ), msec( ), secs( ), mins( ), hour( ), days( ), week( ), which access or build Time objects using the specified number of microseconds, milliseconds, seconds, minutes, hours, days, and weeks, respectively. </paragraph>
<paragraph id="P-0740" lvl="7"><number>&lsqb;0740&rsqb;</number> Memory Pool </paragraph>
<paragraph id="P-0741" lvl="0"><number>&lsqb;0741&rsqb;</number> The Pool class provides a mechanism for fast allocation of objects of fixed sizes at specified offsets from specified power-of-two alignments, restocking the raw memory resources from the PE module memory pool as required. The constructor creates an object that describes the contents of the memory pool and contains the configuration control information for how future allocations will be handled. </paragraph>
<paragraph id="P-0742" lvl="0"><number>&lsqb;0742&rsqb;</number> Special &lsquo;offset&rsquo; and &lsquo;restock&rsquo; parameters are used. The offset parameter allows allocation of classes where a specific member needs to be strongly aligned; for example, objects from the Buffer class contain an element called hard that must start at the beginning of a 2048-byte-aligned region. The restock parameter controls how much memory is allocated from the surrounding environment when the pool is empty. Enough memory is allocated to contain at least the requested number of objects, of the specified size, at the specified offset from the alignment modulus. Member function include: take( )&mdash;allocate a chunk, free( )&mdash;return a chunk to the pool. </paragraph>
<paragraph id="P-0743" lvl="7"><number>&lsqb;0743&rsqb;</number> Tagged Memory Pool </paragraph>
<paragraph id="P-0744" lvl="0"><number>&lsqb;0744&rsqb;</number> Objects that carry with them a reference back to the pool from which they were taken are called tagged. This is most useful for cases when the code that frees the object will not necessarily know what pool it came from. This class is similar to normal Memory Pools, except for internal details and the calling sequence for freeing objects back into the pool. The tagged class trades some additional space overhead for the flexibility of being able to free objects without knowing which Tagged pool they came from; this is similar to the overhead required by most C library malloc implementations. If the object has strong alignment requirements, the single added word of overhead could cause much space to be wasted between the objects. For instance, if the objects were 32 bytes long and were required to start on 32-byte boundaries, the additional word would cause another 28 bytes of padding to be wasted between adjacent objects. </paragraph>
<paragraph id="P-0745" lvl="0"><number>&lsqb;0745&rsqb;</number> The Tagged class adds a second (static) version of the take method, which is passed the size of the object to be allocated. The Tagged class manages an appropriate set of pools based on possible object sizes, grouping objects of similar size together to limit the number of pools and allow sharing of real memory between objects of slightly different sizes. Member functions include: take( )&mdash;allocate a chunk, free( )&mdash;return a chunk to the pool. </paragraph>
<paragraph id="P-0746" lvl="7"><number>&lsqb;0746&rsqb;</number> Dynamic </paragraph>
<paragraph id="P-0747" lvl="0"><number>&lsqb;0747&rsqb;</number> This class takes care of overloading the new and delete operators, redirecting the memory allocation to use a number of Tagged Pools managed by the NBACTION DLL. All classes derived from Dynamic share the same set of Tagged Pools; each pool handles a specific range of object sizes, and objects of similar sizes will share the same Tagged Pool. The dynamic class has no storage requirements and no virtual functions. Thus, declaring objects derived from Dynamic will not change the size or layout of your objects (just how they are allocated). Operators defined include: new( )&mdash;allocate object from underlying pool, delete( )&mdash;return to underlying pool. </paragraph>
<paragraph id="P-0748" lvl="7"><number>&lsqb;0748&rsqb;</number> Name Dictionary </paragraph>
<paragraph id="P-0749" lvl="0"><number>&lsqb;0749&rsqb;</number> The Name class keeps a database of named objects (that are arbitrary pointers in the memory address space of the ASL. It provides mechanisms for adding objects to the dictionary, finding objects by name, and removing them from the dictionary. It is implemented with a Patricia Tree (a structure often used in longest prefix match in routing table lookups). Member functions include: find( )&mdash;look up string, name( )&mdash;return name of dictionary. </paragraph>
<paragraph id="P-0750" lvl="7"><number>&lsqb;0750&rsqb;</number> 2. ASL Extensions for TCP/IP </paragraph>
<paragraph id="P-0751" lvl="0"><number>&lsqb;0751&rsqb;</number> The TCP/IP Extensions to the Action Services Library (ASL) provides a set of class definitions designed to make several tasks common to TCP/IP-based network-oriented applications easier. With functions spanning several protocol layers, it includes operations such as IP fragment reassembly and TCP stream reconstruction. Note that many of the functions that handle Internet data make use of 16 and 32-bit data types beginning with &lsquo;n&rsquo; (such as nuint16 and nuint32). These data types refer to data in network byte order (i.e. big endian). Functions used to convert between host and network byte such as htonl( ) (which converts a 32-bit word from host to network byte order), are also defined. </paragraph>
<paragraph id="P-0752" lvl="7"><number>&lsqb;0752&rsqb;</number> 3. The Internet Class </paragraph>
<paragraph id="P-0753" lvl="0"><number>&lsqb;0753&rsqb;</number> Functions of potential use to any Internet application are grouped together as methods of the Internet class. These functions are declared static within the class, so that they may be used easily without requiring an instantiation of the Internet class. </paragraph>
<paragraph id="P-0754" lvl="7"><number>&lsqb;0754&rsqb;</number> Internet Checksum Support </paragraph>
<paragraph id="P-0755" lvl="0"><number>&lsqb;0755&rsqb;</number> The Internet Checksum is used extensively within the TCP/IP protocols to provide reasonably high assurance that data has been delivered correctly. In particular, it is used in IP (for headers), TCP and UDP (for headers and data), ICMP (for headers and data), and IGMP (for headers). </paragraph>
<paragraph id="P-0756" lvl="0"><number>&lsqb;0756&rsqb;</number> The Internet checksum is defined to be the l&apos;s complement of the sum of a region of data, where the sum is computed using 16-bit words and 1&apos;s complement addition. </paragraph>
<paragraph id="P-0757" lvl="0"><number>&lsqb;0757&rsqb;</number> Computation of this checksum is documented in a number of RFCs (available from ftp://ds internic.net/rfc): RFC 1936 describes a hardware implementation, RFC 1624 and RFC 1141 describe incremental updates, RFC 1071 describes a number of mathematical properties of the checksum and how to compute it quickly. RFC 1071 also includes a copy of IEN 45 (from 1978), which describes motivations for the design of the checksum. </paragraph>
<paragraph id="P-0758" lvl="0"><number>&lsqb;0758&rsqb;</number> The ASL provides the following functions to calculate Internet Checksums: </paragraph>
<paragraph id="P-0759" lvl="1"><number>&lsqb;0759&rsqb;</number> cksum </paragraph>
<paragraph id="P-0760" lvl="7"><number>&lsqb;0760&rsqb;</number> Description </paragraph>
<paragraph id="P-0761" lvl="0"><number>&lsqb;0761&rsqb;</number> Computes the Internet Checksum of the data specified. This function works properly for data aligned to any byte boundary, but may perform (significantly) better for 32-bit aligned data. </paragraph>
<paragraph id="P-0762" lvl="7"><number>&lsqb;0762&rsqb;</number> Syntax </paragraph>
<paragraph id="P-0763" lvl="1"><number>&lsqb;0763&rsqb;</number> static nuint16 Internet::cksum(u_char* base, int len);  
<table-cwu id="TABLE-US-00055">
<number>55</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="49PT" align="left"/>
<colspec colname="3" colwidth="105PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry></entry>
<entry>base</entry>
<entry>unsigned</entry>
<entry>The starting address of the data.</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>char*</entry>
</row>
<row>
<entry></entry>
<entry>len</entry>
<entry>int</entry>
<entry>The number of bytes of data.</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0764" lvl="7"><number>&lsqb;0764&rsqb;</number> Return Value </paragraph>
<paragraph id="P-0765" lvl="0"><number>&lsqb;0765&rsqb;</number> Returns the Internet Checksum in the same byte order as the underlying data, which is assumed to be in network byte order (big endian). </paragraph>
<paragraph id="P-0766" lvl="7"><number>&lsqb;0766&rsqb;</number> psum </paragraph>
<paragraph id="P-0767" lvl="7"><number>&lsqb;0767&rsqb;</number> Description </paragraph>
<paragraph id="P-0768" lvl="0"><number>&lsqb;0768&rsqb;</number> Computes the 2&apos;s-complement sum of a region of data taken as 16-bit words. The Internet Checksum for the specified data region may be generated by folding any carry bits above the low-order 16 bits and taking the l&apos;s complement of the resulting value. </paragraph>
<paragraph id="P-0769" lvl="7"><number>&lsqb;0769&rsqb;</number> Syntax </paragraph>
<paragraph id="P-0770" lvl="1"><number>&lsqb;0770&rsqb;</number> static uint32 Internet::psum(u_char* base, int len);  
<table-cwu id="TABLE-US-00056">
<number>56</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="49PT" align="left"/>
<colspec colname="3" colwidth="105PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry></entry>
<entry>base</entry>
<entry>unsigned</entry>
<entry>The starting address of the data.</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>char*</entry>
</row>
<row>
<entry></entry>
<entry>len</entry>
<entry>int</entry>
<entry>The number of bytes of data.</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0771" lvl="7"><number>&lsqb;0771&rsqb;</number> Return Value </paragraph>
<paragraph id="P-0772" lvl="0"><number>&lsqb;0772&rsqb;</number> Returns the 2&apos;s-complement 32-bit sum of the data treated as an array of 16-bit words. </paragraph>
<paragraph id="P-0773" lvl="1"><number>&lsqb;0773&rsqb;</number> incrcksum </paragraph>
<paragraph id="P-0774" lvl="7"><number>&lsqb;0774&rsqb;</number> Description </paragraph>
<paragraph id="P-0775" lvl="0"><number>&lsqb;0775&rsqb;</number> Computes a new Internet Checksum incrementally. That is, a new checksum is computed given the original checksum for a region of data, a checksum for a block of data to be replaced, and a checksum of the new data replacing the old data. This function is especially useful when small regions of packets are modified and checksums must be updated appropriately (e.g. for decrementing IP ttl fields or rewriting address fields for NAT). </paragraph>
<paragraph id="P-0776" lvl="7"><number>&lsqb;0776&rsqb;</number> Syntax </paragraph>
<paragraph id="P-0777" lvl="1"><number>&lsqb;0777&rsqb;</number> static uint16 </paragraph>
<paragraph id="P-0778" lvl="2"><number>&lsqb;0778&rsqb;</number> Internet::incrcksum(nuint16 ocksum, nuint16 odsum, nuint16 ndsum);  
<table-cwu id="TABLE-US-00057">
<number>57</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="35PT" align="left"/>
<colspec colname="3" colwidth="126PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry></entry>
<entry>ocksum</entry>
<entry>nuint16</entry>
<entry>The original checksum.</entry>
</row>
<row>
<entry></entry>
<entry>odsum</entry>
<entry>nuint16</entry>
<entry>The checksum of the old data.</entry>
</row>
<row>
<entry></entry>
<entry>ndsum</entry>
<entry>nuint16</entry>
<entry>The checksum of the new (replacing) data.</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0779" lvl="7"><number>&lsqb;0779&rsqb;</number> Return Value </paragraph>
<paragraph id="P-0780" lvl="0"><number>&lsqb;0780&rsqb;</number> Returns the computed checksum. </paragraph>
<paragraph id="P-0781" lvl="1"><number>&lsqb;0781&rsqb;</number> asum </paragraph>
<paragraph id="P-0782" lvl="7"><number>&lsqb;0782&rsqb;</number> Description </paragraph>
<paragraph id="P-0783" lvl="0"><number>&lsqb;0783&rsqb;</number> The function asum computes the checksum over only the IP source and destination addresses. </paragraph>
<paragraph id="P-0784" lvl="7"><number>&lsqb;0784&rsqb;</number> Syntax </paragraph>
<paragraph id="P-0785" lvl="1"><number>&lsqb;0785&rsqb;</number> static uint16 asum(IP4Header* hdr);  
<table-cwu id="TABLE-US-00058">
<number>58</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="91PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry></entry>
<entry>hdr</entry>
<entry>IP4Header*</entry>
<entry>Pointer to the header.</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0786" lvl="7"><number>&lsqb;0786&rsqb;</number> Return Value </paragraph>
<paragraph id="P-0787" lvl="0"><number>&lsqb;0787&rsqb;</number> Returns the checksum. </paragraph>
<paragraph id="P-0788" lvl="1"><number>&lsqb;0788&rsqb;</number> apsum </paragraph>
<paragraph id="P-0789" lvl="7"><number>&lsqb;0789&rsqb;</number> Description </paragraph>
<paragraph id="P-0790" lvl="0"><number>&lsqb;0790&rsqb;</number> The function apsum behaves like asum but includes the address plus the two 16-bit words immediately following the IP header (which are the port numbers for TCP and UDP). </paragraph>
<paragraph id="P-0791" lvl="7"><number>&lsqb;0791&rsqb;</number> Syntax </paragraph>
<paragraph id="P-0792" lvl="1"><number>&lsqb;0792&rsqb;</number> static uint16 apsum(IP4Header* hdr);  
<table-cwu id="TABLE-US-00059">
<number>59</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="91PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry></entry>
<entry>hdr</entry>
<entry>IP4Header*</entry>
<entry>Pointer to the header.</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0793" lvl="7"><number>&lsqb;0793&rsqb;</number> Return Value </paragraph>
<paragraph id="P-0794" lvl="0"><number>&lsqb;0794&rsqb;</number> Returns the checksum. </paragraph>
<paragraph id="P-0795" lvl="1"><number>&lsqb;0795&rsqb;</number> apssum </paragraph>
<paragraph id="P-0796" lvl="7"><number>&lsqb;0796&rsqb;</number> Description </paragraph>
<paragraph id="P-0797" lvl="0"><number>&lsqb;0797&rsqb;</number> The function apssum behaves like apsum, but covers the IP addresses, ports, plus TCP sequence number. </paragraph>
<paragraph id="P-0798" lvl="7"><number>&lsqb;0798&rsqb;</number> Syntax </paragraph>
<paragraph id="P-0799" lvl="1"><number>&lsqb;0799&rsqb;</number> static uint16 apssum(IP4Header* hdr);  
<table-cwu id="TABLE-US-00060">
<number>60</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="91PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry></entry>
<entry>hdr</entry>
<entry>IP4Header*</entry>
<entry>Pointer to the header.</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0800" lvl="7"><number>&lsqb;0800&rsqb;</number> Return Value </paragraph>
<paragraph id="P-0801" lvl="0"><number>&lsqb;0801&rsqb;</number> Returns the checksum. </paragraph>
<paragraph id="P-0802" lvl="1"><number>&lsqb;0802&rsqb;</number> apasum </paragraph>
<paragraph id="P-0803" lvl="7"><number>&lsqb;0803&rsqb;</number> Description </paragraph>
<paragraph id="P-0804" lvl="0"><number>&lsqb;0804&rsqb;</number> The function apasum is behaves like apssum, but covers the TCP ACK field instead of the sequence number field. </paragraph>
<paragraph id="P-0805" lvl="7"><number>&lsqb;0805&rsqb;</number> Syntax </paragraph>
<paragraph id="P-0806" lvl="1"><number>&lsqb;0806&rsqb;</number> static uint16 apasum(IP4Header* hdr);  
<table-cwu id="TABLE-US-00061">
<number>61</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="91PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry></entry>
<entry>hdr</entry>
<entry>IP4Header*</entry>
<entry>Pointer to the header.</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0807" lvl="7"><number>&lsqb;0807&rsqb;</number> Return Value </paragraph>
<paragraph id="P-0808" lvl="0"><number>&lsqb;0808&rsqb;</number> Returns the checksum. </paragraph>
<paragraph id="P-0809" lvl="1"><number>&lsqb;0809&rsqb;</number> apsasum </paragraph>
<paragraph id="P-0810" lvl="7"><number>&lsqb;0810&rsqb;</number> Description </paragraph>
<paragraph id="P-0811" lvl="0"><number>&lsqb;0811&rsqb;</number> The function apsasum behaves like apasum but covers the IP addresses, ports, plus the TCP ACK and sequence numbers. </paragraph>
<paragraph id="P-0812" lvl="7"><number>&lsqb;0812&rsqb;</number> Syntax </paragraph>
<paragraph id="P-0813" lvl="1"><number>&lsqb;0813&rsqb;</number> static uint16 apsasum(IP4Header* hdr);  
<table-cwu id="TABLE-US-00062">
<number>62</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="91PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry></entry>
<entry>hdr</entry>
<entry>IP4Header*</entry>
<entry>Pointer to the header.</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0814" lvl="7"><number>&lsqb;0814&rsqb;</number> Return Value </paragraph>
<paragraph id="P-0815" lvl="0"><number>&lsqb;0815&rsqb;</number> Returns the checksum. </paragraph>
<paragraph id="P-0816" lvl="0"><number>&lsqb;0816&rsqb;</number> 4. IP Support </paragraph>
<paragraph id="P-0817" lvl="0"><number>&lsqb;0817&rsqb;</number> This section describes the class definitions and constants used in processing IP-layer data. Generally, all data is stored in network byte order (big endian). Thus, care should be taken by the caller to ensure computations result in proper values when processing network byte ordered data on little endian machines (e.g. in the NetBoost software-only environment on pc-compatible architectures). </paragraph>
<paragraph id="P-0818" lvl="0"><number>&lsqb;0818&rsqb;</number> 5. IP Addresses </paragraph>
<paragraph id="P-0819" lvl="0"><number>&lsqb;0819&rsqb;</number> The IP4Addr class defines 32-bit IP version 4 addresses. </paragraph>
<paragraph id="P-0820" lvl="1"><number>&lsqb;0820&rsqb;</number> Constructors </paragraph>
<paragraph id="P-0821" lvl="7"><number>&lsqb;0821&rsqb;</number> Description </paragraph>
<paragraph id="P-0822" lvl="0"><number>&lsqb;0822&rsqb;</number> The class IP4Addr is the abstraction of an IP (version 4) address within the ASL. It has two constructors, allowing for the creation of the IPv4 addresses given an unsigned 32-bit word in either host or network byte order. In addition, the class is derived from nuint32, so P addresses may generally be treated as 32-bit integers in network byte order. </paragraph>
<paragraph id="P-0823" lvl="7"><number>&lsqb;0823&rsqb;</number> Syntax </paragraph>
<paragraph id="P-0824" lvl="1"><number>&lsqb;0824&rsqb;</number> IP4Addr(nuint32 an); </paragraph>
<paragraph id="P-0825" lvl="1"><number>&lsqb;0825&rsqb;</number> IP4Addr(uint32 ah);  
<table-cwu id="TABLE-US-00063">
<number>63</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="35PT" align="left"/>
<colspec colname="3" colwidth="140PT" align="left"/>
<tbody valign="top">
<row>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>an</entry>
<entry>nuint32</entry>
<entry>Unsigned 32-bit word in network byte order.</entry>
</row>
<row>
<entry>ah</entry>
<entry>uint32</entry>
<entry>Unsigned 32-bit word in host byte order.</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0826" lvl="7"><number>&lsqb;0826&rsqb;</number> Return Value </paragraph>
<paragraph id="P-0827" lvl="0"><number>&lsqb;0827&rsqb;</number> None. </paragraph>
</section>
<section>
<heading lvl="1">EXAMPLE </heading>
<paragraph id="P-0828" lvl="0"><number>&lsqb;0828&rsqb;</number> The following simple example illustrates the creation of addresses: </paragraph>
<paragraph id="P-0829" lvl="1"><number>&lsqb;0829&rsqb;</number> &num;include &ldquo;NBip.h&rdquo;</paragraph>
<paragraph id="P-0830" lvl="1"><number>&lsqb;0830&rsqb;</number> uint32 myhaddr&equals;(128&lt;&lt;24)(32&lt;&lt;16)&verbar;(12&lt;&lt;8)&verbar;4; </paragraph>
<paragraph id="P-0831" lvl="1"><number>&lsqb;0831&rsqb;</number> nuint32 mynaddr&equals;htonl((128&lt;&lt;24)&verbar;(32&lt;&lt;16)&verbar;(12&lt;&lt;8)&verbar;4); </paragraph>
<paragraph id="P-0832" lvl="1"><number>&lsqb;0832&rsqb;</number> IP4Addr ip1(myhaddr); </paragraph>
<paragraph id="P-0833" lvl="1"><number>&lsqb;0833&rsqb;</number> IP4Addr ip2(mynaddr); </paragraph>
<paragraph id="P-0834" lvl="7"><number>&lsqb;0834&rsqb;</number> This example creates two IP4Addr objects, each of which refer to the IP address 128.32.12.4. Note the use of the htonl( ) ASL function to convert the host 32-bit word into network byte order. </paragraph>
<paragraph id="P-0835" lvl="7"><number>&lsqb;0835&rsqb;</number> 6. IP Masks </paragraph>
<paragraph id="P-0836" lvl="0"><number>&lsqb;0836&rsqb;</number> Masks are often applied to IP addresses in order to determine network or subnet numbers, CIDR blocks, etc. The class IP4Mask is the ASL abstraction for a 32-bit mask, available to be applied to an IPv4 address (or for any other use). </paragraph>
<paragraph id="P-0837" lvl="1"><number>&lsqb;0837&rsqb;</number> Constructor </paragraph>
<paragraph id="P-0838" lvl="7"><number>&lsqb;0838&rsqb;</number> Description </paragraph>
<paragraph id="P-0839" lvl="0"><number>&lsqb;0839&rsqb;</number> Instantiates the IP4Mask object with the mask specified. </paragraph>
<paragraph id="P-0840" lvl="7"><number>&lsqb;0840&rsqb;</number> Syntax </paragraph>
<paragraph id="P-0841" lvl="1"><number>&lsqb;0841&rsqb;</number> IP4Mask(nuint32 mn); </paragraph>
<paragraph id="P-0842" lvl="1"><number>&lsqb;0842&rsqb;</number> IP4Mask(uint32 mh);  
<table-cwu id="TABLE-US-00064">
<number>64</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="119PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry></entry>
<entry>mh</entry>
<entry>uint32</entry>
<entry>32-bit mask in host byte order</entry>
</row>
<row>
<entry></entry>
<entry>mn</entry>
<entry>nuint32</entry>
<entry>32-bit mask in network byte order</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0843" lvl="7"><number>&lsqb;0843&rsqb;</number> Return Value </paragraph>
<paragraph id="P-0844" lvl="7"><number>&lsqb;0844&rsqb;</number> None. </paragraph>
<paragraph id="P-0845" lvl="1"><number>&lsqb;0845&rsqb;</number> leftcontig </paragraph>
<paragraph id="P-0846" lvl="7"><number>&lsqb;0846&rsqb;</number> Description </paragraph>
<paragraph id="P-0847" lvl="0"><number>&lsqb;0847&rsqb;</number> Returns true if all of the 1-bits in the mask are left-contiguous, and returns false otherwise. </paragraph>
<paragraph id="P-0848" lvl="7"><number>&lsqb;0848&rsqb;</number> Syntax </paragraph>
<paragraph id="P-0849" lvl="1"><number>&lsqb;0849&rsqb;</number> bool leftcontig( ); </paragraph>
<paragraph id="P-0850" lvl="7"><number>&lsqb;0850&rsqb;</number> Parameters </paragraph>
<paragraph id="P-0851" lvl="0"><number>&lsqb;0851&rsqb;</number> None. </paragraph>
<paragraph id="P-0852" lvl="7"><number>&lsqb;0852&rsqb;</number> Return Value </paragraph>
<paragraph id="P-0853" lvl="0"><number>&lsqb;0853&rsqb;</number> Returns true if all the 1-bits in the mask are left-contiguous. </paragraph>
<paragraph id="P-0854" lvl="1"><number>&lsqb;0854&rsqb;</number> bits </paragraph>
<paragraph id="P-0855" lvl="7"><number>&lsqb;0855&rsqb;</number> Description </paragraph>
<paragraph id="P-0856" lvl="0"><number>&lsqb;0856&rsqb;</number> The function bits returns the number of left-contiguous 1-bits in the mask (a form of &ldquo;population count&rdquo;). </paragraph>
<paragraph id="P-0857" lvl="7"><number>&lsqb;0857&rsqb;</number> Syntax </paragraph>
<paragraph id="P-0858" lvl="1"><number>&lsqb;0858&rsqb;</number> int bits( ); </paragraph>
<paragraph id="P-0859" lvl="7"><number>&lsqb;0859&rsqb;</number> Parameters </paragraph>
<paragraph id="P-0860" lvl="0"><number>&lsqb;0860&rsqb;</number> None. </paragraph>
<paragraph id="P-0861" lvl="7"><number>&lsqb;0861&rsqb;</number> Return Value </paragraph>
<paragraph id="P-0862" lvl="0"><number>&lsqb;0862&rsqb;</number> Returns the number of left-contiguous bits in the mask. Returns &minus;1 if the l-bits in the mask are not left-contiguous. </paragraph>
</section>
<section>
<heading lvl="1">EXAMPLE </heading>
<paragraph id="P-0863" lvl="0"><number>&lsqb;0863&rsqb;</number>  
<table-cwu id="TABLE-US-00065">
<number>65</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>&num;include NBip.h</entry>
</row>
<row>
<entry>uint32 mymask &equals; 0xffffff80; // 255.255.255.128 or /25</entry>
</row>
<row>
<entry>IP4Mask ipm(mymask);</entry>
</row>
<row>
<entry>int nbits &equals; ipm.bits();</entry>
</row>
<row>
<entry>if (nbits &gt;&equals; 0) &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>sprintf(msgbuf, &Prime;Mask is of the form /%d&Prime;, nbits);</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>&rcub;else &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>sprintf(msgbuf, &Prime;Mask is not left-contiguous &excl;&Prime;);</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>&rcub;</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0864" lvl="7"><number>&lsqb;0864&rsqb;</number> This example creates a subnet mask with 25 bits, and sets up a message buffer containing a string which describes the form of the mask (using the common &ldquo;slash notation&rdquo; for subnet masks). </paragraph>
<paragraph id="P-0865" lvl="7"><number>&lsqb;0865&rsqb;</number> 7. IP Header </paragraph>
<paragraph id="P-0866" lvl="0"><number>&lsqb;0866&rsqb;</number> The IP4Header class defines the standard IP header, where sub-byte sized fields have been merged in order to reduce byte-order dependencies. In addition to the standard IP header, the class includes a number of methods for convenience. The class contains no virtual functions, and therefore pointers to the IP4Header class may be used to point to IP headers received in live network packets. </paragraph>
<paragraph id="P-0867" lvl="0"><number>&lsqb;0867&rsqb;</number> The class contains a number of member functions, some of which provide direct access to the header fields and others which provide computed values based on header fields. Members which return computed values are described individually; those functions which provide only simple access to fields are as follows:  
<table-cwu id="TABLE-US-00066">
<number>66</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="203PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Function</entry>
<entry>Return Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>vhl()</entry>
<entry>nuint8&amp;</entry>
<entry>Returns a reference to the byte containing the IP version and header</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>length</entry>
</row>
<row>
<entry>tos()</entry>
<entry>uint8&amp;</entry>
<entry>Returns a reference to the IP type of service byte</entry>
</row>
<row>
<entry>len()</entry>
<entry>uint16&amp;</entry>
<entry>Returns a reference to the IP datagram (fragment) length in bytes</entry>
</row>
<row>
<entry>id()</entry>
<entry>uint16&amp;</entry>
<entry>Returns a reference to the IP identification field (used for</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>fragmentation)</entry>
</row>
<row>
<entry>offset()</entry>
<entry>uint16&amp;</entry>
<entry>Returns a reference to the word containing fragmentation flags and</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>fragment offset</entry>
</row>
<row>
<entry>ttl()</entry>
<entry>nuint8&amp;</entry>
<entry>Returns a reference to the IP time-to-live byte</entry>
</row>
<row>
<entry>proto()</entry>
<entry>nuint8&amp;</entry>
<entry>Returns a reference to the IP protocol byte</entry>
</row>
<row>
<entry>cksum()</entry>
<entry>nuint16&amp;</entry>
<entry>Returns a reference to the IP checksum</entry>
</row>
<row>
<entry>src()</entry>
<entry>IP4Addr&amp;</entry>
<entry>Returns a reference to the IP source address</entry>
</row>
<row>
<entry>dst()</entry>
<entry>IP4Addr&amp;</entry>
<entry>Returns a reference to the IP destination address</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0868" lvl="7"><number>&lsqb;0868&rsqb;</number> The following member functions of the IP4Header class provide convenient methods for accessing various information about an IP header. </paragraph>
<paragraph id="P-0869" lvl="1"><number>&lsqb;0869&rsqb;</number> optbase </paragraph>
<paragraph id="P-0870" lvl="7"><number>&lsqb;0870&rsqb;</number> Description </paragraph>
<paragraph id="P-0871" lvl="0"><number>&lsqb;0871&rsqb;</number> Returns the location of the first IP option in the IP header (if present). </paragraph>
<paragraph id="P-0872" lvl="7"><number>&lsqb;0872&rsqb;</number> Syntax </paragraph>
<paragraph id="P-0873" lvl="1"><number>&lsqb;0873&rsqb;</number> unsigned char* optbase( ); </paragraph>
<paragraph id="P-0874" lvl="7"><number>&lsqb;0874&rsqb;</number> Parameters </paragraph>
<paragraph id="P-0875" lvl="7"><number>&lsqb;0875&rsqb;</number> None. </paragraph>
<paragraph id="P-0876" lvl="7"><number>&lsqb;0876&rsqb;</number> Return Value </paragraph>
<paragraph id="P-0877" lvl="0"><number>&lsqb;0877&rsqb;</number> Returns the address of the first option present in the header. If no options are present, it returns the address of the first byte of the payload. </paragraph>
<paragraph id="P-0878" lvl="1"><number>&lsqb;0878&rsqb;</number> hl </paragraph>
<paragraph id="P-0879" lvl="7"><number>&lsqb;0879&rsqb;</number> Description </paragraph>
<paragraph id="P-0880" lvl="0"><number>&lsqb;0880&rsqb;</number> The first form of this function returns the number of 32-bit words in the IP header. The second form modifies the header length field to be equal to the specified length </paragraph>
<paragraph id="P-0881" lvl="7"><number>&lsqb;0881&rsqb;</number> Syntax </paragraph>
<paragraph id="P-0882" lvl="1"><number>&lsqb;0882&rsqb;</number> int hl( ); </paragraph>
<paragraph id="P-0883" lvl="1"><number>&lsqb;0883&rsqb;</number> void hl(int h);  
<table-cwu id="TABLE-US-00067">
<number>67</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="266PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="21PT" align="left"/>
<colspec colname="3" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>h</entry>
<entry>int</entry>
<entry>Specifies the header length (in 32-bit words) to assign to the IP header</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0884" lvl="7"><number>&lsqb;0884&rsqb;</number> Return Value </paragraph>
<paragraph id="P-0885" lvl="0"><number>&lsqb;0885&rsqb;</number> The first form of this function returns the number of 32-bit words in the IP header. </paragraph>
<paragraph id="P-0886" lvl="1"><number>&lsqb;0886&rsqb;</number> hlen </paragraph>
<paragraph id="P-0887" lvl="7"><number>&lsqb;0887&rsqb;</number> Description </paragraph>
<paragraph id="P-0888" lvl="0"><number>&lsqb;0888&rsqb;</number> The function hlen returns the number of bytes in the IP header (including options). </paragraph>
<paragraph id="P-0889" lvl="7"><number>&lsqb;0889&rsqb;</number> Syntax </paragraph>
<paragraph id="P-0890" lvl="1"><number>&lsqb;0890&rsqb;</number> int hlen( ); </paragraph>
<paragraph id="P-0891" lvl="7"><number>&lsqb;0891&rsqb;</number> Parameters </paragraph>
<paragraph id="P-0892" lvl="0"><number>&lsqb;0892&rsqb;</number> None. </paragraph>
<paragraph id="P-0893" lvl="7"><number>&lsqb;0893&rsqb;</number> Return Value </paragraph>
<paragraph id="P-0894" lvl="0"><number>&lsqb;0894&rsqb;</number> Returns the number of bytes in the IP header including options. </paragraph>
<paragraph id="P-0895" lvl="1"><number>&lsqb;0895&rsqb;</number> ver </paragraph>
<paragraph id="P-0896" lvl="7"><number>&lsqb;0896&rsqb;</number> Description </paragraph>
<paragraph id="P-0897" lvl="0"><number>&lsqb;0897&rsqb;</number> The first form of this function ver returns the version field of the IP header (should be 4). </paragraph>
<paragraph id="P-0898" lvl="0"><number>&lsqb;0898&rsqb;</number> The second form assigns the version number to the IP header. </paragraph>
<paragraph id="P-0899" lvl="7"><number>&lsqb;0899&rsqb;</number> Syntax </paragraph>
<paragraph id="P-0900" lvl="1"><number>&lsqb;0900&rsqb;</number> int ver( ); </paragraph>
<paragraph id="P-0901" lvl="1"><number>&lsqb;0901&rsqb;</number> void ver(int v);  
<table-cwu id="TABLE-US-00068">
<number>68</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="196PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry></entry>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="35PT" align="left"/>
<colspec colname="3" colwidth="112PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry></entry>
<entry>v</entry>
<entry>int</entry>
<entry>Specifies the version number.</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0902" lvl="7"><number>&lsqb;0902&rsqb;</number> Return Value </paragraph>
<paragraph id="P-0903" lvl="0"><number>&lsqb;0903&rsqb;</number> The first form returns the version field of the IP header </paragraph>
<paragraph id="P-0904" lvl="1"><number>&lsqb;0904&rsqb;</number> payload </paragraph>
<paragraph id="P-0905" lvl="7"><number>&lsqb;0905&rsqb;</number> Description </paragraph>
<paragraph id="P-0906" lvl="0"><number>&lsqb;0906&rsqb;</number> The function payload returns the address of the first byte of data (beyond any options present). </paragraph>
<paragraph id="P-0907" lvl="7"><number>&lsqb;0907&rsqb;</number> Syntax </paragraph>
<paragraph id="P-0908" lvl="1"><number>&lsqb;0908&rsqb;</number> unsigned char* payload( ); </paragraph>
<paragraph id="P-0909" lvl="7"><number>&lsqb;0909&rsqb;</number> Parameters </paragraph>
<paragraph id="P-0910" lvl="0"><number>&lsqb;0910&rsqb;</number> None. </paragraph>
<paragraph id="P-0911" lvl="7"><number>&lsqb;0911&rsqb;</number> Return Value </paragraph>
<paragraph id="P-0912" lvl="0"><number>&lsqb;0912&rsqb;</number> Returns the address of the first byte of payload data in the IP packet. </paragraph>
<paragraph id="P-0913" lvl="1"><number>&lsqb;0913&rsqb;</number> psum </paragraph>
<paragraph id="P-0914" lvl="7"><number>&lsqb;0914&rsqb;</number> Description </paragraph>
<paragraph id="P-0915" lvl="0"><number>&lsqb;0915&rsqb;</number> The function psum is used internally by the ASL library, but may be useful to some applications. It returns the 16-bit one&apos;s complement sum of the source and destination IP addresses plus 8-bit protocol field &lsqb;in the low-order byte&rsqb;. It is useful in computing pseudo-header checksums for UDP and TCP. </paragraph>
<paragraph id="P-0916" lvl="7"><number>&lsqb;0916&rsqb;</number> Syntax </paragraph>
<paragraph id="P-0917" lvl="1"><number>&lsqb;0917&rsqb;</number> uint32 psum( ); </paragraph>
<paragraph id="P-0918" lvl="7"><number>&lsqb;0918&rsqb;</number> Parameters </paragraph>
<paragraph id="P-0919" lvl="0"><number>&lsqb;0919&rsqb;</number> None. </paragraph>
<paragraph id="P-0920" lvl="7"><number>&lsqb;0920&rsqb;</number> Return Value </paragraph>
<paragraph id="P-0921" lvl="0"><number>&lsqb;0921&rsqb;</number> Returns the 16-bit one&apos;s complement sum of the source and destination IP addresses plus the 8-bit protocol field. </paragraph>
<paragraph id="P-0922" lvl="7"><number>&lsqb;0922&rsqb;</number> Definitions </paragraph>
<paragraph id="P-0923" lvl="0"><number>&lsqb;0923&rsqb;</number> In addition to the IP header itself, a number of definitions are provided for manipulating fields of the IP header with specific semantic meanings  
<table-cwu id="TABLE-US-00069">
<number>69</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="266PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Fragmentation</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="35PT" align="left"/>
<colspec colname="3" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry>Define</entry>
<entry>Value</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>IP_DF</entry>
<entry>0 &times; 4000</entry>
<entry>Don&apos;t fragment flag, RFC 791, p. 13.</entry>
</row>
<row>
<entry>IP_MF</entry>
<entry>0 &times; 2000</entry>
<entry>More fragments flag, RFC 791, p. 13.</entry>
</row>
<row>
<entry>IP_OFFMASK</entry>
<entry>0 &times; 1FFF</entry>
<entry>Mask for determining the fragment offset from the IP header</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>offset() function.</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0924" lvl="0"><number>&lsqb;0924&rsqb;</number>  
<table-cwu id="TABLE-US-00070">
<number>70</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<thead>
<row>
<entry></entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
<entry>Limitations</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="70PT" align="left"/>
<colspec colname="2" colwidth="35PT" align="left"/>
<colspec colname="3" colwidth="98PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>IP_MAXPACKET</entry>
<entry>65535</entry>
<entry>Maximum IP datagram size.</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0925" lvl="7"><number>&lsqb;0925&rsqb;</number> IP Service Type </paragraph>
<paragraph id="P-0926" lvl="0"><number>&lsqb;0926&rsqb;</number> The following table contains the definitions for IP type of service byte (not commonly used):  
<table-cwu id="TABLE-US-00071">
<number>71</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="91PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="70PT" align="left"/>
<thead>
<row>
<entry></entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry></entry>
<entry>Define</entry>
<entry>Value</entry>
<entry>Reference</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
<entry>IPTOS_LOWDELAY</entry>
<entry>0 &times; 10</entry>
<entry>RFC 791, p. 12.</entry>
</row>
<row>
<entry></entry>
<entry>IPTOS_THROUGHPUT</entry>
<entry>0 &times; 08</entry>
<entry>RFC 791, p. 12.</entry>
</row>
<row>
<entry></entry>
<entry>IPTOS_RELIABILITY</entry>
<entry>0 &times; 04</entry>
<entry>RFC 791, p. 12.</entry>
</row>
<row>
<entry></entry>
<entry>IPTOS_MINCOST</entry>
<entry>0 &times; 02</entry>
<entry>RFC 1349.</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0927" lvl="7"><number>&lsqb;0927&rsqb;</number> IP Precedence </paragraph>
<paragraph id="P-0928" lvl="0"><number>&lsqb;0928&rsqb;</number> The following table contains the definitions for IP precedence. All are from RFC 791, p. 12 (not widely used).  
<table-cwu id="TABLE-US-00072">
<number>72</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="147PT" align="left"/>
<colspec colname="2" colwidth="49PT" align="left"/>
<thead>
<row>
<entry></entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
<row>
<entry></entry>
<entry>Define</entry>
<entry>Value</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
<entry>IPTOS_PREC_NETCONTROL</entry>
<entry>0 &times; E0</entry>
</row>
<row>
<entry></entry>
<entry>IPTOS_PREC_INTERNETCONTROL</entry>
<entry>0 &times; C0</entry>
</row>
<row>
<entry></entry>
<entry>IPTOS_PREC_CRITIC_ECP</entry>
<entry>0 &times; A0</entry>
</row>
<row>
<entry></entry>
<entry>IPTOS_PREC_FLASHOVERRIDE</entry>
<entry>0 &times; 80</entry>
</row>
<row>
<entry></entry>
<entry>IPTOS_PREC_FLASH</entry>
<entry>0 &times; 60</entry>
</row>
<row>
<entry></entry>
<entry>IPTOS_PREC_IMMEDIATE</entry>
<entry>0 &times; 40</entry>
</row>
<row>
<entry></entry>
<entry>IPTOS_PREC_PRIORITY</entry>
<entry>0 &times; 20</entry>
</row>
<row>
<entry></entry>
<entry>IPTOS_PREC_ROUTINE</entry>
<entry>0 &times; 00</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0929" lvl="7"><number>&lsqb;0929&rsqb;</number> Option Definitions </paragraph>
<paragraph id="P-0930" lvl="0"><number>&lsqb;0930&rsqb;</number> The following table contains the definitions for supporting IP options. All definitions are from RFC 791, pp. 15-23.  
<table-cwu id="TABLE-US-00073">
<number>73</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="70PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="154PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Define</entry>
<entry>Value</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>IPOPT_COPIED(o)</entry>
<entry>((o)&amp;0 &times; 80)</entry>
<entry>A macro which returns true if the option &apos;o&apos; is to be</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>copied upon fragmentation.</entry>
</row>
<row>
<entry>IPOPT_CLASS(o)</entry>
<entry>((o)&amp;0 &times; 60)</entry>
<entry>A macro giving the option class for the option &apos;o&apos;</entry>
</row>
<row>
<entry>IPOPT_NUMBER(o)</entry>
<entry>((o)&amp;0 &times; 1F)</entry>
<entry>A macro giving the option number for the option &apos;o&apos;</entry>
</row>
<row>
<entry>IPOPT_CONTROL</entry>
<entry>0 &times; 00</entry>
<entry>Control class</entry>
</row>
<row>
<entry>IPOPT_RESERVED1</entry>
<entry>0 &times; 20</entry>
<entry>Reserved</entry>
</row>
<row>
<entry>IPOPT_DEBMEAS</entry>
<entry>0 &times; 40</entry>
<entry>Debugging and/or measurement class</entry>
</row>
<row>
<entry>IPOPT_RESERVED2</entry>
<entry>0 &times; 60</entry>
<entry>Reserved</entry>
</row>
<row>
<entry>IPOPT_EOL</entry>
<entry>&emsp;0</entry>
<entry>End of option list.</entry>
</row>
<row>
<entry>IPOPT_NOP</entry>
<entry>&emsp;1</entry>
<entry>No operation.</entry>
</row>
<row>
<entry>IPOPT_RR</entry>
<entry>&emsp;7</entry>
<entry>Record packet route:</entry>
</row>
<row>
<entry>IPOPT_TS</entry>
<entry>&ensp;68</entry>
<entry>Time stamp.</entry>
</row>
<row>
<entry>IPOPT_SECURITY</entry>
<entry>130</entry>
<entry>Provide s, c, h, tcc.</entry>
</row>
<row>
<entry>IPOPT_LSRR</entry>
<entry>131</entry>
<entry>Loose source route.</entry>
</row>
<row>
<entry>IPOPT_SATID</entry>
<entry>136</entry>
<entry>Satnet ID.</entry>
</row>
<row>
<entry>IPOPT_SSRR</entry>
<entry>137</entry>
<entry>Strict source route.</entry>
</row>
<row>
<entry>IPOPT_RA</entry>
<entry>148</entry>
<entry>Router alert.</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0931" lvl="7"><number>&lsqb;0931&rsqb;</number> Options Field Offsets </paragraph>
<paragraph id="P-0932" lvl="0"><number>&lsqb;0932&rsqb;</number> The following table contains the offsets to fields in options other than EOL and NOP.  
<table-cwu id="TABLE-US-00074">
<number>74</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="77PT" align="left"/>
<colspec colname="2" colwidth="35PT" align="left"/>
<colspec colname="3" colwidth="91PT" align="left"/>
<thead>
<row>
<entry></entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry></entry>
<entry>Define</entry>
<entry>Value</entry>
<entry>Description</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
<entry>IPOPT_OPTVAL</entry>
<entry>0</entry>
<entry>Option ID.</entry>
</row>
<row>
<entry></entry>
<entry>IPOPT_OLEN</entry>
<entry>1</entry>
<entry>Option length.</entry>
</row>
<row>
<entry></entry>
<entry>IPOPT_OFFSET</entry>
<entry>2</entry>
<entry>Offset within option.</entry>
</row>
<row>
<entry></entry>
<entry>IPOPT_MINOFF</entry>
<entry>4</entry>
<entry>Minimum value of offset.</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0933" lvl="7"><number>&lsqb;0933&rsqb;</number> 7. Fragments and Datagrams </paragraph>
<paragraph id="P-0934" lvl="0"><number>&lsqb;0934&rsqb;</number> The IP protocol performs adaptation of its datagram size by an operation known as fragmentation. Fragmentation allows for an initial (large) IP datagram to be broken into a sequence of IP fragments, each of which is treated as an independent packet until they are received and reassembled at the original datagram&apos;s ultimate destination. Conventional IP routers never reassemble fragments but instead route them independently, leaving the destination host to reassemble them. In some circumstances, however, applications running on the NetBoost platform may wish to reassemble fragments themselves (e.g. to simulate the operation of the destination host). </paragraph>
<paragraph id="P-0935" lvl="7"><number>&lsqb;0935&rsqb;</number> 8. IP Fragment class </paragraph>
<paragraph id="P-0936" lvl="0"><number>&lsqb;0936&rsqb;</number> Within the ASL, a fragment represents a single IP packet (containing an IP header), which may or not be a complete IP layer datagram. In addition, a datagram within the ASL represents a collection of fragments. A datagram (or fragment) is said to be complete if it represents or contains all the fragments necessary to represent an entire IP-layer datagram. </paragraph>
<paragraph id="P-0937" lvl="0"><number>&lsqb;0937&rsqb;</number> The IP4 Fragment class is defined as follows. </paragraph>
<paragraph id="P-0938" lvl="1"><number>&lsqb;0938&rsqb;</number> Constructors </paragraph>
<paragraph id="P-0939" lvl="7"><number>&lsqb;0939&rsqb;</number> Description </paragraph>
<paragraph id="P-0940" lvl="0"><number>&lsqb;0940&rsqb;</number> The IP4 Fragment class provides the abstraction of a single IP packet placed in an ASL buffer (see the description of the Buffer elsewhere in this chapter). It has two constructors intended for use by applications. </paragraph>
<paragraph id="P-0941" lvl="2"><number>&lsqb;0941&rsqb;</number> The first of these allows for specifying the buffer containing an IP fragment as the parameter bp. The location of the of the IP header within the buffer is the second argument. This is the most commonly-used constructor when processing IP fragments in ACE action code. </paragraph>
<paragraph id="P-0942" lvl="2"><number>&lsqb;0942&rsqb;</number> The second form of the constructor performs the same steps as the first form, but also allocates a new Buffer object and copies the IP header pointed to by iph into the new buffer (if specified). This form of the constructor is primarily intended for creation of IP fragments during IP datagram fragmentation. If the specified header contains IP options, only those options which are copied during fragmentation are copied. </paragraph>
<paragraph id="P-0943" lvl="7"><number>&lsqb;0943&rsqb;</number> Syntax </paragraph>
<paragraph id="P-0944" lvl="1"><number>&lsqb;0944&rsqb;</number> IP4Fragment(Buffer* bp, IP4Header* iph); </paragraph>
<paragraph id="P-0945" lvl="1"><number>&lsqb;0945&rsqb;</number> IP4Fragment(int maxiplen, IP4Header* protohdr&equals;0);  
<table-cwu id="TABLE-US-00075">
<number>75</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="273PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="196PT" align="left"/>
<tbody valign="top">
<row>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>bp</entry>
<entry>Buffer*</entry>
<entry>The starting address of the buffer containing the IP fragment</entry>
</row>
<row>
<entry>maxiplen</entry>
<entry>int</entry>
<entry>The maximum size of the fragment being created; used to size the</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>allocated Buffer.</entry>
</row>
<row>
<entry>protohdr</entry>
<entry>IP4Header*</entry>
<entry>The IP4 header to copy into the buffer, if provided. If the header</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>contains IP options, only those options normally copied during</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>fragmentation are copied.</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0946" lvl="7"><number>&lsqb;0946&rsqb;</number> Return Value </paragraph>
<paragraph id="P-0947" lvl="0"><number>&lsqb;0947&rsqb;</number> None. </paragraph>
<paragraph id="P-0948" lvl="1"><number>&lsqb;0948&rsqb;</number> Destructor </paragraph>
<paragraph id="P-0949" lvl="7"><number>&lsqb;0949&rsqb;</number> Description </paragraph>
<paragraph id="P-0950" lvl="0"><number>&lsqb;0950&rsqb;</number> Frees the fragment. </paragraph>
<paragraph id="P-0951" lvl="7"><number>&lsqb;0951&rsqb;</number> Syntax </paragraph>
<paragraph id="P-0952" lvl="1"><number>&lsqb;0952&rsqb;</number> &tilde;IP4Fragment( ); </paragraph>
<paragraph id="P-0953" lvl="7"><number>&lsqb;0953&rsqb;</number> Parameters </paragraph>
<paragraph id="P-0954" lvl="7"><number>&lsqb;0954&rsqb;</number> None. </paragraph>
<paragraph id="P-0955" lvl="7"><number>&lsqb;0955&rsqb;</number> Return Value </paragraph>
<paragraph id="P-0956" lvl="7"><number>&lsqb;0956&rsqb;</number> None. </paragraph>
<paragraph id="P-0957" lvl="1"><number>&lsqb;0957&rsqb;</number> hdr </paragraph>
<paragraph id="P-0958" lvl="7"><number>&lsqb;0958&rsqb;</number> Description </paragraph>
<paragraph id="P-0959" lvl="0"><number>&lsqb;0959&rsqb;</number> The function hdr returns the address of the IP header of the fragment. </paragraph>
<paragraph id="P-0960" lvl="7"><number>&lsqb;0960&rsqb;</number> Syntax </paragraph>
<paragraph id="P-0961" lvl="1"><number>&lsqb;0961&rsqb;</number> IP4Header* hdr( ); </paragraph>
<paragraph id="P-0962" lvl="7"><number>&lsqb;0962&rsqb;</number> Parameters </paragraph>
<paragraph id="P-0963" lvl="0"><number>&lsqb;0963&rsqb;</number> None. </paragraph>
<paragraph id="P-0964" lvl="7"><number>&lsqb;0964&rsqb;</number> Return Value </paragraph>
<paragraph id="P-0965" lvl="0"><number>&lsqb;0965&rsqb;</number> Returns the address of the IP4Header class at the beginning of the fragment. </paragraph>
<paragraph id="P-0966" lvl="1"><number>&lsqb;0966&rsqb;</number> payload </paragraph>
<paragraph id="P-0967" lvl="7"><number>&lsqb;0967&rsqb;</number> Description </paragraph>
<paragraph id="P-0968" lvl="0"><number>&lsqb;0968&rsqb;</number> The function payload returns the address of the first byte of data in the IP fragment (after the basic header and options). </paragraph>
<paragraph id="P-0969" lvl="7"><number>&lsqb;0969&rsqb;</number> Syntax </paragraph>
<paragraph id="P-0970" lvl="1"><number>&lsqb;0970&rsqb;</number> u_char* payload( ); </paragraph>
<paragraph id="P-0971" lvl="7"><number>&lsqb;0971&rsqb;</number> Parameters </paragraph>
<paragraph id="P-0972" lvl="0"><number>&lsqb;0972&rsqb;</number> None. </paragraph>
<paragraph id="P-0973" lvl="7"><number>&lsqb;0973&rsqb;</number> Return Value </paragraph>
<paragraph id="P-0974" lvl="0"><number>&lsqb;0974&rsqb;</number> Returns the address of the first byte of data in the IP fragment. </paragraph>
<paragraph id="P-0975" lvl="1"><number>&lsqb;0975&rsqb;</number> buf </paragraph>
<paragraph id="P-0976" lvl="7"><number>&lsqb;0976&rsqb;</number> Description </paragraph>
<paragraph id="P-0977" lvl="0"><number>&lsqb;0977&rsqb;</number> The function buf returns the address of the Buffer structure containing the IP fragment. </paragraph>
<paragraph id="P-0978" lvl="7"><number>&lsqb;0978&rsqb;</number> Syntax </paragraph>
<paragraph id="P-0979" lvl="1"><number>&lsqb;0979&rsqb;</number> Buffer* buf( ); </paragraph>
<paragraph id="P-0980" lvl="7"><number>&lsqb;0980&rsqb;</number> Parameters </paragraph>
<paragraph id="P-0981" lvl="0"><number>&lsqb;0981&rsqb;</number> None. </paragraph>
<paragraph id="P-0982" lvl="7"><number>&lsqb;0982&rsqb;</number> Return Value </paragraph>
<paragraph id="P-0983" lvl="0"><number>&lsqb;0983&rsqb;</number> Returns the address of the Buffer structure containing the IP fragment. This may return NULL if there is no buffer associated with the fragment. </paragraph>
<paragraph id="P-0984" lvl="1"><number>&lsqb;0984&rsqb;</number> next </paragraph>
<paragraph id="P-0985" lvl="7"><number>&lsqb;0985&rsqb;</number> Description </paragraph>
<paragraph id="P-0986" lvl="0"><number>&lsqb;0986&rsqb;</number> Returns a reference to the pointer pointing to the next fragment of a doubly-linked list of fragments. This is used to link together fragments when they are reassembled (in Datagrams), or queued, etc. Typically, fragments are linked together in a doubly-linked list fashion with NULL pointers indicating the list endpoints. </paragraph>
<paragraph id="P-0987" lvl="7"><number>&lsqb;0987&rsqb;</number> Syntax </paragraph>
<paragraph id="P-0988" lvl="1"><number>&lsqb;0988&rsqb;</number> IP4Fragment*&amp; next( ); </paragraph>
<paragraph id="P-0989" lvl="7"><number>&lsqb;0989&rsqb;</number> Parameters </paragraph>
<paragraph id="P-0990" lvl="0"><number>&lsqb;0990&rsqb;</number> None. </paragraph>
<paragraph id="P-0991" lvl="7"><number>&lsqb;0991&rsqb;</number> Return Value </paragraph>
<paragraph id="P-0992" lvl="0"><number>&lsqb;0992&rsqb;</number> Returns a reference to the internal linked-list pointer </paragraph>
<paragraph id="P-0993" lvl="1"><number>&lsqb;0993&rsqb;</number> prev </paragraph>
<paragraph id="P-0994" lvl="7"><number>&lsqb;0994&rsqb;</number> Description </paragraph>
<paragraph id="P-0995" lvl="0"><number>&lsqb;0995&rsqb;</number> Like next, but returns a reference to pointer to the previous fragment on the list. </paragraph>
<paragraph id="P-0996" lvl="7"><number>&lsqb;0996&rsqb;</number> Syntax </paragraph>
<paragraph id="P-0997" lvl="1"><number>&lsqb;0997&rsqb;</number> IP4Fragment*&amp; prev( ); </paragraph>
<paragraph id="P-0998" lvl="7"><number>&lsqb;0998&rsqb;</number> Parameters </paragraph>
<paragraph id="P-0999" lvl="0"><number>&lsqb;0999&rsqb;</number> None. </paragraph>
<paragraph id="P-1000" lvl="7"><number>&lsqb;1000&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1001" lvl="0"><number>&lsqb;1001&rsqb;</number> Returns a reference to the internal linked-list pointer. </paragraph>
<paragraph id="P-1002" lvl="1"><number>&lsqb;1002&rsqb;</number> first </paragraph>
<paragraph id="P-1003" lvl="7"><number>&lsqb;1003&rsqb;</number> Description </paragraph>
<paragraph id="P-1004" lvl="0"><number>&lsqb;1004&rsqb;</number> The function first returns true when the fragment represents the first fragment of a datagram. </paragraph>
<paragraph id="P-1005" lvl="7"><number>&lsqb;1005&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1006" lvl="1"><number>&lsqb;1006&rsqb;</number> bool first( ); </paragraph>
<paragraph id="P-1007" lvl="7"><number>&lsqb;1007&rsqb;</number> Parameters </paragraph>
<paragraph id="P-1008" lvl="0"><number>&lsqb;1008&rsqb;</number> None. </paragraph>
<paragraph id="P-1009" lvl="7"><number>&lsqb;1009&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1010" lvl="0"><number>&lsqb;1010&rsqb;</number> Returns true when the fragment represents the first fragment of a datagram. </paragraph>
<paragraph id="P-1011" lvl="1"><number>&lsqb;1011&rsqb;</number> fragment </paragraph>
<paragraph id="P-1012" lvl="7"><number>&lsqb;1012&rsqb;</number> Description </paragraph>
<paragraph id="P-1013" lvl="0"><number>&lsqb;1013&rsqb;</number> Fragments an IP datagram comprising a single fragment. The fragment( ) function allocates Buffer structures to hold the newly-formed IP fragments and links them together. It returns the head of the doubly-linked list of fragments. Each fragment in the list will be limited in size to at most the specified MTU size The original fragment is unaffected. </paragraph>
<paragraph id="P-1014" lvl="7"><number>&lsqb;1014&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1015" lvl="1"><number>&lsqb;1015&rsqb;</number> IP4Datagram* fragment(int mtu);  
<table-cwu id="TABLE-US-00076">
<number>76</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="252PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="21PT" align="left"/>
<colspec colname="3" colwidth="196PT" align="left"/>
<tbody valign="top">
<row>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>mtu</entry>
<entry>int</entry>
<entry>The maximum transmission unit MTU size limiting the maximum</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>fragment size</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1016" lvl="0"><number>&lsqb;1016&rsqb;</number> Returns a pointer to an IP4Datagram object containing a doubly-linked list of IP4Fragment objects Each fragment object is contained within a Buffer class allocated by the ASL library. The original fragment object (the one fragmented) is not freed by this function. The caller must free the original fragment when it is no longer needed. </paragraph>
<paragraph id="P-1017" lvl="1"><number>&lsqb;1017&rsqb;</number> complete </paragraph>
<paragraph id="P-1018" lvl="7"><number>&lsqb;1018&rsqb;</number> Description </paragraph>
<paragraph id="P-1019" lvl="0"><number>&lsqb;1019&rsqb;</number> The function complete returns true when the fragment represents a complete IP datagram. </paragraph>
<paragraph id="P-1020" lvl="7"><number>&lsqb;1020&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1021" lvl="1"><number>&lsqb;1021&rsqb;</number> bool complete( ); </paragraph>
<paragraph id="P-1022" lvl="7"><number>&lsqb;1022&rsqb;</number> Parameters </paragraph>
<paragraph id="P-1023" lvl="0"><number>&lsqb;1023&rsqb;</number> None. </paragraph>
<paragraph id="P-1024" lvl="7"><number>&lsqb;1024&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1025" lvl="0"><number>&lsqb;1025&rsqb;</number> Returns true when the fragment represents a complete IP datagram (that is, when the fragment offset field is zero and there are no additional fragments). </paragraph>
<paragraph id="P-1026" lvl="1"><number>&lsqb;1026&rsqb;</number> optcopy </paragraph>
<paragraph id="P-1027" lvl="7"><number>&lsqb;1027&rsqb;</number> Description </paragraph>
<paragraph id="P-1028" lvl="7"><number>&lsqb;1028&rsqb;</number> The static method opt copy is used to copy options from one header to another during IP fragmentation. The function will only copy those options that are supposed to be copied during fragmentation (i.e. for those options x where the macro IPOPT_COPIED(x) is non zero (true)). </paragraph>
<paragraph id="P-1029" lvl="7"><number>&lsqb;1029&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1030" lvl="1"><number>&lsqb;1030&rsqb;</number> static int optcopy(IP4Header* src, IP4Header* dst);  
<table-cwu id="TABLE-US-00077">
<number>77</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="287PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>src</entry>
<entry>IP4Header *</entry>
<entry>Pointer to the source IP header containing options</entry>
</row>
<row>
<entry>dst</entry>
<entry>IP4Header *</entry>
<entry>Pointer to the destination, where the source header should be copied to</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1031" lvl="7"><number>&lsqb;1031&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1032" lvl="7"><number>&lsqb;1032&rsqb;</number> Returns the number of bytes of options present in the destination IP header. </paragraph>
<paragraph id="P-1033" lvl="7"><number>&lsqb;1033&rsqb;</number> 9. IP Datagram Class </paragraph>
<paragraph id="P-1034" lvl="0"><number>&lsqb;1034&rsqb;</number> The class IP4Datagram represents a collection of P fragments, which may (or may not) represent a complete IP4 datagram. Note that objects of the class IP4Datagram include a doubly-linked list of IP4Fragment objects in sorted order (sorted by IP offset). When IP fragments are inserted into a datagram (in order to perform reassembly), coalescing of data between fragments is not performed automatically. Thus, although the IP4Datagram object may easily determine whether it contains a complete set of fragments, it does not automatically reconstruct a contiguous buffer of the original datagram&apos;s contents for the caller. </paragraph>
<paragraph id="P-1035" lvl="0"><number>&lsqb;1035&rsqb;</number> This class supports the fragmentation, reassembly, and grouping of IP fragments. The IP4Datagram class is defined as follows: </paragraph>
<paragraph id="P-1036" lvl="1"><number>&lsqb;1036&rsqb;</number> Constructors </paragraph>
<paragraph id="P-1037" lvl="7"><number>&lsqb;1037&rsqb;</number> Description </paragraph>
<paragraph id="P-1038" lvl="0"><number>&lsqb;1038&rsqb;</number> The class has two constructors. </paragraph>
<paragraph id="P-1039" lvl="2"><number>&lsqb;1039&rsqb;</number> The first form of the constructor is used when creating a fresh datagram (typically for starting the process of reassembly). </paragraph>
<paragraph id="P-1040" lvl="2"><number>&lsqb;1040&rsqb;</number> The second form is useful when an existing list of fragments are to be placed into the datagram immediately at its creation. </paragraph>
<paragraph id="P-1041" lvl="7"><number>&lsqb;1041&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1042" lvl="1"><number>&lsqb;1042&rsqb;</number> IP4Datagram( ); </paragraph>
<paragraph id="P-1043" lvl="1"><number>&lsqb;1043&rsqb;</number> IP4Datagram(IP4Fragment* frag);  
<table-cwu id="TABLE-US-00078">
<number>78</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="266PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="49PT" align="left"/>
<colspec colname="3" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>frag</entry>
<entry>IP4Fragment *</entry>
<entry>Pointer to a doubly linked list of fragments used to create the</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>datagram object</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1044" lvl="7"><number>&lsqb;1044&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1045" lvl="0"><number>&lsqb;1045&rsqb;</number> None. </paragraph>
<paragraph id="P-1046" lvl="1"><number>&lsqb;1046&rsqb;</number> Destructor </paragraph>
<paragraph id="P-1047" lvl="7"><number>&lsqb;1047&rsqb;</number> Description </paragraph>
<paragraph id="P-1048" lvl="0"><number>&lsqb;1048&rsqb;</number> The destructor calls the destructors for each of the fragments comprising the datagram and frees the datagram object. </paragraph>
<paragraph id="P-1049" lvl="1"><number>&lsqb;1049&rsqb;</number> len </paragraph>
<paragraph id="P-1050" lvl="7"><number>&lsqb;1050&rsqb;</number> Description </paragraph>
<paragraph id="P-1051" lvl="0"><number>&lsqb;1051&rsqb;</number> The len function returns the entire length (in bytes) of the datagram, including all of its comprising fragments. Its value is only meaningful if the datagram is complete. </paragraph>
<paragraph id="P-1052" lvl="7"><number>&lsqb;1052&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1053" lvl="1"><number>&lsqb;1053&rsqb;</number> int len( ); </paragraph>
<paragraph id="P-1054" lvl="7"><number>&lsqb;1054&rsqb;</number> Parameters </paragraph>
<paragraph id="P-1055" lvl="0"><number>&lsqb;1055&rsqb;</number> None. </paragraph>
<paragraph id="P-1056" lvl="7"><number>&lsqb;1056&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1057" lvl="0"><number>&lsqb;1057&rsqb;</number> Returns the length of the entire datagram (in bytes). If the datagram contains multiple fragments, only the size of the first fragment header is included in this value. </paragraph>
<paragraph id="P-1058" lvl="1"><number>&lsqb;1058&rsqb;</number> fragment </paragraph>
<paragraph id="P-1059" lvl="7"><number>&lsqb;1059&rsqb;</number> Description </paragraph>
<paragraph id="P-1060" lvl="0"><number>&lsqb;1060&rsqb;</number> The fragment function breaks an IP datagram into a series of IP fragments, each of which will fit in the packet size specified by mtu. Its behavior is equivalent to the </paragraph>
<paragraph id="P-1061" lvl="1"><number>&lsqb;1061&rsqb;</number> IP4 Fragment: fragment (int mtu) function described previously. </paragraph>
<paragraph id="P-1062" lvl="7"><number>&lsqb;1062&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1063" lvl="1"><number>&lsqb;1063&rsqb;</number> IP4Datagram* fragment(int mtu); </paragraph>
<paragraph id="P-1064" lvl="7"><number>&lsqb;1064&rsqb;</number> Parameters </paragraph>
<paragraph id="P-1065" lvl="1"><number>&lsqb;1065&rsqb;</number> See IP4Fragment: fragment (int mtu) above. </paragraph>
<paragraph id="P-1066" lvl="7"><number>&lsqb;1066&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1067" lvl="0"><number>&lsqb;1067&rsqb;</number> See IP4Fragment: fragment (int mtu) above. </paragraph>
<paragraph id="P-1068" lvl="1"><number>&lsqb;1068&rsqb;</number> insert </paragraph>
<paragraph id="P-1069" lvl="7"><number>&lsqb;1069&rsqb;</number> Description </paragraph>
<paragraph id="P-1070" lvl="0"><number>&lsqb;1070&rsqb;</number> The function insert inserts a fragment into the datagram. The function attempts to reassemble the overall datagram by checking the IP offset and ID fields. </paragraph>
<paragraph id="P-1071" lvl="7"><number>&lsqb;1071&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1072" lvl="1"><number>&lsqb;1072&rsqb;</number> int insert(IP4Fragment* frag);  
<table-cwu id="TABLE-US-00079">
<number>79</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="49PT" align="left"/>
<colspec colname="3" colwidth="126PT" align="left"/>
<tbody valign="top">
<row>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>frag</entry>
<entry>IP4Fragment *</entry>
<entry>Pointer to the fragment being inserted.</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1073" lvl="7"><number>&lsqb;1073&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1074" lvl="0"><number>&lsqb;1074&rsqb;</number> Because this function can fail/act in a large number of ways, the following definitions are provided to indicate the results of insertions that were attempted by the caller. The return value is a 32-bit word where each bit indicates a different error or unusual condition. The first definition below, IPD_INSERT_ERROR is set whenever any of the other conditions are encountered. This is an extensible list which may evolve to indicate new error conditions in future releases:  
<table-cwu id="TABLE-US-00080">
<number>80</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="98PT" align="left"/>
<colspec colname="2" colwidth="119PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Define</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>IPD_INSERT_ERROR</entry>
<entry>&lsquo;Or&rsquo; of all other error bits.</entry>
</row>
<row>
<entry>IPD_INSERT_OH</entry>
<entry>Head overlapped.</entry>
</row>
<row>
<entry>IPD_INSERT_OT</entry>
<entry>Tail overlapped.</entry>
</row>
<row>
<entry>IPD_INSERT_MISMATCH</entry>
<entry>Payload mismatch.</entry>
</row>
<row>
<entry>IPD_INSERT_CKFAIL</entry>
<entry>IP header checksum failed (if enabled)</entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1075" lvl="1"><number>&lsqb;1075&rsqb;</number> nfrags </paragraph>
<paragraph id="P-1076" lvl="7"><number>&lsqb;1076&rsqb;</number> Description </paragraph>
<paragraph id="P-1077" lvl="0"><number>&lsqb;1077&rsqb;</number> The function nfrags returns the number of fragments currently present in the datagram. </paragraph>
<paragraph id="P-1078" lvl="7"><number>&lsqb;1078&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1079" lvl="1"><number>&lsqb;1079&rsqb;</number> int nfrags( ); </paragraph>
<paragraph id="P-1080" lvl="1"><number>&lsqb;1080&rsqb;</number> complete </paragraph>
<paragraph id="P-1081" lvl="7"><number>&lsqb;1081&rsqb;</number> Description </paragraph>
<paragraph id="P-1082" lvl="0"><number>&lsqb;1082&rsqb;</number> The function complete returns true when all fragments comprising the original datagram are present. </paragraph>
<paragraph id="P-1083" lvl="7"><number>&lsqb;1083&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1084" lvl="1"><number>&lsqb;1084&rsqb;</number> bool complete( ), </paragraph>
<paragraph id="P-1085" lvl="7"><number>&lsqb;1085&rsqb;</number> Parameters </paragraph>
<paragraph id="P-1086" lvl="0"><number>&lsqb;1086&rsqb;</number> None. </paragraph>
<paragraph id="P-1087" lvl="7"><number>&lsqb;1087&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1088" lvl="0"><number>&lsqb;1088&rsqb;</number> Returns a boolean value indicating when all fragments comprising the original datagram are present. </paragraph>
<paragraph id="P-1089" lvl="1"><number>&lsqb;1089&rsqb;</number> head </paragraph>
<paragraph id="P-1090" lvl="7"><number>&lsqb;1090&rsqb;</number> Description </paragraph>
<paragraph id="P-1091" lvl="0"><number>&lsqb;1091&rsqb;</number> The function head returns the address of the first IP fragment in the datagram&apos;s linked list of fragments. </paragraph>
<paragraph id="P-1092" lvl="7"><number>&lsqb;1092&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1093" lvl="1"><number>&lsqb;1093&rsqb;</number> IP4Fragment* head( ); </paragraph>
<paragraph id="P-1094" lvl="7"><number>&lsqb;1094&rsqb;</number> Parameters </paragraph>
<paragraph id="P-1095" lvl="0"><number>&lsqb;1095&rsqb;</number> None. </paragraph>
<paragraph id="P-1096" lvl="7"><number>&lsqb;1096&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1097" lvl="0"><number>&lsqb;1097&rsqb;</number> Returns the address of the first IP fragment in the datagram&apos;s linked list of fragments. </paragraph>
<paragraph id="P-1098" lvl="7"><number>&lsqb;1098&rsqb;</number> 10. UDP Support </paragraph>
<paragraph id="P-1099" lvl="0"><number>&lsqb;1099&rsqb;</number> The UDP protocol provides a best-effort datagram service. Due to its limited complexity, only the simple UDP header definitions are included here. Additional functions operating on several protocols (e.g. UDP and TCP NAT) are defined in subsequent sections. </paragraph>
<paragraph id="P-1100" lvl="7"><number>&lsqb;1100&rsqb;</number> 11. UDP Header </paragraph>
<paragraph id="P-1101" lvl="0"><number>&lsqb;1101&rsqb;</number> The UDPHeader class defines the standard UDP header. It is defined in NBudp.h. In addition to the standard UDP header, the class includes a single method for convenience in accessing the payload portion of the UDP datagram. The class contains no virtual functions, and therefore pointers to the UDPHeader class may be used to point to UDP headers received in live network packets. </paragraph>
<paragraph id="P-1102" lvl="0"><number>&lsqb;1102&rsqb;</number> The class contains a number of member functions, most of which provide direct access to the header fields. A special payload function may be used to obtain a pointer immediately beyond the UDP header. The following table lists the functions providing direct access to the header fields:  
<table-cwu id="TABLE-US-00081">
<number>81</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="210PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Function</entry>
<entry>Return Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>sport()</entry>
<entry>nuint16&amp;</entry>
<entry>Returns a reference to the source UDP port number</entry>
</row>
<row>
<entry>dport()</entry>
<entry>nuint16&amp;</entry>
<entry>Returns a reference to the destination UDP port number</entry>
</row>
<row>
<entry>len()</entry>
<entry>nuint16&amp;</entry>
<entry>Returns a reference to the UDP length field</entry>
</row>
<row>
<entry>cksum()</entry>
<entry>nuint16&amp;</entry>
<entry>Returns a reference to the UDP pseudoheader checksum. UDP</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>checksums are optional; a value of all zero bits indicate no checksum is</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>was computed.</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1103" lvl="7"><number>&lsqb;1103&rsqb;</number> The following function provides convenient access to the payload portion of the datagram, and maintains consistency with other protocol headers (i.e. IP and TCP). </paragraph>
<paragraph id="P-1104" lvl="1"><number>&lsqb;1104&rsqb;</number> payload </paragraph>
<paragraph id="P-1105" lvl="7"><number>&lsqb;1105&rsqb;</number> Description </paragraph>
<paragraph id="P-1106" lvl="0"><number>&lsqb;1106&rsqb;</number> The function payload returns the address of the first byte of data (beyond the UDP header). </paragraph>
<paragraph id="P-1107" lvl="7"><number>&lsqb;1107&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1108" lvl="1"><number>&lsqb;1108&rsqb;</number> unsigned char* payload( ); </paragraph>
<paragraph id="P-1109" lvl="7"><number>&lsqb;1109&rsqb;</number> Parameters </paragraph>
<paragraph id="P-1110" lvl="7"><number>&lsqb;1110&rsqb;</number> None. </paragraph>
<paragraph id="P-1111" lvl="7"><number>&lsqb;1111&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1112" lvl="0"><number>&lsqb;1112&rsqb;</number> Returns the address of the first byte of payload data in the UDP packet. </paragraph>
<paragraph id="P-1113" lvl="0"><number>&lsqb;1113&rsqb;</number> 12. TCP Support </paragraph>
<paragraph id="P-1114" lvl="0"><number>&lsqb;1114&rsqb;</number> The TCP protocol provides a stateful connection-oriented stream service. The ASL provides the TCP-specific definitions, including the TCP header, plus a facility to monitor the content and progress of an active TCP flow as a third party (i.e. without having to be an endpoint). For address and port number translation of TCP, see the section on NAT in subsequent sections of this document. </paragraph>
<paragraph id="P-1115" lvl="0"><number>&lsqb;1115&rsqb;</number> 13. TCP Sequence Numbers </paragraph>
<paragraph id="P-1116" lvl="0"><number>&lsqb;1116&rsqb;</number> TCP uses sequence numbers to keep track of an active data transfer. Each unit of data transfer is called a segment, and each segment contains a range of sequence numbers In TCP, sequence numbers are in byte units. If a TCP connection is open and data transfer is progressing from computer A to B, TCP segments will be flowing from A to B and acknowledgements will be flowing from B toward A. The acknowledgements indicate to the sender the amount of data the receiver has received. TCP is a bi-directional protocol, so that data may be flowing simultaneously from A to B and from B to A. In such cases, each segment (in both directions) contains data for one direction of the connection and acknowledgements for the other direction of the connection. Both sequence numbers (sending direction) and acknowledgement numbers (reverse direction) use TCP sequence numbers as the data type in the TCP header. TCP sequence numbers are 32-bit unsigned numbers that are allowed to wrap beyond 2&circ; 32-1. Within the ASL, a special class called TCPSeq defines this class and associated operators, so that objects of this type may be treated like ordinary scalar types (e.g. unsigned integers). </paragraph>
<paragraph id="P-1117" lvl="0"><number>&lsqb;1117&rsqb;</number> 14. TCP Header </paragraph>
<paragraph id="P-1118" lvl="0"><number>&lsqb;1118&rsqb;</number> The TCPHeader class defines the standard TCP header. In addition to the standard TCP header, the class includes a set of methods for convenience in accessing the payload portion of the TCP stream. The class contains no virtual functions, and therefore pointers to the TCPHeader class may be used to point to TCP headers received in live network packets. </paragraph>
<paragraph id="P-1119" lvl="0"><number>&lsqb;1119&rsqb;</number> The class contains a number of member functions, most of which provide direct access to the header fields. A special payload function may be used to obtain a pointer immediately beyond the TCP header The following table lists the functions providing direct access to the header fields:  
<table-cwu id="TABLE-US-00082">
<number>82</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="203PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Function</entry>
<entry>Return Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>sport()</entry>
<entry>nuint16&amp;</entry>
<entry>Returns a reference to the source TCP port number</entry>
</row>
<row>
<entry>dport()</entry>
<entry>nuint16&amp;</entry>
<entry>Returns a reference to the destination TCP port number</entry>
</row>
<row>
<entry>seq()</entry>
<entry>TCPSeq&amp;</entry>
<entry>Returns a reference to the TCP sequence number</entry>
</row>
<row>
<entry>ack()</entry>
<entry>TCPSeq&amp;</entry>
<entry>Returns a reference to the TCP acknowledgement number</entry>
</row>
<row>
<entry>off()</entry>
<entry>nuint8</entry>
<entry>Returns the number of 32-bit words in the TCP header (includes TCP</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>options)</entry>
</row>
<row>
<entry>flags()</entry>
<entry>nuint8&amp;</entry>
<entry>Returns a reference to the byte containing the 6 flags bits (and 2</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>reserved bits)</entry>
</row>
<row>
<entry>win()</entry>
<entry>nuint16&amp;</entry>
<entry>Returns a reference to the window advertisement field (unscaled)</entry>
</row>
<row>
<entry>cksum()</entry>
<entry>nuint16&amp;</entry>
<entry>Returns a reference to the TCP pseudoheader checksum. TCP</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>checksums are not optional.</entry>
</row>
<row>
<entry>udp()</entry>
<entry>nuint16&amp;</entry>
<entry>Returns a reference to the TCP urgent pointer field</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1120" lvl="7"><number>&lsqb;1120&rsqb;</number> The following functions provides convenient access to other characteristics of the segment: </paragraph>
<paragraph id="P-1121" lvl="1"><number>&lsqb;1121&rsqb;</number> payload </paragraph>
<paragraph id="P-1122" lvl="7"><number>&lsqb;1122&rsqb;</number> Description </paragraph>
<paragraph id="P-1123" lvl="0"><number>&lsqb;1123&rsqb;</number> The function payload returns the address of the first byte of data (beyond the TCP header). </paragraph>
<paragraph id="P-1124" lvl="7"><number>&lsqb;1124&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1125" lvl="1"><number>&lsqb;1125&rsqb;</number> unsigned char* payload( ); </paragraph>
<paragraph id="P-1126" lvl="7"><number>&lsqb;1126&rsqb;</number> Parameters </paragraph>
<paragraph id="P-1127" lvl="7"><number>&lsqb;1127&rsqb;</number> None. </paragraph>
<paragraph id="P-1128" lvl="7"><number>&lsqb;1128&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1129" lvl="0"><number>&lsqb;1129&rsqb;</number> Returns the address of the first byte of payload data in the TCP packet. </paragraph>
<paragraph id="P-1130" lvl="1"><number>&lsqb;1130&rsqb;</number> window </paragraph>
<paragraph id="P-1131" lvl="7"><number>&lsqb;1131&rsqb;</number> Description </paragraph>
<paragraph id="P-1132" lvl="0"><number>&lsqb;1132&rsqb;</number> The function window returns the window advertisement contained in the segment, taking into account the use of TCP large windows (see RFC 1323). </paragraph>
<paragraph id="P-1133" lvl="7"><number>&lsqb;1133&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1134" lvl="1"><number>&lsqb;1134&rsqb;</number> uint32 window(int wshift)  
<table-cwu id="TABLE-US-00083">
<number>83</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="21PT" align="left"/>
<colspec colname="3" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>wshift</entry>
<entry>int</entry>
<entry>The &ldquo;window shift value&rdquo; (number of left-shift bit positions to scale</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>window field)</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1135" lvl="7"><number>&lsqb;1135&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1136" lvl="0"><number>&lsqb;1136&rsqb;</number> Returns the receiver&apos;s advertised window in the segment (in bytes). This function is to be used when RFC1323-style window scaling is in use. </paragraph>
<paragraph id="P-1137" lvl="1"><number>&lsqb;1137&rsqb;</number> optbase </paragraph>
<paragraph id="P-1138" lvl="7"><number>&lsqb;1138&rsqb;</number> Description </paragraph>
<paragraph id="P-1139" lvl="0"><number>&lsqb;1139&rsqb;</number> The function optbase returns the address of the first option in the TCP header, if any are present. If no options are present, it returns the address of the first payload byte (which may be urgent data if the URG bit is set in the flags field). </paragraph>
<paragraph id="P-1140" lvl="7"><number>&lsqb;1140&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1141" lvl="1"><number>&lsqb;1141&rsqb;</number> u_char* optbase( ) </paragraph>
<paragraph id="P-1142" lvl="7"><number>&lsqb;1142&rsqb;</number> Parameters </paragraph>
<paragraph id="P-1143" lvl="7"><number>&lsqb;1143&rsqb;</number> None. </paragraph>
<paragraph id="P-1144" lvl="7"><number>&lsqb;1144&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1145" lvl="0"><number>&lsqb;1145&rsqb;</number> Returns the address of the first byte of data beyond the urgent pointer field of the TCP header. </paragraph>
<paragraph id="P-1146" lvl="1"><number>&lsqb;1146&rsqb;</number> hlen </paragraph>
<paragraph id="P-1147" lvl="7"><number>&lsqb;1147&rsqb;</number> Description </paragraph>
<paragraph id="P-1148" lvl="0"><number>&lsqb;1148&rsqb;</number> The first form of this function ver returns the TCP header length in bytes. The second form assigns the TCP header length to the number of bytes specified. </paragraph>
<paragraph id="P-1149" lvl="7"><number>&lsqb;1149&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1150" lvl="1"><number>&lsqb;1150&rsqb;</number> int hlen( ); </paragraph>
<paragraph id="P-1151" lvl="1"><number>&lsqb;1151&rsqb;</number> void hlen(int bytes);  
<table-cwu id="TABLE-US-00084">
<number>84</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="21PT" align="left"/>
<colspec colname="3" colwidth="154PT" align="left"/>
<tbody valign="top">
<row>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>bytes</entry>
<entry>int</entry>
<entry>Specifies the number of bytes present in the TCP</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>header</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1152" lvl="7"><number>&lsqb;1152&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1153" lvl="0"><number>&lsqb;1153&rsqb;</number> The first form returns the number of bytes in the TCP header. </paragraph>
<paragraph id="P-1154" lvl="7"><number>&lsqb;1154&rsqb;</number> Definitions </paragraph>
<paragraph id="P-1155" lvl="0"><number>&lsqb;1155&rsqb;</number> In addition to the TCP header itself, a number of definitions are provided for manipulating options in TCP headers:  
<table-cwu id="TABLE-US-00085">
<number>85</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>TCP Options</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="105PT" align="left"/>
<colspec colname="2" colwidth="21PT" align="center"/>
<colspec colname="3" colwidth="133PT" align="left"/>
<tbody valign="top">
<row>
<entry>Define</entry>
<entry>Value</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="105PT" align="left"/>
<colspec colname="2" colwidth="21PT" align="char" char="."/>
<colspec colname="3" colwidth="133PT" align="left"/>
<tbody valign="top">
<row>
<entry>TCPOPT_EOL</entry>
<entry>0</entry>
<entry>End of Option List</entry>
</row>
<row>
<entry>TCPOPT_NOP</entry>
<entry>1</entry>
<entry>No operation (used for padding</entry>
</row>
<row>
<entry>TCPOPT_MAXSEG</entry>
<entry>2</entry>
<entry>Maximum segment size</entry>
</row>
<row>
<entry>TCPOPT_SACK_PERMITTED</entry>
<entry>4</entry>
<entry>Selective Acknowledgements available</entry>
</row>
<row>
<entry>TCPOPT_SACK</entry>
<entry>5</entry>
<entry>Selective Acknowledgements in this segment</entry>
</row>
<row>
<entry>TCPOPT_TIMESTAMP</entry>
<entry>8</entry>
<entry>Time stamps</entry>
</row>
<row>
<entry>TCPOPT_CC</entry>
<entry>11</entry>
<entry>for T/TCP (see RFC 1644)</entry>
</row>
<row>
<entry>TCPOPT_CCNEW</entry>
<entry>12</entry>
<entry>for T/TCP</entry>
</row>
<row>
<entry>TCPOPT_CCECHO</entry>
<entry>13</entry>
<entry>for T/TCP</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1156" lvl="0"><number>&lsqb;1156&rsqb;</number> 15. TCP Following </paragraph>
<paragraph id="P-1157" lvl="0"><number>&lsqb;1157&rsqb;</number> TCP operates as an 11-state finite state machine Most of the states are related to connection establishment and tear-down. By following certain control bits in the TCP headers of segments passed along a connection, it is possible to infer the TCP state at each endpoint, and to monitor the data exchanged between the two endpoints. </paragraph>
<paragraph id="P-1158" lvl="7"><number>&lsqb;1158&rsqb;</number> Defines </paragraph>
<paragraph id="P-1159" lvl="0"><number>&lsqb;1159&rsqb;</number> The following definitions are for TCP state monitoring, and indicate states in the TCP finite state machine:  
<table-cwu id="TABLE-US-00086">
<number>86</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="98PT" align="left"/>
<colspec colname="2" colwidth="84PT" align="left"/>
<colspec colname="3" colwidth="105PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Define</entry>
<entry>Value</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>TCPS_CLOSED</entry>
<entry>&ensp;0</entry>
<entry>Closed</entry>
</row>
<row>
<entry>TCPS_LISTEN</entry>
<entry>&ensp;1</entry>
<entry>Listening for connection.</entry>
</row>
<row>
<entry>TCPS_SYN_SENT</entry>
<entry>&ensp;2</entry>
<entry>Active open, have sent SYN.</entry>
</row>
<row>
<entry>TCPS_SYN_RECEIVED</entry>
<entry>&ensp;3</entry>
<entry>Have sent and received SYN.</entry>
</row>
<row>
<entry>TCPS_ESTABLISHED</entry>
<entry>&ensp;4</entry>
<entry>Established.</entry>
</row>
<row>
<entry>TCPS_CLOSE_WAIT</entry>
<entry>&ensp;5</entry>
<entry>Received FIN, waiting for closed.</entry>
</row>
<row>
<entry>TCPS_FIN_WAIT_1</entry>
<entry>&ensp;6</entry>
<entry>Have closed, sent FIN.</entry>
</row>
<row>
<entry>TCPS_CLOSING</entry>
<entry>&ensp;7</entry>
<entry>Closed exchanged FIN; awaiting</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>FIN ACK.</entry>
</row>
<row>
<entry>TCPS_LAST_ACK</entry>
<entry>&ensp;8</entry>
<entry>Had FIN and close; await FIN</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>ACK.</entry>
</row>
<row>
<entry>TCPS_FIN_WAIT_2</entry>
<entry>&ensp;9</entry>
<entry>Have closed, FIN is acked.</entry>
</row>
<row>
<entry>TCPS_TIME_WAIT</entry>
<entry>10</entry>
<entry>In 2*MSL quiet wait after close.</entry>
</row>
<row>
<entry>TCPS_HAVERCVDSYN(s)</entry>
<entry>((s)&gt;&equals;</entry>
<entry>True if state s indicates a SYN has</entry>
</row>
<row>
<entry></entry>
<entry>TCPS_SYN_RECEIVED)</entry>
<entry>been received</entry>
</row>
<row>
<entry>TCPS_HAVEESTABLISHED(s)</entry>
<entry>((s)&gt;&equals;</entry>
<entry>True if state s indicates have</entry>
</row>
<row>
<entry></entry>
<entry>TCPS_ESTABLISHED)</entry>
<entry>established ever</entry>
</row>
<row>
<entry>TCPS_HAVERCVDFIN(s)</entry>
<entry>((s)&gt;&equals;</entry>
<entry>True if state s indicates a FIN ever</entry>
</row>
<row>
<entry></entry>
<entry>TCPS_TIME_WAIT)</entry>
<entry>received</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1160" lvl="1"><number>&lsqb;1160&rsqb;</number> Note 1: States less than TCPS_ESTABLISHED indicate connections not yet established. </paragraph>
<paragraph id="P-1161" lvl="1"><number>&lsqb;1161&rsqb;</number> Note 2: States greater than TCPS_CLOSE_WAIT are those where the user has closed. </paragraph>
<paragraph id="P-1162" lvl="1"><number>&lsqb;1162&rsqb;</number> Note 3: States greater than TCPS_CLOSE_WAIT and less than TCPS_FIN_WAIT<highlight><subscript>&mdash;</subscript></highlight>2 await ACK of FIN. </paragraph>
<paragraph id="P-1163" lvl="7"><number>&lsqb;1163&rsqb;</number> The TCPSegInfo Class </paragraph>
<paragraph id="P-1164" lvl="0"><number>&lsqb;1164&rsqb;</number> The TCPSegInfo class is a container class for TCP segments that have been queued during TCP stream reconstruction and may be read by applications (using the ReassemblyQueue::read function, defined below). When segments are queued, they are maintained in a doubly-linked list sorted by sequence number order. Note that the list may contain &ldquo;holes&rdquo;. That is, it may contain segments that are not adjacent in the space of sequence numbers because some data is missing in between. In addition, because retransmitted TCP segments can potentially overlap one another&apos;s data areas, the starting and ending sequence number fields (start seq_ and endseq_) may not correspond to the starting sequence number The class contains the following fields, all of which are declared public:  
<table-cwu id="TABLE-US-00087">
<number>87</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="49PT" align="left"/>
<colspec colname="3" colwidth="182PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Field</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>prev<highlight><subscript>&mdash;</subscript></highlight></entry>
<entry>TCPSegInfo*</entry>
<entry>Pointer to the next TCPSegInfo object of the forward linked</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>list; NULL if no more</entry>
</row>
<row>
<entry>next<highlight><subscript>&mdash;</subscript></highlight></entry>
<entry>TCPSegInfo*</entry>
<entry>Pointer to the previous TCPSegInfo object of the reverse</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>linked list; NULL if no previous segment exists</entry>
</row>
<row>
<entry>segment<highlight><subscript>&mdash;</subscript></highlight></entry>
<entry>IP4Datagram*</entry>
<entry>Pointer to the datagram containing the TCP segment</entry>
</row>
<row>
<entry>startseq<highlight><subscript>&mdash;</subscript></highlight></entry>
<entry>TCPSeq</entry>
<entry>The starting sequence number for the segment</entry>
</row>
<row>
<entry>endseq<highlight><subscript>&mdash;</subscript></highlight></entry>
<entry>TCPSeq</entry>
<entry>The ending sequence number for the segment</entry>
</row>
<row>
<entry>startbuf<highlight><subscript>&mdash;</subscript></highlight></entry>
<entry>u_char*</entry>
<entry>Pointer to the byte whose sequence number is specified by the</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>startseq_ field</entry>
</row>
<row>
<entry>endbuf<highlight><subscript>&mdash;</subscript></highlight></entry>
<entry>u_char*</entry>
<entry>Pointer to the byte whose sequence number is specified by the</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>endseq_ field</entry>
</row>
<row>
<entry>flags<highlight><subscript>&mdash;</subscript></highlight></entry>
<entry>uint32</entry>
<entry>Flags field for the segment (reserved as of the EA2 release)</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1165" lvl="7"><number>&lsqb;1165&rsqb;</number> The ReassemblyQueue Class </paragraph>
<paragraph id="P-1166" lvl="0"><number>&lsqb;1166&rsqb;</number> The ReassemblyQueue class is a container class used in reconstructing TCP streams from TCP segments that have been &ldquo;snooped&rdquo; on a TCP connection. This class contains a list of TCPSegInfo objects, each of which corresponds to a single TCP segment. The purpose of this class is not only to contain the segments, but to reassemble received segments as they arrive and present them in proper sequence number order for applications to read. Applications are generally able to read data on the connection in order, or to skip past some fixed amount of enqued data. </paragraph>
<paragraph id="P-1167" lvl="1"><number>&lsqb;1167&rsqb;</number> Constructor </paragraph>
<paragraph id="P-1168" lvl="7"><number>&lsqb;1168&rsqb;</number> Description </paragraph>
<paragraph id="P-1169" lvl="0"><number>&lsqb;1169&rsqb;</number> A ReassemblyQueue object is used internally by the TCP stream reconstruction facility, but may be useful to applications in generaly under some circumstances. It provides for reassembly of TCP streams based on sequence numbers contained in TCP segments. The constructor takes an argument specifying the next sequence number to expect. It is updated as additional segments are inserted into the object. If a segment is inserted which is not contiguous in sequence number space, it is considered &ldquo;out of order&rdquo; and is queued in the object until the &ldquo;hole&rdquo; (data between it and the previous in-sequence data) is filled. </paragraph>
<paragraph id="P-1170" lvl="7"><number>&lsqb;1170&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1171" lvl="1"><number>&lsqb;1171&rsqb;</number> ReassemblyQueue(TCPSeq&amp; rcvnxt)  
<table-cwu id="TABLE-US-00088">
<number>88</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="280PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="35PT" align="left"/>
<colspec colname="3" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>rcvnxt</entry>
<entry>TCPSeq&amp;</entry>
<entry>A reference to the next TCP sequence number to expect. The sequence</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>number referred to by rcvnxt is updated by the add function (see</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>below) to always indicate the next in-order TCP sequence number</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>expected</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1172" lvl="7"><number>&lsqb;1172&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1173" lvl="0"><number>&lsqb;1173&rsqb;</number> None. </paragraph>
<paragraph id="P-1174" lvl="7"><number>&lsqb;1174&rsqb;</number> Defines </paragraph>
<paragraph id="P-1175" lvl="0"><number>&lsqb;1175&rsqb;</number> The following definitions are provided for insertion of TCP segments into a ReassemblyQueue object, and are used as return values for the add function defined below. Generally, acceptable conditions are indicated by bits in the low-order half-word, and suspicious or error conditions are indicated in the upper half-word.  
<table-cwu id="TABLE-US-00089">
<number>89</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="77PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="154PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Define</entry>
<entry>Value</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>RQ_OK</entry>
<entry>0x00000000</entry>
<entry>Segment was non-overlapping and in-order</entry>
</row>
<row>
<entry>RQ_OUTORDER</entry>
<entry>0x00000001</entry>
<entry>Segment was out of order (didn&apos;t match next</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>expected sequence number)</entry>
</row>
<row>
<entry>RQ_LOW_OLAP</entry>
<entry>0x00000002</entry>
<entry>Segment&apos;s sequence number was below next</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>expected but segment extended past next expected</entry>
</row>
<row>
<entry>RQ_HIGH_OLAP</entry>
<entry>0x00000004</entry>
<entry>Segment&apos;s data overlapped another queued</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>segment&apos;s data</entry>
</row>
<row>
<entry>RQ_DUP</entry>
<entry>0x00000008</entry>
<entry>Completely duplicate segment</entry>
</row>
<row>
<entry>RQ_BAD_HLEN</entry>
<entry>0x00010000</entry>
<entry>Bad header length (e.g. less than 5)</entry>
</row>
<row>
<entry>RQ_RSVD</entry>
<entry>0x00020000</entry>
<entry>Bad reserved field (reserved bits are non-zero)</entry>
</row>
<row>
<entry>RQ_FLAGS_ALERT</entry>
<entry>0x00040000</entry>
<entry>Suspicious combination of flags (e.g. RST on or all</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>on, etc)</entry>
</row>
<row>
<entry>RQ_FLAGS_BADURP</entry>
<entry>0x00080000</entry>
<entry>Bad urgent pointer</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1176" lvl="1"><number>&lsqb;1176&rsqb;</number> add </paragraph>
<paragraph id="P-1177" lvl="7"><number>&lsqb;1177&rsqb;</number> Description </paragraph>
<paragraph id="P-1178" lvl="0"><number>&lsqb;1178&rsqb;</number> The add function inserts an IP datagram or complete IP fragment containing a TCP segment into the reassembly queue. The TCP sequence number referenced by rcvnxt in the constructor is updated to reflect the next in-sequence sequence number expected. </paragraph>
<paragraph id="P-1179" lvl="7"><number>&lsqb;1179&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1180" lvl="1"><number>&lsqb;1180&rsqb;</number> int add(IP4Datagram* dp, TCPSeq seq, uint32 dlen); </paragraph>
<paragraph id="P-1181" lvl="1"><number>&lsqb;1181&rsqb;</number> int add(IP4Fragment* fp, TCPSeq seq, uint32 dlen);  
<table-cwu id="TABLE-US-00090">
<number>90</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="273PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="49PT" align="left"/>
<colspec colname="3" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>fp</entry>
<entry>IP4Fragment*</entry>
<entry>Pointer to an unfragmented IP fragment containing a TCP</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>segment</entry>
</row>
<row>
<entry>dp</entry>
<entry>IP4Datagram*</entry>
<entry>A pointer to a complete IP datagram containing a TCP segment</entry>
</row>
<row>
<entry>seq</entry>
<entry>TCPSeq</entry>
<entry>Initial sequence number for the TCP segment</entry>
</row>
<row>
<entry>dlen</entry>
<entry>uint32</entry>
<entry>Usable length of the TCP segment</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1182" lvl="7"><number>&lsqb;1182&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1183" lvl="0"><number>&lsqb;1183&rsqb;</number> Returns a 32-bit integer with the possible values indicated above (definitions beginning with RQ_). </paragraph>
<paragraph id="P-1184" lvl="1"><number>&lsqb;1184&rsqb;</number> empty </paragraph>
<paragraph id="P-1185" lvl="7"><number>&lsqb;1185&rsqb;</number> Description </paragraph>
<paragraph id="P-1186" lvl="0"><number>&lsqb;1186&rsqb;</number> The empty function returns true if the reassembly queue contains no segments. </paragraph>
<paragraph id="P-1187" lvl="7"><number>&lsqb;1187&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1188" lvl="1"><number>&lsqb;1188&rsqb;</number> bool empty( ) </paragraph>
<paragraph id="P-1189" lvl="7"><number>&lsqb;1189&rsqb;</number> Parameters </paragraph>
<paragraph id="P-1190" lvl="0"><number>&lsqb;1190&rsqb;</number> None. </paragraph>
<paragraph id="P-1191" lvl="7"><number>&lsqb;1191&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1192" lvl="0"><number>&lsqb;1192&rsqb;</number> Returns true if the reassembly queue contains no segments. </paragraph>
<paragraph id="P-1193" lvl="1"><number>&lsqb;1193&rsqb;</number> clear </paragraph>
<paragraph id="P-1194" lvl="7"><number>&lsqb;1194&rsqb;</number> Description </paragraph>
<paragraph id="P-1195" lvl="0"><number>&lsqb;1195&rsqb;</number> The clear function removes all queued segments from the reassembly queue and frees their storage. </paragraph>
<paragraph id="P-1196" lvl="7"><number>&lsqb;1196&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1197" lvl="1"><number>&lsqb;1197&rsqb;</number> void clear( ) </paragraph>
<paragraph id="P-1198" lvl="7"><number>&lsqb;1198&rsqb;</number> Parameters </paragraph>
<paragraph id="P-1199" lvl="0"><number>&lsqb;1199&rsqb;</number> None. </paragraph>
<paragraph id="P-1200" lvl="7"><number>&lsqb;1200&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1201" lvl="0"><number>&lsqb;1201&rsqb;</number> None. </paragraph>
<paragraph id="P-1202" lvl="1"><number>&lsqb;1202&rsqb;</number> read </paragraph>
<paragraph id="P-1203" lvl="7"><number>&lsqb;1203&rsqb;</number> Description </paragraph>
<paragraph id="P-1204" lvl="0"><number>&lsqb;1204&rsqb;</number> The read function provides application access to the contiguous data currently queued in the reassembly queue. The function returns a linked list of TCPSegInfo objects. The list is in order sorted by sequence number beginning with the first in-order sequence number and continues no further than the number of bytes specified by the caller. Note that the caller must inspect the value filled in by the call to determine how many byte worth of sequence number space is consumed by the linked list. This call removes the segments returned to the caller from the reassembly queue. </paragraph>
<paragraph id="P-1205" lvl="7"><number>&lsqb;1205&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1206" lvl="1"><number>&lsqb;1206&rsqb;</number> TCPSegInfo* read(int&amp; len);  
<table-cwu id="TABLE-US-00091">
<number>91</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="266PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="21PT" align="left"/>
<colspec colname="3" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>len</entry>
<entry>int&amp;</entry>
<entry>Contains the number of bytes worth of in-sequence data the application</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>is interested in reading from the reassembly queue. The underlying</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>integer is modified by this call to indicate the number of bytes actually</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>covered by the list of segments returned. The call is guaranteed to</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>ever return a larger number of bytes than requested.</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1207" lvl="7"><number>&lsqb;1207&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1208" lvl="0"><number>&lsqb;1208&rsqb;</number> Returns a pointer to the first TCPSegInfo object in a doubly-linked list of objects each of which point to TCP segments that are numerically adjacent in TCP sequence number space. </paragraph>
<paragraph id="P-1209" lvl="7"><number>&lsqb;1209&rsqb;</number> The TCPEndpoint Class </paragraph>
<paragraph id="P-1210" lvl="0"><number>&lsqb;1210&rsqb;</number> The TCPEndpoint class is the abstraction of a single endpoint of a TCP connection. In TCP, a connection is identified by a 4-tuple of two IP addresses and a two port numbers. Each endpoint is identified by a single IP address and port number. Thus, a TCP connection (or &ldquo;session&rdquo;&mdash;see below) actually comprises two endpoint objects. Each endpoint contains the TCP finite state machine state as well as a ReassemblyQueue object, used to contain queued data. The TCPEndpoint class is used internally by the TCPSession class below, but may be useful to applications in certain circumstances. </paragraph>
<paragraph id="P-1211" lvl="1"><number>&lsqb;1211&rsqb;</number> Constructor </paragraph>
<paragraph id="P-1212" lvl="7"><number>&lsqb;1212&rsqb;</number> Description </paragraph>
<paragraph id="P-1213" lvl="0"><number>&lsqb;1213&rsqb;</number> The TCPEndpoint class is created in an empty state and is unable to determine which endpoint of a connection it represents. The user should call the init function described below after object instantiation to begin use of the object. </paragraph>
<paragraph id="P-1214" lvl="7"><number>&lsqb;1214&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1215" lvl="1"><number>&lsqb;1215&rsqb;</number> TCPEndpoint( ) </paragraph>
<paragraph id="P-1216" lvl="7"><number>&lsqb;1216&rsqb;</number> Parameters </paragraph>
<paragraph id="P-1217" lvl="0"><number>&lsqb;1217&rsqb;</number> None. </paragraph>
<paragraph id="P-1218" lvl="7"><number>&lsqb;1218&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1219" lvl="0"><number>&lsqb;1219&rsqb;</number> None. </paragraph>
<paragraph id="P-1220" lvl="1"><number>&lsqb;1220&rsqb;</number> Destructor </paragraph>
<paragraph id="P-1221" lvl="7"><number>&lsqb;1221&rsqb;</number> Description </paragraph>
<paragraph id="P-1222" lvl="0"><number>&lsqb;1222&rsqb;</number> Deletes all queued TCP segments and frees the object&apos;s memory. </paragraph>
<paragraph id="P-1223" lvl="7"><number>&lsqb;1223&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1224" lvl="1"><number>&lsqb;1224&rsqb;</number> &tilde;TCPEndpoint( ) </paragraph>
<paragraph id="P-1225" lvl="7"><number>&lsqb;1225&rsqb;</number> Parameters </paragraph>
<paragraph id="P-1226" lvl="0"><number>&lsqb;1226&rsqb;</number> None. </paragraph>
<paragraph id="P-1227" lvl="7"><number>&lsqb;1227&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1228" lvl="0"><number>&lsqb;1228&rsqb;</number> None. </paragraph>
<paragraph id="P-1229" lvl="1"><number>&lsqb;1229&rsqb;</number> reset </paragraph>
<paragraph id="P-1230" lvl="7"><number>&lsqb;1230&rsqb;</number> Description </paragraph>
<paragraph id="P-1231" lvl="0"><number>&lsqb;1231&rsqb;</number> Resets the endpoint internal state to closed and clears any queued data. </paragraph>
<paragraph id="P-1232" lvl="7"><number>&lsqb;1232&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1233" lvl="1"><number>&lsqb;1233&rsqb;</number> &tilde;TCPEndpoint( ) </paragraph>
<paragraph id="P-1234" lvl="7"><number>&lsqb;1234&rsqb;</number> Parameters </paragraph>
<paragraph id="P-1235" lvl="0"><number>&lsqb;1235&rsqb;</number> None. </paragraph>
<paragraph id="P-1236" lvl="7"><number>&lsqb;1236&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1237" lvl="0"><number>&lsqb;1237&rsqb;</number> None. </paragraph>
<paragraph id="P-1238" lvl="1"><number>&lsqb;1238&rsqb;</number> state </paragraph>
<paragraph id="P-1239" lvl="7"><number>&lsqb;1239&rsqb;</number> Description </paragraph>
<paragraph id="P-1240" lvl="0"><number>&lsqb;1240&rsqb;</number> Returns the current state in the TCP finite state machine associated with the TCP endpoint. </paragraph>
<paragraph id="P-1241" lvl="7"><number>&lsqb;1241&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1242" lvl="1"><number>&lsqb;1242&rsqb;</number> int state( ) </paragraph>
<paragraph id="P-1243" lvl="7"><number>&lsqb;1243&rsqb;</number> Parameters </paragraph>
<paragraph id="P-1244" lvl="0"><number>&lsqb;1244&rsqb;</number> None. </paragraph>
<paragraph id="P-1245" lvl="7"><number>&lsqb;1245&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1246" lvl="0"><number>&lsqb;1246&rsqb;</number> Returns an integer indicating the internal state according to the definitions given above (defines beginning with TCPS_) </paragraph>
<paragraph id="P-1247" lvl="1"><number>&lsqb;1247&rsqb;</number> init </paragraph>
<paragraph id="P-1248" lvl="7"><number>&lsqb;1248&rsqb;</number> Description </paragraph>
<paragraph id="P-1249" lvl="0"><number>&lsqb;1249&rsqb;</number> The init function provides initialization of a TCP endpoint object by specifying the P address and port number the endpoint is acting as. After this call has been made, subsequent processing of IP datagrams and fragments containing TCP segments (and ACKs) is accomplished by the process calls described below. </paragraph>
<paragraph id="P-1250" lvl="7"><number>&lsqb;1250&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1251" lvl="1"><number>&lsqb;1251&rsqb;</number> void init(IP4Addr* myaddr, uint16 myport);  
<table-cwu id="TABLE-US-00092">
<number>92</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="273PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="35PT" align="left"/>
<colspec colname="3" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>myaddr</entry>
<entry>IP4Addr*</entry>
<entry>A pointer to the IP address identifying this TCP endpoint</entry>
</row>
<row>
<entry>myport</entry>
<entry>nuint16</entry>
<entry>The port number (in network byte order) of port number identifying</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>this TCP endpoint</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1252" lvl="7"><number>&lsqb;1252&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1253" lvl="0"><number>&lsqb;1253&rsqb;</number> None. </paragraph>
<paragraph id="P-1254" lvl="1"><number>&lsqb;1254&rsqb;</number> process </paragraph>
<paragraph id="P-1255" lvl="7"><number>&lsqb;1255&rsqb;</number> Description </paragraph>
<paragraph id="P-1256" lvl="0"><number>&lsqb;1256&rsqb;</number> The process function processes an incoming or outgoing TCP segment relative to the TCP endpoint object. The first form of the function operates on a datagram which must be complete; the second form operates on a fragment which must also be complete. Given that the TCPEndpoint object is not actually the literal endpoint of the TCP connection itself, it must infer state transitions at the literal endpoints based upon observed traffic. Thus, it must monitor both directions of the TCP connection to properly follow the state at each literal endpoint. </paragraph>
<paragraph id="P-1257" lvl="7"><number>&lsqb;1257&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1258" lvl="1"><number>&lsqb;1258&rsqb;</number> int process(IP4Datagram* pd); </paragraph>
<paragraph id="P-1259" lvl="1"><number>&lsqb;1259&rsqb;</number> int process(IP4Fragment* pf);  
<table-cwu id="TABLE-US-00093">
<number>93</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="280PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="49PT" align="left"/>
<colspec colname="3" colwidth="196PT" align="left"/>
<tbody valign="top">
<row>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>pd</entry>
<entry>IP4Datagram*</entry>
<entry>A pointer to a complete IP datagram containing a TCP segment</entry>
</row>
<row>
<entry>pf</entry>
<entry>IP4Fragment*</entry>
<entry>Pointer to an unfragmented IP fragment containing a TCP segment</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1260" lvl="7"><number>&lsqb;1260&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1261" lvl="0"><number>&lsqb;1261&rsqb;</number> Returns a 32-bit integer with the same semantics defined for ReassemblyQueue::add (see above). </paragraph>
<paragraph id="P-1262" lvl="7"><number>&lsqb;1262&rsqb;</number> The TCPSession Class </paragraph>
<paragraph id="P-1263" lvl="0"><number>&lsqb;1263&rsqb;</number> The TCPSession class is the abstraction of a complete, bidirectional TCP connection. It includes two TCP endpoint objects, which each include a reassembly queue. Thus, provided the TCPSession object is able to process all data sent on the connection in either direction it will have a reasonably complete picture of the progress and data exchanged across the connection. </paragraph>
<paragraph id="P-1264" lvl="1"><number>&lsqb;1264&rsqb;</number> Constructor </paragraph>
<paragraph id="P-1265" lvl="7"><number>&lsqb;1265&rsqb;</number> Description </paragraph>
<paragraph id="P-1266" lvl="0"><number>&lsqb;1266&rsqb;</number> The TCPSess ion object is created by the caller when a TCP segment arrives on a new connection. The session object will infer from the contents of the segment which endpoint will be considered the client (the active opener&mdash;generally the sender of the first SYN), and which will be considered the server (the passive opener&mdash;generally the sender of the first SYN&plus;ACK). In circumstances of simultaneous active opens (a rare case when both endpoints send SYN packets), the notion of client and server is not well defined, but the session object will behave as though the sender of the first SYN received by the session object is the client. In any case, the terms client and server are only loosely defined and do not affect the proper operation of the object. </paragraph>
<paragraph id="P-1267" lvl="7"><number>&lsqb;1267&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1268" lvl="1"><number>&lsqb;1268&rsqb;</number> TCPSession(IP4Datagram* dp); </paragraph>
<paragraph id="P-1269" lvl="1"><number>&lsqb;1269&rsqb;</number> TCPSession(IP4Fragment* fp);  
<table-cwu id="TABLE-US-00094">
<number>94</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="266PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="49PT" align="left"/>
<colspec colname="3" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>pd</entry>
<entry>IP4Datagram*</entry>
<entry>A pointer to a complete IP datagram containing the first TCP</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>segment on the connection</entry>
</row>
<row>
<entry>pf</entry>
<entry>IP4Fragment*</entry>
<entry>Pointer to a complete IP fragment containing a the first TCP</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>segment on the connection</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1270" lvl="7"><number>&lsqb;1270&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1271" lvl="0"><number>&lsqb;1271&rsqb;</number> None. </paragraph>
<paragraph id="P-1272" lvl="1"><number>&lsqb;1272&rsqb;</number> Destructor </paragraph>
<paragraph id="P-1273" lvl="7"><number>&lsqb;1273&rsqb;</number> Description </paragraph>
<paragraph id="P-1274" lvl="0"><number>&lsqb;1274&rsqb;</number> Deletes all TCP segments queued and frees the object&apos;s memory </paragraph>
<paragraph id="P-1275" lvl="7"><number>&lsqb;1275&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1276" lvl="1"><number>&lsqb;1276&rsqb;</number> &tilde;TCPSession( ) </paragraph>
<paragraph id="P-1277" lvl="7"><number>&lsqb;1277&rsqb;</number> Parameters </paragraph>
<paragraph id="P-1278" lvl="7"><number>&lsqb;1278&rsqb;</number> None. </paragraph>
<paragraph id="P-1279" lvl="7"><number>&lsqb;1279&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1280" lvl="7"><number>&lsqb;1280&rsqb;</number> None. </paragraph>
<paragraph id="P-1281" lvl="1"><number>&lsqb;1281&rsqb;</number> process </paragraph>
<paragraph id="P-1282" lvl="7"><number>&lsqb;1282&rsqb;</number> Description </paragraph>
<paragraph id="P-1283" lvl="0"><number>&lsqb;1283&rsqb;</number> The process function processes a TCP segment on the connection. The first form of the function operates on a datagram which must be complete; the second form operates on a fragment which must also be complete. This function operates by passing the datagram or fragment to each endpoint&apos;s process function. </paragraph>
<paragraph id="P-1284" lvl="7"><number>&lsqb;1284&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1285" lvl="1"><number>&lsqb;1285&rsqb;</number> int process(IP4Datagram* pd); </paragraph>
<paragraph id="P-1286" lvl="1"><number>&lsqb;1286&rsqb;</number> int process(IP4Fragment* pf);  
<table-cwu id="TABLE-US-00095">
<number>95</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="273PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="49PT" align="left"/>
<colspec colname="3" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>pd</entry>
<entry>IP4Datagram*</entry>
<entry>A pointer to a complete IP datagram containing a TCP segment</entry>
</row>
<row>
<entry>pf</entry>
<entry>IP4Fragment*</entry>
<entry>Pointer to an unfragmented IP fragment containing a TCP</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>segment</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1287" lvl="7"><number>&lsqb;1287&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1288" lvl="0"><number>&lsqb;1288&rsqb;</number> Returns a 32-bit integer with the same semantics defined for ReassemblyQueue::add (see above). The value returned will be the result of calling the add function of the reassembly queue object embedded in the endpoint object corresponding to the destination address and port of the received segment. </paragraph>
<paragraph id="P-1289" lvl="0"><number>&lsqb;1289&rsqb;</number> 16. Network Address Translation (NAT) </paragraph>
<paragraph id="P-1290" lvl="0"><number>&lsqb;1290&rsqb;</number> Network Address Translation (NAT) refers to the general ability to modify various fields of different protocols so that the effective source, destination, or source and destination entities are replaced by an alternative. The definitions to perform NAT for the IP, UDP, and TCP protocols are defined within the ASL. The NAT implementation uses incremental checksum computation, so performance should not degrade in proportion to packet size. </paragraph>
<paragraph id="P-1291" lvl="0"><number>&lsqb;1291&rsqb;</number> 17. IP NAT </paragraph>
<paragraph id="P-1292" lvl="0"><number>&lsqb;1292&rsqb;</number> IP address translation refers to the mapping of an IP datagram (fragment) with source and destination IP address (s1,d1) to the same datagram (fragment) with new address pair (s2, d2). A source-rewrite only modifies the source address (d1 is left equal to d2). A destination rewrite implies only the destination address is rewritten (s1 is left equal to s2). A source and destination rewrite refers to a change in both the source and destination IP addresses. Note that for IP NAT, only the IP source and/or destination addresses are rewritten (in addition to rewriting the IP header checksum). For traffic such as TCP or UDP, NAT functionality must include modification of the TCP or UDP pseudoheader checksum (which covers the IP header source and destination addresses plus protocol field). Properly performing NAT on TCP or UDP traffic, requires attention to these details. </paragraph>
<paragraph id="P-1293" lvl="7"><number>&lsqb;1293&rsqb;</number> 18. IP NAT Base Class </paragraph>
<paragraph id="P-1294" lvl="0"><number>&lsqb;1294&rsqb;</number> The class IPNat provides a base class for other IP NAT classes. Because of the pure virtual function rewrite, applications will not create objects of type IP4Nat directly, but rather use the objects of typeIP4SNat, IP4DNat, and IP4SDNat defined below. </paragraph>
<paragraph id="P-1295" lvl="1"><number>&lsqb;1295&rsqb;</number> rewrite </paragraph>
<paragraph id="P-1296" lvl="7"><number>&lsqb;1296&rsqb;</number> Description </paragraph>
<paragraph id="P-1297" lvl="0"><number>&lsqb;1297&rsqb;</number> This pure-virtual function is defined in derived classes. It performs address rewriting in a specific fashion implemented by the specific derived classes (i.e. source, destination, or source/destination combination). The rewrite call, as applied to a fragment, only affects the given fragment. When applied to a datagram, each of the fragment headers comprising the datagram are re-written. </paragraph>
<paragraph id="P-1298" lvl="7"><number>&lsqb;1298&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1299" lvl="1"><number>&lsqb;1299&rsqb;</number> virtual void rewrite(IP4Datagram*fp)&equals;0; </paragraph>
<paragraph id="P-1300" lvl="1"><number>&lsqb;1300&rsqb;</number> virtual void rewrite(IP4Fragment*fp)&equals;0;  
<table-cwu id="TABLE-US-00096">
<number>96</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="119PT" align="left"/>
<tbody valign="top">
<row>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>dp</entry>
<entry>IP4Datagram *</entry>
<entry>Pointer to the datagram to rewrite</entry>
</row>
<row>
<entry>fp</entry>
<entry>IP4Fragment *</entry>
<entry>Pointer to the single fragment to rewrite</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1301" lvl="7"><number>&lsqb;1301&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1302" lvl="7"><number>&lsqb;1302&rsqb;</number> None. </paragraph>
<paragraph id="P-1303" lvl="0"><number>&lsqb;1303&rsqb;</number> There are three classes available for implementing IP NAT, all of which are derived from the base class IP4Nat. The classes IP4SNat, IPDNat, and IPSDNat define the structure of objects implementing source, destination, and source/destination rewriting for IP datagrams and fragments. </paragraph>
<paragraph id="P-1304" lvl="0"><number>&lsqb;1304&rsqb;</number> 19. IP4SNat Class </paragraph>
<paragraph id="P-1305" lvl="0"><number>&lsqb;1305&rsqb;</number> The IP4SNat class is derived from the IP4Nat class. It defines the class of objects implementing source rewriting for IP datagrams and fragments. </paragraph>
<paragraph id="P-1306" lvl="1"><number>&lsqb;1306&rsqb;</number> Constructor </paragraph>
<paragraph id="P-1307" lvl="7"><number>&lsqb;1307&rsqb;</number> Description </paragraph>
<paragraph id="P-1308" lvl="1"><number>&lsqb;1308&rsqb;</number> Instantiates the IP4 SNat object. </paragraph>
<paragraph id="P-1309" lvl="7"><number>&lsqb;1309&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1310" lvl="1"><number>&lsqb;1310&rsqb;</number> IP4SNat (IP4Addr* newsrc);  
<table-cwu id="TABLE-US-00097">
<number>97</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="35PT" align="left"/>
<colspec colname="3" colwidth="147PT" align="left"/>
<tbody valign="top">
<row>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>newsrc</entry>
<entry>IP4Addr *</entry>
<entry>Pointer to the new source address for IP NAT.</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1311" lvl="7"><number>&lsqb;1311&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1312" lvl="7"><number>&lsqb;1312&rsqb;</number> None. </paragraph>
<paragraph id="P-1313" lvl="1"><number>&lsqb;1313&rsqb;</number> rewrite </paragraph>
<paragraph id="P-1314" lvl="7"><number>&lsqb;1314&rsqb;</number> Description </paragraph>
<paragraph id="P-1315" lvl="0"><number>&lsqb;1315&rsqb;</number> Defines the pure virtual rewrite functions in the parent class. </paragraph>
<paragraph id="P-1316" lvl="7"><number>&lsqb;1316&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1317" lvl="1"><number>&lsqb;1317&rsqb;</number> void rewrite(IP4Datagram* dp); </paragraph>
<paragraph id="P-1318" lvl="1"><number>&lsqb;1318&rsqb;</number> void rewrite(IP4Fragment* fp);  
<table-cwu id="TABLE-US-00098">
<number>98</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="119PT" align="left"/>
<tbody valign="top">
<row>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>dp</entry>
<entry>LP4Datagram *</entry>
<entry>Pointer to the datagram to be rewritten</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>(all fragment headers are modified)</entry>
</row>
<row>
<entry>fp</entry>
<entry>IP4Fragment *</entry>
<entry>Pointer to the fragment to rewrite (only</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>the single fragment header is modified)</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1319" lvl="7"><number>&lsqb;1319&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1320" lvl="7"><number>&lsqb;1320&rsqb;</number> None. </paragraph>
<paragraph id="P-1321" lvl="0"><number>&lsqb;1321&rsqb;</number> 20. IP4DNat Class </paragraph>
<paragraph id="P-1322" lvl="0"><number>&lsqb;1322&rsqb;</number> The IP4DNat class is derived from the IP4Nat class. It defines the class of objects implementing destination rewriting for IP datagrams and fragments. </paragraph>
<paragraph id="P-1323" lvl="1"><number>&lsqb;1323&rsqb;</number> Constructor </paragraph>
<paragraph id="P-1324" lvl="7"><number>&lsqb;1324&rsqb;</number> Description </paragraph>
<paragraph id="P-1325" lvl="7"><number>&lsqb;1325&rsqb;</number> Instantiates the IP4DNat object. </paragraph>
<paragraph id="P-1326" lvl="7"><number>&lsqb;1326&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1327" lvl="1"><number>&lsqb;1327&rsqb;</number> IP4DNat(IP4Addr* newdst);  
<table-cwu id="TABLE-US-00099">
<number>99</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="119PT" align="left"/>
<tbody valign="top">
<row>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>newdst</entry>
<entry>IP4Addr *</entry>
<entry>Pointer to the new destination address</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>for IP NAT.</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1328" lvl="7"><number>&lsqb;1328&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1329" lvl="7"><number>&lsqb;1329&rsqb;</number> None. </paragraph>
<paragraph id="P-1330" lvl="1"><number>&lsqb;1330&rsqb;</number> rewrite </paragraph>
<paragraph id="P-1331" lvl="7"><number>&lsqb;1331&rsqb;</number> Description </paragraph>
<paragraph id="P-1332" lvl="0"><number>&lsqb;1332&rsqb;</number> Defines the pure virtual rewrite functions in the parent class. </paragraph>
<paragraph id="P-1333" lvl="7"><number>&lsqb;1333&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1334" lvl="1"><number>&lsqb;1334&rsqb;</number> void rewrite(IP4Datagram* dp); </paragraph>
<paragraph id="P-1335" lvl="1"><number>&lsqb;1335&rsqb;</number> void rewrite(IP4Fragment* fp);  
<table-cwu id="TABLE-US-00100">
<number>100</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="49PT" align="left"/>
<colspec colname="3" colwidth="133PT" align="left"/>
<tbody valign="top">
<row>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>dp</entry>
<entry>IP4Datagram *</entry>
<entry>Pointer to the datagram to be rewritten</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>(all fragment headers are modified)</entry>
</row>
<row>
<entry>fp</entry>
<entry>IP4Fragment *</entry>
<entry>Pointer to the fragment to rewrite</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>(only the single fragment header is modified)</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1336" lvl="7"><number>&lsqb;1336&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1337" lvl="7"><number>&lsqb;1337&rsqb;</number> None. </paragraph>
<paragraph id="P-1338" lvl="0"><number>&lsqb;1338&rsqb;</number> 21. IP4SDNat Class </paragraph>
<paragraph id="P-1339" lvl="0"><number>&lsqb;1339&rsqb;</number> The IP4SDNat class is derived from the IP4Nat class. It defines the class of objects implementing source and destination rewriting for IP datagrams and fragments. </paragraph>
<paragraph id="P-1340" lvl="1"><number>&lsqb;1340&rsqb;</number> Constructor </paragraph>
<paragraph id="P-1341" lvl="7"><number>&lsqb;1341&rsqb;</number> Description </paragraph>
<paragraph id="P-1342" lvl="7"><number>&lsqb;1342&rsqb;</number> Instantiates the IP4SDNat object. </paragraph>
<paragraph id="P-1343" lvl="7"><number>&lsqb;1343&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1344" lvl="1"><number>&lsqb;1344&rsqb;</number> IP4SDNat (IP4Addr* newsrc, IP4Addr* newdst);  
<table-cwu id="TABLE-US-00101">
<number>101</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="35PT" align="left"/>
<colspec colname="3" colwidth="147PT" align="left"/>
<tbody valign="top">
<row>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>nesrc</entry>
<entry>IP4Addr*</entry>
<entry>Pointer to the new source address for IP NAT.</entry>
</row>
<row>
<entry>newdst</entry>
<entry>IP4Addr *</entry>
<entry>Pointer to the new destination address for</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>IP NAT.</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1345" lvl="7"><number>&lsqb;1345&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1346" lvl="7"><number>&lsqb;1346&rsqb;</number> None. </paragraph>
<paragraph id="P-1347" lvl="1"><number>&lsqb;1347&rsqb;</number> rewrite </paragraph>
<paragraph id="P-1348" lvl="7"><number>&lsqb;1348&rsqb;</number> Description </paragraph>
<paragraph id="P-1349" lvl="0"><number>&lsqb;1349&rsqb;</number> Defines the pure virtual rewrite functions in the parent class. </paragraph>
<paragraph id="P-1350" lvl="7"><number>&lsqb;1350&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1351" lvl="1"><number>&lsqb;1351&rsqb;</number> void rewrite(IP4Datagram* dp); </paragraph>
<paragraph id="P-1352" lvl="1"><number>&lsqb;1352&rsqb;</number> void rewrite(IP4Fragment* fp);  
<table-cwu id="TABLE-US-00102">
<number>102</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="49PT" align="left"/>
<colspec colname="3" colwidth="133PT" align="left"/>
<tbody valign="top">
<row>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>dp</entry>
<entry>IP4Datagram *</entry>
<entry>Pointer to the datagram to be rewritten</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>(all fragment headers are modified)</entry>
</row>
<row>
<entry>fp</entry>
<entry>IP4Fragment *</entry>
<entry>Pointer to the fragment to rewrite</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>(only the single fragment header is modified)</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1353" lvl="7"><number>&lsqb;1353&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1354" lvl="0"><number>&lsqb;1354&rsqb;</number> None. </paragraph>
</section>
<section>
<heading lvl="1">EXAMPLE </heading>
<paragraph id="P-1355" lvl="0"><number>&lsqb;1355&rsqb;</number> For fragments, only the single fragment is modified. For datagrams, all comprising fragments are updated. The following simple example illustrates the use of one of these objects: </paragraph>
<paragraph id="P-1356" lvl="0"><number>&lsqb;1356&rsqb;</number> Assuming ipal is an address we wish to place in the IP packet&apos;s destination address field, buf points to the ASL buffer containing an IP packet we wish to rewrite, and iph points the IP header of the packet contained in the buffer: IPDNat *ipd&equals;new IPDNat(&amp;ipal); // create IP DNat object IP4Fragment ipf(buf, iph); // create IP fragment object ipd-&gt;rewrite(&amp;ipf); // rewrite fragment&apos;s header The use of other IP NAT objects follows a similar pattern. </paragraph>
<paragraph id="P-1357" lvl="0"><number>&lsqb;1357&rsqb;</number> 22. UDP NAT </paragraph>
<paragraph id="P-1358" lvl="0"><number>&lsqb;1358&rsqb;</number> The organization of the UDP NAT classes follows the IP NAT classes very closely. The primary difference is in the handling of UDP ports. For UDP NAT, the optional rewriting of port numbers (in addition to IP layer addresses) is specified in the constructor. </paragraph>
<paragraph id="P-1359" lvl="0"><number>&lsqb;1359&rsqb;</number> 23. UDPNat Base Class </paragraph>
<paragraph id="P-1360" lvl="0"><number>&lsqb;1360&rsqb;</number> The class UDPNat provides a base class for other UDP NAT classes. The constructor is given a value indicating whether port number rewriting is enabled. Because of the pure virtual function rewrite, applications will not create objects of type UDPNat directly, but rather use the objects of type UDPSNat, UDPDNat, and UDPSDNat defined below </paragraph>
<paragraph id="P-1361" lvl="1"><number>&lsqb;1361&rsqb;</number> Constructor </paragraph>
<paragraph id="P-1362" lvl="7"><number>&lsqb;1362&rsqb;</number> Description </paragraph>
<paragraph id="P-1363" lvl="0"><number>&lsqb;1363&rsqb;</number> The constructor is given a value indicating whether port number rewriting is enabled. </paragraph>
<paragraph id="P-1364" lvl="7"><number>&lsqb;1364&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1365" lvl="1"><number>&lsqb;1365&rsqb;</number> UDPNat(bool doports);  
<table-cwu id="TABLE-US-00103">
<number>103</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="28PT" align="left"/>
<colspec colname="3" colwidth="147PT" align="left"/>
<tbody valign="top">
<row>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>doports</entry>
<entry>bool</entry>
<entry>Boolean value indicating whether the port number</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>rewriting is enabled. A true value indicates port</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>number rewriting is enabled.</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1366" lvl="7"><number>&lsqb;1366&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1367" lvl="7"><number>&lsqb;1367&rsqb;</number> None. </paragraph>
<paragraph id="P-1368" lvl="1"><number>&lsqb;1368&rsqb;</number> rewrite </paragraph>
<paragraph id="P-1369" lvl="7"><number>&lsqb;1369&rsqb;</number> Description </paragraph>
<paragraph id="P-1370" lvl="0"><number>&lsqb;1370&rsqb;</number> This pure-virtual function is defined in derived classes. It performs address rewriting in a specific fashion implemented by the specific derived classes (i.e. source, destination, or source/destination combination). The rewrite call, as applied to a fragment, only affects the given fragment. When applied to a datagram, each of the fragment headers comprising the datagram are re-written. </paragraph>
<paragraph id="P-1371" lvl="7"><number>&lsqb;1371&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1372" lvl="1"><number>&lsqb;1372&rsqb;</number> virtual void rewrite(IP4Datagram*fp)&equals;0; </paragraph>
<paragraph id="P-1373" lvl="1"><number>&lsqb;1373&rsqb;</number> virtual void rewrite(IP4Fragment*fp)&equals;0;  
<table-cwu id="TABLE-US-00104">
<number>104</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="119PT" align="left"/>
<tbody valign="top">
<row>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>dp</entry>
<entry>IP4Datagram *</entry>
<entry>Pointer to the datagram to rewrite</entry>
</row>
<row>
<entry>fp</entry>
<entry>IP4Fragment *</entry>
<entry>Pointer to the single fragment to rewrite</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1374" lvl="7"><number>&lsqb;1374&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1375" lvl="0"><number>&lsqb;1375&rsqb;</number> None. </paragraph>
<paragraph id="P-1376" lvl="1"><number>&lsqb;1376&rsqb;</number> ports </paragraph>
<paragraph id="P-1377" lvl="7"><number>&lsqb;1377&rsqb;</number> Description </paragraph>
<paragraph id="P-1378" lvl="0"><number>&lsqb;1378&rsqb;</number> The first form of this function returns true if the NAT object is configured to rewrite port numbers. The second form of this function configures the object to enable or disable port number rewriting using the values true and false, respectively. </paragraph>
<paragraph id="P-1379" lvl="7"><number>&lsqb;1379&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1380" lvl="1"><number>&lsqb;1380&rsqb;</number> bool ports( ); </paragraph>
<paragraph id="P-1381" lvl="1"><number>&lsqb;1381&rsqb;</number> void ports(bool p);  
<table-cwu id="TABLE-US-00105">
<number>105</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="21PT" align="left"/>
<colspec colname="3" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>p</entry>
<entry>bool</entry>
<entry>Boolean containing whether port rewriting is enabled.</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1382" lvl="7"><number>&lsqb;1382&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1383" lvl="0"><number>&lsqb;1383&rsqb;</number> The first form of this function returns true if the NAT object is configured to rewrite UDP port numbers. </paragraph>
<paragraph id="P-1384" lvl="0"><number>&lsqb;1384&rsqb;</number> 24. UDPSNat Class </paragraph>
<paragraph id="P-1385" lvl="0"><number>&lsqb;1385&rsqb;</number> The UDPSNat class is derived from the UDPNat class. It defines the class of objects implementing source address and (optionally) port number rewriting for complete and fragmented UDP datagrams. </paragraph>
<paragraph id="P-1386" lvl="1"><number>&lsqb;1386&rsqb;</number> Constructors </paragraph>
<paragraph id="P-1387" lvl="7"><number>&lsqb;1387&rsqb;</number> Description </paragraph>
<paragraph id="P-1388" lvl="0"><number>&lsqb;1388&rsqb;</number> The single-argument constructor is used to create UDP NAT objects that rewrite only the addresses in the IP header (and update the IP header checksum and UDP pseudo-header checksum appropriately). The two-argument constructor is used to create NAT objects that also rewrite the source port number in the UDP header. For fragmented UDP datagrams, the port numbers will generally be present in only the first fragment. </paragraph>
<paragraph id="P-1389" lvl="7"><number>&lsqb;1389&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1390" lvl="1"><number>&lsqb;1390&rsqb;</number> UDPSNat(IP4Addr* newsaddr, nuint16 newsport); </paragraph>
<paragraph id="P-1391" lvl="1"><number>&lsqb;1391&rsqb;</number> UDPSNat(IP4Addr* newsaddr); </paragraph>
<paragraph id="P-1392" lvl="7"><number>&lsqb;1392&rsqb;</number> Parameters  
<table-cwu id="TABLE-US-00106">
<number>106</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="133PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>newsaddr</entry>
<entry>IP4Addr*</entry>
<entry>Pointer the new source address to be used</entry>
</row>
<row>
<entry>newsport</entry>
<entry>nuint16</entry>
<entry>The new source port number to be used</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1393" lvl="7"><number>&lsqb;1393&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1394" lvl="7"><number>&lsqb;1394&rsqb;</number> None. </paragraph>
<paragraph id="P-1395" lvl="1"><number>&lsqb;1395&rsqb;</number> rewrite </paragraph>
<paragraph id="P-1396" lvl="7"><number>&lsqb;1396&rsqb;</number> Description </paragraph>
<paragraph id="P-1397" lvl="0"><number>&lsqb;1397&rsqb;</number> Defines the pure virtual rewrite functions in the parent class. </paragraph>
<paragraph id="P-1398" lvl="7"><number>&lsqb;1398&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1399" lvl="1"><number>&lsqb;1399&rsqb;</number> void rewrite(IP4Datagram* dp); </paragraph>
<paragraph id="P-1400" lvl="1"><number>&lsqb;1400&rsqb;</number> void rewrite(IP4Fragment* fp);  
<table-cwu id="TABLE-US-00107">
<number>107</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="49PT" align="left"/>
<colspec colname="3" colwidth="133PT" align="left"/>
<tbody valign="top">
<row>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>dp</entry>
<entry>IP4Datagram*</entry>
<entry>Pointer to the datagram to be rewritten (all</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>fragment headers are modified)</entry>
</row>
<row>
<entry>fp</entry>
<entry>IP4Fragment*</entry>
<entry>Pointer to the fragment to rewrite (only the</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>single fragment header is modified). Should</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>only be called when the fragment represents</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>a complete UDP/IP datagram.</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1401" lvl="7"><number>&lsqb;1401&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1402" lvl="7"><number>&lsqb;1402&rsqb;</number> None. </paragraph>
<paragraph id="P-1403" lvl="0"><number>&lsqb;1403&rsqb;</number> 25. UDPDNat Class </paragraph>
<paragraph id="P-1404" lvl="0"><number>&lsqb;1404&rsqb;</number> The UDPDNat class is derived from the UDPNat class. It defines the class of objects implementing destination address and (optionally) port number rewriting for complete and fragmented UDP datagrams. </paragraph>
<paragraph id="P-1405" lvl="1"><number>&lsqb;1405&rsqb;</number> Constructors </paragraph>
<paragraph id="P-1406" lvl="7"><number>&lsqb;1406&rsqb;</number> Description </paragraph>
<paragraph id="P-1407" lvl="0"><number>&lsqb;1407&rsqb;</number> The single-argument constructor is used to create UDP NAT objects that rewrite only the addresses in the IP header (and update the IP header checksum and UDP pseudo-header checksum appropriately). The two-argument constructor is used to create NAT objects that also rewrite the destination port number in the UDP header. For fragmented UDP datagrams, the port numbers will generally be present in only the first fragment. </paragraph>
<paragraph id="P-1408" lvl="7"><number>&lsqb;1408&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1409" lvl="1"><number>&lsqb;1409&rsqb;</number> UDPSNat(IP4Addr* newdaddr, nuint16 newdport); </paragraph>
<paragraph id="P-1410" lvl="1"><number>&lsqb;1410&rsqb;</number> UDPSNat(IP4Addr* newdaddr);  
<table-cwu id="TABLE-US-00108">
<number>108</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="35PT" align="left"/>
<colspec colname="3" colwidth="147PT" align="left"/>
<tbody valign="top">
<row>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>newdaddr</entry>
<entry>IPAddr*</entry>
<entry>Pointer the new destination address to be used</entry>
</row>
<row>
<entry>newdport</entry>
<entry>nuint16</entry>
<entry>The new destination port number to be used</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1411" lvl="7"><number>&lsqb;1411&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1412" lvl="7"><number>&lsqb;1412&rsqb;</number> None. </paragraph>
<paragraph id="P-1413" lvl="1"><number>&lsqb;1413&rsqb;</number> rewrite </paragraph>
<paragraph id="P-1414" lvl="7"><number>&lsqb;1414&rsqb;</number> Description </paragraph>
<paragraph id="P-1415" lvl="0"><number>&lsqb;1415&rsqb;</number> Defines the pure virtual rewrite functions in the parent class. </paragraph>
<paragraph id="P-1416" lvl="7"><number>&lsqb;1416&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1417" lvl="1"><number>&lsqb;1417&rsqb;</number> void rewrite(IP4Datagram* dp); </paragraph>
<paragraph id="P-1418" lvl="1"><number>&lsqb;1418&rsqb;</number> void rewrite(IP4Fragment* fp);  
<table-cwu id="TABLE-US-00109">
<number>109</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="49PT" align="left"/>
<colspec colname="3" colwidth="133PT" align="left"/>
<tbody valign="top">
<row>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>dp</entry>
<entry>IP4Datagram*</entry>
<entry>Pointer to the datagram to be rewritten (all</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>fragment headers are modified)</entry>
</row>
<row>
<entry>fp</entry>
<entry>IP4Fragment*</entry>
<entry>Pointer to the fragment to rewrite (only the</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>single fragment header is modified). Should</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>only be called when the fragment represents</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>a complete UDP/IP datagram.</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1419" lvl="7"><number>&lsqb;1419&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1420" lvl="7"><number>&lsqb;1420&rsqb;</number> None. </paragraph>
<paragraph id="P-1421" lvl="0"><number>&lsqb;1421&rsqb;</number> 26. UDPSDNat Class </paragraph>
<paragraph id="P-1422" lvl="0"><number>&lsqb;1422&rsqb;</number> The UDPSDNat class is derived from the UDPNat class. It defines the class of objects implementing source and destination address and (optionally) port number rewriting for complete and fragmented UDP datagrams. </paragraph>
<paragraph id="P-1423" lvl="1"><number>&lsqb;1423&rsqb;</number> Constructors </paragraph>
<paragraph id="P-1424" lvl="7"><number>&lsqb;1424&rsqb;</number> Description </paragraph>
<paragraph id="P-1425" lvl="0"><number>&lsqb;1425&rsqb;</number> The two-argument constructor is used to create UDP NAT objects that rewrite only the addresses in the IP header (and update the IP header checksum and UDP pseudo-header checksum appropriately). The four-argument constructor is used to create NAT objects that also rewrite the source and destination port number in the UDP header. For fragmented UDP datagrams, the port numbers will generally be present in only the first fragment. </paragraph>
<paragraph id="P-1426" lvl="7"><number>&lsqb;1426&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1427" lvl="1"><number>&lsqb;1427&rsqb;</number> UDPSNat(IP4Addr* newsaddr, nuint16 newsport, IP4Addr* newdaddr, nuint16 newdport); </paragraph>
<paragraph id="P-1428" lvl="1"><number>&lsqb;1428&rsqb;</number> UDPSNat(IP4Addr* newsaddr, IP4Addr* newdaddr);  
<table-cwu id="TABLE-US-00110">
<number>110</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="35PT" align="left"/>
<colspec colname="3" colwidth="147PT" align="left"/>
<tbody valign="top">
<row>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>newsaddr</entry>
<entry>IP4Addr*</entry>
<entry>Pointer the new source address to be used</entry>
</row>
<row>
<entry>newsport</entry>
<entry>nuint16</entry>
<entry>The new source port number to be used</entry>
</row>
<row>
<entry>newdaddr</entry>
<entry>IP4Addr*</entry>
<entry>Pointer the new destination address to be used</entry>
</row>
<row>
<entry>newdport</entry>
<entry>nuint16</entry>
<entry>The new destination port number to be used</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1429" lvl="7"><number>&lsqb;1429&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1430" lvl="7"><number>&lsqb;1430&rsqb;</number> None. </paragraph>
<paragraph id="P-1431" lvl="1"><number>&lsqb;1431&rsqb;</number> rewrite </paragraph>
<paragraph id="P-1432" lvl="7"><number>&lsqb;1432&rsqb;</number> Description </paragraph>
<paragraph id="P-1433" lvl="0"><number>&lsqb;1433&rsqb;</number> Defines the pure virtual rewrite functions in the parent class. </paragraph>
<paragraph id="P-1434" lvl="7"><number>&lsqb;1434&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1435" lvl="1"><number>&lsqb;1435&rsqb;</number> void rewrite(IP4Datagram* dp); </paragraph>
<paragraph id="P-1436" lvl="1"><number>&lsqb;1436&rsqb;</number> void rewrite(IP4Fragment* fp);  
<table-cwu id="TABLE-US-00111">
<number>111</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="49PT" align="left"/>
<colspec colname="3" colwidth="133PT" align="left"/>
<tbody valign="top">
<row>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>dp</entry>
<entry>IP4Datagram*</entry>
<entry>Pointer to the datagram to be rewritten (all</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>fragment headers are modified)</entry>
</row>
<row>
<entry>fp</entry>
<entry>IP4Fragment*</entry>
<entry>Pointer to the fragment to rewrite (only the</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>single fragment header is modified). Should</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>only be called when the fragment represents</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>a complete UDP/IP datagram.</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1437" lvl="7"><number>&lsqb;1437&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1438" lvl="7"><number>&lsqb;1438&rsqb;</number> None. </paragraph>
<paragraph id="P-1439" lvl="0"><number>&lsqb;1439&rsqb;</number> 27. TCPNAT </paragraph>
<paragraph id="P-1440" lvl="0"><number>&lsqb;1440&rsqb;</number> The structure of the TCP NAT support classes follow the UDP classes very closely. The primary difference is in the handling of TCP sequence and ACK numbers. </paragraph>
<paragraph id="P-1441" lvl="0"><number>&lsqb;1441&rsqb;</number> 28. TCPNat Base Class </paragraph>
<paragraph id="P-1442" lvl="0"><number>&lsqb;1442&rsqb;</number> The class TCPNat provides a base class for other TCP NAT classes. The constructor is given a pair of values indicating whether port number, sequence number, and acknowledgement number rewriting is enabled. Sequence number and ACK number rewriting are coupled such that enabling sequence number rewriting for source-rewriting will modify the sequence number field of the TCP segment, but enabling sequence number rewriting for destination-rewriting will instead modify the ACK field. This arrangement makes it possible to perform NAT on TCP streams without unnecessary complexity in the TCP NAT interface. Because of the pure virtual function rewrite, applications will not create objects of type TCPNat directly, but rather use the objects of type TCPSNat, TCPDNat, and TCPSDNat defined below. </paragraph>
<paragraph id="P-1443" lvl="1"><number>&lsqb;1443&rsqb;</number> Constructor </paragraph>
<paragraph id="P-1444" lvl="7"><number>&lsqb;1444&rsqb;</number> Description </paragraph>
<paragraph id="P-1445" lvl="0"><number>&lsqb;1445&rsqb;</number> The constructor is given a value indicating whether port number rewriting is enabled. </paragraph>
<paragraph id="P-1446" lvl="7"><number>&lsqb;1446&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1447" lvl="1"><number>&lsqb;1447&rsqb;</number> TCPNat(bool doports, bool doseqs);  
<table-cwu id="TABLE-US-00112">
<number>112</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="21PT" align="left"/>
<colspec colname="3" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>doports</entry>
<entry>bool</entry>
<entry>Boolean value indicating whether the port number</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>rewriting is enabled. A true value indicates port</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>number rewriting is enabled.</entry>
</row>
<row>
<entry>doseqs</entry>
<entry>bool</entry>
<entry>Boolean value indicating whether the sequence/ACK</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>number rewriting is enabled. A true value indicates</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>sequence/ACK number rewriting is enabled.</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1448" lvl="7"><number>&lsqb;1448&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1449" lvl="7"><number>&lsqb;1449&rsqb;</number> None. </paragraph>
<paragraph id="P-1450" lvl="1"><number>&lsqb;1450&rsqb;</number> rewrite </paragraph>
<paragraph id="P-1451" lvl="7"><number>&lsqb;1451&rsqb;</number> Description </paragraph>
<paragraph id="P-1452" lvl="0"><number>&lsqb;1452&rsqb;</number> This pure-virtual function is defined in derived classes It performs address rewriting in a specific fashion implemented by the specific derived classes (i.e. source, destination, or source/destination combination). The rewrite call, as applied to a fragment, only affects the given fragment. When applied to a datagram, each of the fragment headers comprising the datagram are rewritten. </paragraph>
<paragraph id="P-1453" lvl="7"><number>&lsqb;1453&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1454" lvl="1"><number>&lsqb;1454&rsqb;</number> virtual void rewrite(IP4Datagram* dp)&equals;0; </paragraph>
<paragraph id="P-1455" lvl="1"><number>&lsqb;1455&rsqb;</number> virtual void rewrite(IP4Fragment* fp)&equals;0;  
<table-cwu id="TABLE-US-00113">
<number>113</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="126PT" align="left"/>
<tbody valign="top">
<row>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>dp</entry>
<entry>IP4Datagram*</entry>
<entry>Pointer to the datagram to rewrite</entry>
</row>
<row>
<entry>fp</entry>
<entry>IP4Fragment*</entry>
<entry>Pointer to the single fragment to rewrite</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1456" lvl="7"><number>&lsqb;1456&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1457" lvl="7"><number>&lsqb;1457&rsqb;</number> None. </paragraph>
<paragraph id="P-1458" lvl="1"><number>&lsqb;1458&rsqb;</number> ports </paragraph>
<paragraph id="P-1459" lvl="7"><number>&lsqb;1459&rsqb;</number> Description </paragraph>
<paragraph id="P-1460" lvl="0"><number>&lsqb;1460&rsqb;</number> The first form of this function returns true if the NAT object is configured to rewrite port numbers. The second form of this function configures the object to enable or disable port number rewriting using the values true and false, respectively. </paragraph>
<paragraph id="P-1461" lvl="7"><number>&lsqb;1461&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1462" lvl="1"><number>&lsqb;1462&rsqb;</number> bool ports( ); </paragraph>
<paragraph id="P-1463" lvl="1"><number>&lsqb;1463&rsqb;</number> void ports(bool p);  
<table-cwu id="TABLE-US-00114">
<number>114</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="28PT" align="left"/>
<colspec colname="3" colwidth="154PT" align="left"/>
<tbody valign="top">
<row>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>p</entry>
<entry>bool</entry>
<entry>Boolean indicating whether port number rewriting</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>is enabled.</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1464" lvl="7"><number>&lsqb;1464&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1465" lvl="0"><number>&lsqb;1465&rsqb;</number> The first form of this function returns true if the NAT object is configured to rewrite TCP port numbers. </paragraph>
<paragraph id="P-1466" lvl="1"><number>&lsqb;1466&rsqb;</number> seqs </paragraph>
<paragraph id="P-1467" lvl="7"><number>&lsqb;1467&rsqb;</number> Description </paragraph>
<paragraph id="P-1468" lvl="0"><number>&lsqb;1468&rsqb;</number> The first form of this function returns true if the NAT object is configured to rewrite sequence/ACK numbers. The second form of this function configures the object to enable or disable sequence/ACK number rewriting using the values true and false, respectively. </paragraph>
<paragraph id="P-1469" lvl="7"><number>&lsqb;1469&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1470" lvl="1"><number>&lsqb;1470&rsqb;</number> bool seqs( ); </paragraph>
<paragraph id="P-1471" lvl="1"><number>&lsqb;1471&rsqb;</number> void seqs(bool s);  
<table-cwu id="TABLE-US-00115">
<number>115</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="21PT" align="left"/>
<colspec colname="3" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>s</entry>
<entry>bool</entry>
<entry>Boolean indicating whether sequence/ACK number</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>rewriting is enabled.</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1472" lvl="7"><number>&lsqb;1472&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1473" lvl="0"><number>&lsqb;1473&rsqb;</number> The first form of this function returns true if the NAT object is configured to rewrite TCP port numbers. </paragraph>
<paragraph id="P-1474" lvl="0"><number>&lsqb;1474&rsqb;</number> 29. TCPSNat Class </paragraph>
<paragraph id="P-1475" lvl="0"><number>&lsqb;1475&rsqb;</number> The TCPSNat class is derived from the TCPNat class. It defines the class of objects implementing source address and (optionally) port number and sequence number rewriting for complete and fragmented TCP segments. </paragraph>
<paragraph id="P-1476" lvl="1"><number>&lsqb;1476&rsqb;</number> Constructors </paragraph>
<paragraph id="P-1477" lvl="7"><number>&lsqb;1477&rsqb;</number> Description </paragraph>
<paragraph id="P-1478" lvl="0"><number>&lsqb;1478&rsqb;</number> The single-argument constructor is used to create TCP NAT objects that rewrite only the addresses in the IP header (and update the IP header checksum and TCP pseudo-header checksum appropriately). The two-argument constructor is used to create NAT objects that also rewrite the source port number in the TCP header. The three-argument constructor is used to rewrite the IP address, source port number, and to modify the TCP sequence number by a relative (constant) amount. The sequence offset provided may be positive or negative. </paragraph>
<paragraph id="P-1479" lvl="7"><number>&lsqb;1479&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1480" lvl="1"><number>&lsqb;1480&rsqb;</number> TCPSNat(IP4Addr* newsaddr); </paragraph>
<paragraph id="P-1481" lvl="1"><number>&lsqb;1481&rsqb;</number> TCPSNat(IP4Addr* newsaddr, nuint16 newsport); </paragraph>
<paragraph id="P-1482" lvl="1"><number>&lsqb;1482&rsqb;</number> TCPSNat(IP4Addr* newsaddr, nuint16 newsport, long seqoff)  
<table-cwu id="TABLE-US-00116">
<number>116</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="35PT" align="left"/>
<colspec colname="3" colwidth="147PT" align="left"/>
<tbody valign="top">
<row>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>newsaddr</entry>
<entry>IP4Addr*</entry>
<entry>Pointer the new source address to be used</entry>
</row>
<row>
<entry>newsport</entry>
<entry>nuint16</entry>
<entry>The new source port number to be used</entry>
</row>
<row>
<entry>seqoff</entry>
<entry>long</entry>
<entry>Relative change to make to TCP sequence number</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>fields. A positive value indicates the TCP</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>sequence number is increased by the amount</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>specified. A negative value indicates the sequence</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>number is reduced by the amount specified.</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1483" lvl="7"><number>&lsqb;1483&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1484" lvl="7"><number>&lsqb;1484&rsqb;</number> None. </paragraph>
<paragraph id="P-1485" lvl="1"><number>&lsqb;1485&rsqb;</number> rewrite </paragraph>
<paragraph id="P-1486" lvl="7"><number>&lsqb;1486&rsqb;</number> Description </paragraph>
<paragraph id="P-1487" lvl="0"><number>&lsqb;1487&rsqb;</number> Defines the pure virtual rewrite functions in the parent class. </paragraph>
<paragraph id="P-1488" lvl="7"><number>&lsqb;1488&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1489" lvl="1"><number>&lsqb;1489&rsqb;</number> void rewrite(IP4Datagram* dp); </paragraph>
<paragraph id="P-1490" lvl="1"><number>&lsqb;1490&rsqb;</number> void rewrite(IP4Fragment* fp);  
<table-cwu id="TABLE-US-00117">
<number>117</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="49PT" align="left"/>
<colspec colname="3" colwidth="133PT" align="left"/>
<tbody valign="top">
<row>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>dp</entry>
<entry>IP4Datagram*</entry>
<entry>Pointer to the datagram to be rewritten (all</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>fragment headers are modified)</entry>
</row>
<row>
<entry>fp</entry>
<entry>IP4Fragment*</entry>
<entry>Pointer to the fragment to rewrite (only the</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>single fragment header is modified). Should</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>only be called when the fragment represents</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>a complete TCP/IP segment.</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1491" lvl="7"><number>&lsqb;1491&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1492" lvl="7"><number>&lsqb;1492&rsqb;</number> None. </paragraph>
<paragraph id="P-1493" lvl="0"><number>&lsqb;1493&rsqb;</number> 30. TCPSDNat Class </paragraph>
<paragraph id="P-1494" lvl="0"><number>&lsqb;1494&rsqb;</number> The TCPSDNat class is derived from the TCPNat class. It defines the class of objects implementing source address and (optionally) port number and sequence number/ACK number rewriting for complete and fragmented TCP segments. </paragraph>
<paragraph id="P-1495" lvl="1"><number>&lsqb;1495&rsqb;</number> Constructors </paragraph>
<paragraph id="P-1496" lvl="7"><number>&lsqb;1496&rsqb;</number> Description </paragraph>
<paragraph id="P-1497" lvl="0"><number>&lsqb;1497&rsqb;</number> The two-argument constructor is used to create TCP NAT objects that rewrite only the addresses in the IP header (and update the IP header checksum and TCP pseudo-header checksum appropriately). The four-argument constructor is used to create NAT objects that also rewrite the source and destination port numbers in the TCP header. The three-argument constructor is used to rewrite the IP address, source port number, and to modify the TCP ACK number by a relative (constant) amount. The ACK offset provided may be positive or negative </paragraph>
<paragraph id="P-1498" lvl="7"><number>&lsqb;1498&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1499" lvl="1"><number>&lsqb;1499&rsqb;</number> TCPSDNat(IP4Addr* newsaddr, IP4Addr* newdaddr); </paragraph>
<paragraph id="P-1500" lvl="1"><number>&lsqb;1500&rsqb;</number> TCPSDNat(IP4Addr* newsaddr, nuint16 newsport, IP4Addr* newdaddr, nuint16 newdport); </paragraph>
<paragraph id="P-1501" lvl="1"><number>&lsqb;1501&rsqb;</number> TCPSDNat(IP4Addr* newsaddr, nuint16 newsport, long seqoff, </paragraph>
<paragraph id="P-1502" lvl="1"><number>&lsqb;1502&rsqb;</number> IP4Addr* newdaddr, nuint16 newdport, long ackoff);  
<table-cwu id="TABLE-US-00118">
<number>118</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="35PT" align="left"/>
<colspec colname="3" colwidth="147PT" align="left"/>
<tbody valign="top">
<row>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>newsaddr</entry>
<entry>IP4Addr*</entry>
<entry>The new source address to be used</entry>
</row>
<row>
<entry>newsport</entry>
<entry>nuint16</entry>
<entry>The new source port number to be used</entry>
</row>
<row>
<entry>seqoff</entry>
<entry>long</entry>
<entry>Relative change to make to TCP sequence number</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>fields. A positive value indicates the TCP</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>sequence number is increased by the amount</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>specified. A negative value indicates the sequence</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>number is reduced by the amount specified.</entry>
</row>
<row>
<entry>newdaddr</entry>
<entry>IP4Addr*</entry>
<entry>The new destination address to be used</entry>
</row>
<row>
<entry>newdport</entry>
<entry>nuint16</entry>
<entry>The new destination port number to be used</entry>
</row>
<row>
<entry>ackoff</entry>
<entry>long</entry>
<entry>Relative change to make to TCP ACK number</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>fields. A positive value indicates the TCP ACK</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>number is increased by the amount specified.</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>A negative value indicates the ACK number is</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>reduced by the amount specified.</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1503" lvl="7"><number>&lsqb;1503&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1504" lvl="7"><number>&lsqb;1504&rsqb;</number> None. </paragraph>
<paragraph id="P-1505" lvl="1"><number>&lsqb;1505&rsqb;</number> rewrite </paragraph>
<paragraph id="P-1506" lvl="7"><number>&lsqb;1506&rsqb;</number> Description </paragraph>
<paragraph id="P-1507" lvl="0"><number>&lsqb;1507&rsqb;</number> Defines the pure virtual rewrite functions in the parent class. </paragraph>
<paragraph id="P-1508" lvl="7"><number>&lsqb;1508&rsqb;</number> Syntax </paragraph>
<paragraph id="P-1509" lvl="1"><number>&lsqb;1509&rsqb;</number> void rewrite(IP4Datagram* dp); </paragraph>
<paragraph id="P-1510" lvl="1"><number>&lsqb;1510&rsqb;</number> void rewrite(IP4Fragment* fp);  
<table-cwu id="TABLE-US-00119">
<number>119</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="49PT" align="left"/>
<colspec colname="3" colwidth="133PT" align="left"/>
<tbody valign="top">
<row>
<entry>Parameter</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>dp</entry>
<entry>IP4Datagram*</entry>
<entry>Pointer to the datagram to be rewritten (all</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>fragment headers are modified)</entry>
</row>
<row>
<entry>fp</entry>
<entry>IP4Fragment*</entry>
<entry>Pointer to the fragment to rewrite (only the</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>single fragment header is modified). Should</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>only be called when the fragment represents</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>a complete TCP/IP segment.</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-1511" lvl="7"><number>&lsqb;1511&rsqb;</number> Return Value </paragraph>
<paragraph id="P-1512" lvl="7"><number>&lsqb;1512&rsqb;</number> None. </paragraph>
<paragraph id="P-1513" lvl="0"><number>&lsqb;1513&rsqb;</number> Those skilled in the art will appreciate variations of the above described embodiments. In addition to these embodiments, other variations will be appreciated by those skilled in the art. As such, the scope of the invention is not limited to the specified embodiments, but is defined by the following claims. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method of checking cumulative status of a plurality of arithmetic operations, the method comprising: 
<claim-text>initializing a first condition code to a first value; </claim-text>
<claim-text>performing the plurality of arithmetic operations, a result of at least one of the plurality of arithmetic operations being capable of indicating whether a criterion is met; </claim-text>
<claim-text>if the result of at least one of the plurality of arithmetic operations indicates the criterion is met, then initializing the first condition code to a second value; </claim-text>
<claim-text>keeping the first condition code unchanged for a remainder of the plurality of arithmetic operations once the first condition code is initialized to the second value; and </claim-text>
<claim-text>performing a test on the first condition code, </claim-text>
<claim-text>wherein a status of the first condition code indicates a cumulative status of the performed plurality of arithmetic operations. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein the criterion is an item selected from a list comprising the result being non-zero, the result being zero, the result being greater than zero, and the result being less than zero. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein the first condition code is initialized by a non-arithmetic operation. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein the plurality of arithmetic operations are selected from a group comprising a comparison operation and a subtract operation. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein the result of at least one of the plurality of arithmetic operations returns an item selected from a list comprising data equal non-zero, data equal zero, data greater than zero, and data less than zero. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein the first value is non-zero. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein the second value is a zero. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. An apparatus to check cumulative status of a plurality of arithmetic operations, the apparatus comprising: 
<claim-text>first initializing means to initialize a first condition code to a first value; </claim-text>
<claim-text>processing means to perform the plurality of arithmetic operations, a result of at least one of the plurality of arithmetic operations being capable of indicating whether a criterion is met; </claim-text>
<claim-text>second initializing means to initialize the first condition code to a second value; and </claim-text>
<claim-text>test means to perform a test on the first condition code, </claim-text>
<claim-text>wherein the first condition code remains unchanged for a remainder of the plurality of arithmetic operations once the first condition code is initialized to the second value. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference> wherein the first condition code is initialized by a non-arithmetic operation. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference> wherein the plurality of arithmetic operations are selected from a group comprising a comparison operation and a subtract operation. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference> wherein the first value is non-zero. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference> wherein the second value is a zero. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. A system comprising: 
<claim-text>at least one classification engine to classify a selected portion of a plurality of packets; and </claim-text>
<claim-text>an apparatus to check cumulative status of a plurality of arithmetic operations comprising: 
<claim-text>a first facility to initialize a first condition code to a first value; </claim-text>
<claim-text>a second facility to perform the plurality of arithmetic operations, a result of at least one of the plurality of arithmetic operations being capable of indicating whether a criterion is met; and </claim-text>
<claim-text>a third facility to initialize the first condition code to a second value if the result of at least one of the plurality of arithmetic operations indicates the criterion is met. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference> further including a fourth facility to perform a test on the first condition code. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference> wherein once the first condition code is initialized to the second value the first condition code remains unchanged for a remainder of the plurality of arithmetic operations. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference> wherein the plurality of arithmetic operations are selected from a group comprising a comparison operation and a subtract operation. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference> wherein the first value is non-zero. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference> wherein the second value is a zero. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference> wherein the classification engine includes a micro-programmed processor. </claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference> wherein the micro-programmed processor selectively processes the selected portion of the plurality of packets by performing thereon at least a subset of packet-based operations including packet header parsing and table lookups. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00022">claim 20</dependent-claim-reference> wherein the table lookups utilize hash tables. </claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference> wherein a classified packet is returned to the classification engine to be reclassified. </claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference> wherein the classification engine receives a plurality of classification policies to indicate how the classification engine classifies a packet based on select information from a group comprising packet header parsing and table lookups. </claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00022">claim 23</dependent-claim-reference> wherein the classification policies are supplied dynamically from an application processor. </claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference> further including an application processor having a host interface. </claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference> further comprising a plurality of data buffers to store data utilized by the system. </claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference> further including an embedded processor to provide processing capabilities to the system. </claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. A machine-readable medium that provides instructions which, when executed by a machine, cause the machine to perform operations comprising: 
<claim-text>initializing a first condition code to a first value; </claim-text>
<claim-text>performing a plurality of arithmetic operations, a result of at least one of the plurality of arithmetic operations being capable of indicating whether a criterion is met; </claim-text>
<claim-text>if the result of at least one of the plurality of arithmetic operations indicates the criterion is met, then initializing the first condition code to a second value; and </claim-text>
<claim-text>keeping the first condition code unchanged for a remainder of the plurality of arithmetic operations once the first condition code is initialized to the second value. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00029">
<claim-text><highlight><bold>29</bold></highlight>. The medium of <dependent-claim-reference depends_on="CLM-00022">claim 28</dependent-claim-reference> further performing a test on the first condition code. </claim-text>
</claim>
<claim id="CLM-00030">
<claim-text><highlight><bold>30</bold></highlight>. The medium of <dependent-claim-reference depends_on="CLM-00022">claim 28</dependent-claim-reference> wherein a status of the first condition code indicates a cumulative status of the performed plurality of arithmetic operations. </claim-text>
</claim>
<claim id="CLM-00031">
<claim-text><highlight><bold>31</bold></highlight>. The medium of <dependent-claim-reference depends_on="CLM-00022">claim 28</dependent-claim-reference> wherein the plurality of arithmetic operations are selected from a group comprising a comparison operation and a subtract operation. </claim-text>
</claim>
<claim id="CLM-00032">
<claim-text><highlight><bold>32</bold></highlight>. The medium of <dependent-claim-reference depends_on="CLM-00022">claim 28</dependent-claim-reference> wherein the first value is non-zero. </claim-text>
</claim>
<claim id="CLM-00033">
<claim-text><highlight><bold>33</bold></highlight>. The medium of <dependent-claim-reference depends_on="CLM-00022">claim 28</dependent-claim-reference> wherein the second value is a zero. </claim-text>
</claim>
<claim id="CLM-00034">
<claim-text><highlight><bold>34</bold></highlight>. An apparatus to check cumulative status of a plurality of arithmetic operations comprising: 
<claim-text>a first facility to initialize a first condition code to a first value; </claim-text>
<claim-text>a second facility to perform the plurality of arithmetic operations, a result of at least one of the plurality of arithmetic operations being capable of indicating whether a criterion is met; </claim-text>
<claim-text>a third facility to initialize the first condition code to a second value if the result of at least one of the plurality of arithmetic operations indicates the criterion is met; and </claim-text>
<claim-text>a fourth facility to perform a test on the first condition code, </claim-text>
<claim-text>wherein once the first condition code is initialized to the second value the first condition code remains unchanged for a remainder of the plurality of arithmetic operations. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00035">
<claim-text><highlight><bold>35</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00033">claim 34</dependent-claim-reference> wherein the plurality of arithmetic operations are selected from a group comprising a comparison operation and a subtract operation. </claim-text>
</claim>
<claim id="CLM-00036">
<claim-text><highlight><bold>36</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00033">claim 34</dependent-claim-reference> wherein the first value is non-zero. </claim-text>
</claim>
<claim id="CLM-00037">
<claim-text><highlight><bold>37</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00033">claim 34</dependent-claim-reference> wherein the second value is a zero. </claim-text>
</claim>
<claim id="CLM-00038">
<claim-text><highlight><bold>38</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00033">claim 34</dependent-claim-reference> further including a micro-programmed processor. </claim-text>
</claim>
<claim id="CLM-00039">
<claim-text><highlight><bold>39</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00033">claim 34</dependent-claim-reference> further including an application processor having a host interface. </claim-text>
</claim>
<claim id="CLM-00040">
<claim-text><highlight><bold>40</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00033">claim 34</dependent-claim-reference> further comprising a plurality of data buffers to store data utilized by the apparatus. </claim-text>
</claim>
<claim id="CLM-00041">
<claim-text><highlight><bold>41</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00033">claim 34</dependent-claim-reference> further including an embedded processor to provide processing capabilities to the apparatus. </claim-text>
</claim>
<claim id="CLM-00042">
<claim-text><highlight><bold>42</bold></highlight>. A method of checking cumulative status of a plurality of arithmetic operations, the method comprising: 
<claim-text>initializing a first condition code to a first value; </claim-text>
<claim-text>performing the plurality of arithmetic operations, a result of at least one of the plurality of arithmetic operations being capable of indicating whether a criterion is met; </claim-text>
<claim-text>if the result of at least one of the plurality of arithmetic operations indicates the criterion is met, then initializing the first condition code to a second value; and </claim-text>
<claim-text>performing a test on the first condition code, </claim-text>
<claim-text>wherein a status of the first condition code indicates a cumulative status of the performed plurality of arithmetic operations. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00043">
<claim-text><highlight><bold>43</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00044">claim 42</dependent-claim-reference> wherein once the first condition code is initialized to the second value the first condition code remains unchanged for a remainder of the plurality of arithmetic operations. </claim-text>
</claim>
<claim id="CLM-00044">
<claim-text><highlight><bold>44</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00044">claim 42</dependent-claim-reference> wherein the criterion is an item selected from a list comprising the result being non-zero, the result being zero, the result being greater than zero, and the result being less than zero. </claim-text>
</claim>
<claim id="CLM-00045">
<claim-text><highlight><bold>45</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00044">claim 42</dependent-claim-reference> wherein the first condition code is initialized by a non-arithmetic operation. </claim-text>
</claim>
<claim id="CLM-00046">
<claim-text><highlight><bold>46</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00044">claim 42</dependent-claim-reference> wherein the plurality of arithmetic operations are selected from a group comprising a comparison operation and a subtract operation. </claim-text>
</claim>
<claim id="CLM-00047">
<claim-text><highlight><bold>47</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00044">claim 42</dependent-claim-reference> wherein the result of at least one of the plurality of arithmetic operations returns an item selected from a list comprising data equal non-zero, data equal zero, data greater than zero, and data less than zero. </claim-text>
</claim>
<claim id="CLM-00048">
<claim-text><highlight><bold>48</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00044">claim 42</dependent-claim-reference> wherein the first value is non-zero. </claim-text>
</claim>
<claim id="CLM-00049">
<claim-text><highlight><bold>49</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00044">claim 42</dependent-claim-reference> wherein the second value is a zero. </claim-text>
</claim>
<claim id="CLM-00050">
<claim-text><highlight><bold>50</bold></highlight>. An apparatus to check cumulative status of a plurality of arithmetic operations, the apparatus comprising: 
<claim-text>a first initializer to initialize a first condition code to a first value; </claim-text>
<claim-text>a processor to perform the plurality of arithmetic operations, a result of at least one of the plurality of arithmetic operations being capable of indicating whether a criterion is met; </claim-text>
<claim-text>a second initializer to initialize the first condition code to a second value; and </claim-text>
<claim-text>a tester to perform a test on the first condition code, </claim-text>
<claim-text>wherein the first condition code remains unchanged for a remainder of the plurality of arithmetic operations once the first condition code is initialized to the second value. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00051">
<claim-text><highlight><bold>51</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00055">claim 50</dependent-claim-reference> wherein the first condition code is initialized by a non-arithmetic operation. </claim-text>
</claim>
<claim id="CLM-00052">
<claim-text><highlight><bold>52</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00055">claim 50</dependent-claim-reference> wherein the plurality of arithmetic operations are selected from a group comprising a comparison operation and a subtract operation. </claim-text>
</claim>
<claim id="CLM-00053">
<claim-text><highlight><bold>53</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00055">claim 50</dependent-claim-reference> wherein the first value is non-zero. </claim-text>
</claim>
<claim id="CLM-00054">
<claim-text><highlight><bold>54</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00055">claim 50</dependent-claim-reference> wherein the second value is a zero. </claim-text>
</claim>
<claim id="CLM-00055">
<claim-text><highlight><bold>55</bold></highlight>. An apparatus to check cumulative status of a plurality of arithmetic operations comprising: 
<claim-text>a first initializer to initialize a first condition code to a first value; </claim-text>
<claim-text>a first circuit to perform the plurality of arithmetic operations, a result of at least one of the plurality of arithmetic operations being capable of indicating whether a criterion is met; </claim-text>
<claim-text>a second initializer to initialize the first condition code to a second value if the result of at least one of the plurality of arithmetic operations indicates the criterion is met; and </claim-text>
<claim-text>a second circuit to perform a test on the first condition code, </claim-text>
<claim-text>wherein once the first condition code is initialized to the second value the first condition code remains unchanged for a remainder of the plurality of arithmetic operations. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00056">
<claim-text><highlight><bold>56</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00055">claim 55</dependent-claim-reference> wherein the plurality of arithmetic operations are selected from a group comprising a comparison operation and a subtract operation. </claim-text>
</claim>
<claim id="CLM-00057">
<claim-text><highlight><bold>57</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00055">claim 55</dependent-claim-reference> wherein the first value is non-zero. </claim-text>
</claim>
<claim id="CLM-00058">
<claim-text><highlight><bold>58</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00055">claim 55</dependent-claim-reference> wherein the second value is a zero. </claim-text>
</claim>
<claim id="CLM-00059">
<claim-text><highlight><bold>59</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00055">claim 55</dependent-claim-reference> further including a micro-programmed processor. </claim-text>
</claim>
<claim id="CLM-00060">
<claim-text><highlight><bold>60</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00055">claim 59</dependent-claim-reference> wherein the first and second circuits utilize the micro-programmed processor to perform their tasks. </claim-text>
</claim>
<claim id="CLM-00061">
<claim-text><highlight><bold>61</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00055">claim 55</dependent-claim-reference> further including an application processor having a host interface. </claim-text>
</claim>
<claim id="CLM-00062">
<claim-text><highlight><bold>62</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00055">claim 55</dependent-claim-reference> further comprising a plurality of data buffers to store data utilized by the apparatus. </claim-text>
</claim>
<claim id="CLM-00063">
<claim-text><highlight><bold>63</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00055">claim 55</dependent-claim-reference> further including an embedded processor to provide processing capabilities to the apparatus. </claim-text>
</claim>
<claim id="CLM-00064">
<claim-text><highlight><bold>64</bold></highlight>. The apparatus of claim <highlight><bold>63</bold></highlight> wherein the first and second circuits utilize the embedded processor to perform their tasks.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>1</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005103A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005103A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005103A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005103A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005103A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005103A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030005103A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030005103A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030005103A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00009">
<image id="EMI-D00009" file="US20030005103A1-20030102-D00009.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00010">
<image id="EMI-D00010" file="US20030005103A1-20030102-D00010.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00011">
<image id="EMI-D00011" file="US20030005103A1-20030102-D00011.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00012">
<image id="EMI-D00012" file="US20030005103A1-20030102-D00012.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00013">
<image id="EMI-D00013" file="US20030005103A1-20030102-D00013.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00014">
<image id="EMI-D00014" file="US20030005103A1-20030102-D00014.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00015">
<image id="EMI-D00015" file="US20030005103A1-20030102-D00015.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00016">
<image id="EMI-D00016" file="US20030005103A1-20030102-D00016.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00017">
<image id="EMI-D00017" file="US20030005103A1-20030102-D00017.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00018">
<image id="EMI-D00018" file="US20030005103A1-20030102-D00018.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00019">
<image id="EMI-D00019" file="US20030005103A1-20030102-D00019.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
