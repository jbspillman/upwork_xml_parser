<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030004998A1-20030102-D00000.TIF SYSTEM "US20030004998A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030004998A1-20030102-D00001.TIF SYSTEM "US20030004998A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030004998A1-20030102-D00002.TIF SYSTEM "US20030004998A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030004998A1-20030102-D00003.TIF SYSTEM "US20030004998A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030004998A1-20030102-D00004.TIF SYSTEM "US20030004998A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030004998A1-20030102-D00005.TIF SYSTEM "US20030004998A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030004998A1-20030102-D00006.TIF SYSTEM "US20030004998A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030004998A1-20030102-D00007.TIF SYSTEM "US20030004998A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030004998A1-20030102-D00008.TIF SYSTEM "US20030004998A1-20030102-D00008.TIF" NDATA TIF>
<!ENTITY US20030004998A1-20030102-D00009.TIF SYSTEM "US20030004998A1-20030102-D00009.TIF" NDATA TIF>
<!ENTITY US20030004998A1-20030102-D00010.TIF SYSTEM "US20030004998A1-20030102-D00010.TIF" NDATA TIF>
<!ENTITY US20030004998A1-20030102-D00011.TIF SYSTEM "US20030004998A1-20030102-D00011.TIF" NDATA TIF>
<!ENTITY US20030004998A1-20030102-D00012.TIF SYSTEM "US20030004998A1-20030102-D00012.TIF" NDATA TIF>
<!ENTITY US20030004998A1-20030102-D00013.TIF SYSTEM "US20030004998A1-20030102-D00013.TIF" NDATA TIF>
<!ENTITY US20030004998A1-20030102-D00014.TIF SYSTEM "US20030004998A1-20030102-D00014.TIF" NDATA TIF>
<!ENTITY US20030004998A1-20030102-D00015.TIF SYSTEM "US20030004998A1-20030102-D00015.TIF" NDATA TIF>
<!ENTITY US20030004998A1-20030102-D00016.TIF SYSTEM "US20030004998A1-20030102-D00016.TIF" NDATA TIF>
<!ENTITY US20030004998A1-20030102-D00017.TIF SYSTEM "US20030004998A1-20030102-D00017.TIF" NDATA TIF>
<!ENTITY US20030004998A1-20030102-D00018.TIF SYSTEM "US20030004998A1-20030102-D00018.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030004998</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10067432</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20020204</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F015/00</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>707</class>
<subclass>513000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Proxy-based acceleration of dynamically generated content</title-of-invention>
</technical-information>
<continuity-data>
<non-provisional-of-provisional>
<document-id>
<doc-number>60302122</doc-number>
<document-date>20010629</document-date>
<country-code>US</country-code>
</document-id>
</non-provisional-of-provisional>
</continuity-data>
<inventors>
<first-named-inventor>
<name>
<given-name>Anindya</given-name>
<family-name>Datta</family-name>
</name>
<residence>
<residence-us>
<city>Atlanta</city>
<state>GA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
</inventors>
<assignee>
<organization-name>Chutney Technologies, Inc.</organization-name>
<address>
<address-1>3490 Piedmont Road, Suite 1100</address-1>
<city>Atlanta</city>
<state>GA</state>
<postalcode>30305</postalcode>
</address>
<assignee-type>02</assignee-type>
</assignee>
<correspondence-address>
<name-1>KING &amp; SPALDING</name-1>
<name-2></name-2>
<address>
<address-1>191 PEACHTREE STREET, N.E.</address-1>
<city>ATLANTA</city>
<state>GA</state>
<postalcode>30303-1763</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A system and method for delivering a web page can include receiving a web page request corresponding to a web page having cacheable content. In response to the web page request, a script can be executed to produce a template of the web page at run-time. The script can include a code block corresponding to a cacheable content fragment of the web page. A key identifying the cacheable content fragment can be inserted into the template. The template can be sent to a dynamic proxy cache. The dynamic proxy cache can insert the cacheable content fragment identified by the key into the web page. The web page including the cacheable content fragment can then be delivered to a user. </paragraph>
</subdoc-abstract>
<subdoc-description>
<cross-reference-to-related-applications>
<heading lvl="1">PRIORITY AND RELATED APPLICATIONS </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> This application claims the benefit of priority to U.S. Provisional Patent Application Serial No. 60/302,122, entitled &ldquo;Front-End Acceleration of Dynamically Generated Content,&rdquo; filed Jun. 29, 2001. This application is related to U.S. Non-Provisional Patent Application Serial No. 09/722,260, entitled &ldquo;Dynamic Page Generation Acceleration Using Component-Level Caching,&rdquo; filed Nov. 24, 2000. The disclosure of the priority document and the related document is hereby fully incorporated by reference.</paragraph>
</cross-reference-to-related-applications>
<summary-of-invention>
<section>
<heading lvl="1">FIELD OF THE INVENTION </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> The present invention relates generally to delivering web pages over the Internet. More particularly, the present invention relates to caching web page fragments to enable improved web page delivery speeds and web site scalability. </paragraph>
</section>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> A critical issue in conducting commerce via the Internet (&ldquo;e-commerce&rdquo;) is scalability. Scalability refers to the ability of a web site to deliver web pages in a timely manner in high traffic situations and the ability of the web site to respond appropriately when traffic increases significantly. A web site must provide fast response times even under heavy user loads during heavy traffic periods. Web site response times can be measured by web page delivery speed during those heavy traffic periods. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> E-commerce has experienced phenomenal growth during the past few years. That upward trend is expected to continue for years to come. Some predictions claim that e-commerce revenues will continue to grow and will exceed $1.3 trillion by 2003. That growth in revenue has produced, and will continue to produce, an increase in web traffic. As the number of Internet customers increases, an e-commerce company must simultaneously deliver web pages to tens of thousands of customers. That requirement can place a great strain on the computing resources of the company. With the current state of Internet infrastructure technology supporting web site traffic, e-commerce web sites are having trouble supporting such extreme growth while maintaining an acceptable level of service. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> In the past, e-commerce companies typically served static content for their web pages. Static content is content that does not change over its lifetime and that can be stored and served from &ldquo;ready-made&rdquo; files. Over the past few years, e-commerce companies have transitioned from the static content model to a dynamic content model. In the dynamic content model, content is generated and served &ldquo;on-demand.&rdquo; By generating the content on-demand, the e-commerce company can customize its web page according to an individual user&apos;s preferences, in response to a set of parameters associated with that user. The parameters can include information related to the user&apos;s buying habits or Internet browsing behavior. For example, based on the user&apos;s parameters, the web page can display the individual user&apos;s preferred stock quotes and a personal greeting. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> Another example of dynamic web page generation involves the promotion of related products. For instance, a customer at an online book website may travel down the web page link path: Fiction-Thriller-Legal Thriller. If it is known (for example, through accumulating empirical Internet browsing behavior data) that customers who travel down that link path are statistically likely to also be interested in jazz music, then the next web page presented to the customer can have a component including a reference to jazz music. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> Accordingly, dynamic web pages enable the delivery of tailored information to a customer. However, dynamic web pages generate a unique web page for different users based on the particular user&apos;s set of parameters. Creating unique web pages for individual users creates additional requirements on computing resources and contributes further to the difficulty of maintaining an acceptable level of service. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> Today, many web sites delivering dynamic web pages unique to different users experience significant performance problems in terms of response times. Poor performance can be detrimental to a web site&apos;s ability to successfully conduct commerce online. One measurement of response times is the time to deliver a complete web page to a customer. Unacceptable web page delivery delays are a known cause for customer abandonment (a form of customer attrition). One study predicts that if a web page requires longer than eight seconds to deliver, then 30% of customers will abandon the web page request. Another study estimates that a one second improvement in page loading time (for example, from 6.30 seconds to 5.30 seconds) can reduce the abandonment rate from 30 percent to about 7 percent. Other studies indicate that customer attrition attributable to abandonment may cost the online business community upwards of $100 million per month. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> Many e-commerce companies are increasingly adopting dynamic page generation technologies to dynamically display content. However, as discussed above, dynamic page generation comes with a cost. Web and application server scalability can be significantly reduced when dynamically generating web pages, because the web pages are generated on-demand, rather than served from files on disk or in memory. Accordingly, the load on the web and application servers increases to retrieve and format the requested content. Consequently, even under moderate traffic loads, web page generation times slow down significantly. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> Web sites typically utilize application servers to dynamically generate Hypertext Markup Language (HTML) pages. Application servers execute scripts to generate (or create) the dynamic web pages. The scripts typically perform a significant amount of work to generate a dynamic web page. For example, the script may require the application server to retrieve web page content from database systems (located locally or remotely), to perform content transformations (for example, from XML to HTML) (XML is an acronym for Extensible Markup Language), and to execute other business logic (for example, personalization logic). In the absence of web page caching (storing), each request for a dynamic web page requires the entire script to be executed. When the same web page content is requested and generated repeatedly, an unnecessary load on the application server results, leading to longer (and often unacceptable) response times for site visitors. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> To reduce the overhead associated with dynamic web page generation, web pages (or portions of web pages) may be cached in a main memory. When a web page is cached, content generated for one user is saved and used to serve subsequent requests for the same content. Two conventional caching-based approaches exist for improving the performance of web content distribution and delivery. Those two approaches are proxy-based (front-end) caching and back-end caching. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> Proxy-based caches are based on caching content outside the web site&apos;s infrastructure. The content can include static content such as media files (for example, pictures, audio, or video) or dynamically generated HTML pages. These types of caches are considered a front-end caching solution since they reside outside of the web site&apos;s infrastructure, typically in front of the web server cluster and outside the firewall. Proxy-based caches can provide significant bandwidth savings by relieving the web site&apos;s infrastructure from the work required to push responses through the site. (Bandwidth is the capacity needed to transmit a certain amount of data in a fixed amount of time. For digital devices, bandwidth is typically expressed in bits per second (bps) or bytes second.) </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> Two types of proxy-based caches exist. The first type of proxy-based cache is a page-level cache. A page-level cache stores an entire web page of dynamically generated content. Thus, a page level cache stores content at the granularity of a full web page. Page level caches can improve web site performance by reducing (a) delays associated with generating the content, (b) delays associated with packet filtering and other firewall-related delays and (c) delays associated with transmitting the content through the site infrastructure. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> However, three limitations are associated with using page-level caching solutions to cache dynamic pages. First, page level caching solutions rely on the request URLs (Uniform Resource Locators) to identify pages in cache. When pages are dynamically generated, different invocations of a given script, even with the same input parameters, are not guaranteed to produce the same page. Accordingly, the same URL request can generate different pages for different users. For example, if a web page is initially generated based on a set of parameters for one user and then cached, subsequent requests for that web page by a different user having a different set of parameters will result in the initial web page being delivered. Thus, a proxy-based, page-level cache may serve incorrect pages. This problem has previously prevented the use of proxies in caching dynamic pages. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> Another limitation of page-level solutions is that full HTML pages are typically not reusable. For example, web sites that serve highly personalized pages may include a customer greeting on every page. Accordingly, every page instance is unique and is reusable only if the same user makes the same request. This problem can lead to low hit ratios for a cached page, negating any benefit of caching the page. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> Page-level caching also causes unnecessary invalidation of cached web pages. If only one or a few elements on a page become invalid, then the entire page becomes invalid. Accordingly, some page elements are regenerated more frequently than the frequency in which they change. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> A second type of proxy-based caching is dynamic page assembly. In dynamic page assembly, a template is established for each dynamically generated web page. The template specifies the content and layout of the page using a set of markup tags. Essentially, each page is factored into a number of fragments (specifically, separate dynamic scripts) that are used to assemble the page at a network cache when the page is requested. Content generated from templates and factored fragments are cacheable as separate HTML files on distributed caching architectures. Responses can then be assembled at the distributed caching locations around the Internet, rather than accessing the origin server. By moving the dynamic content closer to the user, many of the same benefits of page-level caching accrue, with the additional benefit of further reduced response times and network bandwidth requirements. Those benefits are obtained because the origin web site does not have to deliver the content. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> There are two limitations associated with the conventional dynamic page assembly approach. One limitation is the requirement that a site follow a specified page design paradigm. The paradigm is the use of specified templates, which in turn call separate dynamic scripts for each dynamically generated fragment. The use of templates requires that page layout be known in advance. For example, users having different sets of parameters may generate different page layouts. The page for one user could be factored into, for example, a template plus five fragments, while the page for another user could be factored into, for example, a template plus four fragments. These caches base response decisions on the requested URL. Accordingly, once the template and fragments for one of the two users are present in the cache, every subsequent request for the same URL will be served from cache, regardless of which user makes the request. Thus, sites supporting dynamic layouts cannot take advantage of dynamic page assembly. Additionally, the use of cached templates and fragments is a major departure from the standard Model-View-Controller design paradigm used in many web sites and may require redesigning and rebuilding a web site from the ground up. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> Another limitation of the dynamic page assembly approach is that it cannot be used in the context of pages with semantically interdependent fragments. If dependencies between the fragments of a page exist, then scripts from different fragments repeat the same operation to generate a single page. Accordingly, significant repetition of work is performed on the site when separate fragments include the same steps in their respective scripts. Thus, dynamic page assembly is optimal only for pages that can be easily decomposed into a small number of static, independent fragments, and where the overall layout of the page does not change. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> The second approach for improving the performance of web content distribution and delivery is back-end caching. Back-end caching approaches cache content at the various layers within the web site&apos;s architecture. Back-end caching approaches can help reduce the delays associated with generating content. These solutions can provide the correct content in a generated page because they do not rely on URLs and because they can observe all script parameters at the back end. Back-end caching typically involves finer granularities than page-level caching, allowing greater reuse of content and fine-grained invalidation. However, a limitation of back-end caching approaches is the delivery of all content from the dynamic content application itself. Accordingly, back-end caching does not reduce the bandwidth needed to connect to the server to obtain the content, and it does not address network-related delays. In other words, it does not address delays resulting from transmitting high-bandwidth content through the web site and Internet infrastructures (for example, firewall processing delays and routing delays). </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> Therefore, given the extreme growth in Internet traffic, as well as the increasing use of dynamic page generation technologies, there is a need in the art to improve web and application server scalability. There is a further need in the art for a cache-based approach that mitigates delays associated with dynamic content creation, distribution, and delivery over the Internet. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> The present invention can provide the ability to cache dynamic content at finer granularities outside a web site&apos;s infrastructure. Accordingly, the present invention can provide the benefits of caching finer granularities of content (for example, greater content reusability), while simultaneously achieving the benefits associated with proxy-based caching (for example, reduced bandwidth and reduced firewall processing). The present invention can provide a system and method that combines the benefits of both proxy-based caching and back-end caching, while overcoming the drawbacks of those conventional approaches. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> The present invention can provide a back end monitor as part of a web site&apos;s infrastructure. The back end monitor can observe web page script execution by the web site&apos;s application server. A template of the web page can be generated by the back end monitor based on observed web script execution patterns. The template according to an exemplary embodiment of the present invention can include a key referencing cacheable content stored in a dynamic proxy cache outside of the web site&apos;s infrastructure. The dynamic proxy cache can receive the template and can assemble the web page as instructed in the template. The dynamic proxy cache can then forward the web page to a user. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> As stated above, the template produced according to an exemplary embodiment of the present invention can include a key referencing a cacheable content fragment stored in the dynamic proxy cache. A &ldquo;get&rdquo; command in the template can instruct the dynamic proxy cache to retrieve the cacheable content fragment and to insert it into the web page. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> If the cacheable content fragment is not stored in the dynamic proxy cache, then the template can include the cacheable content fragment and the key referencing that fragment. A &ldquo;set&rdquo; command in the template can instruct the dynamic proxy cache to store the cacheable content fragment and its key. The dynamic proxy cache can insert the cacheable content fragment into the web page before or after storing that fragment in its memory. Accordingly, the cacheable content fragment can be made available in the dynamic proxy cache for subsequent web page requests including that fragment. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> The back end monitor of an exemplary embodiment of the present invention can track content fragments stored in the dynamic proxy cache. A cache directory in the back end monitor can include a listing of the keys referencing the content fragments stored in the dynamic proxy cache. The back end monitor can search the cache directory for a particular content fragment&apos;s ID and associated key to determine whether the particular content fragment is stored in the dynamic proxy cache. The back end monitor also can monitor the content fragments and can delete invalid fragments from the cache directory. Accordingly, the key associated with the invalid content fragment can be made available for future use. The back end monitor also can send a removal message to the dynamic proxy cache, instructing it to remove an invalid content fragment. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> According to an exemplary embodiment of the present invention, a method for delivering a web page can include receiving a web page request for a web page having cacheable content. In response to the web page request, a script can be executed to produce a template of the web page. The script can include a code block corresponding to a content fragment of the web page. If the content fragment is cacheable, then a key referencing the cacheable content fragment can be inserted into the template. The template can be sent to a dynamic proxy cache outside of the web site&apos;s infrastructure. The dynamic proxy cache can insert the cacheable content fragment identified by the key into the web page. The web page including the cacheable content fragment can then be delivered to a user. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> Another exemplary embodiment of the present invention relates to a web page delivery system for dynamically generating a web page including cacheable content. The system can include origin web site infrastructure having an application server and a back end monitor. The application server can be operative to receive a web page request from a user, to generate a web page template, and to forward the template for creation of the web page. The back end monitor can be operative to insert a key referencing a cacheable content fragment into the template. The system also can include a dynamic proxy cache operative to receive the template from the application server, to create the web page by inserting the cacheable content fragment, and to deliver the web page to the user. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> These and other aspects, objects, and features of the present invention will become apparent from the following detailed description of the exemplary embodiments, read in conjunction with, and reference to, the accompanying drawings.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a block diagram depicting a conventional architecture of a web site employing dynamic content generation technologies for generating web pages. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 2A and 2B</cross-reference> are simplified block diagrams of exemplary web pages having dynamic content. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 2C and 2D</cross-reference> are simplified schematics of the layout of the exemplary web pages depicted in <cross-reference target="DRAWINGS">FIGS. 2A and 2B</cross-reference>, respectively. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3A</cross-reference> is a block diagram depicting a network architecture according to an exemplary embodiment of the present invention. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3B</cross-reference> is a block diagram depicting a network architecture showing alternative locations of a dynamic proxy cache according to exemplary embodiments of the present invention. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3C</cross-reference> is a block diagram depicting a process of operation of a web site architecture according to an exemplary embodiment of the present invention. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a flow chart depicting a method for application server processing according to an exemplary embodiment of the present invention. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a flow chart depicting a method for web page assembly according to an exemplary embodiment of the present invention. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is a block diagram depicting an exemplary script and the corresponding web page that the script can generate. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> is a block diagram depicting the script of <cross-reference target="DRAWINGS">FIG. 6</cross-reference> associated with code block tags according to an exemplary embodiment of the present invention. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> illustrates a web page template according to an exemplary embodiment of the present invention that can be generated by an application server for the initial execution of a script. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference> illustrates a web page template according to an exemplary embodiment of the present invention that can be generated by an application server for subsequent execution of the script. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10</cross-reference> is a flow chart depicting a method for application server processing according to another exemplary embodiment of the present invention. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 11</cross-reference> is a block diagram depicting an exemplary script and a corresponding web page that the script can generate. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 12</cross-reference> is a block diagram depicting the script of <cross-reference target="DRAWINGS">FIG. 11</cross-reference> associated with code block tags according to an exemplary embodiment of the present invention. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 13</cross-reference> illustrates a web page template according to an exemplary embodiment of the present invention that can be generated by an application server for the initial execution of a script. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 14</cross-reference> illustrates a web page template according to an exemplary embodiment of the present invention that can be generated by an application server for subsequent execution of the script. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 15</cross-reference> is a flow chart depicting a method for cache directory key assignment according to an exemplary embodiment of the present invention. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 16</cross-reference> is a flow chart depicting a method for cache directory key assignment according to an exemplary embodiment of the present invention including more than one dynamic proxy cache. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 17</cross-reference> is a flow chart depicting a method for cache directory key removal according to an exemplary embodiment of the present invention.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF EXEMPLARY EMBODIMENTS </heading>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> Exemplary embodiments of the present invention will be described in detail with reference to the accompanying drawings in which like reference numerals represent like elements. </paragraph>
<paragraph id="P-0051" lvl="7"><number>&lsqb;0051&rsqb;</number> The Scalability Problem </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> Web page delivery performance is a critical success factor for e-commerce. The performance of a web site is determined by its ability to scale. Not only must a site be able to provide fast response times (for example, web page delivery speed), but also it must be able to do so even under heavy user loads (for example, high user traffic). Scalability refers to the ability of a web site to deliver web pages in a timely manner in high traffic situations and the ability of the web site to respond appropriately when traffic increases significantly. Thus, scalability is a critical problem for e-commerce sites. An exemplary embodiment of the present invention defines a novel and unique dynamic web page component caching model that improves the scalability of web and application servers. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a block diagram depicting a conventional architecture <highlight><bold>100</bold></highlight> of a web site employing dynamic content generation technologies for generating web pages. A web page typically consists of text and several embedded objects such as graphics. A web page can be thought of as a set of components (or content elements or content fragments), where a component is a group of data representing a displayable element. <cross-reference target="DRAWINGS">FIG. 1</cross-reference> also depicts the steps required to satisfy a user&apos;s request for a web page over the Internet. As shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, the exemplary web page download process includes four-steps. A user <highlight><bold>102</bold></highlight> typically uses a local computer to connect to a web site <highlight><bold>105</bold></highlight> via the Internet <highlight><bold>104</bold></highlight>. A firewall <highlight><bold>108</bold></highlight> controls the data that enters the web site <highlight><bold>105</bold></highlight>. When user <highlight><bold>102</bold></highlight> first requests a web page, the user&apos;s web browser sends a web page request, including the URL for the location of the script that will generate the requested page (step <highlight><bold>1</bold></highlight>). The request travels over Internet <highlight><bold>104</bold></highlight>, through firewall <highlight><bold>108</bold></highlight>, and to a web server <highlight><bold>110</bold></highlight> of web site <highlight><bold>105</bold></highlight>. Web server <highlight><bold>110</bold></highlight> passes the request on to an application server <highlight><bold>112</bold></highlight>, which executes the script that generates the page (step <highlight><bold>2</bold></highlight>). Application server <highlight><bold>112</bold></highlight> is connected to a content database <highlight><bold>116</bold></highlight> either directly or via Internet <highlight><bold>104</bold></highlight> (or some other network). Content database <highlight><bold>116</bold></highlight> can have content elements accessible by application server <highlight><bold>112</bold></highlight> to construct the requested page. The content request is contained in the web page request sent to web site <highlight><bold>105</bold></highlight>. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> When application server <highlight><bold>112</bold></highlight> executes the script to generate the web page, the content (for example, HTML) corresponding to the requested page is generated, along with the URLs for the embedded objects in the page. Accordingly, additional work on the part of application server <highlight><bold>112</bold></highlight> is needed to retrieve and format the requested content. For example, content is typically retrieved from underlying database systems, such as content database <highlight><bold>116</bold></highlight>, which may be located remotely. Once the content is retrieved, additional steps may be required to format the content (for example, content stored as XML must be rendered as HTML). In short, application server <highlight><bold>112</bold></highlight>, upon receipt of the user&apos;s request, performs significant work and outputs the HTML that is sent back to the user (step <highlight><bold>3</bold></highlight>). The HTML typically includes several embedded references to rich content objects, such as images. Those objects must be retrieved separately (steps <highlight><bold>4</bold></highlight> and <highlight><bold>5</bold></highlight>). </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> After user <highlight><bold>102</bold></highlight> receives the server output (step <highlight><bold>3</bold></highlight>), the user&apos;s browser initiates subsequent requests for the embedded objects (step <highlight><bold>4</bold></highlight>) (browsers differ in the number of objects they can retrieve per request). Those objects are often located on web server <highlight><bold>110</bold></highlight>. However, those objects may be located at other sites. Application server <highlight><bold>112</bold></highlight> returns the objects to the user over the Internet (step <highlight><bold>5</bold></highlight>). That last step can be consumptive of network resources, requiring more time to download. Pages having a large number of embedded objects can have significantly longer download times. Moreover, the traffic between the client and the server must go through an extensive network of transmission and switching devices such as routers, switches, and firewalls. Thus, the communication between user <highlight><bold>102</bold></highlight>, application server <highlight><bold>112</bold></highlight>, and any involved content database <highlight><bold>116</bold></highlight> (or other database) can be extremely consumptive of time and computing resources. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> Given the above-identified steps involved in downloading a web page, a number of potential bottlenecks can be identified. These bottlenecks can be classified into four broad areas: </paragraph>
<paragraph id="P-0057" lvl="2"><number>&lsqb;0057&rsqb;</number> 1. low bandwidth at the user and/or web server/application server ends, </paragraph>
<paragraph id="P-0058" lvl="2"><number>&lsqb;0058&rsqb;</number> 2. page generation latency, </paragraph>
<paragraph id="P-0059" lvl="2"><number>&lsqb;0059&rsqb;</number> 3. fetching embedded objects, and </paragraph>
<paragraph id="P-0060" lvl="2"><number>&lsqb;0060&rsqb;</number> 4. redundant connections to serve the same objects. </paragraph>
<paragraph id="P-0061" lvl="7"><number>&lsqb;0061&rsqb;</number> Each of these types of delay is next described in more detail. </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> Delays due to low bandwidth concern network speeds. Since the Internet backbone is high-speed, bandwidth problems occur primarily in the &ldquo;first mile&rdquo; at the web server and/or in the &ldquo;last mile&rdquo; at the user&apos;s end. In the past, modem speeds limited the ability to achieve fast Internet access speeds and contributed to slow download times. However, the advent of higher bandwidth access technology, such as broadband modems, has significantly improved that problem in the last mile at the user&apos;s end. While the bandwidth issue has also improved in the first mile (i.e., between the origin site web server and the internet service provider), there is still room for improvement as demand for content continues to increase rapidly. </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> Delays associated with page generation latency are caused by the work required by application server <highlight><bold>112</bold></highlight> to deliver the requested content. That type of delay occurs between steps <highlight><bold>1</bold></highlight> and <highlight><bold>3</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. The page generation latency component was not considered to be a significant problem until very recently, because web sites <highlight><bold>105</bold></highlight> traditionally responded by transmitting a static HTML page to user <highlight><bold>102</bold></highlight>. With the increasingly widespread use of dynamic page generation technologies, page generation latency has become a critical issue. The amount of work required of web server <highlight><bold>110</bold></highlight> and application server <highlight><bold>112</bold></highlight> continues to increase. Page generation latency delays include the delays due to retrieving content from persistent file systems such as content database <highlight><bold>116</bold></highlight> (both local and remote), the delays due to web server&apos;s <highlight><bold>110</bold></highlight> and application server&apos;s <highlight><bold>112</bold></highlight> formatting of the content elements, and the delays due to business logic execution (for example, personalization logic). </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> Fetching embedded objects (step <highlight><bold>4</bold></highlight>) incurs additional network delay. Typically, user <highlight><bold>102</bold></highlight> and application server <highlight><bold>112</bold></highlight> are separated by long distances. Embedded objects that are requested must be downloaded over these long distances. Accordingly, delays occur because these large pieces of data move relatively slowly due to the switching required to make a connection over a significant distance. Solutions to that problem are available and generally involve an attempt to ameliorate those delays by storing data (for example, embedded objects) closer to end users (for example, storing rich content objects on servers that are physically located closer to end users). That approach reduces the travel distance required for content delivery and decreases the number of connections required to transmit content from content providers to end users. </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> Another problem arises when redundant connections are made to serve the same objects. Each page request typically goes through a router, a firewall, and a switch before reaching web server <highlight><bold>110</bold></highlight> and then application server <highlight><bold>112</bold></highlight>. Application server <highlight><bold>112</bold></highlight> then processes the request and passes it back through the same network components. Because each of those devices has a finite throughput, forcing each request through those devices can cause scalability problems. Furthermore, as more and more users try to access the same content, the redundant load on the firewalls and servers for the same embedded objects increases. The problem of redundant connections affects requests for objects including static content, dynamic content, or both. </paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> Various solutions to the redundant connection problem for static content are available. Generally, such solutions involve attempts to reduce the number of redundant connections for the same static object by caching the object. Caching reduces the load on the origin server, thereby helping to solve the redundant connections problem for static content. Additionally, web sites are increasingly using dynamic page generation technologies to generate content on demand. As the use of dynamic objects increases, the requests for redundant, static objects will decrease. Accordingly, the problem of redundant connections for static content will also decrease. However, the problem of redundant connections for dynamic content is not solved by the current solutions discussed above. </paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> The present invention can address the bandwidth problem, the redundant connections problem, and the page generation latency problem. The present invention can reduce the bandwidth needed from the content provider to the edge server to process a web page request. Redundant connections for dynamic content also can be reduced by the present invention. Finally, the present invention can reduce the page generation load on an application server, as discussed more fully below. </paragraph>
<paragraph id="P-0068" lvl="7"><number>&lsqb;0068&rsqb;</number> The Page Generation Latency Problem </paragraph>
<paragraph id="P-0069" lvl="0"><number>&lsqb;0069&rsqb;</number> Web page generation latency is a significant problem that in many cases is the primary impediment to efficient web page generation and delivery. The problem of page generation latency concerns the delays associated with generating pages at the application server <highlight><bold>112</bold></highlight>. That problem, while significant, has only recently been addressed. However, existing solutions are point solutions and do not address many of the specific delays associated with page generation. </paragraph>
<paragraph id="P-0070" lvl="0"><number>&lsqb;0070&rsqb;</number> In addition to pure script execution overhead, which itself can be non-trivial under moderate to heavy traffic load, there are several other types of delay associated with generating dynamic pages. Those types of delay are described below in more detail. </paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> One kind of page generation delay is caused by fetching content from persistent storage. That kind of delay is primarily attributable to the need to retrieve data stored on a disk, which is a relatively slow operation. That delay can be further classified according to the two types of access required: a) local database access, and b) remote database access. Both types of access to database systems incur input/output (I/O) delay. Access to remote database systems is even more costly as it incurs network delay in addition to I/O delay. </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> Another kind of page generation delay is caused by the need to perform data transformations. Given the overwhelming acceptance of XML as a medium of exchange and as a means of characterizing content, web sites are increasingly maintaining content in XML format. However, since XML alone cannot be presented in a meaningful way, there is a need to separate the content and presentation aspects of a web page. That separation is made possible by the use of XSLT (Extensible Stylesheet Language Transformations), a language used to transform an XML document into some other specified format (for example, HTML text). A number of vendors offer XSLT processors that perform such transformations. The XML to HTML transformation process increases the load on the server, because it involves parsing and other string-processing operations. </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> Yet another kind of page generation delay is caused by the need to execute business logic. Web sites commonly incorporate business logic into their scripts. For example, many e-commerce sites utilize personalization software to deliver targeted content to site visitors. The business logic further increases the load on web and application servers as well as on the underlying databases. </paragraph>
<paragraph id="P-0074" lvl="0"><number>&lsqb;0074&rsqb;</number> Solutions that explicitly address dynamic page generation processing delays from a global perspective are not currently available. Rather, only point solutions exist. For example, some caching can be done by a database management system (DBMS) (especially with the advent of main memory database systems) or the web and application servers, but that caching does not mitigate the problem of accessing remote databases, nor does it address the problem of data transformations. Moreover, given that I/O times have reduced by a factor of only 2.5 times during the last decade (as opposed to network latencies, which have reduced by a factor of <highlight><bold>106</bold></highlight>), the problem of I/O delay is a legitimate concern. The problem of page generation latency itself is new, and is a result of the introduction and rapid deployment of dynamic page generation technologies. In many cases, page generation bottlenecks become the dominant impediment to efficient dynamic web page generation and thus to the overall scalability of the site. While the conventional approach is to buy more hardware and software, that approach is not an attractive alternative in terms of cost and is often an infeasible solution in the long run. </paragraph>
<paragraph id="P-0075" lvl="0"><number>&lsqb;0075&rsqb;</number> To solve that problem, an exemplary embodiment of the present invention provides a dynamic proxy cache that caches dynamic web page fragments away from the web site&apos;s infrastructure, thereby significantly reducing the page generation load on the application server. The present invention also can result in a significant reduction in bandwidth requirements. </paragraph>
<paragraph id="P-0076" lvl="7"><number>&lsqb;0076&rsqb;</number> Dynamic Page Layouts </paragraph>
<paragraph id="P-0077" lvl="0"><number>&lsqb;0077&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 2A and 2B</cross-reference> are simplified block diagrams of exemplary web pages having dynamic content. <cross-reference target="DRAWINGS">FIGS. 2A and 2B</cross-reference> illustrate exemplary dynamic page layouts <highlight><bold>200</bold></highlight><highlight><italic>a </italic></highlight>and <highlight><bold>200</bold></highlight><highlight><italic>b </italic></highlight>for a web page, where the different layouts are determined by a particular user&apos;s set of parameters. Layouts <highlight><bold>200</bold></highlight><highlight><italic>a </italic></highlight>and <highlight><bold>200</bold></highlight><highlight><italic>b </italic></highlight>can be generated by the web site of an online book store catering to both registered users and non-registered users. Registered users are users that have set up an account (including a set of parameters) with the site. Non-registered users are infrequent and/or anonymous visitors. </paragraph>
<paragraph id="P-0078" lvl="0"><number>&lsqb;0078&rsqb;</number> A registered user enters the site by starting at the entry page of the site (in other words, the page presented to the user following login). The entry page presents a list of category links that the user can choose to navigate the site. If the user clicks on the &ldquo;Fiction&rdquo; category, a URL request including a category ID&equals;Fiction parameter is sent to the site&apos;s web server. An application server at the site will execute the proper script to generate the next web page. The script takes the categoryID input parameter and retrieves the content associated with the fiction category. Such a request for a registered user could generate the exemplary web page <highlight><bold>200</bold></highlight><highlight><italic>a </italic></highlight>shown in <cross-reference target="DRAWINGS">FIG. 2A</cross-reference>. </paragraph>
<paragraph id="P-0079" lvl="0"><number>&lsqb;0079&rsqb;</number> Page <highlight><bold>200</bold></highlight><highlight><italic>a </italic></highlight>includes a number of content elements or fragments. The banner ad (BA) fragment <highlight><bold>202</bold></highlight><highlight><italic>a </italic></highlight>includes an advertisement retrieved from an ad server based on the user&apos;s referring URL and the current time. The personal greeting (PG) fragment <highlight><bold>204</bold></highlight><highlight><italic>a </italic></highlight>includes a greeting for the user including the user&apos;s name (retrieved from the registered user&apos;s profile object accessed at login) and the current time. The navigation bar (NB) fragment <highlight><bold>206</bold></highlight><highlight><italic>a </italic></highlight>displays the navigation selections available such as the subcategories of the current category. The product category detail (PC) fragment <highlight><bold>208</bold></highlight><highlight><italic>a </italic></highlight>displays the names, descriptions, and images associated with the products in the fiction category. The product information can be obtained by querying a content database. Finally, the recommended products (RP) fragment <highlight><bold>210</bold></highlight><highlight><italic>a </italic></highlight>includes a list of recommended products that are retrieved from a personalization server based on the current category and user profile information. </paragraph>
<paragraph id="P-0080" lvl="0"><number>&lsqb;0080&rsqb;</number> Some of the fragments of page <highlight><bold>200</bold></highlight><highlight><italic>a </italic></highlight>are based on user profile information that is only available for registered users. For example, personal greeting fragment <highlight><bold>204</bold></highlight><highlight><italic>a</italic></highlight>, which includes the user&apos;s name, can only be generated from a registered user&apos;s profile. </paragraph>
<paragraph id="P-0081" lvl="0"><number>&lsqb;0081&rsqb;</number> A non-registered user enters the web site by starting at the web site&apos;s home page. When the non-registered user selects the fiction category link, exactly the same URL request as for the registered user, including the category ID&equals;Fiction parameter, is sent to the site&apos;s server. However, for the non-registered user, the site can provide web page <highlight><bold>200</bold></highlight><highlight><italic>b</italic></highlight>, instead of page <highlight><bold>200</bold></highlight><highlight><italic>a</italic></highlight>. As shown in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>B, the content and the layout of page <highlight><bold>200</bold></highlight><highlight><italic>b </italic></highlight>are different than that of page <highlight><bold>200</bold></highlight><highlight><italic>a</italic></highlight>. For content, page <highlight><bold>200</bold></highlight><highlight><italic>b </italic></highlight>includes banner ad fragment <highlight><bold>202</bold></highlight><highlight><italic>b</italic></highlight>, corresponding to banner ad fragment <highlight><bold>202</bold></highlight><highlight><italic>a</italic></highlight>; navigation bar fragment <highlight><bold>206</bold></highlight><highlight><italic>b</italic></highlight>, corresponding to navigation bar fragment <highlight><bold>206</bold></highlight><highlight><italic>a</italic></highlight>; and product category detail fragment <highlight><bold>208</bold></highlight><highlight><italic>b</italic></highlight>, corresponding to product category detail fragment <highlight><bold>208</bold></highlight><highlight><italic>a</italic></highlight>. However, page <highlight><bold>200</bold></highlight><highlight><italic>b </italic></highlight>also includes a featured products fragment <highlight><bold>212</bold></highlight><highlight><italic>b</italic></highlight>, rather than the personal greeting and recommended products fragments <highlight><bold>204</bold></highlight><highlight><italic>a </italic></highlight>and <highlight><bold>210</bold></highlight><highlight><italic>a</italic></highlight>. For layout, navigation bar <highlight><bold>206</bold></highlight><highlight><italic>b </italic></highlight>appears in a different place on the non-registered user&apos;s page <highlight><bold>200</bold></highlight><highlight><italic>b</italic></highlight>. Additionally, product category detail fragment <highlight><bold>208</bold></highlight> is displayed in two-column format rather than single-column format. </paragraph>
<paragraph id="P-0082" lvl="0"><number>&lsqb;0082&rsqb;</number> Those skilled in the art will appreciate that the differences between layout <highlight><bold>200</bold></highlight><highlight><italic>a </italic></highlight>and layout <highlight><bold>200</bold></highlight><highlight><italic>b </italic></highlight>are only provided as an example to illustrate that web page content and layout can depend upon the particular user&apos;s set of parameters. </paragraph>
<paragraph id="P-0083" lvl="0"><number>&lsqb;0083&rsqb;</number> In general, an HTML page consists of two distinct components: content and layout. Content refers to the actual information displayed and layout refers to a set of markup tags that define the presentation. The presentation is typically the location of the content on the page. For example, with respect to <cross-reference target="DRAWINGS">FIG. 2</cross-reference>A, the different fragments <highlight><bold>202</bold></highlight><highlight><italic>a</italic></highlight>-<highlight><bold>210</bold></highlight><highlight><italic>a </italic></highlight>represent content, and the layout determines how fragments <highlight><bold>202</bold></highlight><highlight><italic>a</italic></highlight>-<highlight><bold>210</bold></highlight><highlight><italic>a </italic></highlight>are presented on page <highlight><bold>200</bold></highlight><highlight><italic>a</italic></highlight>. Examples of layout include an HTML tag, for example, &lt;TABLE&gt; or &lt;TITLE&gt;. </paragraph>
<paragraph id="P-0084" lvl="0"><number>&lsqb;0084&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 2C and 2D</cross-reference> are simplified schematics of the layout of the exemplary web pages depicted in <cross-reference target="DRAWINGS">FIGS. 2A and 2B</cross-reference>, respectively. <cross-reference target="DRAWINGS">FIG. 2C</cross-reference> depicts an exemplary schematic of the layout for the registered user&apos;s page <highlight><bold>200</bold></highlight><highlight><italic>a</italic></highlight>. In <cross-reference target="DRAWINGS">FIG. 2</cross-reference>C, each &ldquo;&lt;L<highlight><subscript>i</subscript></highlight>&gt;&rdquo; represents the layout for a particular section of page <highlight><bold>200</bold></highlight><highlight><italic>a</italic></highlight>. For example, each &lt;L<highlight><subscript>i</subscript></highlight>&gt; can include a string of markup tags, such as &lt;TABLE WIDTH&equals;&ldquo;100%&rdquo;&gt;&lt;TR&gt;&lt;TD&gt; . . . . The remaining elements represent the content. For example &lt;BA&gt; denotes banner ad fragment <highlight><bold>202</bold></highlight><highlight><italic>a</italic></highlight>. <cross-reference target="DRAWINGS">FIG. 2D</cross-reference> depicts the layout for the non-registered user&apos;s page <highlight><bold>200</bold></highlight><highlight><italic>b. </italic></highlight></paragraph>
<paragraph id="P-0085" lvl="0"><number>&lsqb;0085&rsqb;</number> As FIGS. <highlight><bold>2</bold></highlight>A-<highlight><bold>2</bold></highlight>D indicate, the final presentation of the page is partially determined by the order in which the markup tags appear. Clearly, the layout is also determined by the actual markup tags themselves (not shown in the figures). </paragraph>
<paragraph id="P-0086" lvl="0"><number>&lsqb;0086&rsqb;</number> FIGS. <highlight><bold>2</bold></highlight>A-<highlight><bold>2</bold></highlight>D, and the corresponding discussion, illustrate two characteristics of dynamically generated content. First, the content and the page layout of the site can be dynamic. In other words, the precise organization of a page is often determined at run-time. Second, the same request URL can produce different content and/or different layouts. The registered and non-registered users can submit the exact same URL to the site, yet each can receive a different page based on the particular user&apos;s parameter set. </paragraph>
<paragraph id="P-0087" lvl="0"><number>&lsqb;0087&rsqb;</number> Because dynamic pages can be dynamic across two dimensions, content and layout, a dynamic content caching system that can account for both dimensions is desirable. The present invention can provide a system and method to cache such dynamic web pages. </paragraph>
<paragraph id="P-0088" lvl="7"><number>&lsqb;0088&rsqb;</number> Exemplary Embodiments of the Present Invention </paragraph>
<paragraph id="P-0089" lvl="0"><number>&lsqb;0089&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3A</cross-reference> is a block diagram depicting a network architecture <highlight><bold>300</bold></highlight> according to an exemplary embodiment of the present invention. As shown in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>A, the network architecture <highlight><bold>300</bold></highlight> can include components of a conventional web site architecture, as well as a dynamic proxy cache <highlight><bold>306</bold></highlight> (DPC) and a back end monitor <highlight><bold>314</bold></highlight>. </paragraph>
<paragraph id="P-0090" lvl="0"><number>&lsqb;0090&rsqb;</number> Dynamic proxy cache <highlight><bold>306</bold></highlight> can reside outside firewall <highlight><bold>108</bold></highlight> and can store various types of objects. The objects can include rich content, static HTML files, HTML fragments (statically or dynamically generated), and page layouts. Dynamic proxy cache <highlight><bold>306</bold></highlight> can receive a web page request and can pass it to back end monitor <highlight><bold>314</bold></highlight> via web server <highlight><bold>110</bold></highlight> and application server <highlight><bold>112</bold></highlight>. Back end monitor <highlight><bold>314</bold></highlight> can perform any necessary processing and can generate and send page layout instructions (along with some content) to dynamic proxy cache <highlight><bold>306</bold></highlight>. Then, dynamic proxy cache <highlight><bold>306</bold></highlight> can assemble and can serve the request based on the layout instructions. Dynamic proxy cache <highlight><bold>306</bold></highlight> also can receive and execute cache management instructions from the back end. </paragraph>
<paragraph id="P-0091" lvl="0"><number>&lsqb;0091&rsqb;</number> Dynamic proxy cache <highlight><bold>306</bold></highlight> can be a proxy cache that can store dynamic content fragments and can assemble those fragments on demand using run-time page layout instructions. Dynamic proxy cache <highlight><bold>306</bold></highlight> can assemble pages by processing the instructions provided by back end monitor <highlight><bold>314</bold></highlight>. Dynamic proxy cache <highlight><bold>306</bold></highlight> can include a structure implemented as an in-memory array of pointers to cached fragments. An array index can provide a direct link to the cached fragment. </paragraph>
<paragraph id="P-0092" lvl="0"><number>&lsqb;0092&rsqb;</number> Back end monitor <highlight><bold>314</bold></highlight> can observe the back end processing and can dynamically determine the page layout instructions. It can then forward those instructions to dynamic proxy cache <highlight><bold>306</bold></highlight>. Back end monitor <highlight><bold>314</bold></highlight> also can control the cache management of dynamic proxy cache <highlight><bold>306</bold></highlight>. For example, back end monitor <highlight><bold>314</bold></highlight> can notify dynamic proxy cache <highlight><bold>306</bold></highlight> when changes in content cause a fragment to become invalid, in other words, unusable. As shown in <cross-reference target="DRAWINGS">FIG. 3A, a</cross-reference> single back end monitor <highlight><bold>314</bold></highlight> can communicate with a cluster of application servers <highlight><bold>112</bold></highlight>. Back end monitor <highlight><bold>314</bold></highlight> also can cache intermediate output (for example, programmatic objects such as scripts). Back end monitor <highlight><bold>314</bold></highlight> also can have a lightweight client or local monitor component <highlight><bold>314</bold></highlight><highlight><italic>a </italic></highlight>(&ldquo;lightweight&rdquo; generally refers to a single-threaded process that runs on an operating system). Local monitors <highlight><bold>314</bold></highlight><highlight><italic>a </italic></highlight>can determine the page layout instructions for requests by monitoring the processing at each application server <highlight><bold>112</bold></highlight>. </paragraph>
<paragraph id="P-0093" lvl="0"><number>&lsqb;0093&rsqb;</number> In general, dynamic content fragments can be cached in dynamic proxy cache <highlight><bold>306</bold></highlight>, while layout information can be generated on demand from back end monitor <highlight><bold>314</bold></highlight> at the source site infrastructure. Accordingly, the network architecture <highlight><bold>300</bold></highlight> according to an exemplary embodiment of the present invention can provide significant reductions in bandwidth requirements, because only the page layouts, and perhaps some content, are transmitted from back end monitor <highlight><bold>314</bold></highlight> to dynamic proxy cache <highlight><bold>306</bold></highlight>. Additionally, network architecture <highlight><bold>300</bold></highlight> can accommodate dynamic page layouts, because the back end monitor <highlight><bold>314</bold></highlight> can generate the layout information on demand. </paragraph>
<paragraph id="P-0094" lvl="0"><number>&lsqb;0094&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3B</cross-reference> is a block diagram depicting a network architecture <highlight><bold>300</bold></highlight><highlight><italic>a </italic></highlight>showing alternative locations of dynamic proxy cache <highlight><bold>306</bold></highlight><highlight><italic>a</italic></highlight>, <highlight><bold>306</bold></highlight><highlight><italic>b </italic></highlight>according to exemplary embodiments of the present invention. As shown in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>B, the dynamic proxy cache can reside either (a) at the origin site (in a reverse proxy configuration represented by dynamic proxy cache <highlight><bold>306</bold></highlight>), or (b) at the network edge (in a forward proxy configuration represented by one or both of dynamic proxy cache <highlight><bold>306</bold></highlight><highlight><italic>a </italic></highlight>and <highlight><bold>306</bold></highlight><highlight><italic>b</italic></highlight>). The forward proxy configuration can include dynamic proxy cache <highlight><bold>306</bold></highlight><highlight><italic>a </italic></highlight>or <highlight><bold>306</bold></highlight><highlight><italic>b</italic></highlight>. Alternatively, the forward proxy configuration can include both dynamic proxy caches <highlight><bold>306</bold></highlight><highlight><italic>a </italic></highlight>and <highlight><bold>306</bold></highlight><highlight><italic>b</italic></highlight>, as well as additional dynamic proxy caches (not shown). The primary benefit of the reverse proxy configuration is the reduction in the number of bytes transferred through the site infrastructure for each request. The forward proxy configuration can result in even greater benefits because the reduction in bytes transferred for each request can be realized within the site infrastructure as well as across the Internet. The main difference between the two is that a forward proxy configuration typically would mandate a distributed cache architecture, whereas a reverse proxy configuration can be implemented as a single unit. </paragraph>
<paragraph id="P-0095" lvl="0"><number>&lsqb;0095&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3C</cross-reference> is a block diagram depicting a process of operation of web site architecture <highlight><bold>300</bold></highlight> according to an exemplary embodiment of the present invention. Dynamic proxy cache <highlight><bold>306</bold></highlight> can include cached content. Dynamic proxy cache <highlight><bold>306</bold></highlight> can receive a web page request (step <highlight><bold>1</bold></highlight>) and can route the request to origin web site <highlight><bold>105</bold></highlight> (step <highlight><bold>2</bold></highlight>). At web site <highlight><bold>105</bold></highlight>, application server <highlight><bold>112</bold></highlight> can execute a script to serve the request (step <highlight><bold>3</bold></highlight>). Back end monitor <highlight><bold>314</bold></highlight> can observe the application processing and can generate a template of the page layout (step <highlight><bold>4</bold></highlight>). The template can include a condensed string representing the user deliverable page. The template can include page layout instructions and &ldquo;holes&rdquo; (placeholders) to indicate where cached fragments can be inserted. Application server <highlight><bold>112</bold></highlight> then sends the template to dynamic proxy cache <highlight><bold>306</bold></highlight> (step <highlight><bold>5</bold></highlight>), which fills in the &ldquo;holes&rdquo; with the appropriate fragments from its cache (step <highlight><bold>6</bold></highlight>). As described more fully below, each &ldquo;hole&rdquo; in the template can include a reference to content stored in the dynamic proxy cache. The dynamic proxy cache can then retrieve the referenced content to fill in each &ldquo;hole.&rdquo; The resulting page can then be delivered to user <highlight><bold>102</bold></highlight> (step <highlight><bold>7</bold></highlight>). </paragraph>
<paragraph id="P-0096" lvl="0"><number>&lsqb;0096&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a flow chart depicting a method <highlight><bold>400</bold></highlight> for application server processing according to an exemplary embodiment of the present invention. Method <highlight><bold>400</bold></highlight> can include step <highlight><bold>405</bold></highlight> in which code blocks that generate cacheable content can be tagged. In step <highlight><bold>410</bold></highlight>, a request to generate a web page can be received at the application server. Then in step <highlight><bold>415</bold></highlight>, the application logic of the script can be executed and each code block can be checked for a tag. In step <highlight><bold>420</bold></highlight>, it can be determined whether a particular code block is tagged, indicating that it includes cacheable content. If the particular code block is not tagged, then the method branches to step <highlight><bold>425</bold></highlight>. In step <highlight><bold>425</bold></highlight>, the logic of the code block can be executed and the resulting content can be inserted into the template. The method then proceeds to step <highlight><bold>455</bold></highlight>, where it can be determined whether more code blocks remain to be executed. If more code blocks remain, then the method branches back to step <highlight><bold>415</bold></highlight>. If step <highlight><bold>455</bold></highlight> determines that more code blocks do not remain, then the method branches to step <highlight><bold>460</bold></highlight>, where the template can be sent to the dynamic proxy cache. </paragraph>
<paragraph id="P-0097" lvl="0"><number>&lsqb;0097&rsqb;</number> If step <highlight><bold>420</bold></highlight> determines that the code block is tagged, then the method branches to step <highlight><bold>430</bold></highlight>. In step <highlight><bold>430</bold></highlight>, it can be determined whether the cacheable content is contained in the dynamic proxy cache and is valid. Typically, a fragment can become invalid by (a) an invalidation policy that can determine that a fragment is not valid, or (b) a replacement policy that can determine that a fragment should be evicted from cache. For example, fragments can become invalid due to expiration of the time-to-live or updates to the underlying data sources. (The time-to-live specifies a set period of time for which a particular fragment is valid.) Alternatively, a cache replacement manager can monitor the size of the cache directory and can select fragments for replacement when the directory size exceeds a specified threshold. If a particular fragment becomes invalid, a flag can be set to FALSE to indicate that the particular fragment is not valid. Accordingly, a subsequent request for the particular fragment will result in the fragment being regenerated and served fresh. </paragraph>
<paragraph id="P-0098" lvl="0"><number>&lsqb;0098&rsqb;</number> If step <highlight><bold>430</bold></highlight> determines that the cacheable content is contained in the dynamic proxy cache and valid, then the method branches to step <highlight><bold>450</bold></highlight>. In step <highlight><bold>450</bold></highlight>, a &ldquo;get&rdquo; instruction can be inserted into the template. Also in step <highlight><bold>450</bold></highlight>, a key representing the cacheable content can be inserted in the template. The method then proceeds to step <highlight><bold>455</bold></highlight>, as described above. </paragraph>
<paragraph id="P-0099" lvl="0"><number>&lsqb;0099&rsqb;</number> If step <highlight><bold>430</bold></highlight> determines that the cacheable content is not contained in the dynamic proxy cache, or is contained in the dynamic proxy cache but not valid, then the method branches to step <highlight><bold>435</bold></highlight>. In step <highlight><bold>435</bold></highlight>, a key can be assigned to the cacheable content. The key also can be inserted into the cache directory of the back end monitor. Then in step <highlight><bold>440</bold></highlight>, the content of the code block can be generated and can be inserted into the template. In step <highlight><bold>445</bold></highlight>, a &ldquo;set&rdquo; instruction can be inserted into the template, as well as the key generated in step <highlight><bold>440</bold></highlight>. The method then proceeds to step <highlight><bold>455</bold></highlight>, as described above. </paragraph>
<paragraph id="P-0100" lvl="0"><number>&lsqb;0100&rsqb;</number> As discussed above, the template can be sent to the dynamic proxy cache in step <highlight><bold>460</bold></highlight>. The dynamic proxy cache can then receive the template and assemble the web page. The processing performed by the dynamic proxy cache after receiving the template will be discussed below. </paragraph>
<paragraph id="P-0101" lvl="0"><number>&lsqb;0101&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a flow chart depicting a method <highlight><bold>500</bold></highlight> for web page assembly according to an exemplary embodiment of the present invention. Method <highlight><bold>500</bold></highlight> can include step <highlight><bold>505</bold></highlight> in which the dynamic proxy cache receives a template from the application server. Then in step <highlight><bold>510</bold></highlight>, method <highlight><bold>500</bold></highlight> can determine whether the template includes a &ldquo;get&rdquo; instruction, instructing the dynamic proxy cache to retrieve cached content from its memory. The &ldquo;get&rdquo; instruction can include a key referencing the cached content in the dynamic proxy cache. If method <highlight><bold>500</bold></highlight> determines in step <highlight><bold>510</bold></highlight> that the template does not include a &ldquo;get&rdquo; instruction, then the method branches to step <highlight><bold>520</bold></highlight>, discussed below. If step <highlight><bold>510</bold></highlight> determines that the template includes a &ldquo;get&rdquo; instruction, then the method branches to step <highlight><bold>515</bold></highlight>. In step <highlight><bold>515</bold></highlight>, the dynamic proxy cache can retrieve the cached content and can insert the cached content into the web page, as instructed by the template. The method then proceeds to step <highlight><bold>520</bold></highlight>, discussed below. </paragraph>
<paragraph id="P-0102" lvl="0"><number>&lsqb;0102&rsqb;</number> In step <highlight><bold>520</bold></highlight>, method <highlight><bold>500</bold></highlight> can determine whether the template includes a &ldquo;set&rdquo; instruction. The &ldquo;set&rdquo; instruction can instruct the dynamic proxy cache to store specific content. The specific content can be identified by a key. If step <highlight><bold>520</bold></highlight> determines that the template includes a &ldquo;set&rdquo; instruction, then the method branches to step <highlight><bold>525</bold></highlight>. In step <highlight><bold>525</bold></highlight>, the dynamic proxy cache can store the cacheable content identified by the key in the &ldquo;set&rdquo; instruction. Then in step <highlight><bold>530</bold></highlight>, the cacheable content can be inserted into the web page. If necessary, steps <highlight><bold>510</bold></highlight>-<highlight><bold>530</bold></highlight> can be repeated to account for all &ldquo;get&rdquo; and &ldquo;set&rdquo; commands in the template (not shown). The method then proceeds to step <highlight><bold>535</bold></highlight>, where the completed web page can be sent to the user. If step <highlight><bold>520</bold></highlight> determines that the template does not include a &ldquo;set&rdquo; instruction, then the method branches directly to step <highlight><bold>535</bold></highlight>. </paragraph>
<paragraph id="P-0103" lvl="0"><number>&lsqb;0103&rsqb;</number> With reference to FIGS. <highlight><bold>6</bold></highlight>-<highlight><bold>9</bold></highlight>, an example of the processing of method <highlight><bold>400</bold></highlight> will be described. <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is a block diagram depicting an exemplary script <highlight><bold>600</bold></highlight> and a corresponding web page <highlight><bold>600</bold></highlight><highlight><italic>a </italic></highlight>that the script may generate. Web page <highlight><bold>600</bold></highlight><highlight><italic>a </italic></highlight>can include content fragments <highlight><bold>602</bold></highlight><highlight><italic>a</italic></highlight>-<highlight><bold>610</bold></highlight><highlight><italic>a </italic></highlight>corresponding to content fragments <highlight><bold>202</bold></highlight><highlight><italic>a</italic></highlight>-<highlight><bold>210</bold></highlight><highlight><italic>a </italic></highlight>described earlier with reference to <cross-reference target="DRAWINGS">FIG. 2A</cross-reference>. As shown in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>, script <highlight><bold>600</bold></highlight> can include code blocks <highlight><bold>602</bold></highlight>-<highlight><bold>610</bold></highlight> to generate the respective content fragments <highlight><bold>602</bold></highlight><highlight><italic>a</italic></highlight>-<highlight><bold>610</bold></highlight><highlight><italic>a </italic></highlight>of web page <highlight><bold>600</bold></highlight><highlight><italic>a</italic></highlight>. Each code block <highlight><bold>602</bold></highlight>-<highlight><bold>610</bold></highlight> can include the logic to generate the corresponding content fragment. </paragraph>
<paragraph id="P-0104" lvl="0"><number>&lsqb;0104&rsqb;</number> As described earlier, banner ad fragment <highlight><bold>602</bold></highlight><highlight><italic>a </italic></highlight>and personal greeting fragment <highlight><bold>604</bold></highlight><highlight><italic>a </italic></highlight>can be state-dependent, because they can depend on the current time. Accordingly, both fragments <highlight><bold>602</bold></highlight><highlight><italic>a </italic></highlight>and <highlight><bold>604</bold></highlight><highlight><italic>a </italic></highlight>can be considered non-cacheable and can be generated for each request. Fragments <highlight><bold>606</bold></highlight><highlight><italic>a</italic></highlight>-<highlight><bold>610</bold></highlight><highlight><italic>a </italic></highlight>can be cacheable. Accordingly, each of code blocks <highlight><bold>606</bold></highlight>, <highlight><bold>608</bold></highlight>, and <highlight><bold>610</bold></highlight> can be tagged as corresponding to cacheable content. Code blocks <highlight><bold>606</bold></highlight>-<highlight><bold>610</bold></highlight> can be tagged by inserting application programming interfaces (APIs) around the code block, enabling the output of the code block to be cached at run-time. Each tag can provide a unique identifier to the corresponding cacheable fragment. Additionally, each tag can provide additional metadata. For example, metadata can include a time-to-live (ttl). </paragraph>
<paragraph id="P-0105" lvl="0"><number>&lsqb;0105&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> is a block diagram depicting script <highlight><bold>600</bold></highlight> associated with code block tags <highlight><bold>706</bold></highlight>, <highlight><bold>708</bold></highlight>, and <highlight><bold>710</bold></highlight> according to an exemplary embodiment of the present invention. As shown in <cross-reference target="DRAWINGS">FIG. 7</cross-reference>, code blocks <highlight><bold>602</bold></highlight> and <highlight><bold>604</bold></highlight> of script <highlight><bold>600</bold></highlight> can include non-cacheable content. Accordingly, code blocks <highlight><bold>602</bold></highlight> and <highlight><bold>604</bold></highlight> do not include a tag, indicating that the corresponding content will be generated each time script <highlight><bold>600</bold></highlight> is executed. Code blocks <highlight><bold>606</bold></highlight>, <highlight><bold>608</bold></highlight>, and <highlight><bold>610</bold></highlight> include tags <highlight><bold>706</bold></highlight>, <highlight><bold>708</bold></highlight>, and <highlight><bold>710</bold></highlight>, respectively. Tags <highlight><bold>706</bold></highlight>-<highlight><bold>710</bold></highlight> indicate that the corresponding content is cacheable. </paragraph>
<paragraph id="P-0106" lvl="0"><number>&lsqb;0106&rsqb;</number> Each of tags <highlight><bold>706</bold></highlight>-<highlight><bold>710</bold></highlight> can have a similar format. Additionally, each code block can include a single tag, or each code block can have a plurality of tags. For example, each code block can have a &ldquo;begin tag&rdquo; at the beginning of the code block and an &ldquo;end tag&rdquo; at the end of the code block. In <cross-reference target="DRAWINGS">FIG. 7</cross-reference>, items <highlight><bold>706</bold></highlight><highlight><italic>a</italic></highlight>, <highlight><bold>708</bold></highlight><highlight><italic>a</italic></highlight>, and <highlight><bold>710</bold></highlight><highlight><italic>a </italic></highlight>represent begin tags. Items <highlight><bold>706</bold></highlight><highlight><italic>b</italic></highlight>, <highlight><bold>708</bold></highlight><highlight><italic>b</italic></highlight>, and <highlight><bold>710</bold></highlight><highlight><italic>b </italic></highlight>represent end tags. </paragraph>
<paragraph id="P-0107" lvl="0"><number>&lsqb;0107&rsqb;</number> A begin tag can have the following basic format: &lt;dpc:fragmentID:ttl&gt;, where &ldquo;dpc&rdquo; can be a constant indicating the start of a tag, &ldquo;fragmentID&rdquo; can be a unique string to identify the content fragment, and &ldquo;ttl&rdquo; can be a time-to-live value. The fragmentID can include a name element alone, or a name element and a parameter list element. The name element can be a name assigned to the fragment. The parameter list element can be an optional list of run-time parameters. For example, as shown in <cross-reference target="DRAWINGS">FIG. 7</cross-reference>, navigation bar code block <highlight><bold>606</bold></highlight> has been assigned begin tag <highlight><bold>706</bold></highlight><highlight><italic>a </italic></highlight>comprising &ldquo;&lt;dpc:nbKey:3600&gt;.&rdquo; Accordingly, begin tag <highlight><bold>706</bold></highlight><highlight><italic>a </italic></highlight>comprises only the fragment name &ldquo;nbKey&rdquo; and a time-to-live of one day (3600 minutes). Product category detail fragment has been assigned a begin tag <highlight><bold>708</bold></highlight><highlight><italic>a </italic></highlight>comprising &ldquo;&lt;dpc:pcKey&plus;catID:60&gt;.&rdquo; Accordingly, begin tag <highlight><bold>708</bold></highlight><highlight><italic>a </italic></highlight>includes the fragment name &ldquo;pcKey,&rdquo; the catID parameter (the parameter list), and a time-to-live of one hour (60 minutes). </paragraph>
<paragraph id="P-0108" lvl="0"><number>&lsqb;0108&rsqb;</number> An end tag can be constant and can have the format: &lt;/dpc&gt;. Tags according to the present invention are not limited to those discussed above. The tags can have a different format than described above and/or can include more or less information. For example, the tags can include keywords to support keyword-based invalidation. Additionally, the tags can include only a key indicating the content in the cache directory. </paragraph>
<paragraph id="P-0109" lvl="0"><number>&lsqb;0109&rsqb;</number> In operation, a request to generate a web page can be received by the application server. The request can cause script <highlight><bold>600</bold></highlight> to be invoked and can cause execution of script <highlight><bold>600</bold></highlight> to begin. The application logic of script <highlight><bold>600</bold></highlight> can be executed until a tagged code block is encountered. When a tagged code block is encountered, it can be determined whether the fragment produced by that code block exists in the dynamic proxy cache. That determination can be performed by searching for the fragment ID in the back end monitor&apos;s cache directory. The cache directory can include the fragment IDs and additional metadata for each fragment stored in the dynamic proxy cache. The cache directory can use a key to reference the content stored in the dynamic proxy cache. </paragraph>
<paragraph id="P-0110" lvl="0"><number>&lsqb;0110&rsqb;</number> Web page templates generated by the back end monitor will now be discussed with reference to <cross-reference target="DRAWINGS">FIGS. 8 and 9</cross-reference>. The first time script <highlight><bold>600</bold></highlight> is executed, the dynamic proxy cache will not include any of the content elements. Accordingly, cacheable content can be generated by the application server and forwarded to the dynamic proxy cache for storing in its memory. <cross-reference target="DRAWINGS">FIG. 8</cross-reference> illustrates a template <highlight><bold>800</bold></highlight> according to an exemplary embodiment of the present invention that can be generated by the application server for the initial execution of script <highlight><bold>600</bold></highlight>. As shown, template <highlight><bold>800</bold></highlight> includes markers <highlight><bold>802</bold></highlight> and <highlight><bold>804</bold></highlight>, which can include the content for the banner ad and personal greeting fragments corresponding to code blocks <highlight><bold>602</bold></highlight> and <highlight><bold>604</bold></highlight> of script <highlight><bold>600</bold></highlight>. Because the content for those two fragments is not cacheable, that content can be generated each time script <highlight><bold>600</bold></highlight> is executed and can be inserted in the corresponding template. For code blocks <highlight><bold>606</bold></highlight>-<highlight><bold>610</bold></highlight> of script <highlight><bold>600</bold></highlight>, it can be determined whether the cacheable content corresponding to those code blocks is contained in the dynamic proxy cache. Because this is the initial execution of script <highlight><bold>600</bold></highlight>, the cacheable content is not contained in the dynamic proxy cache. Accordingly, the content can be generated by the application server and inserted into template <highlight><bold>800</bold></highlight> with the corresponding marker <highlight><bold>806</bold></highlight>-<highlight><bold>810</bold></highlight>. Additionally, a &ldquo;set&rdquo; instruction can be inserted into template <highlight><bold>800</bold></highlight> to instruct the dynamic proxy cache to store the cacheable content in its memory. </paragraph>
<paragraph id="P-0111" lvl="0"><number>&lsqb;0111&rsqb;</number> For example, marker <highlight><bold>806</bold></highlight> comprises &ldquo;&lt;dpc:1:set&gt;HTML for Navigation Bar . . . &lt;/dpc&gt;.&rdquo; In this exemplary embodiment, the integer &ldquo;1&rdquo; comprises the key referencing the cacheable content corresponding to code block <highlight><bold>606</bold></highlight> of script <highlight><bold>600</bold></highlight>. Marker <highlight><bold>806</bold></highlight> further includes the content of code block <highlight><bold>606</bold></highlight>, represented by &ldquo;HTML for Navigation Bar,&rdquo; and the &ldquo;set&rdquo; instruction. The &ldquo;set&rdquo; instruction can instruct the dynamic proxy cache to store the content and the key for the navigation bar. </paragraph>
<paragraph id="P-0112" lvl="0"><number>&lsqb;0112&rsqb;</number> When the dynamic proxy cache receives template <highlight><bold>800</bold></highlight> from the application server, it processes the instructions to assemble the web page for delivery to the user. Accordingly, the dynamic proxy cache inserts into the web page the content items associated with markers <highlight><bold>802</bold></highlight>-<highlight><bold>810</bold></highlight>, as instructed in the template. Additionally, the dynamic proxy cache can store in its memory the key and the corresponding content for each of code blocks <highlight><bold>806</bold></highlight>-<highlight><bold>810</bold></highlight>, as instructed by the &ldquo;set&rdquo; command. </paragraph>
<paragraph id="P-0113" lvl="0"><number>&lsqb;0113&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference> illustrates a template <highlight><bold>900</bold></highlight> according to an exemplary embodiment of the present invention that can be generated for subsequent executions of script <highlight><bold>600</bold></highlight>. As shown, template <highlight><bold>900</bold></highlight> includes markers <highlight><bold>902</bold></highlight> and <highlight><bold>904</bold></highlight> which can include the content for the banner ad and personal greeting fragments corresponding to code blocks <highlight><bold>602</bold></highlight> and <highlight><bold>604</bold></highlight> of script <highlight><bold>600</bold></highlight>. As stated above, the content for those fragments is not cacheable and can be generated each time script <highlight><bold>600</bold></highlight> is executed. For code blocks <highlight><bold>606</bold></highlight>-<highlight><bold>610</bold></highlight>, the corresponding content is stored in dynamic proxy cache (unless the content has become invalid). Accordingly, the content corresponding to those code blocks does not need to be generated by the application server. A &ldquo;get&rdquo; instruction can be inserted in markers <highlight><bold>906</bold></highlight>-<highlight><bold>910</bold></highlight> of template <highlight><bold>900</bold></highlight> to instruct the dynamic proxy cache to retrieve the corresponding content fragment from its memory. Each marker <highlight><bold>906</bold></highlight>-<highlight><bold>910</bold></highlight> also can include the key referencing the particular content fragment in the cache directory. </paragraph>
<paragraph id="P-0114" lvl="0"><number>&lsqb;0114&rsqb;</number> When the dynamic proxy cache receives template <highlight><bold>900</bold></highlight>, it can assemble the web page as instructed by markers <highlight><bold>902</bold></highlight>-<highlight><bold>910</bold></highlight>. Accordingly, the dynamic proxy cache inserts the content associated with markers <highlight><bold>902</bold></highlight> and <highlight><bold>904</bold></highlight> into the web page. Additionally, the dynamic proxy cache retrieves the content associated with markers <highlight><bold>906</bold></highlight>-<highlight><bold>910</bold></highlight> from its memory and inserts that content into the web page. The dynamic proxy cache can be instructed to retrieve that content by the get command in each of markers <highlight><bold>906</bold></highlight>-<highlight><bold>910</bold></highlight>. Additionally, the dynamic proxy cache can reference the specific keys to retrieve the specific content referenced by each marker <highlight><bold>906</bold></highlight>-<highlight><bold>910</bold></highlight>. </paragraph>
<paragraph id="P-0115" lvl="0"><number>&lsqb;0115&rsqb;</number> As shown in <cross-reference target="DRAWINGS">FIGS. 8 and 9</cross-reference>, the template size of the first and subsequent request can be significantly smaller, even for this simple example. </paragraph>
<paragraph id="P-0116" lvl="0"><number>&lsqb;0116&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10</cross-reference> is flow chart depicting a method <highlight><bold>1000</bold></highlight> for application server processing according to another exemplary embodiment of the present invention. Method <highlight><bold>1000</bold></highlight> includes step <highlight><bold>1005</bold></highlight> in which content-generating code blocks within a script can be tagged to indicate whether the code blocks are configured to generate cacheable content. For example, a content generating code block can be tagged with a &ldquo;C&rdquo; to indicate that its output is cacheable. Alternatively, a content generating code block can be tagged to further indicate that its cacheable output is dynamic or static. For example, a &ldquo;D&rdquo; tag can indicate a dynamic code block, and an &ldquo;S&rdquo; tag can indicate a static code block. Additionally, a content-generating code block can be tagged as producing non-cacheable content. For example, an &ldquo;NC&rdquo; tag can indicate a non-cacheable code block. Both static and dynamic code blocks produce cacheable output. Non-cacheable code blocks include logic that will be executed each time the script is invoked. Tagging the content-generating scripts can allow the page layouts to be captured at run-time. </paragraph>
<paragraph id="P-0117" lvl="0"><number>&lsqb;0117&rsqb;</number> In step <highlight><bold>1010</bold></highlight>, a request to generate a web page can be received at the application server. Then, the application logic of the script can be executed in step <highlight><bold>1020</bold></highlight> until a tagged code block is encountered. In step <highlight><bold>1025</bold></highlight>, it can be determined whether the tagged code block generates cacheable content. In this exemplary embodiment, the tagged code block can represent non-cacheable content if the tag includes an &ldquo;NC&rdquo; and cacheable content if the tag includes a &ldquo;C.&rdquo; Alternatively, the tagged code block can represent static, cacheable content if the tag includes an &ldquo;S,&rdquo; and dynamic, cacheable content if the tag includes a &ldquo;D.&rdquo; If the tagged code block represents non-cacheable content, then the method branches to step <highlight><bold>1030</bold></highlight>. In step <highlight><bold>1030</bold></highlight>, the content can be generated from the code block and inserted into the template. Method <highlight><bold>1000</bold></highlight> then proceeds to step <highlight><bold>1065</bold></highlight>, where it can be determined whether more code blocks remain to be executed. If more code blocks remain to be executed, then the method branches back to step <highlight><bold>1020</bold></highlight> to continue executing the application logic of the script until another tagged code block is encountered. If it is determined in step <highlight><bold>1065</bold></highlight> that no more code blocks remain to be executed, then method <highlight><bold>1000</bold></highlight> branches to step <highlight><bold>1070</bold></highlight>. In step <highlight><bold>1070</bold></highlight>, the template can be sent to the dynamic proxy cache. </paragraph>
<paragraph id="P-0118" lvl="0"><number>&lsqb;0118&rsqb;</number> If method <highlight><bold>1000</bold></highlight> determines in step <highlight><bold>1025</bold></highlight> that the tagged code block represents cacheable content, then the method branches to step <highlight><bold>1040</bold></highlight>, where it can be determined if the cacheable content is stored in the dynamic proxy cache and is valid. If the cacheable content is stored in the dynamic proxy cache and is valid, then the method branches to step <highlight><bold>1060</bold></highlight>. In step <highlight><bold>1060</bold></highlight>, the back end monitor can insert a &ldquo;get&rdquo; instruction into the template. The &ldquo;get&rdquo; instruction can instruct the dynamic proxy cache to retrieve the cacheable content from its memory. Also in step <highlight><bold>1060</bold></highlight>, the back end monitor can insert into the template a key referencing the cacheable content stored in the dynamic proxy cache. The key can be obtained from a cache directory that maintains a record of content stored in the dynamic proxy cache. The method then proceeds to step <highlight><bold>1065</bold></highlight>, as described above. </paragraph>
<paragraph id="P-0119" lvl="0"><number>&lsqb;0119&rsqb;</number> If method <highlight><bold>1000</bold></highlight> determines in step <highlight><bold>1040</bold></highlight> that the cacheable content is not in the dynamic proxy cache, or is in the dynamic proxy cache but not valid, then the method branches to step <highlight><bold>1045</bold></highlight>. In step <highlight><bold>1045</bold></highlight>, a key referencing the cacheable content can be assigned and inserted into the cache directory of the back end monitor. Then in step <highlight><bold>1050</bold></highlight>, the cacheable content can be generated by executing the logic of the code block, and the cacheable content can be inserted into the template. In step <highlight><bold>1055</bold></highlight>, the back end monitor can insert a &ldquo;set&rdquo; instruction into the template. The &ldquo;set&rdquo; instruction can instruct the dynamic proxy cache to store the cacheable content in its memory. Also in step <highlight><bold>1055</bold></highlight>, the key assigned in step <highlight><bold>1045</bold></highlight> can be inserted into the template. The method then proceeds to step <highlight><bold>1065</bold></highlight>, as described above. </paragraph>
<paragraph id="P-0120" lvl="0"><number>&lsqb;0120&rsqb;</number> As discussed earlier, method <highlight><bold>1000</bold></highlight> can determine in step <highlight><bold>1065</bold></highlight> whether more code blocks remain to be executed. If all of the code blocks in the script have been executed, then the method branches to step <highlight><bold>1070</bold></highlight>. In step <highlight><bold>1070</bold></highlight>, the application server can send the template to the dynamic proxy cache. The processing performed by the dynamic proxy cache after receiving the template is discussed above with reference to <cross-reference target="DRAWINGS">FIG. 5</cross-reference>. </paragraph>
<paragraph id="P-0121" lvl="0"><number>&lsqb;0121&rsqb;</number> With reference to FIGS. <highlight><bold>11</bold></highlight>-<highlight><bold>14</bold></highlight>, an example of the operation of methods <highlight><bold>1000</bold></highlight> and <highlight><bold>500</bold></highlight> will be described. <cross-reference target="DRAWINGS">FIG. 11</cross-reference> is a block diagram depicting an exemplary script <highlight><bold>1100</bold></highlight> and the corresponding web page <highlight><bold>1100</bold></highlight><highlight><italic>a </italic></highlight>that it can generate. Script <highlight><bold>1100</bold></highlight> can include code block <highlight><bold>1102</bold></highlight>, which can include logic to generate an ad. Code block <highlight><bold>1102</bold></highlight> can generate a banner ad fragment <highlight><bold>1102</bold></highlight><highlight><italic>a </italic></highlight>of web page <highlight><bold>1100</bold></highlight><highlight><italic>a</italic></highlight>. If fragment <highlight><bold>1102</bold></highlight><highlight><italic>a </italic></highlight>includes an ad based on various state information such as the referring URL or the time of day, then the content generated by code block <highlight><bold>1102</bold></highlight> is non-cacheable. Accordingly, code block <highlight><bold>1102</bold></highlight> can be executed each time that script <highlight><bold>1100</bold></highlight> is executed. </paragraph>
<paragraph id="P-0122" lvl="0"><number>&lsqb;0122&rsqb;</number> Script <highlight><bold>1100</bold></highlight> also can include code block <highlight><bold>1104</bold></highlight>, which can include logic to generate logo formatting. Code block <highlight><bold>1102</bold></highlight> can generate the content for logo fragment <highlight><bold>1104</bold></highlight><highlight><italic>a </italic></highlight>of web page <highlight><bold>1100</bold></highlight><highlight><italic>a</italic></highlight>. Generally, code block <highlight><bold>1104</bold></highlight> will have a standard formatting tag to display a standard logo. Accordingly, the content generated by code block <highlight><bold>1104</bold></highlight> is static and cacheable. </paragraph>
<paragraph id="P-0123" lvl="0"><number>&lsqb;0123&rsqb;</number> Script <highlight><bold>1100</bold></highlight> also can include code block <highlight><bold>1106</bold></highlight>, which can include logic to generate navigation bar formatting. Code block <highlight><bold>1106</bold></highlight> can then generate the content for navigation bar fragment <highlight><bold>1106</bold></highlight><highlight><italic>a </italic></highlight>of web page <highlight><bold>1100</bold></highlight><highlight><italic>a</italic></highlight>. Code block <highlight><bold>1106</bold></highlight> can include a standard formatting tag to display the standard navigation bar. Accordingly, the content generated by code block <highlight><bold>1106</bold></highlight> is static and cacheable. </paragraph>
<paragraph id="P-0124" lvl="0"><number>&lsqb;0124&rsqb;</number> Script <highlight><bold>1100</bold></highlight> also can include code block <highlight><bold>1108</bold></highlight>, which can include logic to generate product category information. Code block <highlight><bold>1108</bold></highlight> can generate the content for product category information fragment <highlight><bold>1108</bold></highlight><highlight><italic>a </italic></highlight>of web page <highlight><bold>1100</bold></highlight><highlight><italic>a</italic></highlight>. Code block <highlight><bold>1108</bold></highlight> can include logic that connects to a database and retrieves records for the product categories within the current category. The relevant attributes can be extracted and formatted as HTML. For example, the relevant attributes can include a name and a short description. Accordingly, the product category information can be common across all requests, making the content generated by code block <highlight><bold>1108</bold></highlight> cacheable, even though it is dynamic. </paragraph>
<paragraph id="P-0125" lvl="0"><number>&lsqb;0125&rsqb;</number> Script <highlight><bold>1100</bold></highlight> also can include code block <highlight><bold>1110</bold></highlight>, which can include logic to generate product recommendations. Code block <highlight><bold>1110</bold></highlight> can generate recommended products fragment <highlight><bold>1110</bold></highlight><highlight><italic>a </italic></highlight>of web page <highlight><bold>1100</bold></highlight><highlight><italic>a</italic></highlight>. Code block <highlight><bold>1110</bold></highlight> can include logic that accesses a personalization engine to determine the appropriate product recommendations for a given user. Because product recommendations can be common across a group of customers, the content generated by code block <highlight><bold>1110</bold></highlight> is cacheable, even though it is dynamic. </paragraph>
<paragraph id="P-0126" lvl="0"><number>&lsqb;0126&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 12</cross-reference> is a block diagram depicting script <highlight><bold>1100</bold></highlight> having tags for each of its code blocks <highlight><bold>1102</bold></highlight>-<highlight><bold>1110</bold></highlight> according to an exemplary embodiment of the present invention. As shown, code blocks <highlight><bold>1102</bold></highlight>-<highlight><bold>1110</bold></highlight> can have corresponding tags <highlight><bold>1202</bold></highlight>-<highlight><bold>1210</bold></highlight>. Tag <highlight><bold>1202</bold></highlight> can indicate that the content of code block <highlight><bold>1102</bold></highlight> is non-cacheable. Tags <highlight><bold>1204</bold></highlight> and <highlight><bold>1206</bold></highlight> can indicate that the content of code blocks <highlight><bold>1104</bold></highlight> and <highlight><bold>1106</bold></highlight> is static and cacheable. Tags <highlight><bold>1208</bold></highlight> and <highlight><bold>1210</bold></highlight> can indicate that the content of code blocks <highlight><bold>1108</bold></highlight> and <highlight><bold>1110</bold></highlight> is dynamic and cacheable. In this exemplary embodiment, tags <highlight><bold>1202</bold></highlight>-<highlight><bold>1210</bold></highlight> include the following: &ldquo;NC&rdquo; to indicate that the corresponding content is non-cacheable; &ldquo;S&rdquo; to indicate that the corresponding content is static and cacheable; or &ldquo;D&rdquo; to indicate that the corresponding content is dynamic and cacheable. </paragraph>
<paragraph id="P-0127" lvl="0"><number>&lsqb;0127&rsqb;</number> Additionally, tags for cacheable content also can include a key to identify the corresponding content in the cache directory. For example, tag <highlight><bold>1204</bold></highlight> includes a key &ldquo;logo&rdquo; to identify the content of code block <highlight><bold>1104</bold></highlight> in the cache directory. As shown in <cross-reference target="DRAWINGS">FIG. 12</cross-reference>, the keys can include fixed strings. The keys also can include run-time parameters such as a category ID. Additionally, the keys can include metadata such as a time-to-live (ttl) for the fragment. </paragraph>
<paragraph id="P-0128" lvl="0"><number>&lsqb;0128&rsqb;</number> The first time that script <highlight><bold>1100</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 12</cross-reference>) is executed, the corresponding cache will be empty. Accordingly, the logic of code blocks <highlight><bold>1102</bold></highlight>-<highlight><bold>1110</bold></highlight> will be executed. Any cacheable content can then be inserted into the dynamic proxy cache. </paragraph>
<paragraph id="P-0129" lvl="0"><number>&lsqb;0129&rsqb;</number> Web page templates generated by the back end monitor will now be discussed with reference to <cross-reference target="DRAWINGS">FIGS. 13 and 14</cross-reference>. <cross-reference target="DRAWINGS">FIG. 13</cross-reference> illustrates a template <highlight><bold>1300</bold></highlight> according to an exemplary embodiment of the present invention that can be generated by an application server for the initial execution of script <highlight><bold>1100</bold></highlight>. As shown in <cross-reference target="DRAWINGS">FIG. 13</cross-reference>, template <highlight><bold>1300</bold></highlight> can include markers <highlight><bold>1302</bold></highlight>-<highlight><bold>1310</bold></highlight> corresponding to content generated by code blocks <highlight><bold>1102</bold></highlight>-<highlight><bold>1110</bold></highlight>, respectively. Marker <highlight><bold>1302</bold></highlight> can include the content generated by the application server for code block <highlight><bold>1102</bold></highlight>. Each of markers <highlight><bold>1304</bold></highlight> and <highlight><bold>1306</bold></highlight> can include the static content generated by the application server for code blocks <highlight><bold>1104</bold></highlight> and <highlight><bold>1106</bold></highlight>, respectively, as well as a key referencing the static content in the cache directory. Additionally, markers <highlight><bold>1304</bold></highlight> and <highlight><bold>1306</bold></highlight> can include a &ldquo;set&rdquo; instruction, as indicated by an &ldquo;S.&rdquo; The &ldquo;set&rdquo; instruction can instruct the dynamic proxy cache to insert into its memory the respective keys and their corresponding static content. </paragraph>
<paragraph id="P-0130" lvl="0"><number>&lsqb;0130&rsqb;</number> Each of markers <highlight><bold>1308</bold></highlight> and <highlight><bold>1310</bold></highlight> can include the dynamic content generated by the application server for code blocks <highlight><bold>1308</bold></highlight> and <highlight><bold>1310</bold></highlight>, respectively, as well as a key referencing the dynamic content in the cache directory. Markers <highlight><bold>1308</bold></highlight> and <highlight><bold>1310</bold></highlight> also can include a &ldquo;set&rdquo; instruction to instruct the dynamic proxy cache to insert into its memory the respective keys and their corresponding dynamic content. </paragraph>
<paragraph id="P-0131" lvl="0"><number>&lsqb;0131&rsqb;</number> When the dynamic proxy cache receives template <highlight><bold>1300</bold></highlight> from the application server, it follows the instructions to assemble the web page that can be sent to the user. Accordingly, the dynamic proxy cache inserts into the web page the content items associated with markers <highlight><bold>1302</bold></highlight>-<highlight><bold>1310</bold></highlight>, as instructed in the template. Additionally, the dynamic proxy cache can store the key and the corresponding cacheable content associated with each of markers <highlight><bold>1304</bold></highlight>-<highlight><bold>1310</bold></highlight>. </paragraph>
<paragraph id="P-0132" lvl="0"><number>&lsqb;0132&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 14</cross-reference> illustrates a template according to an exemplary embodiment of the present invention that can be generated by an application server for subsequent execution of script <highlight><bold>1100</bold></highlight>. When script <highlight><bold>1100</bold></highlight> is executed for a second time, the cached static and dynamic content can be available in the dynamic proxy cache. Accordingly, the back end monitor can generate the template illustrated in <cross-reference target="DRAWINGS">FIG. 14</cross-reference>. In <cross-reference target="DRAWINGS">FIG. 14</cross-reference>, markers <highlight><bold>1402</bold></highlight>-<highlight><bold>1410</bold></highlight> can represent the corresponding content generated by code blocks <highlight><bold>1102</bold></highlight>-<highlight><bold>1110</bold></highlight>. Marker <highlight><bold>1402</bold></highlight> can include the non-cacheable content generated by the application server for code block <highlight><bold>1102</bold></highlight>. Markers <highlight><bold>1404</bold></highlight> and <highlight><bold>1406</bold></highlight> can include only a key referencing the static content stored in the dynamic proxy cache. </paragraph>
<paragraph id="P-0133" lvl="0"><number>&lsqb;0133&rsqb;</number> Additionally, since the dynamic content is still valid, markers <highlight><bold>1408</bold></highlight> and <highlight><bold>1410</bold></highlight> can include only a key referencing the dynamic content in the dynamic proxy cache. As shown in <cross-reference target="DRAWINGS">FIG. 14</cross-reference>, markers <highlight><bold>1404</bold></highlight>-<highlight><bold>1410</bold></highlight> can include a &ldquo;get&rdquo; instruction represented by the &ldquo;G.&rdquo; The &ldquo;get&rdquo; instruction can instruct the dynamic proxy cache to retrieve the content from its memory. As illustrated in <cross-reference target="DRAWINGS">FIGS. 13 and 14</cross-reference>, the size of the template forwarded from the application server to the dynamic proxy cache is significantly smaller, even for this simple example. </paragraph>
<paragraph id="P-0134" lvl="0"><number>&lsqb;0134&rsqb;</number> When the dynamic proxy cache receives template <highlight><bold>1400</bold></highlight>, it assembles the web page as instructed by markers <highlight><bold>1402</bold></highlight>-<highlight><bold>1410</bold></highlight>. Accordingly, the dynamic proxy cache inserts into the web page the content associated with marker <highlight><bold>1402</bold></highlight>. Additionally, the dynamic proxy cache retrieves from its memory the content associated with markers <highlight><bold>1404</bold></highlight>-<highlight><bold>1410</bold></highlight> and inserts it into the web page. The dynamic proxy cache can be instructed to retrieve that content by the get command in each of markers <highlight><bold>1404</bold></highlight>-<highlight><bold>1410</bold></highlight>. Additionally, the dynamic proxy cache can reference the specific keys to retrieve the specific content referenced by each marker <highlight><bold>1404</bold></highlight>-<highlight><bold>1410</bold></highlight>. </paragraph>
<paragraph id="P-0135" lvl="0"><number>&lsqb;0135&rsqb;</number> The back end monitor can include a cache directory to facilitate management of the dynamic proxy cache. The cache directory can monitor content fragments and their respective metadata in the dynamic proxy cache. The cache directory can include the keys of all content fragments stored in the dynamic proxy cache. The cache directory can have the following structure for each cacheable fragment: (1) A fragment ID, which can have a unique fragment identifier. For example, the fragment ID can be a name. Alternatively, the fragment ID can be a name and a parameter list. (2) A dynamic proxy cache key (dpcKey), which can include a unique fragment identifier assigned by a key assigning method (see <cross-reference target="DRAWINGS">FIG. 15</cross-reference>, discussed below). (3) An &ldquo;isValid&rdquo; flag, which can indicate if the fragment is valid or invalid. And (4) a time-to-live (ttl) value for the fragment. </paragraph>
<paragraph id="P-0136" lvl="0"><number>&lsqb;0136&rsqb;</number> The dpcKey can be a unique integer identifier associated with each content fragment. The dpcKey can be a common key for both the back end monitor and the dynamic proxy cache. Using an integer as the dpcKey can reduce the tag size. The fragment IDs can be quite long, especially those that include a list of parameters. By assigning an integer as the dpcKey, the page template size being sent to the dynamic proxy cache can be reduced. Additionally, assigning a common key for both the back end monitor and the dynamic proxy cache can eliminate the need for explicit communication between those components. </paragraph>
<paragraph id="P-0137" lvl="0"><number>&lsqb;0137&rsqb;</number> Key assignment will now be described with reference to <cross-reference target="DRAWINGS">FIG. 15</cross-reference>. <cross-reference target="DRAWINGS">FIG. 15</cross-reference> is a flow chart depicting a method <highlight><bold>1500</bold></highlight> for cache directory key assignment according to an exemplary embodiment of the present invention. The key can be assigned at run-time using key assignment method <highlight><bold>1500</bold></highlight>. The key can be an integer value drawn from a pool of integers allocated at system initialization. For example, the pool of integers can be 1, 2, . . . N. In step <highlight><bold>1505</bold></highlight> of method <highlight><bold>1500</bold></highlight>, the maximum key value, N, can be set to establish the &ldquo;free list.&rdquo; The maximum key value, N, can be chosen such that it provides an upper bound on the number of cacheable fragments. Typically, N can be computed by dividing available memory by the average size of a fragment. The resulting integer pool can be maintained as a queue called the &ldquo;free list.&rdquo;</paragraph>
<paragraph id="P-0138" lvl="0"><number>&lsqb;0138&rsqb;</number> In step <highlight><bold>1510</bold></highlight>, the back end monitor can receive a run-time request for a cacheable content fragment. When the run-time request is received, it can be determined in step <highlight><bold>1515</bold></highlight> whether the content fragment ID exists in the cache directory. If the fragment ID does not exist, then the method branches to step <highlight><bold>1520</bold></highlight>, where the fragment ID can be inserted into the cache directory. Also in step <highlight><bold>1520</bold></highlight>, the fragment&apos;s time-to-live value can be inserted into the cache directory. In step <highlight><bold>1525</bold></highlight>, the fragment&apos;s isValid flag can be set to &ldquo;true&rdquo; to indicate that the fragment is valid. Then, a key can be assigned to the fragment in step <highlight><bold>1530</bold></highlight> by assigning the next available integer from the free list. The method then proceeds to step <highlight><bold>1535</bold></highlight>, where the key can be inserted into the page template. Additionally, the key can be used as the key in the dynamic proxy cache. If step <highlight><bold>1515</bold></highlight> determines that the fragment ID exists in the cache directory, then the method branches directly to step <highlight><bold>1535</bold></highlight>. </paragraph>
<paragraph id="P-0139" lvl="0"><number>&lsqb;0139&rsqb;</number> Key assignment method <highlight><bold>1500</bold></highlight> described above is best suited for a system including a single dynamic proxy cache. In other words, key assignment method <highlight><bold>1500</bold></highlight> is best suited for a system having a reverse proxy configuration. However, key assignment method <highlight><bold>1500</bold></highlight> can be modified to accommodate multiple dynamic proxy caches. Multiple dynamic proxy caches can be encountered in a forward proxy configuration. </paragraph>
<paragraph id="P-0140" lvl="0"><number>&lsqb;0140&rsqb;</number> In a system having multiple dynamic proxy caches, a back end monitor using method <highlight><bold>1500</bold></highlight> could incorrectly determine that content is stored in a particular dynamic proxy cache. For example, two dynamic proxy caches, A and B, can exist. DPC A can receive a request for content C<highlight><bold>1</bold></highlight>. Since it is the first request, the back end monitor can assign a key to content C<highlight><bold>1</bold></highlight>, can generate the content C<highlight><bold>1</bold></highlight>, and then can send the content C<highlight><bold>1</bold></highlight> and the key to DPC A. DPC A can then insert the content C<highlight><bold>1</bold></highlight> and the key into its memory. Subsequently, DPC B can receive a request for content C<highlight><bold>1</bold></highlight>. At this point, the back end monitor thinks that content C<highlight><bold>1</bold></highlight> exists in the dynamic proxy cache. However, the back end monitor cannot determine that content C<highlight><bold>1</bold></highlight> only exists in DPC A. </paragraph>
<paragraph id="P-0141" lvl="0"><number>&lsqb;0141&rsqb;</number> One method to allow the back end monitor to determine which dynamic proxy cache includes specific content is to simply maintain key information for each cache. However, that method will require storing a number of keys, &ldquo;n,&rdquo; for each of the dynamic proxy caches, &ldquo;m.&rdquo; As used for providing content over the Internet, n can be on the order of millions, and m can be on the order of hundreds to thousands, thus creating the problem of storing an enormous amount of information, which will greatly increase the cache lookup time. </paragraph>
<paragraph id="P-0142" lvl="0"><number>&lsqb;0142&rsqb;</number> Another method for allowing the back end monitor to determine which dynamic proxy cache contains specific content is shown in <cross-reference target="DRAWINGS">FIG. 16</cross-reference>. <cross-reference target="DRAWINGS">FIG. 16</cross-reference> is a flow chart depicting a method <highlight><bold>1600</bold></highlight> for cache directory key assignment according to an exemplary embodiment of the present invention in a system having more than one dynamic proxy cache. The key can be assigned at run-time. For each key, a bit vector can be maintained in the cache directory representing the set of all dynamic proxy caches. In other words, a bit vector for a given key &ldquo;k&rdquo; can have cardinality equal to m, the number of dynamic proxy caches. Cardinality refers to the number of bits in the bit vector, where the number of bits can correspond to the number of dynamic proxy caches m associated with a given key k. If the i<highlight><superscript>th </superscript></highlight>bit for key k is set, then the i<highlight><superscript>th </superscript></highlight>dynamic proxy cache includes a valid copy of the content associated with key k. </paragraph>
<paragraph id="P-0143" lvl="0"><number>&lsqb;0143&rsqb;</number> As shown in <cross-reference target="DRAWINGS">FIG. 16</cross-reference>, method <highlight><bold>1600</bold></highlight> operates as follows. In step <highlight><bold>1605</bold></highlight>, the maximum key value, N, can be set as described above for method <highlight><bold>1500</bold></highlight> to establish the &ldquo;free list.&rdquo; In step <highlight><bold>1608</bold></highlight>, an identifier can be established for each dynamic proxy cache. The identifier can act as an index into the bit vectors described above, which can be maintained for each key. The identifier can be an integer assigned to a particular dynamic proxy cache. This integer can be mapped to some other identifier of the dynamic proxy cache, such as an Internet Protocol (IP) address. In step <highlight><bold>1610</bold></highlight>, the back end monitor can receive a run-time request for a cacheable content fragment. The request can include the identifier from the particular dynamic proxy cache. In step <highlight><bold>1615</bold></highlight>, the back end monitor can determine whether the content fragment&apos;s ID exists in the cache directory. If the fragment ID does not exist, then the method branches to step <highlight><bold>1620</bold></highlight>, where the fragment ID can be inserted into the cache directory. Also in step <highlight><bold>1620</bold></highlight>, the fragment&apos;s time-to-live value can be inserted into the cache directory. In step <highlight><bold>1625</bold></highlight>, the fragment&apos;s isValid flag can be set to &ldquo;true&rdquo; to indicate that the fragment is valid. Then, a key can be assigned to the fragment in step <highlight><bold>1630</bold></highlight> by assigning the next available integer from the free list. In step <highlight><bold>1632</bold></highlight>, the content can be generated and stored in the back end monitor. In step <highlight><bold>1633</bold></highlight>, the bit corresponding to the particular dynamic proxy cache can be set in the bit vector of the key. The method then proceeds to step <highlight><bold>1634</bold></highlight>, where the content can be inserted into the page template. Then, in step <highlight><bold>1635</bold></highlight>, the key can be inserted into the page template. Additionally, the key can be used as the key in the dynamic proxy cache. </paragraph>
<paragraph id="P-0144" lvl="0"><number>&lsqb;0144&rsqb;</number> If step <highlight><bold>1615</bold></highlight> determines that the cache directory includes a key referencing the content fragment, then the method branches to step <highlight><bold>1617</bold></highlight>. In step <highlight><bold>1617</bold></highlight>, the back end monitor can determine whether the bit corresponding to the particular dynamic proxy cache is set in the key. If the appropriate bit in the key is set, then the content fragment exists in the particular dynamic proxy cache, and the method branches to step <highlight><bold>1635</bold></highlight>, described above. If the appropriate bit is not set, then the content fragment does not exist in the particular dynamic proxy cache, and the method branches to step <highlight><bold>1633</bold></highlight>, described above. </paragraph>
<paragraph id="P-0145" lvl="0"><number>&lsqb;0145&rsqb;</number> As needed, a &ldquo;get&rdquo; command, or a &ldquo;set&rdquo; command and the content, also can be inserted into the template as described above with reference to <cross-reference target="DRAWINGS">FIGS. 4 and 10</cross-reference>. In other words, if the particular dynamic proxy cache includes the content fragment, then a &ldquo;get&rdquo; command can be inserted into the template. If the particular dynamic proxy cache does not include the content fragment, then a &ldquo;set&rdquo; command and the content can be inserted into the template. </paragraph>
<paragraph id="P-0146" lvl="0"><number>&lsqb;0146&rsqb;</number> In an exemplary embodiment where the system architecture includes more than one dynamic proxy cache, the back end monitor can store the content associated with each key. Thus, the back end monitor can store not only a key and its associated metadata, but also its corresponding content. Accordingly, unnecessary regeneration of cacheable content can be avoided. For instance, consider the example described above for a system having dynamic proxy caches A and B. DPC A can receive a request for content C<highlight><bold>1</bold></highlight>. Since it is the first request, the back end monitor can assign a key to content C<highlight><bold>1</bold></highlight>, can generate content C<highlight><bold>1</bold></highlight>, and then can send content C<highlight><bold>1</bold></highlight> and the key to DPC A. The back end monitor can also store content C<highlight><bold>1</bold></highlight>. DPC A can then insert the content C<highlight><bold>1</bold></highlight> and the key into its memory. Subsequently, DPC B can receive a request for content C<highlight><bold>1</bold></highlight>. At this point, method <highlight><bold>1600</bold></highlight> can determine that the fragment ID for content C<highlight><bold>1</bold></highlight> exists in the cache directory and that content C<highlight><bold>1</bold></highlight> does not exist in DPC B. If the back end monitor did not store content C<highlight><bold>1</bold></highlight>, then content C<highlight><bold>1</bold></highlight> would have to be regenerated (or transferred from DPC A) to send it to DPC B. However, because the backend monitor can store content C<highlight><bold>1</bold></highlight>, it can then insert content C<highlight><bold>1</bold></highlight> into the template to send it to DPC B. </paragraph>
<paragraph id="P-0147" lvl="0"><number>&lsqb;0147&rsqb;</number> Key removal will now be described with reference to <cross-reference target="DRAWINGS">FIG. 17</cross-reference>. <cross-reference target="DRAWINGS">FIG. 17</cross-reference> is a flow chart depicting a method <highlight><bold>1700</bold></highlight> for cache directory key removal according to an exemplary embodiment of the present invention. When a content fragment becomes invalid, the cache directory can be updated to indicate the current status of the fragment and to free the fragment&apos;s key for future use. In step <highlight><bold>1705</bold></highlight> of method <highlight><bold>1700</bold></highlight>, a cache invalidation manager can monitor fragments to determine when they become invalid. Typically, a fragment can become invalid by (a) an invalidation policy that can determine that a fragment is invalid, or (b) a replacement policy that can determine that a fragment should be evicted from cache. For example, fragments can become invalid due to expiration of the time-to-live or updates to the underlying data sources. Alternatively, the cache replacement manager can monitor the size of the cache directory and can select fragments for replacement when the directory size exceeds a specified threshold. </paragraph>
<paragraph id="P-0148" lvl="0"><number>&lsqb;0148&rsqb;</number> In step <highlight><bold>1710</bold></highlight>, it can be determined whether a particular fragment is invalid or needs to be replaced. If the particular fragment is not invalid or does not need replacement, then the method branches back to step <highlight><bold>1705</bold></highlight> to monitor another fragment. If step <highlight><bold>1710</bold></highlight> determines that the particular fragment is invalid or needs replacement, then the method branches to step <highlight><bold>1720</bold></highlight>. In step <highlight><bold>1720</bold></highlight>, the fragment&apos;s isValid flag can be set to FALSE to indicate that it is not valid. Accordingly, a subsequent request for the particular fragment will result in the fragment being regenerated and served fresh. In a forward proxy configuration, all bits for the fragment&apos;s key also can be cleared when the particular fragment becomes invalid. Accordingly, a subsequent request for the particular fragment, regardless of which dynamic proxy cache originates the request, will result in the fragment being regenerated and served fresh. The method then proceeds to step <highlight><bold>1725</bold></highlight>, where the fragment&apos;s key can be inserted at the end of the free List. </paragraph>
<paragraph id="P-0149" lvl="0"><number>&lsqb;0149&rsqb;</number> In step <highlight><bold>1730</bold></highlight>, the back end monitor can update the dynamic proxy cache by sending a removal message to the dynamic proxy cache. The removal message can instruct the dynamic proxy cache to remove the invalid content fragment from its memory. The back end monitor can send the removal message each time a fragment is determined to be invalid. Alternatively, the back end monitor can send the removal message at periodic intervals, after a specified number of fragments become invalid, or after a specified memory size of fragments becomes invalid. Key removal method <highlight><bold>1700</bold></highlight> can be independent of key assignment methods <highlight><bold>1500</bold></highlight> and <highlight><bold>1600</bold></highlight>. </paragraph>
<paragraph id="P-0150" lvl="0"><number>&lsqb;0150&rsqb;</number> Alternatively, invalid fragments do not have to be explicitly removed from the dynamic proxy cache. The slots corresponding to the invalid fragments can simply remain unused until they are subsequently assigned to a new fragment by the back end monitor. For example, suppose a navigation bar fragment having dpcKey <highlight><bold>2</bold></highlight> becomes invalid. That fragment can be marked as invalid by the back end monitor, and &ldquo;2&rdquo; can be inserted back into the free List. The dynamic proxy cache does not have to take any action. Eventually, dpcKey <highlight><bold>2</bold></highlight> can be assigned to another fragment (either the navigation bar fragment or a new fragment) by the back end monitor, at which time the appropriate content will be inserted into the corresponding slot in the dynamic proxy cache. </paragraph>
<paragraph id="P-0151" lvl="0"><number>&lsqb;0151&rsqb;</number> In addition to managing the dynamic proxy cache, the back end monitor also can cache other types of objects. In some cases, it can be beneficial to cache intermediate objects rather than user-deliverable fragments. For instance, in the example described earlier with reference to FIGS. <highlight><bold>6</bold></highlight>-<highlight><bold>9</bold></highlight>, a user profile object can be used to generate both the personal greeting and the recommended products fragments. The web site can cache the intermediate user profile object so that it can be used across multiple requests by that user. The back end monitor can support caching of such objects. Additionally, the back end monitor can cache any arbitrary object that can be serializable. Objects that are cacheable can be tagged in a manner similar to the tagging methods described above. However, those objects can be given a special identifier to indicate that they are to be cached in the back end monitor and that they are not to be sent to the dynamic proxy cache. </paragraph>
<paragraph id="P-0152" lvl="0"><number>&lsqb;0152&rsqb;</number> The present invention can be used with computer hardware and software that performs the methods and processing functions described above. As will be appreciated by those skilled in the art, the systems, methods, and procedures described herein can be embodied in a programmable computer, computer executable software, or digital circuitry. The software can be stored on computer readable media. For example, computer readable media can include a floppy disk, RAM, ROM, hard disk, removable media, flash memory, memory stick, optical media, magneto-optical media, CD-ROM, etc. Digital circuitry can include integrated circuits, gate arrays, building block logic, field programmable gate arrays (FPGA), etc. </paragraph>
<paragraph id="P-0153" lvl="0"><number>&lsqb;0153&rsqb;</number> Although specific embodiments of the present invention have been described above in detail, the description is merely for purposes of illustration. Various modifications of, and equivalent steps corresponding to, the disclosed aspects of the exemplary embodiments, in addition to those described above, may be made by those skilled in the art without departing from the spirit and scope of the present invention defined in the following claims, the scope of which is to be accorded the broadest interpretation so as to encompass such modifications and equivalent structures. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A web page delivery system for dynamically generating a web page comprising cacheable content, said delivery system comprising: 
<claim-text>an origin site infrastructure comprising 
<claim-text>an application server operative to receive a web page request from a user, to generate a web page template corresponding to a layout of the web page, and to forward the template for creation of the web page, and </claim-text>
<claim-text>a back end monitor operative to insert a key into the template, the key identifying a cacheable content fragment; and </claim-text>
</claim-text>
<claim-text>a dynamic proxy cache operative to receive the template from said application server, to create the web page as instructed in the template by inserting the cacheable content fragment identified by the key, and to deliver the web page to the user. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. A web page delivery system according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein said back end monitor is further operative to determine whether the web page comprises the cacheable content fragment, and 
<claim-text>wherein said back end monitor inserts the key into the template in response to a determination that the web page comprises the cacheable content fragment. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. A web page delivery system according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein said back end monitor is further operative to determine whether the cacheable content fragment is stored in said dynamic proxy cache, and 
<claim-text>wherein said back end monitor inserts the key into the template in response to a determination that the cacheable content fragment is stored in said dynamic proxy cache. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. A web page delivery system according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein said back end monitor is further operative to determine whether the cacheable content fragment is stored in said dynamic proxy cache, 
<claim-text>wherein said back end monitor generates the cacheable content fragment and inserts the cacheable content fragment into the template in response to a determination that the cacheable content fragment is not stored in said dynamic proxy cache, and </claim-text>
<claim-text>wherein said dynamic proxy cache stores the cacheable content fragment after receiving the template from said application server. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. A web page delivery system according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein said back end monitor is further operative to maintain a cache directory comprising information that the cacheable content fragment is stored in said dynamic proxy cache. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. A web page delivery system according to <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference>, wherein said back end monitor is further operative to update the cache directory if the cacheable content fragment becomes invalid. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. A web page delivery system according to <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference>, wherein said back end monitor is further operative to send a message to said dynamic proxy cache to remove the invalid cacheable content fragment. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. A web page delivery system according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising a plurality of dynamic proxy caches, 
<claim-text>wherein said back end monitor is further operative determine whether the cacheable content fragment is stored in a specific one of said plurality of dynamic proxy caches. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. A web page delivery system according to <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference>, wherein said back end monitor is further operative to maintain a cache directory comprising information indicating whether the cacheable content fragment is stored in a specific one of said plurality of dynamic proxy caches. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. A web page delivery system according to <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, wherein the information comprises a bit vector associated with the cacheable content fragment. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. A method for delivering a web page, comprising the steps of: 
<claim-text>receiving a web page request, the web page request corresponding to a web page comprising cacheable content; </claim-text>
<claim-text>executing a script in response to the web page request, the script comprising a code block corresponding to a content fragment of the web page; </claim-text>
<claim-text>producing a template corresponding to a layout of the web page; </claim-text>
<claim-text>determining whether the content fragment is cacheable; </claim-text>
<claim-text>inserting a key into the template in response to a determination that the content fragment is cacheable, the key identifying the cacheable content fragment; </claim-text>
<claim-text>sending the template to a dynamic proxy cache; </claim-text>
<claim-text>inserting into the web page, by the dynamic proxy cache, the cacheable content fragment identified by the key; and </claim-text>
<claim-text>transmitting the web page comprising the cacheable content fragment. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, wherein said determining step comprises determining whether the code block comprises a tag indicating that the content fragment is cacheable. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, wherein the code block comprises a tag indicating cache characteristics of the content fragment, and 
<claim-text>wherein said determining step comprises reading the tag to determine the cache characteristics of the content fragment. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference>, further comprising the steps of: 
<claim-text>executing the code block to generate the content element in response to a determination that the content fragment is non-cacheable; and </claim-text>
<claim-text>inserting the non-cacheable content element into the template. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, further comprising the step of inserting a command into the template in response to a determination that the content fragment is cacheable, the command instructing the dynamic proxy cache to retrieve the cacheable content fragment. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, further comprising the steps of: 
<claim-text>determining whether the cacheable content fragment is stored in the dynamic proxy cache; and </claim-text>
<claim-text>retrieving the key from a cache directory in response to a determination that the cacheable content fragment is stored in the dynamic proxy cache. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, further comprising the step of updating the cache directory by releasing the key identifying the cacheable content fragment when the cacheable content fragment becomes invalid. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference>, further comprising the step of sending a message to the dynamic proxy cache to remove the invalid content fragment. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, wherein said step of determining whether the cacheable content fragment is stored in the dynamic proxy cache comprises reading a bit vector associated with the key, the bit vector comprising a bit corresponding to the dynamic proxy cache. </claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference>, further comprising the step of updating the cache directory by releasing the key identifying the cacheable content fragment when the cacheable content fragment becomes invalid. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00022">claim 20</dependent-claim-reference>, wherein said updating step comprises clearing the bit of the bit vector. </claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, further comprising the step of storing the cacheable content fragment in architecture of a web site. </claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, further comprising the steps of: 
<claim-text>determining whether the cacheable content fragment is stored in the dynamic proxy cache; </claim-text>
<claim-text>executing the code block to generate the cacheable content fragment in response to a determination that the cacheable content fragment is not stored in the dynamic proxy cache; </claim-text>
<claim-text>inserting the cacheable content fragment into the template; and </claim-text>
<claim-text>storing the cacheable content fragment in the dynamic proxy cache after said sending step. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00022">claim 23</dependent-claim-reference>, further comprising the step of inserting a command into the template, the command instructing the dynamic proxy cache to perform said storing step. </claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00022">claim 23</dependent-claim-reference>, further comprising the step of storing the key in a cache directory. </claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>, further comprising the step of updating the cache directory by releasing the key identifying the cacheable content fragment when the cacheable content fragment becomes invalid. </claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00022">claim 26</dependent-claim-reference>, further comprising the step of sending a message to the dynamic proxy cache to remove the invalid cacheable content fragment. </claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. A computer-readable medium having computer-executable instructions for performing the method of <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>. </claim-text>
</claim>
<claim id="CLM-00029">
<claim-text><highlight><bold>29</bold></highlight>. A method for delivering a web page, comprising the steps of: 
<claim-text>receiving a web page request; </claim-text>
<claim-text>executing a script in response to the web page request, the script comprising a code block corresponding to a content fragment of the web page; </claim-text>
<claim-text>producing a template at run-time corresponding to a layout of the web page; </claim-text>
<claim-text>assembling the web page according to the template by inserting the content fragment; and </claim-text>
<claim-text>transmitting the web page comprising the content fragment. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00030">
<claim-text><highlight><bold>30</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00022">claim 29</dependent-claim-reference>, further comprising the steps of: 
<claim-text>determining whether the content fragment is cacheable; and </claim-text>
<claim-text>inserting a key into the template in response to a determination that the content fragment is cacheable, the key identifying the content fragment, </claim-text>
<claim-text>wherein said assembling step comprises inserting into the web page the content fragment identified by the key. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00031">
<claim-text><highlight><bold>31</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00033">claim 30</dependent-claim-reference>, further comprising the step of sending the template to a dynamic proxy cache, 
<claim-text>wherein the dynamic proxy cache performs said assembling step. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00032">
<claim-text><highlight><bold>32</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00022">claim 29</dependent-claim-reference>, further comprising the step of sending the template to a dynamic proxy cache, 
<claim-text>wherein the dynamic proxy cache performs said assembling step. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00033">
<claim-text><highlight><bold>33</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00033">claim 32</dependent-claim-reference>, further comprising the steps of: 
<claim-text>determining whether the content fragment is cacheable; and </claim-text>
<claim-text>inserting a key into the template in response to a determination that the content fragment is cacheable, the key identifying the content fragment, </claim-text>
<claim-text>wherein said assembling step comprises inserting into the web page the content fragment identified by the key. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00034">
<claim-text><highlight><bold>34</bold></highlight>. A computer-readable medium having computer-executable instructions for performing the method of <dependent-claim-reference depends_on="CLM-00022">claim 29</dependent-claim-reference>. </claim-text>
</claim>
<claim id="CLM-00035">
<claim-text><highlight><bold>35</bold></highlight>. A method for assigning a key to a cacheable content fragment, the content fragment having a fragment ID, said method comprising the steps of: 
<claim-text>determining whether the fragment ID corresponding to the cacheable content fragment exists in a cache directory maintained at a web site, the cache directory comprising information indicating whether the content fragment is stored in a dynamic proxy cache; </claim-text>
<claim-text>assigning a key to the content element in response to a determination that the fragment ID does not exist in the cache directory; and </claim-text>
<claim-text>inserting the key into the cache directory. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00036">
<claim-text><highlight><bold>36</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00033">claim 35</dependent-claim-reference>, wherein, in said assigning step, the key is assigned by taking the next available key from a list of keys. </claim-text>
</claim>
<claim id="CLM-00037">
<claim-text><highlight><bold>37</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00033">claim 36</dependent-claim-reference>, further comprising the step of updating the cache directory when the content fragment becomes invalid by releasing the key assigned to the content fragment and inserting the key back into the list of keys. </claim-text>
</claim>
<claim id="CLM-00038">
<claim-text><highlight><bold>38</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00033">claim 36</dependent-claim-reference>, wherein the key comprises an integer, and 
<claim-text>wherein the list of keys comprises a free list of unused integers. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00039">
<claim-text><highlight><bold>39</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00033">claim 35</dependent-claim-reference>, wherein the cache directory comprises information indicating whether the content fragment is stored in one of a plurality of dynamic proxy caches. </claim-text>
</claim>
<claim id="CLM-00040">
<claim-text><highlight><bold>40</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00033">claim 39</dependent-claim-reference>, wherein the information comprises a bit vector having a plurality of bits, each bit corresponding to a respective one of the plurality of dynamic proxy caches. </claim-text>
</claim>
<claim id="CLM-00041">
<claim-text><highlight><bold>41</bold></highlight>. The method according to claim <highlight><bold>40</bold></highlight>, further comprising the step of updating the cache directory when the content fragment becomes invalid by releasing the key assigned to the content fragment. </claim-text>
</claim>
<claim id="CLM-00042">
<claim-text><highlight><bold>42</bold></highlight>. The method according to claim <highlight><bold>41</bold></highlight>, wherein the key is released in said updating step by clearing each bit of the bit vector. </claim-text>
</claim>
<claim id="CLM-00043">
<claim-text><highlight><bold>43</bold></highlight>. A computer-readable medium having computer-executable instructions for performing the method of claim <highlight><bold>35</bold></highlight>.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>3A</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030004998A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030004998A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030004998A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030004998A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030004998A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030004998A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030004998A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030004998A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030004998A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00009">
<image id="EMI-D00009" file="US20030004998A1-20030102-D00009.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00010">
<image id="EMI-D00010" file="US20030004998A1-20030102-D00010.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00011">
<image id="EMI-D00011" file="US20030004998A1-20030102-D00011.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00012">
<image id="EMI-D00012" file="US20030004998A1-20030102-D00012.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00013">
<image id="EMI-D00013" file="US20030004998A1-20030102-D00013.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00014">
<image id="EMI-D00014" file="US20030004998A1-20030102-D00014.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00015">
<image id="EMI-D00015" file="US20030004998A1-20030102-D00015.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00016">
<image id="EMI-D00016" file="US20030004998A1-20030102-D00016.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00017">
<image id="EMI-D00017" file="US20030004998A1-20030102-D00017.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00018">
<image id="EMI-D00018" file="US20030004998A1-20030102-D00018.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
