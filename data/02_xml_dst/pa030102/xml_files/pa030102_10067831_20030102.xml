<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005409A1-20030102-D00000.TIF SYSTEM "US20030005409A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005409A1-20030102-D00001.TIF SYSTEM "US20030005409A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005409A1-20030102-D00002.TIF SYSTEM "US20030005409A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005409A1-20030102-D00003.TIF SYSTEM "US20030005409A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005409A1-20030102-D00004.TIF SYSTEM "US20030005409A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005409A1-20030102-D00005.TIF SYSTEM "US20030005409A1-20030102-D00005.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005409</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10067831</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20020205</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F009/44</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>717</class>
<subclass>110000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>System and method for modifying software without halting its execution</title-of-invention>
</technical-information>
<continuity-data>
<non-provisional-of-provisional>
<document-id>
<doc-number>60302420</doc-number>
<document-date>20010702</document-date>
<country-code>US</country-code>
</document-id>
</non-provisional-of-provisional>
</continuity-data>
<inventors>
<first-named-inventor>
<name>
<given-name>Pradeep</given-name>
<family-name>Tumati</family-name>
</name>
<residence>
<residence-us>
<city>Blacksburg</city>
<state>VA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
</inventors>
<correspondence-address>
<name-1>McNair Law Firm, P.A.</name-1>
<name-2></name-2>
<address>
<address-1>P.O. Box 10827</address-1>
<city>Greenville</city>
<state>SC</state>
<postalcode>29603</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">This invention is directed to a computerized system and method for modifying an executing target software application segmented into grains according to a hot pack without halting its execution. Modification can be performed according to second version object code contained within said hot pack. Modifications can be performed immediately upon receipt of the hot pack or during the subsequent resumption of execution of the target application. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">FIELD OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> This invention is directed to a computerized system and method for modifying an executing target computer application without the need to halt the target application. This application claims priority pursuant to 35 U.S.C. &sect;119 of provisional patent application No. 60/302,420 that was filed on Jul. 2, 2001. </paragraph>
</section>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> From the mid-1980&apos;s to the present, there has been an extraordinary adaptation of computers into almost all aspects of business. The unparalleled explosion of the computer software industry and the Internet has led to a high reliance on technology and particularly, software applications. While there have been astronomical advances in computer hardware, essentially it is the software applications which are at the core of the functionality of computers. Simply said, a computer is useless without software to run it. Nearly a decade ago, e-mail was just entering the private sector and becoming adopted by businesses for day to day communications. Today, it is hard to imagine functioning without such advances as e-mail, instant messaging, global communications, file transfers, and other electronic transmissions all made possible by advances in computer technology. The side effect of this tremendous acceptance of computerized systems is that individuals and businesses are becoming more and more reliant upon these systems and, particularly, on the applications running them. It has now reached the point to where applications need to run uninterrupted or else their users are deprived of their functionality and operations of the business are dramatically effected </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> Applications that must run uninterrupted exist in several areas. For example, business software that provides service for clients 24 hours a day, such as 24-hour stock trading systems, hospital equipment used to maintain patients&apos; health, and radar and air traffic control systems which are used to control airline flights. None of these systems can tolerate downtime. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> In the case of stock trading, seconds of downtime in today&apos;s volatile stock market can cost millions of dollars. Banking software and many e-businesses need their software running continuously. A period of downtime damages both the profits of a company and the goodwill a company has developed by offering continuous service. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> In today&apos;s global economy, there is no time that a section of business software can be safely offline. Although it may be 3:00 a.m. in the United States and 9:00 a.m. in London, potential as well as existing customers need to access computer systems at all times. Thus, there is no time that is conducive to having a software outage. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> With the necessity of software applications running 24-hours a day and seven days a week, a problem is created as to how to update or maintain the software of the system. Software development is complicated and can involve millions of lines of code which, inevitably, will need to be updated many times throughout its life-span. Modifications are necessary for both bug correction and to offer new functionality. To compound the problem, it is common practice for a software vendor to issue software with known bugs that are to be corrected later. The &ldquo;first-in-market&rdquo; strategy has created the practice of distributing &ldquo;beta&rdquo; versions and 1.0 versions. This strategy does not allow a software vendor to absolutely perfect the software product before going to market. With the existing technology, software must be halted before an upgrade can be made. Thus, businesses have to choose between downtime that results in lost customers and profits or upgrading software to offer new functionality or correct bugs. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> While profits and customer relations are affected, more important are health care concerns. Today&apos;s new hospital equipment is mostly computerized and contains software. Therefore, hospitals have to wait for a piece of equipment to no longer be in use before upgrading the residing application. For example, problems arise when a patient is in critical need of a piece of equipment and that equipment needs to be upgraded for the benefit of the patient but the equipment simply can not be turned off. In this situation, the patient is not able to receive the best possible care do to the lack of the existence of software as a catch-<highlight><bold>22</bold></highlight> exists between operating with outdated software or stopping the software for an upgrade. Attempts in the past to solve this problem have resulted in maintaining redundant systems which at least doubles the cost of the system to the hospital. While redundant systems are a good practice, they require disconnecting a patient from a piece of equipment, replacing the existing equipment with a new piece of equipment, and performing maintenance on the existing piece of equipment. The ability to update the software without needing to halt the use of the equipment would significantly reduce the number of redundant systems needed and would allow a back-up piece of equipment to service several online systems. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> Also of importance are the computer systems used by air traffic controllers and military radar systems. Both of these systems need to run uninterrupted, yet both need to be periodically upgraded. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> Previous attempts to provide for the modification of an executing application have not provided a satisfactory remedy. Previous attempts fall short in at least three key areas. First, they create another application in memory that wastes valuable computer resources. Second, if the old application takes a long time to finish operating, then there will be two applications in memory wastefully using resources for an unacceptably long time or perhaps indefinitely. Third, system failures during the modification process severely damage the integrity of the computer system. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> For example, U.S. Pat. No. 4,954,941 attempts to provide a method for modifying a currently executing application. It allows an executing application to be modified so long as errors in data are acceptable. Otherwise, the system halts the executing application and performs the modification. This system is only a usable solution if data corruption is acceptable. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> Another example is U.S. Pat. No. 5,274,808, which attempts to alleviate the data integrity concerns of the U.S. Pat. No. 4,954,941 patent by creating a separate modified application that runs with the other unmodified application. Data is directed to the new application while the data in the old application ends its execution. When the old application finishes, the new, modified application becomes the only version of the application. This process, however, wastes valuable computer resources. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> Accordingly, an object of the present invention is to provide a method to safely modify an executing software application without halting the application. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> Another object of the present invention is to provide software that will maintain a currently executing application without having to halt the application and while maintaining data integrity. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> Another object of the present invention is to provide software that can update an executing application in RAM and store the updated application to fixed storage medium simultaneously. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> Still another objective of the present invention is to provide a system and method for modifying software that does not have a steep learning curve. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> The above objectives are accomplished through an automated system and method for modifying an executing software application, having an address space and at least one grain, defined by grain boundaries, and crumb associated with at least one grain, without halting the executing application comprising a computer readable medium and a set of computer readable hot swapper instructions. A computerized system and embodied in a computer readable medium is provided having a set of computer readable instructions embodied in the computer readable medium. A method for performing the above functionality is also provided since these steps can be automatically performed through computer software or manually performed through human intervention. The computer readable instructions provide for receiving a hot pack having a dictum and a second version grain, opening the hot pack, suspending the target software application, determining the status of at least one of the first version grains of the target software application, modifying at least one of the first version grains of the target software application according to the second version grain and the dictum of the hot pack if the determination of the status of the first version grain allows for its immediate modification, and, resuming execution of the target application so that modification of the target software application is achieved without halting its execution. Additionally, performance of a validity operation according to the dictum can be triggered so that data and functional integrity is maintained within the target software application subsequent modification of the target software application. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> Further, the system can include instructions for resizing the address space of the target software application according to the hot pack, copying the second version grain within the address space of the target software application, and copying the dictum into the address space of the target software application. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> The first version grains can have associated crumbs having an active and inactive state and the computer readable instructions include instructions for activating the associated crumb upon the determination that the status of the first grain to be modified does not allow for its immediate modification. The system can also include instructions for, when encountering the crumb in an active state, suspending the executing software application, determining whether the first grain associated with the active crumb can be modified according to the associated dictum, modifying the first version grain according to the second version grain and the dictum if the determination of whether the first version grain can be modified is affirmative, and resuming execution of the target software application so that the target application can be modified without halting its execution. The system can also include instructions for determining if any dictums associated with active crumbs can be executed upon encountering any active grain and execute all dictums that are properly executable. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> The system can include a hot pack contained with the computer readable medium, a second version grain contained within the hot pack, and a dictum associated with at least one of the first version grains contained within the hot pack for providing instructions for modification of at least one of the first version grains according to the dictum.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> The construction designed to carry out the invention will hereinafter be described, together with other features thereof. The invention will be more readily understood from a reading of the following specification and by reference to the accompanying drawings forming a part thereof, wherein an example of the invention is shown and wherein: </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a schematic of the hardware and software; </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a schematic of grains and grain boundaries; </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a schematic illustrating the modification of an old grain; </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a flowchart illustrating the hot swapper; and, <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a flowchart illustrating the steps for a crumb.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DESCRIPTION OF A PREFERRED EMBODIMENT </heading>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> The detailed description that follows may be presented in terms of program procedures executed on a computer or network of computers. These procedural descriptions are representations used by those skilled in the art to most effectively convey the substance of their work to others skilled in the art. These procedures herein described are generally a self-consistent sequence of steps leading to a desired result. These steps require physical manipulations of physical quantities such as electrical or magnetic signals capable of being stored, transferred, combined, compared, or otherwise manipulated. An object or module is a section of computer readable code embodied in a computer readable medium that is designed to perform a specific task or tasks. Actual computer or executable code or computer readable code may not be contained within one file or one storage medium but may span several computers or storage mediums. The term &ldquo;host&rdquo; and &ldquo;server&rdquo; may be hardware, software, or combination of hardware and software that provides the functionality described herein. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> The present invention is described below with reference to flowchart illustrations of methods, apparatus (&ldquo;systems&rdquo;) and computer program products according to the invention. It will be understood that each block of a flowchart illustration can be implemented by a set of computer readable instructions or code. These computer readable instructions may be loaded onto a general purpose computer, special purpose computer, or other programmable data processing apparatus to produce a machine such that the instructions will execute on a computer or other data processing apparatus to create a means for implementing the functions specified in the flowchart block or blocks. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> These computer readable instructions may also be stored in a computer readable medium that can direct a computer or other programmable data processing apparatus to function in a particular manner, such as the instructions stored in a computer readable medium that produce an article of manufacture including instruction means that implement the functions specified in the flowchart block or blocks. Computer program instructions may also be loaded onto a computer or other programmable apparatus to produce a computer executed process. These instructions are executed on the computer or other programmable apparatus which provide steps for implementing the functions specified in the flowchart block or blocks. Accordingly, elements of the flowchart support combinations of means for performing these special functions, combination of steps for performing the specified functions and program instruction means for performing the specified functions. It will be understood that each block of the flowchart illustrations can be implemented by special purpose hardware based computer systems that perform the specified functions, or steps, or combinations of special purpose hardware or computer instructions. The present invention is now described more fully herein with reference to the drawings in which the preferred embodiment of the invention is shown. This invention may, however, be embodied in many different forms and should not be construed as limited to the embodiment set forth herein. Rather, these embodiments are provided so that this disclosure will be thorough and complete and will fully convey the scope of the invention. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> For purposes of explaining this invention to those skilled in the art, the following terminology is used. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> &ldquo;Initial Version&rdquo;&mdash;The alpha version of source code, or object code. This version is created without the existence of any previous versions and is the version that exists before all others. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> &ldquo;First Version&rdquo;&mdash;A version prior to a subsequent version. The first version can also be the initial version, but is not necessarily the initial version. For example, version 2.0 can be a first version to version 3.0. A first version is modified to a second version as described in this application. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> &ldquo;Second Version&rdquo;&mdash;A version subsequent to a first version which is a modification of the first version. The second version would, for example, be version 3.0 from 2.0. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> &ldquo;Source code&rdquo; is program instructions generally written as a text file that must be translated by a compiler or interpreter or sent into object code for a particular computer before the computer can execute the program. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> &ldquo;Object code&rdquo; is computer readable output produced by compiler, interpreter, or assembler that can be executed directly by a computer. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> &ldquo;Executable code&rdquo; is a collection of object code that may be linked with libraries in order to produce a finalized program to be executed by a computer. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> &ldquo;Halting&rdquo;, when used in terms of target application execution, means when the target application is stopped and the instruction counter is reset to the initial position. Therefore the execution of the application begins from the beginning rather than resuming from where the instruction counter is located. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> &ldquo;Suspension&rdquo;, when used in terms of target application execution, means when execution of the target application is suspended without altering the position of the instruction counter. Therefore, the target application can be resumed from where the instruction counter is located rather than resetting the instruction counter to the initial position. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> In development of software, there are two stages. First, the initial version is created by the computer programmer and shipped to a customer for execution. After this version is executing at the client&apos;s location, the initial version may need to be modified for various reasons. Such reason can be to add functionality, correct errors, or to provide compatibility with new or different hardware. When the first version is created, the source code and associated object code is stored in the database <highlight><bold>22</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 1</cross-reference> of the developer computer <highlight><bold>20</bold></highlight> within a computer readable medium <highlight><bold>21</bold></highlight>. The computer programmer uses a computer program such as an editor to create human readable source code representing the desired functionality according to the programmer&apos;s wishes. The source code is then translated into object code through a compiler, translator, or assembler. The object code is then sent to a customer or client site for execution. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> Subsequently, the computer programmer may modify the first version to create a second version. The second version is present at the computer programmer&apos;s location. Therefore, the client or customer computers that have the initial version executing need to be updated so as to be executing the second version rather than the outdated initial version. For purposes of this invention, the initial version is also a first version, but a first version does not have to be the initial version. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 1, a</cross-reference> client computer <highlight><bold>12</bold></highlight> contains a readable medium <highlight><bold>14</bold></highlight> that has a first version of object code <highlight><bold>10</bold></highlight>, also described as the target application, executing on computer <highlight><bold>12</bold></highlight>. While object code can be linked to libraries to create executable versions, the term object code is used to include the executable version of the software. The target application is contained within computer readable medium <highlight><bold>14</bold></highlight>. Additionally, computer readable instructions, coined a &ldquo;hot swapper,&rdquo; is present in computer readable medium <highlight><bold>14</bold></highlight> of client computer <highlight><bold>12</bold></highlight>. Hot swapper <highlight><bold>16</bold></highlight> is a set of computer readable instructions that performs the functionality of modifying the first version to the second version on client computer <highlight><bold>12</bold></highlight> without halting target application <highlight><bold>10</bold></highlight>. Hot swapper <highlight><bold>12</bold></highlight> may be a separate application from the target application and therefore can run continuously on the client computer regardless of whether the target application is executing or not. The hot swapper may also be functionality embedded within target program <highlight><bold>10</bold></highlight> and contained within the same object code as the target. If the hot swapper is part of the target program, then it automatically executes whenever the target program executes. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> When the computer programmer wishes to update a first version to a second version, the computer programmer utilizes a development computer <highlight><bold>20</bold></highlight> that contains a development environment for updating the software. The computer programmer retrieves source code <highlight><bold>18</bold></highlight> into an editor and performs the edits necessary to convert the first version of the source code to the second version. Once the source code is completed, object code <highlight><bold>24</bold></highlight> is created from source code <highlight><bold>18</bold></highlight>. The information necessary to modify the first version to the second version is then stored in a computer file <highlight><bold>26</bold></highlight>, coined as a &ldquo;hot pack,&rdquo; that is then transmitted from the developer computer to the client computer. The hot pack contains at least a portion of object code <highlight><bold>28</bold></highlight> of the second version to be used to modify the first version. The portion of object code contained in the hot pack can be called second version grains further define below. Rules or dictums <highlight><bold>30</bold></highlight> for performing the modification of the first version to the second version are also included in the hot pack. Dictums are instructions that contain the actual steps and conditions necessary to replace the first version object code with second version object code. There are at least three types of dictums, first for modification of a first version to a second version, second for performing certain tasks based upon the condition of the target application, and third, dictums that both modify portions of object code or grains as well as perform certain tasks associated with that dictum. For example, dictums may inform the hot swapper to replace certain portions of object code or grains only upon predetermined conditions such as the state of the instruction counter, the value of certain variables, or the ability to execute several dictums at once. Therefore, the hot pack contains not only what to use for modifying the first version, but also how to perform the modifications. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> When the hot pack is sent to the client so that the first version executing on the client&apos;s computer can be updated. The hot pack is then received by hot swapper <highlight><bold>16</bold></highlight> of client computer <highlight><bold>12</bold></highlight> and the hot pack is then opened in order to perform the necessary modifications on the target application. The object code of the target application is replaced with a second version object code <highlight><bold>28</bold></highlight> of the hot pack. Turning now to <cross-reference target="DRAWINGS">FIG. 2, a</cross-reference> first (old) function <highlight><bold>18</bold></highlight> is shown having grain boundaries defining grains <highlight><bold>18</bold></highlight><highlight><italic>a</italic></highlight>, <highlight><bold>18</bold></highlight><highlight><italic>b</italic></highlight>, and <highlight><bold>18</bold></highlight><highlight><italic>c</italic></highlight>. Grains delineate the source code and object code into discreet segments of specific statements <highlight><bold>15</bold></highlight><highlight><italic>d</italic></highlight>, functions <highlight><bold>15</bold></highlight><highlight><italic>b</italic></highlight>, or the entire program unit <highlight><bold>15</bold></highlight><highlight><italic>a</italic></highlight>. By dividing the source code into discreet segments, it is possible to map the grains of the first version to the grains of the second version thereby localizing the amount of changes needed to the target application to modify a first version to a second version. By modifying only those grains affected, an efficient method of updating a first version to a second version is achieved. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> By way of example, first grain <highlight><bold>18</bold></highlight> is contained within a first version or initial version of the target software application executing on the client that the programmer wishes to modify. The computer programmer retrieves the source code containing function <highlight><bold>18</bold></highlight> into an editing module and modifies grain <highlight><bold>18</bold></highlight><highlight><italic>c </italic></highlight>into grain <highlight><bold>44</bold></highlight>, thereby, creating function <highlight><bold>44</bold></highlight>. In this example, grain <highlight><bold>18</bold></highlight><highlight><italic>c </italic></highlight>of function <highlight><bold>18</bold></highlight> contains the equation (a&plus;x)/x. This equation needs to be updated to b&circ; x, shown as <highlight><bold>44</bold></highlight><highlight><italic>c </italic></highlight>of function <highlight><bold>44</bold></highlight>. First (old) grain <highlight><bold>18</bold></highlight><highlight><italic>c </italic></highlight>is replaced with the second (new) grain <highlight><bold>44</bold></highlight><highlight><italic>c </italic></highlight>in order to update the first version to the second version. A dictum or rule would be associated with the modification of grain <highlight><bold>18</bold></highlight><highlight><italic>c </italic></highlight>to perform the steps to modify this grain and replace grain <highlight><bold>18</bold></highlight><highlight><italic>c </italic></highlight>with grain <highlight><bold>44</bold></highlight><highlight><italic>c</italic></highlight>. Additionally, the dictum may also contain other conditions to modify the grain. For example, the dictums associated with replacement of first grain <highlight><bold>18</bold></highlight><highlight><italic>c </italic></highlight>with second grain <highlight><bold>44</bold></highlight><highlight><italic>c </italic></highlight>may include a condition that grain <highlight><bold>18</bold></highlight><highlight><italic>a </italic></highlight>must be replaced with grain <highlight><bold>44</bold></highlight><highlight><italic>a </italic></highlight>contemporaneously. In this case, the dictum would not allow the modification of first grain <highlight><bold>18</bold></highlight><highlight><italic>c </italic></highlight>unless modification of grain <highlight><bold>18</bold></highlight><highlight><italic>a </italic></highlight>was also allowed. If grain <highlight><bold>18</bold></highlight><highlight><italic>a </italic></highlight>is not modifiable, grain <highlight><bold>18</bold></highlight><highlight><italic>c </italic></highlight>would not be modified and must be marked for subsequent modification when conditions for modification contained in the dictum are satisfied. When the first version grain is immediately modifiable upon initial execution of the hot pack, the first version grain can be modified in an instantaneous phase as explained below. When the first version grain cannot be modified immediately based upon some condition unsatisfied, the modification must take place during an incremental phase as explained below. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> Execution of dictums contained in the hot pack for replacing old grains with new grains can occur in two manners. In an instantaneous phase, the hot swapper has determined that there are dictums that can be executed immediately. The instantaneous phase occurs during the period of time when the target application is first suspended and when the execution of the target application is first resumed. These dictums are executed and the second (new) grains associated with these dictums are used to modify the corresponding first (old) grains of the executing application according to the dictums executed. The address space of the first grain that is now not being used can then be placed in a garbage table for reuse. The garbage table is an area or table that tracks address space within the target application that is no longer in use and can be recaptured or reused for other purposes. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> In the instantaneous phase, the first grain is immediately modified according to the dictums associated with the first grain according to the hot pack. The hot swapper suspends the execution of the target application and then examines the address space of the application. If necessary, the hot swapper resizes the address space of the target application and executes all the dictums that can be immediately executed. The hot swapper then resumes the execution of the target application. If a dictum can not be immediately modified, the modification of those grains is delayed for modification during the incremental phase. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 3</cross-reference>, modification of the first grain can be achieved by adding a new jump instruction <highlight><bold>58</bold></highlight><highlight><italic>f </italic></highlight>so as to proceed to first (old) grain <highlight><bold>58</bold></highlight>. Second (new) grain <highlight><bold>60</bold></highlight>, having been copied to the resized address space of the target application, can be the subject of new jump instruction <highlight><bold>58</bold></highlight><highlight><italic>f</italic></highlight>. Therefore, when the target application resumes, jump instruction <highlight><bold>58</bold></highlight><highlight><italic>f </italic></highlight>causes second grain <highlight><bold>60</bold></highlight> to execute rather than first grain <highlight><bold>58</bold></highlight><highlight><italic>a</italic></highlight>. The first version is modified to the second version. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> The incremental phase, occurs after the first resumption of the target application and uses a crumb to indicate what dictums need to be executed after the instantaneous phase. Adjacent to a first grain is a jump instruction <highlight><bold>58</bold></highlight><highlight><italic>b </italic></highlight>and crumb <highlight><bold>58</bold></highlight><highlight><italic>c</italic></highlight>. The crumb and jump instruction can be added to the first grain by the hot swapper or can be associated with the first grain when the target application is compiled, assembled or translated. When the crumb is added by the hot swapper, jump instruction <highlight><bold>58</bold></highlight><highlight><italic>b </italic></highlight>is not necessary. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> In alternative embodiments, one skilled in the art may use various means for establishing that a crumb has an active state and inactive state as well as various means for detecting the particular state of a crumb. An active crumb is one that will execute to cause to have executed modification instructions. Modification instructions are those instructions that perform the modification of the first version and can include dictums. Therefore, when the instruction counter encounters active grains, the target application may be modified according to the dictums that can be exeucted. An inactive grain does not cause the modification instructions to execute when encountered by the instruction counter. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> In another embodiment, the crumbs can be activated when the hot pack is activated when the hot pack Is received or by the hot swapper at predetermined times. When all crumbs are active, the target application determines if any dictum is to be executed when any active crumb is encountered. Therefore, the target application is always checking to determine if dictums of a hot pack can be executed. However, this embodiment may cause unnecessary processing cycles to be used since all crumbs are active and all dictums are checked at all active crumbs. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> In another embodiment, the next instruction command <highlight><bold>58</bold></highlight><highlight><italic>d </italic></highlight>is executed when jump instruction <highlight><bold>58</bold></highlight><highlight><italic>b </italic></highlight>passes control to next instruction command <highlight><bold>58</bold></highlight><highlight><italic>d </italic></highlight>that in turn passes control to the next grain. However, when the first version grain is to be modified in the incremental phase, the computer readable instructions, or hot swapper located at the client site, include instructions to convert jump instruction <highlight><bold>58</bold></highlight><highlight><italic>b </italic></highlight>into a no-op instruction <highlight><bold>58</bold></highlight><highlight><italic>e</italic></highlight>. The no-op instructions causes crumb <highlight><bold>58</bold></highlight><highlight><italic>c </italic></highlight>to execute thereby causing modification instructions <highlight><bold>59</bold></highlight> to execute. The modification instructions include instructions to perform the steps contained within the dictums as well as other functionality such as a validity operation. These modifications instructions can assist in the execution of dictums, merely cause the dictums to be executed, or insure that the dictums executed do not create invalid conditions within the target application through validity operations. A validity operation is a set of computer readable instructions associated with a dictum to insure data and functional integrity within the target application after modification. The validity operation can also contain instructions for internal processing, library calls, and input/output operations. For example, if grain <highlight><bold>18</bold></highlight><highlight><italic>b </italic></highlight>(<cross-reference target="DRAWINGS">FIG. 2</cross-reference>) was to be modified to the statement a&equals;5, the value stored in a grain <highlight><bold>18</bold></highlight><highlight><italic>c </italic></highlight>would have to changed in some cases to maintain data integrity. This is especially true if the instruction counter had already passed by grain <highlight><bold>18</bold></highlight><highlight><italic>b</italic></highlight>. Therefore, a validity operator could be used to change the value of &ldquo;a&rdquo; and data integrity is maintained. If the modification instructions determine that the first grain can be modified when the active crumb is encountered, new jump instruction <highlight><bold>58</bold></highlight><highlight><italic>f </italic></highlight>is placed in front of the first grain to point to new grain <highlight><bold>60</bold></highlight>. New grain <highlight><bold>60</bold></highlight> then executes next instruction <highlight><bold>60</bold></highlight><highlight><italic>a</italic></highlight>. The old grain and associated old crumb are moved into the garbage table and no longer part of the executing code of the target application. Consequently, the functionality of new grain <highlight><bold>60</bold></highlight> effectively replaces the functionality of old grain <highlight><bold>58</bold></highlight> and the object code is updated to a second version. In placing second grain <highlight><bold>60</bold></highlight> and next instruction <highlight><bold>60</bold></highlight><highlight><italic>a </italic></highlight>within the address space of the target application, it may be necessary to resize the address space of the target application. Accordingly, the address space of the target application can be resized during the instantaneous phase or during the incremental phase to allow for such modification. Also, second grain <highlight><bold>60</bold></highlight> and next instruction <highlight><bold>60</bold></highlight><highlight><italic>a </italic></highlight>can be copied to the address space of the target application during the instantaneous phase or the incremental phase. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> Referring now to <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, the steps for performing the modification of a first version to a second version are shown in more detail. Step <highlight><bold>47</bold></highlight> represents the executing application target object code executing. Step <highlight><bold>48</bold></highlight> represents the determination of whether a hot pack is present. If there is no hot pack present, the process returns to step <highlight><bold>47</bold></highlight> where the target application continues to execute. If a hot pack is present, a determination is made as to the hot pack&apos;s validity at step <highlight><bold>50</bold></highlight>. A hot pack may be considered invalid if it has modifications that have already been completed, if it refers to a later version of the program then the one currently executing on the client computer or if the hot pack contains errors. If the hot pack is invalid, an error is generated and the system returns to step <highlight><bold>47</bold></highlight>. If the hot pack is valid, the hot swapper suspends the target application in step <highlight><bold>52</bold></highlight>. It is noted that the application is not halted since the application can be resumed from the existing location of the instruction counter and the instruction counter does not return to the initial setting. The hot swapper reads the address space of the program in step <highlight><bold>54</bold></highlight> in order to determine how much address space the new grains will need in order to be stored. The hot swapper then resizes the address space of the target application in step <highlight><bold>56</bold></highlight> in order to have enough space for the modifications according to the hot pack. It is possible that in determining the new address space, there may be space contained in the object code of the target that is not being used. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> Next, the new grains can be copied into the expanded address space at step <highlight><bold>57</bold></highlight>. Thus, the target application would contain the old and new grains within its address space. The second grain, if the first grain is immediately modifiable, can be copied into the address space of the first grain, if space is permitting. If space is not permitting, the second grain can be copied into another location apart from the first grain and a pointer placed in the location of the first grain to execute the second gain when the instruction counter reaches the location of the previous first grain. If a first grain cannot be immediately modified, the second grain is copied to a different part of the address space rather than simply overwriting the first grain and the crumb of the first grain is activated. The coping of the second grain can occur at any time after suspension of the target application and can be performed by the hot swapper or modification instructions. Once the second grains are located within the address space of the target application, the determination of which dictums are executable is made at step <highlight><bold>58</bold></highlight>. Those dictums that are immediately executable are executed at step <highlight><bold>60</bold></highlight> and first grains are modified into second grains. Afterwards, the process is left to resume execution so that the first grain can be modified in the incremental phase. It is understood that crumbs can be added to grains when the source code is compiled or translated, when the hot pack is initially executed, or when the hot swapper executes. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> The hot swapper then resumes the program in step <highlight><bold>68</bold></highlight> and returns to step <highlight><bold>47</bold></highlight> where the target application continues to execute. If all of the dictums in step <highlight><bold>58</bold></highlight> cannot be immediately executed, then step <highlight><bold>62</bold></highlight> determines if any dictum can be executed. If some dictums can be executed, then the first grain associated with that dictum is modified so that the second grain executes. After the immediate dictums are executed, the crumbs are activated for the grains that cannot be immediately modified in step <highlight><bold>66</bold></highlight> so that these grains may be modified in the incremental phase. If none of the dictums can be executed in step <highlight><bold>62</bold></highlight>, then all of the first version grains have their crumbs activated in step <highlight><bold>66</bold></highlight>. After step <highlight><bold>66</bold></highlight>, the now updated program is resumed in step <highlight><bold>68</bold></highlight>, and the program continues to run normally in step <highlight><bold>47</bold></highlight>. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> Alternatively, the hot swapper can check to see if all the dictums can be executed in step <highlight><bold>58</bold></highlight>. If so, the hot swapper copies all the second grains in the hot pack into the address space and modifies the first grains to the second grains. The hot swapper then resumes the program in step <highlight><bold>68</bold></highlight> and returns to step <highlight><bold>47</bold></highlight> where the target application continues to execute. If all of the dictums in step <highlight><bold>58</bold></highlight> cannot be immediately executed, the determination is made as to whether any dictums can be executed. If some of the dictums can be executed, then the first grains associated with that dictum is modified so that the first grain is modified to the second grain. After these dictums are executed, the crumbs are activated for the grains associated with dictums that cannot be immediately modified so that these grains may be modified in the incremental phase. If none of the dictums can be executed, then all first grains have their crumbs activated and the target application is resumed. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> In alternate embodiment, there may not be an instantaneous phase and every modification is handled through an incremental phase. In this embodiment, the first version grain crumbs can always be active and the dictums that can be executed are executed when any active grain is encountered. In the event that there are no dictums to execute the hot swapper would still determining this upon encountering the active grains. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> illustrates the steps taken when an active crumb is encountered when the target application is resumed as during the incremental phase. Crumbs are associated with at least one dictum. In step <highlight><bold>70</bold></highlight>, the target program is executing after being resumed from the instantaneous phase. In step <highlight><bold>72</bold></highlight>, the hot swapper determines if there is an active crumb. For example, if the instruction counter of the target application encounters an active crumb, then the modification instructions <highlight><bold>59</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 3</cross-reference>) are executed. If so, the hot swapper or the modification instructions attempts to update the corresponding grain when the modification instructions are included with the hot swapper. The update can be performed by the hot swapper instructions or computer readable instruction of the crumb itself. The modification instructions or hot swapper can either attempt to execute all dictums associated with all active crumbs or merely attempt to execute the dictums associated with the particular active crumb encountered. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> If modification is not possible at step <highlight><bold>73</bold></highlight>, than the target application continues execution and returns to step <highlight><bold>70</bold></highlight>. The modification may not be necessary if some condition of the dictum associated the first grain or active crumb is not satisfied, or for other conditions preventing modification such as recursion. If a dictum is executable when an active crumb is encountered, the target application is suspended at step <highlight><bold>74</bold></highlight>. It should be noted that certain conditions allow the active crumb&apos;s grain to be modified without having to suspend the target application. Additionally, the modification instructions executed by the active crumb&apos;s grain may also modify more than just that grain. The grains associated with the dictums executable are modified according to the associated dictum at step <highlight><bold>77</bold></highlight> and execution of the target application is then resumed at step <highlight><bold>78</bold></highlight>. If no active crumb is encountered, the program continues to run normally in step <highlight><bold>70</bold></highlight>. Once a grain is modified, the now deactivated crumb may be deleted from the address space of the target and the address space resized accordingly. A jump statement can be reinserted before the encountered crumb so that it is no longer an active crumb. Those skilled in the art will understand that there are various means and methods for activating and deactivating crumbs. The program then returns to a state of execution in step <highlight><bold>70</bold></highlight>. Once a grain is modified, the now deactivated crumb may be deleted from the address space of the target and the address space resized accordingly. A jump statement can be reinserted before the encountered crumbs to that it is no longer an active crumb. Those skilled in the art, will understand that there are various means and methods for activating and deactivating crumbs. The program then returns to a state of execution in step <highlight><bold>70</bold></highlight>. </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> While a preferred embodiment of the invention has been described using specific terms, such description is for illustrative purposes only, and it is to be understood that changes and variations may be made without departing from the spirit or scope of the following claims. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A computerized system embodied in a computer readable medium for modifying a target software application segmented into first version grains, comprising: 
<claim-text>a set of computer readable instructions embodied in said computer readable medium for: </claim-text>
<claim-text>receiving a hot pack having a dictum and a second version grain associated with at least one of said first version grains, </claim-text>
<claim-text>opening said hot pack, </claim-text>
<claim-text>suspending said target software application, </claim-text>
<claim-text>determining the status of said dictum, </claim-text>
<claim-text>modifying at least one of said first version grains of said target software application according to said second version grain and said dictum of said hot pack if said determination of said status of said dictum allows for its immediate modification, and, </claim-text>
<claim-text>resuming execution of said target application so that modification of said target software application is achieved without halting its execution. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein said computer readable instructions include instructions for triggering performance of a validity operation according to said dictum so that data and functional integrity is maintained within said target software application subsequent modification of said target software application. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein said computer readable instructions include instructions for: 
<claim-text>resizing the address space of said target software application according to said hot pack, and, </claim-text>
<claim-text>copying said second version grain within said address space of said target software application. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein said computer readable instructions include instructions for: 
<claim-text>resizing the address space of said target software application according to said hot pack; and, </claim-text>
<claim-text>copying said dictum into said address space of said target software application. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein: 
<claim-text>at least one crumb associated with at least one of said first version grains having an active and inactive state; and, </claim-text>
<claim-text>said computer readable instructions include instructions for activating said associated crumbs upon the determination that said status of said dictum associated with said first version grain does not allow for its immediate execution. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference> wherein said computer readable instructions include instructions for, when encountering said crumb in an active state: 
<claim-text>suspending said executing software application; </claim-text>
<claim-text>determining whether said dictum associated with said active crumb can be executed; </claim-text>
<claim-text>modifying said first version grain according to said second version grain and said dictum if said determination of whether said dictum can be executed is affirmative, and, </claim-text>
<claim-text>resuming execution of said target software application so that said target application is modified without halting its execution. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference> wherein said computer readable instructions include instruction for adding at least one crumb to at least one of said first version grains that are to be modified according to said hot pack. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. A computerized system embodied within a computer readable medium for modification of an executing target software application, having first version grains, comprising: 
<claim-text>a hot pack contained within said computer readable medium; </claim-text>
<claim-text>a second version grain contained within said hot pack; </claim-text>
<claim-text>a dictum associated with at least one of said first version grains contained within said hot pack for providing instructions for modification of at least one of said first version grains according to said dictum and said second version grain; </claim-text>
<claim-text>a set of computer readable instructions embodied within said computer readable medium for: 
<claim-text>suspending said target software application, </claim-text>
<claim-text>modifying at least one of said first version grains according to said second version grain and said dictum, and, </claim-text>
<claim-text>resuming execution of said target software application so that said target software application is modified without halting its execution. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference> wherein said computer readable instructions include instructions for triggering performance of a validity operation according to said dictum so that data and functional integrity is maintained within said target software application subsequent to modification of said target software application. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference> wherein said computer readable instructions include instructions for: 
<claim-text>resizing the address space of said target software application according to said hot pack; and, </claim-text>
<claim-text>copying said second version grain to within said resized address space of said target software application. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference> wherein said computer readable instructions Include instructions for: 
<claim-text>resizing the address space if said target software application according to said hot pack; and, </claim-text>
<claim-text>copying said dictum into said address space of said target application. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference> wherein: 
<claim-text>at least one crumb associated with at least one of said first version grains having an active and inactive state; and, </claim-text>
<claim-text>said computer readable instructions include instructions for activating said crumb upon the determination that said status of said dictum associated with said first grain to be modified does not allow for its immediate modification. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference> wherein said computer readable instructions include instructions for when encountering said crumb in said active state: 
<claim-text>suspending said executing software application; </claim-text>
<claim-text>determining whether said dictum in turn associated with said first grain associated with said active crumb can be modified; </claim-text>
<claim-text>modifying said first version grain according to said second version grain and said dictum if said determination of whether said first version grain can be modified is affirmative; and, </claim-text>
<claim-text>resuming execution of said target software application so that said target application can be modified without halting its execution. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. A computerized system embodied within a computer readable medium for modification of an executing target software application having first version grains comprising: 
<claim-text>a hot pack contained within said computer readable medium; </claim-text>
<claim-text>a second version grain contained within said hot pack; </claim-text>
<claim-text>a dictum associated with at least one of said first version grains contained within said hot pack for providing instructions for modification of at least one of said first version grains according to said dictum; </claim-text>
<claim-text>a means for suspending said target software application; </claim-text>
<claim-text>a means for modifying at least one of said first version grains according to said second version grain and said dictum; and, </claim-text>
<claim-text>a means for resuming execution of said target software application so that said target software application is modified without halting its execution. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference> including a means for preforming a validity operation according to said dictum so that data and functional integrity is maintained within said target software application subsequent modification of said target software application. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference> including: 
<claim-text>a means for resizing said target application&apos;s address space according to said hot pack; and, </claim-text>
<claim-text>a means for copying said second version grain to within said resized address space of said target software application. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference> including a means for copying said dictum into said address space of said target application. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference> including: 
<claim-text>at least one crumb associated with at least one of said first version grains having an active and inactive state; </claim-text>
<claim-text>a means for determining whether said dictum associated with at least one of said first version grains can be activated; </claim-text>
<claim-text>a means for activating said crumb upon the determination that said status of said dictumdoes not allow for its immediate modification. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 18</dependent-claim-reference> including: 
<claim-text>a means for determining whether active crumb is encountered; </claim-text>
<claim-text>a means for suspending said executing software application upon encountering said active crumb; </claim-text>
<claim-text>a means for determining whether said dictum associated with said active crumb can be modified according to said dictum; </claim-text>
<claim-text>a means for modifying said first version grain according to said second version grain and said dictum if said determination of whether said dictum can be executed is affirmative; and, </claim-text>
<claim-text>a means for resuming execution of said target software application so that said target application can be modified without halting its execution. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. A method for modifying a target software application segmented into first version grains with each of the first version grains having associated crumbs with the associated crumbs having an active and inactive state, comprising the steps of: 
<claim-text>providing a hot pack having a dictum and a second version grain, </claim-text>
<claim-text>suspending said target software application, </claim-text>
<claim-text>determining the status of said dictum; </claim-text>
<claim-text>modifying at least one of said first version grains of said target software application according to said second version grain and said dictum of said hot pack if said determination of said status of said dictum allows for its immediate modification, and, </claim-text>
<claim-text>resuming execution of said target application so that modification of said target software application is achieved without halting its execution. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00022">claim 20</dependent-claim-reference> including the steps of performing a validity operation associated with said dictum so that data and functional integrity is maintained within said target software application subsequent modification of said target software application. </claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00022">claim 20</dependent-claim-reference> including the steps of: 
<claim-text>resizing the address space of said target software application according to said hot pack; and, </claim-text>
<claim-text>copying said second version grain within said address space of said target software application. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00022">claim 20</dependent-claim-reference> including the steps of: 
<claim-text>Resizing the address space of said target software application according to said hot pack; and, </claim-text>
<claim-text>copying said dictum into said address space of said target software application. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00022">claim 20</dependent-claim-reference> including the steps of: 
<claim-text>providing at least one crumb associated with at lest one of said first version grains having an active and inactive state; and, </claim-text>
<claim-text>activating said crumb upon the determination that said dictum associated with at least one of said first version grains does not allow for its immediate execution. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00022">claim 24</dependent-claim-reference> including upon resumption of execution: 
<claim-text>suspending said executing software application; </claim-text>
<claim-text>determining whether said dictum associated with said first version grain can be modified upon encountering said active grain; </claim-text>
<claim-text>modifying said first version grain according to said second version grain and said dictum if said determination of whether said dictum can be executed is affirmative; and, </claim-text>
<claim-text>resuming execution of said target software application so that said target application can be modified without halting its execution. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. A computerized system embodied in a computer readable medium for modifying a target software application segmented into first version grains having associated crumbs, comprising: 
<claim-text>a set of computer readable instructions embodied in said computer readable medium for: 
<claim-text>receiving a hot pack having a plurality of dictums and plurality of second version grains encountered with said first version grains, </claim-text>
<claim-text>opening said hot pack, </claim-text>
<claim-text>suspending said target software application, </claim-text>
<claim-text>determining the status of said plurality of dictums to discover whether any of said dictums can be immediately executed, </claim-text>
<claim-text>modifying said first version grain associated with said dictum that can be immediately executed, and, </claim-text>
<claim-text>resuming execution of said target application so that modification of said target software application is achieved without halting its execution. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00022">claim 26</dependent-claim-reference> wherein said computer readable instructions include instructions for triggering performance of a validity operation according to said dictums so that data and functional integrity is maintained within said target software application subsequent modification of said target software application. </claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00022">claim 26</dependent-claim-reference> wherein said computer readable instructions include instructions for: 
<claim-text>resizing the address space of said target software application according to said hot pack, and, </claim-text>
<claim-text>copying said second version grains within said address space of said target software application. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00029">
<claim-text><highlight><bold>29</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00022">claim 26</dependent-claim-reference> wherein said computer readable instructions include instructions for: 
<claim-text>resizing the address space of said target software application according to said hot pack; and, </claim-text>
<claim-text>copying said plurality of dictums into said address space of said target software application. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00030">
<claim-text><highlight><bold>30</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00022">claim 26</dependent-claim-reference> including: 
<claim-text>at least one grain associated with at least one of said first version grains having an active and inactive state; and, </claim-text>
<claim-text>said computer readable instructions include instructions for activating said crumb upon the determination that said status of said dictum associated with at least one of said first version grains does not allow for its immediate modification. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00031">
<claim-text><highlight><bold>31</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00033">claim 30</dependent-claim-reference> wherein said computer readable instructions include instructions for when encountering said crumb in an active state: 
<claim-text>suspending said executing software application; </claim-text>
<claim-text>determining whether any of said plurality of dictums previously unexecuted can be executed, </claim-text>
<claim-text>modifying said first version grains according to said second version grains and said associated dictum if said determination of whether said dictum can be executed is affirmative, and, </claim-text>
<claim-text>resuming execution of said target software application so that said target application can be modified without halting its execution. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00032">
<claim-text><highlight><bold>32</bold></highlight>. A computerized system embodied in a computer readable medium for modifying a target software application segmented into first version grains, comprising: 
<claim-text>a set of computer readable instructions embodied in said computer readable medium for: 
<claim-text>receiving a hot pack having a dictum and a second version grain associated with at least one of said first version grains, </claim-text>
<claim-text>suspending said target software application, </claim-text>
<claim-text>modifying at least one of said first version grains of said target software application according to said second version grain and said dictum of said hot pack, and, </claim-text>
<claim-text>resuming execution of said target application so that modification of said target software application is achieved without halting its execution. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00033">
<claim-text><highlight><bold>33</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00033">claim 32</dependent-claim-reference> wherein said computer readable instructions include instructions for triggering performance of a validity operation according to said dictum so that data and functional integrity is maintained within said target software application subsequent modification of said target software application. </claim-text>
</claim>
<claim id="CLM-00034">
<claim-text><highlight><bold>34</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00033">claim 32</dependent-claim-reference> wherein said computer readable instructions include instructions for copying said second version grain into said computer readable medium. </claim-text>
</claim>
<claim id="CLM-00035">
<claim-text><highlight><bold>35</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00033">claim 32</dependent-claim-reference> wherein said computer readable instructions include instructions for copying said dictum into said computer readable medium. </claim-text>
</claim>
<claim id="CLM-00036">
<claim-text><highlight><bold>36</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00033">claim 32</dependent-claim-reference> including: 
<claim-text>at least one crumb associated with at least one of said first version grains having an active and inactive state; and, </claim-text>
<claim-text>said computer readable instructions include instructions for activating said associated crumbs upon the determination that said dictum associated with said first version grain does not allow for its execution at a predetermined time. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00037">
<claim-text><highlight><bold>37</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00033">claim 36</dependent-claim-reference> wherein said computer readable instructions include instructions for, when encountering said crumb in an active state: 
<claim-text>suspending said executing software application; </claim-text>
<claim-text>determining whether said dictum associated with said active crumb can be executed; </claim-text>
<claim-text>modifying said first version grain according to said second version grain and said dictum if said determination of whether said dictum can be executed is affirmative, and, </claim-text>
<claim-text>resuming execution of said target software application so that said target application is modified without halting its execution. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00038">
<claim-text><highlight><bold>38</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00033">claim 37</dependent-claim-reference> wherein said computer readable instructions include instruction for adding at least one crumb to at least one of said first version grains that are to be modified according to said hot pack.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>4</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005409A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005409A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005409A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005409A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005409A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005409A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
