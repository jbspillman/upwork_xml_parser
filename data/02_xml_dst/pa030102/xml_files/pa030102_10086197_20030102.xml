<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005260A1-20030102-D00000.TIF SYSTEM "US20030005260A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005260A1-20030102-D00001.TIF SYSTEM "US20030005260A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005260A1-20030102-D00002.TIF SYSTEM "US20030005260A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005260A1-20030102-D00003.TIF SYSTEM "US20030005260A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005260A1-20030102-D00004.TIF SYSTEM "US20030005260A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005260A1-20030102-D00005.TIF SYSTEM "US20030005260A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030005260A1-20030102-D00006.TIF SYSTEM "US20030005260A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030005260A1-20030102-D00007.TIF SYSTEM "US20030005260A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030005260A1-20030102-D00008.TIF SYSTEM "US20030005260A1-20030102-D00008.TIF" NDATA TIF>
<!ENTITY US20030005260A1-20030102-D00009.TIF SYSTEM "US20030005260A1-20030102-D00009.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005260</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10086197</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20020301</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F015/00</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>712</class>
<subclass>023000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Superscalar RISC instruction scheduling</title-of-invention>
</technical-information>
<continuity-data>
<continuations>
<continuation-of>
<parent-child>
<child>
<document-id>
<doc-number>10086197</doc-number>
<kind-code>A1</kind-code>
<document-date>20020301</document-date>
</document-id>
</child>
<parent>
<document-id>
<doc-number>09906099</doc-number>
<document-date>20010717</document-date>
<country-code>US</country-code>
</document-id>
</parent>
<parent-status>ABANDONED</parent-status>
</parent-child>
</continuation-of>
</continuations>
<continuations>
<continuation-of>
<parent-child>
<child>
<document-id>
<doc-number>09906099</doc-number>
<document-date>20010717</document-date>
<country-code>US</country-code>
</document-id>
</child>
<parent>
<document-id>
<doc-number>09329354</doc-number>
<document-date>19990610</document-date>
<country-code>US</country-code>
</document-id>
</parent>
<parent-status>GRANTED</parent-status>
<parent-patent>
<document-id>
<doc-number>6289433</doc-number>
<country-code>US</country-code>
</document-id>
</parent-patent>
</parent-child>
</continuation-of>
</continuations>
<continuations>
<continuation-of>
<parent-child>
<child>
<document-id>
<doc-number>09329354</doc-number>
<document-date>19990610</document-date>
<country-code>US</country-code>
</document-id>
</child>
<parent>
<document-id>
<doc-number>08990414</doc-number>
<document-date>19971215</document-date>
<country-code>US</country-code>
</document-id>
</parent>
<parent-status>GRANTED</parent-status>
<parent-patent>
<document-id>
<doc-number>5974526</doc-number>
<country-code>US</country-code>
</document-id>
</parent-patent>
</parent-child>
</continuation-of>
</continuations>
<continuations>
<continuation-of>
<parent-child>
<child>
<document-id>
<doc-number>08990414</doc-number>
<document-date>19971215</document-date>
<country-code>US</country-code>
</document-id>
</child>
<parent>
<document-id>
<doc-number>08594401</doc-number>
<document-date>19960131</document-date>
<country-code>US</country-code>
</document-id>
</parent>
<parent-status>GRANTED</parent-status>
<parent-patent>
<document-id>
<doc-number>5737624</doc-number>
<country-code>US</country-code>
</document-id>
</parent-patent>
</parent-child>
</continuation-of>
</continuations>
<continuations>
<continuation-of>
<parent-child>
<child>
<document-id>
<doc-number>08594401</doc-number>
<document-date>19960131</document-date>
<country-code>US</country-code>
</document-id>
</child>
<parent>
<document-id>
<doc-number>08219425</doc-number>
<document-date>19940329</document-date>
<country-code>US</country-code>
</document-id>
</parent>
<parent-status>GRANTED</parent-status>
<parent-patent>
<document-id>
<doc-number>5497499</doc-number>
<country-code>US</country-code>
</document-id>
</parent-patent>
</parent-child>
</continuation-of>
</continuations>
<continuations>
<continuation-of>
<parent-child>
<child>
<document-id>
<doc-number>08219425</doc-number>
<document-date>19940329</document-date>
<country-code>US</country-code>
</document-id>
</child>
<parent>
<document-id>
<doc-number>07860719</doc-number>
<document-date>19920331</document-date>
<country-code>US</country-code>
</document-id>
</parent>
<parent-status>ABANDONED</parent-status>
</parent-child>
</continuation-of>
</continuations>
</continuity-data>
<inventors>
<first-named-inventor>
<name>
<given-name>Sanjiv</given-name>
<family-name>Garg</family-name>
</name>
<residence>
<residence-us>
<city>Freemont</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Kevin</given-name>
<middle-name>Ray</middle-name>
<family-name>Iadonato</family-name>
</name>
<residence>
<residence-us>
<city>San Jose</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Le</given-name>
<middle-name>Trong</middle-name>
<family-name>Nguyen</family-name>
</name>
<residence>
<residence-us>
<city>Monte Sereno</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Johannes</given-name>
<family-name>Wang</family-name>
</name>
<residence>
<residence-us>
<city>Redwood City</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>STERNE, KESSLER, GOLDSTEIN &amp; FOX PLLC</name-1>
<name-2></name-2>
<address>
<address-1>1100 NEW YORK AVENUE, N.W., SUITE 600</address-1>
<city>WASHINGTON</city>
<state>DC</state>
<postalcode>20005-3934</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A register renaming system for out-of-order execution of a set of reduced instruction set computer instructions having addressable source and destination register fields, adapted for use in a computer having an instruction execution unit with a register file accessed by read address ports and for storing instruction operands. A data dependance check circuit is included for determining data dependencies between the instructions. A tag assignment circuit generates one or more tags to specify the location of operands, based on the data dependencies determined by the data dependance check circuit. A set of register file port multiplexers select the tags generated by the tag assignment circuit and pass the tags onto the read address ports of the register file for storing execution results. </paragraph>
</subdoc-abstract>
<subdoc-description>
<cross-reference-to-related-applications>
<heading lvl="1">CROSS-REFERENCE TO RELATED APPLICATIONS </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> This application is a continuation of application Ser. No. 09/906,099, filed Jul. 17, 2001, still pending, which is a continuation of application Ser. No. 09/329,354, filed Jun. 10, 1999, now U.S. Pat. No. 6,289,433, which is a continuation of application Ser. No. 08/990,414, filed Dec. 15, 1997, now U.S. Pat. No. 5,974,526, which is a continuation of application Ser. No. 08/594,401, filed Jan. 31, 1996, now U.S. Pat. No. 5,737,624, which is a continuation of application Ser. No. 08/219,425, filed Mar. 29, 1994, now U.S. Pat. No. 5,497,499, which is a continuation of application Ser. No. 07/860,719, filed Mar. 31, 1992, now abandoned. The disclosures of each of the above-referenced applications are incorporated herein by reference. </paragraph>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> The following are related applications: &ldquo;Semiconductor Floor Plan and Method for a Register Renaming Circuit,&rdquo; Ser. No. 07/860,718, filed Mar. 31, 1992, now U.S. Pat. No. 5,371,684; &ldquo;High-Performance, Superscalar-Based Computer System with Out-Of-Order Instruction Execution,&rdquo; Ser. No. 07/817,810, filed Jan. 8, 1992, now U.S. Pat. No. 5,539,911; and &ldquo;High-Performance, Superscalar-Based Computer System with Out-Of-Order Instruction Execution and Concurrent Results Distribution,&rdquo; Ser. No. 08/397,016, filed Mar. 1, 1995, now U.S. Pat. No. 5,560,032. The disclosures of the above applications are incorporated herein by reference. </paragraph>
</cross-reference-to-related-applications>
<summary-of-invention>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> 1. Field of the Invention </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> The present invention relates to superscalar reduced instruction set computers (RISC). More particularly, the present invention relates to instruction scheduling including register renaming and instruction issuing for superscalar RISC computers. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> 2. Related Art </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> A more detailed description of some ofthe basic concepts discussed in this application is found in a number of references, including Mike Johnson, <highlight><italic>Superscalar Microprocessor Design </italic></highlight>(Prentice-Hall, Inc., Englewood Cliffs, N.J., 1991); John L. Hennessy et al., <highlight><italic>Computer Architecture&mdash;A Quantitative Approach </italic></highlight>(Morgan Kaufmann Publishers, Inc., San Mateo, Calif., 1990). Johnson&apos;s text, particularly Chapters 2, 6 and 7 provide an excellent discussion of the register renaming issues addressed by the present invention. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> A major consideration in a superscalar RISC processor is to how to execute multiple instructions in parallel and out-of-order, without incurring data errors due to dependencies inherent in such execution. Data dependency checking, register renaming and instruction scheduling are integral aspects of the solution. </paragraph>
<paragraph id="P-0008" lvl="7"><number>&lsqb;0008&rsqb;</number> Storage Conflicts and Register Renaming </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> True dependencies (sometimes called &ldquo;flow dependencies&rdquo; or &ldquo;write-read&rdquo; dependencies) are often grouped with anti-dependencies (also called &ldquo;read-write&rdquo; dependencies) and output dependencies (also called &ldquo;write-write&rdquo; dependencies) into a single group of instruction dependencies. The reason for this grouping is that each of these dependencies manifests itself through use of registers or other storage locations. However, it is important to distinguish true dependencies from the other two. True dependencies represent the flow of data and information through a program. Anti- and output dependencies arise because, at different points in time, registers or other storage locations hold different values for different computations. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> When instructions are issued in order and complete in order, there is a one-to-one correspondence between registers and values. At any given point in execution, a register identifier precisely identifies the value contained in the corresponding register. When instructions are issued out of order and complete out of order, correspondence between registers and values breaks down, and values conflict for registers. This problem is severe when the goal of register allocation is to keep as many values in as few registers as possible. Keeping a large number of values in a small number of registers creates a large number of conflicts when the execution order is changed from the order assumed by the register allocator. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> Anti- and output dependencies are more properly called &ldquo;storage conflicts&rdquo; because reusing storage locations (including registers) causes instructions to interfere with one another even though conflicting instructions are otherwise independent. Storage conflicts constrain instruction issue and reduce performance. But storage conflicts, like other resource conflicts, can be reduced or eliminated by duplicating the troublesome resource. </paragraph>
<paragraph id="P-0012" lvl="7"><number>&lsqb;0012&rsqb;</number> Dependency Mechanisms </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> Johnson also discusses in detail various dependency mechanisms, including: software, register renaming, register renaming with a reorder buffer, register renaming with a future buffer, interlocks, the copying of operands in the instruction window to avoid dependencies, and partial renaming. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> A conventional hardware implementation relies on software to enforce dependencies between instructions. A compiler or other code generator can arrange the order of instructions so that the hardware cannot possibly see an instruction until it is free of true dependencies and storage conflicts. Unfortunately, this approach runs into several problems. Software does not always know the latency of processor operations, and thus, cannot always know how to arrange instructions to avoid dependencies. There is the question of how the software prevents the hardware from seeing an instruction until it is free of dependencies. In a scalar processor with low operation latencies, software can insert &ldquo;no-ops&rdquo; in the code to satisfy data dependencies without too much overhead. If the processor is attempting to fetch several instructions per cycle, or if some operations take several cycles to complete, the number of no-ops required to prevent the processor from seeing dependent instructions rapidly becomes excessive, causing an unacceptable increase in code size. The no-ops use a precious resource, the instruction cache, to encode dependencies between instructions. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> When a processor permits out-of-order issue, it is not at all clear what mechanism software should use to enforce dependencies. Software has little control over the behavior of the processor, so it is hard to see how software prevents the processor from decoding dependent instructions The second consideration is that no existing binary code for any scalar processor enforces the dependencies in a superscalar processor, because the mode of execution is very different in the superscalar processor. Relying on software to enforce dependencies requires that the code be regenerated for the superscalar processor. Finally, the dependencies in the code are directly determined by the latencies in the hardware, so that the best code for each version of a superscalar processor depends on the implementation of that version. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> On the other hand, there is some motivation against hardware dependency techniques, because they are inherently complex. Assuming instructions with two input operands and one output value, as holds for typical RISC instructions, then there are five possible dependencies between any two instructions: two true dependencies, two anti-dependencies, and one output dependency. Furthermore, the number of dependencies between a group of instructions, such as a group of instructions in a window, varies with the square of the number of instructions in the group, because each instruction must be considered against every other instruction. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> Complexity is further multiplied by the number of instructions that the processor attempts to decode, issue, and complete in a single cycle. These actions introduce dependencies. The only aid in reducing complexity is that the dependencies can be determined incrementally, over many cycles to help reduce the scope and complexity of the dependency hardware. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> One technique for removing storage conflicts is by providing additional registers that are used to reestablish the correspondence between registers and values. The additional registers are conventionally allocated dynamically by hardware, and the registers are associated with values needed by the program using &ldquo;register renaming.&rdquo; To implement register renaming, processors typically allocate a new register for every new value produced (i.e., for every instruction that writes a register). An instruction identifying the original register, for the purpose of reading its value, obtains instead the value in the newly allocated register. Thus, hardware renames the original register identifier in the instruction to identify the new register and correct value. The same register identifier in several different instructions may access different hardware registers, depending on the locations of register references with respect to register assignments. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> Consider the following code sequence where &ldquo;op&rdquo; is an operation, &ldquo;Rn&rdquo; represents a numbered register, and &ldquo;:&equals;&rdquo; represents assignment: </paragraph>
<paragraph id="P-0020" lvl="2"><number>&lsqb;0020&rsqb;</number> R<highlight><bold>3</bold></highlight>b:&equals;R<highlight><bold>3</bold></highlight>a op R<highlight><bold>5</bold></highlight>a (<highlight><bold>1</bold></highlight>) </paragraph>
<paragraph id="P-0021" lvl="2"><number>&lsqb;0021&rsqb;</number> R<highlight><bold>4</bold></highlight>b:&equals;R<highlight><bold>3</bold></highlight>b&plus;<highlight><bold>1</bold></highlight> (<highlight><bold>2</bold></highlight>) </paragraph>
<paragraph id="P-0022" lvl="2"><number>&lsqb;0022&rsqb;</number> R<highlight><bold>3</bold></highlight>c:&equals;R<highlight><bold>5</bold></highlight>a&plus;<highlight><bold>1</bold></highlight> (<highlight><bold>3</bold></highlight>) </paragraph>
<paragraph id="P-0023" lvl="2"><number>&lsqb;0023&rsqb;</number> R<highlight><bold>7</bold></highlight>b:&equals;R<highlight><bold>3</bold></highlight>c op R<highlight><bold>4</bold></highlight>b (<highlight><bold>4</bold></highlight>) </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> Each assignment to a register creates a new &ldquo;instance&rdquo; of the register, denoted by an alphabetic subscript. The creation of a new instance for R<highlight><bold>3</bold></highlight> in the third instruction avoids the anti- and output dependencies on the second and first instructions, respectively, and yet does not interfere with correctly supplying an operand to the fourth instruction. The assignment to R3 in the third instruction supersedes the assignment to R<highlight><bold>3</bold></highlight> in the first instruction, causing R<highlight><bold>3</bold></highlight>c to become the new R<highlight><bold>3</bold></highlight> seen by subsequent instructions until another instruction assigns a value to R<highlight><bold>3</bold></highlight>. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> Hardware that performs renaming creates each new register instance and destroys the instance when its value is superseded and there are no outstanding references to the value. This removes anti- and output dependencies and allows more instruction parallelism. Registers are still reused, but reuse is in line with the requirements of parallel execution. This is particularly helpful with out-of-order issue, because storage conflicts introduce instruction issue constraints that are not really necessary to produce correct results. For example, in the preceding instruction sequence, renaming allows the third instruction to be issued immediately, whereas, without renaming, the instruction must be delayed until the first instruction is complete and the second instruction is issued. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> Another technique for reducing dependencies is to associate a single bit (called a &ldquo;scoreboard bit&rdquo;) with each register. The scoreboard bit is used to indicate that a register has a pending update. When an instruction is decoded that will write a register, the processor sets the associated scoreboard bit. The scoreboard bit is reset when the write actually occurs. Because there is only one scoreboard bit indicating whether or not there is a pending update, there can be only one such update for each register. The scoreboard stalls instruction decoding if a decoded instruction will update a register that already has a pending update (indicated by the scoreboard bit being set). This avoids output dependencies by allowing only one pending update to a register at any given time. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> Register renaming, in contrast, uses multiple-bit tags to identify the various uncomputed values, some of which values may be destined for the same processor register (that is, the same program-visible register). Conventional renaming requires hardware to allocate tags from a pool of available tags that are not currently associated with any value and requires hardware to free the tags to the pool once the values have been computed. Furthermore, since scoreboarding allows only one pending update to a given register, the processor is not concerned about which update is the most recent. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> A further technique for reducing dependencies is using register renaming with a &ldquo;reorder buffer&rdquo; which uses associative lookup. The associative lookup maps the register identifier to the reorder buffer entry as soon as the entry is allocated, and, to avoid output dependencies, the lookup is prioritized so that only the value for the most recent assignment is obtained if the register is assigned more than once. A tag is obtained if the result is not yet available. There can be as many instances of a given register as there are reorder buffer entries, so there are no storage conflicts between instructions. The values for the different instances are written from the reorder buffer to the register file in sequential order. When the value for the final instance is written to the register file, the reorder buffer no longer maps the register; the register file contains the only instance of the register, and this is the most recent instance. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> However, renaming with a reorder buffer relies on the associative lookup in the reorder buffer to map register identifiers to values. In the reorder buffer, the associative lookup is prioritized so that the reorder buffer always provides the most recent value in the register of interest (or a tag). The reorder buffer also writes values to the register file in order, so that, if the value is not in the reorder buffer, the register file must contain the most recent value </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> In a still further technique for reducing dependencies, associative lookup can be eliminated using a &ldquo;future file.&rdquo; The future file does not have the properties of the reorder buffer discussed in the preceding paragraph. A value presented to the future file to be written may not be the most recent value destined for the corresponding register, and the value cannot be treated as the most recent value unless it actually is. The future file therefore keeps track of the most recent update and checks that each write corresponds to the most recent update before it actually performs the write. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> When an instruction is decoded, it accesses tags in the future file along with the operand values. If the register has one or more pending updates, the tag identifies the update value required by the decoded instruction. Once an instruction is decoded, other instructions may overwrite this instruction&apos;s source operands without being constrained by anti-dependencies, because the operands are copied into the instruction window. Output dependencies are handled by preventing the writing as a result into the future file if the result does not have a tag for the most recent value. Both anti- and output dependencies are handled without stalling instruction issue. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> If dependencies are not removed through renaming, &ldquo;interlocks&rdquo; must be used to enforce dependencies. An interlock simply delays the execution of an instruction until the instruction is free of dependencies. There are two ways to prevent an instruction from being executed: one way is to prevent the instruction from being decoded, and the other is to prevent the instruction from being issued. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> To improve performance over scoreboarding, interlocks are moved from the decoder to the instruction window using a &ldquo;dispatch stack.&rdquo; The dispatch stack is an instruction window that augments each instruction in the window with dependency counts. There is a dependency count associated with the source register of each instruction in the window, giving the number of pending prior updates to the source register and thus the number of updates that must be completed before all possible true dependencies are removed. There are two similar dependency counts associated with the destination register of each instruction in the window, giving both the number of pending prior uses of the register (which is the number of anti-dependencies) and the number of pending prior updates to the register (which is the number of output dependencies). </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> When an instruction is decoded and loaded into the dispatch stack, the dependency counts are set by comparing the instruction&apos;s register identifiers with the register identifiers of all instructions already in the dispatch stack. As instructions complete, the dependency counts of instructions that are still in the window are decremented based on the source and destination register identifiers of completing instructions (the counts are decremented by a variable amount, depending on the number of instructions completed). An instruction is independent when all of its counts are zero. The use of counts avoids having to compare all instructions in the dispatch stack to all other instructions on every cycle. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> Anti-dependencies can be avoided altogether by copying operands to the instruction window (for example, to the reservation stations) during instruction decode. In this manner, the operands cannot be overwritten by subsequent register updates. Operands can be copied to eliminate anti-dependencies in any approach, independent of register renaming. The alternative to copying operands is to interlock anti-dependencies, but the comparators and/or counters required for these interlocks are costly, considering the number of combinations of source and result registers to be compared. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> A tag can be supplied for the operand rather than the operand itself. This tag is simply a means for the hardware to identify which value the instruction requires, so that, when the operand value is produced, it can be matched to the instruction. If there can be only one pending update to a register, the register identifier can serve as a tag (as with scoreboarding). If there can be more than one pending update to a register (as with renaming), there must be a mechanism for allocating result tags and insuring uniqueness. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> An alternative to scoreboarding interlocking is to allow multiple pending updates of registers to avoid stalling the decoder for output dependencies, but to handle anti-dependencies by copying operands (or tags) during decode. An instruction in the window is not issued until it is free of output dependencies, so the updates to each register are performed in the same order in which they would be performed with in-order completion, except that updates for different registers are out of order with respect to each other. The alternative has almost all of the capabilities of register renaming, lacking only the capability to issue instructions so that updates to the same register occur out of order. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> There appears to be no better alternative to renaming other than with a reorder buffer. Underlying the discussion of dependencies has been the assumption that the processor performs out-of-order issue and already has a reorder buffer for recovering from mispredicted branches. Out-of-order issue makes it unacceptable to stall the decoder for dependencies. If the processor has an instruction window, it is inconsistent to limit the look ahead capability of the processor by interlocking the decoder. There are then only two alternatives: implement anti- and output dependency interlocks in the window or remove these altogether with renaming. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> The present invention is directed to instruction scheduling including register renaming and instruction issuing for superscalar RISC computers. A Register Rename Circuit (RRC), which is part of the scheduling logic allows a computer&apos;s Instruction Execution Unit (IEU) to execute several instructions at the same time while avoiding dependencies. In contrast to conventional register renaming, the present invention does not actually rename register addresses. The RRC of the present invention temporarily buffers the instruction results, and the results of out-of-order instruction execution are not transferred to the register file until all previous instructions are done. The RRC also performs result forwarding to provide temporarily buffered operands (results) to dependant instructions. The RRC contains three subsections: a Data Dependency Checker (DDC), Tag Assign Logic (TAL) and Register file Port MUXes (RPM). </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> The function of the DDC is to locate the dependencies between the instructions for a group of instructions. The DDC does this by comparing the addresses of the source registers of each instruction to the addresses of the destination registers of each previous instruction in the group. For example, if instruction A reads a value from a register that is written to by instruction B, then instruction A is dependent upon instruction B and instruction A cannot start until instruction B has finished. The DDC outputs indicate these dependencies. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> The outputs of the DDC go to the TAL. Because it is possible for an instruction to be dependent on more than one previous instruction, the TAL must determine which of those previous instructions will be the last one to be executed. The present invention automatically maps each instruction to a predetermined temporary buffer location; hence, the present invention does not need prioritized associative look-up as used by conventional reorder buffers, thereby saving chip area/cost and execution speed. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> Out-of-order results for several instructions being executed at the same time are stored in a set of temporary buffers, rather than the file register designated by the instruction. If the DDC determines, for example, that a register that instruction <highlight><bold>6</bold></highlight>&apos;s source is written to by instructions <highlight><bold>2</bold></highlight>, <highlight><bold>3</bold></highlight> and <highlight><bold>5</bold></highlight>, then the TAL will indicate that instruction <highlight><bold>6</bold></highlight> must wait for instruction <highlight><bold>5</bold></highlight> by outputting the &ldquo;tag&rdquo; of instruction <highlight><bold>5</bold></highlight> for instruction <highlight><bold>6</bold></highlight>. The tag of instruction <highlight><bold>5</bold></highlight> shows the temporary buffer location where instruction <highlight><bold>5</bold></highlight>&apos;s result is stored. It also contains a one bit signal (called a &ldquo;done flag&rdquo;) that indicates if instruction <highlight><bold>5</bold></highlight> is finished or not. The TAL will output three tags for each instruction, because each instruction can have three source registers. If an instruction is not dependent on any previous instruction, the TAL will output the register file address ofthe instruction&apos;s input, rather than a temporary buffer&apos;s address. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> The last part of the RRC are the RPMs or Register file Port MuXes. The inputs of the RPMs are the outputs of the TAL, and the select lines for the RPMs come from another part of the IEU called the Instruction Scheduler or Issuer. The Instruction Scheduler chooses which instruction to execute (this decision is based partly on the done flags) and then uses the RPMs to select the tags of that instruction. These tags go to the read address ports of the computer&apos;s register files. In the previous example, once instruction <highlight><bold>5</bold></highlight> has finished, the Instruction Scheduler will start instruction <highlight><bold>6</bold></highlight>. It will select the RPM so that the address of instruction <highlight><bold>5</bold></highlight>&apos;s result (its tag) is sent to the register file, and the register file will make the result of instruction <highlight><bold>5</bold></highlight> available to instruction <highlight><bold>6</bold></highlight>. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> The foregoing and other features and advantages of the present invention will be apparent from the following more particular description of the preferred embodiments of the invention, as illustrated in the accompanying drawings.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE FIGURES </heading>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> The invention will be better understood if reference is made to the accompanying drawings. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> shows a representative high level block diagram of the register renaming circuit of the present invention. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> shows a representative block diagram ofthe data dependency check circuit of the present invention. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> shows a representative block diagram of the tag assignment logic of the present invention. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> shows a representative block diagram of the register port file multiplexers of the present invention. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a representative flowchart showing a data dependency check method for IXS<highlight><bold>1</bold></highlight> and IYS/D in accordance with the present invention. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 6A and 6B</cross-reference> are representative flowcharts showing a tag assignment method in accordance with the present invention. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> shows a representative block diagram which compares an instruction Y&apos;s source/destination operand with each operand of an instruction X in accordance with an embodiment of the present invention. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> shows a representative circuit diagram for comparator block <highlight><bold>706</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 7</cross-reference>. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference> shows a representative block diagram of a Priority Encoder in accordance with an embodiment of the present invention. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10</cross-reference> shows a representative block diagram ofthe instruction scheduling logic of the present invention.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF THE INVENTION </heading>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> shows a representative high level block diagram of an Instruction Execution Unit (IEU) <highlight><bold>100</bold></highlight> associated with the present invention. The goal of IEU <highlight><bold>100</bold></highlight> is to execute as many instructions as possible in the shortest amount of time. There are two basic ways to accomplish this: optimize IEU <highlight><bold>100</bold></highlight> so that each instruction takes as little time as possible or optimize IEU <highlight><bold>100</bold></highlight> so that it can execute several instructions at the same time. </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> Instructions are sent to IEU <highlight><bold>100</bold></highlight> from an Instruction Fetch Unit (IFU, not shown) through an instruction FIFO (first-in-first-out register stack storage device) <highlight><bold>101</bold></highlight> in groups of four called &ldquo;buckets.&rdquo; IEU <highlight><bold>100</bold></highlight> can decode and schedule up to two buckets of instructions at one time. FIFO <highlight><bold>101</bold></highlight> stores 16 total instructions in four buckets labeled <highlight><bold>0</bold></highlight>-<highlight><bold>3</bold></highlight>. IEU <highlight><bold>100</bold></highlight> looks at an instruction window <highlight><bold>102</bold></highlight>. In one embodiment of the present invention, window <highlight><bold>102</bold></highlight> comprises eight instructions (buckets <highlight><bold>0</bold></highlight> and <highlight><bold>1</bold></highlight>). Every cycle IEU <highlight><bold>100</bold></highlight> tries to issue a maximum number of instructions from window <highlight><bold>102</bold></highlight>. Window <highlight><bold>102</bold></highlight> functions as an instruction buffer register. Once the instructions in a bucket are executed and their results stored in the processor&apos;s register file (see block <highlight><bold>117</bold></highlight>), the bucket is flushed out a bottom <highlight><bold>104</bold></highlight> and a new bucket is dropped in at a top <highlight><bold>106</bold></highlight>. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> In order to execute instructions in parallel or out of order, care must be taken so that the data that each instruction needs is available when the instruction needs it and also so that the result of each instruction is available for any future instructions that might need it. A Register Rename Circuit (RRC), which is part of the scheduling logic of the computer&apos;s IEU performs this function by locating dependencies between current instructions and then renaming the sources (inputs) of the instruction. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> As noted above, there are three types of dependencies: input dependencies, output dependencies and anti-dependencies. Input dependencies occur when an instruction, call it A, performs an operation on the result of a previous instruction, call it B. Output dependencies occur when the outputs of A and B are to be stored in the same place. Anti-dependencies occur when instruction A comes before B in the instruction stream and B&apos;s result will be stored in the same place as one of A&apos;s inputs. </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> Input dependencies are handled by not executing instructions until their inputs are available. RRC <highlight><bold>112</bold></highlight> is used to locate the input dependencies between current instructions and then to signal an Instruction Scheduler or Issuer <highlight><bold>118</bold></highlight> when all inputs for a particular instruction are ready. In order to locate these dependencies, RRC <highlight><bold>112</bold></highlight> compares the register file addresses of each instruction&apos;inputs with the addresses of each previous instruction&apos;s output using a data dependency circuit (DDC) <highlight><bold>108</bold></highlight>. If one instruction&apos;s input comes from a register where a previous instruction&apos;s output will be stored, then the latter instruction must wait for the former to finish. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> This implementation of RRC <highlight><bold>112</bold></highlight> can check eight instructions at the same time, so a current instruction is defined as any one of those eight from window <highlight><bold>102</bold></highlight>. It should become evident to those skilled in the art that the present invention can easily be adapted to check more or less instructions. </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> In one embodiment of the present invention, instructions can have from 0 to 3 inputs and 0 or 1 outputs. Most instructions&apos; inputs and outputs come from, or are stored in, one of several register files. Each register file <highlight><bold>117</bold></highlight> (e.g., separate integer, floating and boolean register files) has 32 real entries plus the group of 8 temporary buffers <highlight><bold>116</bold></highlight>. When an instruction completes (the term &ldquo;complete&rdquo; means that the operation is complete and the operand is ready to be written to its destination register), its result is stored in its preassigned location in the temporary buffers <highlight><bold>1</bold></highlight> <highlight><bold>16</bold></highlight>. Its result is later moved to the appropriate place in register file <highlight><bold>117</bold></highlight> after all previous instructions&apos; results have been moved to their places in the register file. This movement of results from temporary buffers <highlight><bold>116</bold></highlight> to register file <highlight><bold>117</bold></highlight> is called &ldquo;retirement&rdquo; and is controlled by termination logic, as should become evident to those skilled in the art. More than one instruction may be retired at a time. Retirement comprises updating the &ldquo;official state&rdquo; ofthe machine, including the computer&apos;s Program Counter, as will become evident to those skilled in the art. For example, if instruction I<highlight><bold>0</bold></highlight> happens to complete directly before instruction I<highlight><bold>1</bold></highlight>, both results can be stored directly into register file <highlight><bold>117</bold></highlight>. But if instruction I<highlight><bold>3</bold></highlight> then completes, its result must be stored in temporary buffer <highlight><bold>116</bold></highlight> until instruction I<highlight><bold>2</bold></highlight> completes. By having IEU <highlight><bold>100</bold></highlight> store each instruction&apos;s result in its preassigned place in the temporary buffers <highlight><bold>116</bold></highlight>, IEU <highlight><bold>100</bold></highlight> can execute instructions out of program order and still avoid the problems caused by output and anti-dependencies. </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> RRC <highlight><bold>112</bold></highlight> sends a bit map to an Instruction Scheduler <highlight><bold>118</bold></highlight> via a bus <highlight><bold>120</bold></highlight> indicating which instructions in window <highlight><bold>102</bold></highlight> are ready for issuing. Instruction decode logic (not shown) indicates to Issuer <highlight><bold>118</bold></highlight> the resource requirements for each instruction over a bus <highlight><bold>123</bold></highlight>. For each resource in IEU <highlight><bold>100</bold></highlight> (e.g., each functional unit being an adder, multiplier, shifter, or the like), Issuer <highlight><bold>118</bold></highlight> scans this information and selects the first and subsequent instructions for issuing by sending issue signals over bus <highlight><bold>121</bold></highlight>. The issue signals select a group of Register File Port MUXes (RPMs) <highlight><bold>124</bold></highlight> inside RRC <highlight><bold>112</bold></highlight> whose inputs are the addresses of each instruction&apos;s inputs. </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> Because the results may stay in temporary buffer <highlight><bold>116</bold></highlight> several cycles before going to register file <highlight><bold>117</bold></highlight>, a mechanism is provided to get results from temporary buffer <highlight><bold>116</bold></highlight> before they go to register file <highlight><bold>117</bold></highlight>, so the information can be used as operands for other instructions. This mechanism is called &ldquo;result forwarding,&rdquo; and without it, Issuer <highlight><bold>118</bold></highlight> would not be able to issue instructions out of order. This result forwarding is done in register file <highlight><bold>117</bold></highlight> and is controlled by RRC <highlight><bold>112</bold></highlight>. The control signals necessary for performing the result forwarding will become evident to those skilled in the art, as should the random logic used for generating such control signals. </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> If an instruction is not dependent on any of the current instructions, result forwarding is not necessary since the instruction&apos;s inputs are already in register file <highlight><bold>117</bold></highlight>. When Issuer <highlight><bold>118</bold></highlight> decides to execute that instruction, RRC <highlight><bold>112</bold></highlight> tells register file <highlight><bold>117</bold></highlight> to output its data. </paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> RRC <highlight><bold>112</bold></highlight> contains three subsections: a Data Dependency Checker (DDC) <highlight><bold>108</bold></highlight>, Tag Assign Logic (TAL) <highlight><bold>122</bold></highlight> and Register File Port MUXes (RPM) <highlight><bold>124</bold></highlight>. DDC <highlight><bold>108</bold></highlight> determines where the input dependencies are between the current instructions. TAL <highlight><bold>122</bold></highlight> monitors the dependencies for Issuer <highlight><bold>118</bold></highlight> and controls result forwarding. RPM <highlight><bold>124</bold></highlight> is controlled by Issuer <highlight><bold>118</bold></highlight> and directs the outputs of TAL <highlight><bold>122</bold></highlight> to the appropriate register file address ports <highlight><bold>119</bold></highlight>. Instructions are passed to DDC <highlight><bold>108</bold></highlight> via bus <highlight><bold>110</bold></highlight>. All source registers are compared with all previous destination registers for each instruction in window <highlight><bold>102</bold></highlight>. </paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> Each instruction has only one destination, which may be a double register in one embodiment. An instruction can only depend on a previous instruction and may have up to three source registers. There are various register file source and destination addresses that need to be checked against each other for any dependencies. As noted above, the eight bottom instructions corresponding to the lower two buckets are checked by DDC <highlight><bold>108</bold></highlight>. All source register addresses are compared with all previous destination register addresses for the instructions in window <highlight><bold>102</bold></highlight>. </paragraph>
<paragraph id="P-0068" lvl="0"><number>&lsqb;0068&rsqb;</number> For example, let&apos;s say a program has the following instruction sequence: </paragraph>
<paragraph id="P-0069" lvl="2"><number>&lsqb;0069&rsqb;</number> add R<highlight><bold>0</bold></highlight>, R<highlight><bold>1</bold></highlight>, R<highlight><bold>2</bold></highlight> (<highlight><bold>0</bold></highlight>) </paragraph>
<paragraph id="P-0070" lvl="2"><number>&lsqb;0070&rsqb;</number> add R<highlight><bold>0</bold></highlight>, R<highlight><bold>2</bold></highlight>, R<highlight><bold>3</bold></highlight> (<highlight><bold>1</bold></highlight>) </paragraph>
<paragraph id="P-0071" lvl="2"><number>&lsqb;0071&rsqb;</number> add R<highlight><bold>4</bold></highlight>, R<highlight><bold>5</bold></highlight>, R<highlight><bold>2</bold></highlight> (<highlight><bold>2</bold></highlight>) </paragraph>
<paragraph id="P-0072" lvl="2"><number>&lsqb;0072&rsqb;</number> add R<highlight><bold>2</bold></highlight>, R<highlight><bold>3</bold></highlight>, R<highlight><bold>4</bold></highlight> (<highlight><bold>3</bold></highlight>) </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> The first two registers in each instruction <highlight><bold>0</bold></highlight>-<highlight><bold>3</bold></highlight> are the source registers, and the last listed register in each instruction is the destination register. For example, R<highlight><bold>0</bold></highlight> and R<highlight><bold>1</bold></highlight> are the source registers for instruction <highlight><bold>0</bold></highlight> and R<highlight><bold>2</bold></highlight> is the destination register. Instruction <highlight><bold>0</bold></highlight> adds the contents of registers <highlight><bold>0</bold></highlight> and <highlight><bold>1</bold></highlight> and stores the result in R<highlight><bold>2</bold></highlight>. For instructions <highlight><bold>1</bold></highlight>-<highlight><bold>3</bold></highlight> in this example, the following are the comparisons needed to evaluate all of the dependencies: </paragraph>
<paragraph id="P-0074" lvl="2"><number>&lsqb;0074&rsqb;</number> I<highlight><bold>1</bold></highlight>S<highlight><bold>1</bold></highlight>, I<highlight><bold>1</bold></highlight>S<highlight><bold>2</bold></highlight> vs. I<highlight><bold>0</bold></highlight>D </paragraph>
<paragraph id="P-0075" lvl="2"><number>&lsqb;0075&rsqb;</number> I<highlight><bold>2</bold></highlight>S<highlight><bold>1</bold></highlight>, I<highlight><bold>2</bold></highlight>S<highlight><bold>2</bold></highlight> vs. I<highlight><bold>1</bold></highlight>D, I<highlight><bold>0</bold></highlight>D </paragraph>
<paragraph id="P-0076" lvl="2"><number>&lsqb;0076&rsqb;</number> I<highlight><bold>3</bold></highlight>S<highlight><bold>1</bold></highlight>, I<highlight><bold>3</bold></highlight>S<highlight><bold>2</bold></highlight> vs. I<highlight><bold>2</bold></highlight>D, I<highlight><bold>1</bold></highlight>D, I<highlight><bold>0</bold></highlight>D </paragraph>
<paragraph id="P-0077" lvl="0"><number>&lsqb;0077&rsqb;</number> The key to the above is as follows: IXRS<highlight><bold>1</bold></highlight> is the address of source (input) number <highlight><bold>1</bold></highlight> of instruction X; IXRS<highlight><bold>2</bold></highlight> is the address of source (input) number <highlight><bold>2</bold></highlight> of instruction X; and IXD is the address of the destination (output) of instruction X. </paragraph>
<paragraph id="P-0078" lvl="0"><number>&lsqb;0078&rsqb;</number> Note also that RRC <highlight><bold>112</bold></highlight> can ignore the fact that instruction <highlight><bold>2</bold></highlight> is output dependent on instruction <highlight><bold>0</bold></highlight>, because the processor has a temporary buffer where instruction <highlight><bold>2</bold></highlight>&apos;s result can be stored without interfering with instruction <highlight><bold>0</bold></highlight>&apos;s result. As discussed before, instruction <highlight><bold>2</bold></highlight>&apos;s result will not be moved from temporary buffers <highlight><bold>116</bold></highlight> to register file <highlight><bold>117</bold></highlight> until instructions <highlight><bold>0</bold></highlight> and <highlight><bold>1</bold></highlight>&apos;s results are moved to register file <highlight><bold>117</bold></highlight>. </paragraph>
<paragraph id="P-0079" lvl="0"><number>&lsqb;0079&rsqb;</number> The number of instructions that can be checked by RRC <highlight><bold>112</bold></highlight> is easily scaleable. In order to check eight instructions at a time instead of four, the following additional comparisons would also need to be made: </paragraph>
<paragraph id="P-0080" lvl="2"><number>&lsqb;0080&rsqb;</number> I<highlight><bold>4</bold></highlight>S<highlight><bold>1</bold></highlight>, I<highlight><bold>4</bold></highlight>S<highlight><bold>2</bold></highlight> vs I<highlight><bold>3</bold></highlight>D, I<highlight><bold>2</bold></highlight>D, I<highlight><bold>1</bold></highlight>D, I<highlight><bold>0</bold></highlight>D </paragraph>
<paragraph id="P-0081" lvl="2"><number>&lsqb;0081&rsqb;</number> I<highlight><bold>5</bold></highlight>S<highlight><bold>1</bold></highlight>, I<highlight><bold>5</bold></highlight>S<highlight><bold>2</bold></highlight> vs <highlight><bold>14</bold></highlight>D, I<highlight><bold>3</bold></highlight>D, I<highlight><bold>2</bold></highlight>D, I<highlight><bold>1</bold></highlight>D, I<highlight><bold>0</bold></highlight>D </paragraph>
<paragraph id="P-0082" lvl="2"><number>&lsqb;0082&rsqb;</number> I<highlight><bold>6</bold></highlight>S<highlight><bold>1</bold></highlight>, I<highlight><bold>6</bold></highlight>S<highlight><bold>2</bold></highlight> vs <highlight><bold>15</bold></highlight>D, I<highlight><bold>4</bold></highlight>D, I<highlight><bold>3</bold></highlight>D, I<highlight><bold>2</bold></highlight>D, I<highlight><bold>1</bold></highlight>D, I<highlight><bold>0</bold></highlight>D </paragraph>
<paragraph id="P-0083" lvl="2"><number>&lsqb;0083&rsqb;</number> I<highlight><bold>7</bold></highlight>S<highlight><bold>1</bold></highlight>, I<highlight><bold>7</bold></highlight>S<highlight><bold>2</bold></highlight> vs I<highlight><bold>6</bold></highlight>D, I<highlight><bold>5</bold></highlight>D, I<highlight><bold>4</bold></highlight>D, I<highlight><bold>3</bold></highlight>D, I<highlight><bold>2</bold></highlight>D, I<highlight><bold>1</bold></highlight>D, I<highlight><bold>0</bold></highlight>D </paragraph>
<paragraph id="P-0084" lvl="0"><number>&lsqb;0084&rsqb;</number> There are several special cases that RRC <highlight><bold>112</bold></highlight> must handle in order to do the dependency check. First, there are some instructions that use the same register as an input and an output. Thus, RRC <highlight><bold>112</bold></highlight> must compare this source/destination register address with the destination register addresses of all previous instructions. </paragraph>
<paragraph id="P-0085" lvl="0"><number>&lsqb;0085&rsqb;</number> So for instruction <highlight><bold>7</bold></highlight>, the following comparisons would be necessary: </paragraph>
<paragraph id="P-0086" lvl="2"><number>&lsqb;0086&rsqb;</number> I<highlight><bold>7</bold></highlight>S<highlight><bold>1</bold></highlight>, I<highlight><bold>7</bold></highlight>S<highlight><bold>2</bold></highlight>, I<highlight><bold>7</bold></highlight>S/D vs. I<highlight><bold>6</bold></highlight>D, I<highlight><bold>5</bold></highlight>D, I<highlight><bold>4</bold></highlight>D, I<highlight><bold>3</bold></highlight>D, I<highlight><bold>2</bold></highlight>D, I<highlight><bold>1</bold></highlight>D, I<highlight><bold>0</bold></highlight>D. </paragraph>
<paragraph id="P-0087" lvl="0"><number>&lsqb;0087&rsqb;</number> Another special case occurs when a program contains instructions that generate 64 bit outputs (called long-word operations). These instructions need two registers in which to store their results. In this embodiment, these registers must be sequential. Thus if RRC <highlight><bold>112</bold></highlight> is checking instruction <highlight><bold>4</bold></highlight>&apos;s dependencies and instruction <highlight><bold>1</bold></highlight> is a long-word operation, then it must do the following comparisons: </paragraph>
<paragraph id="P-0088" lvl="2"><number>&lsqb;0088&rsqb;</number> I<highlight><bold>4</bold></highlight>S<highlight><bold>1</bold></highlight>, I<highlight><bold>4</bold></highlight>S<highlight><bold>2</bold></highlight> vs. I<highlight><bold>3</bold></highlight>D, I<highlight><bold>2</bold></highlight>D, I<highlight><bold>1</bold></highlight>D, I<highlight><bold>1</bold></highlight>D&plus;1, I<highlight><bold>0</bold></highlight>D </paragraph>
<paragraph id="P-0089" lvl="0"><number>&lsqb;0089&rsqb;</number> Sometimes, instructions do not have destination registers. Thus RRC <highlight><bold>112</bold></highlight> must ignore any dependencies between instructions without destination registers and any future instructions. Also, instructions may have only one valid source register, so RRC <highlight><bold>112</bold></highlight> must ignore any dependencies between the unused source register (usually S<highlight><bold>2</bold></highlight>) and any previous instructions. </paragraph>
<paragraph id="P-0090" lvl="0"><number>&lsqb;0090&rsqb;</number> RRC <highlight><bold>112</bold></highlight> is also capable of dealing with multiple register files. When using multiple register files, dependencies only occur when one instruction&apos;s source register has the same address and is in the same register file as some other instruction&apos;s destination register. RRC <highlight><bold>112</bold></highlight> treats the information regarding which register file a particular address is from as part ofthe address. For example, in an implementation using four 32 bit register files, RRC <highlight><bold>112</bold></highlight> would do 7 bit compares instead of 5 bit compares (5 for the address and 2 for the register file). </paragraph>
<paragraph id="P-0091" lvl="0"><number>&lsqb;0091&rsqb;</number> Signals indicating which instructions are long-word operations or have invalid source or destination registers are sent to RRC <highlight><bold>112</bold></highlight> from Instruction Decode Logic (IDL; not shown). IDL also tells RRC <highlight><bold>112</bold></highlight> which register file each instruction&apos;s sources and destinations will come from or go to. </paragraph>
<paragraph id="P-0092" lvl="0"><number>&lsqb;0092&rsqb;</number> A block diagram of DDC <highlight><bold>108</bold></highlight> is shown in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>. Source address signals arrive from IFIFO <highlight><bold>101</bold></highlight> for all eight instructions of window <highlight><bold>102</bold></highlight>. Additional inputs include long-word load operation flags, register file decode signals, invalid destination register flags, destination address signals and addressing mode flags for all eight instructions. </paragraph>
<paragraph id="P-0093" lvl="0"><number>&lsqb;0093&rsqb;</number> DDC <highlight><bold>208</bold></highlight> comprises <highlight><bold>28</bold></highlight> data dependency blocks <highlight><bold>204</bold></highlight>. Each block <highlight><bold>204</bold></highlight> is described in a KEY <highlight><bold>206</bold></highlight>. Each block <highlight><bold>204</bold></highlight> receives 3 inputs, IXS<highlight><bold>1</bold></highlight>, IXS<highlight><bold>2</bold></highlight> and IXS/D. IXS<highlight><bold>1</bold></highlight> is the address of source (input) number <highlight><bold>1</bold></highlight> of instruction X, IXS<highlight><bold>2</bold></highlight> is the address of source (input) number <highlight><bold>2</bold></highlight> of instruction X and IXS/D is the address of the source/destination (input) of instruction X. Each block <highlight><bold>204</bold></highlight> also receives input IYS/D, which is the destination register address for some previous instruction Y. A top row <highlight><bold>208</bold></highlight>, for example, receives I<highlight><bold>0</bold></highlight>S/D, which is the destination register address for instruction <highlight><bold>0</bold></highlight>. Each block <highlight><bold>204</bold></highlight> outputs the data dependency results to one of a corresponding bus line <highlight><bold>114</bold></highlight>. For example, the address of I<highlight><bold>2</bold></highlight>S/D must be checked with operand addresses S<highlight><bold>1</bold></highlight>, S<highlight><bold>2</bold></highlight> and S/D of instructions <highlight><bold>7</bold></highlight>, <highlight><bold>6</bold></highlight>, <highlight><bold>5</bold></highlight>, <highlight><bold>4</bold></highlight>, and <highlight><bold>3</bold></highlight>. </paragraph>
<paragraph id="P-0094" lvl="0"><number>&lsqb;0094&rsqb;</number> Each block <highlight><bold>204</bold></highlight> performs the three comparisons. To illustrate these comparisons, consider a generic block <highlight><bold>700</bold></highlight> shown in <cross-reference target="DRAWINGS">FIG. 7</cross-reference>, which compares instruction Y&apos;s source/destination operand with each operand of instruction X. In this example, the three following comparisons must be made: </paragraph>
<paragraph id="P-0095" lvl="2"><number>&lsqb;0095&rsqb;</number> IXS<highlight><bold>1</bold></highlight>&equals;IYS/D </paragraph>
<paragraph id="P-0096" lvl="2"><number>&lsqb;0096&rsqb;</number> IXS<highlight><bold>2</bold></highlight>&equals;IYS/D </paragraph>
<paragraph id="P-0097" lvl="2"><number>&lsqb;0097&rsqb;</number> IXS/D&equals;IYS/D </paragraph>
<paragraph id="P-0098" lvl="0"><number>&lsqb;0098&rsqb;</number> These comparisons are represented by three comparator blocks <highlight><bold>702</bold></highlight>, <highlight><bold>704</bold></highlight> and <highlight><bold>706</bold></highlight>, respectively. One set of inputs to comparator blocks <highlight><bold>702</bold></highlight>, <highlight><bold>704</bold></highlight> and <highlight><bold>706</bold></highlight> are the bits of the IYS/D field, which is represented by number <highlight><bold>708</bold></highlight>. Comparator block <highlight><bold>702</bold></highlight> has as its second set of inputs the bits of the IXS<highlight><bold>1</bold></highlight>. Similarly, comparator block <highlight><bold>704</bold></highlight> has as its second set of inputs the bits of the IXS<highlight><bold>2</bold></highlight>, and comparator block <highlight><bold>706</bold></highlight> has as its second set of inputs the bits of the IXS/D. </paragraph>
<paragraph id="P-0099" lvl="0"><number>&lsqb;0099&rsqb;</number> In a preferred embodiment, the comparisons performed by blocks <highlight><bold>702</bold></highlight>,<highlight><bold>704</bold></highlight> and <highlight><bold>706</bold></highlight> can be performed by random logic. An example of random logic for comparator block <highlight><bold>706</bold></highlight> is shown in <cross-reference target="DRAWINGS">FIG. 8</cross-reference>. Instruction Y&apos;s source/destination bits &lsqb;<highlight><bold>6</bold></highlight>:<highlight><bold>0</bold></highlight>&rsqb; are shown input from the right at reference number <highlight><bold>802</bold></highlight> and instruction X&apos;s source/destination bits &lsqb;<highlight><bold>6</bold></highlight>:<highlight><bold>0</bold></highlight>&rsqb; are shown input from the top at reference number <highlight><bold>804</bold></highlight>. The most scant bit (MSB) is bit <highlight><bold>6</bold></highlight> and the least significant bit (LSB) is bit <highlight><bold>0</bold></highlight>. The corresponding bits from the two operands are fed to a set of seven exclusive NOR gates (XNORS) <highlight><bold>806</bold></highlight>. The outputs of XNORs <highlight><bold>806</bold></highlight> are then ANDed by a seven input AND gate <highlight><bold>808</bold></highlight>. If the corresponding bits are the same, the output of XNOR <highlight><bold>806</bold></highlight> will be logic high. When all bits are the same, all seven XNOR <highlight><bold>806</bold></highlight> outputs are logic high and the output of AND gate <highlight><bold>808</bold></highlight> is logic high, this indicates that there is a dependency between IXS/D and IYS/D. </paragraph>
<paragraph id="P-0100" lvl="0"><number>&lsqb;0100&rsqb;</number> The random logic for comparator blocks <highlight><bold>702</bold></highlight> and <highlight><bold>704</bold></highlight> will be identical to that shown in <cross-reference target="DRAWINGS">FIG. 8</cross-reference>. The present invention contemplates many other random logic circuits for performing data dependency checking, as will become evident to those skilled in the art without departing from the spirit of this example. </paragraph>
<paragraph id="P-0101" lvl="0"><number>&lsqb;0101&rsqb;</number> As will further become evident to those skilled in the art, various implementation-specific special cases can arise which require additional random logic to perform data dependency checking. An illustrative special data dependency checking case is for long word handling. </paragraph>
<paragraph id="P-0102" lvl="0"><number>&lsqb;0102&rsqb;</number> As mentioned before, if a long word operation writes to register X, the first 32 bits are written to register X and the second 32 bits are written to register X&plus;1. The data dependency checker therefore needs to check both registers when doing a comparison. In a preferred embodiment, register X is an even register, X&plus;1 is an odd register and thus they only differ by the LSB. The easiest way to check both registers at the same time is to simply ignore the LSB. In the case of a store long (STLG) or load long (LDLG) operation, if X and Y only differ by the LSB bit &lsqb;<highlight><bold>0</bold></highlight>&rsqb;, the logic in <cross-reference target="DRAWINGS">FIG. 8</cross-reference> would cause there to be no dependency, when there really is a dependency. Therefore, for a long word operation the STLG and LDLG flags must be ORed with the output of the &lsqb;0&rsqb; bit XNOR to assure that all dependencies are detected. </paragraph>
<paragraph id="P-0103" lvl="0"><number>&lsqb;0103&rsqb;</number> A data dependency check flowchart for IXS<highlight><bold>1</bold></highlight> and IYS/D is shown in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>. DDC <highlight><bold>108</bold></highlight> first checks whether IXS<highlight><bold>1</bold></highlight> and IYS/D are in the same register file, as shown at a conditional block <highlight><bold>502</bold></highlight>. If they are not in the same register file there is no dependency. This is shown at a block <highlight><bold>504</bold></highlight>. If there is a dependency, DDC <highlight><bold>108</bold></highlight> then determines whether IXS<highlight><bold>1</bold></highlight> and IYS/D are in the same register, as shown at a block <highlight><bold>506</bold></highlight>. If they are not in the same register, flow proceeds to a conditional block <highlight><bold>508</bold></highlight> where DDC <highlight><bold>108</bold></highlight> determines whether IY is a long word operation. If IY is not a long word operation there is no dependency and flow proceeds to a block <highlight><bold>504</bold></highlight>. If IY is a long word operation, flow then proceeds to a conditional statement <highlight><bold>510</bold></highlight> where DDC <highlight><bold>108</bold></highlight> determines whether IXS<highlight><bold>1</bold></highlight> and IYS/D&plus;1 are the same register. If they are not, there is no dependency and flow proceeds to a block <highlight><bold>504</bold></highlight>. If IXS<highlight><bold>1</bold></highlight> and IYS/D&plus;1 are the same register, flow proceeds to a conditional block <highlight><bold>512</bold></highlight> where DDC <highlight><bold>108</bold></highlight> determines if IY has a valid destination. If it does not have a valid destination, there is no dependency and flow proceeds to block <highlight><bold>504</bold></highlight>. If IY does have a valid destination, flow proceeds to a conditional block <highlight><bold>514</bold></highlight> where DDC <highlight><bold>108</bold></highlight> determines if IXS<highlight><bold>1</bold></highlight> has a valid source register. Again, if no valid source register is detected there is no dependency, and flow proceeds to a block <highlight><bold>504</bold></highlight>. If a valid source register is detected, DDC <highlight><bold>108</bold></highlight> has determined that there is a dependency between IXS<highlight><bold>1</bold></highlight> and IYX/D, as shown at a block <highlight><bold>516</bold></highlight>. </paragraph>
<paragraph id="P-0104" lvl="0"><number>&lsqb;0104&rsqb;</number> A more detailed discussion of data dependency checking is found in commonly owned, copending application Ser. No. 07/860,718, the disclosure of which is incorporated herein by reference. </paragraph>
<paragraph id="P-0105" lvl="0"><number>&lsqb;0105&rsqb;</number> Because it is possible that an instruction might get one of its inputs from a register that was written to by several other instructions, the present invention must choose which one is the real dependency. For example, if instructions <highlight><bold>2</bold></highlight> and <highlight><bold>5</bold></highlight> write to register <highlight><bold>4</bold></highlight> and instruction <highlight><bold>7</bold></highlight> reads register <highlight><bold>4</bold></highlight>, then instruction <highlight><bold>7</bold></highlight> has two possible dependencies. In this case, it is assumed that since instruction <highlight><bold>5</bold></highlight> came after instruction <highlight><bold>2</bold></highlight> in the program, the programmer intended instruction <highlight><bold>7</bold></highlight> to use instruction <highlight><bold>5</bold></highlight>&apos;s result and not instruction <highlight><bold>2</bold></highlight>&apos;s. So, if an instruction can be dependent on several previous instructions, RRC <highlight><bold>112</bold></highlight> will consider it to be dependent on the highest numbered previous instruction. </paragraph>
<paragraph id="P-0106" lvl="0"><number>&lsqb;0106&rsqb;</number> Once TAL <highlight><bold>122</bold></highlight> has determined where the real dependencies are, it must locate the inputs for each instruction. In a preferred embodiment of the present invention, the inputs can come from the actual register file or an array of temporary buffers <highlight><bold>116</bold></highlight>. RRC <highlight><bold>112</bold></highlight> assumes that if an instruction has no dependencies, its inputs are all in the register file. In this case, RRC <highlight><bold>112</bold></highlight> passes the IXS<highlight><bold>1</bold></highlight>, IXS<highlight><bold>2</bold></highlight> and IXS/D addresses that came from IFIFO <highlight><bold>102</bold></highlight> to the register file. If an instruction has a dependency, then RRC <highlight><bold>112</bold></highlight> assumes that the data is in temporary buffers <highlight><bold>116</bold></highlight>. Since RRC <highlight><bold>112</bold></highlight> knows which previous instruction each instruction depends on, and since each instruction always writes to the same place in temporary buffers <highlight><bold>116</bold></highlight>, RRC <highlight><bold>112</bold></highlight> can determine where in temporary buffers <highlight><bold>116</bold></highlight> an instruction&apos;s inputs are stored. It sends these addresses to register file read ports <highlight><bold>119</bold></highlight> and register file <highlight><bold>117</bold></highlight> outputs the data from temporary buffers <highlight><bold>116</bold></highlight> so that the instruction can use it. </paragraph>
<paragraph id="P-0107" lvl="0"><number>&lsqb;0107&rsqb;</number> The following is an example of tag assignments: </paragraph>
<paragraph id="P-0108" lvl="2"><number>&lsqb;0108&rsqb;</number> 0: add r<highlight><bold>0</bold></highlight>, r<highlight><bold>2</bold></highlight>, r<highlight><bold>2</bold></highlight> </paragraph>
<paragraph id="P-0109" lvl="2"><number>&lsqb;0109&rsqb;</number> 1: add r<highlight><bold>0</bold></highlight>, r<highlight><bold>2</bold></highlight>, r<highlight><bold>3</bold></highlight> </paragraph>
<paragraph id="P-0110" lvl="2"><number>&lsqb;0110&rsqb;</number> 2: add r<highlight><bold>4</bold></highlight>, r<highlight><bold>5</bold></highlight>, r<highlight><bold>2</bold></highlight> </paragraph>
<paragraph id="P-0111" lvl="2"><number>&lsqb;0111&rsqb;</number> 3: add r<highlight><bold>2</bold></highlight>, r<highlight><bold>3</bold></highlight>, r<highlight><bold>4</bold></highlight> </paragraph>
<paragraph id="P-0112" lvl="0"><number>&lsqb;0112&rsqb;</number> The following are the dependencies for the above operations (dependencies are represented by the symbol &ldquo;&num;&rdquo;): </paragraph>
<paragraph id="P-0113" lvl="2"><number>&lsqb;0113&rsqb;</number> I<highlight><bold>1</bold></highlight>S<highlight><bold>2</bold></highlight>&num;I<highlight><bold>0</bold></highlight>S/D </paragraph>
<paragraph id="P-0114" lvl="2"><number>&lsqb;0114&rsqb;</number> I<highlight><bold>3</bold></highlight>S<highlight><bold>1</bold></highlight>&num;I<highlight><bold>0</bold></highlight>S/D </paragraph>
<paragraph id="P-0115" lvl="2"><number>&lsqb;0115&rsqb;</number> I<highlight><bold>3</bold></highlight>S<highlight><bold>1</bold></highlight>&num;I<highlight><bold>2</bold></highlight>S/D </paragraph>
<paragraph id="P-0116" lvl="2"><number>&lsqb;0116&rsqb;</number> I<highlight><bold>3</bold></highlight>S<highlight><bold>2</bold></highlight>&num;I<highlight><bold>1</bold></highlight>S/D </paragraph>
<paragraph id="P-0117" lvl="0"><number>&lsqb;0117&rsqb;</number> First, look at I<highlight><bold>0</bold></highlight>; since it has no dependencies, its tags are equal to its original source register addresses: </paragraph>
<paragraph id="P-0118" lvl="2"><number>&lsqb;0118&rsqb;</number> I<highlight><bold>0</bold></highlight>S<highlight><bold>1</bold></highlight> TAG&equals;I<highlight><bold>0</bold></highlight>S<highlight><bold>1</bold></highlight>&equals;r<highlight><bold>0</bold></highlight> </paragraph>
<paragraph id="P-0119" lvl="2"><number>&lsqb;0119&rsqb;</number> I<highlight><bold>0</bold></highlight>S<highlight><bold>2</bold></highlight> TAG&equals;I<highlight><bold>0</bold></highlight>S<highlight><bold>2</bold></highlight>&equals;r<highlight><bold>1</bold></highlight> </paragraph>
<paragraph id="P-0120" lvl="2"><number>&lsqb;0120&rsqb;</number> I<highlight><bold>0</bold></highlight>S/D TAG&equals;I<highlight><bold>0</bold></highlight>S/D&equals;r<highlight><bold>2</bold></highlight> </paragraph>
<paragraph id="P-0121" lvl="0"><number>&lsqb;0121&rsqb;</number> I<highlight><bold>1</bold></highlight> has one dependency, and its tags are as follows: </paragraph>
<paragraph id="P-0122" lvl="2"><number>&lsqb;0122&rsqb;</number> I<highlight><bold>1</bold></highlight>S<highlight><bold>1</bold></highlight> TAG&equals;I<highlight><bold>1</bold></highlight>S<highlight><bold>1</bold></highlight>&equals;r<highlight><bold>0</bold></highlight> </paragraph>
<paragraph id="P-0123" lvl="2"><number>&lsqb;0123&rsqb;</number> I<highlight><bold>1</bold></highlight>S<highlight><bold>2</bold></highlight> TAG&equals;I<highlight><bold>0</bold></highlight>S/D&equals;t<highlight><bold>0</bold></highlight> </paragraph>
<paragraph id="P-0124" lvl="3"><number>&lsqb;0124&rsqb;</number> where: (t<highlight><bold>0</bold></highlight>&equals;inst. <highlight><bold>0</bold></highlight>&apos;s slot in temporary buffer) </paragraph>
<paragraph id="P-0125" lvl="2"><number>&lsqb;0125&rsqb;</number> I<highlight><bold>1</bold></highlight>S/D TAG&equals;I<highlight><bold>1</bold></highlight>S/D&equals;r<highlight><bold>3</bold></highlight> </paragraph>
<paragraph id="P-0126" lvl="0"><number>&lsqb;0126&rsqb;</number> I<highlight><bold>2</bold></highlight> is also independent </paragraph>
<paragraph id="P-0127" lvl="2"><number>&lsqb;0127&rsqb;</number> I<highlight><bold>2</bold></highlight>S<highlight><bold>1</bold></highlight> TAG&equals;I<highlight><bold>2</bold></highlight>S<highlight><bold>1</bold></highlight>&equals;r<highlight><bold>4</bold></highlight> </paragraph>
<paragraph id="P-0128" lvl="2"><number>&lsqb;0128&rsqb;</number> I<highlight><bold>2</bold></highlight>S<highlight><bold>2</bold></highlight> TAG&equals;I<highlight><bold>2</bold></highlight>S<highlight><bold>2</bold></highlight>&equals;r<highlight><bold>5</bold></highlight> </paragraph>
<paragraph id="P-0129" lvl="2"><number>&lsqb;0129&rsqb;</number> I<highlight><bold>2</bold></highlight>S/D TAG&equals;I<highlight><bold>2</bold></highlight>S/D&equals;r<highlight><bold>2</bold></highlight> </paragraph>
<paragraph id="P-0130" lvl="0"><number>&lsqb;0130&rsqb;</number> I<highlight><bold>3</bold></highlight>S<highlight><bold>1</bold></highlight> has two possible dependencies, I<highlight><bold>0</bold></highlight>S/D and <highlight><bold>12</bold></highlight>SD. Because TAL <highlight><bold>122</bold></highlight> must pick the last one (highest numbered one), I<highlight><bold>2</bold></highlight>S/D is chosen. </paragraph>
<paragraph id="P-0131" lvl="2"><number>&lsqb;0131&rsqb;</number> I<highlight><bold>3</bold></highlight>S<highlight><bold>1</bold></highlight> TAG&equals;I<highlight><bold>2</bold></highlight>S/D&equals;t<highlight><bold>2</bold></highlight> </paragraph>
<paragraph id="P-0132" lvl="2"><number>&lsqb;0132&rsqb;</number> I<highlight><bold>3</bold></highlight>S<highlight><bold>2</bold></highlight> TAG&equals;I<highlight><bold>1</bold></highlight>S/D&equals;t<highlight><bold>1</bold></highlight> </paragraph>
<paragraph id="P-0133" lvl="2"><number>&lsqb;0133&rsqb;</number> I<highlight><bold>3</bold></highlight>S/D TAG&equals;I<highlight><bold>3</bold></highlight>S/D&equals;r<highlight><bold>4</bold></highlight> </paragraph>
<paragraph id="P-0134" lvl="7"><number>&lsqb;0134&rsqb;</number> These tags are then sent to RPM <highlight><bold>124</bold></highlight> via bus <highlight><bold>126</bold></highlight> to be selected by Issuer <highlight><bold>118</bold></highlight>. At the same time TAL <highlight><bold>122</bold></highlight> is preparing the tags, it is also monitoring the outputs of DCL <highlight><bold>130</bold></highlight> and passing them on to Issuer <highlight><bold>118</bold></highlight> using bus <highlight><bold>120</bold></highlight>. TAL <highlight><bold>122</bold></highlight> chooses the proper outputs of DCL&apos;s <highlight><bold>130</bold></highlight> to pass to Issuer <highlight><bold>118</bold></highlight> by the same method that it chooses the tags that it sends to RPM <highlight><bold>124</bold></highlight>. </paragraph>
<paragraph id="P-0135" lvl="0"><number>&lsqb;0135&rsqb;</number> Continuing the example, TAL <highlight><bold>122</bold></highlight> sends the following ready signals to Issuer <highlight><bold>118</bold></highlight>: </paragraph>
<paragraph id="P-0136" lvl="2"><number>&lsqb;0136&rsqb;</number> I<highlight><bold>0</bold></highlight>S<highlight><bold>1</bold></highlight> INFO&equals;<highlight><bold>1</bold></highlight> </paragraph>
<paragraph id="P-0137" lvl="3"><number>&lsqb;0137&rsqb;</number> (Inst <highlight><bold>0</bold></highlight> is independent so it can start immediately) </paragraph>
<paragraph id="P-0138" lvl="2"><number>&lsqb;0138&rsqb;</number> I<highlight><bold>0</bold></highlight>S<highlight><bold>2</bold></highlight> INFO&equals;1 </paragraph>
<paragraph id="P-0139" lvl="2"><number>&lsqb;0139&rsqb;</number> I<highlight><bold>0</bold></highlight>S/D INFO&equals;1 </paragraph>
<paragraph id="P-0140" lvl="2"><number>&lsqb;0140&rsqb;</number> I<highlight><bold>1</bold></highlight>S<highlight><bold>1</bold></highlight> INFO&equals;1 </paragraph>
<paragraph id="P-0141" lvl="2"><number>&lsqb;0141&rsqb;</number> I<highlight><bold>1</bold></highlight>S<highlight><bold>2</bold></highlight> INFO&equals;DONE&lsqb;<highlight><bold>0</bold></highlight>&rsqb;</paragraph>
<paragraph id="P-0142" lvl="3"><number>&lsqb;0142&rsqb;</number> (DONE&lsqb;<highlight><bold>0</bold></highlight>&rsqb;&equals;1 when IO is done) </paragraph>
<paragraph id="P-0143" lvl="2"><number>&lsqb;0143&rsqb;</number> I<highlight><bold>1</bold></highlight>S/D INFO&equals;1 </paragraph>
<paragraph id="P-0144" lvl="2"><number>&lsqb;0144&rsqb;</number> I<highlight><bold>2</bold></highlight>S<highlight><bold>1</bold></highlight> INFO&equals;1 </paragraph>
<paragraph id="P-0145" lvl="2"><number>&lsqb;0145&rsqb;</number> I<highlight><bold>2</bold></highlight>S<highlight><bold>2</bold></highlight> INFO&equals;1 </paragraph>
<paragraph id="P-0146" lvl="2"><number>&lsqb;0146&rsqb;</number> I<highlight><bold>2</bold></highlight>S/D INFO&equals;1 </paragraph>
<paragraph id="P-0147" lvl="2"><number>&lsqb;0147&rsqb;</number> I<highlight><bold>3</bold></highlight>S<highlight><bold>1</bold></highlight> INFO&equals;DONE&lsqb;<highlight><bold>2</bold></highlight>&rsqb;</paragraph>
<paragraph id="P-0148" lvl="2"><number>&lsqb;0148&rsqb;</number> I<highlight><bold>3</bold></highlight>S<highlight><bold>2</bold></highlight> INFO&equals;DONE&lsqb;<highlight><bold>1</bold></highlight>&rsqb;</paragraph>
<paragraph id="P-0149" lvl="2"><number>&lsqb;0149&rsqb;</number> I<highlight><bold>3</bold></highlight>S/D READ&equals;1 </paragraph>
<paragraph id="P-0150" lvl="0"><number>&lsqb;0150&rsqb;</number> (The DONE signals come from DCL <highlight><bold>130</bold></highlight> via a bus <highlight><bold>132</bold></highlight>. In connection with the present invention, the term &ldquo;done&rdquo; means the result of the instruction is in a temporary buffer or otherwise available at the output of a functional unit. Contrastingly, the term &ldquo;terminate&rdquo; means the result of the instruction is in the register file.) </paragraph>
<paragraph id="P-0151" lvl="0"><number>&lsqb;0151&rsqb;</number> Turning now to <cross-reference target="DRAWINGS">FIG. 3, a</cross-reference> representative block diagram of TAL <highlight><bold>122</bold></highlight> will be discussed. TAL <highlight><bold>122</bold></highlight> comprises <highlight><bold>8</bold></highlight> tag assignment logic blocks <highlight><bold>302</bold></highlight>. Each TAL block <highlight><bold>302</bold></highlight> receives the corresponding data dependency results via buses <highlight><bold>114</bold></highlight>, as well as further signals that come from the computer&apos;s Instruction Decode and control logic (not shown). The BKT bit signal forms the least significant bit ofthe tag. DONE&lsqb;X&rsqb; flags are for instructions <highlight><bold>0</bold></highlight> through <highlight><bold>6</bold></highlight>, and indicate if instruction X is done. DBLREG&lsqb;X&rsqb; flags indicates which, if any, of the instructions is a double (long) word. Each TAL block <highlight><bold>302</bold></highlight> also receives its own instructions register addresses as inputs. The Misc. signals, DBLREG and BKT signals are all implementation dependent control signals. Each TAL block <highlight><bold>302</bold></highlight> outputs <highlight><bold>3</bold></highlight> TAGs <highlight><bold>126</bold></highlight> labeled IXS<highlight><bold>1</bold></highlight>, IXS<highlight><bold>2</bold></highlight> and IXS/D, which are 6 bits. TAL <highlight><bold>122</bold></highlight> outputs the least significant 5 bits of each TAG signal to RPMs <highlight><bold>124</bold></highlight> and the most significant TAG to Issuer <highlight><bold>118</bold></highlight>. </paragraph>
<paragraph id="P-0152" lvl="0"><number>&lsqb;0152&rsqb;</number> Each block <highlight><bold>302</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 3</cross-reference> comprises three Priority Encoders (PE), one for S<highlight><bold>1</bold></highlight>, one for S<highlight><bold>2</bold></highlight> and one for S/D. There is one exception however. I<highlight><bold>0</bold></highlight> requires no tag assignment. Its tags are the same as the original S<highlight><bold>1</bold></highlight>, S<highlight><bold>2</bold></highlight> and S/D addresses, because I<highlight><bold>0</bold></highlight> is always independent. </paragraph>
<paragraph id="P-0153" lvl="0"><number>&lsqb;0153&rsqb;</number> An illustrative PE is shown in <cross-reference target="DRAWINGS">FIG. 9</cross-reference>. PE <highlight><bold>902</bold></highlight> has eight inputs <highlight><bold>904</bold></highlight> and eight outputs <highlight><bold>906</bold></highlight>. Inputs <highlight><bold>904</bold></highlight> for PE <highlight><bold>902</bold></highlight> are outputs <highlight><bold>114</bold></highlight> from DDC <highlight><bold>108</bold></highlight> which show where dependencies exist. For example, in the case of source register <highlight><bold>1</bold></highlight> (S<highlight><bold>1</bold></highlight>), I<highlight><bold>7</bold></highlight>S<highlight><bold>1</bold></highlight> tag assign PE <highlight><bold>902</bold></highlight>&apos;s seven inputs are the seven outputs <highlight><bold>114</bold></highlight> of DDC <highlight><bold>108</bold></highlight> that indicate whether I<highlight><bold>7</bold></highlight>S<highlight><bold>1</bold></highlight> is dependent on I<highlight><bold>6</bold></highlight>D, whether I<highlight><bold>7</bold></highlight>S<highlight><bold>1</bold></highlight> is dependent on I<highlight><bold>5</bold></highlight>D, and so on down to whether I<highlight><bold>7</bold></highlight>S<highlight><bold>1</bold></highlight> is dependent on I<highlight><bold>0</bold></highlight>D. An eighth input, shown at reference number <highlight><bold>908</bold></highlight>, is always tied high because there should always be an output from PE <highlight><bold>902</bold></highlight>. </paragraph>
<paragraph id="P-0154" lvl="0"><number>&lsqb;0154&rsqb;</number> As stated before, if an instruction depends on several previous instructions, PE <highlight><bold>902</bold></highlight> will select and output only the most previous instruction (in program order) on which there is a dependency. This is accomplished by connecting the signal showing if there is a dependency on the most previous instruction to the highest priority input of the PE <highlight><bold>902</bold></highlight> and the signal showing if there is a dependency on the second most previous instruction to the input of PE <highlight><bold>902</bold></highlight> with the second highest priority and so on for all previous instructions. The input of the PE <highlight><bold>902</bold></highlight> with the lowest priority is always tied high so that at least one of PE <highlight><bold>902</bold></highlight>&apos;s outputs will be asserted. </paragraph>
<paragraph id="P-0155" lvl="0"><number>&lsqb;0155&rsqb;</number> Outputs <highlight><bold>906</bold></highlight> are used as select lines for a MUX <highlight><bold>910</bold></highlight>. MUX <highlight><bold>910</bold></highlight> has eight inputs <highlight><bold>912</bold></highlight> to which the tags for each instruction are applied. </paragraph>
<paragraph id="P-0156" lvl="0"><number>&lsqb;0156&rsqb;</number> To illustrate this, assume that I<highlight><bold>7</bold></highlight> depends on I<highlight><bold>6</bold></highlight> and I<highlight><bold>5</bold></highlight>; then, since I<highlight><bold>6</bold></highlight> has a higher priority than I<highlight><bold>5</bold></highlight>, the bit corresponding to I<highlight><bold>6</bold></highlight> at outputs <highlight><bold>906</bold></highlight> of PE <highlight><bold>902</bold></highlight> will be high. At the corresponding input <highlight><bold>912</bold></highlight> of MUX <highlight><bold>910</bold></highlight> will be I<highlight><bold>6</bold></highlight>&apos;s tag for S<highlight><bold>1</bold></highlight> (recall PE <highlight><bold>902</bold></highlight> is for I<highlight><bold>7</bold></highlight>S<highlight><bold>1</bold></highlight>). Because I<highlight><bold>7</bold></highlight> is dependent on I<highlight><bold>6</bold></highlight>, the location of I<highlight><bold>6</bold></highlight>&apos;s result must be output from MUX <highlight><bold>910</bold></highlight> so that it can be used by I<highlight><bold>7</bold></highlight>. I<highlight><bold>6</bold></highlight>&apos;s tag will therefore be selected and output on an output line <highlight><bold>914</bold></highlight>. I<highlight><bold>6</bold></highlight>&apos;s done flag, DONE&lsqb;<highlight><bold>6</bold></highlight>&rsqb; must also be output from MUX <highlight><bold>910</bold></highlight> so that Issuer <highlight><bold>118</bold></highlight> will know when I<highlight><bold>7</bold></highlight>&apos;s input is ready. This data is passed to Issuer <highlight><bold>118</bold></highlight> via bus <highlight><bold>120</bold></highlight>. Since an instruction can have up to three sources, TAL <highlight><bold>122</bold></highlight> monitors up to three dependencies for each instruction and sends three vectors for each instruction (totaling 24 vectors) to Issuer <highlight><bold>118</bold></highlight>. If an instruction is independent, TAL <highlight><bold>122</bold></highlight> signals to Issuer <highlight><bold>118</bold></highlight> that the instruction can begin immediately. </paragraph>
<paragraph id="P-0157" lvl="0"><number>&lsqb;0157&rsqb;</number> The MSB of the tag outputs which are sent to RPMs <highlight><bold>124</bold></highlight> is used to indicate if the address is a register file address or a temporary buffer address. If an instruction is independent, then the five LSB outputs indicate the source register address. For instructions that have dependencies: the second MSB indicates that the address is for a 64 bit value; the third through fifth MSB outputs specify the temporary buffer address; and the LSB output indicates which bucket is the current bucket, which is equal to the BKT signal in TAL <highlight><bold>122</bold></highlight>. </paragraph>
<paragraph id="P-0158" lvl="0"><number>&lsqb;0158&rsqb;</number> Like DDC <highlight><bold>108</bold></highlight>, TAL <highlight><bold>122</bold></highlight> has numerous implementation dependent, (i.e., special cases) that it handles. First, in an embodiment of the present invention, register number <highlight><bold>0</bold></highlight> of the register file is always equal to 0. Therefore, even if one instruction writes to register <highlight><bold>0</bold></highlight> and another reads from register <highlight><bold>0</bold></highlight>, there will be no dependency between them. TAL <highlight><bold>122</bold></highlight> receives three signals from Instruction Decode Logic (IDL; not shown) for each instruction to indicate if one of that instruction&apos;s sources is register <highlight><bold>0</bold></highlight>. If any of those is asserted, TAL <highlight><bold>122</bold></highlight> will ignore any dependencies for that particular input of that instruction. </paragraph>
<paragraph id="P-0159" lvl="0"><number>&lsqb;0159&rsqb;</number> Another special case occurs because under some circumstances, an instruction in bucket <highlight><bold>0</bold></highlight> will be guaranteed to not have any of the instructions in bucket <highlight><bold>1</bold></highlight> dependent on it. A four bit signal called BKT<highlight><bold>1</bold></highlight>_NODEP_ is sent to RRC <highlight><bold>112</bold></highlight> from the IEU control logic (not shown) and if BKT1_NODEP&lsqb;X&rsqb;&equals;1 then RRC <highlight><bold>112</bold></highlight> knows to ignore any dependencies between instructions <highlight><bold>4</bold></highlight>,<highlight><bold>5</bold></highlight>,<highlight><bold>6</bold></highlight> or <highlight><bold>7</bold></highlight> and instruction X </paragraph>
<paragraph id="P-0160" lvl="0"><number>&lsqb;0160&rsqb;</number> An example for TAG assignment of instruction <highlight><bold>7</bold></highlight>&apos;s source <highlight><bold>1</bold></highlight> (I<highlight><bold>7</bold></highlight>S<highlight><bold>1</bold></highlight>) is shown in a flowchart in FIGS. <highlight><bold>6</bold></highlight>A-<highlight><bold>6</bold></highlight>B. TAL <highlight><bold>122</bold></highlight> first determines whether I<highlight><bold>7</bold></highlight>S<highlight><bold>1</bold></highlight> is register <highlight><bold>0</bold></highlight>, as shown at a conditional block <highlight><bold>602</bold></highlight>. If the first source operand for I<highlight><bold>7</bold></highlight> is register <highlight><bold>0</bold></highlight>, the TAG is set equal to zero, and the I<highlight><bold>7</bold></highlight>S<highlight><bold>1</bold></highlight>&apos;s INFO flag is set equal to one, as shown in a block <highlight><bold>604</bold></highlight>. If the first source operand (S<highlight><bold>1</bold></highlight>) for I<highlight><bold>7</bold></highlight> is not register <highlight><bold>0</bold></highlight>, TAL <highlight><bold>122</bold></highlight> then determines if I<highlight><bold>7</bold></highlight>S<highlight><bold>1</bold></highlight> is dependent on I<highlight><bold>6</bold></highlight>S/D, as shown at a conditional block <highlight><bold>606</bold></highlight>. If I<highlight><bold>7</bold></highlight>S<highlight><bold>1</bold></highlight> is dependent on I<highlight><bold>6</bold></highlight>S/D, flow then proceeds to a block <highlight><bold>610</bold></highlight> where I<highlight><bold>7</bold></highlight>S<highlight><bold>1</bold></highlight>&apos;s TAG is set equal to &lcub;<highlight><bold>1</bold></highlight>,DBLREG&lsqb;<highlight><bold>6</bold></highlight>&rsqb;,<highlight><bold>0</bold></highlight>,<highlight><bold>1</bold></highlight>,<highlight><bold>0</bold></highlight>,BKT&rcub; and I<highlight><bold>7</bold></highlight>S<highlight><bold>1</bold></highlight>&apos;s INFO flag is set equal to DONE&lsqb;<highlight><bold>6</bold></highlight>&rsqb;, as shown at a block <highlight><bold>610</bold></highlight>. If either of the condition tested at a conditional block <highlight><bold>606</bold></highlight> is not met, flow proceeds to conditional block <highlight><bold>612</bold></highlight> where TAL <highlight><bold>122</bold></highlight> determines if I<highlight><bold>7</bold></highlight>S<highlight><bold>1</bold></highlight> is dependent on I<highlight><bold>5</bold></highlight>S/D. If there is a dependency, flow then proceeds to block <highlight><bold>616</bold></highlight> where TAL <highlight><bold>122</bold></highlight> sets I<highlight><bold>7</bold></highlight>S<highlight><bold>1</bold></highlight>&apos;s TAG equal to &lcub;<highlight><bold>1</bold></highlight>,DBLREG&lsqb;<highlight><bold>5</bold></highlight>&rsqb;,<highlight><bold>0</bold></highlight>,<highlight><bold>0</bold></highlight>,<highlight><bold>1</bold></highlight>,BKT&rcub; and I<highlight><bold>7</bold></highlight>S<highlight><bold>1</bold></highlight>&apos;s INFO flag is set equal to DONE&lsqb;<highlight><bold>5</bold></highlight>&rsqb;. If the condition tested at block <highlight><bold>612</bold></highlight> is not met, flow proceeds to a block <highlight><bold>618</bold></highlight> where TAL <highlight><bold>122</bold></highlight> determines if I<highlight><bold>7</bold></highlight>S<highlight><bold>1</bold></highlight> is dependent on I<highlight><bold>4</bold></highlight>S/D. </paragraph>
<paragraph id="P-0161" lvl="0"><number>&lsqb;0161&rsqb;</number> As evident by inspection of the remaining sections of <cross-reference target="DRAWINGS">FIGS. 6A and 6B</cross-reference>, similar TAG determinations are made depending on whether I<highlight><bold>7</bold></highlight>S<highlight><bold>1</bold></highlight> is dependent on I<highlight><bold>4</bold></highlight>S/D, I<highlight><bold>3</bold></highlight>S/D, I<highlight><bold>2</bold></highlight>S/D, I<highlight><bold>1</bold></highlight>S/D and I<highlight><bold>0</bold></highlight>S/D, as shown at sections <highlight><bold>620</bold></highlight>, <highlight><bold>622</bold></highlight>, <highlight><bold>624</bold></highlight>, <highlight><bold>626</bold></highlight> and <highlight><bold>628</bold></highlight>, respectively. Finally, if instruction <highlight><bold>7</bold></highlight> is independent of instruction <highlight><bold>0</bold></highlight> or if all instructions in bucket <highlight><bold>1</bold></highlight> are independent of instruction <highlight><bold>0</bold></highlight> (i.e., if BKI<highlight><bold>1</bold></highlight>_NODEP&lsqb;<highlight><bold>0</bold></highlight>&rsqb;&equals;1), as tested at a conditional block <highlight><bold>630</bold></highlight>, the flow proceeds to block <highlight><bold>632</bold></highlight> where TAL <highlight><bold>122</bold></highlight> sets I<highlight><bold>7</bold></highlight>S<highlight><bold>1</bold></highlight>&apos;s TAG equal to &lcub;0, I<highlight><bold>7</bold></highlight>S<highlight><bold>1</bold></highlight>&rcub; and I<highlight><bold>7</bold></highlight>S<highlight><bold>1</bold></highlight>&apos;s INFO flag equal to 1. It should be noted for the above example that I<highlight><bold>7</bold></highlight>S<highlight><bold>1</bold></highlight> TAG signals are forwarded directly the register file port MUXes of register file <highlight><bold>117</bold></highlight>. The I<highlight><bold>7</bold></highlight>S<highlight><bold>1</bold></highlight> INFO signals are sent to Issuer <highlight><bold>118</bold></highlight> to tell it when I<highlight><bold>7</bold></highlight>&apos;s S<highlight><bold>1</bold></highlight> input is ready. </paragraph>
<paragraph id="P-0162" lvl="0"><number>&lsqb;0162&rsqb;</number> A representative block diagram of Issuer <highlight><bold>118</bold></highlight> is shown in <cross-reference target="DRAWINGS">FIG. 10</cross-reference>. In a preferred embodiment, Issuer <highlight><bold>118</bold></highlight> has one scanner block <highlight><bold>1002</bold></highlight> for each resource (functional unit) that has to be allocated. In this example, Issuer <highlight><bold>118</bold></highlight> has scanner blocks FU<highlight><bold>1</bold></highlight>, FU<highlight><bold>2</bold></highlight>, FU<highlight><bold>3</bold></highlight>, FU<highlight><bold>4</bold></highlight> through FUn. Requests for functional units are generated from instruction information by decoding logic (not shown) in a known manner, which are sent to scanners <highlight><bold>1002</bold></highlight> via bus <highlight><bold>123</bold></highlight>. Each scanner block <highlight><bold>1002</bold></highlight> scans from instruction I<highlight><bold>0</bold></highlight> to I<highlight><bold>7</bold></highlight> and selects the first request for the corresponding functional unit to be serviced during that cycle. </paragraph>
<paragraph id="P-0163" lvl="0"><number>&lsqb;0163&rsqb;</number> In the case of multiple register files (integer, floating and/or boolean), Issuer <highlight><bold>118</bold></highlight> is capable of issuing instructions having operands stored in different register files. For example, an ADD instruction may have a first operand from the floating point register file and a second operand from the integer register file. </paragraph>
<paragraph id="P-0164" lvl="0"><number>&lsqb;0164&rsqb;</number> Instructions with operands from different register files are typically given higher issue priority (i.e., they are issued first). This issuing technique conserves processor execution time and functional unit resources. </paragraph>
<paragraph id="P-0165" lvl="0"><number>&lsqb;0165&rsqb;</number> In a further embodiment in which IEU <highlight><bold>100</bold></highlight> may include two ALU&apos;s, ALU scanning becomes a bit more complicated. For speed reasons, one ALU scanner block scans from I<highlight><bold>0</bold></highlight> to I<highlight><bold>7</bold></highlight>, while the other scanner block scans from I<highlight><bold>7</bold></highlight> to I<highlight><bold>0</bold></highlight>. This is how two ALU requests are selected. With this scheme it is possible that an ALU instruction in bucket <highlight><bold>1</bold></highlight> will get issued before an ALU instruction in bucket <highlight><bold>0</bold></highlight>, while increasing scanning efficiency. </paragraph>
<paragraph id="P-0166" lvl="0"><number>&lsqb;0166&rsqb;</number> Scanner outputs <highlight><bold>1003</bold></highlight> are selected by MUXing logic <highlight><bold>1004</bold></highlight>. A set of SELect inputs <highlight><bold>1006</bold></highlight> for MUX <highlight><bold>1004</bold></highlight> receive three 8-bit vectors (one for each operand) from TAL <highlight><bold>122</bold></highlight> via bus <highlight><bold>120</bold></highlight>. The vectors indicate which of the eight instructions have no dependencies and are ready to be issued. Issuer <highlight><bold>118</bold></highlight> must wait for this information before it can start to issue any instructions. Issuer <highlight><bold>118</bold></highlight> monitors these vectors and when all three go high for a particular instruction, Issuer <highlight><bold>118</bold></highlight> knows that the inputs for that instruction are ready. Once the necessary functional unit is ready, the issuer can issue that instruction and send select signals to the register file port MUXes to pass the corresponding instructions outputs to register file <highlight><bold>117</bold></highlight>. </paragraph>
<paragraph id="P-0167" lvl="0"><number>&lsqb;0167&rsqb;</number> In a preferred embodiment of the present invention, after Issuer <highlight><bold>118</bold></highlight> is done it provides two 8-bit vectors per register file back to RRC <highlight><bold>112</bold></highlight> via MUXOUTputs <highlight><bold>1008</bold></highlight> to bus <highlight><bold>121</bold></highlight>. These vectors indicate which instructions are issued this cycle, are used a select lines for RPMs <highlight><bold>124</bold></highlight>. </paragraph>
<paragraph id="P-0168" lvl="0"><number>&lsqb;0168&rsqb;</number> The maximum number of instructions that can be issued simultaneously for each register file is restricted by the number of register file read ports available. A data dependency with a previous uncompleted instruction may prevent an instruction from being issued. In addition, an instruction may be prevented from being issued if the necessary functional unit is allocated to another instruction. </paragraph>
<paragraph id="P-0169" lvl="0"><number>&lsqb;0169&rsqb;</number> Several instructions, such as load immediate instructions, Boolean operations and relative conditional branches, may be issued independently, because they may not require resources other than register file read ports or they may potentially have no dependencies. </paragraph>
<paragraph id="P-0170" lvl="0"><number>&lsqb;0170&rsqb;</number> The last section of RRC <highlight><bold>112</bold></highlight> is the register file port MUX (RPM) section <highlight><bold>124</bold></highlight>. The function of RPMs <highlight><bold>124</bold></highlight> is to provide a way for Issuer <highlight><bold>118</bold></highlight> to get data out ofregister files <highlight><bold>117</bold></highlight> for each instruction to use. RPMs <highlight><bold>124</bold></highlight> receive tag information via bus <highlight><bold>126</bold></highlight>, and the select lines for RPMs <highlight><bold>124</bold></highlight> come from Issuer <highlight><bold>118</bold></highlight> via a bus <highlight><bold>121</bold></highlight> and also from the computer&apos;s IEU control logic. The selected TAGs comprise read addresses that are sent to a predetermined set of ports <highlight><bold>119</bold></highlight> of register file <highlight><bold>117</bold></highlight> using bus <highlight><bold>128</bold></highlight>. </paragraph>
<paragraph id="P-0171" lvl="0"><number>&lsqb;0171&rsqb;</number> The number and design of RPMs <highlight><bold>124</bold></highlight> depend on the number of register files and the number of ports on each register file. One embodiment of RPMs <highlight><bold>124</bold></highlight> is shown in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>. In this embodiment, RPMs <highlight><bold>124</bold></highlight> comprises 3 register port file MUXes <highlight><bold>402</bold></highlight>,<highlight><bold>404</bold></highlight> and <highlight><bold>406</bold></highlight>. MUX <highlight><bold>402</bold></highlight> receives as inputs the TAGs of instructions <highlight><bold>0</bold></highlight>-<highlight><bold>7</bold></highlight> corresponding to the source register field S<highlight><bold>1</bold></highlight> that are generated by TAL <highlight><bold>122</bold></highlight>. MUX <highlight><bold>404</bold></highlight> receives as inputs the TAGs of instructions <highlight><bold>0</bold></highlight>-<highlight><bold>7</bold></highlight> corresponding to the source register field S<highlight><bold>2</bold></highlight> that are generated by TAL <highlight><bold>122</bold></highlight>. MUX <highlight><bold>406</bold></highlight> receives as inputs the TAGs of instructions <highlight><bold>0</bold></highlight>-<highlight><bold>7</bold></highlight> corresponding to the source/destination register field S/ID that are generated by TAL <highlight><bold>122</bold></highlight>. The outputs of MUXes <highlight><bold>402</bold></highlight>, <highlight><bold>404</bold></highlight> and <highlight><bold>406</bold></highlight> are connected to the read addresses ports of register file <highlight><bold>117</bold></highlight> via bus <highlight><bold>128</bold></highlight>. </paragraph>
<paragraph id="P-0172" lvl="0"><number>&lsqb;0172&rsqb;</number> RRC <highlight><bold>112</bold></highlight> and Issuer <highlight><bold>118</bold></highlight> allow the processor to execute instructions simultaneously and out of program order. An IEU for use with the present invention is disclosed in commonly owned, co-pending application Ser. No. 07/817,810 the disclosure of which is incorporated herein by reference. </paragraph>
<paragraph id="P-0173" lvl="0"><number>&lsqb;0173&rsqb;</number> While various embodiments of the present invention have been described above, it should be understood that they have been presented by way of example, and not limitation. Thus the breadth and scope ofthe present invention should not be limited by any of the above-described exemplary embodiments, but should be defined only in accordance with the following claims and their equivalents. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A register renaming system for out-of-order execution of a set of reduced instruction set computer instructions having addressable source and destination register fields, adapted for use in a computer having an instruction execution unit with a register file accessed by read address ports and for storing instruction operands, the system comprising: 
<claim-text>(a) data dependance check means for determining data dependencies between the instructions; </claim-text>
<claim-text>(b) tag assignment means for generating one or more tags to specify the location of operands, based on said data dependencies determined by said data dependance check means; and </claim-text>
<claim-text>(c) register file port means for selecting said tags generated by said tag assignment means and passing said tags onto the read address ports of the register file for storing execution results.</claim-text>
</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>1</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005260A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005260A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005260A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005260A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005260A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005260A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030005260A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030005260A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030005260A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00009">
<image id="EMI-D00009" file="US20030005260A1-20030102-D00009.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
