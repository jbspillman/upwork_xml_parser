<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005418A1-20030102-D00000.TIF SYSTEM "US20030005418A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005418A1-20030102-D00001.TIF SYSTEM "US20030005418A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005418A1-20030102-D00002.TIF SYSTEM "US20030005418A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005418A1-20030102-D00003.TIF SYSTEM "US20030005418A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005418A1-20030102-D00004.TIF SYSTEM "US20030005418A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005418A1-20030102-D00005.TIF SYSTEM "US20030005418A1-20030102-D00005.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005418</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10098861</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20020315</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F009/45</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>717</class>
<subclass>140000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Method for allocation, initialization and access of aggregate data types for architectures with differing memory granularity</title-of-invention>
</technical-information>
<continuity-data>
<non-provisional-of-provisional>
<document-id>
<doc-number>60277114</doc-number>
<document-date>20010319</document-date>
<country-code>US</country-code>
</document-id>
</non-provisional-of-provisional>
</continuity-data>
<inventors>
<first-named-inventor>
<name>
<given-name>C.</given-name>
<family-name>Sridhar</family-name>
</name>
<residence>
<residence-non-us>
<city>Bangalore</city>
<country-code>IN</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Shashi</given-name>
<middle-name>Bhushan</middle-name>
<family-name>Kumar</family-name>
</name>
<residence>
<residence-non-us>
<city>Bangalore</city>
<country-code>IN</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>TEXAS INSTRUMENTS INCORPORATED</name-1>
<name-2></name-2>
<address>
<address-1>P O BOX 655474, M/S 3999</address-1>
<city>DALLAS</city>
<state>TX</state>
<postalcode>75265</postalcode>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">The present invention provides methods for facilitating the adaptation of shared data structures created in assembly language to differing memory models, compiler alignment constraints, and hardware alignment constraints. The use of these methods permits the assembler to create shared data structures that are transparently adapted to memory alignment differences introduced by the differing memory models and alignment constraints. </paragraph>
</subdoc-abstract>
<subdoc-description>
<cross-reference-to-related-applications>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> This application is related to and claims priority under 35 USC &sect;119 (e)(1) to Provisional Application Serial No. 60/277,114, (TI-32563) Portable Technique for Allocation, Initialization and Access of Aggregate Data Type for DSP Architecture With Mixed Memory Granularity filed on Mar. 19, 2001.</paragraph>
</cross-reference-to-related-applications>
<summary-of-invention>
<section>
<heading lvl="1">FIELD OF THE INVENTION </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> This invention generally relates to embedded software applications, and more specifically to embedded software applications combining source code written in a high level language with source code written in assembly language. </paragraph>
</section>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> Embedded applications are typically developed using a composition of high level language, e.g., the C programming language, and low level assembly language. The high level language provides abstraction and portability and is best suited to represent target independent modules of the application. Assembly language is used to develop low level, target dependent functionality, e.g., device drivers, and where optimal processor performance is desired. In such applications, it is common and desirable for the modules written in the high level language and the assembly language modules to share data structures. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> The shared data structures may be allocated and optionally initialized by either the high level language compiler in response to specifications in the high level language source code or by the assembler in response to specifications in the assembly language source code. In the latter case, the data structures must be created to conform to compiler conventions for alignment of such structures in memory and the memory length of primitive data types. These compiler conventions are based on the memory models supported by the target hardware. For example, the TMS320C55 C compiler available from Texas Instruments Incorporated supports both a small and a large memory model, wherein the length of a data pointer is 16 bits in the small memory model and 23 bits in the large memory model. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> Finally, the architecture of the target hardware of the application may impose memory alignment requirements. For example, the architecture may require that all code pointers be located at even word addresses, regardless of the actual length of the pointer. And, the architecture may provide support for both 16-bit data addresses and 23-bit data addresses where a 16-bit data address may be located at either an even or odd word address while a 23-bit data address must be located at an even word address. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> Therefore, there are a variety of combinations or sets of memory alignment constraints attributable to differing memory models, compiler alignment constraints, and hardware alignment constraints that may be imposed on a data structure used by both high level language and assembly code. Current approaches to handling these combinatorial factors have significant development and maintenance costs when an embedded application is targeted for multiple architectures with differing memory models. Multiple possible sets of memory alignment constraints are possible in this situation. While the high level language modules can simply be recompiled with a compiler target to the desired memory model and hardware architecture, the shared data structures in the assemble language modules must be modified for each new set of memory alignment constraints introduced. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> These modifications to support the new architectures will likely involve a significant re-write of the shared data structures. The programmer has to re-analyze the structures in view of the new memory alignment requirements and determine the appropriate alignment and offset of each element. Any changes to the data structures must be done manually by the programmer, creating a potential for the introduction of errors. Also, multiple versions of the data structures are created, posing future maintenance issues. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> The present invention provides methods for facilitating the adaptation of shared data structures created in assembly language to differing memory models, compiler alignment constraints, and hardware alignment constraints, across the same as well as different hardware architectures. The use of these methods permits the assembler to create shared data structures that are transparently adapted to memory alignment differences introduced by the differing memory models and alignment constraints. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> Methods are provided for creating a data structure in assembly language that conforms to the semantics of an analogous data structure in a high level language wherein the method transparently adapts the data structure to a selected set of memory alignment constraints. One such method comprises defining a set of primitive data types that have a one-to-one correspondence to analogous primitive data types in the high level language such that the definition of each primitive data type is transparently adapted to the selected set of memory alignment constraints; defining a template for the data structure wherein each element of the data structure is either selected from the set of primitive data types or is a substructure that is transparently adapted to the selected set of memory alignment constraints and the data structure length is transparently adapted to the selected set of memory alignment constraints; allocating memory for the data structure based on the template definition such that the allocated memory transparently conforms to the selected set of memory alignment constraints; and creating an initialization record for the data structure that is transparently adapted to the selected set of memory alignment constraints. </paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> Particular embodiments in accordance with the invention will now be described, by way of example only, and with reference to the accompanying drawings in which like reference signs are used to denote like parts unless otherwise stated, and in which: </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> presents a flowgraph of a method for creating a data structure in assembly language that conforms to the semantics of an analogous data structure in a high level language such that the data structure is transparently adapted to a selected set of memory alignment constraints; </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2A</cross-reference> is a flowgraph of one possible method for defining a template for the data structure of <cross-reference target="DRAWINGS">FIG. 1</cross-reference>; </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2B</cross-reference> is a flowgraph of an improved version of the method of <cross-reference target="DRAWINGS">FIG. 2A</cross-reference>; </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a logical representation of a pipe data structure specified in assembly language source code contained in Table 2 that illustrates a method for creating a data structure in assembly language that conforms to the semantics of an analogous data structure in a high level language such that the data structure is transparently adapted to a selected set of memory alignment constraints; </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a flowgraph of a method for allocating memory for the data structure of <cross-reference target="DRAWINGS">FIG. 1</cross-reference> as defined by the template of <cross-reference target="DRAWINGS">FIG. 2A</cross-reference> or <cross-reference target="DRAWINGS">FIG. 2B</cross-reference>; and </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a flowgraph illustrating a method for creating the initialization record for the data structure of <cross-reference target="DRAWINGS">FIG. 1</cross-reference>.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> Corresponding numerals and symbols in the different figures and tables refer to corresponding parts unless otherwise indicated. </paragraph>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF EMBODIMENTS OF THE INVENTION </heading>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> Methods for facilitating the adaptation of shared data structures created in assembly language to differing memory models, compiler alignment constraints, and hardware alignment constraints have now been developed by the present inventors. The use of these methods permits the assembler to create shared data structures that are transparently adapted to alignment differences introduced by the differing memory models and alignment constraints. These methods are described below assuming that the high level language used is C and that the target memory models are a small model with a 16-bit address space for data and a 24 bit address space for code and a large model with a 23-bit address space for data and a 24 bit address space for code. The architecture of the target processor requires that all code pointers and all data pointers larger than 16 bits be located on even word boundaries in memory. 16-bit data pointers may be located on even or odd word boundaries in memory. Adaptation of these methods to other high level languages, such as C&plus;&plus; or Java, other memory models, and/or other processor architectures is obvious to one skilled in the art. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> The examples provided in the tables and figures assume that the target processor is a Texas Instruments Incorporated TMS320C55x with a corresponding assembler and C compiler. The assembly language for this processor&apos;s assembler is documented in the &ldquo;TMX320C55x Assembly Language Tools User&apos;s Guide&rdquo; available at http://www-s.ti.com/sc/psheets/spru280d/spru280d.pdf. The assembler directives used in the examples are explained in more detail in Appendix A. The C compiler for this processor is documented in the &ldquo;TMX320C55x Optimizing C/C&plus;&plus; Compiler Users Guide&rdquo; available at http://www-s.ti.com/sc/psheets/spru281c/spru281c.pdf. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> presents a flowgraph of a method for creating a data structure in assembly language that conforms to the semantics of an analogous data structure in a high level language such that the data structure is transparently adapted to a selected set of memory alignment constraints. Creating the data structure entails defining the data structure, allocating space for it in memory, and initializing the contents of each element. As the data structure is created, adjustments are made as needed to the overall length of the structure and to the alignment of the data structure and its elements to conform to the selected set of memory alignment constraints. In addition, the initialization record for the data structure is adapted to allow for these adjustments. This transparent adaptation occurs without requiring any changes in the source code defining the data structure. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> The TMS320C55x C compiler requires that any data structure that contains elements having alignment constraints must begin at an even memory address and be of even length. An element in a data structure has a memory alignment constraint if it must be placed at an even address or offset in memory but its relative location in the data structure would cause it to be placed at an odd address or offset due to the placement and length of previous elements. The TMS320C55x architecture mandates that 32 bit data be placed at an even address. In the small memory model, a code pointer is 32-bits and thus has an alignment constraint requiring it to be placed at an even address within a data structure while a data pointer is limited to 16-bits and has no alignment constraint. In the large memory model, both code pointers and data pointers have alignment constraints and must be placed at even addresses within a data structure. Any other data elements greater than 16-bits in length will also have alignment constraints in either memory model. Furthermore, if an element of a data structure is another data structure, generically referred to as a substructure, that substructure may also have an alignment constraint due to its element composition. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> In step <highlight><bold>1001</bold></highlight>, a set of primitive data types having a one-to-one correspondence to analogous primitive data types in the high level language is defined. The definition of each primitive data type is transparently adapted to the selected set of memory alignment constraints. The C programming language includes several primitive data types but for illustration purposes, only the primitive data types for an integer, a code pointer, and a data pointer will be considered. An integer, which has the mnemonic Int, is a single memory word in length. A code pointer, which has the mnemonic CodePtr, is a long word in length. In the small memory model, a data pointer, which has the mnemonic DataPtr, is a single memory word in length. In the large memory model, a DataPtr is a long word in length. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> In the embodiment presented in Table 1, the transparent adaptation of these primitive data types to the selected memory model is illustrated in lines 8-34. If the large memory model is selected when the source code is assembled, a DataPtr is defined to be a long memory word. Otherwise, it will be defined to be a single memory word. A CodePtr is defined to be a long memory word and an Int is defined to be a single memory word as the specified memory model does not affect their length. The .long assembler directive, as used in lines 9, 10, and 23, causes its 32-bit value to be placed at an even memory address. The .word assembler directive, as used in line 22 to define a DataPtr in the small memory model, causes its 16-bit value to be placed at the next consecutive memory location as there is no alignment constraint for such a value. As a result of this definition process, the use of the mnemonics elsewhere in the assembly language source code to define elements of a data structure will cause a corresponding amount of memory space to be reserved for the element and that any corresponding alignment constraint be enforced. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> In step <highlight><bold>1002</bold></highlight>, a template for the data structure is defined. Each element of the data structure is defined to be either a primitive data type or a substructure. If an element is a substructure, its memory alignment is transparently adapted as necessitated by the selected set of memory alignment constraints. The length of the data structure is also transparently adapted to conform to the selected set of memory alignment constraints. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2A</cross-reference> is a flowgraph of one possible method for defining a template for the data structure. The type of an element is determined at step <highlight><bold>2001</bold></highlight>. If it is a primitive data type, at step <highlight><bold>2002</bold></highlight> the assembler increases the length of the template by the length of the primitive data type, and places the element within the data structure as required by its alignment constraint. If the element is not a primitive data type, then it is a substructure. In step <highlight><bold>2003</bold></highlight>, the length of the template is increased to include the length of the substructure and the substructure is started at an even offset if it has an alignment constraint. If placing the substructure at an aligned boundary creates padding in the data structure, the length of the template is also increased to accommodate the space for that padding. As indicated by step <highlight><bold>2004</bold></highlight>, the definition of the template continues until each element has been considered. At step <highlight><bold>2005</bold></highlight>, if the data structure itself had an alignment constraint, the length of the template is increased to include any padding required at the end of the data structure to make its overall length even. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2B</cross-reference> is a flowgraph of an improved version of the method of <cross-reference target="DRAWINGS">FIG. 2A</cross-reference>. In this method, step <highlight><bold>2000</bold></highlight> is added to define an alignment flag for the data structure. This flag is uniquely associated with the data structure and is given a value to indicate whether or not the data structure has an alignment constraint. Substructures will always have such an alignment flag as they are also data structures. In the steps that consider whether the data structure or a substructure has an alignment constraint, the appropriate alignment flag is checked to make a determination. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> Table 2 contains assembly language source code illustrating the use of an embodiment of the invention. This source code uses the constructs and macros of the embodiment contained in Table 1 to specify the creation of a pipe data structure. <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a logical representation of the pipe data structure created by this source code. As this figure illustrates, the pipe data structure is composed of main data structure <highlight><bold>3001</bold></highlight> and several substructures <highlight><bold>3002</bold></highlight>-<highlight><bold>3007</bold></highlight> that are linked to main data structure <highlight><bold>3001</bold></highlight> by pointers <highlight><bold>3011</bold></highlight>-<highlight><bold>3012</bold></highlight>. The source code in Table 2 specifies the entire data structure using an embodiment of the invention. A discussion of the portion of the source code specifying the main data structure <highlight><bold>3001</bold></highlight> is sufficient to allow one skilled in the art to determine how the method is used to create additional substructures <highlight><bold>3002</bold></highlight>-<highlight><bold>3007</bold></highlight>. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> The template for main data structure <highlight><bold>3001</bold></highlight>, named PIP_Obj, is defined at lines 66-73 of Table 2. Its corresponding alignment flag, isPipAligned, is defined at line 36. The PIP_Obj template is defined by the use of two assembler directives, .struct and .endstruct. The .struct directive assigns offsets to the elements of the data structure. It does not allocate memory; it merely creates a symbolic template that can be used repeatedly. Following the .struct directive, each element of the template is defined using the primitive data types defined in lines 8-34 of Table 1 or other appropriate assembler directives. At line 67, the first element of the template is declared to be an integer using the Int primitive data type. This element is placed at offset 0 within the data structure. The assembler increases the length of structure by 1 as dictated by the length of the element. The next element will begin at an offset of 1. The second element of the template is defined at line 69. This element is actually a substructure and is defined using the .tag assembler directive. The .tag directive essentially causes the template definition of the designated substructure to be inserted in the PIP_Obj template at this point. The designated substructure, PIP_Sock, is defined at lines 47-60 in Table 2. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> Because PIP_Sock is a substructure and it has an alignment constraint per its alignment flag defined at line 35, it must always be placed at an even offset. To ensure that this constraint is honored, its use in the parent structure is preceded by a pad definition at line 68 that will be conditionally applied. The pad is defined using the .align assembler directive. The .align directive forces an alignment of the element to the next memory boundary as specified by the value of the parameter. A hole is created if the current alignment is not on the correct boundary. In this instance, the parameter for the .align directive is the alignment flag, isPipsockAligned, defined at line 35. Because the value of this alignment flag is 2, the .align directive will force the definition of the PIP_Sock substructure to start at an even offset. As the current offset within the structure is 1, the align construct creates a hole of length 1 and places the substructure at offset 2. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> The third element of the template is defined at line 71. This element is also a PIP_Sock substructure and is preceded by a conditional pad at line 70. Because the second element was a substructure, its template definition forced it to be of even length. Therefore, because it was placed an even offset within the data structure, the third element will automatically be placed an even offset. The conditional pad at line 70 will not introduce a hole in the data structure. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> As all elements of the template have now been specified, the template is terminated at line 60 with an .endstruct directive. Because all data structures that have alignment constraints must have an even length, another conditional pad is inserted at line 59. If the current offset is odd, this directive will create a hole and make the current offset even. Since this is the end of the template, the current offset would be the length of the structure. In this particular instance, the directive will have no effect as the ending location of the template is on an even offset. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> Referring back to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, at step <highlight><bold>1003</bold></highlight> memory is allocated for the data structure. This allocation is derived from the template defined for the data structure and is transparently adapted to the selected set of memory constraints. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a flowgraph of a method for allocating memory for the data structure as defined by the template of the data structure. At step <highlight><bold>4001</bold></highlight>, a determination is made as to whether the data structure has alignment constraints. If it does not, the ensuing steps are skipped and step <highlight><bold>4004</bold></highlight> is executed. If it does have alignment constraints, a check is made at step <highlight><bold>4002</bold></highlight> to determine if the overall length of the data structure is odd. If it is, the length is increased to the next even number at step <highlight><bold>4003</bold></highlight>. Otherwise, step <highlight><bold>4003</bold></highlight> is skipped. At step <highlight><bold>4004</bold></highlight>, the required amount of memory space for the data structure is allocated. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> An embodiment of an allocation method is presented in the assembly language source code in Table 1. Lines 289-351 contain the definition of a memory allocation macro, C55_allocateObject. This macro takes as its parameters, among other things, the alignment flag for the data structure, the symbolic name to be given to this instance of the data structure, and the length of the data structure. This macro allocates the required amount of memory and returns the address where the memory is allocated as the value of the symbolic name. At line 313, the alignment flag is checked. If the alignment flag value indicates that the data structure to be allocated must be aligned, then the overall length of the data structure must be an even number, and it must be located at even address. At lines 314-316, the length of the data structure is increased to an even length if necessary. At line 318, the memory for the data structure is actually allocated. This allocation is accomplished by the .usect assembler directive. This directive reserves the requested amount of memory space and, if required, forces the initial address of the reserved space to occur at an aligned memory location. The alignment flag for the data structure is given to this directive as a parameter to be used to make the alignment determination. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> Lines 137-293 of Table 2 present the source code for a macro that is used to create an instance of the previously discussed PIP_Obj. At line 182, the macro C55_allocateObject is called to allocate the required memory space. Note that PIP_SIZE is defined to be the length of the PIP_Obj template at line 128. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> Referring back to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, at step <highlight><bold>1004</bold></highlight> an initialization record is created for the data structure. This initialization record contains the values that are to be inserted in the initial version of the data structure created when the application is executed. This initialization record will typically be created in an initialization memory that is accessed when execution begins. The length and contents of the record are transparently adapted as required to conform to the selected set of memory constraints as it is created. This transparent adaptation comprises ensuring that all values in the initialization record are aligned in the same manner as the elements in the data structure to be initialized by the record. In addition, any holes in the data structure created as a result of matching the alignment constraints may be filled with a predetermined value. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a flowgraph illustrating a method for creating the initialization record for a data structure such that the length and contents of the record are transparently adapted as required to conform to the selected set of memory constraints. At step <highlight><bold>5001</bold></highlight>, a header for the initialization record is created. This header will typically contain information about the length and the address of the data structure. At step <highlight><bold>5002</bold></highlight>, a hole is inserted following the header if required to make the first value in the initialization record occur at a memory alignment conforming to the selected set of memory alignment constraints. The, the value for each element of the data structure is stored in the initialization record. As exemplified by step <highlight><bold>5003</bold></highlight>, if the next element of the data structure is a primitive data type, at step <highlight><bold>5005</bold></highlight> its value is inserted in the initialization record at the memory alignment required by the selected set of memory alignment constraints and a hole is created if required. If the next element is a substructure, the value of its first element must be placed in the initialization record in accordance with any alignment constraints indicated by the alignment flag of the substructure. If necessary, a hole in the initialization record is created to permit the correct alignment. The values of the substructure elements are then recorded in the initialization record in the same manner as for the parent data structure. That is, steps <highlight><bold>5003</bold></highlight> through <highlight><bold>5007</bold></highlight> are performed for the substructure elements. This process of inserting values in the initialization continues until the value for the last element of the data structure has been recorded, as shown at step <highlight><bold>5006</bold></highlight>. Finally, at step <highlight><bold>5007</bold></highlight>, a final hole is inserted if required to make the length of the initialization record even. This requirement will be determined from the alignment constraints indicated by the alignment flag associated with the data structure. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> An embodiment of the method of <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is presented in the assembly language source code in Table 1 and Table 2. First, in Table 1, are macros used to create an initialization record. The macro C55_cinitHeader at lines 40-80 is called to create a header record containing length of the data structure and its memory address. This macro also initializes a variable representing the current offset of an element value within the initialization record at line 79. This variable will be incremented by all subsequent macros used in the process of inserting values in the initialization record. The macros C55_cinitBegin, at lines 114-136, and C55_cinitEnd, at lines 138-159, are called at the beginning and the end, respectively, of the insertion of the initialization values into the initialization record for the data structure and for any substructures within that data structure. The C55_cinitBegin macro calls the C55_alignIfRequired macro at line 135. This macro, defined at lines 82-111, checks the alignment flag associated with the data structure at line 102. If alignment at an even memory address is required, then the current element value offset within the initialization record is checked. If this offset is odd, a predetermined value is inserted into the initialization record to fill the hole that is created by this alignment constraint and the offset is incremented to the next even boundary. The C55_cinitEnd macro takes the alignment flag of the data structure as an argument. If the value of the alignment flag indicates that the data structure must be of even length, the macro checks the value of the offset. If the offset is odd, a hole is created at the end of the initialization record to make its length even and a predetermined value is placed in that hole. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> The macros that create the initialization values for each of the primitive data types are at lines 161-287. Each takes as its argument the value to be inserted in the initialization record and each macro detects if a hole is created by the alignment constraints of the primitive data type, places a predetermined value in that hole and place n initialization value for primitive data type in the initialization record. Each macro increases the offset variable by the length of the primitive type and length of the hole, if created. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> The use of these macros to create an initialization record is illustrated in Table 2. At line 190, C55_cinitHeader is called to create the header record for a PIP_Obj data structure. At line 216, C55_cinitBegin is called to indicate the beginning of the value portion of the initialization record. This macro, as indicated above, will cause an alignment adjustment if required by the memory alignment constraints indicated by the PIP_OBJ alignment flag by creating a hole and filling it with a predetermined value. At this point, the offset is zero so there is no need to change the memory alignment. At line 22, the value for the first element of the PIP_Obj data structure is inserted in the initialization record. This element is an Int primitive data type so the corresponding macro, C55_cinitInt, is called to insert the integer value in the initialization record. This macro would also increase the offset variable to 1. The next two elements of the data structure are PIP_Sock substructures. In this embodiment, each substructure provides its own macro for inserting its values into the initialization record of the parent data structure. The initialization macro for the PIP_Sock substructure, PIPSOCK_cinitObj is located at lines 235-349. Note that this macro uses the initialization macros provided in Table 1. The memory alignment constraints indicated by the associated alignment flag isPipSockAligned will be followed as this portion of the initialization record is created. This macro is called at lines 224 and 231 in Table 2 to insert the initialization values for the two substructures. Finally, at line 233, c55_cinitEnd is called to complete the initialization record for PIP_Obj. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> While the invention has been described with reference to illustrative embodiments, this description is not intended to be construed in a limiting sense. Various other embodiments of the invention will be apparent to persons skilled in the art upon reference to this description. It is therefore contemplated that the appended claims will cover any such modifications of the embodiments as fall within the true scope and spirit of the invention.  
<table-cwu id="TABLE-US-00001">
<number>1</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="238PT" align="left"/>
<thead>
<row>
<entry namest="1" nameend="2" align="center">TABLE 1</entry>
</row>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>1</entry>
<entry>; &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals; cinit.h55&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;</entry>
</row>
<row>
<entry>2</entry>
<entry>;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry>4</entry>
<entry>.if($isdefed(&ldquo;CTNIT_&rdquo;) &equals; 0) ; prevent multiple includes of this file</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="238PT" align="left"/>
<tbody valign="top">
<row>
<entry>5</entry>
<entry>CINIT_ .set 1</entry>
</row>
<row>
<entry>6</entry>
<entry>.include &ldquo;chk.h55&rdquo;</entry>
</row>
<row>
<entry>7</entry>
<entry>; Define DataPtr, CodePtr, Int</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry>8</entry>
<entry>.if($isdefed(&ldquo;_large_model&rdquo;))</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="98PT" align="left"/>
<colspec colname="2" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry>9</entry>
<entry>.asg .long, DataPtr</entry>
</row>
<row>
<entry>10</entry>
<entry>.asg .long, CodePtr</entry>
</row>
<row>
<entry>11</entry>
<entry>.asg .word, Int</entry>
</row>
<row>
<entry>12</entry>
<entry>.asg .long, Long</entry>
</row>
<row>
<entry>13</entry>
<entry>.asg DataPtr, Arg</entry>
</row>
<row>
<entry>14</entry>
<entry>.asg DataPtr, Args</entry>
</row>
<row>
<entry>15</entry>
<entry>.eval 2, DATAPTRSIZE</entry>
</row>
<row>
<entry>16</entry>
<entry>.eval 1, INTSIZE</entry>
</row>
<row>
<entry>17</entry>
<entry>.eval 2, CODEPTRSIZE</entry>
</row>
<row>
<entry>18</entry>
<entry>.eval 2, ARGSIZE</entry>
</row>
<row>
<entry>19</entry>
<entry>.asg 2, isDataPtrAligned</entry>
</row>
<row>
<entry>20</entry>
<entry>.asg 1, isIntAligned</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry>21</entry>
<entry>.else</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="98PT" align="left"/>
<colspec colname="2" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry>22</entry>
<entry>.asg .word, DataPtr</entry>
</row>
<row>
<entry>23</entry>
<entry>.asg .long, CodePtr</entry>
</row>
<row>
<entry>24</entry>
<entry>.asg .word, Int</entry>
</row>
<row>
<entry>25</entry>
<entry>.asg .long, Long</entry>
</row>
<row>
<entry>26</entry>
<entry>.asg DataPtr, Arg</entry>
</row>
<row>
<entry>27</entry>
<entry>.asg DataPtr, Args</entry>
</row>
<row>
<entry>28</entry>
<entry>.eval 1, DATAPTRSIZE</entry>
</row>
<row>
<entry>29</entry>
<entry>.eval 1, INTSIZE</entry>
</row>
<row>
<entry>30</entry>
<entry>.eval 2, CODEPTRSIZE</entry>
</row>
<row>
<entry>31</entry>
<entry>.eval 1, ARGSIZE</entry>
</row>
<row>
<entry>32</entry>
<entry>.asg 1, isDataPtrAligned</entry>
</row>
<row>
<entry>33</entry>
<entry>.asg 1, isIntAligned</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry>34</entry>
<entry>endif</entry>
</row>
<row>
<entry>35</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="28PT" align="left"/>
<colspec colname="4" colwidth="154PT" align="left"/>
<tbody valign="top">
<row>
<entry>36</entry>
<entry>DATAPAGE</entry>
<entry>.set</entry>
<entry>0</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="21PT" align="left"/>
<colspec colname="4" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry>37</entry>
<entry>CINITALIGN</entry>
<entry>.set</entry>
<entry>1</entry>
</row>
<row>
<entry>38</entry>
</row>
<row>
<entry>39</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="238PT" align="left"/>
<tbody valign="top">
<row>
<entry>40</entry>
<entry>;&num; &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals; C55_cinitHeader&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;</entry>
</row>
<row>
<entry>41</entry>
<entry>; Create the header section of cinit records.</entry>
</row>
<row>
<entry>42</entry>
</row>
<row>
<entry>43</entry>
<entry>; Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="77PT" align="left"/>
<colspec colname="3" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry>44</entry>
<entry>; cinitAlign:</entry>
<entry>Alignment constraints for cinit record</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="238PT" align="left"/>
<tbody valign="top">
<row>
<entry>45</entry>
<entry>; isObjAligned: Alignment constraint for the object. This indicates</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="77PT" align="left"/>
<colspec colname="3" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry>46</entry>
<entry>;</entry>
<entry>if objects members or any of its sub objects have</entry>
</row>
<row>
<entry>47</entry>
<entry>;</entry>
<entry>members that have alignment constraints.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry>48</entry>
<entry>; objAddr:</entry>
<entry>Is the addr of the object</entry>
</row>
<row>
<entry>49</entry>
<entry>; objSize:</entry>
<entry>It is the size of the object</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="238PT" align="left"/>
<tbody valign="top">
<row>
<entry>50</entry>
<entry>; page: Is the page where the object exists.</entry>
</row>
<row>
<entry>51</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>52</entry>
<entry>;&num; Preconditions:</entry>
</row>
<row>
<entry>53</entry>
<entry>;&num; &emsp;none</entry>
</row>
<row>
<entry>54</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>55</entry>
<entry>;&num; Postconditions:</entry>
</row>
<row>
<entry>56</entry>
<entry>;&num; offset &equals; 0</entry>
</row>
<row>
<entry>57</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>58</entry>
<entry>;&num; Constraints and Calling Environment:</entry>
</row>
<row>
<entry>59</entry>
<entry>;&num; The macro must be called for creating cinit records only.</entry>
</row>
<row>
<entry>60</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry>61</entry>
<entry>.asg &ldquo;:C55_cinitHeader$regs&rdquo;, C55_cinitHeader$regs</entry>
</row>
<row>
<entry>62</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="238PT" align="left"/>
<tbody valign="top">
<row>
<entry>63</entry>
<entry>C55_cinitHeader .macro cinitAlign, isObjAligned, objAddr, objSize, page</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry>64</entry>
<entry>CHK_nargs &ldquo;CINIT&rdquo;, page</entry>
</row>
<row>
<entry>65</entry>
<entry>.eval :objSize:, cinitSize ; This is the size of</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="147PT" align="left"/>
<colspec colname="2" colwidth="112PT" align="left"/>
<tbody valign="top">
<row>
<entry>66</entry>
<entry>; cinit records.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="84PT" align="left"/>
<colspec colname="3" colwidth="126PT" align="left"/>
<tbody valign="top">
<row>
<entry>67</entry>
<entry>if (isObjAligned &equals; 2) ;</entry>
<entry>Does the Obj require alignment</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="63PT" align="left"/>
<colspec colname="2" colwidth="70PT" align="left"/>
<colspec colname="3" colwidth="126PT" align="left"/>
<tbody valign="top">
<row>
<entry>68</entry>
<entry>.if(:objSize: &amp; 0&times;1)</entry>
<entry>; if the cinit size is odd</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="98PT" align="left"/>
<colspec colname="2" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry>69</entry>
<entry>.eval cinitSize &plus; 1, cinitSize ; Make it even</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="63PT" align="left"/>
<colspec colname="2" colwidth="196PT" align="left"/>
<tbody valign="top">
<row>
<entry>70</entry>
<entry>.endif</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry>72</entry>
<entry>.endif</entry>
</row>
<row>
<entry>73</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="77PT" align="left"/>
<colspec colname="3" colwidth="133PT" align="left"/>
<tbody valign="top">
<row>
<entry>74</entry>
<entry>.align cinitAlign</entry>
<entry>; Create the cinit header</entry>
</row>
<row>
<entry>75</entry>
<entry>.sect &ldquo;.cinit&rdquo;</entry>
</row>
<row>
<entry>76</entry>
<entry>.field cinitSize</entry>
<entry>; size</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="98PT" align="left"/>
<colspec colname="3" colwidth="112PT" align="left"/>
<tbody valign="top">
<row>
<entry>77</entry>
<entry>.field objAddr, 24</entry>
<entry>; address</entry>
</row>
<row>
<entry>78</entry>
<entry>.field page, 8</entry>
<entry>; page</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="77PT" align="left"/>
<colspec colname="3" colwidth="133PT" align="left"/>
<tbody valign="top">
<row>
<entry>79</entry>
<entry>.eval 0, offset</entry>
<entry>; initialize the offset to 0</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="238PT" align="left"/>
<tbody valign="top">
<row>
<entry>80</entry>
<entry>.endm</entry>
</row>
<row>
<entry>81</entry>
</row>
<row>
<entry>82</entry>
<entry>;&num; &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals; C55_alignIfRequire &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;</entry>
</row>
<row>
<entry>83</entry>
<entry>; This macro checks if the offset is odd, and creates a hole</entry>
</row>
<row>
<entry>84</entry>
<entry>; with a value of dead.</entry>
</row>
<row>
<entry>85</entry>
</row>
<row>
<entry>86</entry>
<entry>; Parameters</entry>
</row>
<row>
<entry>87</entry>
<entry>; isObjAligned: Alignment constraint for the object. This indicates</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry>88</entry>
<entry>;</entry>
<entry>if objects members or any of its sub objects have</entry>
</row>
<row>
<entry>89</entry>
<entry>;</entry>
<entry>members that have alignment constraints.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="238PT" align="left"/>
<tbody valign="top">
<row>
<entry>90</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>91</entry>
<entry>;&num; Preconditions:</entry>
</row>
<row>
<entry>92</entry>
<entry>;&num; &emsp;none</entry>
</row>
<row>
<entry>93</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>94</entry>
<entry>;&num; Postconditions:</entry>
</row>
<row>
<entry>95</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>96</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>97</entry>
<entry>;&num; Constraints and Calling Environment:</entry>
</row>
<row>
<entry>98</entry>
<entry>;&num; The macro must be called for creating cinit records only.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="98PT" align="left"/>
<colspec colname="3" colwidth="140PT" align="left"/>
<tbody valign="top">
<row>
<entry>99</entry>
<entry>C55_alignIfRequired .macro</entry>
<entry>isObjAligned</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="63PT" align="left"/>
<colspec colname="2" colwidth="196PT" align="left"/>
<tbody valign="top">
<row>
<entry>100</entry>
<entry>CHK_nargs &ldquo;CINIT&rdquo;, isObjAligned</entry>
</row>
<row>
<entry>101</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="63PT" align="left"/>
<colspec colname="2" colwidth="84PT" align="left"/>
<colspec colname="3" colwidth="112PT" align="left"/>
<tbody valign="top">
<row>
<entry>102</entry>
<entry>.if(isObjAligned &equals; 2)</entry>
<entry>: Does the obj requir</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="168PT" align="left"/>
<colspec colname="2" colwidth="91PT" align="left"/>
<tbody valign="top">
<row>
<entry>103</entry>
<entry>; alignment</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="77PT" align="left"/>
<colspec colname="2" colwidth="70PT" align="left"/>
<colspec colname="3" colwidth="112PT" align="left"/>
<tbody valign="top">
<row>
<entry>104</entry>
<entry>.if(offset &amp; 0&times;1)</entry>
<entry>; if the object is at</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="168PT" align="left"/>
<colspec colname="2" colwidth="91PT" align="left"/>
<tbody valign="top">
<row>
<entry>105</entry>
<entry>; odd offset</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="91PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="112PT" align="left"/>
<tbody valign="top">
<row>
<entry>106</entry>
<entry>.word 0&times;dead</entry>
<entry>; create a dead word</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="91PT" align="left"/>
<colspec colname="2" colwidth="168PT" align="left"/>
<tbody valign="top">
<row>
<entry>107</entry>
<entry>.eval offset &plus; 1, offset</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="168PT" align="left"/>
<colspec colname="2" colwidth="91PT" align="left"/>
<tbody valign="top">
<row>
<entry>108</entry>
<entry>; increase the offset</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="77PT" align="left"/>
<colspec colname="2" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry>109</entry>
<entry>.endif</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="63PT" align="left"/>
<colspec colname="2" colwidth="196PT" align="left"/>
<tbody valign="top">
<row>
<entry>110</entry>
<entry>.endif</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="238PT" align="left"/>
<tbody valign="top">
<row>
<entry>111</entry>
<entry>.endm</entry>
</row>
<row>
<entry>112</entry>
</row>
<row>
<entry>113</entry>
</row>
<row>
<entry>114</entry>
<entry>;&num; &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals; C55_cinitBegin &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;</entry>
</row>
<row>
<entry>115</entry>
<entry>; This macro checks if the offset is odd, and creates a hole</entry>
</row>
<row>
<entry>116</entry>
<entry>; with a value of dead.</entry>
</row>
<row>
<entry>117</entry>
</row>
<row>
<entry>118</entry>
<entry>; Parameters</entry>
</row>
<row>
<entry>119</entry>
<entry>; isObjAligned: Alignment constraint for the object. This indicates</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry>120</entry>
<entry>;</entry>
<entry>if object&apos;s members or any of its sub-objects have</entry>
</row>
<row>
<entry>121</entry>
<entry>;</entry>
<entry>members that have alignment constraints.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="238PT" align="left"/>
<tbody valign="top">
<row>
<entry>122</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>123</entry>
<entry>;&num; Preconditions:</entry>
</row>
<row>
<entry>124</entry>
<entry>;&num; &emsp;none</entry>
</row>
<row>
<entry>125</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>126</entry>
<entry>;&num; Postconditions:</entry>
</row>
<row>
<entry>127</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>128</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>129</entry>
<entry>;&num; Constraints and Calling Environment:</entry>
</row>
<row>
<entry>130</entry>
<entry>;&num; The macro must be called before initializing any value field</entry>
</row>
<row>
<entry>131</entry>
<entry>;&num; of a cinit record.</entry>
</row>
<row>
<entry>132</entry>
</row>
<row>
<entry>133</entry>
<entry>C55_cinitBegin .macro &emsp;isObjAligned</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry>134</entry>
<entry>CHK_nargs &ldquo;CINIT&rdquo;, isObjAligned</entry>
</row>
<row>
<entry>135</entry>
<entry>C55_alignIfRequired &emsp;isObjAligned</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="238PT" align="left"/>
<tbody valign="top">
<row>
<entry>136</entry>
<entry>.endm</entry>
</row>
<row>
<entry>137</entry>
</row>
<row>
<entry>138</entry>
<entry>;&num; &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals; C55_cinitEnd &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;</entry>
</row>
<row>
<entry>139</entry>
<entry>; This macro checks if the offset is odd, and creates a hole</entry>
</row>
<row>
<entry>140</entry>
<entry>; with a value of dead.</entry>
</row>
<row>
<entry>141</entry>
</row>
<row>
<entry>142</entry>
<entry>; Parameters</entry>
</row>
<row>
<entry>143</entry>
<entry>; isObjAligned: Alignment constraint for the object. This indicates</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry>144</entry>
<entry>;</entry>
<entry>if object&apos;s members or any of its sub-objects have</entry>
</row>
<row>
<entry>145</entry>
<entry>;</entry>
<entry>members that have alignment constraints.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="238PT" align="left"/>
<tbody valign="top">
<row>
<entry>146</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>147</entry>
<entry>;&num; Preconditions:</entry>
</row>
<row>
<entry>148</entry>
<entry>;&num; &emsp;none</entry>
</row>
<row>
<entry>149</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>150</entry>
<entry>;&num; Postconditions:</entry>
</row>
<row>
<entry>151</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>152</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>153</entry>
<entry>;&num; Constraints and Calling Environment:</entry>
</row>
<row>
<entry>154</entry>
<entry>;&num; The macro must be called at the end of ciniting a structure</entry>
</row>
<row>
<entry>155</entry>
</row>
<row>
<entry>156</entry>
<entry>C55_cinitEnd .macro isObjAligned</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry>157</entry>
<entry>CHK_nargs &ldquo;CINIT&rdquo;, isObjAligned</entry>
</row>
<row>
<entry>158</entry>
<entry>C55_alignIfRequired &emsp;isObjAligned</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="238PT" align="left"/>
<tbody valign="top">
<row>
<entry>159</entry>
<entry>.endm</entry>
</row>
<row>
<entry>160</entry>
</row>
<row>
<entry>161</entry>
<entry>;&num; &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals; C55_cinitDataPtr &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;</entry>
</row>
<row>
<entry>162</entry>
<entry>; Initialize a data ptr in a cinit record.</entry>
</row>
<row>
<entry>163</entry>
</row>
<row>
<entry>164</entry>
<entry>; Parameters</entry>
</row>
<row>
<entry>165</entry>
<entry>; value: value to which the record must be initialized</entry>
</row>
<row>
<entry>166</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>167</entry>
<entry>;&num; Preconditions:</entry>
</row>
<row>
<entry>168</entry>
<entry>;&num; &ensp;none</entry>
</row>
<row>
<entry>169</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>170</entry>
<entry>;&num; Postconditions:</entry>
</row>
<row>
<entry>171</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>172</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>173</entry>
</row>
<row>
<entry>174</entry>
<entry>C55_cinitDataPtr .macro value</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry>175</entry>
<entry>CHK_nargs &ldquo;CINIT&rdquo;, value</entry>
</row>
<row>
<entry>176</entry>
<entry>if ($isdefed(&ldquo;_large_model&rdquo;))</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="168PT" align="left"/>
<colspec colname="2" colwidth="91PT" align="left"/>
<tbody valign="top">
<row>
<entry>177</entry>
<entry>; compilaton</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="77PT" align="left"/>
<colspec colname="2" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry>178</entry>
<entry>.if (offset &amp; 0&times;1); if at odd offset</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="91PT" align="left"/>
<colspec colname="2" colwidth="168PT" align="left"/>
<tbody valign="top">
<row>
<entry>179</entry>
<entry>.word 0&times;dead &emsp;; fill in the hole</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="84PT" align="left"/>
<colspec colname="2" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry>180</entry>
<entry>.eval offset &plus; 1, offset</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="168PT" align="left"/>
<colspec colname="2" colwidth="91PT" align="left"/>
<tbody valign="top">
<row>
<entry>181</entry>
<entry>; increase the offset</entry>
</row>
<row>
<entry>182</entry>
<entry>; for hole filled.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="77PT" align="left"/>
<colspec colname="2" colwidth="70PT" align="left"/>
<colspec colname="3" colwidth="112PT" align="left"/>
<tbody valign="top">
<row>
<entry>183</entry>
<entry>.endif</entry>
<entry></entry>
</row>
<row>
<entry>184</entry>
<entry>.xlong value:</entry>
<entry>; Fill in the value</entry>
</row>
<row>
<entry>185</entry>
<entry>eval offset &plus; 2, offset</entry>
<entry>; Increase the offset</entry>
</row>
<row>
<entry>186</entry>
<entry></entry>
<entry>; corresponding size</entry>
</row>
<row>
<entry>187</entry>
<entry></entry>
<entry>; of dataPtr.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="63PT" align="left"/>
<colspec colname="2" colwidth="196PT" align="left"/>
<tbody valign="top">
<row>
<entry>188</entry>
<entry>.else</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="77PT" align="left"/>
<colspec colname="2" colwidth="70PT" align="left"/>
<colspec colname="3" colwidth="112PT" align="left"/>
<tbody valign="top">
<row>
<entry>189</entry>
<entry>.word :value:</entry>
<entry>: If in near mode just</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="168PT" align="left"/>
<colspec colname="2" colwidth="91PT" align="left"/>
<tbody valign="top">
<row>
<entry>190</entry>
<entry>; fill the value.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="77PT" align="left"/>
<colspec colname="2" colwidth="70PT" align="left"/>
<colspec colname="3" colwidth="112PT" align="left"/>
<tbody valign="top">
<row>
<entry>191</entry>
<entry>.eval offset &plus; 1, offset</entry>
<entry>; increase the offset</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="168PT" align="left"/>
<colspec colname="2" colwidth="91PT" align="left"/>
<tbody valign="top">
<row>
<entry>192</entry>
<entry>; coressponding to</entry>
</row>
<row>
<entry>193</entry>
<entry>; that of data ptr.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="238PT" align="left"/>
<tbody valign="top">
<row>
<entry>194</entry>
<entry>.endif</entry>
</row>
<row>
<entry>195</entry>
<entry>.endm</entry>
</row>
<row>
<entry>196</entry>
</row>
<row>
<entry>197</entry>
<entry>;&num; &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;C55_cinitCodePtr &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;</entry>
</row>
<row>
<entry>198</entry>
<entry>; Initialize a code ptr in a cinit record.</entry>
</row>
<row>
<entry>199</entry>
</row>
<row>
<entry>200</entry>
<entry>; Parameters</entry>
</row>
<row>
<entry>201</entry>
<entry>; value: value to which the record must be initialized</entry>
</row>
<row>
<entry>202</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>203</entry>
<entry>;&num; Preconditions:</entry>
</row>
<row>
<entry>204</entry>
<entry>;&num; &emsp;none</entry>
</row>
<row>
<entry>205</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>206</entry>
<entry>;&num; Postconditions:</entry>
</row>
<row>
<entry>207</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>208</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>209</entry>
</row>
<row>
<entry>210</entry>
<entry>C55_cinitCodePtr .macro value</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry>211</entry>
<entry>CHK_nargs &ldquo;CINIT&rdquo;, value</entry>
</row>
<row>
<entry>212</entry>
<entry>.if (offset &amp; 0&times;1); if at odd offset</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="77PT" align="left"/>
<colspec colname="2" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry>213</entry>
<entry>word 0&times;dead ; fill in the hole</entry>
</row>
<row>
<entry>214</entry>
<entry>eval offset &plus; 1, offset</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="168PT" align="left"/>
<colspec colname="2" colwidth="91PT" align="left"/>
<tbody valign="top">
<row>
<entry>215</entry>
<entry>; increase the offset</entry>
</row>
<row>
<entry>216</entry>
<entry>; for hole filled.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="91PT" align="left"/>
<colspec colname="3" colwidth="112PT" align="left"/>
<tbody valign="top">
<row>
<entry>217</entry>
<entry>.endif</entry>
<entry></entry>
</row>
<row>
<entry>218</entry>
<entry>.xlong :value:</entry>
<entry>; Fill in the value</entry>
</row>
<row>
<entry>219</entry>
<entry>.eval offset &plus; 2, offset</entry>
<entry>; Increase the offset</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="168PT" align="left"/>
<colspec colname="2" colwidth="91PT" align="left"/>
<tbody valign="top">
<row>
<entry>220</entry>
<entry>; corresponding size</entry>
</row>
<row>
<entry>221</entry>
<entry>; of dataPtr.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="238PT" align="left"/>
<tbody valign="top">
<row>
<entry>222</entry>
<entry>.endm</entry>
</row>
<row>
<entry>223</entry>
<entry>;&num; &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals; C55_cinitLong &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;</entry>
</row>
<row>
<entry>224</entry>
<entry>; Initialize a long in a cinit record.</entry>
</row>
<row>
<entry>225</entry>
</row>
<row>
<entry>226</entry>
<entry>; Parameters</entry>
</row>
<row>
<entry>227</entry>
<entry>; value: value to which the record must be initialized</entry>
</row>
<row>
<entry>228</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>229</entry>
<entry>;&num; Preconditions:</entry>
</row>
<row>
<entry>230</entry>
<entry>;&num; &emsp;none</entry>
</row>
<row>
<entry>231</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>232</entry>
<entry>;&num; Postconditions:</entry>
</row>
<row>
<entry>233</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>234</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>235</entry>
</row>
<row>
<entry>236</entry>
<entry>C55_cinitLong .macro value</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry>237</entry>
<entry>CHK_nargs &ldquo;CINIT&rdquo;, value</entry>
</row>
<row>
<entry>238</entry>
<entry>.if (offset &amp; 0&times;1) ; if at odd offset</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="77PT" align="left"/>
<colspec colname="2" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry>239</entry>
<entry>.word 0&times;dead &emsp;; fill in the hole</entry>
</row>
<row>
<entry>240</entry>
<entry>.eval offset &plus; 1, offset</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="168PT" align="left"/>
<colspec colname="2" colwidth="91PT" align="left"/>
<tbody valign="top">
<row>
<entry>241</entry>
<entry>; increase the offset</entry>
</row>
<row>
<entry>242</entry>
<entry>; for hole filled.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="91PT" align="left"/>
<colspec colname="3" colwidth="112PT" align="left"/>
<tbody valign="top">
<row>
<entry>243</entry>
<entry>.endif</entry>
<entry></entry>
</row>
<row>
<entry>244</entry>
<entry>.xlong :value:</entry>
<entry>; Fill in the value</entry>
</row>
<row>
<entry>245</entry>
<entry>eval offset &plus; 2, offset</entry>
<entry>; Increase the offset</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="168PT" align="left"/>
<colspec colname="2" colwidth="91PT" align="left"/>
<tbody valign="top">
<row>
<entry>246</entry>
<entry>; corresponding size</entry>
</row>
<row>
<entry>247</entry>
<entry>; of dataPtr.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="238PT" align="left"/>
<tbody valign="top">
<row>
<entry>248</entry>
<entry>.endm</entry>
</row>
<row>
<entry>249</entry>
</row>
<row>
<entry>250</entry>
<entry>;&num; &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals; C55_cinitInt &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;</entry>
</row>
<row>
<entry>251</entry>
<entry>; Initialize a long in a cinit record.</entry>
</row>
<row>
<entry>252</entry>
</row>
<row>
<entry>253</entry>
<entry>; Parameters</entry>
</row>
<row>
<entry>254</entry>
<entry>; value: value to which the record must be initialized</entry>
</row>
<row>
<entry>255</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>256</entry>
<entry>;&num; Preconditions:</entry>
</row>
<row>
<entry>257</entry>
<entry>;&num; &emsp;none</entry>
</row>
<row>
<entry>258</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>259</entry>
<entry>;&num; Postconditions:</entry>
</row>
<row>
<entry>260</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>261</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>262</entry>
</row>
<row>
<entry>263</entry>
<entry>C55_cinitInt .macro value</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry>264</entry>
<entry>CHK_nargs &ldquo;CINIT&rdquo;, value</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="91PT" align="left"/>
<colspec colname="3" colwidth="112PT" align="left"/>
<tbody valign="top">
<row>
<entry>265</entry>
<entry>.word value</entry>
<entry>; Fill in the value</entry>
</row>
<row>
<entry>266</entry>
<entry>.eval offset &plus; 1. offset</entry>
<entry>; Increase the offset</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="168PT" align="left"/>
<colspec colname="2" colwidth="91PT" align="left"/>
<tbody valign="top">
<row>
<entry>267</entry>
<entry>; corrresponding size</entry>
</row>
<row>
<entry>268</entry>
<entry>; of dataPtr.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="238PT" align="left"/>
<tbody valign="top">
<row>
<entry>269</entry>
<entry>.endm</entry>
</row>
<row>
<entry>270</entry>
</row>
<row>
<entry>271</entry>
<entry>;&num; &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals; C55_cinitArg &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;</entry>
</row>
<row>
<entry>272</entry>
<entry>; Initialize a long in a cinit record.</entry>
</row>
<row>
<entry>273</entry>
</row>
<row>
<entry>274</entry>
<entry>; Parameters</entry>
</row>
<row>
<entry>275</entry>
<entry>; value: value to which the record must be initialized</entry>
</row>
<row>
<entry>276</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>277</entry>
<entry>;&num; Preconditions:</entry>
</row>
<row>
<entry>278</entry>
<entry>;&num; &emsp;none</entry>
</row>
<row>
<entry>279</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>280</entry>
<entry>;&num; Postconditions:</entry>
</row>
<row>
<entry>281</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>282</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>283</entry>
</row>
<row>
<entry>284</entry>
<entry>C55_cinitArg .macro value</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry>285</entry>
<entry>CHK_nargs &ldquo;CINIT&rdquo;, value</entry>
</row>
<row>
<entry>286</entry>
<entry>C55_cinitDataPtr value</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="238PT" align="left"/>
<tbody valign="top">
<row>
<entry>287</entry>
<entry>.endm</entry>
</row>
<row>
<entry>288</entry>
</row>
<row>
<entry>289</entry>
<entry>;&num; &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals; C55_allocateObject &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;</entry>
</row>
<row>
<entry>290</entry>
<entry>; Allocates space in an uninitialized section for the object.</entry>
</row>
<row>
<entry>291</entry>
</row>
<row>
<entry>292</entry>
<entry>; Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry>293</entry>
<entry>; cinitAlign:</entry>
<entry>Alignment constraints for cinit record</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="238PT" align="left"/>
<tbody valign="top">
<row>
<entry>294</entry>
<entry>; isObjAligned: Alignment constraint for the object. This indicates</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry>295</entry>
<entry>;</entry>
<entry>if objects members or any of its sub objects have</entry>
</row>
<row>
<entry>296</entry>
<entry>;</entry>
<entry>members that have alignment constraints.</entry>
</row>
<row>
<entry>297</entry>
<entry>; objAddr:</entry>
<entry>Is the addr of the object</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="238PT" align="left"/>
<tbody valign="top">
<row>
<entry>298</entry>
<entry>; size: &emsp;It is the size of the object</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry>299</entry>
<entry>; section:</entry>
<entry>The section where the object should exists.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="238PT" align="left"/>
<tbody valign="top">
<row>
<entry>300</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>301</entry>
<entry>;&num; Preconditions:</entry>
</row>
<row>
<entry>302</entry>
<entry>;&num; &emsp;none</entry>
</row>
<row>
<entry>303</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>304</entry>
<entry>;&num; Postconditions:</entry>
</row>
<row>
<entry>305</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>306</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>307</entry>
<entry>C55_allocateObject .macro isObjAligned, objAddr, size, section</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry>308</entry>
<entry>CHK_nargs &ldquo;CINIT&rdquo;, section</entry>
</row>
<row>
<entry>309</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="91PT" align="left"/>
<colspec colname="3" colwidth="112PT" align="left"/>
<tbody valign="top">
<row>
<entry>310</entry>
<entry>.eval size, objSize</entry>
<entry>; This is the size of</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="168PT" align="left"/>
<colspec colname="2" colwidth="91PT" align="left"/>
<tbody valign="top">
<row>
<entry>311</entry>
<entry>; .object</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="91PT" align="left"/>
<colspec colname="3" colwidth="112PT" align="left"/>
<tbody valign="top">
<row>
<entry>312</entry>
<entry>.if(isObjAligned &equals; 2)</entry>
<entry>; Does the Obj require alignment</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="70PT" align="left"/>
<colspec colname="2" colwidth="77PT" align="left"/>
<colspec colname="3" colwidth="112PT" align="left"/>
<tbody valign="top">
<row>
<entry>313</entry>
<entry>.if(objSize &amp; 0&times;1)</entry>
<entry>: if the cinit size is odd</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="77PT" align="left"/>
<colspec colname="2" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry>314</entry>
<entry>eval objSize &plus; 1, objSize ; Make it even</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry>315</entry>
<entry>.endif</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>316</entry>
<entry>.endif</entry>
</row>
<row>
<entry>317</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="238PT" align="left"/>
<tbody valign="top">
<row>
<entry>318</entry>
<entry>objAddr .usect &ldquo;:section:&rdquo;, objSize, 0, isObjAligned ; allocate</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="189PT" align="left"/>
<colspec colname="2" colwidth="70PT" align="left"/>
<tbody valign="top">
<row>
<entry>319</entry>
<entry>; space for object.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="105PT" align="left"/>
<colspec colname="3" colwidth="133PT" align="left"/>
<tbody valign="top">
<row>
<entry>320</entry>
<entry>.endm</entry>
<entry></entry>
</row>
<row>
<entry>321</entry>
<entry>.endif</entry>
<entry>; endif for CINIT inclusion</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number>  
<table-cwu id="TABLE-US-00002">
<number>2</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<thead>
<row>
<entry namest="1" nameend="2" align="center">TABLE 2</entry>
</row>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>1</entry>
<entry>; Pipe Manager.</entry>
</row>
<row>
<entry>2</entry>
<entry>;</entry>
</row>
<row>
<entry>3</entry>
<entry>; Pipes allow two clients (a producer (writer) and a consumer (reader)) to</entry>
</row>
<row>
<entry>4</entry>
<entry>; transfer frames of data without copying the data.</entry>
</row>
<row>
<entry>5</entry>
<entry>;</entry>
</row>
<row>
<entry>6</entry>
<entry>; The consumer (reader) does the following:</entry>
</row>
<row>
<entry>7</entry>
<entry>; PIP_get &amp;pipe</entry>
</row>
<row>
<entry>8</entry>
<entry>; use pipereaderSize words of data from the frame at pipe.readerAddr</entry>
</row>
<row>
<entry>9</entry>
<entry>; PIP_free &amp;pipe</entry>
</row>
<row>
<entry>10</entry>
<entry>;</entry>
</row>
<row>
<entry>11</entry>
<entry>; The producer (writer) does the following:</entry>
</row>
<row>
<entry>12</entry>
<entry>; PIP_alloc &amp;pipe</entry>
</row>
<row>
<entry>13</entry>
<entry>; fill the frame at pipe.writerAddr with up to pipe.writerSize words</entry>
</row>
<row>
<entry>14</entry>
<entry>; set pipe.writerSize to the actual number of words in frame</entry>
</row>
<row>
<entry>15</entry>
<entry>; PIP_put &amp;pip</entry>
</row>
<row>
<entry>16</entry>
<entry>;</entry>
</row>
<row>
<entry>17</entry>
<entry>; The fields readerNumprames and writerNumFrames of PIP object</entry>
</row>
<row>
<entry>18</entry>
<entry>; represent the number of full and empty frames respectively.</entry>
</row>
<row>
<entry>19</entry>
<entry>;</entry>
</row>
<row>
<entry>20</entry>
<entry>; The pipe manager allows for probing of data transferred through each</entry>
</row>
<row>
<entry>21</entry>
<entry>; pipe. This probing is accomplished using the PIP_&lt;read&verbar;write&gt;probeSET; ; and</entry>
</row>
<row>
<entry></entry>
<entry>PIP_&lt;read&verbar;write&gt;probeCLR operations which attach a separate PIP; ; ; probe to the specified pipe.</entry>
</row>
<row>
<entry>22</entry>
<entry>;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="301PT" align="left"/>
<tbody valign="top">
<row>
<entry>23</entry>
<entry>.if($isdefed(&ldquo;PIP_&rdquo;) &equals; 0) ; prevent multiple includes of this file</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>24</entry>
<entry>PIP_ .set 1</entry>
</row>
<row>
<entry>25</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="301PT" align="left"/>
<tbody valign="top">
<row>
<entry>26</entry>
<entry>.include chk.h55</entry>
</row>
<row>
<entry>27</entry>
<entry>.include fxn.h55</entry>
</row>
<row>
<entry>28</entry>
<entry>.include cinit.h55</entry>
</row>
<row>
<entry>29</entry>
<entry>.include gbl.h55</entry>
</row>
<row>
<entry>30</entry>
<entry>.include sts.h55</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>31</entry>
<entry>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</entry>
</row>
<row>
<entry>32</entry>
<entry>; Define alignment constraints for structure in PIP_Obj</entry>
</row>
<row>
<entry>33</entry>
<entry>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</entry>
</row>
<row>
<entry>34</entry>
</row>
<row>
<entry>35</entry>
<entry>isPipsockAligned .set 2</entry>
</row>
<row>
<entry>36</entry>
<entry>isPipAligned .set 2</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="301PT" align="left"/>
<tbody valign="top">
<row>
<entry>37</entry>
<entry>if ($isdefed(&ldquo;_large_model&rdquo;))</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>38</entry>
<entry>isPipdescAligned .set 2</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="301PT" align="left"/>
<tbody valign="top">
<row>
<entry>39</entry>
<entry>.else</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>40</entry>
<entry>isPipdescAligned .set 1</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="301PT" align="left"/>
<tbody valign="top">
<row>
<entry>41</entry>
<entry>.endif</entry>
</row>
<row>
<entry>42</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>43</entry>
<entry>;</entry>
</row>
<row>
<entry>44</entry>
<entry>; &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals; PIP_Sock &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;</entry>
</row>
<row>
<entry>45</entry>
<entry>;</entry>
</row>
<row>
<entry>46</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="266PT" align="left"/>
<tbody valign="top">
<row>
<entry>47</entry>
<entry>PIP_Sock</entry>
<entry>.struct</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="49PT" align="left"/>
<colspec colname="3" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry>48</entry>
<entry>tprobe</entry>
<entry>DataPtr 1</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="77PT" align="left"/>
<colspec colname="3" colwidth="49PT" align="left"/>
<colspec colname="4" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry>49</entry>
<entry>frameAddr</entry>
<entry>DataPtr 1</entry>
<entry>; Address of the frame</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="77PT" align="left"/>
<colspec colname="3" colwidth="35PT" align="left"/>
<colspec colname="4" colwidth="196PT" align="left"/>
<tbody valign="top">
<row>
<entry>50</entry>
<entry>frameSize</entry>
<entry>Int 1</entry>
<entry>; Size of the frame</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="56PT" align="left"/>
<colspec colname="4" colwidth="196PT" align="left"/>
<tbody valign="top">
<row>
<entry>51</entry>
<entry>curDesc</entry>
<entry>DataPtr 1</entry>
<entry>; Current descriptor</entry>
</row>
<row>
<entry>52</entry>
<entry>pFxnObj</entry>
<entry>DataPtr 1</entry>
<entry>pointer to function Obj</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="77PT" align="left"/>
<colspec colname="3" colwidth="35PT" align="left"/>
<colspec colname="4" colwidth="196PT" align="left"/>
<tbody valign="top">
<row>
<entry>53</entry>
<entry>numFrames</entry>
<entry>Int 1</entry>
<entry>; number of frames</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="56PT" align="left"/>
<colspec colname="4" colwidth="196PT" align="left"/>
<tbody valign="top">
<row>
<entry>54</entry>
<entry>gprobe</entry>
<entry>DataPtr 1</entry>
<entry>; grobe. not yet used</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="77PT" align="left"/>
<colspec colname="3" colwidth="49PT" align="left"/>
<colspec colname="4" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry>55</entry>
<entry>pNumFrames</entry>
<entry>DataPtr 1</entry>
<entry>; ptr to numFrames</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="77PT" align="left"/>
<colspec colname="3" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry>56</entry>
<entry>pad</entry>
<entry>.align &ensp;isFxnAligned</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="252PT" align="left"/>
<tbody valign="top">
<row>
<entry>57</entry>
<entry>fxnObj</entry>
<entry>.tag FXN_Obj ; function object</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="56PT" align="left"/>
<colspec colname="4" colwidth="196PT" align="left"/>
<tbody valign="top">
<row>
<entry>58</entry>
<entry>stsHdl</entry>
<entry>DataPtr 1</entry>
<entry>; Handle to STS object</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="252PT" align="left"/>
<tbody valign="top">
<row>
<entry>59</entry>
<entry>endPad</entry>
<entry>.align &ensp;isPipsockAligned</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>60</entry>
<entry>PIP_A_SOCKSIZE .endstruct</entry>
</row>
<row>
<entry>61</entry>
</row>
<row>
<entry>62</entry>
<entry>;</entry>
</row>
<row>
<entry>63</entry>
<entry>&equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals; PIP_Obj &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;</entry>
</row>
<row>
<entry>64</entry>
<entry>;</entry>
</row>
<row>
<entry>65</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="77PT" align="left"/>
<colspec colname="3" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry>66</entry>
<entry>PIP_Obj</entry>
<entry>.struct</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="91PT" align="left"/>
<colspec colname="3" colwidth="70PT" align="left"/>
<colspec colname="4" colwidth="147PT" align="left"/>
<tbody valign="top">
<row>
<entry>67</entry>
<entry>threshold</entry>
<entry>Int 1</entry>
<entry>; (Uns) max size of frames in pip</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="91PT" align="left"/>
<colspec colname="3" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>68</entry>
<entry>pad0</entry>
<entry>.align isPipsockAligned</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="5">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="91PT" align="left"/>
<colspec colname="3" colwidth="28PT" align="left"/>
<colspec colname="4" colwidth="42PT" align="left"/>
<colspec colname="5" colwidth="147PT" align="left"/>
<tbody valign="top">
<row>
<entry>69</entry>
<entry>readerSock</entry>
<entry>.tag</entry>
<entry>PIP_Sock</entry>
<entry>; Reader Socket</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="91PT" align="left"/>
<colspec colname="3" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>70</entry>
<entry>pad1</entry>
<entry>.align isPipsockAligned</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="5">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="91PT" align="left"/>
<colspec colname="3" colwidth="28PT" align="left"/>
<colspec colname="4" colwidth="42PT" align="left"/>
<colspec colname="5" colwidth="147PT" align="left"/>
<tbody valign="top">
<row>
<entry>71</entry>
<entry>writerSock</entry>
<entry>.tag</entry>
<entry>PIP_Sock</entry>
<entry>; Writer Socket</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="70PT" align="left"/>
<colspec colname="3" colwidth="238PT" align="left"/>
<tbody valign="top">
<row>
<entry>72</entry>
<entry>endPad</entry>
<entry>. align isPipAligned</entry>
</row>
<row>
<entry>73</entry>
<entry>PIP_A_OBJSIZE</entry>
<entry>.endstruct</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>74</entry>
<entry>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</entry>
</row>
<row>
<entry>75</entry>
<entry>; readerSock has the following members</entry>
</row>
<row>
<entry>76</entry>
<entry>; preaderTakeProbe, readerAddr readerSize, readerCurdesc,</entry>
</row>
<row>
<entry>77</entry>
<entry>; pnotifyReader, readerNumFrames preaderGiveProbe .pwriterNumFrames</entry>
</row>
<row>
<entry>78</entry>
<entry>; notifyWriter, preaderSts</entry>
</row>
<row>
<entry>79</entry>
<entry>;</entry>
</row>
<row>
<entry>80</entry>
<entry>; writerSock has the following members</entry>
</row>
<row>
<entry>81</entry>
<entry>; pwriterTakeProbe, writerAddr, writerSize ,writerCurdesc</entry>
</row>
<row>
<entry>82</entry>
<entry>; pnotifyWriter, writerNumFrames, pwriterGiveProbe</entry>
</row>
<row>
<entry>83</entry>
<entry>; preaderNumFrames ,notifyReader, pwriterSts</entry>
</row>
<row>
<entry>84</entry>
<entry>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</entry>
</row>
<row>
<entry>85</entry>
</row>
<row>
<entry>86</entry>
<entry>PIPDESC_Obj .struct</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="91PT" align="left"/>
<colspec colname="3" colwidth="56PT" align="left"/>
<colspec colname="4" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry>87</entry>
<entry>addr</entry>
<entry>DataPtr 1</entry>
<entry></entry>
</row>
<row>
<entry>88</entry>
<entry>size</entry>
<entry>Int</entry>
<entry>1</entry>
</row>
<row>
<entry>89</entry>
<entry>next</entry>
<entry>DataPtr 1</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>90</entry>
<entry>PIPDESC_A_OBJSIZE .endstruct</entry>
</row>
<row>
<entry>91</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="91PT" align="left"/>
<colspec colname="3" colwidth="35PT" align="left"/>
<colspec colname="4" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry>92</entry>
<entry>PIPDESC_BASE</entry>
<entry>.set</entry>
<entry>PIPDESC_Obj.addr</entry>
</row>
<row>
<entry>93</entry>
<entry>PIPDESC_O_SIZE</entry>
<entry>.set</entry>
<entry>PIPDESC_Obj.size-PIPDESC_BASE</entry>
</row>
<row>
<entry>94</entry>
<entry>PIPDESC_O_NEXT</entry>
<entry>.set</entry>
<entry>PIPDESC_Obj.next-PIPDESC_BASE</entry>
</row>
<row>
<entry>95</entry>
<entry>PIPDESC_SIZE</entry>
<entry>.set</entry>
<entry>PIPDESC_A_OBJSIZE</entry>
</row>
<row>
<entry>96</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>97</entry>
<entry>;</entry>
</row>
<row>
<entry>98</entry>
<entry>; &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals; PIP OFFSETS &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;</entry>
</row>
<row>
<entry>99</entry>
<entry>;</entry>
</row>
<row>
<entry>100</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="91PT" align="left"/>
<colspec colname="3" colwidth="35PT" align="left"/>
<colspec colname="4" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry>101</entry>
<entry>PIP_O_BASE</entry>
<entry>.set</entry>
<entry>PIP_Obj.threshold</entry>
</row>
<row>
<entry>102</entry>
<entry>PIP_O_TPROBE</entry>
<entry>.set</entry>
<entry>PIP_Sock.tprobe</entry>
</row>
<row>
<entry>103</entry>
<entry>PIP_O_FADDR</entry>
<entry>.set</entry>
<entry>PIP_Sock.frameAddr</entry>
</row>
<row>
<entry>104</entry>
<entry>PIP_O_FSIZE</entry>
<entry>.set</entry>
<entry>PIP_Sock.frameSize</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="112PT" align="left"/>
<colspec colname="3" colwidth="35PT" align="left"/>
<colspec colname="4" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry>105</entry>
<entry>PIP_O_CURDESC</entry>
<entry>.set</entry>
<entry>PIP_Sock.curDesc</entry>
</row>
<row>
<entry>106</entry>
<entry>PIP_O_PFXNOBJ</entry>
<entry>.set</entry>
<entry>PIP_Sock.pFxnObj</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="91PT" align="left"/>
<colspec colname="3" colwidth="35PT" align="left"/>
<colspec colname="4" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry>107</entry>
<entry>PIP_O_NUMFRAMES</entry>
<entry>.set</entry>
<entry>PIP_Sock.numFrames</entry>
</row>
<row>
<entry>108</entry>
<entry>PIP_O_GPROBE</entry>
<entry>.set</entry>
<entry>PIP_Sock.gprobe</entry>
</row>
<row>
<entry>109</entry>
<entry>PIP_O_PNUMFRAMES</entry>
<entry>.set</entry>
<entry>PIP_Sock.pNumFrames</entry>
</row>
<row>
<entry>110</entry>
<entry>PIP_O_FXNOBJ</entry>
<entry>.set</entry>
<entry>PIP_Sock.fknObj</entry>
</row>
<row>
<entry>111</entry>
<entry>PIP_O_STSHDL</entry>
<entry>.set</entry>
<entry>PIP_Sock.stsHdl</entry>
</row>
<row>
<entry>112</entry>
<entry>PIP_O_HDBASE</entry>
<entry>.set</entry>
<entry>PIP_Obj.readerSock - PIP_O_BASE</entry>
</row>
<row>
<entry>113</entry>
<entry>PIP_O_TLBASE</entry>
<entry>.set</entry>
<entry>PIP_Obj.writerSock - PIP_O_BASE</entry>
</row>
<row>
<entry>114</entry>
<entry>PIP_READPTR</entry>
<entry>.set</entry>
<entry>PIP_O_HDBASE&plus;PIP_O_FADDR</entry>
</row>
<row>
<entry>115</entry>
<entry>PIP_READCNT</entry>
<entry>.set</entry>
<entry>PIP_O_HDBASE&plus;PIP_O_FSIZE</entry>
</row>
<row>
<entry>116</entry>
<entry>PIP_READCURDESC</entry>
<entry>.set</entry>
<entry>PIP_O_HDBASE&plus;PIP_O_CURDESC</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="91PT" align="left"/>
<colspec colname="3" colwidth="49PT" align="left"/>
<colspec colname="4" colwidth="168PT" align="left"/>
<tbody valign="top">
<row>
<entry>117</entry>
<entry>PIP_READSTSHDL</entry>
<entry>.set</entry>
<entry>PIP_O_HDBASE&plus;PIP_O_STSHDL</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="91PT" align="left"/>
<colspec colname="3" colwidth="35PT" align="left"/>
<colspec colname="4" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry>118</entry>
<entry>PIP_WRITECURDESC</entry>
<entry>.set</entry>
<entry>PIP_O_TLBASE&plus;PIP_O_CURDESC</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="91PT" align="left"/>
<colspec colname="3" colwidth="49PT" align="left"/>
<colspec colname="4" colwidth="168PT" align="left"/>
<tbody valign="top">
<row>
<entry>119</entry>
<entry>PIP_READFXNOBJ</entry>
<entry>.set</entry>
<entry>PIP_O_HDBASE&plus;PIP_O_FXNOBJ</entry>
</row>
<row>
<entry>120</entry>
<entry>PIP_WRITEPTR</entry>
<entry>.set</entry>
<entry>PIP_O_TLBASE&plus;PIP_O_FADDR</entry>
</row>
<row>
<entry>121</entry>
<entry>PIP_WRITECNT</entry>
<entry>.set</entry>
<entry>PIP_O_TLBASE&plus;PIP_O_FSIZE</entry>
</row>
<row>
<entry>122</entry>
<entry>PIP_WRITECURDESC</entry>
<entry>.set</entry>
<entry>PIP_O_TLBASE&plus;PIP_O_CURDESC</entry>
</row>
<row>
<entry>123</entry>
<entry>PIP_WRITESTSHDL</entry>
<entry>.set</entry>
<entry>PIP_O_TLBASE&plus;PIP_O_STSHDL</entry>
</row>
<row>
<entry>124</entry>
<entry>PIP_WRITEFXNOBJ</entry>
<entry>.set</entry>
<entry>PIP_O_TLBASE&plus;PIP_O_FXNOBJ</entry>
</row>
<row>
<entry>125</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="77PT" align="left"/>
<colspec colname="3" colwidth="42PT" align="left"/>
<colspec colname="4" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry>126</entry>
<entry>PIP_FULLBUFS</entry>
<entry>.set</entry>
<entry>PIP_O_HDBASE&plus;PIP_O_NUMFRAMES</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="91PT" align="left"/>
<colspec colname="3" colwidth="35PT" align="left"/>
<colspec colname="4" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry>127</entry>
<entry>PIP_EMPTYBUFS</entry>
<entry>.set</entry>
<entry>PIP_O_TLBASE&plus;PIP_O_NUMFRAMES</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="112PT" align="left"/>
<colspec colname="3" colwidth="35PT" align="left"/>
<colspec colname="4" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry>128</entry>
<entry>PIP_SIZE</entry>
<entry>.set</entry>
<entry>PIP_A_OBJSIZE</entry>
</row>
<row>
<entry>129</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="280PT" align="left"/>
<tbody valign="top">
<row>
<entry>130</entry>
<entry>.mmregs</entry>
</row>
<row>
<entry>131</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="294PT" align="left"/>
<tbody valign="top">
<row>
<entry>132</entry>
<entry>.global PIP_F_give, PIP_F_take, PIP_F_probe, PIP_F_start</entry>
</row>
<row>
<entry>133</entry>
<entry>global PIP_D_tabbeg, PIP_D_tablen</entry>
</row>
<row>
<entry>134</entry>
<entry>global PIP_A_TABBEG, PIP_A_TABEND, PIP_A_TABLEN</entry>
</row>
<row>
<entry>135</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>136</entry>
<entry>;</entry>
</row>
<row>
<entry>137</entry>
<entry>; &num; &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals; PIP_Obj &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;</entry>
</row>
<row>
<entry>138</entry>
<entry>; Create a pipe object.</entry>
</row>
<row>
<entry>139</entry>
<entry>;</entry>
</row>
<row>
<entry>140</entry>
<entry>; name - name of pipe object</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="252PT" align="left"/>
<tbody valign="top">
<row>
<entry>141</entry>
<entry>;id</entry>
<entry>- pipe id</entry>
</row>
<row>
<entry>142</entry>
<entry>; buf</entry>
<entry>- preallocated buffer (or &lt;NULL&gt; if PIP_Obj should create)</entry>
</row>
<row>
<entry>143</entry>
<entry>; framesize</entry>
<entry>- size of each frame in pipe (in words)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>144</entry>
<entry>; numframes- number of frames in pipe</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="252PT" align="left"/>
<tbody valign="top">
<row>
<entry>145</entry>
<entry>; stsend</entry>
<entry>- which end STS stats are accumulated</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>146</entry>
<entry>; notifyWriter - function to call whenever PIP_free is called</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="252PT" align="left"/>
<tbody valign="top">
<row>
<entry>147</entry>
<entry>; nwarg*</entry>
<entry>- arguments to notify Writer function</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>148</entry>
<entry>; notifyReader - function to call whenever PIP_put is called</entry>
</row>
<row>
<entry>149</entry>
<entry>; nrarg* - arguments to notifyReader function</entry>
</row>
<row>
<entry>150</entry>
<entry>;</entry>
</row>
<row>
<entry>151</entry>
<entry>; Note: PIP probe functionality is *not* implemented for this target</entry>
</row>
<row>
<entry>152</entry>
<entry>;</entry>
</row>
<row>
<entry>153</entry>
<entry>;&num; Preconditions:</entry>
</row>
<row>
<entry>154</entry>
<entry>;&num; &ensp;none</entry>
</row>
<row>
<entry>155</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>156</entry>
<entry>;&num; Postconditions:</entry>
</row>
<row>
<entry>157</entry>
<entry>;&num; &ensp;none</entry>
</row>
<row>
<entry>158</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>159</entry>
<entry>;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="301PT" align="left"/>
<tbody valign="top">
<row>
<entry>160</entry>
<entry>.asg &emsp;&ldquo;:GBL_Obj$regs:,:FXN_Obj$regs:,:STS_Obj$regs:&rdquo;, PIP_Obj$regs</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>161</entry>
<entry>PIP_Obj.macro cflag, name, id, buf, framesize, numframes, stsend, notifyWriter, nwarg0, nwarg1,</entry>
</row>
<row>
<entry></entry>
<entry>notifyReader, nrarg0, nrarg1</entry>
</row>
<row>
<entry>162</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="280PT" align="left"/>
<tbody valign="top">
<row>
<entry>163</entry>
<entry>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</entry>
</row>
<row>
<entry>164</entry>
<entry>; These globals are only for debug purposes. They are</entry>
</row>
<row>
<entry>165</entry>
<entry>; not used by host tool.</entry>
</row>
<row>
<entry>166</entry>
<entry>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</entry>
</row>
<row>
<entry>167</entry>
</row>
<row>
<entry>168</entry>
<entry>.global :name:, :name:$rd, :name:$wr, :name:$dtab, :name:$buf</entry>
</row>
<row>
<entry>169</entry>
<entry>.global :name:$rdstshdl, :name:$wrstshdl</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>170</entry>
<entry>.global :name:$rdcurdesc, :name:$rdaddr, :name:$rdsize</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="280PT" align="left"/>
<tbody valign="top">
<row>
<entry>171</entry>
<entry>global :name:$wrcurdesc, :name:$wraddr, :name:$wrsize</entry>
</row>
<row>
<entry>172</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="294PT" align="left"/>
<tbody valign="top">
<row>
<entry>173</entry>
<entry>.if(:cflag: &equals; 0)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="287PT" align="left"/>
<tbody valign="top">
<row>
<entry>174</entry>
<entry>.mexit</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="294PT" align="left"/>
<tbody valign="top">
<row>
<entry>175</entry>
<entry>.endif</entry>
</row>
<row>
<entry>176</entry>
</row>
<row>
<entry>177</entry>
<entry>.if($symcmp(&ldquo;:buf:&rdquo;, &ldquo;&lt;NULL&gt;&rdquo;) &equals; 0)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="280PT" align="left"/>
<tbody valign="top">
<row>
<entry>178</entry>
<entry>GBL_Obj &emsp;:name:$buf, :framesize:*:numframes:,.pip:id:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="28PT" align="left"/>
<colspec colname="3" colwidth="252PT" align="left"/>
<tbody valign="top">
<row>
<entry>179</entry>
<entry>.asg</entry>
<entry>:name:$buf, buf</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="294PT" align="left"/>
<tbody valign="top">
<row>
<entry>180</entry>
<entry>.endif</entry>
</row>
<row>
<entry>181</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="280PT" align="left"/>
<tbody valign="top">
<row>
<entry>182</entry>
<entry>C55_allocateObject isPipAligned,:name:, PIP_SIZE, &ldquo;.pip&rdquo;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="133PT" align="left"/>
<colspec colname="2" colwidth="196PT" align="left"/>
<tbody valign="top">
<row>
<entry>183</entry>
<entry>; Allocate space</entry>
</row>
<row>
<entry>184</entry>
<entry>; for the PIP Object</entry>
</row>
<row>
<entry>185</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="280PT" align="left"/>
<tbody valign="top">
<row>
<entry>186</entry>
<entry>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</entry>
</row>
<row>
<entry>187</entry>
<entry>; allocate space for threshold/framesize &amp; cinit the same ;</entry>
</row>
<row>
<entry>188</entry>
<entry>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</entry>
</row>
<row>
<entry>189</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>190</entry>
<entry>C55_cinitHeader CINITALIGN, isPipAligned, :name:,</entry>
</row>
<row>
<entry></entry>
<entry>PIP_SIZE,DATAPAGE</entry>
</row>
<row>
<entry>191</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="280PT" align="left"/>
<tbody valign="top">
<row>
<entry>192</entry>
<entry>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</entry>
</row>
<row>
<entry>193</entry>
<entry>; Define various ptr values, that would serve to fill the;</entry>
</row>
<row>
<entry>194</entry>
<entry>; the cinit records.</entry>
</row>
<row>
<entry>195</entry>
<entry>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</entry>
</row>
<row>
<entry>196</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="147PT" align="left"/>
<colspec colname="3" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry>197</entry>
<entry>:name:$rd: .set :name: &plus; PIP_O_HDBASE</entry>
<entry>; assign the reader</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>198</entry>
<entry>:name:$rdstshdl  .set :name: &plus; PIP_READSTSHDL; sts handle value.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="77PT" align="left"/>
<colspec colname="3" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry>199</entry>
<entry>:name:$rdcurdesc</entry>
<entry>.set  :name: &plus; PIP_READCURDESC; .reader curdesc</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="77PT" align="left"/>
<colspec colname="3" colwidth="105PT" align="left"/>
<colspec colname="4" colwidth="126PT" align="left"/>
<tbody valign="top">
<row>
<entry>200</entry>
<entry>:name:$rdaddr</entry>
<entry>.set :name: &plus; PIP_READPTR</entry>
<entry>; reader addr</entry>
</row>
<row>
<entry>201</entry>
<entry>:name:$rdsize</entry>
<entry>.set :name: &plus; PIP_READCNT</entry>
<entry>; reader size</entry>
</row>
<row>
<entry>202</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="91PT" align="left"/>
<colspec colname="3" colwidth="105PT" align="left"/>
<colspec colname="4" colwidth="112PT" align="left"/>
<tbody valign="top">
<row>
<entry>203</entry>
<entry>:name:$wr</entry>
<entry>set :name: &plus; PIP_O_TLBASE</entry>
<entry>; assign writer ptr</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="196PT" align="left"/>
<colspec colname="3" colwidth="112PT" align="left"/>
<tbody valign="top">
<row>
<entry>204</entry>
<entry>:name:$wrstshdl .set :name: &plus; PIP_WRITESTSHDL</entry>
<entry>; This is the writer</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>205</entry>
<entry>:name:$wrcurdesc .set :name: &plus; PIP_WRITECURDESC ; .reader curdesc</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="126PT" align="left"/>
<colspec colname="4" colwidth="126PT" align="left"/>
<tbody valign="top">
<row>
<entry>206</entry>
<entry>:name:$wraddr</entry>
<entry>set :name: &plus; PIP_WRITEPTR</entry>
<entry>; reader addr</entry>
</row>
<row>
<entry>207</entry>
<entry>:name:$wrsize</entry>
<entry>.set :name: &plus; PIP_WRITECNT</entry>
<entry>; reader size</entry>
</row>
<row>
<entry>208</entry>
<entry></entry>
<entry></entry>
<entry>; sts handle value.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="252PT" align="left"/>
<tbody valign="top">
<row>
<entry>209</entry>
<entry>:name:$rdfxn</entry>
<entry>set :name: &plus; PIP_READFXNOBJ ; This is the rdrxn</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="140PT" align="left"/>
<colspec colname="4" colwidth="112PT" align="left"/>
<tbody valign="top">
<row>
<entry>210</entry>
<entry>:name:$wrfxn</entry>
<entry>.set :name: &plus; PIP_WRITEFXNOBJ</entry>
<entry>; This is the wrtrfxn</entry>
</row>
<row>
<entry>211</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="294PT" align="left"/>
<tbody valign="top">
<row>
<entry>212</entry>
<entry>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="112PT" align="left"/>
<colspec colname="3" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry>213</entry>
<entry>; Start the cinit recrod</entry>
<entry>;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="294PT" align="left"/>
<tbody valign="top">
<row>
<entry>214</entry>
<entry>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</entry>
</row>
<row>
<entry>215</entry>
</row>
<row>
<entry>216</entry>
<entry>C55_cinitBegin isPipAligned</entry>
</row>
<row>
<entry>217</entry>
</row>
<row>
<entry>218</entry>
<entry>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</entry>
</row>
<row>
<entry>219</entry>
<entry>; cinit reader-side (excluding FXN_Obj &amp; ;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="63PT" align="left"/>
<colspec colname="3" colwidth="49PT" align="left"/>
<colspec colname="4" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry>220</entry>
<entry>; StsPtr) &amp; cinit the</entry>
<entry>same</entry>
<entry>;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>221</entry>
<entry>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="42PT" align="left"/>
<colspec colname="4" colwidth="196PT" align="left"/>
<tbody valign="top">
<row>
<entry>222</entry>
<entry>C55_cinitInt</entry>
<entry>:framesize:</entry>
<entry>; threshold allocation</entry>
</row>
<row>
<entry>223</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="294PT" align="left"/>
<tbody valign="top">
<row>
<entry>224</entry>
<entry>PIPSOCK_cinitObj framesize, :name:$dtab, :name:$wr &plus; PIP_O_FXNOBJ,0, :name:$wr &plus;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>PIP_O_NUMFRAMES, :notifyWriter:, :nwarg0:, :nwarg1:. :stsend:, &ldquo;reader&rdquo;, :name:$sts</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>225</entry>
<entry></entry>
</row>
<row>
<entry>226</entry>
<entry>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="294PT" align="left"/>
<tbody valign="top">
<row>
<entry>227</entry>
<entry>; cinit writer-side (excluding FXN_Obj &amp; ;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="98PT" align="left"/>
<colspec colname="3" colwidth="196PT" align="left"/>
<tbody valign="top">
<row>
<entry>228</entry>
<entry>StsPtr) &amp; cinit the same</entry>
<entry>;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>229</entry>
<entry>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</entry>
</row>
<row>
<entry>230</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="294PT" align="left"/>
<tbody valign="top">
<row>
<entry>231</entry>
<entry>PIPSOCK_cinitObj framesize, :name:$dtab, :name:$rd &plus; PIP_O_FXNOBJ,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>numframes,:name:$rd &plus; PIP_O_NUMFRAMES, :notifyReader:, :nrarg0:, :nrarg1:, :stsend:, &ldquo;writer&rdquo;,</entry>
</row>
<row>
<entry></entry>
<entry>:name:$sts</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="294PT" align="left"/>
<tbody valign="top">
<row>
<entry>232</entry>
<entry></entry>
</row>
<row>
<entry>233</entry>
<entry>C55_cinitEnd isPipAligned</entry>
</row>
<row>
<entry>234</entry>
<entry>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</entry>
</row>
<row>
<entry>235</entry>
<entry>;</entry>
</row>
<row>
<entry>236</entry>
<entry>; put PIP descriptors into .bss section</entry>
</row>
<row>
<entry>237</entry>
<entry>;</entry>
</row>
<row>
<entry>238</entry>
<entry>; addr&lsqb;i&rsqb;</entry>
</row>
<row>
<entry>239</entry>
<entry>; size&lsqb;i&rsqb;</entry>
</row>
<row>
<entry>240</entry>
<entry>; next &lsqb;i&rsqb;</entry>
</row>
<row>
<entry>241</entry>
<entry>;</entry>
</row>
<row>
<entry>242</entry>
<entry>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</entry>
</row>
<row>
<entry>243</entry>
</row>
<row>
<entry>244</entry>
<entry>.global :name:$dtab</entry>
</row>
<row>
<entry>245</entry>
</row>
<row>
<entry>246</entry>
<entry>.bss :name:$dtab, (PIPDESC_SIZE * :numframes:), STD_TARGWORDMAUS,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>isPipdescAligned</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="301PT" align="left"/>
<tbody valign="top">
<row>
<entry>247</entry>
<entry></entry>
</row>
<row>
<entry>248</entry>
<entry>.sect &ldquo;.cinit&rdquo;</entry>
</row>
<row>
<entry>249</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="280PT" align="left"/>
<tbody valign="top">
<row>
<entry>250</entry>
<entry>.var temp0, temp1, boff</entry>
</row>
<row>
<entry>251</entry>
<entry>.eval 0, temp0</entry>
</row>
<row>
<entry>252</entry>
<entry>eval 0, temp1</entry>
</row>
<row>
<entry>253</entry>
<entry>.eval 0, boff</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="28PT" align="left"/>
<colspec colname="3" colwidth="280PT" align="left"/>
<tbody valign="top">
<row>
<entry>254</entry>
<entry>.eval</entry>
<entry>:numframes: * (PIPDESC_SIZE) , temp0</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="280PT" align="left"/>
<tbody valign="top">
<row>
<entry>255</entry>
<entry>.eval &emsp;PIPDESC_A_OBJSIZE , temp1</entry>
</row>
<row>
<entry>256</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="294PT" align="left"/>
<tbody valign="top">
<row>
<entry>257</entry>
<entry>C55_cinitHeader 1, isPipdescAligned, :name:$dtab, :temp0:, 0</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="133PT" align="left"/>
<colspec colname="2" colwidth="196PT" align="left"/>
<tbody valign="top">
<row>
<entry>258</entry>
<entry>; offset to start of next desc.</entry>
</row>
<row>
<entry>259</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="294PT" align="left"/>
<tbody valign="top">
<row>
<entry>260</entry>
<entry>.loop :numframes:-1</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="77PT" align="left"/>
<colspec colname="2" colwidth="133PT" align="left"/>
<colspec colname="3" colwidth="119PT" align="left"/>
<tbody valign="top">
<row>
<entry>261</entry>
<entry>C55_cinitBegin &emsp;isPipdescAligned</entry>
<entry></entry>
</row>
<row>
<entry>262</entry>
<entry>C55_cinitDataPtr :buf:&plus;:boff:</entry>
<entry>; addr&lsqb;i&rsqb;</entry>
</row>
<row>
<entry>263</entry>
<entry>C55_cinitInt &emsp;:framesize:</entry>
<entry>; size &lsqb;i&rsqb;</entry>
</row>
<row>
<entry>264</entry>
<entry>C55_cinitDataPtr :name:$dtab &plus; :temp1:</entry>
<entry>; next &lsqb;i&rsqb;</entry>
</row>
<row>
<entry>265</entry>
<entry>C55_cinitEnd &emsp;isPipdescAligned</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="77PT" align="left"/>
<colspec colname="2" colwidth="252PT" align="left"/>
<tbody valign="top">
<row>
<entry>266</entry>
<entry>.eval :boff:&plus;(:framesize: * (STD_TARGWORDMAUS)), boff</entry>
</row>
<row>
<entry>267</entry>
<entry>.eval :temp1: &plus; (PIPDESC_SIZE * STD_TARGWORDMAUS), temp1</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="294PT" align="left"/>
<tbody valign="top">
<row>
<entry>268</entry>
<entry>.endloop</entry>
</row>
<row>
<entry>269</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="280PT" align="left"/>
<tbody valign="top">
<row>
<entry>270</entry>
<entry>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</entry>
</row>
<row>
<entry>271</entry>
<entry>; cinit data for the very last descriptor triplet</entry>
</row>
<row>
<entry>272</entry>
<entry>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</entry>
</row>
<row>
<entry>273</entry>
</row>
<row>
<entry>274</entry>
<entry>C55_cinitBegin isPipdescAligned</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="105PT" align="left"/>
<colspec colname="3" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry>275</entry>
<entry>C55_cinitDataPtr:buf:&plus;:boff:</entry>
<entry>; addr&lsqb;n&rsqb;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="49PT" align="left"/>
<colspec colname="3" colwidth="70PT" align="left"/>
<colspec colname="4" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry>276</entry>
<entry>C55_cinitInt</entry>
<entry>:framesize:</entry>
<entry>; size&lsqb;n&rsqb;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="105PT" align="left"/>
<colspec colname="3" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry>277</entry>
<entry>C55_cinitDataPtr :name:$dtab</entry>
<entry>; next&lsqb;n&rsqb;</entry>
</row>
<row>
<entry>278</entry>
<entry>C55_cinitEnd isPipdescAligned</entry>
</row>
<row>
<entry>279</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="280PT" align="left"/>
<tbody valign="top">
<row>
<entry>280</entry>
<entry>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</entry>
</row>
<row>
<entry>281</entry>
<entry>; allocate/cinit (via STS_Obj macro) Statistics obj for this PIP</entry>
</row>
<row>
<entry>282</entry>
<entry>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</entry>
</row>
<row>
<entry>283</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="294PT" align="left"/>
<tbody valign="top">
<row>
<entry>284</entry>
<entry>.if ($symcmp(&ldquo;:stsend:&rdquo;, &ldquo;reader&rdquo;) &equals; 0)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="280PT" align="left"/>
<tbody valign="top">
<row>
<entry>285</entry>
<entry>STS_Obj 1, :name:$sts, 0, 0, 0</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="294PT" align="left"/>
<tbody valign="top">
<row>
<entry>286</entry>
<entry>.endif</entry>
</row>
<row>
<entry>287</entry>
<entry>.if($symcmp(&ldquo;:stsend:&rdquo;, &ldquo;writer&rdquo;) &equals; 0)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="280PT" align="left"/>
<tbody valign="top">
<row>
<entry>288</entry>
<entry>STS_Obj 1, :name:$sts, 0, 0, 0</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="294PT" align="left"/>
<tbody valign="top">
<row>
<entry>289</entry>
<entry>.endif</entry>
</row>
<row>
<entry>290</entry>
<entry>.eval PIP$pipCount &plus; 1, PIP$pipCount ; increment the number</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="182PT" align="left"/>
<colspec colname="2" colwidth="147PT" align="left"/>
<tbody valign="top">
<row>
<entry>291</entry>
<entry>; of PIP objects.</entry>
</row>
<row>
<entry>292</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="294PT" align="left"/>
<tbody valign="top">
<row>
<entry>293</entry>
<entry>.endm</entry>
</row>
<row>
<entry>294</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>295</entry>
<entry>;&num; &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals; PIPSOCK_cinitOBj &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;</entry>
</row>
<row>
<entry>296</entry>
<entry>; Create cinit record for PIP sockets</entry>
</row>
<row>
<entry>297</entry>
<entry>;</entry>
</row>
<row>
<entry>298</entry>
<entry>; Parameters</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="77PT" align="left"/>
<colspec colname="3" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry>299</entry>
<entry>; framesize:</entry>
<entry>Size of the frame</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="252PT" align="left"/>
<tbody valign="top">
<row>
<entry>300</entry>
<entry>; curdesc:</entry>
<entry>The value of curdesc</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="77PT" align="left"/>
<colspec colname="3" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry>301</entry>
<entry>; pFxnObj:</entry>
<entry>Pointer to FXN_Obj</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="252PT" align="left"/>
<tbody valign="top">
<row>
<entry>302</entry>
<entry>; pNumFrames:</entry>
<entry>10 Pointer to numFrames</entry>
</row>
<row>
<entry>303</entry>
<entry>; notifyFunc:</entry>
<entry>The PIP notify function</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>304</entry>
<entry>; notifyFuncArg0: First argument of notify function</entry>
</row>
<row>
<entry>305</entry>
<entry>; notifyFuncArg1: Second argument of notify function</entry>
</row>
<row>
<entry>306</entry>
<entry>; stsEnd: The end at which sts obj is attached to PIP</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="63PT" align="left"/>
<colspec colname="3" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry>307</entry>
<entry>;</entry>
<entry>This comes from gconf</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>308</entry>
<entry>; endType &emsp;:Reader/Writer</entry>
</row>
<row>
<entry>309</entry>
<entry>; stsAddr &emsp;:Address of sts object</entry>
</row>
<row>
<entry>310</entry>
<entry>;</entry>
</row>
<row>
<entry>311</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>312</entry>
<entry>;&num; Preconditions:</entry>
</row>
<row>
<entry>313</entry>
<entry>;&num; &ensp;none</entry>
</row>
<row>
<entry>314</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>315</entry>
<entry>;&num; Postconditions:</entry>
</row>
<row>
<entry>316</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>317</entry>
<entry>;&num; Constraints and Calling Environment:</entry>
</row>
<row>
<entry>318</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>319</entry>
</row>
<row>
<entry>320</entry>
<entry>PIPSOCK_cinitObj &emsp;.macro frameSize, curDesc, pFxnObj, numFrames, pNumFrames,</entry>
</row>
<row>
<entry></entry>
<entry>notifyFunc , notifyFuncArg0, notifyFuncArg1, stsEnd, endType, stsAddr</entry>
</row>
<row>
<entry>321</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="280PT" align="left"/>
<tbody valign="top">
<row>
<entry>322</entry>
<entry>;CHK_nargs &ldquo;PIPSOCK&rdquo;, stsAddr</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>323</entry>
<entry>C55_cinitBegin &emsp;isPipsockAligned</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="105PT" align="left"/>
<colspec colname="3" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry>324</entry>
<entry>C55_cinitDataPtr 0</entry>
<entry>; take-probe</entry>
</row>
<row>
<entry>325</entry>
<entry>C55_cinitDataPtr 0</entry>
<entry>; addr</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="84PT" align="left"/>
<colspec colname="3" colwidth="196PT" align="left"/>
<tbody valign="top">
<row>
<entry>326</entry>
<entry>C55_cinitInt &emsp;frameSize</entry>
<entry>; size</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="105PT" align="left"/>
<colspec colname="3" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry>327</entry>
<entry>C55_cinitDataPtr curDesc</entry>
<entry>; curdesc</entry>
</row>
<row>
<entry>328</entry>
<entry>C55_cinitDataPtr pFxnObj</entry>
<entry>; pFxnOBj</entry>
</row>
<row>
<entry>329</entry>
<entry>C55_cinitInt &emsp;numFrames</entry>
<entry>; reader numframes</entry>
</row>
<row>
<entry>330</entry>
<entry>C55_cinitDataPtr 0</entry>
<entry>; reader give-probe</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="280PT" align="left"/>
<tbody valign="top">
<row>
<entry>331</entry>
<entry>C55_cinitDataPtrpNum Frames &emsp;; writer pnumframes</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="189PT" align="left"/>
<colspec colname="2" colwidth="140PT" align="left"/>
<tbody valign="top">
<row>
<entry>332</entry>
<entry>;(&equals;&amp;writerNumFrames)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="294PT" align="left"/>
<tbody valign="top">
<row>
<entry>333</entry>
<entry>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="280PT" align="left"/>
<tbody valign="top">
<row>
<entry>334</entry>
<entry>; Generate value section for the FXN_object;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="294PT" align="left"/>
<tbody valign="top">
<row>
<entry>335</entry>
<entry>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</entry>
</row>
<row>
<entry>336</entry>
</row>
<row>
<entry>337</entry>
<entry>FXN_cinitObj notifyFunc, notifyFuncArg0, notifyFuncArg1</entry>
</row>
<row>
<entry>338</entry>
</row>
<row>
<entry>339</entry>
<entry>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="280PT" align="left"/>
<tbody valign="top">
<row>
<entry>340</entry>
<entry>; Continue Filling the rest of the object &emsp;;</entry>
</row>
<row>
<entry>341</entry>
<entry>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</entry>
</row>
<row>
<entry>342</entry>
</row>
<row>
<entry>343</entry>
<entry>if ($symcmp(&ldquo;:stsEnd:&rdquo;, &ldquo;:endType:&rdquo;) &equals; 0)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="287PT" align="left"/>
<tbody valign="top">
<row>
<entry>344</entry>
<entry>C55_cinitDataPtr stsAddr</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="294PT" align="left"/>
<tbody valign="top">
<row>
<entry>345</entry>
<entry>.else</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="287PT" align="left"/>
<tbody valign="top">
<row>
<entry>346</entry>
<entry>C55_cinitDataPtr 0</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="294PT" align="left"/>
<tbody valign="top">
<row>
<entry>347</entry>
<entry>.endif</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="287PT" align="left"/>
<tbody valign="top">
<row>
<entry>348</entry>
<entry>C55_cinitEnd &emsp;isPipsockAligned</entry>
</row>
<row>
<entry>349</entry>
<entry>.endm</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>350</entry>
<entry>;</entry>
</row>
<row>
<entry>351</entry>
<entry>;&num; &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals; PIP_config &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;</entry>
</row>
<row>
<entry>352</entry>
<entry>;</entry>
</row>
<row>
<entry>353</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>354</entry>
<entry>;&num; Preconditions:</entry>
</row>
<row>
<entry>355</entry>
<entry>;&num; &ensp;none</entry>
</row>
<row>
<entry>356</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>357</entry>
<entry>;&num; Postconditions:</entry>
</row>
<row>
<entry>358</entry>
<entry>;&num; &ensp;none</entry>
</row>
<row>
<entry>359</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>360</entry>
<entry>;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="301PT" align="left"/>
<tbody valign="top">
<row>
<entry>361</entry>
<entry>.asg &ldquo;&rdquo;, PIP_config$regs</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>362</entry>
<entry>PIP_config .macro _gNumEmbed, _gNextId</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="21PT" align="left"/>
<colspec colname="3" colwidth="77PT" align="left"/>
<colspec colname="4" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry>363</entry>
<entry>.asg</entry>
<entry>0, PIP$pipCount</entry>
<entry>; This indicate the</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="168PT" align="left"/>
<colspec colname="2" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry>364</entry>
<entry>; the number of</entry>
</row>
<row>
<entry>365</entry>
<entry>; PIP objects.</entry>
</row>
<row>
<entry>366</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="301PT" align="left"/>
<tbody valign="top">
<row>
<entry>367</entry>
<entry>.endm</entry>
</row>
<row>
<entry>368</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>369</entry>
<entry>;</entry>
</row>
<row>
<entry>370</entry>
<entry>;&num; &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;PIP_end &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;</entry>
</row>
<row>
<entry>371</entry>
<entry>; Invoked at the end of all other configuration</entry>
</row>
<row>
<entry>372</entry>
<entry>; declarations.</entry>
</row>
<row>
<entry>373</entry>
<entry>;</entry>
</row>
<row>
<entry>374</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>375</entry>
<entry>;&num; Preconditions:</entry>
</row>
<row>
<entry>376</entry>
<entry>;&num; &ensp;none</entry>
</row>
<row>
<entry>377</entry>
<entry>;&num; Postconditions:</entry>
</row>
<row>
<entry>378</entry>
<entry>;&num; &ensp;none</entry>
</row>
<row>
<entry>379</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>380</entry>
<entry>;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="301PT" align="left"/>
<tbody valign="top">
<row>
<entry>381</entry>
<entry>.asg &ldquo;&rdquo;, PIP end$regs</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>382</entry>
<entry>PIP_end .macro</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="301PT" align="left"/>
<tbody valign="top">
<row>
<entry>383</entry>
<entry>.endm</entry>
</row>
<row>
<entry>384</entry>
</row>
<row>
<entry>385</entry>
<entry>;</entry>
</row>
<row>
<entry>386</entry>
<entry>;&num; &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals; PIP_int &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;</entry>
</row>
<row>
<entry>387</entry>
<entry>;</entry>
</row>
<row>
<entry>388</entry>
<entry>;&num; Preconditions:</entry>
</row>
<row>
<entry>389</entry>
<entry>;&num; &ensp;none</entry>
</row>
<row>
<entry>390</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>391</entry>
<entry>;&num; Postconditions:</entry>
</row>
<row>
<entry>392</entry>
<entry>;&num; &ensp;none</entry>
</row>
<row>
<entry>393</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>394</entry>
<entry>;</entry>
</row>
<row>
<entry>395</entry>
<entry>.asg &ldquo;&rdquo;, PIP_init$regs</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>396</entry>
<entry>PIP_int .macro</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="301PT" align="left"/>
<tbody valign="top">
<row>
<entry>397</entry>
<entry>.endm</entry>
</row>
<row>
<entry>398</entry>
</row>
<row>
<entry>399</entry>
<entry>;</entry>
</row>
<row>
<entry>400</entry>
<entry>;&num; &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals; PIP_alloc &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;</entry>
</row>
<row>
<entry>401</entry>
<entry>;</entry>
</row>
<row>
<entry>402</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>403</entry>
<entry>:&num; Preconditions:</entry>
</row>
<row>
<entry>404</entry>
<entry>;&num; xar0 &equals; address of the pipe object</entry>
</row>
<row>
<entry>405</entry>
<entry>;&num; pipe.writerNumFrames &gt; 0</entry>
</row>
<row>
<entry>406</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>407</entry>
<entry>;&num; Postconditions:</entry>
</row>
<row>
<entry>408</entry>
<entry>;&num; &ensp;none</entry>
</row>
<row>
<entry>409</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>410</entry>
<entry>;&num; Constraints and Calling Environment:</entry>
</row>
<row>
<entry>411</entry>
<entry>;&num; &ensp;Before calling PIP_alloc a function should check the</entry>
</row>
<row>
<entry>412</entry>
<entry>;&num; &ensp;writerNumFrames member of the PIP_Obj structure to make</entry>
</row>
<row>
<entry>413</entry>
<entry>;&num; &ensp;sure it is greater than 0 (at least one empty frame is</entry>
</row>
<row>
<entry>414</entry>
<entry>:&num; &ensp;available)</entry>
</row>
<row>
<entry>415</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>416</entry>
<entry>;&num; Note:</entry>
</row>
<row>
<entry>417</entry>
<entry>;&num; &ensp;registers used by &lsquo;notify Writer&rsquo; functions might be modified</entry>
</row>
<row>
<entry>418</entry>
<entry>;&num; &ensp;too. Since such a function can be &ldquo;C&rdquo;, it&apos;d imply all registers</entry>
</row>
<row>
<entry>419</entry>
<entry>;&num; &ensp;considered as trashable by C compiler</entry>
</row>
<row>
<entry>420</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>421</entry>
<entry>;</entry>
</row>
<row>
<entry>422</entry>
<entry>.asg &ldquo;xar0,PIP_F_take$regs&rdquo;, PIP_alloc$regs</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="63PT" align="left"/>
<colspec colname="3" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry>423</entry>
<entry>PIP_alloc</entry>
<entry>.macro dummy</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="301PT" align="left"/>
<tbody valign="top">
<row>
<entry>424</entry>
<entry>CHK_void &emsp;PIP_alloc, dummy</entry>
</row>
<row>
<entry>425</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="154PT" align="left"/>
<colspec colname="3" colwidth="126PT" align="left"/>
<tbody valign="top">
<row>
<entry>426</entry>
<entry>.if(.MNEMONIC)</entry>
<entry>;if MNEMONIC assembler</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="77PT" align="left"/>
<colspec colname="2" colwidth="105PT" align="left"/>
<colspec colname="3" colwidth="147PT" align="left"/>
<tbody valign="top">
<row>
<entry>427</entry>
<entry>aadd &num;PIP_EMPTYBUFS, ar0</entry>
<entry>; ar0 &equals; &amp;writerNumFrames</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="154PT" align="left"/>
<colspec colname="3" colwidth="126PT" align="left"/>
<tbody valign="top">
<row>
<entry>428</entry>
<entry>.else</entry>
<entry>;if ALGEBRAIC</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="77PT" align="left"/>
<colspec colname="2" colwidth="105PT" align="left"/>
<colspec colname="3" colwidth="147PT" align="left"/>
<tbody valign="top">
<row>
<entry>429</entry>
<entry>mar(ar0 &plus; &num;PIP_EMPTYBUFS)</entry>
<entry>; ar0 &equals; &amp;writerNumFrames</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="154PT" align="left"/>
<colspec colname="3" colwidth="126PT" align="left"/>
<tbody valign="top">
<row>
<entry>430</entry>
<entry>.endif</entry>
<entry>; endif MNEMONIC</entry>
</row>
<row>
<entry>431</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="154PT" align="left"/>
<colspec colname="3" colwidth="147PT" align="left"/>
<tbody valign="top">
<row>
<entry>432</entry>
<entry>call PIP_F_take</entry>
<entry>; call PIP_F_take</entry>
</row>
<row>
<entry>433</entry>
</row>
<row>
<entry>434</entry>
<entry>.endm</entry>
</row>
<row>
<entry>435</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>436</entry>
<entry>;</entry>
</row>
<row>
<entry>437</entry>
<entry>;&num; &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals; PIP_put &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;</entry>
</row>
<row>
<entry>438</entry>
<entry>;</entry>
</row>
<row>
<entry>439</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>440</entry>
<entry>;&num; Preconditions for large model:</entry>
</row>
<row>
<entry>441</entry>
<entry>;&num; &ensp;xar0 &equals; address of the pipe object</entry>
</row>
<row>
<entry>442</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>443</entry>
<entry>;&num; Postconditions:</entry>
</row>
<row>
<entry>444</entry>
<entry>;&num; &ensp;none</entry>
</row>
<row>
<entry>445</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>446</entry>
<entry>;&num; Note:</entry>
</row>
<row>
<entry>447</entry>
<entry>;&num; &ensp;registers used by &lsquo;notifyReader&rsquo; functions might be modified too.</entry>
</row>
<row>
<entry>448</entry>
<entry>;&num; &ensp;Since such a function can be &ldquo;C&rdquo;, it&apos;d imply all registers</entry>
</row>
<row>
<entry>449</entry>
<entry>;&num; &ensp;considered as trashable by C compiler</entry>
</row>
<row>
<entry>450</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>451</entry>
<entry>;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="301PT" align="left"/>
<tbody valign="top">
<row>
<entry>452</entry>
<entry>.asg &ldquo;xar0,:PIP_F give$regs:&rdquo;, PIP_put$regs</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="252PT" align="left"/>
<tbody valign="top">
<row>
<entry>453</entry>
<entry>PIP_put</entry>
<entry>.macro dummy</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="49PT" align="left"/>
<colspec colname="3" colwidth="252PT" align="left"/>
<tbody valign="top">
<row>
<entry>454</entry>
<entry>CHK_void</entry>
<entry>PIP_put, dummy</entry>
</row>
<row>
<entry>455</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="63PT" align="left"/>
<colspec colname="2" colwidth="84PT" align="left"/>
<colspec colname="3" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry>456</entry>
<entry>.if (MNEMONIC)</entry>
<entry>;if MNEMONIC assembler</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="84PT" align="left"/>
<colspec colname="2" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry>457</entry>
<entry>aadd &num;(PIP_O_TLBASE &plus; PIP_O_CURDESC),ar0</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="147PT" align="left"/>
<colspec colname="2" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry>458</entry>
<entry>; ar0 &equals; &amp;writerCurdesc</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="63PT" align="left"/>
<colspec colname="2" colwidth="84PT" align="left"/>
<colspec colname="3" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry>459</entry>
<entry>.else</entry>
<entry>; if ALGEBRAIC</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="98PT" align="left"/>
<colspec colname="2" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry>460</entry>
<entry>mar(ar0 &plus; &num;(PIP_O_TLBASE &plus; PIP__O_CURDESC))</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="63PT" align="left"/>
<colspec colname="2" colwidth="266PT" align="left"/>
<tbody valign="top">
<row>
<entry>461</entry>
<entry>; ar0 &equals; &amp;writerCurdesc</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="63PT" align="left"/>
<colspec colname="2" colwidth="84PT" align="left"/>
<colspec colname="3" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry>462</entry>
<entry>endif</entry>
<entry>; endif MNEMONIC</entry>
</row>
<row>
<entry>463</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="105PT" align="left"/>
<colspec colname="3" colwidth="196PT" align="left"/>
<tbody valign="top">
<row>
<entry>464</entry>
<entry>call PIP_F_give</entry>
<entry>; call PIP_F_give</entry>
</row>
<row>
<entry>465</entry>
</row>
<row>
<entry>466</entry>
<entry>.endm</entry>
</row>
<row>
<entry>467</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>468</entry>
<entry>;</entry>
</row>
<row>
<entry>469</entry>
<entry>;&num; &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals; PIP_get &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;</entry>
</row>
<row>
<entry>470</entry>
<entry>;</entry>
</row>
<row>
<entry>471</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>472</entry>
<entry>;&num; Preconditions for large:</entry>
</row>
<row>
<entry>473</entry>
<entry>;&num; xar0 &equals; address of the pipe object</entry>
</row>
<row>
<entry>474</entry>
<entry>;&num; pipe.readerNumFrames &gt; 0</entry>
</row>
<row>
<entry>475</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>476</entry>
<entry>;&num; Postconditions:</entry>
</row>
<row>
<entry>477</entry>
<entry>;&num; &ensp;none</entry>
</row>
<row>
<entry>478</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>479</entry>
<entry>;&num; Constraints and Calling Environment:</entry>
</row>
<row>
<entry>480</entry>
<entry>;&num; &ensp;Before calling PIP_get, a function should check the</entry>
</row>
<row>
<entry>481</entry>
<entry>;&num; &ensp;readerNumFrames member of the PIP_Obj structure to make sure it</entry>
</row>
<row>
<entry>482</entry>
<entry>;&num; &ensp;is greater than 0 (at least one full frame is available)</entry>
</row>
<row>
<entry>483</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>484</entry>
<entry>;&num; Note:</entry>
</row>
<row>
<entry>485</entry>
<entry>;&num; &ensp;registers used by &lsquo;notifyReader&rsquo; functions might be</entry>
</row>
<row>
<entry>486</entry>
<entry>;&num; &ensp;modified too. Since such a function can be &ldquo;C&rdquo;, it&apos;d imply</entry>
</row>
<row>
<entry>487</entry>
<entry>;&num; &ensp;all registers considered as trashable by C compiler</entry>
</row>
<row>
<entry>488</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>489</entry>
<entry>;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="301PT" align="left"/>
<tbody valign="top">
<row>
<entry>490</entry>
<entry>.asg &ldquo;xar0,:PIP_F_take$regs:&rdquo;, PIP_get$regs</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="252PT" align="left"/>
<tbody valign="top">
<row>
<entry>491</entry>
<entry>PIP_get</entry>
<entry>.macro dummy</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="49PT" align="left"/>
<colspec colname="3" colwidth="252PT" align="left"/>
<tbody valign="top">
<row>
<entry>492</entry>
<entry>CHK_void</entry>
<entry>PIP_get, dummy</entry>
</row>
<row>
<entry>493</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="126PT" align="left"/>
<colspec colname="3" colwidth="154PT" align="left"/>
<tbody valign="top">
<row>
<entry>494</entry>
<entry>.if(.MNEMONIC)</entry>
<entry>;if MNEMONIC assembler</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="63PT" align="left"/>
<colspec colname="2" colwidth="98PT" align="left"/>
<colspec colname="3" colwidth="168PT" align="left"/>
<tbody valign="top">
<row>
<entry>495</entry>
<entry>aadd &num;PIP_FULLBUFS ,ar0</entry>
<entry>; ar0 &equals; &amp;readerNumFrames</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="126PT" align="left"/>
<colspec colname="3" colwidth="154PT" align="left"/>
<tbody valign="top">
<row>
<entry>496</entry>
<entry>.else</entry>
<entry>:if ALGEBRAIC</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="63PT" align="left"/>
<colspec colname="2" colwidth="98PT" align="left"/>
<colspec colname="3" colwidth="168PT" align="left"/>
<tbody valign="top">
<row>
<entry>497</entry>
<entry>mar(ar0 &plus; &num;PIP_FULLBUFS)</entry>
<entry>; ar0 &equals; &amp;readerNumFrames</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="280PT" align="left"/>
<tbody valign="top">
<row>
<entry>498</entry>
<entry>.endif</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="126PT" align="left"/>
<colspec colname="3" colwidth="168PT" align="left"/>
<tbody valign="top">
<row>
<entry>499</entry>
<entry>call &emsp;PIP_F take</entry>
<entry>; call PIP_F_take</entry>
</row>
<row>
<entry>500</entry>
</row>
<row>
<entry>501</entry>
<entry>.endm</entry>
</row>
<row>
<entry>502</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>503</entry>
<entry>;</entry>
</row>
<row>
<entry>504</entry>
<entry>;&num; &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals; PIP_free &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;</entry>
</row>
<row>
<entry>505</entry>
<entry>;</entry>
</row>
<row>
<entry>506</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>507</entry>
<entry>;&num; Preconditions:</entry>
</row>
<row>
<entry>508</entry>
<entry>;&num; &ensp;xar0 &equals; address of the pipe object</entry>
</row>
<row>
<entry>509</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>510</entry>
<entry>;&num; Postconditions:</entry>
</row>
<row>
<entry>511</entry>
<entry>;&num; &ensp;none</entry>
</row>
<row>
<entry>512</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>513</entry>
<entry>;&num; Note:</entry>
</row>
<row>
<entry>514</entry>
<entry>;&num; &ensp;registers used by &lsquo;notify Writer&rsquo; functions might be</entry>
</row>
<row>
<entry>515</entry>
<entry>;&num; &ensp;modified too. Since such a function can be &ldquo;C&rdquo;,</entry>
</row>
<row>
<entry>516</entry>
<entry>;&num; &ensp;all registers considered as trashable by C compiler</entry>
</row>
<row>
<entry>517</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>518</entry>
<entry>;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="301PT" align="left"/>
<tbody valign="top">
<row>
<entry>519</entry>
<entry>.asg &ldquo;xar0,:PIP_F give$regs:&rdquo;, PIP_free$regs</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>520</entry>
<entry>PIP_free .macro dummy</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="301PT" align="left"/>
<tbody valign="top">
<row>
<entry>521</entry>
<entry>CHK_void PIP_free, dummy</entry>
</row>
<row>
<entry>522</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="112PT" align="left"/>
<colspec colname="3" colwidth="168PT" align="left"/>
<tbody valign="top">
<row>
<entry>523</entry>
<entry>.if(.MNEMONIC)</entry>
<entry>;if MNEMONIC assembler</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="63PT" align="left"/>
<colspec colname="2" colwidth="266PT" align="left"/>
<tbody valign="top">
<row>
<entry>524</entry>
<entry>mar(ar0 &plus; &num;(PIP_O_HDBASE &plus; PIP_O_CURDESC))</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="161PT" align="left"/>
<colspec colname="2" colwidth="168PT" align="left"/>
<tbody valign="top">
<row>
<entry>525</entry>
<entry>; ar0 &equals; &amp;readerCurdesc</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="280PT" align="left"/>
<tbody valign="top">
<row>
<entry>526</entry>
<entry>.else</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="63PT" align="left"/>
<colspec colname="2" colwidth="266PT" align="left"/>
<tbody valign="top">
<row>
<entry>527</entry>
<entry>mar(ar0 &plus; &num;(PIP_O_HDBASE &plus; PIP_O_CURDESC))</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="161PT" align="left"/>
<colspec colname="2" colwidth="168PT" align="left"/>
<tbody valign="top">
<row>
<entry>528</entry>
<entry>; ar0 &equals; &amp;readerCurdesc</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="280PT" align="left"/>
<tbody valign="top">
<row>
<entry>529</entry>
<entry>.endif</entry>
</row>
<row>
<entry>530</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="98PT" align="left"/>
<colspec colname="3" colwidth="196PT" align="left"/>
<tbody valign="top">
<row>
<entry>531</entry>
<entry>call &emsp;PIP_F_give</entry>
<entry>; call PIP_F_give</entry>
</row>
<row>
<entry>532</entry>
</row>
<row>
<entry>533</entry>
<entry>.endm</entry>
</row>
<row>
<entry>534</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>535</entry>
<entry>;</entry>
</row>
<row>
<entry>536</entry>
<entry>,&num; &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals; PIP_startup &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;</entry>
</row>
<row>
<entry>537</entry>
<entry>;</entry>
</row>
<row>
<entry>538</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>539</entry>
<entry>;&num; Preconditions:</entry>
</row>
<row>
<entry>540</entry>
<entry>;&num; &ensp;none</entry>
</row>
<row>
<entry>541</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>542</entry>
<entry>;&num; Postconditions:</entry>
</row>
<row>
<entry>543</entry>
<entry>;&num; &ensp;none</entry>
</row>
<row>
<entry>544</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>545</entry>
<entry>;&num; Dependencies:</entry>
</row>
<row>
<entry>546</entry>
<entry>;&num; &ensp;Must come before HWI_startup to allow pipes to be ready</entry>
</row>
<row>
<entry>547</entry>
<entry>;&num; &ensp;before ISRs are taken and I/O starts.</entry>
</row>
<row>
<entry>548</entry>
<entry>;&num; &ensp;Note: SWI scheduler is not yet enabled as we walk through</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="28PT" align="left"/>
<colspec colname="3" colwidth="280PT" align="left"/>
<tbody valign="top">
<row>
<entry>549</entry>
<entry>;&num;</entry>
<entry>each of the configured PIP objects and call</entry>
</row>
<row>
<entry>550</entry>
<entry>;&num;</entry>
<entry>their respective notifyWriter(nwarg0, nwarg1)</entry>
</row>
<row>
<entry>551</entry>
<entry>;&num;</entry>
<entry>functions.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>552</entry>
<entry>;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="280PT" align="left"/>
<tbody valign="top">
<row>
<entry>553</entry>
<entry>.asg &ldquo;xar0,:PIP_F_start$regs:&rdquo;, PIP_startup$regs</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="56PT" align="left"/>
<colspec colname="3" colwidth="252PT" align="left"/>
<tbody valign="top">
<row>
<entry>554</entry>
<entry>PIP_startup</entry>
<entry>macro dummy</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="49PT" align="left"/>
<colspec colname="3" colwidth="252PT" align="left"/>
<tbody valign="top">
<row>
<entry>555</entry>
<entry>CHK_void</entry>
<entry>PIP_startup, dummy</entry>
</row>
<row>
<entry>556</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="301PT" align="left"/>
<tbody valign="top">
<row>
<entry>557</entry>
<entry>; expand only if some PIP objects are configured</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="35PT" align="left"/>
<colspec colname="3" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry>558</entry>
<entry>.var</entry>
<entry>pipcount</entry>
</row>
<row>
<entry>559</entry>
<entry>.eval</entry>
<entry>PIP$pipCount, pipcount</entry>
</row>
<row>
<entry>560</entry>
<entry>asg</entry>
<entry>&ldquo;&num;:pipcount:&rdquo;, pipcount</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="112PT" align="left"/>
<colspec colname="3" colwidth="168PT" align="left"/>
<tbody valign="top">
<row>
<entry>561</entry>
<entry>.if (.MNEMONIC)</entry>
<entry>;if MNEMONIC assembler</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="63PT" align="left"/>
<colspec colname="2" colwidth="266PT" align="left"/>
<tbody valign="top">
<row>
<entry>562</entry>
<entry>.if((PIP$ &plus; PIP_gNumEmbed) &excl;&equals; 0); if PIP objects exits</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="77PT" align="left"/>
<colspec colname="2" colwidth="252PT" align="left"/>
<tbody valign="top">
<row>
<entry>563</entry>
<entry>.if($isdefed(&ldquo;_large_model&rdquo;)); if large model</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="91PT" align="left"/>
<colspec colname="2" colwidth="238PT" align="left"/>
<tbody valign="top">
<row>
<entry>564</entry>
<entry>mov pipcount, *(&num;PIP_D_tablen)</entry>
</row>
<row>
<entry>565</entry>
<entry>mov dbl(*(&num;PIP_D_tabbeg)),xar0</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="168PT" align="left"/>
<colspec colname="2" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry>566</entry>
<entry>; load xar0 with</entry>
</row>
<row>
<entry>567</entry>
<entry>; address of</entry>
</row>
<row>
<entry>568</entry>
<entry>; 1st PIP_Obj</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="77PT" align="left"/>
<colspec colname="2" colwidth="91PT" align="left"/>
<colspec colname="3" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry>569</entry>
<entry>.else</entry>
<entry>; if small model</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="91PT" align="left"/>
<colspec colname="2" colwidth="238PT" align="left"/>
<tbody valign="top">
<row>
<entry>570</entry>
<entry>mov pipcount, *abs16(&num;PIP_D_tablen)</entry>
</row>
<row>
<entry>571</entry>
<entry>mov *abs16(&num;PIP_D_tabbeg), xar0</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="168PT" align="left"/>
<colspec colname="2" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry>572</entry>
<entry>; load ar0 with address</entry>
</row>
<row>
<entry>573</entry>
<entry>; of; 1st PIP_Obj</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="77PT" align="left"/>
<colspec colname="2" colwidth="77PT" align="left"/>
<colspec colname="3" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry>574</entry>
<entry>.endif</entry>
<entry>; endif large model</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="105PT" align="left"/>
<colspec colname="3" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry>575</entry>
<entry>call PIP_F_start</entry>
<entry>; walk thru&apos; table of</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="168PT" align="left"/>
<colspec colname="2" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry>576</entry>
<entry>; PIPs &amp; start&apos;em up</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="77PT" align="left"/>
<colspec colname="2" colwidth="77PT" align="left"/>
<colspec colname="3" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry>577</entry>
<entry>.endif</entry>
<entry>; endif PIP$</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="133PT" align="left"/>
<colspec colname="3" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry>578</entry>
<entry>.else</entry>
<entry>; if ALGREBRAIC</entry>
</row>
<row>
<entry>579</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="77PT" align="left"/>
<colspec colname="2" colwidth="252PT" align="left"/>
<tbody valign="top">
<row>
<entry>580</entry>
<entry>.if((PIP$ &plus; PIP_gNumEmbed) &excl;&equals; 0); if PIP objects exits</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="98PT" align="left"/>
<colspec colname="2" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry>581</entry>
<entry>.if($isdefed(&ldquo;_large_model&rdquo;)); if large model</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="119PT" align="left"/>
<colspec colname="2" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry>582</entry>
<entry>*(&num;PIP_D_tablen) &equals; pipcount</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="98PT" align="left"/>
<colspec colname="2" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry>583</entry>
<entry>xar0 &equals; dbl(*(&num;PIP_D_tabbeg))</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="154PT" align="left"/>
<colspec colname="2" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry>584</entry>
<entry>;load xar0 with</entry>
</row>
<row>
<entry>585</entry>
<entry>; address of</entry>
</row>
<row>
<entry>586</entry>
<entry>; 1st PIP_Obj</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="98PT" align="left"/>
<colspec colname="2" colwidth="70PT" align="left"/>
<colspec colname="3" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry>587</entry>
<entry>.else</entry>
<entry>; if small model</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="112PT" align="left"/>
<colspec colname="2" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>588</entry>
<entry>*abs16(&num;PIP_D_tablen) &equals; pipcount</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="98PT" align="left"/>
<colspec colname="2" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry>589</entry>
<entry>ar0 &equals; *abs16(&num;PIP_D_tabbeg)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="154PT" align="left"/>
<colspec colname="2" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry>590</entry>
<entry>;load ar0 with address</entry>
</row>
<row>
<entry>591</entry>
<entry>;of ; 1st PIP_Obj</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="98PT" align="left"/>
<colspec colname="2" colwidth="35PT" align="left"/>
<colspec colname="3" colwidth="196PT" align="left"/>
<tbody valign="top">
<row>
<entry>592</entry>
<entry>.endif</entry>
<entry>; endif large model</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="294PT" align="left"/>
<tbody valign="top">
<row>
<entry>593</entry>
<entry>call  PIP_F_start; walk thru&apos; table of</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="154PT" align="left"/>
<colspec colname="2" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry>594</entry>
<entry>; PIPs &amp; start&apos;em up</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="84PT" align="left"/>
<colspec colname="3" colwidth="196PT" align="left"/>
<tbody valign="top">
<row>
<entry>595</entry>
<entry>.endif</entry>
<entry>; endif PIP$</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="105PT" align="left"/>
<colspec colname="3" colwidth="196PT" align="left"/>
<tbody valign="top">
<row>
<entry>596</entry>
<entry>.endif</entry>
<entry>; endif MNEMONIC</entry>
</row>
<row>
<entry>597</entry>
</row>
<row>
<entry>598</entry>
<entry>.endm</entry>
</row>
<row>
<entry>599</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>600</entry>
<entry>;</entry>
</row>
<row>
<entry>601</entry>
<entry>;&num; &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals; PIP_readprobeSET &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;</entry>
</row>
<row>
<entry>602</entry>
<entry>; Attach named probe to the named pipe&apos;s reader</entry>
</row>
<row>
<entry>603</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>604</entry>
<entry>;&num; Preconditions:</entry>
</row>
<row>
<entry>605</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>606</entry>
<entry>;&num; Postconditions:</entry>
</row>
<row>
<entry>607</entry>
<entry>;&num; &ensp;none</entry>
</row>
<row>
<entry>608</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>609</entry>
</row>
<row>
<entry>610</entry>
<entry>.asg &emsp;&ldquo;&rdquo;, PIP_readprobeSET$regs</entry>
</row>
<row>
<entry>611</entry>
<entry>PIP_readprobeSET .macro dummy</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="98PT" align="left"/>
<colspec colname="2" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry>612</entry>
<entry>.wmsg &ldquo;PIP_readprobeSET not implemented for c55x&rdquo;</entry>
</row>
<row>
<entry>613</entry>
<entry>.endm</entry>
</row>
<row>
<entry>614</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>615</entry>
<entry>;</entry>
</row>
<row>
<entry>616</entry>
<entry>;&num; &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals; PIP_readprobeCLR &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;</entry>
</row>
<row>
<entry>617</entry>
<entry>; disable probing on a pipe&apos;s reader</entry>
</row>
<row>
<entry>618</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>619</entry>
<entry>;&num; Preconditions:</entry>
</row>
<row>
<entry>620</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>621</entry>
<entry>;&num; Postconditions:</entry>
</row>
<row>
<entry>622</entry>
<entry>;&num; &ensp;none</entry>
</row>
<row>
<entry>623</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>624</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="301PT" align="left"/>
<tbody valign="top">
<row>
<entry>625</entry>
<entry>asg &ldquo;&rdquo;, PIP_readprobeCLR$regs</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>626</entry>
<entry>PIP_readprobeCLR .macro dummy</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="98PT" align="left"/>
<colspec colname="2" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry>627</entry>
<entry>.wmsg &ldquo;PIP_readprobeCLR not implemented for c55x&rdquo;</entry>
</row>
<row>
<entry>628</entry>
<entry>.endm</entry>
</row>
<row>
<entry>629</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>630</entry>
<entry>;</entry>
</row>
<row>
<entry>631</entry>
<entry>;&num; &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals; PIP_writeprobeSET &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;</entry>
</row>
<row>
<entry>632</entry>
<entry>; Attach named probe to the named pipe&apos;s writer</entry>
</row>
<row>
<entry>633</entry>
<entry>;</entry>
</row>
<row>
<entry>634</entry>
<entry>;&num; Preconditions:</entry>
</row>
<row>
<entry>635</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>636</entry>
<entry>;&num; Postconditions:</entry>
</row>
<row>
<entry>637</entry>
<entry>;&num; &ensp;none</entry>
</row>
<row>
<entry>638</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>639</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="301PT" align="left"/>
<tbody valign="top">
<row>
<entry>640</entry>
<entry>.asg &ensp;&ldquo;&rdquo;, PIP_writeprobeSET$regs</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>641</entry>
<entry>PIP_writeprobeSET .macro dummy</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="77PT" align="left"/>
<colspec colname="2" colwidth="252PT" align="left"/>
<tbody valign="top">
<row>
<entry>642</entry>
<entry>.wmsg &ldquo;PIP_writeprobeSET not implemented for c55x&rdquo;</entry>
</row>
<row>
<entry>643</entry>
<entry>.endm</entry>
</row>
<row>
<entry>644</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>645</entry>
<entry>;</entry>
</row>
<row>
<entry>646</entry>
<entry>;&num; &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals; PIP_writeprobeCLR &equals;&equals;&equals;&equals;&equals;&equals;&equals;&equals;</entry>
</row>
<row>
<entry>647</entry>
<entry>; disable probing on a pipe&apos;s writer</entry>
</row>
<row>
<entry>648</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>649</entry>
<entry>;&num; Preconditions:</entry>
</row>
<row>
<entry>650</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>651</entry>
<entry>;&num; Postconditions:</entry>
</row>
<row>
<entry>652</entry>
<entry>;&num; &ensp;none</entry>
</row>
<row>
<entry>653</entry>
<entry>;&num;</entry>
</row>
<row>
<entry>654</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="301PT" align="left"/>
<tbody valign="top">
<row>
<entry>655</entry>
<entry>.asg &ldquo;&rdquo;, PIP_writeprobeCLR$regs</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21PT" align="left"/>
<colspec colname="2" colwidth="308PT" align="left"/>
<tbody valign="top">
<row>
<entry>656</entry>
<entry>PIP_writeprobeCLR .macro dummy</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="77PT" align="left"/>
<colspec colname="2" colwidth="252PT" align="left"/>
<tbody valign="top">
<row>
<entry>657</entry>
<entry>.wmsg &ldquo;PIP_writeprobeCLR not implemented for c55x&rdquo;</entry>
</row>
<row>
<entry>658</entry>
<entry>.endm</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="35PT" align="left"/>
<colspec colname="3" colwidth="266PT" align="left"/>
<tbody valign="top">
<row>
<entry>659</entry>
<entry>.endif</entry>
<entry>; if PIP_is not defined</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method for creating a data structure in assembly language that conforms to the semantics of an analogous data structure in a high level language wherein the method transparently adapts the data structure to a selected set of memory alignment constraints, the method comprising the steps of: 
<claim-text>defining a set of primitive data types that have a one-to-one correspondence to analogous primitive data types in the high level language such that the definition of each primitive data type is transparently adapted to the selected set of memory alignment constraints; </claim-text>
<claim-text>defining a template for the data structure wherein each element of the data structure is either selected from the set of primitive data types or is a substructure that is transparently adapted to the selected set of memory alignment constraints and the data structure length is transparently adapted to the selected set of memory alignment constraints; </claim-text>
<claim-text>allocating memory for the data structure based on the template definition such that the allocated memory transparently conforms to the selected set of memory alignment constraints; and </claim-text>
<claim-text>creating an initialization record for the data structure that is transparently adapted to the selected set of memory alignment constraints. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein the selected set of memory alignment constraints is determined by a memory model selected from a set of memory models supported by a compiler of the high level language, a memory length imposed by the compiler for each primitive data type of the set of primitive data types, and address alignment constraints imposed by the target hardware architecture and the compiler. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference> wherein the set of memory models is comprised of a large memory model and a small memory model. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference> wherein the step of defining a set of primitive data types is comprised of selecting a memory length and a memory alignment constraint for each primitive data type in the set of primitive data types as required by the memory model selected from the set of memory models. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00004">claim 4</dependent-claim-reference> wherein the set of primitive data types is comprised of a code pointer and a data pointer. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference> wherein the step of defining a template comprises defining a first alignment flag uniquely associated with the template such that the value of the first alignment flag indicated whether or not the data structure has a memory alignment constraint. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference> wherein the step of defining a template further comprises adjusting the length of the template in response to the memory alignment constraint indicated by the first alignment flag wherein the length adjustment comprises inserting a hole at the end of the template. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference> wherein the step of defining a template further comprises adjusting the length of the template and aligning a substructure of the data structure in response to a second alignment flag uniquely associated with a template of the substructure wherein the length adjustment and memory alignment comprise inserting a hole in the template immediately preceding the beginning of the substructure. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference> wherein the step of allocating memory is comprised of allocating memory space for the data structure at a memory alignment responsive to the memory alignment constraint indicated by the first alignment flag. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference> wherein the step of creating an initialization record further comprises transparently detecting holes inserted in the data structure to conform to the selected set of memory alignment constraints and supplying a predetermined fill value for the holes. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference> wherein the initialization record is comprised of a header and an initial value for each element of the data structure. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference> wherein the step of creating an initialization record is comprised of: 
<claim-text>allocating space in an initialization memory for the header of the initialization record; </claim-text>
<claim-text>ensuring that a first initial value of the initialization record is placed in the initialization memory at a memory alignment responsive to the memory alignment constraints indicated by the first alignment flag; </claim-text>
<claim-text>allocating a portion of the initialization memory for each element of the data structure such that 
<claim-text>if the element is selected from the set of primitive data types, the portion of the initialization memory allocated corresponds to the memory length of the selected primitive data type and the allocated memory space begins at a memory alignment responsive to the selected set of memory alignment constraints, or </claim-text>
<claim-text>if the element is a substructure, the portion of the initialization memory allocated corresponds to a length of a template of the substructure and the allocated memory space begins at a memory alignment responsive to a memory alignment constraint indicated by a second alignment flag uniquely associated with the template of the substructure; and </claim-text>
</claim-text>
<claim-text>placing an initial value for each element of the data structure in the portion of the initialization memory spaced allocated to the element. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein the high level language is selected from the group consisting of C, C&plus;&plus;, and Java. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. A method for creating a data structure in assembly language that conforms to the semantics of an analogous data structure in a high level language wherein the method transparently adapts the data structure to a selected set of memory alignment constraints determined by a memory model selected from a set of memory models supported by a compiler of the high level language, a memory length imposed by the compiler for each primitive data type of the set of primitive data types, and address alignment constraints imposed by the target hardware architecture and the compiler, the method comprising the steps of: 
<claim-text>defining a set of primitive data types that have a one-to-one correspondence to analogous primitive data types in the high level language by selecting a memory length for each primitive data type in the set of primitive data types as required by a memory model selected from the set of memory models; </claim-text>
<claim-text>defining a template for the data structure, wherein 
<claim-text>a first alignment flag is created and uniquely associated with the template such that the value of the first alignment flag indicates whether or not the data structure has a memory alignment constraint; </claim-text>
<claim-text>each element of the data structure is either selected from the set of primitive data types or is a substructure; </claim-text>
<claim-text>a length of the template is adjusted in response to the memory alignment constraint indicated by the first alignment flag wherein the length adjustment comprises inserting a hole at the end of the template; and </claim-text>
<claim-text>the length of the template is adjusted and a substructure of the data structure is aligned in response to a second alignment flag uniquely associated with a template of the substructure wherein the length adjustment and substructure alignment comprise inserting a hole in the template immediately preceding the beginning of the substructure; </claim-text>
</claim-text>
<claim-text>allocating memory for the data structure at a memory alignment responsive to the memory alignment constraint indicated by the first alignment flag; and </claim-text>
<claim-text>creating an initialization record for the data structure that is transparently adapted to the memory alignment constraint indicated by the first alignment flag and any holes inserted in the data structure to conform to the selected set of memory alignment constraints are given a predetermined fill value. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference> wherein the initialization record is comprised of a header and an initial value for each element of the data structure and the step of creating an initialization record is comprised of: 
<claim-text>allocating space in an initialization memory for the header of the initialization record; </claim-text>
<claim-text>ensuring that a first initial value of the initialization record is placed in the initialization memory at a memory alignment responsive to the memory alignment constraint indicated by the first alignment flag; </claim-text>
<claim-text>allocating a portion of the initialization memory for each element of the data structure such that: </claim-text>
<claim-text>if the element is selected from the set of primitive data types, the portion of the initialization memory allocated corresponds to the memory length of the selected primitive data type and the allocated memory space begins at a memory alignment responsive to the selected set of memory alignment constraints, or 
<claim-text>if the element is a substructure, the portion of the initialization memory allocated corresponds to a length of a template of the substructure and the allocated memory space begins at a memory alignment responsive to a memory alignment constraint indicated by a second alignment flag uniquely associated with the template of the substructure; and </claim-text>
</claim-text>
<claim-text>placing an initial value for each element of the data structure in the portion of the initialization memory allocated to the element.</claim-text>
</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>2A2B</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005418A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005418A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005418A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005418A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005418A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005418A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
