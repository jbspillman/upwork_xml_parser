<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005412A1-20030102-D00000.TIF SYSTEM "US20030005412A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005412A1-20030102-D00001.TIF SYSTEM "US20030005412A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005412A1-20030102-D00002.TIF SYSTEM "US20030005412A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005412A1-20030102-D00003.TIF SYSTEM "US20030005412A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005412A1-20030102-D00004.TIF SYSTEM "US20030005412A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005412A1-20030102-D00005.TIF SYSTEM "US20030005412A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030005412A1-20030102-D00006.TIF SYSTEM "US20030005412A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030005412A1-20030102-D00007.TIF SYSTEM "US20030005412A1-20030102-D00007.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005412</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10117968</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20020628</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F009/44</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>717</class>
<subclass>120000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>System for ontology-based creation of software agents from reusable components</title-of-invention>
</technical-information>
<continuity-data>
<non-provisional-of-provisional>
<document-id>
<doc-number>60281691</doc-number>
<document-date>20010406</document-date>
<country-code>US</country-code>
</document-id>
</non-provisional-of-provisional>
</continuity-data>
<inventors>
<first-named-inventor>
<name>
<given-name>James</given-name>
<middle-name>Thomas</middle-name>
<family-name>Eanes</family-name>
</name>
<residence>
<residence-us>
<city>Smithfield</city>
<state>VA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
</inventors>
<correspondence-address>
<name-1>George F. Helfrich</name-1>
<name-2></name-2>
<address>
<address-1>162 Shasta Drive</address-1>
<city>Newport News</city>
<state>VA</state>
<postalcode>23608</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">Provided is a system for the creation of autonomous and semi-autonomous networked and non-networked software agents from reusable software components based on domain-specific ontologies and component metadata to reduce the workload and improve the efficiency of end-users. The reusable software components that this system combines into software agents exist either as individual programming entities, such as C&plus;&plus; classes or Java Beans, as component-based system entities, such as Common Object Request Broker Architecture (CORBA) objects or Component Object Model (COM) clients/servers, as stand-alone applications, as Web Services, or as any other individual software entity. Each knowledge domain of interest for agent processing is described using metadata based on one or more ontologies. Each reusable software component is described by metadata adhering to one or more relevant ontologies, defining the component&apos;s relationship(s) with the data and procedural model(s) of the relevant knowledge domain(s). A software program combines software components into software agents based on all available metadata and end-user preferences for agent behavior within the bounds of the given knowledge domain(s) and computer or computer network(s). A set of graphical user interfaces (GUIs) provide end-user creation of agents from reusable components through drag-and-drop component combination and domain-specific agent behavior definition. </paragraph>
</subdoc-abstract>
<subdoc-description>
<cross-reference-to-related-applications>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> This application claims the benefit of U.S. Provisional Application No. 60/281,691, which was filed on Apr. 6, 2001 for &ldquo;Tool for creation of software agents (Agent Wizard&trade;)&rdquo;.</paragraph>
</cross-reference-to-related-applications>
<federal-research-statement>
<heading lvl="1">STATEMENT REGARDING FEDERALLY SPONSORED RESEARCH OR DEVELOPMENT </heading>
<paragraph-federal-research-statement id="P-0002"><number>&lsqb;0002&rsqb;</number> The U.S. Government has a paid-up license in this invention as provided for by the terms of Contract No. DAAHO1-00-C-R054 awarded by the Defense Advanced Research Projects Agency (DARPA), Contract Nos. F30602-010C-0005 and F30602-01-C-0015 awarded by the Office of the Secretary of Defense (OSD), and Contract No. DAAD17-01-C-0023 awarded by the Department of the Army.</paragraph-federal-research-statement>
</federal-research-statement>
<summary-of-invention>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> 1. Technical Field of the Invention </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> This invention relates generally to software agent assistance of end-user operations, the creation of software agents, and metadata. This invention relates specifically to the use of metadata descriptions based on domain-specific ontologies to combine reusable software components into software agents performing tasks as defined by an end-user in a graphical user interface. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> 2. Description of the Related Art </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> Fighting Data Overload. The difficulty in distilling useful information from the vast amounts of data on modern networks is a well-known problem. Though the latter part of the twentieth century has been labeled the Information Age due to the advent of mass communications technologies, it is increasingly difficult to glean useful information from the increasingly large and complex network of data sources. Advances in Internet and Ethernet technologies have provided a gateway through which homes, businesses, and military installations can connect with each other as never before to share and sell all manner of data. However, finding the right data from the right place at the right time and then making sense of that data is often difficult, if not impossible. The military&apos;s evolution to network-centric warfare has promised information superiority in the battlespace through the integration of information-rich systems on local and global networks. So far, this approach has provided effective data warehousing. Whether it&apos;s a munitions database on a local area network (LAN), a weather database accessed over the Internet, or a secure web page providing details for an upcoming mission, remote data abounds in this new information space. However, the current dependence on disjointed legacy systems with application-specific interfaces limits the amount of useful, personalized information provided to the end-user from the available data. What is needed is a method for end-users to locate, extract and display information from existing and emerging systems relevant to their specific tasks. This requirement includes the retrieval of data from systems with no existing human interfaces and systems whose interfaces are not developed toward the end-user&apos;s specific tasks. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> In order to provide this level of user-oriented information processing, three major technologies are necessary: 1) autonomous agents performing domain-specific tasks based on user preferences; 2) a distributed information integration solution, allowing agents to perform data location, retrieval, translation, and display functions on local and global networks; and 3) a means for end-users to create specialized agents from reusable components. Autonomous agents have been with us for decades, and there are several efforts underway within the military and commercial sectors to provide distributed information integration solutions for a user-oriented information space. The present invention provides the third necessary technology, a means by which end-users can create the agents that will assist them in their daily operations. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> Empowering The End-User. The goal of software development is to somehow improve human experience. Software developers that do not pay enough attention to the end-user&apos;s operation of the software will invariably fail to fully meet end-user requirements, either resulting in undesirable software or increasing software life-cycle cost through inefficiency (or both). The logical extension of this precept is to provide the end-user with more control over the software development process. By presenting the component-based programming model underlying the agent creation process to the end-user through an interface that is specific to the end-user&apos;s knowledge domain and/or experience level, we empower the end-user by reducing the technical details involved in programming software agents. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> The transition to component-based programming can be traced back to the development of object-oriented programming languages, such as Smalltalk and Ada, and leading to more widespread use in C&plus;&plus; and Java. However, there has been a fundamental shift from the concept of an object as an instantiation of a program&apos;s internal class to a component as an instantiation of a programming entity responsible for a specific task, regardless of the language used. By this definition, any programming effort (e.g. C&plus;&plus; class, Java applet, Ada application) that can be integrated into a larger programming model by some means (e.g. application programming interface (API), Web Services, etc.) becomes a component. Of course, the value of components is in their reuse, and so the method of integrating each component into a larger application needs to be as simple as possible to foster its reuse by other programmers and projects. Because of the many details involved in writing software, enabling end-user software development requires added layers of high-level interfaces to low-level programming details. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> Microsoft has provided an interface layer above the use of sockets, shared memory. and other stovepipe connections by developing the Component Object Model (COM). COM hides the details of client-server connections within the Windows operating system itself. The COM model is based on the concept of automation servers and clients. An automation server is a program that exposes some of its internal functions (methods) for use by other programs (clients). Just like a C&plus;&plus; or Java class that has exposed public methods for use outside of the class, the automation server becomes a reusable component to be extended toward multiple applications. An example of a COM automation server is the Web Server object within Microsoft&apos;s Internet Explorer (IE), version 4.0 and higher. The Web Server object exposes IE&apos;s internal methods for connecting to the Web and processing and displaying HTML and XML documents. By providing an automation interface to the Web Server object, Microsoft has empowered desktop developers to create sophisticated Web-based applications through reuse of a powerful Web component. In order for a potential client to access an automation server&apos;s exposed methods, the client must program toward the server&apos;s interface, often represented in a type library defining the names and data types of the exposed methods. Microsoft has provided support for the creation of automation servers and clients within their Visual Studio integrated development environment (IDE). Visual Studio provides automatic functionality for type library generation and for the creation of client interface classes from type libraries. Because the COM plumbing is hidden within Windows, the developer using Visual Studio has the power to create and integrate reusable components with the push of a few buttons. The rub, of course, is the tight integration with the Windows operating system. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> In order to provide a more open model for component reuse, the OMG has developed an interface layer called CORBA. CORBA is based on three concepts: 1) there is an Object Request Broker (ORB) responsible for message passing between objects using the Internet Inter-Orb Protocol (IIOP), 2) there is a language, called the Interface Description Language (IDL), for describing the interface(s) an object exposes, and 3) there is an Interface Repository containing object descriptions. CORBA provides component reuse on all major platforms, including Solaris, Irix, Linux, and Windows, by hiding the plumbing within ORBs and Repositories that are not directly integrated with any given operating system. CORBA has become a commercially viable large-scale component integration solution, as demonstrated by its use in several large-scale military projects and its close association with other non-Microsoft efforts, including Sun&apos;s development of Java. As Java&apos;s object-oriented programming model has evolved to include such component-based models as Java Beans, and eventually Enterprise Java Beans (EJB), the open standards community has fostered the combination of Java and CORBA as an alternative to the Microsoft hegemony. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> Given their commercial and open standards support, it is not surprising that both CORBA and COM have become widely used component reuse models. However, with the rise of the Web has come a migration from LAN-based solutions to Web-based solutions, both within corporate infrastructures and between corporations using the business-to-business (b2b) e-commerce model. Though COM and CORBA are the de facto standards in the LAN-based systems integration market, they have failed to successfully scale to the larger distributed networks, including military wide area networks (WANs) and the Internet. Efforts to scale them up include the Distributed Component Object Model (DCOM) from Microsoft and the EJB-powered CORBA Beans initiative by the Technical Resource Connection, neither of which has had much success integrating the Enterprise, largely due to their use of non-firewall-friendly protocols (e.g. IIOP) or attachment to specific underlying technologies (e.g. Windows), as well as the general difficulty programming and debugging their lengthy and sophisticated interfaces. In order to support component reuse in the Web-based Enterprise, industry is moving toward a lightweight, firewall-friendly, platform-independent protocol, along with a programming methodology that makes use of the existing distributed architecture of the Web. The protocol is called the Simple Object Access Protocol (SOAP), and the programming model is called Web Services. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> The concept of SOAP-based Web Services is another interface layer over the LAN-based models of COM and CORBA. A Web Service is nothing more than an application (service) registered with a Web server to provide its exposed functionality to other applications (clients). Of course, clients may be services, as well; the designation is strictly directional (i.e. who initiates the request). Each service registers itself with a Web server (and optionally with a service repository) in order to expose its capabilities to potential clients. Standard Web servers on the network become data brokers by passing SOAP messages between clients and services. These SOAP messages are composed of a protocol stack, consisting of an underlying transport layer, which includes the SOAP envelope and the chosen transport protocol (e.g. HTTP), and an additional content layer, which includes elements from a service description language and possibly from any number of domain-specific schemas. Current efforts toward service description include proprietary solutions such as Microsoft&apos;s BizTalk.org initiative and open standards such as the Web Services Description Language (WSDL), the electronic business eXtensible Markup Language (ebXML), and the Defense Advanced Research Projects Agency (DARPA) Agent Markup Language-Services (DAML-S). The number of Web Service efforts currently underway and the level of commercial involvement, including Microsoft&apos;s new &ldquo;software as a service&rdquo; .NET initiative, make it clear that the Web Service model represents the latest stage in the evolution of component-based development. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> The current efforts toward component-based development are aimed at the software development community. However, as interface layers are added to the underlying plumbing of programming, the ease of developing useful applications from reusable components is increasing. As these interface layers improve, the programming expertise required of the developer decreases. The current state of the art does not enable every non-programmer end-user to write software; that is, using any modern programming language still requires some programming skill. How can we enable military and commercial end-users of limited programming ability to successfully combine reusable components into software agents capable of assisting their daily operations&quest; Or, what type of interface layer is required to sufficiently hide the details of agent creation and reduce the required amount of programming skill to almost nothing&quest;</paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> The present invention is a system for creating autonomous and semi-autonomous software agents from reusable components. The system requires a computer, including an operating system providing access to platform-specific hardware and software. On this computer must exist a set of software components performing specialized tasks within larger software components or as stand-alone applications. These components must exist as atomic entities to be independently manipulated within the given operating system. Also required is a set of ontologies describing knowledge domains of interest for agent operations. In this disclosure, an ontology is defined as a metadata description of data and procedural models for a specific knowledge domain. Finally, there is an agent creation program combining relevant software components into software agents based on the available ontologies. These software agents then perform automated operations to provide value-added results based on end-user goals and preferences. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> Another embodiment of the present invention includes a set of component metadata relating all available software components to relevant ontologies for automated combination of components into software agents. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> A third embodiment of the present invention includes a set of interfaces for end-user creation of software agents using the agent creation program. These interfaces map end-user goals and preferences to agent behavior based on relevant and available ontologies and component metadata. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> A fourth embodiment of the present invention includes a set of communications interfaces providing a distributed architecture for the agent creation process. In this distributed architecture, the agent creation program, interfaces, ontologies, software components, component metadata, created software agents, and end-user results exist on the same computer or on separate computers on a network.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a schematic which shows the general process involved in the present invention. The left-hand side shows the invention on a single computer. The right-hand side shows a distributed embodiment of the invention. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a flow chart showing the process of ontology-based agent creation. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> shows screen shots of a Requirements Wizard agent creation interface developed under contract with the Defense Advanced Research Projects Agency (DARPA). </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> shows a generalized, multiple knowledge domain agent creation interface developed under contracts with the Army and Air Force. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> shows screen shots from the Systems Integration Requirements Wizard, a domain-specific extension of the generalized interface in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> shows another agent creation interface developed for the Army and Air Force, allowing end-user drag-and-drop of components onto a palette for agent creation. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> shows another agent creation interface developed for DARPA that displays a data model description to allow metadata keyword selection for agent search.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF THE INVENTION </heading>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> In the background above we posed the following question: what type of interface layer is required to sufficiently hide the details of agent creation and reduce the required amount of programming skill to almost nothing&quest; The required interface layer consists of domain-specific ontologies defining data and procedural models within knowledge and computing domains of interest for agent development. A knowledge domain as used here includes tightly- and loosely-coupled data types and operations within military and commercial applications, including environmental, command and control, search and surveillance, marketing, managing, etc. A computing domain includes the resources available on the operator&apos;s machine and on the network, such as data sources (e.g. Oracle database, Web server, human expert), transport protocols (e.g. HTTP, FTP), middleware solutions (e.g. CORBA, Web Services), and software components capable of performing operations within specific knowledge domains. Data types within a knowledge domain&apos;s data model are represented using an appropriate schema (e.g. XML). Operations within the domain&apos;s procedural model are represented using an appropriately defined grammar (e.g. Backus-Naur Form (BNF)) and include data source location, dynamic data source discovery, data retrieval, translation, storage, and display. Domain-specific ontologies describing the resources, operations, and software components available within limited knowledge and computing domains empower end-users to combine those software components into software agents based on clearly understood requirements within their daily operations. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> For example, an operator responsible for generating a daily weather report, requiring multiple types and formats of environmental data from multiple data sources, would benefit from an agent assistant built from components performing data retrieval, translation, and display within the environmental knowledge domain. The agent could gather the required data from the available data sources (as defined within the computing domain), translate each data format into a standard common format for display or ingest into a common database, and provide the operator with his or her preference of updates and alerts regarding the status of the operation. In addition, an agent assistant could be commanded to spend its downtime (i.e. when the operator hasn&apos;t tasked it to a specific operation) looking for alternative data sources on the LAN or on the Web, extending this agent to dynamic data source discovery. Creating this agent assistant requires the existence of specialized components within the environmental knowledge domain capable of recognizing and translating the types and formats of the environmental data required, as well as specialized components capable of performing data location, retrieval, and display with regard to the data sources within the computing domain of the end-user&apos;s network. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> Building Agents from Components. The schematic shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference> shows the general process of the present invention. The end-user (<highlight><bold>1</bold></highlight>), which can be either a human user or a software program, interacts with the agent creation program (<highlight><bold>2</bold></highlight>) through one or more of its interfaces (<highlight><bold>3</bold></highlight>) to define agent behavior within the limitations of the chosen knowledge domain(s) (<highlight><bold>4</bold></highlight>) and the given computing domain(s) (<highlight><bold>5</bold></highlight> and right-hand side of figure). The agent creation program utilizes the ontologies defining these domains to combine reusable software components (<highlight><bold>6</bold></highlight>) into one or more software agents (<highlight><bold>7</bold></highlight>) to perform operations as defined by the end-user. The created agents make use of any necessary intermediate agents (<highlight><bold>7</bold></highlight>) for ancillary translation, retrieval, or other processing, and finally provide the required results (<highlight><bold>8</bold></highlight>) to the end-user. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> The first step in devising the present invention was to describe agent behavior as the interaction of conceptual components performing specialized operations (e.g. get, put, translate, display). From this initial approach, we have a generalized grammar describing potential agent operations within specific knowledge domains. The following portion of a modified Backus-Naur grammar partially describes the conceptual component operations &ldquo;get&rdquo;, &ldquo;put&rdquo;, and &ldquo;translate&rdquo;: </paragraph>
<paragraph id="P-0030" lvl="1"><number>&lsqb;0030&rsqb;</number> get::&equals;&lt;object&gt; from &lt;data_source&gt;</paragraph>
<paragraph id="P-0031" lvl="1"><number>&lsqb;0031&rsqb;</number> put:: &lt;object&gt; to &lt;data_source&gt;</paragraph>
<paragraph id="P-0032" lvl="1"><number>&lsqb;0032&rsqb;</number> translate::&equals;&lt;object&gt; to &lt;object&gt;</paragraph>
<paragraph id="P-0033" lvl="1"><number>&lsqb;0033&rsqb;</number> display::&equals;&lt;object&gt; on&lt;object_viewer&gt;</paragraph>
<paragraph id="P-0034" lvl="1"><number>&lsqb;0034&rsqb;</number> object::&equals;&lt;domain specific&gt;</paragraph>
<paragraph id="P-0035" lvl="1"><number>&lsqb;0035&rsqb;</number> object_viewer::&equals;&lt;domain specific&gt;</paragraph>
<paragraph id="P-0036" lvl="1"><number>&lsqb;0036&rsqb;</number> data_source::&equals;&lt;database&gt;&verbar;&lt;file&gt;&verbar;&lt;serial&gt;&verbar;&lt;internet&gt;&verbar;&lt;program&gt;&verbar;&lt;domain specific&gt;</paragraph>
<paragraph id="P-0037" lvl="1"><number>&lsqb;0037&rsqb;</number> database::&equals;Informix&verbar;Access&verbar;Oracle&verbar;&lt;domain specific&gt;</paragraph>
<paragraph id="P-0038" lvl="1"><number>&lsqb;0038&rsqb;</number> file::&equals;&lt;ascii&gt;&verbar;&lt;binary&gt;</paragraph>
<paragraph id="P-0039" lvl="1"><number>&lsqb;0039&rsqb;</number> ascii::&equals;XML&verbar;HTML&verbar;&lt;domain specific&gt;</paragraph>
<paragraph id="P-0040" lvl="1"><number>&lsqb;0040&rsqb;</number> binary::&equals;JPEG&verbar;GIF&verbar;MS_WORD&verbar;&lt;domain specific&gt;</paragraph>
<paragraph id="P-0041" lvl="1"><number>&lsqb;0041&rsqb;</number> serial::&equals;&lt;rs-232&gt;&verbar;&lt;domain specific&gt;</paragraph>
<paragraph id="P-0042" lvl="1"><number>&lsqb;0042&rsqb;</number> rs-232::&equals;&lt;ascii&gt;&verbar;&lt;binary&gt;</paragraph>
<paragraph id="P-0043" lvl="1"><number>&lsqb;0043&rsqb;</number> internet::&equals;HTTP&verbar;FTP&verbar;SOAP&verbar;&lt;domain specific&gt;</paragraph>
<paragraph id="P-0044" lvl="1"><number>&lsqb;0044&rsqb;</number> program::&equals;Agent&verbar;ORB&verbar;COM_Server&verbar;&lt;domain specific&gt;</paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> Those components that retrieve data objects from databases, the Internet, files, serial ports, other programs, etc. perform &ldquo;get&rdquo; operations. Those components that write data objects to files, databases, serial ports, etc. perform &ldquo;put&rdquo; operations. Between a &ldquo;get&rdquo; and a &ldquo;put&rdquo; might be a component to &ldquo;translate&rdquo; the data object form the source&apos;s format into the format of the receiver. These conceptual components are atomic entities, each describing a single operation. By devising a generalized grammar for agent behavior, we have formed the basis for the description of actual software components performing multiple operations within an application. The next step was to connect this conceptual approach to real-world applications. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> Domain-specific ontologies provide the mapping of conceptual component descriptions to actual software systems within specific knowledge domains. An ontology is a definition of the elements of a knowledge domain (i.e. from philosophy, those things that &ldquo;exist&rdquo; within the knowledge domain) and the relationships among them. The &lt;domain specific&gt; elements shown in the above grammar represent those elements that are not generalized to every type of conceptual component, but instead directly correspond to a specific ontology. As defined in this approach, an ontology for a specific knowledge domain is represented by a data model, which defines the types of data objects to be manipulated and their relationships to each other, and a procedural model, which defines the types of operations that can be performed on the given data types. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> The data model is the definition of structure among data elements in the domain. For example, the following is a portion of an XML Schema definition for a complex data type, called forecast, to be used within environmental data transactions. The data type consists of several fields in sequence, including type, time, and location, each of which refers to other data types defined by other schemas, including time (e.g. either GMT or epoch time) and position (e.g. defining the forecast for a point or an area):  
<table-cwu id="TABLE-US-00001">
<number>1</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>&lt;&quest;xml version&equals;&ldquo;1.0&rdquo;&quest;&gt;</entry>
</row>
<row>
<entry>&lt;xsd:schema targetNamespace&equals;&ldquo;http:wwww.wagner.com/metoc.xsd&rdquo;</entry>
</row>
<row>
<entry>xmlns:xsd&equals;&ldquo;http://www.w3.org/2001/XMLSchema&rdquo;</entry>
</row>
<row>
<entry>xmlns:time&equals;&ldquo;http://www.wagner.com/time.xsd&rdquo;</entry>
</row>
<row>
<entry>xmlns:pos&equals;&ldquo;http://www.wagner.com/space.xsd&rdquo;</entry>
</row>
<row>
<entry>xmlns&equals;&ldquo;http://www.w3.org/2001/XMLSchema&rdquo;&gt;</entry>
</row>
<row>
<entry>&lt;element name&equals;&ldquo;forecast&rdquo;&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lt;complexType&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="196PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lt;sequence&gt;</entry>
</row>
<row>
<entry></entry>
<entry>&lt;element name&equals;&ldquo;forecastType&rdquo; type&equals;&ldquo;tns:forecastType&rdquo;/&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lt;choice&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="35PT" align="left"/>
<colspec colname="1" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lt;element name&equals;&ldquo;time&rdquo; type&equals;&ldquo;time:gmt&rdquo;/&gt;</entry>
</row>
<row>
<entry></entry>
<entry>&lt;element name&equals;&ldquo;time&rdquo; type&equals;&ldquo;time:epoch&rdquo;/&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lt;/choice&gt;</entry>
</row>
<row>
<entry></entry>
<entry>&lt;choice&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="35PT" align="left"/>
<colspec colname="1" colwidth="182PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lt;element name&equals;&ldquo;location&rdquo; type&equals;&ldquo;space:latlonPoint&rdquo;/&gt;</entry>
</row>
<row>
<entry></entry>
<entry>&lt;element name&equals;&ldquo;location&rdquo; type&equals;&ldquo;space:latlonBox&rdquo;/&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lt;/choice&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="196PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lt;/sequence&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lt;/complexType&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>&lt;/element&gt;</entry>
</row>
<row>
<entry>&lt;element&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="196PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>(other elements, such as &ldquo;parameter&rdquo;, are defined here)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lt;/element&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>&lt;/schema&gt;</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> The values assigned to these elements within metadata descriptions make up the knowledge domain&apos;s vocabulary, which may be defined by the data model or may be application-specific (i.e. agreed upon between applications using this data model). This type of data model description document, existing as a DTD, an XML schema, or any other structured format, defines the data model definition for each knowledge domain. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> The data model describes both the data objects passed between software components and the computing domain, or infrastructure, of interest. The infrastructure description might exist as a document written in XML, as a CORBA Repository, or as any other valid description of resources available on the network. This description would make use of the given data model&apos;s structure and vocabulary, whether implied by use in this document or defined in a data model description, to describe the infrastructure on which agents operate for the given knowledge domain. For example, the following partial infrastructure document uses elements from the METOC schema partially listed above, another schema for sensor types, and yet another schema for device types to describe a sensor network on which agents retrieve, process, and visualize METOC data:  
<table-cwu id="TABLE-US-00002">
<number>2</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>&lt;&quest;xml version&equals;&ldquo;1.0&rdquo;&quest;&gt;</entry>
</row>
<row>
<entry>&lt;infrastructure</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>xmlns:sensors&equals;&ldquo;http://www.wagner.com/sensors.xsd&rdquo;</entry>
</row>
<row>
<entry></entry>
<entry>xmlns:devices&equals;&ldquo;http://www.wagner.com/devices.xsd&rdquo;</entry>
</row>
<row>
<entry></entry>
<entry>xmlns:metoc&equals;&ldquo;http://www.wagner.com/metoc.xsd&rdquo;</entry>
</row>
<row>
<entry></entry>
<entry>xmlns&equals;&ldquo;http://www.wagner.com/infrastructure.xsd&rdquo;&gt;</entry>
</row>
<row>
<entry></entry>
<entry>&lt;sensors:sensor id&equals;&ldquo;120&rdquo; format&equals;&ldquo;RS-232&rdquo;&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="238PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lt;metoc:parameter units&equals;&ldquo;K&rdquo;&gt;temperature&lt;/metoc:parameter&gt;</entry>
</row>
<row>
<entry></entry>
<entry>&lt;metoc:period units&equals;&ldquo;minutes&rdquo;&gt;1&lt;/metoc:period&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lt;/sensors:sensor&gt;</entry>
</row>
<row>
<entry></entry>
<entry>&lt;sensors:sensor id&equals;&ldquo;185&rdquo; name&equals;&ldquo;WindSensor 3000&rdquo; format&equals;&ldquo;RS-232&rdquo;&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="238PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lt;metoc:parameter units&equals;&ldquo;KTS&rdquo;&gt;wind speed&lt;/metoc:parameter&gt;</entry>
</row>
<row>
<entry></entry>
<entry>&lt;metoc:parameter units&equals;&ldquo;DEG T&rdquo;&gt;wind direction&lt;/metoc:parameter&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lt;/sensors:sensor&gt;</entry>
</row>
<row>
<entry></entry>
<entry>&lt;devices:display id&equals;&ldquo;34452-K&rdquo; name&equals;&ldquo;Xybernaut&rdquo; type&equals;&ldquo;wearable&rdquo;&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="238PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lt;format&gt;JPEG&lt;/format&gt;</entry>
</row>
<row>
<entry></entry>
<entry>&lt;format&gt;HTML&lt;/format&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lt;/devices:display&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry>&lt;/infrastructure&gt;</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> This description shows that there is a sensor with ID 120 that outputs temperature in Kelvin every minute. It also shows that there is a display system called a Xybernaut that is a wearable device capable of displaying the browser-oriented formats JPEG and HTML. By describing the given infrastructure using the given schemas, we link the physical sensor network to the conceptual behavior of software agent components on that network. The more detail provided by this description, the more effective the agent creation process when attempting to meet user requirements, as discussed below. The elements used in this infrastructure description document can be defined in a data model description, such as the one shown above, or simply accepted as stand-alone metadata (e.g. well-formed XML). </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> The procedural model is the definition of operations on data model elements in the domain and is derived from the generalized grammar defined above. The following portion of a modified Backus-Naur grammar continues our METOC example by defining actions within the infrastructure described above: </paragraph>
<paragraph id="P-0052" lvl="1"><number>&lsqb;0052&rsqb;</number> get:&equals;&lt;parameter&gt;&plus;from &lt;sensor&gt;&plus;&lsqb;during &lt;timerange&gt;&plus;&rsqb;</paragraph>
<paragraph id="P-0053" lvl="1"><number>&lsqb;0053&rsqb;</number> translate:&equals;&lt;parameter&gt;&plus;from &lt;units&gt; to &lt;units&gt;</paragraph>
<paragraph id="P-0054" lvl="1"><number>&lsqb;0054&rsqb;</number> translate:&equals;&lt;parameter&gt;&plus;from &lt;format&gt; to &lt;format&gt;</paragraph>
<paragraph id="P-0055" lvl="1"><number>&lsqb;0055&rsqb;</number> display:&equals;&lt;parameter&gt;&plus;on&lt;display&gt;&lsqb;as&lt;format&gt;&rsqb;</paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> This document (which could also be written as an XML schema) states that agents within this domain can perform operations such as &ldquo;Get temperature from sensor23 during 1000-1200,&rdquo; or &ldquo;Translate wind speed, wind direction from GRIB to ASCII,&rdquo; or &ldquo;Display temperature, wind speed, wind direction on Xybernaut as HTML.&rdquo; The grammar defines what operations are available for agents to accomplish on the given infrastructure within the given domain. Existence of an operation within the grammar does not imply the existence of an agent component capable of performing such an operation. However, in order to develop an agent capable of performing a specific operation, there must be an agent component to perform that operation within the limitations of the given domain and network. If there is no procedural model provided for a specific domain, then the agent creation process is still possible via end-user manipulation of agent components within a graphical interface. </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> The final requirement for a fully automated system is a component description document defining the relationship between the procedural model and the software components available for agent creation. These components might exist as any type of programming entity, such as C&plus;&plus; or Java classes, Perl scripts, Java Beans, CORBA objects, COM clients/servers, stand-alone applications, Web Services, or any other type of software. For example, the following component description defines Java Bean components performing operations as described in our METOC example:  
<table-cwu id="TABLE-US-00003">
<number>3</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>&lt;&quest;xml version&equals;&ldquo;1.0&rdquo;&quest;&gt;</entry>
</row>
<row>
<entry>&lt;components</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>xmlns:sensors&equals;&ldquo;http://www.wagner.com/sensors.xsd&rdquo;</entry>
</row>
<row>
<entry></entry>
<entry>xmlns:metoc&equals;&ldquo;http://www.wagner.com/metoc.xsd&rdquo;</entry>
</row>
<row>
<entry></entry>
<entry>xmlns:grammar&equals;&ldquo;http://www.wagner.com/grammar.xsd&rdquo;</entry>
</row>
<row>
<entry></entry>
<entry>xmlns&equals;&ldquo;http://www.wagner.com/components.xsd&rdquo;&gt;</entry>
</row>
<row>
<entry></entry>
<entry>&lt;component&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="238PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lt;id&gt;12&lt;/id&gt;</entry>
</row>
<row>
<entry></entry>
<entry>&lt;name&gt;get_winds.class&lt;/name&gt;</entry>
</row>
<row>
<entry></entry>
<entry>&lt;location type&equals;&ldquo;url&rdquo;&gt;23.334.99&bsol;source&bsol;beans&lt;/location&gt;</entry>
</row>
<row>
<entry></entry>
<entry>&lt;language&gt;Java&lt;/language&gt;</entry>
</row>
<row>
<entry></entry>
<entry>&lt;type&gt;Bean&lt;/type&gt;</entry>
</row>
<row>
<entry></entry>
<entry>&lt;grammar:get&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lt;metoc:parameter&gt;wind speed&lt;/metoc:parameter&gt;</entry>
</row>
<row>
<entry></entry>
<entry>&lt;metoc:parameter&gt;wind direction&lt;/metoc:parameter&gt;</entry>
</row>
<row>
<entry></entry>
<entry>&lt;from&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="35PT" align="left"/>
<colspec colname="1" colwidth="224PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lt;sensors:sensor format&equals;&ldquo;RS-232&rdquo;/&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lt;/from&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="238PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lt;/grammar:get&gt;</entry>
</row>
<row>
<entry></entry>
<entry>&lt;grammar:put&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lt;meroc:parameter units&equals;&ldquo;KTS&rdquo;&gt;wind speed&lt;/metoc:parameter&gt;</entry>
</row>
<row>
<entry></entry>
<entry>&lt;metoc:parameter units&equals;&ldquo;DEG T&rdquo;&gt;wind direction&lt;/metoc:parameter&gt;</entry>
</row>
<row>
<entry></entry>
<entry>&lt;to&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="35PT" align="left"/>
<colspec colname="1" colwidth="224PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lt;file&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lt;name&gt;winds.xml./name&gt;</entry>
</row>
<row>
<entry></entry>
<entry>&lt;location type&equals;&ldquo;url&rdquo;&gt;23.334.99&bsol;data&lt;/location&gt;</entry>
</row>
<row>
<entry></entry>
<entry>&lt;format&gt;XML&lt;/format&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="35PT" align="left"/>
<colspec colname="1" colwidth="224PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lt;/file&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lt;/to&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="238PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lt;/grammar:put&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lt;/component&gt;</entry>
</row>
<row>
<entry></entry>
<entry>&lt;component&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="238PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lt;id&gt;34&lt;/id&gt;</entry>
</row>
<row>
<entry></entry>
<entry>&lt;name&gt;GRIB_to_ASCII.class&lt;/name&gt;</entry>
</row>
<row>
<entry></entry>
<entry>&lt;location type&equals;&ldquo;url&rdquo;&gt;23.334.99&bsol;source\beans&lt;/location&gt;</entry>
</row>
<row>
<entry></entry>
<entry>&lt;language&gt;Java&lt;/language&gt;</entry>
</row>
<row>
<entry></entry>
<entry>&lt;type&gt;Bean&lt;/type&gt;</entry>
</row>
<row>
<entry></entry>
<entry>&lt;grammar:translate&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lt;from&gt;GRIB&lt;/from&gt;</entry>
</row>
<row>
<entry></entry>
<entry>&lt;to&gt;ASCII format 32&lt;/to&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="238PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lt;/grammar:translate&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lt;/component&gt;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry>&lt;/components&gt;</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> This example shows that agent component <highlight><bold>12</bold></highlight>, called get_winds.class, can retrieve wind speed and direction from an RS-232 serial port and output that data in an XML document. Also according to the description, component <highlight><bold>34</bold></highlight> can translate gridded binary (GRIB) data to ASCII text. The use of XML namespaces in this example allows us to specify the knowledge domain(s) that our components intersect in their operations. With these descriptions of the inputs/outputs, types, and behavior of components, we are able to dynamically (with no user interaction) combine the proper components into one or more software agents by simply mapping user requirements to component capabilities using the same ontologies. The level of detail in these descriptions determines the effectiveness of the created agents in terms of the end-user&apos;s original goals. Each component communicates with other programming entities on the computer network using either its own inherent interface (e.g. COM, CORBA, SOAP) or through specialized translation entities providing access to required interfaces. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> Agent Creation Interfaces. The graphical interfaces associated with this invention allow end-users to specify their goals and preferences in terms of the knowledge domains in which they are operating. <cross-reference target="DRAWINGS">FIG. 3</cross-reference> shows screen shots of an agent creation interface developed under contract with the Defense Advanced Research Projects Agency (DARPA). This interface, a METOC-specific Requirements Wizard, steps the end-user through the definition of METOC-specific agent behavior. <cross-reference target="DRAWINGS">FIG. 4</cross-reference> shows another agent creation interface developed under contracts with the Army and Air Force. This interface is a more generalized (and more powerful) interface because it provides access to agent creation within several knowledge domains, including system integration, weather, unattended ground sensors, and logistics. <cross-reference target="DRAWINGS">FIG. 5</cross-reference> shows screen shots taken while defining systems integration requirements. The first screen asks the user to choose the type of data source that is being integrated. If the type is not in the list, the user has the option of defining a new data source type. Choosing &ldquo;database&rdquo; in this first screen and clicking &ldquo;Next&rdquo; brings up the second screen, in which the user chooses the specific type of database that&apos;s being integrated. In the next screen, the user chooses from databases that have a registered entry with the agent creation program (i.e., they have a metadata description, as described below). The next screen asks what the user wants the agent to do with the data from the data source. Choosing to update an existing system results in the next screen, in which they enter the registered system to be updated (again, this system must have a metadata description). Finally, when the user clicks &ldquo;Next&rdquo; the Requirements Wizard asks for a name for the agent to be created. </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> Each interface developed for a domain-specific application (e.g. Requirements Wizard) requires programming. A programmer developed each of the screens in <cross-reference target="DRAWINGS">FIG. 5</cross-reference> for the specific purpose of being displayed within that particular Requirements Wizard. This represents the tradeoff between ease of development and ease of use. In order for end-users with very little technical expertise to be able to easily develop agents to assist their daily operations, time and money must be put into the development of this type of step-by-step interface. An alternative approach is to develop a generic interface that allows for the creation of agents within any application domain, but requires more technical expertise on the part of the end-user. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> shows a prototype interface for creating software agents through direct component manipulation. This interface is a simple Java Bean manipulation demonstration that allows technically inclined end-users to combine Java Bean agent components into working agents. The leftmost screen shows the Agent Component Toolbox, which contains all the components currently known to the agent creation program (i.e. that currently have metadata descriptions). The middle screen shows the Agent Builder palette where components are combined into a working agent. In this example, the user has dragged and dropped two components from the toolbox, getWebGIFs and plotToSystemChart, and placed them on the palette. The red line between the components shows that an event or property from the first component is bound to the second component, which means that the second component&apos;s behavior is linked to that of the first (e.g. plotToSystemChart won&apos;t activate until getWebGIFs fires an event stating that it has retrieved imagery to display). The rightmost screen shows the Properties window, which shows the user the bound properties for the selected component. This interface enforces component connections based on their metadata descriptions, permitting compatible components to be connected and warning of incompatibilities in data types, formats, etc. This type of interface provides the user with direct control over the creation of an agent, but it also requires more technical understanding than a requirements-driven interface. </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> shows an interface to the agent creation process that displays a data model description (in this case an XML DTD) to allow the end-user to select keywords from the data model that are of particular interest. These keywords provide targets for agent search and retrieval from local or remote data sources. By searching directly on the data model, instead of requiring the end-user to fabricate appropriate keywords, agent search becomes much more efficient. Instead of searching HTML documents on the Web for matching keywords (e.g. looking for the keyword &ldquo;stock quote&rdquo; on millions of HTML pages), agents can focus search on those data sources providing metadata specifically matching that keyword (e.g. Charles Schwab&apos;s web site). </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A system for creating autonomous and semi-autonomous software agents from reusable software components, comprising: 
<claim-text>a) a computer, including an operating system providing access to platform-specific hardware and software; </claim-text>
<claim-text>b) a set of software components on said operating system, said software components existing as atomic entities exposed for human or machine manipulation on said operating system and performing specialized tasks within larger software components or as stand-alone applications; </claim-text>
<claim-text>c) a set of ontologies describing knowledge domains, said ontologies being metadata descriptions of data and procedural models and existing in human-readable or machine-readable form on said operating system; </claim-text>
<claim-text>d) an agent creation program combining said software components into software agents based on said ontologies, said software agents providing results based on end-user goals and preferences. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. A system according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, additionally comprising: 
<claim-text>a set of component metadata relating said software components to said ontologies for automated combination of software components into software agents. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. A system according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, additionally comprising: 
<claim-text>a set of interfaces for creation of software agents using said agent creation program. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. A system according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, additionally comprising: 
<claim-text>a set of communications interfaces providing a distributed architecture for said agent creation program, said ontologies, said software components, and said software agents.</claim-text>
</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>1</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005412A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005412A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005412A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005412A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005412A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005412A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030005412A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030005412A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
