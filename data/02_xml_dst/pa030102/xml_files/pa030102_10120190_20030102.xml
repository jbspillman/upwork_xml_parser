<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005149A1-20030102-D00000.TIF SYSTEM "US20030005149A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005149A1-20030102-D00001.TIF SYSTEM "US20030005149A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005149A1-20030102-D00002.TIF SYSTEM "US20030005149A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005149A1-20030102-D00003.TIF SYSTEM "US20030005149A1-20030102-D00003.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005149</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10120190</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20020411</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F015/173</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>709</class>
<subclass>238000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Independent-tree ad hoc multicast routing</title-of-invention>
</technical-information>
<continuity-data>
<non-provisional-of-provisional>
<document-id>
<doc-number>60286491</doc-number>
<document-date>20010425</document-date>
<country-code>US</country-code>
</document-id>
</non-provisional-of-provisional>
</continuity-data>
<inventors>
<first-named-inventor>
<name>
<given-name>Zygmunt</given-name>
<middle-name>J.</middle-name>
<family-name>Haas</family-name>
</name>
<residence>
<residence-us>
<city>Summit</city>
<state>NJ</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>S.</given-name>
<family-name>Sajama</family-name>
</name>
<residence>
<residence-us>
<city>La Jolla</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>William A. Blake</name-1>
<name-2>Jones, Tullar &amp; Cooper, P.C.</name-2>
<address>
<address-1>P.O. Box 2266 Eads Station</address-1>
<city>Arlington</city>
<state>VA</state>
<postalcode>22202</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A routing protocol for a multicasting network, such as an ad hoc network, employs alternate tree or path computation algorithms that continually compute backup trees or paths that can be employed to replace failed trees or paths. The sets of alternate multicast trees or paths are preferably pre-calculated before a first tree or path fails to minimize delay in replacing a failed tree or path. Preferably, the algorithms are designed to compute the alternate multicast trees or paths in such a manner that they are maximally independent of the original set of trees and paths to minimize correlation between the original trees or paths and the replacement trees or paths and to possibly increase the useful time of the calculated trees. This helps insure that the replacement trees or paths will not be likely themselves to fail soon after failure of the original trees or paths. </paragraph>
</subdoc-abstract>
<subdoc-description>
<cross-reference-to-related-applications>
<heading lvl="1">PRIORITY CLAIM UNDER 35 U.S.C. &sect;119(e) </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> This application claims priority, under 35 U.S.C. &sect;119(e), on U.S. Provisional Application No. 60/286,491, filed Apr. 25, 2001.</paragraph>
</cross-reference-to-related-applications>
<federal-research-statement>
<heading lvl="1">GOVERNMENT RIGHTS STATEMENT </heading>
<paragraph-federal-research-statement id="P-0002"><number>&lsqb;0002&rsqb;</number> This invention was made with Government support from the National Science Foundation (NSF) under Grant No. 9980521, the Office of Naval Research (ONR) under Grant No. N00014-00-1-0564 and the AFRL under contract No. F360602-97-C-0133. The Government has certain rights in the invention.</paragraph-federal-research-statement>
</federal-research-statement>
<summary-of-invention>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> 1. Field of the Invention </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> The present invention relates in general to a method and system for multicasting communications using routing schemes in which multiple independent trees or paths are employed to minimize communications interruptions due to tree or path failures. The invention is particularly suited for use in ad hoc networks. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> 2. Description of the Background Art </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> An ad hoc network consists of a collection of mobile routers that are interconnected via wireless links and are free to move about arbitrarily. This technology has its roots in DARPA packet radio networks. Research on multi hop packet-switching radio networks started in the 1970s, with its initial motivation in military applications. Their attractiveness was (and continues to be) because of the ease and speed of deployment in hard-to-access environments. In recent years, interest in ad hoc networks has grown with improvements in laptop computers including greater computational power, longer battery life and decreased weight. Advent of ubiquitous computing and the proliferation of portable computing devices have further increased the importance of efficient routing in mobile networks. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> One of the most pressing needs for enhanced communication protocols come from multi point applications, which involve the one-to-many communication model (i.e., multicasting operation). Such applications cover a very wide spectrum including software distribution, replicated database update, command and control systems, audio/video conferencing, and distributed interactive simulation. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> Multicasting is an efficient communication tool for use in multi point applications. Many of the proposed multicast routing protocols, both for the Internet and for ad hoc networks, construct trees over which information is transmitted. Using trees is evidently more efficient than the brute force approach of sending the same information from the source individually to each of the receivers. Another benefit of using trees is that routing decisions at the intermediate nodes become very simple: a router in a multicast tree that receives a multicast packet over an in-tree interface forwards the packet over the rest of its in-tree interfaces. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> Multicast routing algorithms in the Internet can be classified into three broad categories: Shortest Path Tree algorithms, Minimum Cost Tree algorithms, and Constrained Tree algorithms. There are two fundamental approaches in designing multicast routing&mdash;one is to minimize the distance (or cost) from the sender to each receiver individually (shortest path tree algorithms) and the other is to minimize the overall (total) cost of the multicast tree. Practical considerations lead to a third category of algorithms which try to optimize both constraints using some metric (minimum cost trees with constrained delays). The majority of multicast routing protocols in the Internet are based on shortest path trees, because of their ease of implementation. Also, they provide minimum delay from sender to receiver, which is desirable for many real-life multicast applications. However shared trees are used in some more recent protocols (like PIM and CBT) in order to minimize states stored in the routers. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> Multicasting in ad hoc networks is more challenging than in the Internet, because of the need to optimize the use of several resources simultaneously. Firstly, nodes in ad hoc networks are battery-power limited. Furthermore, data travels over the air and wireless resources are scarce. Secondly, there is no centralized access point or existing infrastructure (like in the cellular network) to keep track of the node mobility. Thirdly, the status of communication links between routers is a function of their positions, transmission power levels, etc. The mobility of routers and randomness of other connectivity factors lead to a network with a potentially unpredictable and rapidly changing topology. This means that by the time a reasonable amount of information about the topology of the network is collected and a tree is computed, there may be very little time before this computed tree becomes useless. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> Work on multicast routing in ad hoc networks gained momentum in the mid 1990s. Some early approaches to provide multicast support in ad hoc networks, such as for example, Shared Tree Wireless Network Multicast, consisted of adapting the existing Internet multicasting protocols. Other protocols, such as On-Demand Multicast Routing Protocol (ODMRP) have been designed specifically for ad hoc networks. ODMRP is a mesh based, on-demand protocol that uses a soft state approach for maintenance of the message transmission structure. It exploits robustness of mesh structure to frequent route failure and gains stability at the expense of bandwidth. The Core Assisted Mesh Protocol (CAMP) attempts to remedy this excessive overhead, while still using a mesh by using a core for route discovery. AMRIS is a protocol that constructs a shared delivery tree rooted at a node, with ID-numbers increasing as they radiate from the source. Local route recovery is made possible due to this property of ID numbers, hence reducing the route recovery time and also confining route recovery traffic to the region of link failures. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> One common characteristic of most of these approaches is that they react to a link failure, i.e. they act after a link has already failed, causing a significant delay in route recovery. As a result, communications between selected nodes in the network can be disabled for a significant period of time. A need therefore exists for a multicasting routing protocol that can minimize the time period between failure of a link and route recovery. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> The present invention fulfills the foregoing need through use of a routing protocol or scheme that can be employed to replace failed links and nodes in a multicasting network virtually as soon as they occur. To achieve this functionality, the routing protocol continuously computes alternate routing trees or paths that can be used to facilitate communications among a plurality of nodes in the network. The alternate trees or paths are computed even before a failure in a link or node in the network occurs. As a result, the alternate trees or paths can immediately be employed in place of the original set of trees or path upon occurrence of a node or link failure, thereby minimizing duration of any interruptions in communications between the nodes. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> Preferably, the invention can be implemented using a number of techniques, the following two of which are examples. The most preferred technique is to calculate multiple backup paths that can be employed to replace failed portions or segments of a tree. The use of backup paths is preferred since it avoids the necessity of replacing the whole tree when only a small portion thereof has failed. Preferably, an algorithm is employed to implement this technique that computes trees such that paths to each receiver in these trees are disjoint while allowing paths to different receivers to overlap within trees. Using the algorithm, one starts off with a tree and then for each receiver, has a set of backup paths that are maximally disjoint from one another and from the path to the receiver in the first tree. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> The second technique for implementing the invention is to calculate sets of alternate trees, which can be used whenever a presently employed tree fails. Preferably, the alternate trees are maximally independent (i.e., have a minimum number of common nodes and links) of the original set of trees to minimize correlation between the original trees and the alternate trees. This helps insure that the nodes and links in the alternate trees that are employed to replace the original trees will not be likely to fail themselves soon after their implementation in the network. Various algorithms can be employed to calculate the backup trees in such a manner that the trees are maximally independent of one another without being so independent that the backup trees contain an excessive number of links, which themselves, would increase the likelihood of tree failure. The independence of the sets of trees also improves the mean time between route discovery cycles for a given interruption rate and hence reduces the control overhead and the rate of data loss. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> Once a set of backup paths or trees is computed using the aforementioned or other techniques and the network starts multicasting, it is necessary to replenish the backup path or tree set in such a way as to maintain some quality of service, i.e., to maintain the probability of interruptions below some threshold. This means that new backup paths or trees need to be computed by the time the probability of failure of the current set of paths or trees rises above a given threshold. Thus, in the preferred embodiments, an estimate of the time at which the probability of failure of a current set of trees or paths therein exceeds a threshold is made. Using this time estimate, in conjunction with knowledge of how long it takes to discover a new route and how long it then takes to compute a set of alternate backup trees or paths, the time at which calculation of a new set of backup trees or paths should begin can be determined. Using this technique, the probability of interruption to multicast communication is not allowed to rise above a certain threshold, hence maintaining the desired quality of service. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> Through use of the present invention, the efficiency of multicasting networks is substantially improved. When a network is reasonably stable, like the Internet, the gain in efficiency due to multicasting (when compared to flooding) more than offsets the cost of route discovery and maintenance. However, as the average velocity of nodes increases, so does the cost of route discovery and maintenance. This means that for any mobility pattern, there is an average velocity of nodes beyond which multicasting is no longer efficient when compared to flooding. This velocity is much higher for the protocol of the present invention when compared to other tree-based schemes because of use of the backup trees and paths. The cost of the multicast tree is optimized along with minimizing the mutual correlation of failure times of each pair of trees under the constraints of partial knowledge of the network.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> The features and advantages of the present invention will become apparent form the following detailed description of a number of preferred embodiments thereof, taken in conjunction with the accompanying drawings, in which: </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a block diagram of an example of an ad hoc network that can be configured to operate in accordance with the principles of the present invention; </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a graphical representation of an ad hoc network showing a group of communications nodes connected by a group of edges that represent communications links; </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a portion of a sample auxiliary digraph, which illustrates edges of the graph of <cross-reference target="DRAWINGS">FIG. 1</cross-reference> that are to be removed and added to form an alternate tree in accordance with one embodiment of the invention; </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a graph illustrating two non-maximal trees that are obtained through simple enumeration; and </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a graph illustrating a pair of spanning trees that are calculated in one preferred embodiment using the Matroid Intersection algorithm.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS </heading>
<paragraph id="P-0024" lvl="7"><number>&lsqb;0024&rsqb;</number> 1. Exemplary Network </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> With reference to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, an ad hoc network <highlight><bold>10</bold></highlight> is illustrated that can be configured to operate in accordance with the principles of the present invention. While the invention is particularly suited for use with ad hoc networks, it should be understood that the invention could be employed in any type of communications network that employs multicasting routing protocols. The network <highlight><bold>10</bold></highlight> includes a plurality of communications nodes <highlight><bold>12</bold></highlight>, many or all of which can be portable and mobile. As an example, the nodes <highlight><bold>12</bold></highlight> can be associated with military vehicles or personnel in the field. As is conventional, each node <highlight><bold>12</bold></highlight> includes a transceiver <highlight><bold>13</bold></highlight> for transmitting and receiving communications to and from the other nodes <highlight><bold>12</bold></highlight> in the network <highlight><bold>10</bold></highlight>. In addition, each node <highlight><bold>12</bold></highlight> includes a processor <highlight><bold>14</bold></highlight> for processing information requests from other nodes, managing node routing and location information, performing route discovery and calculating routing trees and paths in accordance with the embodiments of the present invention. A memory <highlight><bold>15</bold></highlight> is also interfaced to the processor <highlight><bold>14</bold></highlight> for storing a database of node location and route information for all other nodes in the network <highlight><bold>10</bold></highlight>, as well as for storing routing tree and path sets. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> In a multicasting routing protocol, when one node in a network receives a message from another node to be passed onto other nodes, the receiving node will send the message to one or more of the other nodes in the network in accordance with the routing tree or scheme being employed by the network at the time. As an example, a number of the nodes <highlight><bold>12</bold></highlight> in the network <highlight><bold>10</bold></highlight> have been lettered A through H to illustrate the multicasting process. Suppose node A wants to send a message to node H. Now, assume that in the sample network <highlight><bold>10</bold></highlight>, each of the nodes <highlight><bold>12</bold></highlight> multicasts messages to two other of the nodes <highlight><bold>12</bold></highlight> in the network <highlight><bold>10</bold></highlight>. Under this scheme, node A sends the message destined for node H to nodes B and C. In response, nodes B and C pass the message to nodes D and E, and F and G, respectively. These four nodes then pass the message to more of the nodes <highlight><bold>12</bold></highlight>, including node H, which receives the message from node G. In this manner, each of the nodes <highlight><bold>12</bold></highlight> is linked to one another via a plurality of paths <highlight><bold>16</bold></highlight>, each formed of one or more transmission links <highlight><bold>17</bold></highlight>. Collectively, the paths <highlight><bold>16</bold></highlight> make up a routing tree <highlight><bold>18</bold></highlight> that interconnects the nodes <highlight><bold>12</bold></highlight> (note that the term &ldquo;edge&rdquo; is also used to refer to a link between adjacent nodes in the analysis that follows). The links labeled L<highlight><bold>1</bold></highlight>-L<highlight><bold>3</bold></highlight> form a path P<highlight><bold>1</bold></highlight> that interconnects node A with node H. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> Now, consider the situation where either one of the links <highlight><bold>17</bold></highlight> fails, as may occur if two of the nodes become too far apart, or one or more of the nodes <highlight><bold>12</bold></highlight> fails. For example, if node G fails, node A can no longer communicate with node H. It then becomes necessary for node A to reconfigure the routing tree <highlight><bold>18</bold></highlight> or paths <highlight><bold>16</bold></highlight> therein to bypass the node G, so that, for example, node F now sends messages to node H. This procedure, however, takes time in using algorithms to recompute the network trees or paths. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> The present invention overcomes the drawbacks of previous routing schemes by programming each of the processors <highlight><bold>14</bold></highlight> in the nodes <highlight><bold>12</bold></highlight> to calculate backup trees and paths on a continuous basis, even when no link or node failure has occurred, so that multiple alternate trees or paths are available when a link or node failure does occur. As a result, these alternate trees or paths can be immediately employed to minimize communications interruptions. In addition, the backup trees and paths are preferably computed using algorithms that insure a selected maximal level of independence of the backup trees or paths relative to the original trees and paths. The basic idea is that if one is able to compute multiple backup multicast trees with minimal overlap, the backup trees could be used one after another to reduce the number of service interruptions. This would also improve the mean time between route discovery cycles for a given interruption rate and hence reduce the control overhead and the rate of data loss. At the same time, there are competing concerns that need to be addressed. In particular, the cost of transmission needs to be kept low, while the mobility of ad hoc networks requires that very little time be used for tree computation and hence it is important that the route discovery algorithms be of low complexity. </paragraph>
<paragraph id="P-0029" lvl="7"><number>&lsqb;0029&rsqb;</number> 2. Dependence of a Set of Trees </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> This method of using one tree after another will be effective if the trees to be used as backup last for a significant amount of time after the previous trees fail. This means that the failure times of the trees should be independent of one another. If it is assumed that nodes move independently of one another, having no common nodes (and hence no common links or edges) would make the trees fail independently of one another. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> However, in the case of ad hoc networks, where the average degree of a node is not high, one would expect not to find completely independent trees in many cases. Hence the present invention employs schemes that concentrate on minimizing the dependence between the failure times. The dependence of a pair of trees is defined as the correlation of the failure times of the two trees. Given a pair of trees, their dependence depends on the structure of each of the trees apart from the number of common nodes and edges. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> Dependence of a pair of trees is a complicated function of the mobility pattern of the nodes. Hence a practical way to compute independent enough trees would be to discourage common edges and nodes among the trees. Intuition suggests that having a common edge is much worse (causes more dependence in a pair of trees) than having a common node. However, a probabilistic analysis was conducted to find the correlation of the failure times of two edges sharing a common node. This analysis established that under certain conditions, such as when the nodes in the network have velocities that are uniformly distributed over a selected range, the correlation between the failure times of two adjacent links was more than a trivial amount. Hence, under this kind of mobility pattern, it is important to minimize common nodes between trees in addition to minimizing common edges, in order to keep the failure times as independent as possible. </paragraph>
<paragraph id="P-0033" lvl="7"><number>&lsqb;0033&rsqb;</number> 3. Tradeoff Between Dependence And The Total Time For Which The Set Of Trees Last </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> The total time for which a system lasts depends on the individual failure times of the trees used and their independence. If a tree has greater number of links, it is likely to fail faster. On the other hand, if trees have to be maximally independent, they might be less efficient and contain more links, as compared with the case in which some overlap is allowed. Hence the trees should not be so independent as to make them fail very fast and hence reduce the total system time. </paragraph>
<paragraph id="P-0035" lvl="7"><number>&lsqb;0035&rsqb;</number> 4. Mechanism To Replace Trees </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> Once a set of backup trees is computed and the network starts multicasting, it is necessary to replenish the backup tree set in such a way as to maintain some quality of service, i.e., to maintain the probability of interruptions below some threshold. This means that new trees need to be computed by the time the probability of failure of the current set of trees rises above a given threshold. If a sender node has an estimate of the time when this will happen, it could initiate route discovery at such a time, T, as to allow for the route discovery and tree computation to be completed in time. One way to estimate T given a mobility pattern of nodes follows. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> It is possible to compute the probability of interruption occurring before a given time after a given route discovery cycle (or failure of first n trees) if one has knowledge of the mobility pattern of the nodes. If the threshold for probability is too high, the scheme will resemble a link state multicast protocol, thus initiating the route discovery process too often, while if it is too low it will be reactive, possibly causing service disruption. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> Let the average time for route discovery be T<highlight><subscript>RD </subscript></highlight>and let the average time for computing the set of n trees for a multicast group size m be T<highlight><subscript>m,n</subscript></highlight>. Let F<highlight><subscript>n,m</subscript></highlight>(p) be the time, since failure of the first n trees, at which the probability that all remaining trees will fail increases above p (finding this function is illustrated in the simulation results section on tree replacement). Let P<highlight><subscript>T </subscript></highlight>be the threshold below which the probability of failure is to be kept at all times. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> Initially, the estimate of T is T&equals;F<highlight><subscript>0,m</subscript></highlight>(P<highlight><subscript>T</subscript></highlight>)&minus;T<highlight><subscript>RD</subscript></highlight>&minus;T<highlight><subscript>m,n</subscript></highlight>. At the time when the n-th tree fails, the estimate of T is updated to:</paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>T&equals;F</italic></highlight><highlight><subscript>n,m</subscript></highlight>(<highlight><italic>P</italic></highlight><highlight><subscript>T</subscript></highlight>)&minus;<highlight><italic>T</italic></highlight><highlight><subscript>RD</subscript></highlight><highlight><italic>&minus;T</italic></highlight><highlight><subscript>m,n</subscript></highlight></in-line-formula></paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> At the time T after the most recent tree failure (or previous route discovery if no tree has failed since then), another cycle of route discovery should be started. If at the time of failure of the n-th tree, T is estimated to be negative, a new route discovery cycle should be started immediately. Thus the probability of interruption to multicast communication is not allowed to rise above P<highlight><subscript>T</subscript></highlight>, hence maintaining the desired quality of service. </paragraph>
<paragraph id="P-0041" lvl="7"><number>&lsqb;0041&rsqb;</number> 5. Incorporating the Invention Into Existing Routing Protocols </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> The concepts of the present invention can be easily implemented on top of a suitable unicast layer, which provides route discovery. For example, consider the Dynamic Source Routing (DSR) protocol, a unicast protocol for ad hoc networks. In this protocol, in response to a single route discovery (as well as through routing information from other packets overheard), a node may learn and cache multiple routes to any destination. This way when one of the edges fails, the sender uses another cached route. Using &ldquo;Diversity Injection&rdquo; can increase knowledge of network obtained from route discovery. Also, once the sender discovers edges to all receivers, one of the proposed algorithms can be used to compute and maintain several multicast backup trees. The mechanism required to switch between trees in the event of link failure is already available in DSR. </paragraph>
<paragraph id="P-0043" lvl="7"><number>&lsqb;0043&rsqb;</number> 6. Network Model </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> An ad hoc network like the network <highlight><bold>10</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 1</cross-reference> can be represented via a graph (V, E), where V is the set of nodes and E is the set of edges. The network is assumed to be two-dimensional and the mobile hosts (transceivers) are represented by nodes of the graph. An edge or link between any two nodes is present whenever the two nodes are able to communicate directly with one another. The total number of edges in the graph is denoted by L, i.e., L&equals;&cup;E, and the sender node is denoted by O (which stands for origin of the data). V<highlight><bold>1</bold></highlight><highlight><uline>&sub;</uline></highlight>V is the set of nodes in the multicast receiver group. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> It is assumed that O has some knowledge of the graph topology from route discovery. E<highlight><bold>2</bold></highlight> is the set of all edges in the graph that exist according to O&apos;s current view of the network. (V<highlight><bold>2</bold></highlight>, E<highlight><bold>2</bold></highlight>) are the nodes and edges that belong to all these edges. The goal of the protocol is to find methods for computing a set of trees &lcub;T<highlight><bold>1</bold></highlight>, T<highlight><bold>2</bold></highlight>, T<highlight><bold>3</bold></highlight> . . . &rcub; from O to &lcub;V<highlight><bold>1</bold></highlight>&rcub; in this graph G&equals;(V<highlight><bold>2</bold></highlight>, E<highlight><bold>2</bold></highlight>), while minimizing the dependence of their failure times. As is usually the case with multicast trees, T<highlight><bold>1</bold></highlight> and T<highlight><bold>2</bold></highlight> are directed (though the links of the graph are assumed to be bi-directional); i.e., associated with each link i there is a node at which the link begins O<highlight><subscript>1 </subscript></highlight>and a node at which it ends D<highlight><subscript>1</subscript></highlight>, which stand for origin and destination of each link. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> In the schemes described below, the set of all edges in the graph, along with a quantity called the cost of each edge, is called the cost function of the graph. The known Dijkstra algorithm is extensively used, which takes the cost function and incidence matrix of the graph as input and computes the shortest edge tree from a given source to the given set of receivers. </paragraph>
<paragraph id="P-0047" lvl="7"><number>&lsqb;0047&rsqb;</number> 7. Schemes For Computing Maximally Independent Trees </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> As explained before, one goal of the alternate tree embodiments of the present invention is to develop schemes to efficiently compute a set of trees, whose failure times are minimally correlated. Under the assumption that mobility of a node is independent of other nodes, this condition translates to the trees having minimum number of common nodes and edges, with common edges being more undesirable than common nodes. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> Two possible ways of using the backup tree set in the event of a link failure: 1) replace the whole tree being used currently by a backup tree, if available or 2) determine which of the nodes are disconnected because of this link failure and replace or augment the links or edges to those nodes by backup links or edges. </paragraph>
<paragraph id="P-0050" lvl="7"><number>&lsqb;0050&rsqb;</number> 7.1. Computing Backup Trees </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> Numerous algorithms can be employed to calculate backup trees or paths. Three specific techniques of finding sets of disjoint multicasting trees from a sender node to a group of receiving nodes have been studied. However, it will be understood that these techniques are exemplary and that the invention is not limited to the use of these techniques. In the discussions that follow, the trees to be found are referred to as T<highlight><bold>1</bold></highlight>, T<highlight><bold>2</bold></highlight> and so on. T<highlight><bold>1</bold></highlight> is intended to be used at the start and the others are to be used as backup. </paragraph>
<paragraph id="P-0052" lvl="7"><number>&lsqb;0052&rsqb;</number> 7.1.1 Matroid Intersection Heuristic </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> The Matroid Intersection algorithm is a known algorithm that can be applied in a first embodiment of the present invention to find two maximally independent spanning trees on any given graph (i.e., spanning trees with a minimum possible number of common edges) such that the total cost of the two spanning trees is minimized. The two spanning trees obtained are called J<highlight><bold>1</bold></highlight> and J<highlight><bold>2</bold></highlight>. Given a sender (call it the source node) and a set of receivers, two multicasting trees T<highlight><bold>1</bold></highlight> and T<highlight><bold>2</bold></highlight> are obtained on graphs J<highlight><bold>1</bold></highlight> and J<highlight><bold>2</bold></highlight>, respectively, using the Dijkstra algorithm. </paragraph>
<paragraph id="P-0054" lvl="7"><number>&lsqb;0054&rsqb;</number> Matroids and Spanning Trees </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> Let E be a finite set and I be a family of subsets of E, called &ldquo;Independent&rdquo; sets. A subset system M&equals;(E, I) (a finite set E together with a collection I of subsets of E) is called a matroid if the following axioms are satisfied: </paragraph>
<paragraph id="P-0056" lvl="2"><number>&lsqb;0056&rsqb;</number> 1) 0&egr;I </paragraph>
<paragraph id="P-0057" lvl="2"><number>&lsqb;0057&rsqb;</number> 2) if J&prime;<highlight><uline>&sub;</uline></highlight>J&egr;I, then; J&prime;&egr;I </paragraph>
<paragraph id="P-0058" lvl="2"><number>&lsqb;0058&rsqb;</number> 3) for every A<highlight><uline>&sub;</uline></highlight>E, every maximal independent subset of A has the same cardinality. </paragraph>
</section>
<section>
<heading lvl="1">EXAMPLE 1 </heading>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> E<highlight><bold>1</bold></highlight>&equals;Set of all edges in a graph G and I is the family of subsets of E satisfying the condition that none of them contains a circuit of the graph. Hence independent subsets of this graph are all subsets of trees on this graph. </paragraph>
</section>
<section>
<heading lvl="1">EXAMPLE 2 </heading>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> E&equals;Set of all edges in graphs G and G&prime; (see <cross-reference target="DRAWINGS">FIG. 2</cross-reference>) where G&prime; is a copy of G (edge e&prime;<highlight><subscript>1 </subscript></highlight>is a copy of e<highlight><subscript>1 </subscript></highlight>and so on). Two matroids which can be defined on this set are: </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> M<highlight><subscript>1</subscript></highlight>&equals;(E, I<highlight><subscript>1</subscript></highlight>) where an &ldquo;independent&rdquo; set is a union of subsets of trees of G and G&prime;. For example, an independent set in the collection I<highlight><subscript>1</subscript></highlight>, could be &lcub;e<highlight><subscript>1</subscript></highlight>, e<highlight><subscript>2</subscript></highlight>, e<highlight><subscript>3</subscript></highlight>, e<highlight><subscript>4</subscript></highlight>, e&prime;<highlight><subscript>5</subscript></highlight>, e&prime;<highlight><subscript>6</subscript></highlight>, e&prime;<highlight><subscript>7</subscript></highlight>, e&prime;<highlight><subscript>2</subscript></highlight>&rcub; and a set which would not belong to I<highlight><subscript>2 </subscript></highlight>would be &lcub;e<highlight><subscript>1</subscript></highlight>, e<highlight><subscript>2</subscript></highlight>, e<highlight><subscript>7</subscript></highlight>, e&prime;<highlight><subscript>8</subscript></highlight>&rcub; since it has a circuit in it.&rcub;</paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> M<highlight><subscript>2</subscript></highlight>&equals;(E, I<highlight><subscript>2</subscript></highlight>) where an &ldquo;independent&rdquo; set is one which does not have both copies of any of the edges. An example of an independent set in I<highlight><subscript>2 </subscript></highlight>would be &lcub;e<highlight><subscript>1</subscript></highlight>, e&prime;<highlight><subscript>3</subscript></highlight>, e&prime;<highlight><subscript>7</subscript></highlight>&rcub; and a set which would not belong to I<highlight><subscript>2 </subscript></highlight>would be &lcub;e<highlight><subscript>1</subscript></highlight>, e&prime;<highlight><subscript>3</subscript></highlight>, e&prime;<highlight><subscript>1</subscript></highlight>&rcub; since it contains both copies of e<highlight><subscript>1</subscript></highlight>. </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> Hence if a subset of E belongs to both Matroids defined above, it will have to be a union of 2 trees, one in G and the other in G&prime;. Moreover, the copy of an edge that belongs to the tree in G should not belong to the tree in G&prime;. This observation indicates that when 2 edge disjoint trees are possible in a graph G, the set belonging to both the collections I<highlight><subscript>1 </subscript></highlight>and I<highlight><subscript>2 </subscript></highlight>and having the maximum possible cardinality will be the union of two disjoint spanning trees. Hence the problem of finding two independent forests in the graph can be thought of as finding a maximum cardinality common independent set of the two matroids defined above. </paragraph>
<paragraph id="P-0064" lvl="7"><number>&lsqb;0064&rsqb;</number> The Matroid Intersection Algorithm (MIA) </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> In this algorithm, start with a set J which belongs to both I<highlight><subscript>1 </subscript></highlight>and I<highlight><subscript>2</subscript></highlight>, say the empty set (Refer to Example 2 above for meaning of I<highlight><subscript>1 </subscript></highlight>and I<highlight><subscript>2</subscript></highlight>). </paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> Then, repeatedly increase the size of J with the help of an auxiliary directed graph G&equals;G(M<highlight><subscript>1</subscript></highlight>, M<highlight><subscript>2</subscript></highlight>, J, w<highlight><superscript>1</superscript></highlight>, w<highlight><superscript>2</superscript></highlight>) constructed using some rules. w<highlight><superscript>1 </superscript></highlight>and w<highlight><superscript>2 </superscript></highlight>is a weight splitting (obtained from weight splitting in the previous step using rules described in the algorithm and starting with w<highlight><superscript>1</superscript></highlight>&equals;w and w<highlight><superscript>2</superscript></highlight>&equals;0). G has a node set E&cup;&lcub;r, s&rcub; and arcs: </paragraph>
<paragraph id="P-0067" lvl="2"><number>&lsqb;0067&rsqb;</number> es for every e&egr;E&bsol;J such that J&cup;&lcub;e&rcub;&egr;I<highlight><subscript>1</subscript></highlight>; </paragraph>
<paragraph id="P-0068" lvl="2"><number>&lsqb;0068&rsqb;</number> re for every e&egr;E&bsol;J such that J&cup;&lcub;e&rcub;&egr;I<highlight><subscript>2</subscript></highlight>; </paragraph>
<paragraph id="P-0069" lvl="2"><number>&lsqb;0069&rsqb;</number> ef for every e&egr;E&bsol;J, f&egr;J such that J&cup;&lcub;e&rcub;&notin;I<highlight><subscript>1</subscript></highlight>, (J&cup;&lcub;e&rcub;)&bsol;&lcub;f&rcub;&egr;I<highlight><subscript>1</subscript></highlight>; </paragraph>
<paragraph id="P-0070" lvl="2"><number>&lsqb;0070&rsqb;</number> fe for every e&egr;E&bsol;J, f&egr;J such that J&cup;&lcub;e&rcub;&notin;I<highlight><subscript>2</subscript></highlight>, ( J &cup;&lcub;e&rcub;)&bsol;&lcub;f&rcub;&egr;I<highlight><subscript>2</subscript></highlight>; </paragraph>
<paragraph id="P-0071" lvl="2"><number>&lsqb;0071&rsqb;</number> The costs of arcs of G, p<highlight><subscript>uv</subscript></highlight>, are defined by (ci<highlight><subscript>0 </subscript></highlight>denotes max&lcub;w<highlight><superscript>1</superscript></highlight><highlight><subscript>e</subscript></highlight>:e&notin;J, J&cup;&lcub;e&rcub;&egr;I<highlight><subscript>1</subscript></highlight>&rcub;); </paragraph>
<paragraph id="P-0072" lvl="2"><number>&lsqb;0072&rsqb;</number> p<highlight><subscript>es</subscript></highlight>&equals;w<highlight><superscript>1</superscript></highlight><highlight><subscript>0</subscript></highlight>&minus;w<highlight><superscript>1</superscript></highlight><highlight><subscript>e </subscript></highlight>for each M<highlight><bold>1</bold></highlight> arc es with:e&notin;J; </paragraph>
<paragraph id="P-0073" lvl="2"><number>&lsqb;0073&rsqb;</number> p<highlight><subscript>es</subscript></highlight>&equals;w<highlight><superscript>2</superscript></highlight><highlight><subscript>0</subscript></highlight>&minus;w<highlight><superscript>2</superscript></highlight><highlight><subscript>e </subscript></highlight>for each M<highlight><bold>2</bold></highlight> arc re with:e&notin;J; </paragraph>
<paragraph id="P-0074" lvl="2"><number>&lsqb;0074&rsqb;</number> p<highlight><subscript>es</subscript></highlight>&equals;&minus;w<highlight><superscript>1</superscript></highlight><highlight><subscript>e</subscript></highlight>&plus;w<highlight><superscript>1</superscript></highlight><highlight><subscript>f </subscript></highlight>for each M<highlight><bold>1</bold></highlight> arc ef with:e&notin;J and, f&egr;J; </paragraph>
<paragraph id="P-0075" lvl="2"><number>&lsqb;0075&rsqb;</number> p<highlight><subscript>es</subscript></highlight>&equals;&minus;w<highlight><superscript>2</superscript></highlight><highlight><subscript>e</subscript></highlight>&plus;w<highlight><superscript>2</superscript></highlight><highlight><subscript>f </subscript></highlight>for each M<highlight><bold>1</bold></highlight> arc ef with:e&notin;J and, f&egr;J. </paragraph>
<paragraph id="P-0076" lvl="0"><number>&lsqb;0076&rsqb;</number> If there exists an (r, s) dipath in G, then J is not maximum; in fact, if r, el, fl, . . . em, fm, em&plus;1, s is the node sequence of a chordless (r, s)-dipath, then J&Dgr;&lcub;el, fl, . . . em, fm, em&plus;1&rcub; in I<highlight><subscript>1 </subscript></highlight>&cup;I<highlight><subscript>2</subscript></highlight>. If there exists no (r, s) dipath in G, then J is a maximum. J&lt;&lcub;el, fl, . . . , em, fm, em&plus;1&rcub; is defined as J&cup;&lcub;e<highlight><subscript>1</subscript></highlight>&rcub;&bsol;&lcub;f<highlight><subscript>1</subscript></highlight>&rcub; . . . &bsol;&lcub;f&rcub;&cup;e<highlight><subscript>m&plus;1</subscript></highlight>. </paragraph>
<paragraph id="P-0077" lvl="7"><number>&lsqb;0077&rsqb;</number> Weighted Matroid Intersection Algorithm  
<table-cwu id="TABLE-US-00001">
<number>1</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>Set k &equals; 0;</entry>
</row>
<row>
<entry>Set J<highlight><subscript>K</subscript></highlight> &equals; 0;</entry>
</row>
<row>
<entry>Let w<highlight><superscript>1</superscript></highlight> &equals; w, w<highlight><superscript>2</superscript></highlight> &equals; 0;</entry>
</row>
<row>
<entry>While J<highlight><subscript>K</subscript></highlight> is neither M1-basis nor an M2-basis</entry>
</row>
<row>
<entry>&lcub;</entry>
</row>
<row>
<entry>Construct G(M1, M2, J<highlight><subscript>K</subscript></highlight>, w<highlight><superscript>1</superscript></highlight>, w<highlight><superscript>2</superscript></highlight>);</entry>
</row>
<row>
<entry>Find least weight directed edge from r to v in G of cost d<highlight><subscript>&ngr;</subscript></highlight> for each v</entry>
</row>
<row>
<entry>For all &ngr; &egr; E, let &sgr;<highlight><subscript>&ngr;</subscript></highlight> &equals; min(d<highlight><subscript>&ngr;</subscript></highlight>, d<highlight><subscript>s</subscript></highlight>) and replace w<highlight><superscript>1</superscript></highlight><highlight><subscript>&ngr;</subscript></highlight> by w<highlight><superscript>1</superscript></highlight><highlight><subscript>&ngr;</subscript></highlight> &minus; &sgr;<highlight><subscript>&ngr;</subscript></highlight>, w<highlight><superscript>2</superscript></highlight><highlight><subscript>&ngr;</subscript></highlight> by</entry>
</row>
<row>
<entry>w<highlight><superscript>2</superscript></highlight><highlight><subscript>&ngr;</subscript></highlight> &minus; &sgr;<highlight><subscript>&ngr;</subscript></highlight>. Construct G(M1, M2, J<highlight><subscript>K</subscript></highlight>, w<highlight><superscript>1</superscript></highlight>, w<highlight><superscript>2</superscript></highlight>);</entry>
</row>
<row>
<entry>If there is an (r,s)-dipath in G</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub;</entry>
</row>
<row>
<entry></entry>
<entry>Find a least weight (r,s) dipath P having as few arcs as possible;</entry>
</row>
<row>
<entry></entry>
<entry>Augment J<highlight><subscript>K</subscript></highlight> on P to obtain J<highlight><subscript>K&plus;1</subscript></highlight>;</entry>
</row>
<row>
<entry></entry>
<entry>Replace k by k&plus;1</entry>
</row>
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="7PT" align="left"/>
<colspec colname="1" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>else</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub;Choose J &equals; J<highlight><subscript>P</subscript></highlight> and stop.&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="7PT" align="left"/>
<colspec colname="1" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0078" lvl="0"><number>&lsqb;0078&rsqb;</number> In the above algorithm, Dijkstra&apos;s algorithm could be used to find the minimum weight edges. </paragraph>
<paragraph id="P-0079" lvl="7"><number>&lsqb;0079&rsqb;</number> Maximal Vs Maximum </paragraph>
<paragraph id="P-0080" lvl="0"><number>&lsqb;0080&rsqb;</number> When it is not possible to have 2 completely edge-disjoint spanning trees, the above algorithm gives 2 trees edge disjoint trees with maximal cardinality (These might not be spanning trees as adding any more edges might require overlap between the 2 trees). Hence now to complete each tree, the links in the other tree are arranged in ascending order of their costs and links are added to the first tree (unless they form circuits) until the first tree is complete and vice versa. Note that multicast trees generated in this way may not have minimum possible number of common edges, though the spanning trees do have this property. Also, note that this scheme can be used only to obtain one backup tree, because the problem of finding the intersection of 3 Matroids is too difficult. </paragraph>
</section>
<section>
<heading lvl="1">EXAMPLE </heading>
<paragraph id="P-0081" lvl="0"><number>&lsqb;0081&rsqb;</number> Consider the graph G in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>. The problem is to find two disjoint spanning trees. First, it needs to be verified that this is possible. This is easily done by trying different combinations of 4 edges each; four edges are needed to form a tree for a graph with <highlight><bold>4</bold></highlight> nodes. One example would be &lcub;e<highlight><subscript>1</subscript></highlight>, e<highlight><subscript>3</subscript></highlight>, e<highlight><subscript>5</subscript></highlight>, e<highlight><subscript>7</subscript></highlight>&rcub; and &lcub;e<highlight><subscript>2</subscript></highlight>, e<highlight><subscript>4</subscript></highlight>, e<highlight><subscript>6</subscript></highlight>, e<highlight><subscript>8</subscript></highlight>&rcub;. </paragraph>
<paragraph id="P-0082" lvl="0"><number>&lsqb;0082&rsqb;</number> The effectiveness of arriving at a pair of disjoint trees using the Matroid Intersection Algorithm can be seen by going through the process for this simple graph. Suppose one starts by building just a tree T<highlight><subscript>1 </subscript></highlight>first and then removing links of T<highlight><subscript>1 </subscript></highlight>from the set of edges and then trying to build another tree T<highlight><subscript>2</subscript></highlight>. The following two sets would be obtained (see <cross-reference target="DRAWINGS">FIG. 4</cross-reference>): </paragraph>
<paragraph id="P-0083" lvl="2"><number>&lsqb;0083&rsqb;</number> T<highlight><subscript>1</subscript></highlight>&equals;&lcub;e<highlight><subscript>1</subscript></highlight>, e<highlight><subscript>2</subscript></highlight>, e<highlight><subscript>3</subscript></highlight>, e<highlight><subscript>4</subscript></highlight>&rcub;</paragraph>
<paragraph id="P-0084" lvl="2"><number>&lsqb;0084&rsqb;</number> T<highlight><subscript>2</subscript></highlight>&equals;&lcub;e<highlight><subscript>5</subscript></highlight>, e<highlight><subscript>6</subscript></highlight>, e<highlight><subscript>7</subscript></highlight>&rcub;</paragraph>
<paragraph id="P-0085" lvl="0"><number>&lsqb;0085&rsqb;</number> Adding e&prime;<highlight><subscript>8 </subscript></highlight>to T<highlight><subscript>2 </subscript></highlight>will create a circuit and hence is not acceptable. Now one would like to move some edges from T<highlight><subscript>1 </subscript></highlight>to T<highlight><subscript>2 </subscript></highlight>and add some new ones to T<highlight><subscript>1</subscript></highlight>, so that it still remains a tree. </paragraph>
<paragraph id="P-0086" lvl="0"><number>&lsqb;0086&rsqb;</number> Constructing an auxiliary digraph G&prime; (see <cross-reference target="DRAWINGS">FIG. 3</cross-reference>) helps find the edges which are to be removed and those which are to be added. In the terminology used above: </paragraph>
<paragraph id="P-0087" lvl="2"><number>&lsqb;0087&rsqb;</number> E&equals;&lcub;e<highlight><subscript>1</subscript></highlight>, . . . , e<highlight><subscript>8</subscript></highlight>, e&prime;<highlight><subscript>1</subscript></highlight>, . . . , e&prime;<highlight><subscript>8</subscript></highlight>&rcub;</paragraph>
<paragraph id="P-0088" lvl="2"><number>&lsqb;0088&rsqb;</number> Current J&equals;&lcub;e<highlight><subscript>1</subscript></highlight>, e<highlight><subscript>2</subscript></highlight>, e<highlight><subscript>3</subscript></highlight>, e<highlight><subscript>4</subscript></highlight>, e&prime;<highlight><subscript>5</subscript></highlight>, e&prime;<highlight><subscript>6</subscript></highlight>, e&prime;<highlight><subscript>7</subscript></highlight>&rcub;</paragraph>
<paragraph id="P-0089" lvl="2"><number>&lsqb;0089&rsqb;</number> G has the node set E&cup;&lcub;r, s&bsol;&rcub;.e&egr;S&bsol;J and f&egr;J. </paragraph>
<paragraph id="P-0090" lvl="2"><number>&lsqb;0090&rsqb;</number> Its edges are: </paragraph>
<paragraph id="P-0091" lvl="3"><number>&lsqb;0091&rsqb;</number> from rule 1, edges of the form es:e&prime;<highlight><subscript>1</subscript></highlight>S, e&prime;<highlight><subscript>2</subscript></highlight>S, e&prime;<highlight><subscript>3</subscript></highlight>S since e&prime;<highlight><subscript>1</subscript></highlight>, e&prime;<highlight><subscript>2 </subscript></highlight>and e&prime;<highlight><subscript>3 </subscript></highlight>combined with T<highlight><subscript>2 </subscript></highlight>form a tree, i.e., J&cup;&lcub;e&rcub;&egr;I<highlight><subscript>1</subscript></highlight>; </paragraph>
<paragraph id="P-0092" lvl="3"><number>&lsqb;0092&rsqb;</number> from rule 2, edges of the form re :re&prime;<highlight><subscript>8</subscript></highlight>, re<highlight><subscript>8</subscript></highlight>; J &cup; &lcub;e&rcub; &egr; I<highlight><subscript>2</subscript></highlight>; </paragraph>
<paragraph id="P-0093" lvl="3"><number>&lsqb;0093&rsqb;</number> from rule 3, edges of the form ef :e<highlight><subscript>5</subscript></highlight>e<highlight><subscript>4</subscript></highlight>, e<highlight><subscript>5</subscript></highlight>e<highlight><subscript>1</subscript></highlight>, e<highlight><subscript>5</subscript></highlight>e<highlight><subscript>2</subscript></highlight>, e<highlight><subscript>6</subscript></highlight>e<highlight><subscript>1 , e</subscript></highlight><highlight><subscript>6</subscript></highlight>e<highlight><subscript>3</subscript></highlight>, e<highlight><subscript>6</subscript></highlight>e<highlight><subscript>4</subscript></highlight>, e<highlight><subscript>7</subscript></highlight>e<highlight><subscript>1</subscript></highlight>, e<highlight><subscript>7</subscript></highlight>e<highlight><subscript>2</subscript></highlight>, e<highlight><subscript>8</subscript></highlight>e<highlight><subscript>2</subscript></highlight>, e<highlight><subscript>8</subscript></highlight>e<highlight><subscript>3</subscript></highlight>, e&prime;<highlight><subscript>4</subscript></highlight>e&prime;<highlight><subscript>5</subscript></highlight>, e&prime;<highlight><subscript>4</subscript></highlight>e&prime;<highlight><subscript>7</subscript></highlight>, e&prime;<highlight><subscript>8</subscript></highlight>e&prime;<highlight><subscript>5</subscript></highlight>, e&prime;<highlight><subscript>8</subscript></highlight>e&prime;<highlight><subscript>6</subscript></highlight>,; J&cup;&lcub;e&rcub;&notin;I<highlight><subscript>1</subscript></highlight>, (J&cup;&lcub;e&rcub;)&bsol;&lcub;f&rcub;&egr;I<highlight><subscript>1</subscript></highlight>; </paragraph>
<paragraph id="P-0094" lvl="3"><number>&lsqb;0094&rsqb;</number> from rule 4, edges of the form fe: e<highlight><subscript>1</subscript></highlight>e&prime;<highlight><subscript>1</subscript></highlight>, e<highlight><subscript>2</subscript></highlight>e&prime;<highlight><subscript>2</subscript></highlight>, e<highlight><subscript>3</subscript></highlight>e&prime;<highlight><subscript>3</subscript></highlight>, e<highlight><subscript>4</subscript></highlight>e&prime;<highlight><subscript>4</subscript></highlight>, e&prime;<highlight><subscript>5</subscript></highlight>e&prime;<highlight><subscript>5</subscript></highlight>, e&prime;<highlight><subscript>6</subscript></highlight>e<highlight><subscript>6</subscript></highlight>, e&prime;<highlight><subscript>7</subscript></highlight>e<highlight><subscript>7</subscript></highlight>, J &cup;&lcub;e&rcub;&notin;I<highlight><subscript>2</subscript></highlight>, (J&cup;&lcub;e&rcub;)&bsol;&lcub;f&rcub;&egr;I<highlight><subscript>2</subscript></highlight>; </paragraph>
<paragraph id="P-0095" lvl="0"><number>&lsqb;0095&rsqb;</number> Now, an rs dipath needs to be found in this graph. One of the paths is P&equals;&lcub;r, e&prime;<highlight><subscript>8</subscript></highlight>, e&prime;<highlight><subscript>5</subscript></highlight>, e<highlight><subscript>5</subscript></highlight>, e<highlight><subscript>1</subscript></highlight>, e&prime;<highlight><subscript>1</subscript></highlight>&rcub;. Doing J&Dgr; P, the new J is obtained as &lcub;e<highlight><subscript>2</subscript></highlight>, e<highlight><subscript>3</subscript></highlight>, e<highlight><subscript>4</subscript></highlight>, e<highlight><subscript>5</subscript></highlight>, e&prime;<highlight><subscript>6</subscript></highlight>, e&prime;<highlight><subscript>7</subscript></highlight>, e&prime;<highlight><subscript>1</subscript></highlight>, e&prime;<highlight><subscript>8</subscript></highlight>&rcub;), which is set of two disjoint spanning trees as illustrated in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>. As mentioned before, J&Dgr;&lcub;el, fl, . . . ,em, fm, em&plus;1&rcub; is defined as J &cup;&lcub;e<highlight><subscript>1</subscript></highlight>&rcub;&bsol;&lcub;f<highlight><subscript>l</subscript></highlight>&rcub; . . . &bsol;&lcub;f<highlight><subscript>m</subscript></highlight>&rcub;&cup;e<highlight><subscript>m&plus;</subscript></highlight>1. </paragraph>
<paragraph id="P-0096" lvl="7"><number>&lsqb;0096&rsqb;</number> 7.1.2 Shortest Path Heuristic (SPTH) </paragraph>
<paragraph id="P-0097" lvl="0"><number>&lsqb;0097&rsqb;</number> As described in Section 6, the set of all paths in the graph along with a quantity called the cost of each path is called the cost function of the graph. The Dijkstra algorithm takes the cost function and incidence matrix of the graph as inputs and computes the shortest path tree from a given source to the given set of receivers. </paragraph>
<paragraph id="P-0098" lvl="0"><number>&lsqb;0098&rsqb;</number> In this scheme, the first tree, T<highlight><bold>1</bold></highlight>, is obtained using the Dijkstra algorithm; i.e., T<highlight><bold>1</bold></highlight> is the shortest path tree from the source to the set of receivers. The cost function of the graph is modified after computing the first tree in the following manner&mdash;cost associated with paths used in T<highlight><bold>1</bold></highlight> is increased by an amount called Link Weight and the cost associated with paths which share a common node with T<highlight><bold>1</bold></highlight> is increased by an amount called Node Weight. T<highlight><bold>2</bold></highlight> is computed using the original incidence matrix of the graph and this new cost function. Since the Dijkstra algorithm tries to use paths of the lowest cost, this way of modifying the cost function discourages use of the paths already used in T<highlight><bold>1</bold></highlight> or the paths with a common node with T<highlight><bold>1</bold></highlight> (the extent of the discouragement depends on the values of the parameters Link Weight and Node Weight). Computation of subsequent backup trees is carried out (in a manner similar to the computation of the second tree) by discouraging the use of links and nodes already used in previous trees by further modification of cost function, hence allowing nodes used in both trees to be discourage more than nodes used in just one of them. </paragraph>
<paragraph id="P-0099" lvl="7"><number>&lsqb;0099&rsqb;</number> Shortest Path Heuristic Algorithm  
<table-cwu id="TABLE-US-00002">
<number>2</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>T1&equals;Dijkstra_Algorithm (G,Cost,Source,Receivers)</entry>
</row>
<row>
<entry>Initialize Cost1 to equal Cost for all paths in G</entry>
</row>
<row>
<entry>For each edge i in T1</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="7PT" align="left"/>
<colspec colname="1" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub; Cost1<highlight><subscript>1</subscript></highlight> &equals; Cost<highlight><subscript>1</subscript></highlight> &plus; LinkWeight &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>For each node in T1</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="7PT" align="left"/>
<colspec colname="1" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>For each link in G which is incident on this node in T1</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="196PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub; Cost1<highlight><subscript>1</subscript></highlight> &equals; Cost<highlight><subscript>1</subscript></highlight> &plus; Node Weight &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="7PT" align="left"/>
<colspec colname="1" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>T2&equals;D(G,Cost1,Source,Receivers)</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0100" lvl="7"><number>&lsqb;0100&rsqb;</number> 7.1.3 Low Cost Heuristic (LCH) </paragraph>
<paragraph id="P-0101" lvl="0"><number>&lsqb;0101&rsqb;</number> The Low Cost Heuristic algorithm is designed to reduce the total number of transmissions in the multicast trees. The idea is that a single channel wireless network is a broadcast channel, i.e., when a node transmits a packet all of its neighboring nodes can receive it. Hence to minimize resources used, the total number of transmissions required to send data over the multicast tree should be reduced. To achieve this objective, in the Low Cost Heuristic, each of the trees is constructed path by path. Computation of a tree given an initial cost function is done in the following way&mdash;a path to a node is computed, cost function is modified and then path to next node is computed and added to the partial tree already constructed and so on. </paragraph>
<paragraph id="P-0102" lvl="0"><number>&lsqb;0102&rsqb;</number> The modification of the cost function in between computing paths to each receiver is done in such a way as to encourage use of a minimum number of additional transmissions; i.e., if a link already carries the multicast data, its transmission cost is decreased to a very small value. There will be several links outside the current partial tree with this property, because of the broadcast nature of ad hoc networks. </paragraph>
<paragraph id="P-0103" lvl="0"><number>&lsqb;0103&rsqb;</number> The cost function taken at the beginning of computation of the second tree is a modified version of the original cost function of the tree done in order to discourage use of links and nodes already used in prior trees (for details of modification look at the description in Shortest Path Heuristic). Computation of subsequent backup trees is carried out by discouraging use of links and nodes already used in previous trees by modification of the cost function. </paragraph>
<paragraph id="P-0104" lvl="7"><number>&lsqb;0104&rsqb;</number> Low Cost Heuristic Algorithm  
<table-cwu id="TABLE-US-00003">
<number>3</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>Initialize Cost&prime; to Cost</entry>
</row>
<row>
<entry>For each receiver j</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="7PT" align="left"/>
<colspec colname="1" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub;</entry>
</row>
<row>
<entry></entry>
<entry>P<highlight><subscript>J</subscript></highlight> &equals;D(G,Cost&prime;, Source,j)</entry>
</row>
<row>
<entry></entry>
<entry>For each edge in P1 &oplus; ... &oplus; P<highlight><subscript>J</subscript></highlight></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub;Cost&apos;<highlight><subscript>1</subscript></highlight> &equals; 0&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="7PT" align="left"/>
<colspec colname="1" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>For each node in P1 &oplus; ... &oplus; P<highlight><subscript>J</subscript></highlight></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub;</entry>
</row>
<row>
<entry></entry>
<entry>For each link in G which is incident on this node in P1 &oplus; ... &oplus; P<highlight><subscript>J</subscript></highlight></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="196PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub;Cost&apos;<highlight><subscript>1</subscript></highlight> &equals; &egr;&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="7PT" align="left"/>
<colspec colname="1" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>T1 &equals; P1 &oplus; P2 &oplus; ... &oplus; P<highlight><subscript>N</subscript></highlight></entry>
</row>
<row>
<entry>Initialize Cost1 to Cost</entry>
</row>
<row>
<entry>For each edge i in T1</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="7PT" align="left"/>
<colspec colname="1" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub; Cost1<highlight><subscript>1</subscript></highlight> &equals; Cost<highlight><subscript>1</subscript></highlight> &plus; LinkWeight &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>For each node in T1</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="7PT" align="left"/>
<colspec colname="1" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub;</entry>
</row>
<row>
<entry></entry>
<entry>For each link in G which is incident on this node in T1</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub; c1<highlight><subscript>i</subscript></highlight> &equals; c<highlight><subscript>1&mdash;</subscript></highlight> &plus; NodeWeight&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="7PT" align="left"/>
<colspec colname="1" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>Initialize Cost&prime; to Cost1</entry>
</row>
<row>
<entry>For each receiver j</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="7PT" align="left"/>
<colspec colname="1" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub;</entry>
</row>
<row>
<entry></entry>
<entry>P&apos;<highlight><subscript>J</subscript></highlight>&equals;D(G,Cost&prime;,Source,j)</entry>
</row>
<row>
<entry></entry>
<entry>For each edge in P&apos;1 &oplus; ... &oplus; P&apos;<highlight><subscript>J</subscript></highlight></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub; Cost1<highlight><subscript>1</subscript></highlight> &equals; 0 &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="7PT" align="left"/>
<colspec colname="1" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>For each node in P&apos;1 &oplus; ... &oplus; P&apos;<highlight><subscript>J</subscript></highlight></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub;</entry>
</row>
<row>
<entry></entry>
<entry>For each link in G which is incident on this node in P&apos;1 &oplus; ... &oplus; P&apos;<highlight><subscript>J</subscript></highlight></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="196PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub; c1<highlight><subscript>1</subscript></highlight> &equals; &egr; &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="7PT" align="left"/>
<colspec colname="1" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>T2 &equals; P&apos;1 &oplus; P&apos;2 &oplus; ... &oplus; P&apos;<highlight><subscript>N</subscript></highlight></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0105" lvl="7"><number>&lsqb;0105&rsqb;</number> 7.2 Computing Backup Paths With The Independent Path Algorithm (IPA) </paragraph>
<paragraph id="P-0106" lvl="0"><number>&lsqb;0106&rsqb;</number> As discussed previously, a more preferred technique for implementing the invention is to calculate backup paths instead of backup trees. The Independent Path Algorithm is an example of an algorithm that computes trees such that paths to each receiver in these trees are disjoint, while allowing paths to different receivers to overlap across trees. Again, it will be understood that this algorithm is exemplary and that the alternate path version of the invention is not limited to use with this specific algorithm. The problem with using trees as backup is that even if just one link in the tree fails, the whole tree needs to be replaced by another, when most of the first tree may be intact. Instead, using the Independent Path Algorithm, one starts off with a tree and then for each receiver, the algorithm computes a set of backup paths which are maximally disjoint from one another and from the path to the receiver in the first tree. </paragraph>
<paragraph id="P-0107" lvl="0"><number>&lsqb;0107&rsqb;</number> The first tree can be computed using either the Dijkstra algorithm or using the Low Cost Heuristic (if cost is critical). For each receiver, a path independent of the original path to the node in the first tree is computed by modifying the cost function (as in the Shortest Path Heuristic) in order to discourage use of already used nodes and paths. </paragraph>
<paragraph id="P-0108" lvl="0"><number>&lsqb;0108&rsqb;</number> This method differs from the backup tree methods not only in that it replaces only the damaged part of the tree (local repair) but also in that the backup path to any given receiver can overlap with the rest of the first tree (apart from what is being used to transmit data to that receiver). It is more likely to find paths independent from a given path rather than one independent from a given tree. As in the previous two methods, computation of subsequent backup trees is carried out (similar to the second tree) by discouraging use of links and nodes already used in previous trees by modifying the cost function. </paragraph>
<paragraph id="P-0109" lvl="7"><number>&lsqb;0109&rsqb;</number> Independent Path Algorithm  
<table-cwu id="TABLE-US-00004">
<number>4</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>T1&equals;D(G,Cost,Source,Receivers)</entry>
</row>
<row>
<entry>Initialize Cost1 to equal Cost</entry>
</row>
<row>
<entry>For receiver node k</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="7PT" align="left"/>
<colspec colname="1" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub;</entry>
</row>
<row>
<entry></entry>
<entry>For link i in path (in T1) to node k</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub; Cost1<highlight><subscript>1</subscript></highlight> &equals; Cost<highlight><subscript>1</subscript></highlight> &plus; Link Weight &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="7PT" align="left"/>
<colspec colname="1" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>For each node in path (in T1) to node k</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="7PT" align="left"/>
<colspec colname="1" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>For each link in G which is incident on this node in T1</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lcub; c1<highlight><subscript>1</subscript></highlight> &equals; c<highlight><subscript>1</subscript></highlight> &plus; Node Weight &rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="7PT" align="left"/>
<colspec colname="1" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry>Backup Path to k&equals;D(G,Cost1,Source,k)</entry>
</row>
<row>
<entry>&rcub;</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0110" lvl="7"><number>&lsqb;0110&rsqb;</number> 8. Criteria Used For Performance Comparison </paragraph>
<paragraph id="P-0111" lvl="0"><number>&lsqb;0111&rsqb;</number> The algorithms that are employed in the various embodiments of the present invention were evaluated using simulations for a number of performance criteria, which are discussed in this section. </paragraph>
<paragraph id="P-0112" lvl="7"><number>&lsqb;0112&rsqb;</number> A. Cost </paragraph>
<paragraph id="P-0113" lvl="0"><number>&lsqb;0113&rsqb;</number> A number, cost c<highlight><subscript>1</subscript></highlight>, is associated with each link i in the graph. As in traditional networks, it could be chosen to be inversely proportional to the link capacity, proportional to the current load on the link, the delay of the link, etc, or some combination of these parameters. Hence it changes with changes in the network, such as congestion. For example, the cost of a failed link is infinite. The choice depends on what one would like to minimize while communicating information in a given multicast group. </paragraph>
<paragraph id="P-0114" lvl="0"><number>&lsqb;0114&rsqb;</number> The cost of a tree is defined as the sum of the costs of all the links in the tree. The cost of a set of trees is defined as the sum of the costs of all the trees in the set. For a given multicast group size, the average cost of a scheme is the weighted average of the cost of all the trees being computed, weighted by the average amount of time each of the trees is being used. </paragraph>
<paragraph id="P-0115" lvl="7"><number>&lsqb;0115&rsqb;</number> B. Dcost </paragraph>
<paragraph id="P-0116" lvl="0"><number>&lsqb;0116&rsqb;</number> The idea behind defining Dcost is that in a single channel wireless network, the MAC layer is naturally of broadcast type. In other words, when a node transmits, all its neighbors are able to listen to it. Hence the cost of transmission of information to all neighbors from one node is the same as the cost of transmission to the most &ldquo;expensive&rdquo; neighbor. To find Dcost, the tree graph T is divided into many trees T<highlight><superscript>j </superscript></highlight>with the following property&mdash;if an edge i belongs to T<highlight><superscript>j </superscript></highlight>for some j, all paths in T with the same origin node as i (denoted by O<highlight><subscript>i</subscript></highlight>) also belong to T<highlight><superscript>j </superscript></highlight>and all other edges belonging to T<highlight><superscript>j </superscript></highlight>have the origin node O<highlight><subscript>i</subscript></highlight>. With each T<highlight><superscript>j </superscript></highlight>we associate a number dc<highlight><subscript>j </subscript></highlight>which is &lcub;max c<highlight><subscript>1</subscript></highlight>:i&egr;T<highlight><superscript>j</superscript></highlight>&rcub;. The Dcost of the tree T is then defined as &Sgr;<highlight><subscript>i</subscript></highlight>dc<highlight><subscript>j</subscript></highlight>. The Dcost of a set of trees is defined as the sum of Dcosts of the trees in the set. </paragraph>
<paragraph id="P-0117" lvl="0"><number>&lsqb;0117&rsqb;</number> Just as in the case of cost, the average Dcost of a scheme is the weighted average of the Dcost of all the trees being computed, weighted by the average amount of time each of the trees is being used. </paragraph>
<paragraph id="P-0118" lvl="7"><number>&lsqb;0118&rsqb;</number> C. Time Of Failure Or Mean Time Between Interruptions </paragraph>
<paragraph id="P-0119" lvl="0"><number>&lsqb;0119&rsqb;</number> Time of failure of a tree is the minimum time by which at least one of the links of the tree fails and the time of failure of the system is the minimum time at which all paths, (in the first and the backup trees) to at least one of the multicast receivers fail. </paragraph>
<paragraph id="P-0120" lvl="0"><number>&lsqb;0120&rsqb;</number> The terms, system time and the mean time between interruptions, are used interchangeably since an interruption occurs whenever there is a failure of all the trees triggering re-computation of trees. </paragraph>
<paragraph id="P-0121" lvl="7"><number>&lsqb;0121&rsqb;</number> D. Probability Of Usefulness </paragraph>
<paragraph id="P-0122" lvl="0"><number>&lsqb;0122&rsqb;</number> The probability that the backup set computed by any of the above schemes will be used is defined as the probability of usefulness. It is that fraction of the total number of trials for which failure time of the system is greater than failure time of the first tree. </paragraph>
<paragraph id="P-0123" lvl="7"><number>&lsqb;0123&rsqb;</number> E. Increase In Mean Time Between Interruptions </paragraph>
<paragraph id="P-0124" lvl="0"><number>&lsqb;0124&rsqb;</number> The increase in mean time between interruptions due to backup is T<highlight><subscript>system</subscript></highlight>&mdash;T<highlight><subscript>tree1</subscript></highlight>. Here T<highlight><subscript>system </subscript></highlight>is the time of failure of the system and T<highlight><subscript>treel </subscript></highlight>is the time of failure of tree <highlight><bold>1</bold></highlight>. </paragraph>
<paragraph id="P-0125" lvl="7"><number>&lsqb;0125&rsqb;</number> 9. Simulation Results And Discussion </paragraph>
<paragraph id="P-0126" lvl="0"><number>&lsqb;0126&rsqb;</number> A number of simulation experiments were conducted to evaluate the performance of the four techniques (MIA, SPTH, LCH, IPA) employed in the preferred embodiments to calculate backup trees and paths. Overall, it was found that the IPA gives much better performance than the others with very small increase in transmission cost of the multicast trees. A more detailed discussion of the results follows. </paragraph>
<paragraph id="P-0127" lvl="0"><number>&lsqb;0127&rsqb;</number> For one backup tree, the average cost of trees used was not very different for the various schemes. However, the average number of transmissions required per packet, the Dcost, was found to be significantly higher for the Matroid Intersection Algorithm, while the Dcost curves for the other three schemes were relatively bunched together. This is because of the fact that the Matroid Intersection Algorithm, in the process of making the two spanning trees path disjoint, causes links incident on any given node to be distributed among the two spanning trees. Hence, there is a lower number of links incident on any given node in each of these spanning trees when compared to the whole network. Because of this, each multicast tree has a smaller number of outgoing links to choose from at each node and hence has a larger number of transmissions. </paragraph>
<paragraph id="P-0128" lvl="0"><number>&lsqb;0128&rsqb;</number> If one were using just one tree, it would be expected that the mean time between interruptions would be reduced with an increase in the multicast group size. This is so, since the increase in multicast group size increases the size of the tree and hence increases the probability that at least one of the links fails by any given time. However, while using backups, the total time for which the system lasts may increase with an increase in the multicast group size due to an increase in the probability of usefulness. This is because even though the first tree fails faster, the backup trees are available more often, hence increasing the total time (on an average) for which the set of trees lasts. In terms of the mean time between interruptions and increase in it due to use of backup, the schemes can be ranked in the following order: IPA, MIA, LCH and SPTH with the IPA performing best. The two trees in LCH are expected to have greater independence than in the SPTH, because by encouraging several links from one node to be included in the first tree, the tree is made to occupy a smaller &ldquo;area,&rdquo; hence leaving greater space for the other tree to be formed without having to overlap with the first one. </paragraph>
<paragraph id="P-0129" lvl="0"><number>&lsqb;0129&rsqb;</number> MIA ensures that the trees are almost path disjoint, by computing the two trees simultaneously while the SPTH and LCH compute the first tree before the second one, hence losing out on the possibility of combined optimization. IPA lasts much longer than other schemes, especially for larger multicast groups, because of the fact that it includes local repair. Firstly, since independence means that the two paths to each receiver are independent of one another, the average dependence does not increase much with size of the multicast group like the other schemes. Secondly, since local repair is implemented, if one part of first tree and one part of the second tree have failed, the system can still be working by some combination of the two trees, hence increasing the system time. </paragraph>
<paragraph id="P-0130" lvl="0"><number>&lsqb;0130&rsqb;</number> The probability of usefulness was found to decrease with the increase in dependence between the two trees. For the tree based algorithms, dependence between the two trees increases with the increase in multicast group size, because each tree occupies more &ldquo;area.&rdquo; On the other hand, as the size of a tree increases, its failure time decreases. For this reason, given that the first tree fails, it is very likely that the rest of the network is intact and hence the second tree is intact with higher probability. These opposing factors were noted especially in the case of SPTH. On the other hand, the LCH curve did not change much, because the two factors balanced each other out. In the case of MIA the two trees are almost path disjoint, irrespective of the size of the group and hence only the second factor dominates. The same is true for the IPA because, as described in the previous paragraph, its dependence does not increase much with group size. </paragraph>
<paragraph id="P-0131" lvl="0"><number>&lsqb;0131&rsqb;</number> Results for two and three backup trees followed the same trends for various parameters as the one backup case with greater improvements in terms of mean time between interruptions, probability of usefulness, and higher cost and Dcost of trees. Using IPA was found to result in a greater increase in mean time between interruptions than SPTH and LCH for any amount of backup used. Surprisingly, it was also observed that for IPA the improvement in time due to third backup tree was greater than the improvement due to second backup tree. This is also true for LCH and SPTH for low multicast group sizes, where dependence between two trees is still low. </paragraph>
<paragraph id="P-0132" lvl="0"><number>&lsqb;0132&rsqb;</number> The simulations also established that increase in the probability of usefulness decreases with increase in number of backup trees. This is an expected result because with increase in n, the probability that at least one first n&minus;1 backup tree is available along with the nth backup tree at the time of failure of the first tree increases. </paragraph>
<paragraph id="P-0133" lvl="0"><number>&lsqb;0133&rsqb;</number> The simulations also confirmed, as discussed in Section 3, that maximum independence among the trees does not maximize mean time between interruptions. The simulation in this regard used the Independent Path Algorithm and a 30 node network with node degree of 6 and one backup tree. The Link Weight and Node Weight parameters which regulate the amount of dependence were set equal to each other and varied over the range &lsqb;1, 30&rsqb;. It was found that increase in the Link Weight/Node Weight increases the average Dcost of trees monotonically and decreases the number of common edges (and hence dependence) monotonically. However, the mean time between interruptions was found to increase first, until a Link Weight/Node Weight value of 2 and then decreased slightly to reach a saturation level. This illustrates the trade off between dependence of a pair of trees and the total time for which at least one of them lasts. Hence, the principles of the present invention perform best when some dependence is allowed among the set of trees by choosing a relatively moderate value for the Link Weight and Node Weight parameters in the tree computation algorithms. </paragraph>
<paragraph id="P-0134" lvl="7"><number>&lsqb;0134&rsqb;</number> 10. Conclusion </paragraph>
<paragraph id="P-0135" lvl="0"><number>&lsqb;0135&rsqb;</number> The use of multiple backup trees or paths in the various embodiments of the present invention that are available for immediate replacement of failed trees or paths provide the multicasting operation in an ad hoc or other networks with a working backup infrastructure having high probability without much extra expense in terms of cost of the trees or computation or data collection. Each of the exemplary algorithms employed in the preferred embodiments seeks to provide an optimal level of independence that allows for maximum mean time between interruptions. In addition, timely update of the backup tree or path set before actual failure of a current tree set is preferably employed in the various embodiments of the present invention to keep the probability of interruption below a desired value. </paragraph>
<paragraph id="P-0136" lvl="0"><number>&lsqb;0136&rsqb;</number> Although the invention has been disclosed in terms of a number of preferred embodiments and variations thereon, it will be understood that numerous other variations and modifications could be made thereto without departing from the scope of the invention as defined in the following claims. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method of operating a multicasting communications network comprising the steps of 
<claim-text>a) providing a multicasting communications network formed of a plurality of nodes and links connecting said nodes to facilitate communication among said nodes; </claim-text>
<claim-text>b) calculating a first multicast routing scheme, said multicast routing scheme defining, for each of said nodes, a plurality of paths for facilitating communication with each of said other nodes in said network, said paths each being formed by one or more of said links; </claim-text>
<claim-text>c) calculating one or more alternate multicast routing schemes to be employed if said first multicast routing scheme fails due to failure of one or more of said links or nodes; </claim-text>
<claim-text>b) implementing multicasting communications between said nodes in said network by interconnecting said nodes in accordance with said first multicast routing scheme; and </claim-text>
<claim-text>d) interconnecting said nodes in accordance with one of said alternate multicast routing schemes if said first multicast routing scheme fails. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising the steps of estimating a time at which a probability of said one or more alternate multicast routing schemes failing exceeds a predetermined threshold; employing said estimated time to determine a time at which calculation of one or more additional alternate multicast routing schemes should begin; and, calculating one or more additional alternate multicast routing schemes at said determined time. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein said first multicast routing scheme comprises a first set of routing trees that define how each of said nodes is connected to one or more of said other of said nodes using said links, and said one or more alternate multicast routing schemes comprise one or more set of backup trees. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference>, wherein said sets of alternate multicast backup trees are calculated using an algorithm that maximizes the independence of said alternate multicast trees relative to said first set of multicast trees by minimizing the number of said nodes and links that are employed in said first set of trees. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein said first multicast routing scheme comprises a first set of multicast routing trees that define how each of said nodes is connected to one or more of said other of said nodes using said paths, and said alternate multicast routing schemes comprise one or more sets of backup paths to be used if one or more of said paths in said first set of multicast routing trees fails. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference>, wherein said one or more sets of backup paths are calculated using an algorithm that maximizes the independence of said backup paths relative to the paths employed in said first set of multicast trees. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. A multicasting communications network comprising: 
<claim-text>a) a plurality of communications nodes; and </claim-text>
<claim-text>b) a plurality of links connecting said nodes to facilitate communication among said nodes; </claim-text>
<claim-text>wherein, each of said nodes includes: 
<claim-text>1) a transceiver for receiving communications from and transmitting communications to other of said nodes in said network </claim-text>
<claim-text>2) a processor for controlling operation of said transceiver, said processor being programmed to calculate a first multicast routing scheme, said multicast routing scheme defining, for each of said nodes, a plurality of paths for facilitating multicast communication with each of said other nodes in said network, said paths each being formed by one or more of said links, and one or more alternate multicast routing schemes to be employed if said first routing scheme fails due to failure of one or more of said links or nodes; and </claim-text>
<claim-text>3) a database for storing said first and one or more alternate multicast routing schemes. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The network of <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference>, wherein said processor is programmed to estimate a time at which a probability of said one or more alternate multicast routing schemes failing exceeds a predetermined threshold, employ said estimated time to determine a time at which calculation of one or more additional alternate multicast routing schemes should begin, and calculate one or more additional alternate multicast routing schemes at said determined time. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The network of <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference>, wherein said first routing scheme comprises a first set of multicast routing trees that define how each of said nodes is connected to one or more of said other of said nodes using said links, and said one or more alternate multicast routing schemes comprise one or more set of backup trees. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The network of <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, wherein said processor is programmed to calculate said sets of alternate backup multicast trees using an algorithm that maximizes the independence of said alternate multicast trees relative to said first set of multicast trees by minimizing the number of said nodes and links that are employed in said first set of multicast trees. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The network of <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference>, wherein said first routing scheme comprises a first set of multicast routing trees that define how each of said nodes is connected to one or more of said other of said nodes using said paths, and said alternate multicast routing schemes comprise one or more sets of backup paths to be used if one or more of said paths in said first set of multicast routing trees fails. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The network of <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, wherein said processor is programmed to calculate said one or more sets of multicast backup paths using an algorithm that maximizes the independence of said multicast backup paths relative to the paths employed in said first set of trees. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The network of <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference>, wherein said network is an ad-hoc network.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>1</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005149A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005149A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005149A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005149A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
