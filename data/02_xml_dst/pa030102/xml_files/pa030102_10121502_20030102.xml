<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030004959A1-20030102-M00001.NB SYSTEM "US20030004959A1-20030102-M00001.NB" NDATA NB>
<!ENTITY US20030004959A1-20030102-M00001.TIF SYSTEM "US20030004959A1-20030102-M00001.TIF" NDATA TIF>
<!ENTITY US20030004959A1-20030102-D00000.TIF SYSTEM "US20030004959A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030004959A1-20030102-D00001.TIF SYSTEM "US20030004959A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030004959A1-20030102-D00002.TIF SYSTEM "US20030004959A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030004959A1-20030102-D00003.TIF SYSTEM "US20030004959A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030004959A1-20030102-D00004.TIF SYSTEM "US20030004959A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030004959A1-20030102-D00005.TIF SYSTEM "US20030004959A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030004959A1-20030102-D00006.TIF SYSTEM "US20030004959A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030004959A1-20030102-D00007.TIF SYSTEM "US20030004959A1-20030102-D00007.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030004959</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10121502</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20020412</filing-date>
</domestic-filing-data>
<foreign-priority-data>
<priority-application-number>
<doc-number>GB9924523.5</doc-number>
</priority-application-number>
<filing-date>19991015</filing-date>
<country-code>GB</country-code>
</foreign-priority-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F007/00</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>707</class>
<subclass>100000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Database processor</title-of-invention>
</technical-information>
<continuity-data>
<continuations>
<continuation-of>
<parent-child>
<child>
<document-id>
<doc-number>10121502</doc-number>
<kind-code>A1</kind-code>
<document-date>20020412</document-date>
</document-id>
</child>
<parent>
<document-id>
<doc-number>PCT/GB00/03963</doc-number>
<document-date>20001016</document-date>
<country-code>US</country-code>
</document-id>
</parent>
<parent-status>UNKNOWN</parent-status>
</parent-child>
</continuation-of>
</continuations>
</continuity-data>
<inventors>
<first-named-inventor>
<name>
<given-name>Nikolaos</given-name>
<family-name>Kotsis</family-name>
</name>
<residence>
<residence-non-us>
<city>Glasgow</city>
<country-code>GB</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Douglas</given-name>
<middle-name>Robert</middle-name>
<family-name>MacGregor</family-name>
</name>
<residence>
<residence-non-us>
<city>Glasgow</city>
<country-code>GB</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<assignee>
<organization-name>University of Strathclyde</organization-name>
<address>
<city>Glasgow</city>
<country>
<country-code>GB</country-code>
</country>
</address>
<assignee-type>03</assignee-type>
</assignee>
<correspondence-address>
<name-1>ALSTON &amp; BIRD LLP</name-1>
<name-2>BANK OF AMERICA PLAZA</name-2>
<address>
<address-1>101 SOUTH TRYON STREET, SUITE 4000</address-1>
<city>CHARLOTTE</city>
<state>NC</state>
<postalcode>28280-4000</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A database processor for on-line transaction processing has significantly reduced storage. The processor is arranged to obtain multi-dimensional aggregates of an input relation after a pre-processing stage which identifies aggregates which can be obtained without computation, said pre-processing stage being arranged to: i) identify and store the primary keys derived from the schema of the input relation; ii) establish a Group-by schema generator to generate schemas from minimum arity to maximum arity of aggregate for the possible aggregates of the input relation; iii) sequentially in an arity order beginning with single columns and proceeding in an order in which each lower level of every sub-tree is visited before any root (i.e., breadth-wise from the lowest level to the highest node of the lattice) comparing the generated schemas with the primary keys stored in step (i) augmented by any previous schema identified as being a key and in the event of a generated schema containing a stored key treating the input relation as the virtual representation of the corresponding Group-by aggregate without computation. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> This invention relates to an improved database processor and system architecture. </paragraph>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> Relational database management systems (DBMSs) are used throughout organisations for maintaining data that changes on a daily basis recording individual transactions as they occur. These databases are called operational databases and their data processing applications are known as On-Line Transaction Processing (OLTP) applications. DBMSs have been able to perform these functions satisfactorily for some years. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> Increasingly organizations utilize data processing applications which allow them to compare current and past data, enabling them to highlight trends and thus support decision making. In order that the decision support system is effective, many organizations create consolidated data warehouses which collect the data from several heterogeneous operational databases or other information sources and integrate them for retrieval of historical and summary information. This is known as On-Line Analytical Processing (OLAP) and the computations required are complex, involve large volumes of data and typically involve data aggregation. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> The functional and performance requirements of OLAP are quite different from those of the OLTP data processing applications traditionally supported by the operational databases. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> OLTP applications typically automate clerical data processing tasks such as order entry and banking transactions that are the day-to-day operations of an organisation. These tasks are structured, repetitive and consist of short, atomic isolated transactions which require detailed, up-to-date data, and read or update, a few (tens of) records accessed typically on their primary keys. Operational databases tend to be hundreds of megabytes to gigabytes in size. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> OLAP applications in contrast, are targeted for decision support. Historical summarised and consolidated data is more important than detailed, individual records. Since data warehouses typically contain consolidated data from several databases, potentially over long periods of time (for example as indicated in Table I), they tend to be orders of magnitude larger than the operational databases. The workloads are query intensive with mostly ad-hoc, complex queries that can access millions of records. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> Most database management systems to-day are based on the relational data model. The central data description construct in this model is a relation which is a set of records, each of which has the same number (and type) of fields. A database is a collection of one or more relations and includes a schema&mdash;a description of the data. In the relational model, the schema for a relation specifies its name, the name of each field (or attribute or column) and the domain (type) of each field. For example, a relation called Product may have the following schema: </paragraph>
<paragraph id="P-0008" lvl="1"><number>&lsqb;0008&rsqb;</number> Product(Product_ID:string, Type:string, Day:string, Month:integer, Year:integer), </paragraph>
<paragraph id="P-0009" lvl="7"><number>&lsqb;0009&rsqb;</number> which denotes that each row in the relation has four fields, with field names and types as indicated. An example instance of the Product relation would be:  
<table-cwu id="TABLE-US-00001">
<number>1</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="84PT" align="center"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="91PT" align="center"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Product_ID</entry>
<entry>Type</entry>
<entry>Production_Year</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>P1</entry>
<entry>Shampoo</entry>
<entry>1997</entry>
</row>
<row>
<entry>P2</entry>
<entry>Soap</entry>
<entry>1998</entry>
</row>
<row>
<entry>P3</entry>
<entry>Conditioner</entry>
<entry>1998</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> Relational systems allow a wide variety of queries to be posed easily. An example of the type of query the relational system enables are user to find is: </paragraph>
<paragraph id="P-0011" lvl="2"><number>&lsqb;0011&rsqb;</number> Find the products which have been produced in 1998 </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> The most widely used commercial relational database language is the Structured Query Language (SQL). The above query can be posed to the database through ANSI/ISO SQL-92 in the following form: </paragraph>
<paragraph id="P-0013" lvl="1"><number>&lsqb;0013&rsqb;</number> SELECT P.Product_ID, P.Type, P.Day, P.Month, P.Year </paragraph>
<paragraph id="P-0014" lvl="1"><number>&lsqb;0014&rsqb;</number> FROM Product </paragraph>
<paragraph id="P-0015" lvl="1"><number>&lsqb;0015&rsqb;</number> WHERE P.Year&equals;1998 </paragraph>
<paragraph id="P-0016" lvl="7"><number>&lsqb;0016&rsqb;</number> The abbreviation of P stands for the full relation name (Product). </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> The result relation of the above query is:  
<table-cwu id="TABLE-US-00002">
<number>2</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="84PT" align="center"/>
<colspec colname="2" colwidth="42PT" align="left"/>
<colspec colname="3" colwidth="91PT" align="center"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Product_ID</entry>
<entry>Type</entry>
<entry>Production_Year</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>P2</entry>
<entry>Soap</entry>
<entry>1998</entry>
</row>
<row>
<entry>P3</entry>
<entry>Conditioner</entry>
<entry>1998</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> For OLAP applications a recently proposed multidimensional conceptual model may be used in preference to the tabular model (Table I) of the relational system. Data are represented to the users as a multidimensional Cube. The multidimensional model can be associated with the Sales relation shown in Table I. Each domain is classified either as a Dimension or a Measure of Interest. In this example, the measure of interest is Total_Sales and the dimensions are PRODUCT_ID, STORE, MONTH. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> The fundamental operation in OLAP applications is aggregating a measure over one or more dimensions. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> In the cube those domains considered as dimensions are placed on the sides of the cube and the measure of interest (Total_Sales) is the content of each cell of the multidimensional array as shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> The cube data model introduced new conceptual operations. The user can &lsquo;rollup&rsquo; the cube to obtain a less detailed more abstract view of the data. In the opposite process the user can &lsquo;drill-down&rsquo; expanding the representation from the total to a further level of detail. &lsquo;Slice&rsquo; amounts to equality selection and &lsquo;dice&rsquo; amounts to a range selection. &lsquo;Rotate&rsquo; is when the view is rotated 90 degrees clockwise without any rearrangement of the data. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> A dimension may be associated with a hierarchy. For example the TIME dimension could have the following hierarchy: </paragraph>
<paragraph id="P-0023" lvl="1"><number>&lsqb;0023&rsqb;</number> YEAR -------&gt; QUARTER --------&gt; MONTH --------&gt; DAY </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> The multidimensional operations can utilize such hierarchies, e.g., Rollup of a TIME dimension can be done to each of the above levels as required by the user. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> Aggregation which is the fundamental operation in OLAP transactions is classified into Scalar aggregates and aggregate functions. Scalar aggregates calculate a single scalar value from a unary-input relation, e.g., the max value of an attribute in a relation. An aggregate function takes a binary input relation, e.g., Total of Sales in each country. The aggregate functions take relations as input and return relations as an output. They are classified into Distributive, Algebraic and Holistic. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> For example, the users of such a system typically wish to obtain information of much larger granularity than a single sale, e. g, The Stores&apos; performance per month, irrespective of the individual product. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> This would require as regards the relation in Table I aggregation of Total_Sales over the STORE and TIME dimensions. It can be expressed using the following SQL statement  
<table-cwu id="TABLE-US-00003">
<number>3</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="35PT" align="left"/>
<colspec colname="1" colwidth="70PT" align="left"/>
<colspec colname="2" colwidth="112PT" align="left"/>
<thead>
<row>
<entry></entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
<entry>SELECT</entry>
<entry>Store, Time as (SUM) Sales</entry>
</row>
<row>
<entry></entry>
<entry>FROM</entry>
<entry>Sales</entry>
</row>
<row>
<entry></entry>
<entry>GROUP-BY</entry>
<entry>Store, Time</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0028" lvl="7"><number>&lsqb;0028&rsqb;</number> to give the result shown in Table II. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> There are three disadvantages in the SQL/relational approach. The first is that many different aggregations are possible. In typical practical cases, the Sales relation of the above example may well have many more domains than shown in the example and each different aggregate requires a distinct SQL program. The second disadvantage is that it is by no means easy to visualise the computations conceptually. Finally, most users to-day expect to manipulate their data graphically. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> The user interface to the Multidimensional data model (Cube) allows the user to specify the conceptual multidimensional operators graphically, for example as shown in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> Users in OLAP systems typically require to investigate many of the different possible aggregates. Given a measure of N dimensions there are 2<highlight><superscript>N </superscript></highlight>possible aggregates (the above example with three dimensions giving rise to 8 aggregates). It is important that users can specify and visualize the different levels of aggregation with ease. Typically this would be done in real time using a graphical user interface operating with the Cube-by operator to explore the multidimensional environment. The Cube-by operator is the n-generalization of simple aggregate functions and it computes Group-bys corresponding to all possible combinations of a list of attributes. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> With the introduction of the Cube-by operator it became easier for users to specify and visualize different levels of aggregation. However, the processing required to support this operator is enormous in terms of time and storage. Particularly where hierarchies are involved the effective number of possible combinations becomes unmanageable. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> Many workers have attempted to approach the implementation of the Cube-by by directly implementing Materialized Views which are precomputed for later retrieval. This is because it has been judged that the computation of aggregates &lsquo;on the fly&rsquo; (i.e., on demand) would be too slow. Though significant research has been carried out to optimize the Materialized View approach, the method is inherently unsatisfactory. First there are a large number of Views. This implies a long precomputation time and precludes even modest update. Storage of the Views requires storage capacity which is possibly more than an order of magnitude greater than that required for the original data. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> For the highest aggregations, the pre-computation approach is economical in the additional storage resources consumed, while providing gratifyingly rapid response. The low-level aggregates however are large and numerous, resulting in a many-fold expansion of the original relation. They virtually always require further processing, e.g., restriction, etc., to extract the tuples of interest. The most significant disadvantage, however, of the pre-computational approach is that it is not suited to dealing with update, other than as a batch-type operation separate from its interactive use. While there are undoubtedly situations in which this is acceptable, it nevertheless represents a major restriction on the system performance envelope for this approach. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> The major disadvantage of a purely direct computational approach (i.e., on the fly) is the work which must be undertaken for each operation, and hence the much greater delay given equivalent systems performance parameters. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> A partial-computation approach is possible but has been a subject of research by many workers mainly because to select the materialized views is not trivial. Systems architecture has also been the subject of research to minimize the total query response and the cost of maintaining the selected views, given a limited amount of resources (time, storage). </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> The above mentioned approaches have their advantages and disadvantages. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> It is an object of the present invention to provide a new and improved database processor and system architecture. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> The present invention is directed to a database processor and system architecture capable of operating as as On-line Analytical Processing (OLAP) system for the implementation of multidimensional aggregates of an input relation, and which is arranged to obtain such multidimensional aggregates after a pre-processing stage which identifies aggregates which can be obtained without computation, said pre-processing stage being arranged to: </paragraph>
<paragraph id="P-0040" lvl="2"><number>&lsqb;0040&rsqb;</number> i) identify and store the primary keys derived from the schema of the input relation; </paragraph>
<paragraph id="P-0041" lvl="2"><number>&lsqb;0041&rsqb;</number> ii) establish a Group-by schema generator to generate schemas from minimum arity to maximum arity of aggregate for the possible aggregates of the input relation; </paragraph>
<paragraph id="P-0042" lvl="2"><number>&lsqb;0042&rsqb;</number> iii) sequentially in an arity order beginning with single columns and proceeding in an order in which each lower level of every sub-tree is visited before any root (i.e., breadth-wise from the lowest level to the highest node of the lattice) comparing the generated schemas with the primary keys stored in step (i) augmented by any previous schema identified as being a key and in the event of a generated schema containing a stored key treating the input relation as the virtual representation of the corresponding Group-by aggregate without computation. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> Preferably the arity order is the sequence minimum arity to maximum arity. Alternatively the arity order (known as &lsquo;post order&rsquo;) may be used in which all the sub-trees of each sub-tree are visited before the root of that sub-tree. This commences with a least some schemas of minimum arity followed by those higher arities which utilise schemas of the minimum arity which have already been dealt with, and so on. In any event the order ensures that those schemas of higher arity are dealt with subsequently to the sub-schemas of lower arity. Accordingly for a schema ABC the sub-schemas are A, B, C, AB, AC, BC and the order referred to may be A,B, C, AB, AC, BC or A, B, AB, C, AC, BC or B, C, BC, A, AB, AC, etc. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> Preferably in accordance with the present invention, in sequence, each schema which is not found to contain a stored key according to step (iii) is subjected to a secondary check step, wherein an upper bound size of the Group-by relation defined by the current such schema is evaluated and the size of the input relation is compared against that upper bound size and in the event of the upper bound size not being less than the size of the input relation, sequentially comparing the tuples of the current schema and in the absence of tuple-duplication recognising that the current schema is a key and treating the input relation as the virtual representation of the corresponding Group-by aggregate without computation. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> The upper bound size of the Group-by relation defined by the current schema may be evaluated according to a pre-determined algorithm for example based upon the product of the cardinalities (i.e., number of distinct values in a column) of the relation. There are various other algorithms which may take into account previously-evaluated upper bound sizes. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> Preferably those generated Group-by schemas which are recognised as being or as containing a key are effectively stored to permit subsequent retrieval of the corresponding Group-by aggregate without computation. The store may contain pointers to such schemas since such pointers in effect represent the schema. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> Preferably those generated Group-by schemas which are recognised as being or as containing a key are effectively stored to permit subsequent retrieval of the corresponding Group-by aggregate without computation. The store may contain pointers to such schemas since such pointers in effect represent the schema. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> It will be understood that, in accordance with Relational Theory, a Relation R, which is defined over Domains &lcub;d<highlight><subscript>1 </subscript></highlight>. . . d<highlight><subscript>n</subscript></highlight>&rcub;, is composed of a set of tuples each of which has the same number and type of fields. (The complete tuple must be distinct for it to conform to the definition of any Relation as being a set of tuples). One domain (or combination of domains which is minimal in number) of a given relation has values which uniquely identify each element (n-tuple) of that relation. Such a domain (or combination) is called a primary key. In general there may be several primary keys. Primary Keys belong to two different categories: Definitional and Observational. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> Observational Primary Keys are dimension domains, or a set of dimension domains that together possess the unique identification property for a relation within a particular dataset or instance of the database. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> The unique identification property is invariant for an observational primary key in a read-only database, but may be destroyed by updates to the dataset. Thus an observational primary key is equivalent to a definitional primary key in a read-only database, or until an update to the relation occurs in the case of a transactional database. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> Definitional Primary Keys are those observational keys which have been defined as part of the schema (e.g., by the database designer) and remain keys irrespective of allowed changes in the data set. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> The present invention is founded upon the fact that where the result of an aggregate is equivalent to the input relation the aggregate does not require to be explicitly computed. For example, consider an Aggregation as any operation (applied to a parent relation R) that produces a result relation Rc which consists of a projection of the relation R over a subset of domains, while at the same time applying an operator (e.g., SUM) to the attribute defined as the Measure of Interest. Each tuple of the result relation Rc is either derived from a single tuple of R, or from the combination of two or more tuples of R which have the same dimensional values in the dimensions projected in Rc as shown in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> By virtue of the present invention the amount of aggregate computation and aggregate storage required in an OLAP system is significantly reduced. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> Preferably and also independently, those Group-by schemas which require computational aggregation are computationally aggregated and each aggregate is assessed to identify whether or not it is similar to the parent relation by having almost the same cardinality (i.e., number of tuples) as the input relation, in which case to reduce storage space only those tuples that differ from the input relation need to be represented, whereby the aggregate can be obtained from this representation of the difference and from the input relation. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> It will be understood in the context of database processors that items may be represented by explicit storage of the item or by various other known techniques which enable the item to be realised. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> As a result of the present invention and the preferred embodiments thereof the database processor and system architecture can effectively represent a significant percentage (typically greater than 50%) of the aggregates, as though everything had been computed, the storage of these representations being within the original database and even if the remainder of the aggregates are actually computed and stored these are within a small percentage of the space required by the conventional materialised views process, and the amount of processing is greatly reduced. Typically over different datasets savings of the order of 50% in space and time can be achieved.</paragraph>
</summary-of-invention>
<brief-description-of-drawings>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> Embodiments of the present invention will now be described by way of example with reference to the accompanying drawings in which: </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> illustrates a multi-dimensional cube; </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> shows the <cross-reference target="DRAWINGS">FIG. 1</cross-reference> cube from a different perspective and illustrates the effect of roll-up and drill-down operations; </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> illustrates a dataset R and the aggregation dataset R<highlight><subscript>c </subscript></highlight>produced by the SUM operator applied to R; </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 4 and 5</cross-reference> together illustrate three alternative known pre-processing stages for use with three known querying stages together forming three known OLAP systems; </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 6 and 7</cross-reference> illustrate the pre-processing and the querying stages of an OLAP system in accordance with the present invention; </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 8A, 8B</cross-reference>, <highlight><bold>9</bold></highlight> and <highlight><bold>10</bold></highlight> identify detailed methods used in the system of <cross-reference target="DRAWINGS">FIGS. 6 and 7</cross-reference>.</paragraph>
</brief-description-of-drawings>
<detailed-description>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> By way of comparison with the present invention conventional OLAP systems are shown in <cross-reference target="DRAWINGS">FIGS. 4 and 5</cross-reference>. The earliest conventional system (Approach II) has no materialisation but uses the data retrieval mechanism which directly calls the aggregator to compute on the fly the necessary aggregation which is then returned as a result. The only storage is that required by the database (DB). </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> Approach I has full materialisation and the system pre-computes all possible aggregates in advance. These are stored as materialized views in an additional MV store for later querying and requires use of an indexing mechanism. Unfortunately the MV storage required is excessive, the process requires a great deal of data manipulation which takes a considerable time and consequently is limited to systems requiring only moderate updates. </paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> Approach III is a compromise between the first two in that the system selects in advance a sub-set of the possible aggregates and these are computed and stored as materialized views in an Mv store which is additional to the DB store. When a query has to be handled the system first checks whether the required result is already stored as a materialized view. Failing which, the aggregator is activated to compute the required result directly. This system results in a considerable saving in MV storage required for the materialized views but is achieved at the cost of a much higher variance in the time required to obtain a result. </paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> The system in accordance with the present invention is shown in block diagram form in <cross-reference target="DRAWINGS">FIGS. 6 and 7</cross-reference>. Like the conventional system (Approach III) employing stored materialised views, the system of <cross-reference target="DRAWINGS">FIGS. 6 and 7</cross-reference> also has a pre-processing stage. However, the operation of the system in the pre-processing stage is entirely different in that those aggregates which do not require to be computed are identified so that they can be retrieved from the input relation stored in the data base, whilst those aggregates which do require to be computed are computed and stored as materialised views, or if the aggregate is sufficiently similar to the parent relation the aggregate is stored in a difference format with a pointer to the parent relation. This is schematically shown in <cross-reference target="DRAWINGS">FIGS. 8A, 8B</cross-reference>, <highlight><bold>9</bold></highlight> and <highlight><bold>10</bold></highlight>. </paragraph>
<paragraph id="P-0068" lvl="0"><number>&lsqb;0068&rsqb;</number> As shown in <cross-reference target="DRAWINGS">FIG. 8A</cross-reference> a Group-by schema generator <highlight><bold>30</bold></highlight> issues schemas in sequence in an arity order which is essentially from minimum arity to maximum arity of aggregate for the possible aggregates of the input relation to an advance Materialised views selector <highlight><bold>31</bold></highlight> which operates to categorise the schemas into lists K and/or E failing which the schemas are directed to an aggregator <highlight><bold>32</bold></highlight> to compute aggregations. The K list initially stores any primary keys derived from the schema of the input relation and is subsequentially loaded with observational keys from the Group-by schemas identified by the categorisation process. The E list stores all Group-by schemas which contain a key previously stored in the K-list or which are found to be a key and from which the corresponding aggregate can be obtained without computation. </paragraph>
<paragraph id="P-0069" lvl="0"><number>&lsqb;0069&rsqb;</number> In the first pass the generator <highlight><bold>30</bold></highlight> for the required Group-by schemas issues these sequentially to a check unit <highlight><bold>33</bold></highlight> which examines the schema of the Group-by and checks its domains against the key list K to determine whether or not the schema contains a stored K-list key. At this point the K list contains all of the primary keys derived from the input relation augmented by any previous Group-by schema identified as being a key. Any Group-by schema which contains a key of the parent relation has a corresponding aggregate which can be represented by the parent relation itself and hence that aggregate does not require to be computed and stored, instead the schema is inserted directly into the E list. </paragraph>
<paragraph id="P-0070" lvl="0"><number>&lsqb;0070&rsqb;</number> Alternatively, if there is no match according to unit <highlight><bold>33</bold></highlight> the Group-by schema is subjected to a secondary check to identify if the schema is itself a key and which is based on size estimation in check unit <highlight><bold>34</bold></highlight>. On receipt of a schema unit <highlight><bold>34</bold></highlight> evaluates an upper bound size (ES) of the Group-by relation defined by that schema and then compares that evaluation with the size of the input relation. If the current upper bound size is not less than the input relation size then the individual tuples as defined by the current schema are sequentially compared by unit <highlight><bold>35</bold></highlight>, each succeeding tuple being compared with all its predecessors which are stored in unit <highlight><bold>35</bold></highlight> and provided a duplicate tuple is not detected (i.e., duplication is absent) the process continues until all the tuples have been compared. If at this stage no duplication has been detected the schema is recognised as being a key and is added to both the K and E lists provided that on a further check of these tuples the total size is found to be the same as that of ES. </paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> The E list, as a result, contains (pointers to) all aggregations which are equal in size to their parent and which hence neither require to be computed explicitly nor stored. The K list contains the primary keys derived from the schema of the input relation augmented by any Group-by schema identified as itself being a key. </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> Group-by schemas which are not entered into the E list are directed to the aggregator <highlight><bold>32</bold></highlight> for aggregation on a computational basis. Aggregator <highlight><bold>32</bold></highlight> may operate on the conventional basis. Alternatively aggregator <highlight><bold>32</bold></highlight> may operate on a modified basis to reduce the storage space required for computed aggregates, as shown in <cross-reference target="DRAWINGS">FIG. 8B</cross-reference>. </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> The aggregator <highlight><bold>32</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 8B</cross-reference> computes the aggregates and then categorises each aggregate according to size in comparison with the size of the parent relation. </paragraph>
<paragraph id="P-0074" lvl="0"><number>&lsqb;0074&rsqb;</number> If the size is less than that of the parent but within a specified threshold distance (t) of it the aggregator <highlight><bold>32</bold></highlight> stores this aggregate in a D-list difference format. This is made up of two parts, a small aggregate relation the tuples of which are each aggregates of more than one tuple of the parent, and a pointer to the parent relation. The appropriate entry specifying the relation and the small aggregate relation as well as the schema of the aggregate are inserted into the D list. </paragraph>
<paragraph id="P-0075" lvl="0"><number>&lsqb;0075&rsqb;</number> We define a relation R&prime; to be similar to the relation R if a number n&prime;<highlight><subscript>R </subscript></highlight>of equivalent tuples in R&prime; is within a threshold t<highlight><subscript>s </subscript></highlight>of the number of the corresponding tuples n<highlight><subscript>R </subscript></highlight>in R.  
<math-cwu id="MATH-US-00001">
<number>1</number>
<math>
<mrow>
  <mfrac>
    <msubsup>
      <mi>n</mi>
      <mi>R</mi>
      <mi>&prime;</mi>
    </msubsup>
    <msub>
      <mi>n</mi>
      <mi>R</mi>
    </msub>
  </mfrac>
  <mo>&lt;</mo>
  <msub>
    <mi>t</mi>
    <mi>s</mi>
  </msub>
  <mo>&lt;</mo>
  <mn>1</mn>
</mrow>
</math>
<mathematica-file id="MATHEMATICA-00001" file="US20030004959A1-20030102-M00001.NB"/>
<image id="EMI-M00001" wi="216.027" he="18.96615" file="US20030004959A1-20030102-M00001.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0076" lvl="0"><number>&lsqb;0076&rsqb;</number> The value of t<highlight><subscript>s </subscript></highlight>may be pre-determined or may be varied since its size influences the required storage volume and the retrieval time of an aggregate. </paragraph>
<paragraph id="P-0077" lvl="0"><number>&lsqb;0077&rsqb;</number> If the difference is larger than t then the aggregate, or at least a pointer to it, is entered into a C-list which contains pointers to all aggregates which have been conventionally computed and stored in a materialised views (MV) store. </paragraph>
<paragraph id="P-0078" lvl="0"><number>&lsqb;0078&rsqb;</number> With regard to the difference production procedure utilised in <cross-reference target="DRAWINGS">FIG. 8B</cross-reference> consider by way of example the relation R (p,s,t) shown in <cross-reference target="DRAWINGS">FIG. 9</cross-reference> aggregated to the relation Rc (p,s). As can be seen two (R&prime;<highlight><subscript>t</subscript></highlight>) tuples (P<highlight><bold>2</bold></highlight>, S<highlight><bold>2</bold></highlight>, <highlight><bold>70</bold></highlight>) and (P<highlight><bold>2</bold></highlight>, S<highlight><bold>2</bold></highlight>, <highlight><bold>20</bold></highlight>) are equivalent to the corresponding tuples (R<highlight><subscript>t</subscript></highlight>) in R (P<highlight><bold>2</bold></highlight>, S<highlight><bold>2</bold></highlight>, T<highlight><bold>1</bold></highlight>, <highlight><bold>70</bold></highlight>) and (P<highlight><bold>2</bold></highlight>, S<highlight><bold>2</bold></highlight>, T<highlight><bold>2</bold></highlight>, <highlight><bold>20</bold></highlight>) respectively. The remaining tuple (R<highlight><subscript>d</subscript></highlight>) is different being an aggregate of three tuples (R<highlight><subscript>a</subscript></highlight>) in R. The two relations R and Rc are represented indirectly by storing only the parent relation R and Rd where Rd consists of the tuples of Rc which are not equivalent to any in the parent relation R. </paragraph>
<paragraph id="P-0079" lvl="0"><number>&lsqb;0079&rsqb;</number> The algorithm required for this process requires the following operations:</paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>R&prime;</italic></highlight><highlight><subscript>t</subscript></highlight><highlight><italic>&equals;R</italic></highlight><highlight><subscript>c</subscript></highlight><highlight><italic>&agr;R</italic></highlight></in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>R</italic></highlight><highlight><subscript>d</subscript></highlight><highlight><italic>&equals;R</italic></highlight><highlight><subscript>c</subscript></highlight><highlight><italic>&minus;R&prime;</italic></highlight><highlight><subscript>t</subscript></highlight></in-line-formula></paragraph>
<paragraph id="P-0080" lvl="7"><number>&lsqb;0080&rsqb;</number> where: </paragraph>
<paragraph id="P-0081" lvl="2"><number>&lsqb;0081&rsqb;</number> (&agr;) is the semi-join relational operation, and </paragraph>
<paragraph id="P-0082" lvl="2"><number>&lsqb;0082&rsqb;</number> (&minus;) is the difference operator. </paragraph>
<paragraph id="P-0083" lvl="0"><number>&lsqb;0083&rsqb;</number> When a query is received the system of <cross-reference target="DRAWINGS">FIG. 7</cross-reference> may require to obtain those aggregates which are stored in the D-list format of <cross-reference target="DRAWINGS">FIG. 8</cross-reference>B and this is achieved as shown in <cross-reference target="DRAWINGS">FIG. 10</cross-reference> using the stored relation R<highlight><subscript>d </subscript></highlight>in the following operations;</paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>R&prime;</italic></highlight><highlight><subscript>t</subscript></highlight>&equals;&pgr;<highlight><subscript>pls</subscript></highlight>{overscore ((<highlight><italic>R&agr;R</italic></highlight><highlight><subscript>d</subscript></highlight>))}</in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>R</italic></highlight><highlight><subscript>c</subscript></highlight><highlight><italic>&equals;R</italic></highlight><highlight><subscript>d</subscript></highlight><highlight><italic>&cup;R&prime;</italic></highlight><highlight><subscript>t</subscript></highlight></in-line-formula></paragraph>
<paragraph id="P-0084" lvl="7"><number>&lsqb;0084&rsqb;</number> where {overscore ((R &agr; R<highlight><subscript>d</subscript></highlight>))} is the anti-semijoin operation and (&cup;) is the union operator. </paragraph>
<paragraph id="P-0085" lvl="0"><number>&lsqb;0085&rsqb;</number> As will be readily understood by an expert in the field, the implementation of this algorithm can be rendered faster if an explicit representation (such as a bit list) of the set of tuples being selected from the parent relation (readily computed during the aggregation pre-processing phase) is stored in association with the two component part relations. </paragraph>
<paragraph id="P-0086" lvl="0"><number>&lsqb;0086&rsqb;</number> Otherwise the <cross-reference target="DRAWINGS">FIG. 7</cross-reference> system obtains the required aggregate by using the content of the C-list as a pointer to the previously computed and stored aggregate or alternatively via the E-list which stores the schemas of those aggregates which do not require computation but which are to be found from the input relation which is already stored in the original database.  
<table-cwu id="TABLE-US-00004">
<number>4</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center">TABLE I</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>SALES</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="5">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="28PT" align="center"/>
<colspec colname="2" colwidth="56PT" align="center"/>
<colspec colname="3" colwidth="28PT" align="left"/>
<colspec colname="4" colwidth="84PT" align="center"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Product</entry>
<entry>Store</entry>
<entry>Time</entry>
<entry>Total Sales</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="4" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="5">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="28PT" align="center"/>
<colspec colname="2" colwidth="56PT" align="center"/>
<colspec colname="3" colwidth="28PT" align="left"/>
<colspec colname="4" colwidth="84PT" align="char" char="."/>
<tbody valign="top">
<row>
<entry></entry>
<entry>P1</entry>
<entry>S1</entry>
<entry>Jan</entry>
<entry>50</entry>
</row>
<row>
<entry></entry>
<entry>P1</entry>
<entry>S1</entry>
<entry>Feb</entry>
<entry>34</entry>
</row>
<row>
<entry></entry>
<entry>P1</entry>
<entry>S2</entry>
<entry>March</entry>
<entry>22</entry>
</row>
<row>
<entry></entry>
<entry>P2</entry>
<entry>S3</entry>
<entry>Jan</entry>
<entry>8</entry>
</row>
<row>
<entry></entry>
<entry>P2</entry>
<entry>S3</entry>
<entry>Jan</entry>
<entry>96</entry>
</row>
<row>
<entry></entry>
<entry>P2</entry>
<entry>S1</entry>
<entry>Jan</entry>
<entry>56</entry>
</row>
<row>
<entry></entry>
<entry>P2</entry>
<entry>S1</entry>
<entry>Apr</entry>
<entry>45</entry>
</row>
<row>
<entry></entry>
<entry>P3</entry>
<entry>S2</entry>
<entry>Feb</entry>
<entry>98</entry>
</row>
<row>
<entry></entry>
<entry>P3</entry>
<entry>S2</entry>
<entry>Jan</entry>
<entry>33</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="4" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0087" lvl="0"><number>&lsqb;0087&rsqb;</number>  
<table-cwu id="TABLE-US-00005">
<number>5</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="84PT" align="center"/>
<colspec colname="2" colwidth="28PT" align="left"/>
<colspec colname="3" colwidth="105PT" align="center"/>
<thead>
<row>
<entry namest="1" nameend="3" align="center">TABLE II</entry>
</row>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Store</entry>
<entry>Time</entry>
<entry>Total Sales</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="84PT" align="center"/>
<colspec colname="2" colwidth="28PT" align="left"/>
<colspec colname="3" colwidth="105PT" align="char" char="."/>
<tbody valign="top">
<row>
<entry>S1</entry>
<entry>Jan</entry>
<entry>106</entry>
</row>
<row>
<entry>S1</entry>
<entry>Feb</entry>
<entry>34</entry>
</row>
<row>
<entry>S2</entry>
<entry>March</entry>
<entry>22</entry>
</row>
<row>
<entry>S3</entry>
<entry>Jan</entry>
<entry>104</entry>
</row>
<row>
<entry>S1</entry>
<entry>Apr</entry>
<entry>45</entry>
</row>
<row>
<entry>S2</entry>
<entry>Feb</entry>
<entry>98</entry>
</row>
<row>
<entry>S2</entry>
<entry>Jan</entry>
<entry>33</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A database processor and system architecture capable of operating as an On-line Analytical Processing (OLAP) system for the implementation of multidimensional aggregates of an input relation, and which is arranged to obtain such multidimensional aggregates after a pre-processing stage which identifies aggregates which can be obtained without computation, said pre-processing stage being arranged to: 
<claim-text>i) identify and store the primary keys derived from the schema of the input relation; </claim-text>
<claim-text>ii) establish a Group-by schema generator to generate schemas from minimum arity to maximum arity of aggregate for the possible aggregates of the input relation; </claim-text>
<claim-text>iii) sequentially in an arity order beginning with single columns and proceeding in an order in which each lower level of every sub-tree is visited before any root (i.e., breadth-wise from the lowest level to the highest node of the lattice) comparing the generated schemas with the primary keys stored in step (i) augmented by any previous schema identified as being a key and in the event of a generated schema containing a stored key treating the input relation as the virtual representation of the corresponding Group-by aggregate without computation. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. A database processor as claimed in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the arity order is the sequence minimum arity to maximum arity. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. A database processor as claimed in either preceding claim, where in sequence, each schema which is not found to contain a stored key according to step (iii) is subjected to a secondary check step, wherein an upper bound size of the Group-by relation defined by the current such schema is evaluated and the size of the input relation is compared against that upper bound size and in the event of the upper bound size not being less than the size of the input relation sequentially comparing the tuples of the current schema, and in the absence of tuple-duplication recognising that the current schema is a key and treating the input relation as the virtual representation of the corresponding Group-by aggregate without computation. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. A database processor as claimed in <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference>, wherein the upper bound size of the Group-by relation defined by the current schema is evaluated according to a pre-determined algorithm. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. A database processor as claimed in any preceding claim, wherein those generated Group-by schemas which are recognised as being or as containing a key are effectively stored to permit subsequent retrieval of the corresponding Group-by aggregate without computation. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. A database processor as claimed in <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference>, wherein the store contains pointers to those generated Group-by schemas which are recognised as being or as containing a key, such pointers in effect representing the schema. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. A database processor as claimed in any preceding claim, wherein those Group-by schemas which require computational aggregation are computationally aggregated and each aggregate is assessed to identify whether or not it is similar to the parent relation by having almost the same cardinality (i.e., number of tuples) as the input relation, in which case to reduce storage space only those tuples that differ from the input relation need to be represented, whereby the aggregate can be obtained from this representation of the difference and from the input relation. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. An on-line transaction processing system comprising a database processor and system architecture as claimed in any preceding claim. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. An on-line transaction processing system, wherein those Group-by schemas which require computational aggregation are computationally aggregated and each aggregate is assessed to identify whether or not it is similar to the parent relation by having almost the same cardinality (i.e., number of tuples) as the input relation, in which case to reduce storage space only those tuples that differ from the input relation need to be represented, whereby the aggregate can be obtained from this representation of the difference and from the input relation.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>6</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030004959A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030004959A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030004959A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030004959A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030004959A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030004959A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030004959A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030004959A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
