<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030004950A1-20030102-D00000.TIF SYSTEM "US20030004950A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030004950A1-20030102-D00001.TIF SYSTEM "US20030004950A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030004950A1-20030102-D00002.TIF SYSTEM "US20030004950A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030004950A1-20030102-D00003.TIF SYSTEM "US20030004950A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030004950A1-20030102-D00004.TIF SYSTEM "US20030004950A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030004950A1-20030102-D00005.TIF SYSTEM "US20030004950A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030004950A1-20030102-D00006.TIF SYSTEM "US20030004950A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030004950A1-20030102-D00007.TIF SYSTEM "US20030004950A1-20030102-D00007.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030004950</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10124630</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20020417</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F007/00</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>707</class>
<subclass>010000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Integrated procedure for partitioning network data services among multiple subscribers</title-of-invention>
</technical-information>
<continuity-data>
<non-provisional-of-provisional>
<document-id>
<doc-number>60284439</doc-number>
<document-date>20010418</document-date>
<country-code>US</country-code>
</document-id>
</non-provisional-of-provisional>
</continuity-data>
<inventors>
<first-named-inventor>
<name>
<given-name>Joris</given-name>
<middle-name>J.</middle-name>
<family-name>Wils</family-name>
</name>
<residence>
<residence-us>
<city>Acton</city>
<state>MA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Beth</given-name>
<middle-name>K.</middle-name>
<family-name>Miaoulis</family-name>
</name>
<residence>
<residence-us>
<city>Stow</city>
<state>MA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Jack</given-name>
<middle-name>J.</middle-name>
<family-name>Stiffler</family-name>
</name>
<residence>
<residence-us>
<city>Marion</city>
<state>MA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<assignee>
<organization-name>Cereva Network, Inc.</organization-name>
<assignee-type>02</assignee-type>
</assignee>
<correspondence-address>
<name-1>KUDIRKA &amp; JOBSE, LLP</name-1>
<name-2></name-2>
<address>
<address-1>ONE STATE STREET</address-1>
<address-2>SUITE 1510</address-2>
<city>BOSTON</city>
<state>MA</state>
<postalcode>02109</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A method and apparatus for partitioning network data services among multiple subscribers uses information stored in several tables to define a plurality of independent networks where each independent network comprises a set of access ports and a unique set of destination addresses and is logically separate from all other independent networks so that no information can pass from one independent network to another independent network. When a subscriber makes a request to use an independent network, a subscriber key that is based on the subscriber identity and the network access port is used to determine whether the subscriber has permission to use the independent network. If the subscriber has permission to use the independent network, information retrieved from the tables is used to determine whether the source subscriber or a destination subscriber has control over the resource. If a destination subscriber has control over the resource, using information in the request to identify a destination subscriber and a response port; and if the source subscriber has control over the resource, using the identity to determine whether the source subscriber can access the resource. </paragraph>
</subdoc-abstract>
<subdoc-description>
<cross-reference-to-related-applications>
<heading lvl="1">RELATED APPLICATIONS </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> This application is related to, and claims priority of, U.S. provisional patent application serial No. 60/284,439, filed on Apr. 18, 2001 by Joris J. Wills, Beth K. Miaoulis and Jack J. Stiffler.</paragraph>
</cross-reference-to-related-applications>
<summary-of-invention>
<section>
<heading lvl="1">FIELD OF THE INVENTION </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> This invention relates to the provision of data services, including data storage services, from a centralized data center over a network to a plurality of data service subscribers, and the mechanisms for insuring that the provided services meet predefined security and quality of service goals. </paragraph>
</section>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> Data service centers provide subscribers access to a variety of data services using a variety of protocols. In many cases, these services involve access to a centralized database that may be comprised of multiple storage resources. The database to which the subscribers seek access generally stores both static and dynamic content including text and graphic files, video and animation files, digital music, digital libraries, stock market and individual portfolio reports, financial statements and many other types of information. The protocols used to access the stored information include Hypertext Transfer Protocol (HTTP), File Transfer Protocol (FTP), Transmission Control Protocol (TCP), User Datagram Protocol (UDP), Network File System (NFS), Web-based NFS (WebNFS), Small Computer System Interface (SCSI) and Common Internet File System (CIFS) protocols. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> A typical data service center must usually make its services simultaneously available to large numbers of subscribers using various combinations of these protocols. Further, for each subscriber, the center must provide security services that prevent other subscribers from getting unauthorized access to the subscribers&apos; data. The data center must further provide accounting services in order to bill subscribers for the services provided and to allow traffic profiling. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> All of these services must be provided in accordance with predefined quality of service commitments as contracted with the subscribers. Further, the services must be performed in a differentiated manner, with each subscriber receiving the type of service to which it has subscribed. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> Prior-art data service systems have used separate procedures for handling each of these various requirements individually. Prior-art data services systems have only very limited support for a plurality of subscribers. They do not provide for separate quality of service and accounting metrics. They provide only weak separation of access. Thus, in practice, data center administrators would have to construct a physically separate data service system for each subscriber, which would lead to significant increased capital expense, maintenance and administrative cost. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> In accordance with the principles of the invention a method and apparatus for partitioning network data services among multiple subscribers uses information stored in several tables to define a plurality of independent networks where each independent network comprises a set of access ports and a unique set of destination addresses and is logically separate from all other independent networks so that no information can pass from one independent network to another independent network. When a subscriber makes a request to use an independent network a subscriber key which is based on the subscriber identity and the network access port is used to access information in the tables to determine whether the subscriber has permission to use the independent network. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> If the subscriber has permission to use the independent network, information retrieved from the tables is used to determine whether the source subscriber or a destination subscriber has control over the resource. If a destination subscriber has control over the resource, using information in the request to identify a destination subscriber and a response port; and if the source subscriber has control over the resource, using the identity to determine whether the source subscriber can access the resource. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> In accordance with another embodiment of the invention, an integrated procedure enables a data service system to provide two levels of security to ensure that unauthorized users do not get access to the system or to its protected resources. The first level of security is provided at the network interface into the system where users attempting to access the system are checked against a database of eligible users and admitted only if they have been entered into that database. A second security barrier is provided at the resource level where a second database is used to specify the system resources to which each user has access. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> Quality of service commitments are addressed by parceling out system capacity based on a subscriber&apos;s service agreement, ensuring that no subscriber gets more than its share of that capacity at the expense of any other subscriber that might otherwise receive less than its fair share. In addition, each subscriber is allowed to specify how its capacity is to be allocated among its various sessions and the quality of service procedure guarantees fairness among a subscriber&apos;s sessions in accordance with those specifications. Finally, system resources are monitored and the results of this monitoring are used to prevent requests that cannot currently be serviced due to insufficient system resources from blocking service to those requests that can be serviced. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> Other embodiments of the present invention also provide accounting features that enable each subscriber to the data service to monitor its system usage, both overall and broken down into its individual sessions.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> The above and further advantages of the invention may be better understood by referring to the following description in conjunction with the accompanying drawings in which: </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a depiction of the various data structures used to implement the security, quality of service and accounting features of the invention and an illustration of the interrelation among those structures. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a flowchart showing the response to a request for service in accordance with the principles of the invention and, in particular, the procedure by which the legitimacy of an access request is determined. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a flowchart depicting the procedure used to determine if a user requesting access to a specific system resource in fact has permission to access that resource. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a flowchart showing the procedure for placing a request that has been determined to be legitimate on the appropriate list of requests awaiting service. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a flowchart illustrating the procedure for cycling through the set of active subscribers and determining the subscriber that is next eligible for service. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is a flowchart showing the procedure for cycling through a subscriber&apos;s active sessions, identifying those sessions eligible for service and delivering those sessions&apos; requests to the appropriate application. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> is a flowchart showing the activities undertaken when a request has been serviced by an application. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> is a flowchart illustrating the accounting procedure whereby data reflecting subscribers&apos; and sessions&apos; system usage is collected and updated.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION </heading>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> For purposes of this description, the term &ldquo;data service system&rdquo; or simply &ldquo;system&rdquo; denotes the hardware and software used to implement the desired data center services and the term &ldquo;subscriber&rdquo; refers to a client given access to some subset of the available services and associated data. A subscriber typically consists of a number of users and host computers. Each subscriber is identified by a set of attributes, called the subscriber key, which uniquely distinguishes it from all other subscribers. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> A subscriber is called a &ldquo;registered subscriber&rdquo; once the data system administrator has entered one or more &ldquo;subscriber keys&rdquo; into the appropriate database. Each subscriber key identifies computer systems, which are associated with the subscriber, by attributes in the input requests (such as source address information) and/or the system ports through which the subscriber has access into the data services system. The system administrator also enters the system resources that the subscriber can access. The registered subscriber can then manage its own resources within this larger context. For example, a subscriber may configure two or more &ldquo;virtual subscribers&rdquo; and the data center system administrator can then assign to each virtual subscriber its own set of one or more IP addresses, associated volume or file system, set of applications, and access rights. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> Another important concept is a &ldquo;session&rdquo;. A session is defined either inherently by the protocol used by the subscriber to communicate with the system or else by a subscriber-resource pair, that is, by a transaction initiated by a subscriber to get access to a particular system resource (for example, file system or logical volume). A session is opened on the first request for service received, and remains active so long as requests continue to be received, under that session. When no such requests are pending, the session is called inactive. An inactive session can be quickly reactivated if new requests are received under that session. Inactive sessions that have not received any requests for some predetermined time period may be closed to conserve system resources. Sessions can also be closed through a variety of means, depending on the communication protocol being used, including excessive idle time, log outs, administrative requests and other mechanisms. A subscriber is called &ldquo;active&rdquo; so long as any of its associated sessions are active; otherwise, it is called &ldquo;inactive.&rdquo;</paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> One embodiment of a data service system constructed in accordance with the principles of the invention comprises a set of integrated procedures for enabling a data service system efficiently to provide security, quality of service and accounting features. These procedures operate with a set of interrelated data structures for tracking subscribers and sessions and for determining their access privileges and the level of service to which they are entitled. The information in these structures is supplied either by the data center system administrator, by individual subscribers or computed by the data services system. In one embodiment, in order to simplify this process, this information is represented by Management Information Base (MIB) tables in compliance with the Internet Society RFC 1155 standard. Since the tables are in a standard format, their contents can be accessed and manipulated using the widely accepted Simple Network Management Protocol (SNMP). </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> Data structures used in one embodiment of the present invention are shown schematically in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. Those structures that are organized as MIB tables are indicated by hatched title bars and are referred to as &ldquo;tables&rdquo; rather than the more generic term &ldquo;databases&rdquo;. Base table <highlight><bold>102</bold></highlight> contains one entry for each subscriber and this entry includes the subscriber&apos;s name, contact information and optional additional descriptive information. The information for this entry is entered by the data system administrator. The entry is indexed by a unique number, called a &ldquo;subscriber handle&rdquo;, that is assigned to each subscriber when the subscriber is registered. The mapping from the subscriber&apos;s name to the subscriber handle is also listed in inverse table <highlight><bold>100</bold></highlight> to so that subsequent references to the subscriber&apos;s name can be easily converted to the appropriate handle. The inverse table is constructed internally without administrator intervention. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> In this embodiment, when a subscriber attempts to access the system, it is identified by an entity, unique to that subscriber, called a &ldquo;subscriber key&rdquo;. The subscriber key is composed of subscriber-specific attributes gleaned from the input request, the nature of which depends on the communication infrastructure. For storage-area networks using Fibre Channel, for example, the relevant attributes include the system port address, the Fibre Channel domain and area identifiers and the arbitrated loop port address (AL_PA). For Internet accesses, the subscriber key is constructed by the computer system from some subset of the following: the identity of the system port through which the request was received, the tag identifying the virtual local area net (VLAN) over which the input request was communicated, the source Internet Protocol (IP) address, the destination IP address and the source TCP or UDP port addresses. A subscriber can designate some of these parameters as &ldquo;don&apos;t care&rdquo;, thereby enabling the subscriber to be represented by a range of addresses. Other parameters are used with other protocols and communication topologies. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> The subscriber key, in addition to identifying the subscriber, can be used to prevent unauthorized access to resources assigned to the subscriber. Accordingly, the specific subset of attributes used to define the subscriber key depends, in part, on what is under physical control of the data center. If, for example, the data center controls the physical access to the VLAN, the system port address does not need to be included in the key used for Internet access since the VLAN-to-system port connections are secure. If the data center places source IP address-filtering router ports between the subscribers and the VLAN, then these addresses provide a means of secure subscriber identification. Similarly, if the data center includes equipment that independently identifies subscribers and assigns them a known set of TCP or UDP port addresses, then these addresses provide still another means for reliably identifying a subscriber. Nevertheless, source and network addresses that are not under control of the data center, such as Media Access Control (MAC) addresses and World Wide Names, may also be used to identify the subscriber. While these addresses can be counterfeited relatively easily, they still offer a level of protection against accidental intrusion. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> For each entry in the base table <highlight><bold>102</bold></highlight>, there is a corresponding entry, also indexed by the subscriber handle, in three other tables and databases: the subscriber accounting table <highlight><bold>118</bold></highlight>, the subscriber traffic agreement table <highlight><bold>112</bold></highlight> and the subscriber monitoring database <highlight><bold>122</bold></highlight>. The first of these tables, the subscriber accounting table <highlight><bold>118</bold></highlight>, is used to record the amount of service provided to each subscriber and is periodically updated by the data center computer system with statistics reflecting each subscriber&apos;s system usage over the most recent accounting period. Typically included in this table are the number of operations performed by the subscriber and the amount of data received and transmitted during the current accounting period. Each subscriber can read its corresponding entry in the subscriber accounting table, thus allowing it to monitor its own level of activity. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> The next two of these tables and databases, in combination, are used to guarantee each subscriber the quality of service to which it is entitled. The subscriber traffic agreement table <highlight><bold>112</bold></highlight> itemizes the level of service contracted for by the subscriber and includes the fraction of the system&apos;s capacity allocated to each subscriber in accordance with its service contract. Information can be entered into this table by both subscribers and data center personnel and enables subscribers to specify how these resources are to be allocated over different classes of sessions. Since the table can be accessed by a subscriber, the subscriber can specify its desired level of service and be billed accordingly. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> The subscriber monitoring database <highlight><bold>122</bold></highlight> is used by the data center computer system to keep track of the on-going activity associated with each active subscriber. Each entry contains a counter recording the number of requests pending for that subscriber, a quality of service metric related to the fraction of the subscriber&apos;s allocated capacity that has been used, and pointers to other data structures indicating the order in which its sessions are to be serviced. These data structures, in turn, are based on quality of service metrics reflecting the fraction of the capacity allocated to each of the subscriber&apos;s sessions that has been consumed by that session. On simple example of a quality of service metric associated with a session is the ratio C<highlight><subscript>u</subscript></highlight>(i)/f(i)C<highlight><subscript>s</subscript></highlight>, with C<highlight><subscript>u</subscript></highlight>(i) the capacity thus far consumed by the subscriber&apos;s i<highlight><superscript>th </superscript></highlight>session and f(i) the fraction of the subscriber&apos;s allocated capacity C<highlight><subscript>s </subscript></highlight>assigned to that session. The quantity C<highlight><subscript>u</subscript></highlight>(i) is typically periodically renormalized to reflect the capacity used over the most recent time interval, in which case C<highlight><subscript>s </subscript></highlight>represents the capacity allocated per time interval. This information is used to ensure that each subscriber gets the quality of service that was contracted for, that that quality of service is allocated across its sessions in accordance with the subscriber&apos;s specifications, and, in particular, that no subscriber or session suffers inferior service due to excessive demand on the part of another subscriber or session. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> Another data structure, the session database <highlight><bold>120</bold></highlight>, is maintained by the data center system and used to expedite the processing of a request associated with an open session. Here a &ldquo;session handle&rdquo; is used as an index to an entry in the database that contains pointers to the lists of requests pending under that session and, if appropriate, to the relevant entry in the subscriber file system mapping database <highlight><bold>106</bold></highlight> (see below). In addition, each entry contains a metric related to the fraction of throughput allocated to the session that has been used at any given time. Each session is uniquely identified by its associated session handle constructed from the concatenation of the subscriber handle and a session key constructed from other fields extracted from the communication protocol header. In an Ethernet environment, for example, the session key is extracted from a subset of the protocol identifier, IP source and destination address and transport-layer source and destination port address fields. In a Fibre Channel networked environment, the node identification (N_ID) and the target logical unit number (LUN) are typically used. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> In another embodiment, a subscriber has the capability to assign its sessions, distinguished by their session keys, to different priority classes and to assign different fractions of its total allocated system throughput to sessions in each class by manipulating information in the subscriber traffic agreement table. For example, the system administrator might assign all sessions having a specified destination IP address to a high priority class, thereby giving those sessions a larger fraction of the available throughput than they would otherwise have. To accommodate this option, the priority class of each session is extracted from the subscriber traffic agreement table <highlight><bold>112</bold></highlight> when the session is created and appended to metric associated with the session in the session database <highlight><bold>120</bold></highlight>. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> In still another embodiment, a concept called &ldquo;session groups&rdquo; is introduced. Session groups are used to prevent system performance from degrading because of excess demand for some subset of the system resources when other sessions that do not require that subset are eligible for service. In conventional systems, if the queue of requests for a specific resource (for example, a physical disk or communication port) reaches some prescribed limit, all subsequent requests are blocked until some of those requests have been serviced even though other system resources may not be fully utilized. In accordance with the principles of the present invention, in this embodiment, when a session is created by the data center system, it is assigned to a session group defined by the subset of the system resources that it uses (system port, storage volume, etc.). The group to which a session belongs is appended to its entry in the session database <highlight><bold>120</bold></highlight>. Before any session is serviced, its session-group activity level is checked to determine if the session-group has reached capacity. If it has, the session is temporarily bypassed and another session made eligible for service. This prevents one session from being blocked by another session waiting for resources that the one session does not in fact need to become available. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> In another embodiment, a quality of service metric and its implementation, depend on the operating environment, the acceptable computational complexity and the quality of service objectives. The metric itself is usually related to the fraction of the currently available throughput capacity that is allocated to the subscriber or session in question, but, alternatively, could involve the average latency experienced by a request or some combination of these and other measures. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> For example, a throughput metric can be combined with an ordered-list structure to order sessions based on their associated metrics. With this structure, up to N active-session lists and one inactive list are defined for each subscriber and the number of sessions on, and a pointer to, each list are maintained in the subscriber monitoring database <highlight><bold>122</bold></highlight>. The list headers represent the first time any session on that list, represented by its session handle, is entitled to service. For example, list 0 to contains the handles of all sessions currently eligible for service and list k contains the handles of those sessions that are next eligible to be serviced at time T<highlight><subscript>k</subscript></highlight>&equals;T<highlight><subscript>1</subscript></highlight>&plus;(k&minus;1 )&Dgr;t with &Dgr;t a predetermined time interval. An example of a throughput metric could be the number of bytes to write or read. Another could be the number of 32 KB blocks to write or read. Another could be the number of basic file system operations needed to service the request. The former two examples could be applied to ordinary data reads and writes. The latter applies well to directory reads, which typically are very operation intensive, but generate few bytes. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> When an eligible session is selected for service, its pending requests are serviced in turn either until its associated group, subscriber or session limit has been reached, or until it has no requests left that have not been serviced. The session limit is reached when the throughput consumed by all requests serviced during its current service interval is estimated to exceed s-seconds worth of its allocated capacity for some prescribed value s. When this limit is reached, the session&apos;s handle is appended to list i, with i the largest integer for which T<highlight><subscript>i</subscript></highlight>&lt;t&plus;s and with t the current time, and the next eligible session is selected. If all the session&apos;s requests are serviced before it reaches this limit, its handle is placed on the inactive list along with the header of the list to which it would have been appended were it still active. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> When a request is submitted to an application, the application responds with an estimate of the capacity that will be required to satisfy that request. The associated subscriber&apos;s metric is updated to reflect that estimate. If, following that update, the current subscriber still has unused capacity and if it still has requests that need service, then its next eligible request is serviced. Otherwise, the next eligible subscriber is selected. All of the new subscriber&apos;s sessions on any list j for which T<highlight><subscript>j </subscript></highlight>is less than or equal to the current time t are now eligible to run and all such lists are accordingly appended to list 0. If all of these lists, including list 0, are empty, the first non-empty list, say, list k, becomes the new list 0 even if T<highlight><subscript>k</subscript></highlight>&gt;t. If list i is the first list not linked to list 0, its header becomes the new T<highlight><subscript>1</subscript></highlight>, the old header T<highlight><subscript>i&plus;1 </subscript></highlight>becomes the new T<highlight><subscript>2</subscript></highlight>, etc. and new, temporarily empty lists are created with the headers T<highlight><subscript>j</subscript></highlight>&equals;T<highlight><subscript>1</subscript></highlight>&plus;j&Dgr;t for N&minus;i&lt;j&lt;N&minus;1. The sessions are then serviced beginning with the first session on list 0. If all sessions on list 0 are serviced before the subscriber reaches its allocated capacity and the subscriber still has at least one active session, one or more non-empty lists are again linked to list 0 and the remaining list headers modified as before. If the subscriber has no active sessions, it is labeled inactive. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> The allocation of the subscriber&apos;s capacity among its active sessions is effectively adjusted each time the subscriber becomes eligible for service in an attempt to keep the number of sessions on list 0 roughly equal to the number of sessions that can be serviced before the subscriber reaches its capacity. If, at the time that a subscriber becomes eligible for service, list k is the first non-empty list with T<highlight><subscript>k </subscript></highlight>greater than the current time t, the allocation to each session is proportionately increased. If, instead, the number of items on list 0 exceeds some prescribed number M, the allocation for each session is proportionately decreased. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> Similarly, the allocation of the system&apos;s capacity among the active subscribers is periodically adjusted to reflect the total capacity currently available. A background task monitors the system parameters pertaining to each session group such as, for example, the lengths of the various system queues. This data is then dynamically updated each time a request is submitted for service, thereby keeping a current estimate of the capacity available to each session group. If these parameters indicate that a session group is approaching maximum capacity, the effective allocation to that group is proportionally reduced; if they indicate that a session group is underutilized, its effective allocation is proportionally increased. Session group allocations are distributed among the active subscribers in accordance with their contracted levels of service. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> The sum of the available capacities of the session groups is used to define the available system capacity. Active subscribers are serviced in a round-robin manner. Each subscriber is allocated a portion of its share of the available system capacity each time it is made eligible for service and, if the current subscriber reaches the temporary limit imposed by this system-level allocation, the request service routine moves to the next subscriber on the active list. The portion of the system&apos;s capacity made available to a subscriber during any given service interval is generally less than 100% of its full share of that capacity. The function of the system capacity parameter, therefore, is to limit the likelihood that any one subscriber can exhaust the capacity available to any given session group before other subscribers have had a chance to submit requests requiring resources belonging to that same session group. The portion of the system capacity that is allocated on any one round involves a tradeoff between performance and fairness. If too little capacity is made available, each subscriber is able to submit only a small number of requests before the request service routine moves to the next subscriber resulting in computational inefficiencies. If too much capacity is made available, early subscribers may effectively prevent later subscribers from getting their fair share of some of the system&apos;s resources. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> The various allocations are, of course, also increased or reduced, as appropriate, when the number of active subscribers or sessions changes due to active subscribers or sessions becoming inactive or vice versa. The result of all this is that the fraction of the system&apos;s capacity allocated to a subscriber is a function of the number of subscribers and the contracted level of service for each subscriber. Similarly, the fraction of a subscriber&apos;s share of the system&apos;s capacity allocated to any one of its sessions is a function of the relative priority assigned to the session, the relative fraction of the total system capacity that is available to the session&apos;s group, and the number of the subscriber&apos;s other sessions belonging to that group. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> Another embodiment of the present invention provides subscribers with two levels of security. (A third level is typically provided by the subscriber-specific application itself.) The first of these levels, the network security level, ensures that only registered subscribers are able to gain access to the system through the network ports for which they have contracted or, in cases where this level of screening is not appropriate, that only those destinations specified by the subscriber are allowed to receive information through those ports. The second security level, the resource security level, ensures that each subscriber&apos;s resources can be accessed only in the manner specified for each member of the subscriber&apos;s group. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> In this embodiment, the first level of security (network security) is provided by the concept of an &ldquo;independent network.&rdquo; An independent network is a network configuration that is logically separate from all other independent networks in the system, thereby allowing the configuration and routing rules to be independently defined for each such network. Each independent network is isolated from all other networks for security purposes; no packets of information can pass from one such network to another through the system. Moreover, an independent network can be directly connected to an external network, such as the Internet or a subscriber&apos;s own private network, and can be made consistent with the attached network&apos;s configuration requirements. This level of security assumes that the physical components, which provide the independent network, are under total control of a network administrator trusted by the data center administrator. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> The independent network structure enables the system to provide network-level security by associating each independent network with a unique set of destination IP addresses. No access is allowed over an independent network to any destination address other than those that have been assigned to it. These access rules are enforced using three different MIB tables: the independent network details table <highlight><bold>114</bold></highlight>, the application address table <highlight><bold>110</bold></highlight> and the subscriber network identification table <highlight><bold>116</bold></highlight>. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> The independent network details table <highlight><bold>114</bold></highlight> contains an entry for each independent network identifying the characteristics of that network. It is indexed by a &ldquo;network key&rdquo; consisting of a subset of those parameters used to identify the subscriber (the previously defined subscriber key). For Ethernet access, for example, the VLAN tag or the physical connection, or both, can be used for this purpose. For an ATM connection, the network is identified by the set of virtual circuits comprising that connection. For Fibre Channel, the network is defined by the system port to which it is physically connected. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> The information listed in table <highlight><bold>114</bold></highlight> for each independent network includes the attributes of that network (system ports used by that network, protocols supported, etc.), the network handle assigned by the system and used elsewhere to identify the independent network and two flags. The first of these flags, when set, indicates that the source subscriber (the subscriber initiating the access) and destination subscriber (the subscriber controlling the resources being accessed) are identical and, hence, that no other access permissions are required. In this case, the subscriber handle is also part of the entry for that independent network so no additional table lookups are needed to identify it. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> The second flag indicates that the controlling subscriber is the destination subscriber, as is true, for example, for normal Internet accesses. In this case, the application address table <highlight><bold>110</bold></highlight> must be consulted to determine the controlling subscriber handle, access permissions and the system port to be used in responding to this access. The relevant entry into table <highlight><bold>110</bold></highlight> is indexed by another key called the &ldquo;application key.&rdquo; The application key consists of the network handle, extracted from table <highlight><bold>114</bold></highlight>, combined with other information received along with the request. The specific information used is again dependent on the communication protocol in effect, but typically includes the destination IP address and the UDP or TCP port number being used. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> If neither flag is set, the relevant subscriber is the source subscriber and the subscriber handle and the associated access permissions must be extracted from the subscriber network identification table <highlight><bold>116</bold></highlight>. The previously defined subscriber key is used as the index into this table. Table <highlight><bold>116</bold></highlight> has an entry containing a permissions field for each valid key. If the subscriber key is listed, indicating that the subscriber in question is registered for access through the specified system port using the specified network address, and permission is given for the type of access requested, access is allowed. Otherwise, the attempted access is rejected. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> In addition to providing network-level security, the independent network structure is also used to increase system availability. Typically, an independent network has multiple physical ports for accessing the system. Subscribers connected to the data center over a switched network, for example, can usually reach multiple system ports. Associating these ports with an independent network gives the subscriber the ability to access the system through any of the ports belonging to its associated independent network. Requests that come in through one port can be responded to through another port in the same network, thereby enabling traffic to be managed more efficiently. The independent network structure also allows another port to take over the role of a failed port without affecting connectivity. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> In this embodiment, the second level of security, resource-level security, is implemented using three other MIB tables: the file system details table <highlight><bold>104</bold></highlight>, the subscriber file system access table <highlight><bold>106</bold></highlight> and the subscriber file system mapping table <highlight><bold>108</bold></highlight>. The contents of the first two of these tables can be manipulated by a data system administrator to define file systems (table <highlight><bold>104</bold></highlight>) and to assign access rights to them (table <highlight><bold>106</bold></highlight>). The first of these tables is indexed by the file system name (i.e., the name assigned to the file system by its creator) and the second by a concatenation of the file system name with the handle of the subscriber for which the access privileges are being defined. If the indexed entry is present in table <highlight><bold>106</bold></highlight>, the subscriber in question has the specified access privileges (e.g., NFS read, NFS write, FTP read, FTP write, CIFS read, CIFS write, HTTP read, HTTP write). </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> The entries in the subscriber file system mapping table <highlight><bold>108</bold></highlight> are determined by the subscriber, but the system reconciles those entries with the entries in table <highlight><bold>106</bold></highlight> to prevent any subscriber from attempting to gain access to any file system to which it is not entitled. The table <highlight><bold>108</bold></highlight> entries are indexed by a file-system key rather than the file-system name. The definition of the file-system key is protocol and application dependent. In some applications, for example, the system administrator provides the subscriber with unique logical-unit numbers (LUNs) that map to specific storage volumes, e.g., storage-area network (SAN) file systems. For Internet applications, the file system key is equated to the universal resource locator (URL) address. In all cases, however, the file system key can be extracted from the information received with the request and hence can be concatenated with the subscriber handle to locate the relevant access privileges in table <highlight><bold>108</bold></highlight>. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> The MIB tables are all stored as flat databases. Using these databases, any member of a subscriber group can monitor and control the subscriber&apos;s resources through writeable files or Simple Network Management Protocol (SNMP) commands. The MIB tables define the parameters that the subscriber can manipulate and the allowed limits on those parameters. For example, by manipulating the information in the subscriber file system mapping table <highlight><bold>108</bold></highlight>, the subscriber can define several virtual subscriber subgroups, each having its own IP address. The subscriber can then associate with each subgroup the volume or file system to which the subgroup has access, the number of active sessions that the subgroup can maintain at any one time, its URL (Uniform Resource Locator) maps, its user password and the group to which it is assigned. In addition, the subscriber can access these databases to specify its service agreement and to monitor its system utilization parameters. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> The use of some or all of these various tables and lists can be illustrated by tracing the system&apos;s response to a subscriber&apos;s access request in accordance with an embodiment of the invention. The first routine to handle a request is called a network access control routine and the steps involved in this routine are shown in the flowchart in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> The routine begins when a new request for service is received by the system. In step <highlight><bold>200</bold></highlight>, the network access control routine first checks the session database <highlight><bold>120</bold></highlight> for the session handle and, in step <highlight><bold>202</bold></highlight>, the routine determines whether the request is part of an ongoing session. Specifically, if the session already exists, its handle will be found in the session database and the subscriber&apos;s network access permissions will have already been established and verified and hence do not have to be reestablished. In this case, the routine proceeds to step <highlight><bold>218</bold></highlight> where another routine called a resource access control routine is then called to enforce the second level of security, that is, to determine if the requester has the necessary permissions to access the requested resource. This latter routine is discussed below and makes a decision in step <highlight><bold>220</bold></highlight> whether to grant or to deny access. If the access request is not accepted, the resource access control routine returns with an &ldquo;access denied&rdquo; message and the request is rejected by the network access control routine in step <highlight><bold>226</bold></highlight>. The network access control routine then finishes. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> If the access request is accepted in step <highlight><bold>220</bold></highlight>, the subscriber&apos;s pending request counter is incremented in step <highlight><bold>222</bold></highlight> and, in step <highlight><bold>224</bold></highlight>, a determination is made if the counter has reached a prescribed limit. If a determination is made in step <highlight><bold>224</bold></highlight> that the counter has reached the limit, the routine proceeds to step <highlight><bold>228</bold></highlight> where flow control is initiated for that subscriber, thereby preventing any new requests from being accepted until at least one of the pending requests has been served. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> In any case, the network access control routine proceeds to step <highlight><bold>230</bold></highlight> where a routine called the request submission routine is then called and the network access control routine finishes. </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> If, in step <highlight><bold>202</bold></highlight>, no session database matching entry is found, the routine proceeds to step <highlight><bold>204</bold></highlight> where the independent network details table <highlight><bold>114</bold></highlight> is accessed using the network key as the first step in identifying the controlling subscriber. A determination is made in step <highlight><bold>206</bold></highlight>, based on the results of this access. If an entry corresponding to the network key is not found in table <highlight><bold>114</bold></highlight>, the routine proceeds to step <highlight><bold>226</bold></highlight> where the request is immediately rejected. The routine then finishes. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> Otherwise, an entry is retrieved and the two flags of the entry are examined as described above in connection with <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. Depending on which, if either, of the two flags is set, the handle for the controlling subscriber may be extracted from the independent network details table <highlight><bold>114</bold></highlight> itself as set forth in step <highlight><bold>208</bold></highlight>. Alternatively, the handle can be obtained from the application address table <highlight><bold>110</bold></highlight> as set forth in step <highlight><bold>210</bold></highlight> or the handle can be obtained from the subscriber network identification table <highlight><bold>116</bold></highlight> as set forth in step <highlight><bold>212</bold></highlight>. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> In particular, if the source and destination subscribers are identical, as indicated by one of the flags in the entry retrieved from table <highlight><bold>114</bold></highlight>, the handle of the controlling subscriber can be extracted from table <highlight><bold>114</bold></highlight> and permission is automatically granted since the subscriber in control of the resource is also the subscriber requesting access to that resource. If, however, this is not the case, then the information retrieved from either table <highlight><bold>110</bold></highlight> or table <highlight><bold>116</bold></highlight>, as determined by the second flag, yields both the controlling subscriber handle and the access permissions specified by that subscriber, as previously discussed. </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> A determination is then made in step <highlight><bold>214</bold></highlight> whether permission to access the resources will be granted. If, based on the information retrieved from tables <highlight><bold>110</bold></highlight> and <highlight><bold>116</bold></highlight>, permission is not granted in step <highlight><bold>214</bold></highlight>, the routine proceeds to step <highlight><bold>226</bold></highlight> where the session is rejected and the routine finishes. Otherwise, a new session is created as shown in step <highlight><bold>216</bold></highlight>. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> Creating a session entails several steps. First, if the subscriber was previously not active, an entry for it is inserted in the subscriber monitoring database <highlight><bold>122</bold></highlight>. This, in turn, involves checking the subscriber traffic agreement table <highlight><bold>112</bold></highlight> to determine the contracted level of service for that subscriber. Second, the session handle is appended to the subscriber monitoring database entry for the subscriber. If the previously described metric is used, for example, the new session is appended to the subscriber&apos;s list 0. Third, an entry for that session is inserted into the session database <highlight><bold>120</bold></highlight> listing the new request, identifying the session&apos;s session group and, if priority levels are used, specifying its associated priority level as specified in table <highlight><bold>112</bold></highlight>. </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> Once the session has been created, the routine proceeds through steps <highlight><bold>218</bold></highlight> through <highlight><bold>230</bold></highlight> as previously described. </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> A flowchart describing the steps taken in the aforementioned resource access control routine is shown in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>. When this routine is called, in step <highlight><bold>300</bold></highlight>, it first checks the session database <highlight><bold>120</bold></highlight> to determine if a pointer is present, which pointer can be used to access the subscriber file system mapping database <highlight><bold>108</bold></highlight>. If such a pointer is present as determined in step <highlight><bold>302</bold></highlight>, then the routine proceeds to step <highlight><bold>304</bold></highlight>&mdash;where that pointer is used to access directly a bitmap entry in database <highlight><bold>108</bold></highlight> containing the relevant access permissions. If, based on these permissions, the access is determined to be legitimate in step <highlight><bold>308</bold></highlight>, the routine returns with an &ldquo;access allowed&rdquo; return value as set forth in step <highlight><bold>318</bold></highlight>. Alternatively, if, in step <highlight><bold>308</bold></highlight>, it is determined that the request is not legal, then the routine returns with an &ldquo;access rejected&rdquo; return value in step <highlight><bold>312</bold></highlight>. </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> If, in step <highlight><bold>302</bold></highlight>, no pointer is found in the session database <highlight><bold>120</bold></highlight>, the routine proceeds to step <highlight><bold>306</bold></highlight> where the catenation of the subscriber handle and the file system key is used as an index to search through the subscriber file system mapping database <highlight><bold>108</bold></highlight> in order to find the governing access permissions. If the access attempt is found to be illegal in step <highlight><bold>310</bold></highlight>, the routine proceeds to step <highlight><bold>312</bold></highlight> and returns with an access rejected return value. If the access is permitted as determined in step <highlight><bold>310</bold></highlight>, since the session database <highlight><bold>120</bold></highlight> does not already contain a pointer into database <highlight><bold>108</bold></highlight> (as determined in step <highlight><bold>300</bold></highlight>), the routine first determines whether the file session is bound to the resource being accessed in step <highlight><bold>314</bold></highlight>. A session is bound to a resource if all requests submitted as part of that session are constrained to access only that resource. This, in turn, is a function of the type of session that has been created. NFS sessions using TCP, for example, are bound to a specific file system or mount point; NFS sessions using UDP are not. Similarly, HTTP sessions can be either persistent sessions, which are not bound to a resource, or non-persistent sessions that are bound to a resource. </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> If, as determined in step <highlight><bold>314</bold></highlight>, the session is bound to a resource, in step <highlight><bold>316</bold></highlight>, a pointer to the relevant permission entry in the subscriber file system mapping database <highlight><bold>108</bold></highlight> is inserted into the session database <highlight><bold>120</bold></highlight>, thereby expediting the service of subsequent requests made during that same session. If the session is not bound to the resource, this of course cannot be done since the next request under that session may well be for some other resource, so the entry pointed to would no longer be relevant. In either case, the routine returns with an access granted return value in step <highlight><bold>318</bold></highlight>. </paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> The steps of the request submission routine are depicted in the flowchart in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>. When called, the routine proceeds to step <highlight><bold>402</bold></highlight> where a determination is made whether the associated session is active. If the determination is made that the association is not active, it is activated in step <highlight><bold>404</bold></highlight> by moving the session from the inactive list identified in the relevant subscriber monitoring database entry to the appropriate active list location, as determined by the inactive session&apos;s most recent metric (next eligible service time using the previously described ordered-list implementation). In step <highlight><bold>406</bold></highlight>, the request is added to the session&apos;s list of requests, identified by a pointer in the session database <highlight><bold>120</bold></highlight>. Next, in step <highlight><bold>408</bold></highlight>, the previously mentioned performance parameters that are maintained by system-level performance monitoring background task are checked, to determine if the system is running at capacity. If the system is at capacity, the routine exits. If the system is not at capacity, the request submission routine calls the request service routine in step <highlight><bold>410</bold></highlight> and then exits. </paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> A flow chart for the request service routine is shown in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>. A subscriber, or session, is called &ldquo;conformant&rdquo; if its metric does not exceed the current metric threshold for that subscriber or session. The request service routine cycles through all of the active subscribers, servicing each subscriber&apos;s active sessions in turn, until either all of the subscribers active sessions have been serviced or until the subscriber is no longer conformant. To make this possible, session metric thresholds may be increased periodically so long as the subscriber is conformant and there are still requests pending. A session is said to be eligible for service if it is conformant. </paragraph>
<paragraph id="P-0068" lvl="0"><number>&lsqb;0068&rsqb;</number> The request service routine is always called with the handle of a subscriber called the &ldquo;initial subscriber&rdquo;. On being called, in step <highlight><bold>500</bold></highlight>, the routine first determines the conformance criteria for each active subscriber and then equates the current subscriber pointer to the initial subscriber. The conformance criteria determination is made by first estimating the current capacity available to each session group based on parameters generated by the background performance-monitoring task and updated with the demand represented by the requests that have been submitted since that task was last run. The capacity available to each session group is then apportioned among the active subscribers in compliance with their contracted levels of service. Finally, the system capacity is equated to the sum of the session group capacities and a portion of that capacity is allocated to each subscriber as previously described. </paragraph>
<paragraph id="P-0069" lvl="0"><number>&lsqb;0069&rsqb;</number> Once the conformance criteria have been determined, in step <highlight><bold>502</bold></highlight>, a further determination is made whether the current subscriber is conformant, that is, if it has not already exceeded its allocated portion of the system&apos;s capacity. If the subscriber is determined to be conformant, then the routine proceeds to step <highlight><bold>504</bold></highlight> where it is determined whether the subscriber has any pending requests. </paragraph>
<paragraph id="P-0070" lvl="0"><number>&lsqb;0070&rsqb;</number> If there are pending requests, then, in step <highlight><bold>506</bold></highlight>, the session threshold metric is updated so that at least one session is conformant. If the aforementioned ordered list implementation is used to order sessions, this step entails re-labeling and, where necessary, coalescing the session lists based on the current time as previously described. The request service routine then calls the request delivery routine (described below) in step <highlight><bold>508</bold></highlight>. When the latter routine completes, in step <highlight><bold>510</bold></highlight>, the request service routine equates the current subscriber to the next active subscriber in the subscriber monitoring database <highlight><bold>122</bold></highlight> and, if the current subscriber is again the initial subscriber, as determined in step <highlight><bold>512</bold></highlight>, indicating that all active subscribers have been serviced, the routine exits. Otherwise, the routine loops back to step <highlight><bold>502</bold></highlight> and continues with steps <highlight><bold>504</bold></highlight>-<highlight><bold>510</bold></highlight>. Whenever a subscriber is encountered that is either no longer conformant (as determined in step <highlight><bold>502</bold></highlight>) or has no pending requests (as determined in step <highlight><bold>504</bold></highlight>), the routine immediately proceeds to the next active subscriber as set by step <highlight><bold>510</bold></highlight>. </paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> The request delivery routine is illustrated by the flowchart shown in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>. This routine cycles through all eligible sessions for the current subscriber and, for each eligible session, submits the session&apos;s pending requests one-by-one until that session is no longer eligible for further service. After being called, in step <highlight><bold>600</bold></highlight>, the subscriber&apos;s first eligible unserved session is selected and, in step <highlight><bold>602</bold></highlight>, a check is made to determine if the selected session belongs to a conformant session group. </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> If the selected session belongs to a conformant group, then, in step <highlight><bold>604</bold></highlight> the first pending request of the selected session is delivered to the appropriate application and, based on information returned by the application, the quality-of-service data of the subscriber, the session group and the session is updated to reflect the estimated throughput capacity needed to service that request. </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> Next, in step <highlight><bold>606</bold></highlight>, a counter containing the number of requests pending for that subscriber is decremented and, if the subscriber had been previously placed under flow control, that restriction is removed, since the submission of one of its requests to the application makes room for one more request on the subscriber&apos;s request-pending queue. </paragraph>
<paragraph id="P-0074" lvl="0"><number>&lsqb;0074&rsqb;</number> If, following the submission of the request, the subscriber either has no more pending requests as determined in step <highlight><bold>608</bold></highlight> or is no longer conformant as determined in step <highlight><bold>610</bold></highlight>, the routine returns. Otherwise, the routine proceeds to step <highlight><bold>612</bold></highlight> where the session is tested for conformance. If the session is still conformant and still has requests pending as determined in step <highlight><bold>614</bold></highlight>, the routine returns to step <highlight><bold>602</bold></highlight> and repeats the sequence of steps <highlight><bold>602</bold></highlight>-<highlight><bold>612</bold></highlight>. Alternatively, if, in step <highlight><bold>614</bold></highlight>, it is determined that the session has no more requests, the session is put on the inactive list in step <highlight><bold>616</bold></highlight>. </paragraph>
<paragraph id="P-0075" lvl="0"><number>&lsqb;0075&rsqb;</number> If the session either has been deactivated in step <highlight><bold>616</bold></highlight>, is no longer conformant (as determined in step <highlight><bold>612</bold></highlight>) or was found to belong to a non-conformant session group in step <highlight><bold>602</bold></highlight> the routine proceeds to step <highlight><bold>618</bold></highlight> where a determination is made whether the subscriber has other eligible sessions. If it does, the routine returns to step <highlight><bold>600</bold></highlight> and selects the next eligible session. If, however, no more sessions are eligible, then the eligibility criterion is adjusted in step <highlight><bold>620</bold></highlight> before returning to step <highlight><bold>600</bold></highlight>. The eligibility criteria are changed because the subscriber has already been determined to be conformant and has pending requests. Thus, next most nearly eligible sessions need to be made eligible in order to satisfy the quality of service to which the subscriber is entitled. If the previously described ordered-list implementation is used to order sessions, step <highlight><bold>620</bold></highlight> involves linking the first non-empty list of sessions to list 0 and may also entail re-labeling and, where necessary, coalescing the session lists based on the current time. </paragraph>
<paragraph id="P-0076" lvl="0"><number>&lsqb;0076&rsqb;</number> Two other routines are needed to implement an embodiment of the present invention: a request complete routine and an accounting routine. Flow charts for these two routines are depicted in <cross-reference target="DRAWINGS">FIGS. 7 and 8</cross-reference>, respectively. The request complete routine in <cross-reference target="DRAWINGS">FIG. 7</cross-reference> is called by the relevant application after each request submitted to it has been serviced by that application. Since the original estimate of the capacity needed to service a request, which was returned to the request delivery routine (illustrated in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>), may be imprecise, because the throughout capacity needed to service the request may not have been calculable or predictable before servicing the request, the first step <highlight><bold>700</bold></highlight> in the request complete routine updates the relevant session metric with the difference between the estimated and the actual amount of data transferred in servicing the request. This is accomplished by requiring the application to provide that difference when it calls the request complete routine and then using that information to update the metric stored along with the session handle in the session database <highlight><bold>120</bold></highlight>. This information is subsequently used when the subscriber and session metrics are updated in the request service routine and the request delivery routine. Specifically, the difference between the estimated and actual demand is used to increment or decrement, as appropriate, the new capacity allocation for that subscriber and session. </paragraph>
<paragraph id="P-0077" lvl="0"><number>&lsqb;0077&rsqb;</number> Next, in step <highlight><bold>702</bold></highlight>, the request complete routine then updates the estimate of the capacity available to the session group in question. Since the request has been serviced, the capacity previously reserved for servicing it can be released to other requests pending in that same session group. </paragraph>
<paragraph id="P-0078" lvl="0"><number>&lsqb;0078&rsqb;</number> An accounting routine, such as that illustrated in <cross-reference target="DRAWINGS">FIG. 8</cross-reference> is run periodically to update the information in the subscriber accounting table <highlight><bold>118</bold></highlight>. When run, this routine first updates the accounting information for each open session in step <highlight><bold>800</bold></highlight> by sequencing though the session database and capturing the recent throughput data for each session. In step <highlight><bold>802</bold></highlight>, the data associated with each of a subscriber&apos;s sessions is then combined to update the accounting information for each active subscriber. Next, in step <highlight><bold>804</bold></highlight>, the inactive session list is scanned for each active subscriber and those sessions that have been inactive for some predetermined time period are closed, pruning them from the session database <highlight><bold>120</bold></highlight>. Finally, all subscribers having no active sessions are removed from the active subscriber list in step <highlight><bold>806</bold></highlight>. Both of these last two steps prevent the session database and the subscriber monitoring database <highlight><bold>122</bold></highlight> from becoming unnecessarily large, thereby significantly improving computational efficiency. </paragraph>
<paragraph id="P-0079" lvl="0"><number>&lsqb;0079&rsqb;</number> A software implementation of the above-described embodiment may comprise a series of computer instructions either fixed on a tangible medium, such as a computer readable medium, e.g. a diskette, a CD-ROM, a ROM memory, or a fixed disk, or transmissible to a computer system, via a modem or other interface device over a medium. The medium either can be a tangible medium, including, but not limited to, optical or analog communications lines, or may be implemented with wireless techniques, including but not limited to microwave, infrared or other transmission techniques. It may also be the Internet. The series of computer instructions embodies all or part of the functionality previously described herein with respect to the invention. Those skilled in the art will appreciate that such computer instructions can be written in a number of programming languages for use with many computer architectures or operating systems. Further, such instructions may be stored using any memory technology, present or future, including, but not limited to, semiconductor, magnetic, optical or other memory devices, or transmitted using any communications technology, present or future, including but not limited to optical, infrared, microwave, or other transmission technologies. It is contemplated that such a computer program product may be distributed as removable media with accompanying printed or electronic documentation, e.g., shrink wrapped software, pre-loaded with a computer system, e.g., on system ROM or fixed disk, or distributed from a server or electronic bulletin board over a network, e.g., the Internet or World Wide Web. </paragraph>
<paragraph id="P-0080" lvl="0"><number>&lsqb;0080&rsqb;</number> Although an exemplary embodiment of the invention has been disclosed, it will be apparent to those skilled in the art that various changes and modifications can be made which will achieve some of the advantages of the invention without departing from the spirit and scope of the invention. For example, it will be obvious to those reasonably skilled in the art that, although the description was directed to a particular hardware system, other hardware and system software could be used in the same manner as that described. Other aspects, such as the specific instructions utilized to achieve a particular function, as well as other modifications to the inventive concept are intended to be covered by the appended claims.</paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method for partitioning network data services among multiple subscribers, to allow multiple source subscribers to selectively access a plurality of destination subscribers who provide data services, each destination subscriber being located at a destination address, the method comprising: 
<claim-text>(a) defining a plurality of independent networks, each independent network comprising a set of access ports and a unique set of destination addresses and being logically separate from all other independent networks so that no information can pass from one independent network to another independent network; </claim-text>
<claim-text>(b) when a source subscriber with an identity makes a request to use a first independent network to connect to a destination subscriber and access a resource, using the identity to determine whether the source subscriber has permission to use the first independent network; </claim-text>
<claim-text>(c) if the source subscriber has permission to use the first independent network, determining whether the source subscriber or a destination subscriber has control over the resource; </claim-text>
<claim-text>(d) if a destination subscriber has control over the resource, using information in the request to identify a destination subscriber and a response port; and </claim-text>
<claim-text>(e) if the source subscriber has control over the resource, using the identity to determine whether the source subscriber can access the resource. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein the identity identifies an access port by which the source subscriber is accessing the first independent network. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein step (a) comprises storing in a first database information for each source subscriber defining each independent network to which that source subscriber has access. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference> wherein step (b) comprises using the identity to access the first database and to determine whether information concerning the first independent network resides in the first database and, if so, to retrieve that information. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00004">claim 4</dependent-claim-reference> wherein step (c) comprises using the information concerning the first network to determine whether the source subscriber or a destination subscriber has control over the resource. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference> wherein step (d) comprises using the information concerning the first network and information in the request to access a second database and to retrieve an identify of a destination subscriber and a response port. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference> wherein step (e) comprises using the identity to access a third database to determine whether information concerning the source subscriber resides in the third database and, if so, to retrieve permission information from the third database. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> further comprising: 
<claim-text>(f) using a fourth database to store information entered by an administrator of the data center defining a plurality of file systems; </claim-text>
<claim-text>(g) using a fifth database to store information entered by an administrator of the data center defining access privileges of the multiple subscribers to file systems defined by information in the first database; </claim-text>
<claim-text>(h) using a sixth database to store information entered by the multiple subscribers defining subgroups of subscribers and assigning each subgroup to a file system defined by the first database; and </claim-text>
<claim-text>(i) reconciling the information in the sixth database to the information in the fourth database to prevent the multiple subscribers from accessing a file system to which they do not have access. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference> wherein the sixth database is structured in accordance with a management information base protocol. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. A method for partitioning network data services among multiple subscribers, each of whom makes requests to selectively access a plurality of data services, the method comprising: 
<claim-text>(a) defining at least one session for each of the multiple subscribers, during which session requests from the each subscriber can be generated; </claim-text>
<claim-text>(b) assigning to each session a throughput metric that measures quality of service; </claim-text>
<claim-text>(c) assigning at least one active session list and one inactive list to each of the multiple subscribers and placing sessions defined for each subscriber on the active session list assigned to that subscriber; and </claim-text>
<claim-text>(d) ordering the active session lists from a first list to a last list and servicing pending requests in sessions in the first active session list. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference> wherein step (a) comprises opening a session for one of the multiple subscribers when the one subscriber generates a request and closing the session when no further requests are generated. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference> wherein step (a) comprises assigning each session to a session group defined by a set of resources used by the each session. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference> wherein step (d) comprises checking the session group prior to servicing pending requests in the each session to determine whether the resources assigned to the each session group have reached capacity and bypassing the session when the set of resources has reached capacity. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference> wherein step (b) comprises assigning to each session a throughput metric that is related to a fraction of the currently available throughput capacity that is allocated to the each session. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference> wherein an application responds to a request for service by returning an estimate of the resource capacity that will be necessary to respond to the request and wherein step (b) comprises adjusting the throughput metric based on the estimate. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference> further comprising (e) selecting the next eligible subscriber for servicing requests when a throughput adjustment results in a subscriber exceeding an allocated capacity. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference> wherein step (d) comprises servicing pending requests in an active session on the first active session list until the throughput consumed by all requests serviced is estimated to exceed a predetermined amount of allocated capacity or all requests have been serviced. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference> wherein step (d) further comprises removing the active session from the first active session list and placing the active session on another session list when the throughput consumed by all requests serviced is estimated to exceed a predetermined amount of capacity allocated to the active session. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference> wherein step (d) further comprises removing the active session from the first active session list and placing the active session on the inactive list when all requests have been serviced. </claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. Apparatus for partitioning network data services among multiple subscribers, to allow multiple source subscribers to selectively access a plurality of destination subscribers who provide data services, each destination subscriber being located at a destination address, the apparatus comprising: 
<claim-text>means for defining a plurality of independent networks, each independent network comprising a set of access ports and a unique set of destination addresses and being logically separate from all other independent networks so that no information can pass from one independent network to another independent network; </claim-text>
<claim-text>when a source subscriber with an identity makes a request to use a first independent network to connect to a destination subscriber and access a resource, first means for using the identity to determine whether the source subscriber has permission to use the first independent network; </claim-text>
<claim-text>if the source subscriber has permission to use the first independent network, means for determining whether the source subscriber or a destination subscriber has control over the resource; </claim-text>
<claim-text>if a destination subscriber has control over the resource, second means for using information in the request to identify a destination subscriber and a response port; and </claim-text>
<claim-text>if the source subscriber has control over the resource, third means for using the identity to determine whether the source subscriber can access the resource. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 20</dependent-claim-reference> wherein the identity identifies an access port by which the source subscriber is accessing the first independent network. </claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 20</dependent-claim-reference> wherein the means for defining a plurality of independent networks comprises a first database and means for storing in the first database information for each source subscriber defining each independent network to which that source subscriber has access. </claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 22</dependent-claim-reference> wherein the first using means comprises means for using the identity to access the first database and to determine whether information concerning the first independent network resides in the first database and, if so, to retrieve that information. </claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 23</dependent-claim-reference> wherein the means for determining comprises using the information concerning the first network to determine whether the source subscriber or a destination subscriber has control over the resource. </claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 24</dependent-claim-reference> wherein the second means for using comprises a second database and means for using the information concerning the first network and information in the request to access the second database and to retrieve an identify of a destination subscriber and a response port. </claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 24</dependent-claim-reference> wherein the third means for using comprises a third database and means for using the identity to access the third database to determine whether information concerning the source subscriber resides in the third database and, if so, to retrieve permission information from the third database. </claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 20</dependent-claim-reference> further comprising: 
<claim-text>a fourth database and means for using the fourth database to store information entered by an administrator of the data center defining a plurality of file systems; </claim-text>
<claim-text>a fifth database and means for using the fifth database to store information entered by an administrator of the data center defining access privileges of the multiple subscribers to file systems defined by information in the first database; </claim-text>
<claim-text>a sixth database and means for using the sixth database to store information entered by the multiple subscribers defining subgroups of subscribers and assigning each subgroup to a file system defined by the first database; and </claim-text>
<claim-text>means for reconciling the information in the sixth database to the information in the fourth database to prevent the multiple subscribers from accessing a file system to which they do not have access. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 27</dependent-claim-reference> wherein the sixth database is structured in accordance with a management information base protocol. </claim-text>
</claim>
<claim id="CLM-00029">
<claim-text><highlight><bold>29</bold></highlight>. Apparatus for partitioning network data services among multiple subscribers, each of whom makes requests to selectively access a plurality of data services, the method comprising: 
<claim-text>means for defining at least one session for each of the multiple subscribers, during which session requests from the each subscriber can be generated; </claim-text>
<claim-text>means for assigning to each session a throughput metric that measures quality of service; </claim-text>
<claim-text>means for assigning at least one active session list and one inactive list to each of the multiple subscribers and placing sessions defined for each subscriber on the active session list assigned to that subscriber; and </claim-text>
<claim-text>means for ordering the active session lists from a first list to a last list and servicing pending requests in sessions in the first active session list. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00030">
<claim-text><highlight><bold>30</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 29</dependent-claim-reference> wherein the means for defining at least one session comprises means for opening a session for one of the multiple subscribers when the one subscriber generates a request and means for closing the session when no further requests are generated. </claim-text>
</claim>
<claim id="CLM-00031">
<claim-text><highlight><bold>31</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 29</dependent-claim-reference> wherein the means for defining comprises means for assigning each session to a session group defined by a set of resources used by the each session. </claim-text>
</claim>
<claim id="CLM-00032">
<claim-text><highlight><bold>32</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00033">claim 31</dependent-claim-reference> wherein the means for ordering the active session lists comprises means for checking the session group prior to servicing pending requests in the each session to determine whether the resources assigned to the each session group have reached capacity and means for bypassing the session when the set of resources has reached capacity. </claim-text>
</claim>
<claim id="CLM-00033">
<claim-text><highlight><bold>33</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 29</dependent-claim-reference> wherein the means for assigning to each session a throughput metric comprises means for assigning to each session a throughput metric that is related to a fraction of the currently available throughput capacity that is allocated to the each session. </claim-text>
</claim>
<claim id="CLM-00034">
<claim-text><highlight><bold>34</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00033">claim 33</dependent-claim-reference> wherein an application responds to a request for service by returning an estimate of the resource capacity that will be necessary to respond to the request and wherein the means for assigning to each session a throughput metric comprises means for adjusting the throughput metric based on the estimate. </claim-text>
</claim>
<claim id="CLM-00035">
<claim-text><highlight><bold>35</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00033">claim 34</dependent-claim-reference> further comprising means for selecting the next eligible subscriber for servicing requests when a throughput adjustment results in a subscriber exceeding an allocated capacity. </claim-text>
</claim>
<claim id="CLM-00036">
<claim-text><highlight><bold>36</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 29</dependent-claim-reference> wherein the means for ordering the active session lists comprises means for servicing pending requests in an active session on the first active session list until the throughput consumed by all requests serviced is estimated to exceed a predetermined amount of allocated capacity or all requests have been serviced. </claim-text>
</claim>
<claim id="CLM-00037">
<claim-text><highlight><bold>37</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00033">claim 36</dependent-claim-reference> wherein the means for ordering the active session lists further comprises means for removing the active session from the first active session list and means for placing the active session on another session list when the throughput consumed by all requests serviced is estimated to exceed a predetermined amount of capacity allocated to the active session. </claim-text>
</claim>
<claim id="CLM-00038">
<claim-text><highlight><bold>38</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00033">claim 36</dependent-claim-reference> wherein the means for ordering the active session lists further comprises means for removing the active session from the first active session list and means for placing the active session on the inactive list when all requests have been serviced. </claim-text>
</claim>
<claim id="CLM-00039">
<claim-text><highlight><bold>39</bold></highlight>. A computer program product for partitioning network data services among multiple subscribers, to allow multiple source subscribers to selectively access a plurality of destination subscribers who provide data services, each destination subscriber being located at a destination address, the computer program product comprising a computer usable medium having computer readable program code thereon, including: 
<claim-text>program code for defining a plurality of independent networks, each independent network comprising a set of access ports and a unique set of destination addresses and being logically separate from all other independent networks so that no information can pass from one independent network to another independent network; </claim-text>
<claim-text>first program code operable when a source subscriber with an identity makes a request to use a first independent network to connect to a destination subscriber and access a resource, for using the identity to determine whether the source subscriber has permission to use the first independent network; </claim-text>
<claim-text>program code operable if the source subscriber has permission to use the first independent network, for determining whether the source subscriber or a destination subscriber has control over the resource; </claim-text>
<claim-text>second program code operable if a destination subscriber has control over the resource, for using information in the request to identify a destination subscriber and a response port; and </claim-text>
<claim-text>third program code operable if the source subscriber has control over the resource, for using the identity to determine whether the source subscriber can access the resource. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00040">
<claim-text><highlight><bold>40</bold></highlight>. The computer program product of <dependent-claim-reference depends_on="CLM-00033">claim 39</dependent-claim-reference> wherein the identity identifies an access port by which the source subscriber is accessing the first independent network. </claim-text>
</claim>
<claim id="CLM-00041">
<claim-text><highlight><bold>41</bold></highlight>. The computer program product of <dependent-claim-reference depends_on="CLM-00033">claim 39</dependent-claim-reference> wherein the program code for defining a plurality of independent networks comprises program code for storing in a first database information for each source subscriber defining each independent network to which that source subscriber has access. </claim-text>
</claim>
<claim id="CLM-00042">
<claim-text><highlight><bold>42</bold></highlight>. The computer program product of <dependent-claim-reference depends_on="CLM-00044">claim 41</dependent-claim-reference> wherein the first program code for using comprises program code for using the identity to access the first database and to determine whether information concerning the first independent network resides in the first database and, if so, to retrieve that information. </claim-text>
</claim>
<claim id="CLM-00043">
<claim-text><highlight><bold>43</bold></highlight>. The computer program product of <dependent-claim-reference depends_on="CLM-00044">claim 42</dependent-claim-reference> wherein the determining means comprises means for using the information concerning the first network to determine whether the source subscriber or a destination subscriber has control over the resource. </claim-text>
</claim>
<claim id="CLM-00044">
<claim-text><highlight><bold>44</bold></highlight>. The computer program product of <dependent-claim-reference depends_on="CLM-00044">claim 43</dependent-claim-reference> wherein the second program code for using comprises program code for using the information concerning the first network and information in the request to access a second database and to retrieve an identify of a destination subscriber and a response port. </claim-text>
</claim>
<claim id="CLM-00045">
<claim-text><highlight><bold>45</bold></highlight>. The computer program product of <dependent-claim-reference depends_on="CLM-00044">claim 43</dependent-claim-reference> wherein the third program code for using comprises program code for using the identity to access a third database to determine whether information concerning the source subscriber resides in the third database and, if so, to retrieve permission information from the third database. </claim-text>
</claim>
<claim id="CLM-00046">
<claim-text><highlight><bold>46</bold></highlight>. The computer program product of <dependent-claim-reference depends_on="CLM-00033">claim 39</dependent-claim-reference> further comprising: 
<claim-text>program code for using a fourth database to store information entered by an administrator of the data center defining a plurality of file systems; </claim-text>
<claim-text>program code for using a fifth database to store information entered by an administrator of the data center defining access privileges of the multiple subscribers to file systems defined by information in the first database; </claim-text>
<claim-text>program code for using a sixth database to store information entered by the multiple subscribers defining subgroups of subscribers and assigning each subgroup to a file system defined by the first database; and </claim-text>
<claim-text>program code for reconciling the information in the sixth database to the information in the fourth database to prevent the multiple subscribers from accessing a file system to which they do not have access. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00047">
<claim-text><highlight><bold>47</bold></highlight>. A computer program product for partitioning network data services among multiple subscribers, each of whom makes requests to selectively access a plurality of data services, the computer program product comprising a computer usable medium having computer readable program code thereon, including: 
<claim-text>program code for defining at least one session for each of the multiple subscribers, during which session requests from the each subscriber can be generated; </claim-text>
<claim-text>program code for assigning to each session a throughput metric that measures quality of service; </claim-text>
<claim-text>program code for assigning at least one active session list and one inactive list to each of the multiple subscribers and placing sessions defined for each subscriber on the active session list assigned to that subscriber; and </claim-text>
<claim-text>program code for ordering the active session lists from a first list to a last list and servicing pending requests in sessions in the first active session list. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00048">
<claim-text><highlight><bold>48</bold></highlight>. A computer data signal embodied in a carrier wave for partitioning network data services among multiple subscribers, to allow multiple source subscribers to selectively access a plurality of destination subscribers who provide data services, each destination subscriber being located at a destination address, the computer data signal comprising: 
<claim-text>program code for defining a plurality of independent networks, each independent network comprising a set of access ports and a unique set of destination addresses and being logically separate from all other independent networks so that no information can pass from one independent network to another independent network; </claim-text>
<claim-text>first program code operable when a source subscriber with an identity makes a request to use a first independent network to connect to a destination subscriber and access a resource, for using the identity to determine whether the source subscriber has permission to use the first independent network; </claim-text>
<claim-text>program code operable if the source subscriber has permission to use the first independent network, for determining whether the source subscriber or a destination subscriber has control over the resource; </claim-text>
<claim-text>second program code operable if a destination subscriber has control over the resource, for using information in the request to identify a destination subscriber and a response port; and </claim-text>
<claim-text>third program code operable if the source subscriber has control over the resource, for using the identity to determine whether the source subscriber can access the resource. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00049">
<claim-text><highlight><bold>49</bold></highlight>. A computer data signal embodied in a carrier wave for partitioning network data services among multiple subscribers, each of whom makes requests to selectively access a plurality of data services, the computer data signal comprising: 
<claim-text>program code for defining at least one session for each of the multiple subscribers, during which session requests from the each subscriber can be generated; </claim-text>
<claim-text>program code for assigning to each session a throughput metric that measures quality of service; </claim-text>
<claim-text>program code for assigning at least one active session list and one inactive list to each of the multiple subscribers and placing sessions defined for each subscriber on the active session list assigned to that subscriber; and </claim-text>
<claim-text>program code for ordering the active session lists from a first list to a last list and servicing pending requests in sessions in the first active session list.</claim-text>
</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>1</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030004950A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030004950A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030004950A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030004950A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030004950A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030004950A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030004950A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030004950A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
