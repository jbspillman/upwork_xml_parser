<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005404A1-20030102-D00000.TIF SYSTEM "US20030005404A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005404A1-20030102-D00001.TIF SYSTEM "US20030005404A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005404A1-20030102-D00002.TIF SYSTEM "US20030005404A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005404A1-20030102-D00003.TIF SYSTEM "US20030005404A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005404A1-20030102-D00004.TIF SYSTEM "US20030005404A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005404A1-20030102-D00005.TIF SYSTEM "US20030005404A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030005404A1-20030102-D00006.TIF SYSTEM "US20030005404A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030005404A1-20030102-D00007.TIF SYSTEM "US20030005404A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030005404A1-20030102-D00008.TIF SYSTEM "US20030005404A1-20030102-D00008.TIF" NDATA TIF>
<!ENTITY US20030005404A1-20030102-D00009.TIF SYSTEM "US20030005404A1-20030102-D00009.TIF" NDATA TIF>
<!ENTITY US20030005404A1-20030102-D00010.TIF SYSTEM "US20030005404A1-20030102-D00010.TIF" NDATA TIF>
<!ENTITY US20030005404A1-20030102-D00011.TIF SYSTEM "US20030005404A1-20030102-D00011.TIF" NDATA TIF>
<!ENTITY US20030005404A1-20030102-D00012.TIF SYSTEM "US20030005404A1-20030102-D00012.TIF" NDATA TIF>
<!ENTITY US20030005404A1-20030102-D00013.TIF SYSTEM "US20030005404A1-20030102-D00013.TIF" NDATA TIF>
<!ENTITY US20030005404A1-20030102-D00014.TIF SYSTEM "US20030005404A1-20030102-D00014.TIF" NDATA TIF>
<!ENTITY US20030005404A1-20030102-D00015.TIF SYSTEM "US20030005404A1-20030102-D00015.TIF" NDATA TIF>
<!ENTITY US20030005404A1-20030102-D00016.TIF SYSTEM "US20030005404A1-20030102-D00016.TIF" NDATA TIF>
<!ENTITY US20030005404A1-20030102-D00017.TIF SYSTEM "US20030005404A1-20030102-D00017.TIF" NDATA TIF>
<!ENTITY US20030005404A1-20030102-D00018.TIF SYSTEM "US20030005404A1-20030102-D00018.TIF" NDATA TIF>
<!ENTITY US20030005404A1-20030102-D00019.TIF SYSTEM "US20030005404A1-20030102-D00019.TIF" NDATA TIF>
<!ENTITY US20030005404A1-20030102-D00020.TIF SYSTEM "US20030005404A1-20030102-D00020.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005404</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10126913</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20020419</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F017/50</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>716</class>
<subclass>018000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Graphical loop profile analysis</title-of-invention>
</technical-information>
<continuity-data>
<non-provisional-of-provisional>
<document-id>
<doc-number>60285656</doc-number>
<document-date>20010420</document-date>
<country-code>US</country-code>
</document-id>
</non-provisional-of-provisional>
</continuity-data>
<inventors>
<first-named-inventor>
<name>
<given-name>Bryan</given-name>
<middle-name>Darrell</middle-name>
<family-name>Bowyer</family-name>
</name>
<residence>
<residence-us>
<city>Newberg</city>
<state>OR</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>David</given-name>
<middle-name>Gaines</middle-name>
<family-name>Burnette</family-name>
</name>
<residence>
<residence-us>
<city>Tigard</city>
<state>OR</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Ian</given-name>
<middle-name>Andrew</middle-name>
<family-name>Guyler</family-name>
</name>
<residence>
<residence-us>
<city>Wilsonville</city>
<state>OR</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<assignee>
<organization-name>Mentor Graphics</organization-name>
<assignee-type>02</assignee-type>
</assignee>
<correspondence-address>
<name-1>KLARQUIST SPARKMAN, LLP</name-1>
<name-2></name-2>
<address>
<address-1>One World Trade Center, Suite 1600</address-1>
<address-2>121 S.W. Salmon Street</address-2>
<city>Portland</city>
<state>OR</state>
<postalcode>97204</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A tool is disclosed that allows a hardware designer using a behavioral synthesis tool to view a calculated execution time for a group of related loops identified in source code describing a hardware design circuit. Further, a designer can then interactively unroll and/or pipeline a selected loop without having to modify the source code description of the circuit. Using a graphical user interface (GUI), the designer can modify the loop design easily and see the results of the new loop configuration without having to generate the RTL code, perform RTL synthesis, etc. For example, the designer can readily view the relative loop execution time of the circuit to better determine whether the design is acceptable. Additionally, the designer can execute an area-versus-latency analysis, and, if the analysis is not satisfactory, the designer can unroll and or pipeline selected loops using the GUI. </paragraph>
</subdoc-abstract>
<subdoc-description>
<cross-reference-to-related-applications>
<heading lvl="1">RELATED APPLICATION DATA </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> This application is based on provisional application serial No. 60/285,656, filed Apr. 20, 2001, which is incorporated herein by reference.</paragraph>
</cross-reference-to-related-applications>
<summary-of-invention>
<section>
<heading lvl="1">TECHNICAL FIELD </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> This invention relates generally to behavioral synthesis tools for creating integrated circuits, and more particularly, relates to the representation of loop execution time in a behavioral synthesis tool. </paragraph>
</section>
<section>
<heading lvl="1">BACKGROUND </heading>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> The design of complex computer hardware no longer begins with a circuit diagram. Instead, it begins with a software program that describes the behavior or functionality of a circuit. This software program is written in a hardware description language (HDL) that defines an algorithm to be performed with limited implementation details. Designers direct behavioral synthesis tools to generate alternate architectures by modifying constraints (such as clock period, number and type of data path elements, and desired number of clock cycles). Behavioral synthesis tools convert the HDL program into a register transfer level (RTL) description. The RTL description is used to ultimately generate a netlist that includes a list of components in the circuit and the interconnections between the components. This netlist is used to create the physical integrated circuit. One characteristic of RTL code is that the RTL code is specified for each clock event, while a behavioral specification has a more abstract timing or no timing at all. Going from a behavioral specification to RTL code (manually or automatically) requires a determination of the clocked behavior. In behavioral synthesis this essential step is called scheduling. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> An example HDL source code is shown in Table 1 below that declares three variables, a, b, and c, that are arrays. Each array contains 1024, 8-bit words. The code first declares a &ldquo;subtype&rdquo; to define the type of each element in the array. The code then defines a &ldquo;type&rdquo; to represent the array itself. Finally, the variables are declared, each variable representing an array.  
<table-cwu id="TABLE-US-00001">
<number>1</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="196PT" align="left"/>
<thead>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center">TABLE 1</entry>
</row>
<row>
<entry></entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
<entry>SUBTYPE word IS unsigned (7 DOWNTO 0);</entry>
</row>
<row>
<entry></entry>
<entry>TYPE array type IS ARRAY (integer RANGE &lt;&gt;) of word,</entry>
</row>
<row>
<entry></entry>
<entry>VARIABLE a, b, c: array_type (0 to 1023)</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> Generally, the variables are accessed using loops, such as the loop shown below in Table 2.  
<table-cwu id="TABLE-US-00002">
<number>2</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="70PT" align="left"/>
<colspec colname="1" colwidth="147PT" align="left"/>
<thead>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center">TABLE 2</entry>
</row>
<row>
<entry></entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
<entry>FOR i IN 0 TO 15 LOOP</entry>
</row>
<row>
<entry></entry>
<entry>&emsp;a(i) :&equals; b (i) * c(i) &plus; 4;</entry>
</row>
<row>
<entry></entry>
<entry>END LOOP;</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> After the designer completes the HDL source code (which may include pragma statements or other directives), the designer runs the source code through the synthesis tool. The synthesis tool generates a report that the designer can use to analyze the performance of the circuit. For example, the user can examine the area and latency of the circuit to determine whether the current loop configuration is acceptable. If the loop configuration is not acceptable, the designer must return to an editor, re-edit the source code to unroll or pipeline loops, and run the source code through the synthesis tool again. Such a technique for modifying the design is time consuming and inefficient. Moreover, the designer cannot easily visualize how the loop configuration changes the design while modifying the source code. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> It is desirable, therefore, to provide a synthesis tool that allows a designer to easily identify loops where execution time is relatively inefficient, and unroll or pipeline those loops more quickly and simply. Scheduling determines the number of cycles to perform a static segment of the specification (e.g., one iteration of a loop). How this translates into the dynamic timing of the design depends if and how often each code segment is executed. Segments of the code are repeated over and over again in loops, so the user needs a way to go from the static timing of a scheduled specification to the dynamic timing when executing the specification with actual input values. It is desirable to allow a designer to readily visualize relative loop execution time in the context of dynamic timing. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY </heading>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> The present invention allows a hardware designer using a behavioral synthesis tool to view a calculated execution time for a group of related loops identified in source code describing a hardware design circuit. Further, a designer can then interactively unroll and/or pipeline loops without having to modify the source code description of the circuit. Using a graphical user interface (GUI), the designer can modify the loop design easily and see the results of the new loop configuration without having to generate the RTL code, perform RTL synthesis, etc. For example, the designer can readily view the relative loop execution time of the circuit to better determine whether the design is acceptable. Additionally, the designer can execute an area-versus-latency analysis, and, if the analysis is not satisfactory, the designer can unroll and or pipeline selected loops using the GUI. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> In one aspect, a source code file having a description of the hardware is read into a database within the synthesis tool. The synthesis tool analyzes the source code file and generates a data structure associated with the source code file. The designer can then invoke a GUI that displays a graphical loop profiling analysis including displaying the loops, together with a relative representation of time spent within each loop. The designer can then interactively unroll and or pipeline loops without having to change the source code file. In one embodiment, a graphical loop profile panel is displayed in the context of a loop hierarchy panel and a process scheduler panel. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> Further features and advantages of the invention will become apparent with reference to the following detailed description and accompanying drawings. </paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a block diagram of a system for allowing graphical loop profiling analysis. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a design flow for creating a graphical loop profile display. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a more detailed flow chart for a hardware circuit design utilizing relative loop profile analysis. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is an illustration of a graphical user interface displaying loop constraints. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is an illustration of a graphical user interface displaying process scheduling including a runtime profile panel. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is an expanded illustration of <cross-reference target="DRAWINGS">FIG. 5</cross-reference> including hardware operations within loops. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> is an illustration of a graphical user interface displaying process scheduling including a runtime profile panel. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> is an illustration of a graphical user interface displaying process scheduling including showing an expanded tree structure. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference> is an illustration of a graphical user interface displaying process scheduling including expanded decedent relations and shading representing execution time within loops. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10</cross-reference> is an illustration of a graphical user interface displaying process scheduling including a fly over window showing detailed loop information. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 11</cross-reference> is an illustration of a graphical user interface displaying a latency versus area graph. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 12</cross-reference> is an illustration of a graphical user interface displaying loop constraints wherein the designer unrolls a loop. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 13</cross-reference> is an illustration of a graphical user interface displaying loop constraints wherein the designer pipelines a loop. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 14</cross-reference> is an illustration of a graphical user interface displaying loop constraints wherein the designer applies changes made in <cross-reference target="DRAWINGS">FIGS. 12 and 13</cross-reference>. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 15</cross-reference> is an illustration of a graphical user interface displaying process scheduling including displaying the changes made in FIGS. <highlight><bold>12</bold></highlight>-<highlight><bold>14</bold></highlight>. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 16</cross-reference> is an illustration of a graphical user interface displaying a latency versus area graph showing the data point with improved latency. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 17</cross-reference> is an illustration of an alternative relative loop analysis display using percentage loop execution time. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 18</cross-reference> is an illustration of an alternative relative loop analysis display using a pie chart. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 19</cross-reference> is an illustration of a network environment supporting a distributed client-server embodiment. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 20</cross-reference> is a design flow for one potential distributed client-server embodiment.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION </heading>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> shows a system <highlight><bold>10</bold></highlight> for generating an integrated circuit. A designer typically creates a behavioral description of an integrated circuit by generating source code file <highlight><bold>12</bold></highlight> using a separate editor (not shown). The source code is described generically as HDL and may be written in C, C&plus;&plus;, VHDL, Verilog, etc. Once the source code <highlight><bold>12</bold></highlight> is complete, a behavioral synthesis tool <highlight><bold>14</bold></highlight> reads in the source code file <highlight><bold>12</bold></highlight> and allows a designer to evaluate and modify the circuit architecture early in the design process. In particular, the source code <highlight><bold>12</bold></highlight> is read into an intermediate database <highlight><bold>16</bold></highlight> that holds the behavioral description as a data structure. This data structure, called a synthesis intermediate format (SIF), is modifiable by the user through a graphical user interface (GUI) <highlight><bold>18</bold></highlight>. The behavior synthesis tool then identifies the loops within the source code, and calculates the execution time spent in the identified loops. The GUI <highlight><bold>18</bold></highlight> then displays the relative execution time spent in the identified loops. In one embodiment, a GUI also allows the designer to unroll and or pipeline identified loops where execution time is greatest. By focusing design changes on loops with the greatest execution time, the overall execution time can be efficiently reduced. Additionally, the designer may also quickly evaluate the area and latency associated with different pipelining and unrolling combinations. Once the designer is satisfied with the architecture, the RTL code is generated as shown at <highlight><bold>20</bold></highlight>. Further processing is then performed on the RTL code to ultimately generate the integrated circuit. The behavioral synthesis tool <highlight><bold>14</bold></highlight> may be executed on any desired general purpose computer having any display device or monitor for displaying the GUI and having any desired user input, such as a mouse, keyboard, etc. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> In previous systems, the designer had no relative representation of total time spent in loops, so it was more difficult to determine where to focus design alterations. For example, a loop that has only a few hardware operations compared to the rest of the design, may represent the majority of the execution time, because that loop is executed hundreds of times. With the relative loop execution time displayed, a designer can focus on optimizing the design where the results most efficiently reduce execution time for the integrated circuit. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> shows a flow chart for generating an integrated circuit according to a hardware design tool. The source code is loaded <highlight><bold>30</bold></highlight> into the design tool. The design tool identifies loops within the source code <highlight><bold>32</bold></highlight>. The design tool then calculates the estimated time that each loop will execute <highlight><bold>34</bold></highlight>. The design tool then displays the estimated execution time for the identified loops <highlight><bold>36</bold></highlight>. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> shows a more detailed flow chart for generating an integrated circuit. In process block <highlight><bold>40</bold></highlight>, the designer develops the source code as already described. The behavioral synthesis tool <highlight><bold>14</bold></highlight> (see <cross-reference target="DRAWINGS">FIG. 1</cross-reference>) reads the source code <highlight><bold>42</bold></highlight> into the intermediate database <highlight><bold>16</bold></highlight> and generates a data structure that is changeable by the designer. When generating the data structure, the synthesis tool performs an analysis of the source code <highlight><bold>42</bold></highlight>. For example, the synthesis tool searches for operators, signals, and variables in the source code and generates the data structure based on these HDL statements. Additionally, the synthesis tool searches for directives and uses the directives and/or a set of default selections to set a hardware description in the data structure. The data structure is a data model that can represent loops in a variety of forms the most general being a mapping of the source code as when first read into the behavioral synthesis tool. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> The synthesis tool also identifies the loops <highlight><bold>44</bold></highlight> in the source code, and calculates in conjunction with the hardware description in the data structure, the relative execution time spent in the identified loops <highlight><bold>44</bold></highlight>. This calculation of estimated execution time within loops, can be accomplished a number of ways. The hardware description (e.g., adders, multipliers, flip-flops, memory devices, etc.) has an associated execution time for operations identified within the identified loops. The calculation can estimate execution time by measuring the time required to complete the hardware operations in a loop according to the hardware description. Then multiply the loop calculated execution time with the number of loop iterations identified in the source code to obtain the execution time for a loop. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> Another method involves estimating the number of clock cycles in the source code for the design, and multiplying by the time required for an estimated clock cycle for the design. For example, the hardware operations within the loop are assigned to clock cycles within a loop, thereby determining the number of clock cycles needed to complete each iteration of the loop. The number of clock cycles can then be multiplied by the number of loop iterations to find a total number of clock cycles for the loop. This total number of loop cycles can be multiplied by the clock period to obtain the execution time for the loop. However loop execution time units can be represented as total clock cycles or total execution time, so long as the loops being compared have the same units. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> Pipelined loops can be used in designs to reduce latency. The initialization interval of a pipelined loop specifies the rate at which the pipelined component can begin processing new input data. When a designer decides to pipeline a selected loop, they indicate a pipeline input value (e.g., a pragma statement in the source code, or later interactively, e.g., <cross-reference target="DRAWINGS">FIG. 13</cross-reference>, at <highlight><bold>334</bold></highlight>). This input represents the initialization interval (e.g., number of clock cycles) required before the pipelined loop can begin processing new input data. This initiation interval is used to calculate the execution time for a pipelined loop. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> This calculation of execution time for pipelined loops can be estimated a number of ways. For example, the hardware description of the pipelined loop has an associated execution time for the operations completed within the pipeline. These operations can be assigned to clock cycles to obtain the number of clock cycles required to complete the pipeline once. However the pipelined can begin processing new data (i.e., a next iteration, initiation, or entry into the pipeline) before all instructions in the pipeline are completed. In this way, the pipeline can begin processing input for a second iteration before the first iteration completes. To calculate the time required in waiting before starting a next iteration, the initiation interval described in the previous paragraph is used. Each initiation of the pipeline can begin consecutively after waiting one initiation interval after the previous initiation of the pipeline. Thus, to calculate the execution time of a pipelined loop, the following equation is used: number of clock cycles in the pipeline&plus;(initiation interval * (number of iterations &minus;1)). This produces a total number of clock cycles which can be used directly for relative comparison or multiplied by the clock period to obtain an estimated execution time for relative comparison. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> Of course, as the design changes, these estimations change accordingly. Once the execution time estimation is calculated for each loop, the entire execution time for the design is known, and relative execution times can be calculated. These relative loop execution times can express the relative time relationships parent loops have with child loops and grand-child loops, as well as sibling child loops within the same parent loops. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> The synthesis tool then displays the execution time of the loops <highlight><bold>46</bold></highlight>. The display can be any graphical representation of numeric representation that allows the designer to appreciate the estimated execution time within a loop as compared to the total execution time or as compared to the execution time spent in one or more other loops. The selected display can be more helpful, if it allows the designer to readily discover execution time spent in one loop as compared to another. For example, if a design executes in a hierarchy of nested loops, and the majority of the total estimated execution time is spent in one or more of the loops, the designer might unroll or pipeline those loops to quickly reduce overall execution time. By representing the loop execution times in the context of sibling and or parent-child loop relationships, the illustrated embodiment greatly enhances the efficient development of a hardware circuit. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> Once a designer knows the loops where the greatest execution time is spent, the designer can select the loop, and unroll or pipeline the loop. In one embodiment, the designer makes changes to the source code indicating a new hardware circuit configuration wherein the selected loop is unrolled and or pipeline. Thus, the graphical representation of relative loop execution time allows intelligent choices in hardware design thereby reducing the time required to change the source code. Such an embodiment would not include process block <highlight><bold>50</bold></highlight>, of <cross-reference target="DRAWINGS">FIG. 3</cross-reference>. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> However, in another embodiment, a designer can interactively unroll or pipeline the selected loop <highlight><bold>50</bold></highlight>. This feature allows the designer to make interactive changes to the initial hardware description and design structure represented in the data structure (<cross-reference target="DRAWINGS">FIG. 1, 16</cross-reference>). For example the designer can interactively select a loop, unroll the loop, and/or pipeline the loop <highlight><bold>50</bold></highlight>. With these changes, the data structure representation changes, without requiring the designer to write source code. One embodiment of a design tool can then be used to re-calculate the relative time spent in the altered design <highlight><bold>44</bold></highlight>, and display the relative time of the loops in the altered design <highlight><bold>46</bold></highlight>. This iterative process of unrolling or pipelining loops in the design, continues until the designer decides that a proper balance of speed and size has been realized for the circuit under design. Optionally, the tool can perform a check to analyze the area and latency of the circuit. This may be displaying in an area versus latency graph that gives the designer some immediate feedback on whether the design is satisfactory (e.g., <cross-reference target="DRAWINGS">FIG. 11</cross-reference>) </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> If the designer is unhappy with the displayed relative execution time of the loops or the displayed area versus latency graph, the designer can return to process block <highlight><bold>50</bold></highlight> to further modify the loops, as shown by arrow <highlight><bold>48</bold></highlight>. On the other hand, if the designer is satisfied with the design, the RTL code can be generated and simulated (process blocks <highlight><bold>52</bold></highlight> and <highlight><bold>54</bold></highlight>). Finally, an RTL synthesis tool can perform RTL synthesis (process block <highlight><bold>56</bold></highlight>) and the gate level design can be verified and analyzed (process block <highlight><bold>58</bold></highlight>). </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> shows an example of a loop constraint user interface <highlight><bold>70</bold></highlight> that shows a loop hierarchy panel <highlight><bold>72</bold></highlight> for displaying the family relationships of the loops, after the loops have been identified in the source code by the behavioral synthesis tool (e.g., <cross-reference target="DRAWINGS">FIG. 3, 44</cross-reference>). For example, the loop &ldquo;compress&rdquo; <highlight><bold>74</bold></highlight> is the parent of three child loops &ldquo;mult<highlight><bold>1</bold></highlight>&rdquo; <highlight><bold>76</bold></highlight>, &ldquo;mult<highlight><bold>2</bold></highlight>&rdquo; <highlight><bold>78</bold></highlight>, &ldquo;compress_for&rdquo; <highlight><bold>96</bold></highlight>, and &ldquo;nibble&rdquo; <highlight><bold>80</bold></highlight>. Further, &ldquo;inner<highlight><bold>1</bold></highlight>&rdquo; <highlight><bold>82</bold></highlight> is a grandchild of &ldquo;compress&rdquo; <highlight><bold>74</bold></highlight>, and &ldquo;inner<highlight><bold>1</bold></highlight>_for&rdquo; <highlight><bold>84</bold></highlight> is a great grandchild of &ldquo;compress&rdquo;. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> The loop constraint user interface <highlight><bold>70</bold></highlight>, also has a loop frequency panel <highlight><bold>86</bold></highlight> that indicates the number of times each loop will be executed. For example, the loop &ldquo;mult<highlight><bold>1</bold></highlight>&rdquo; <highlight><bold>76</bold></highlight> will be executed &ldquo;8&rdquo; times (as shown at <highlight><bold>88</bold></highlight>), and the loop &ldquo;inner<highlight><bold>1</bold></highlight>&rdquo; will be executed &ldquo;8&rdquo; times (as shown at <highlight><bold>90</bold></highlight>). However, since loop &ldquo;inner<highlight><bold>1</bold></highlight>&rdquo; is a child of loop &ldquo;mult<highlight><bold>1</bold></highlight>&rdquo;, this family relationship indicates that &ldquo;inner<highlight><bold>1</bold></highlight>&rdquo; will execute 8 times each time &ldquo;mult<highlight><bold>1</bold></highlight>&rdquo; executes. Thus, loop &ldquo;inner<highlight><bold>1</bold></highlight>&rdquo; will execute a total of 64 times. Finally, since the source code did not indicate the number of times loop &ldquo;nibble&rdquo; <highlight><bold>80</bold></highlight> will execute, the frequency panel has no corresponding loop frequency value <highlight><bold>92</bold></highlight> for &ldquo;nibble&rdquo;. For each such undefined loop frequency value, the synthesis tool will assume a default loop execution frequency value of <highlight><bold>1</bold></highlight>. However, the loop constraint user interface is an interactive interface (e.g., <cross-reference target="DRAWINGS">FIG. 3, 50</cross-reference>), so the user can change the default loop frequency value by entering a new value (at the space shown at <highlight><bold>92</bold></highlight>). </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> The loop constraint user interface <highlight><bold>70</bold></highlight> also contains a loop unroll panel <highlight><bold>94</bold></highlight>. The loop unroll panel indicates for each loop, whether or not that loop is unrolled. For example, the loop unroll panel indicates that loop &ldquo;inner<highlight><bold>1</bold></highlight>_for&rdquo; <highlight><bold>84</bold></highlight> is not (&ldquo;(n)&rdquo;) unrolled <highlight><bold>96</bold></highlight>. When the source code is first read into the behavioral design tool, the code itself may indicate in pragma statements to unroll a given loop. For example, in this case the loop &ldquo;compress_for&rdquo; <highlight><bold>96</bold></highlight> started in an unrolled state &ldquo;y&rdquo; <highlight><bold>98</bold></highlight> according to a pragma instruction contained in the source code. However, the loop constraint user interface <highlight><bold>70</bold></highlight> is interactive. During the design process, a designer can change the state of the loops from rolled to unrolled, or from unrolled to rolled. This allows the designer to change the description of the data structure (e.g., <cross-reference target="DRAWINGS">FIG. 3, 42</cross-reference>) without developing new source code <highlight><bold>40</bold></highlight>. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> The loop constraint user interface <highlight><bold>70</bold></highlight> also contains a loop pipeline panel <highlight><bold>100</bold></highlight>. The loop pipeline panel indicates for each loop, whether or not that loop is pipelined. For example, the loop pipeline panel indicates that loop &ldquo;inner<highlight><bold>1</bold></highlight>_for&rdquo; <highlight><bold>84</bold></highlight> is not (&ldquo;no&rdquo;) pipelined <highlight><bold>102</bold></highlight>. When the source code is first read into the behavioral design tool, the code itself may indicate in pragma statements to pipeline a given loop. However, the loop constraint user interface <highlight><bold>70</bold></highlight> is interactive. During the design process, a designer can change the state of the loops from not pipelined to pipelined, or from pipelined to not pipelined. This allows the designer to change the description of the data structure (e.g., <cross-reference target="DRAWINGS">FIG. 3, 42</cross-reference>) without developing new source code <highlight><bold>40</bold></highlight>. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> Once the designer has viewed a start state of the loops <highlight><bold>70</bold></highlight>, the designer can click &ldquo;OK&rdquo; <highlight><bold>104</bold></highlight>, and view the next window. However, if the designer makes changes to the loops, the designer can &ldquo;Apply&rdquo; <highlight><bold>106</bold></highlight> those changes. In either event, the designer can next view the schedule for the design. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> shows an example of a process schedule user interface <highlight><bold>120</bold></highlight> that shows a loop hierarchy panel <highlight><bold>122</bold></highlight> for displaying the family relationships of the loops. The process schedule user interface <highlight><bold>120</bold></highlight>, has a scheduled operations panel <highlight><bold>124</bold></highlight>, which includes a graphical representation of the family relationships of the loops, along with an indication of the clock cycles estimated for each loop (e.g., C<highlight><bold>1</bold></highlight>, C<highlight><bold>1</bold></highlight>, C<highlight><bold>2</bold></highlight> . . . ). </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> For example, the loop &ldquo;compress&rdquo; <highlight><bold>126</bold></highlight>, is shown in the scheduled operations panel as a box <highlight><bold>128</bold></highlight> containing three child boxes <highlight><bold>132</bold></highlight>, <highlight><bold>136</bold></highlight>, and <highlight><bold>140</bold></highlight>. The loop &ldquo;mult<highlight><bold>1</bold></highlight>&rdquo; <highlight><bold>130</bold></highlight> is shown in the scheduled operations panel as a box <highlight><bold>132</bold></highlight> inside the box <highlight><bold>128</bold></highlight> representing its parent loop &ldquo;compress&rdquo; <highlight><bold>126</bold></highlight>. Since &ldquo;mult<highlight><bold>1</bold></highlight>&rdquo; <highlight><bold>130</bold></highlight>, &ldquo;mult<highlight><bold>2</bold></highlight>&rdquo; <highlight><bold>134</bold></highlight>, and &ldquo;nibble&rdquo; <highlight><bold>138</bold></highlight>, are all direct children of &ldquo;compress&rdquo; <highlight><bold>126</bold></highlight>, they each are individually distinguishable boxes <highlight><bold>132</bold></highlight>, <highlight><bold>136</bold></highlight>, <highlight><bold>140</bold></highlight>, inside the box <highlight><bold>128</bold></highlight> representing their parent loop &ldquo;compress&rdquo; <highlight><bold>126</bold></highlight>. Notice that boxes <highlight><bold>132</bold></highlight>, <highlight><bold>136</bold></highlight>, representing sibling child loops, appear within their common parent box <highlight><bold>128</bold></highlight>, but do not appear inside each other. Also notice, that the top of each box in the scheduled operations panel <highlight><bold>124</bold></highlight> appears directly across from the loop it represents in the loop hierarchy panel <highlight><bold>122</bold></highlight>. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> The scheduled operations panel also represents multiple level descendent relationships such as grandparent-grandchild. For example, loop &ldquo;compress&rdquo; <highlight><bold>126</bold></highlight> is a parent of loop &ldquo;mult<highlight><bold>2</bold></highlight>&rdquo; <highlight><bold>134</bold></highlight>, a grandparent of loop &ldquo;inner<highlight><bold>2</bold></highlight>&rdquo; <highlight><bold>142</bold></highlight>, and a great grandparent of loop &ldquo;inner<highlight><bold>2</bold></highlight>_for&rdquo; <highlight><bold>146</bold></highlight>&rdquo;. This relationship is represented in the scheduled operations panel as a hierarchy of boxes nested within boxes in multiple layers. For example, a parent box <highlight><bold>128</bold></highlight> has a child box within itself <highlight><bold>136</bold></highlight>, a grandparent box <highlight><bold>128</bold></highlight>, has a grandchild box <highlight><bold>144</bold></highlight> within its child box <highlight><bold>136</bold></highlight>, and a great grandparent box <highlight><bold>128</bold></highlight>, has its great grandchild box <highlight><bold>148</bold></highlight>, within its grandchild box <highlight><bold>144</bold></highlight>. Thus, in the scheduled operations panel sibling relationships are next to each other <highlight><bold>132</bold></highlight>, <highlight><bold>136</bold></highlight> and within a their parent <highlight><bold>128</bold></highlight>, while descendent relationships are nested within each other (e.g., child within parent, grandchild within child, etc). </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> The process schedule user interface <highlight><bold>120</bold></highlight>, also has a runtime profile panel <highlight><bold>150</bold></highlight>. This panel represents the relative calculated runtime of the identified loops. The panel will be discussed in depth in the following drawings. But first, there is a horizontal relationship between the loop hierarchy panel <highlight><bold>122</bold></highlight>, the scheduled operations panel <highlight><bold>124</bold></highlight>, and the runtime profile panel <highlight><bold>150</bold></highlight>. In particular, the loop &ldquo;compress&rdquo; <highlight><bold>126</bold></highlight> is on the same horizontal line as its box <highlight><bold>128</bold></highlight>, and its runtime profile bar graph <highlight><bold>152</bold></highlight>. Thus, the relative execution time of &ldquo;mult<highlight><bold>1</bold></highlight>&rdquo; <highlight><bold>130</bold></highlight> can be compared to the relative execution time of &ldquo;mult<highlight><bold>2</bold></highlight>&rdquo; <highlight><bold>134</bold></highlight>, by comparing the width of their corresponding bar graphs, respectively <highlight><bold>154</bold></highlight>, <highlight><bold>156</bold></highlight>. Since the &ldquo;mult<highlight><bold>2</bold></highlight>&rdquo; bar <highlight><bold>156</bold></highlight> is wider than the &ldquo;mult<highlight><bold>1</bold></highlight>&rdquo; bar <highlight><bold>132</bold></highlight>, more time is spent executing within &ldquo;mult<highlight><bold>2</bold></highlight>&rdquo;. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> Also notice, that the time spent in a parent includes the time spent in its children, grandchildren, and great grandchildren, etc. Thus, the sum of the &ldquo;mult<highlight><bold>1</bold></highlight>&rdquo; bar <highlight><bold>154</bold></highlight>, the &ldquo;mult<highlight><bold>2</bold></highlight>&rdquo; bar <highlight><bold>156</bold></highlight>, and the &ldquo;nibble&rdquo; bar, should be less than or equal to the size of the bar representing their common parent <highlight><bold>152</bold></highlight>. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> Next, notice that the runtime profile panel includes bars of different shades and or colors. For example, the bar <highlight><bold>160</bold></highlight> is darker than bar <highlight><bold>156</bold></highlight>. Further, bar <highlight><bold>158</bold></highlight> has multiple shades. These multiple colors or shades help the designer determine whether work is being done in a loop or the child of a loop. This concept will be fully developed in conjunction with FIGS. <highlight><bold>7</bold></highlight>-<highlight><bold>9</bold></highlight>. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> Finally, the process schedule user interface <highlight><bold>120</bold></highlight>, has a loop only button <highlight><bold>164</bold></highlight>. <cross-reference target="DRAWINGS">FIG. 5</cross-reference> represents a view of the process schedule interface <highlight><bold>120</bold></highlight> when the loop only button <highlight><bold>164</bold></highlight> is selected. If the designer un-clicks the loop only button <highlight><bold>164</bold></highlight>, <cross-reference target="DRAWINGS">FIG. 6</cross-reference> appears. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference>, is still the process schedule interface <highlight><bold>120</bold></highlight>, but it includes not only the loops scheduled, but the hardware operations within each loop. For example, loop &ldquo;compress&rdquo; contains five hardware operations <highlight><bold>180</bold></highlight> before entering the loop &ldquo;mult<highlight><bold>1</bold></highlight>&rdquo;. </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference>, shows the clock cycles within each loop, and the hardware operations that occur during the clock cycles. For example, within the loop &ldquo;inner<highlight><bold>1</bold></highlight>_for&rdquo; <highlight><bold>190</bold></highlight>, three hardware operations <highlight><bold>192</bold></highlight> are executed in the first clock cycle <highlight><bold>186</bold></highlight>, and one hardware operation <highlight><bold>196</bold></highlight> is executed in the second clock cycle <highlight><bold>194</bold></highlight>. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> Since the loops have been spread out vertically in order to make room for the instructions within loops, the bars representing execution times <highlight><bold>182</bold></highlight> are also spread out vertically in the runtime profile panel. A scroll bar <highlight><bold>184</bold></highlight> is provided to traverse the design pattern, and standard-type window pull-downs <highlight><bold>188</bold></highlight> provide controls and other features such as printing, zoom, edit functions, etc. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> With reference to <cross-reference target="DRAWINGS">FIG. 7</cross-reference>, the diagram focuses on two panels contained within the process schedule user interface <highlight><bold>120</bold></highlight> of <cross-reference target="DRAWINGS">FIGS. 5 and 6</cross-reference>. The discussion focuses on the relationship between the loop hierarchy panel <highlight><bold>202</bold></highlight>, and the runtime profile panel <highlight><bold>204</bold></highlight> in order to fully develop the useful nuances of this runtime profile panel <highlight><bold>204</bold></highlight> embodiment. The scheduled operations panel <highlight><bold>200</bold></highlight> has been pulled closed. Remember, the time spent in a loop is represented by its corresponding bar in the runtime profile panel <highlight><bold>204</bold></highlight>. </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> The loop hierarchy panel <highlight><bold>202</bold></highlight> contains a tree structure that represents the nested parent child relationships between loops. For example, since &ldquo;start wuc&rdquo; <highlight><bold>210</bold></highlight> and &ldquo;compress&rdquo; are direct children of &ldquo;JPEG_Compress_main&rdquo;, they are lined up vertically in the tree structure under &ldquo;JPEG_Compress_main&rdquo;. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> Since &ldquo;JPEG_Compress_&rdquo; <highlight><bold>206</bold></highlight> is the shell for the source code, all execution time exists within its corresponding bar in the runtime profile panel <highlight><bold>214</bold></highlight>. The execution time for the entire design is represented in bar <highlight><bold>214</bold></highlight>. However, the design immediately enters the first loop &ldquo;JPEG_Compress_main&rdquo; <highlight><bold>208</bold></highlight>, so almost all time is also in the bar <highlight><bold>216</bold></highlight>, which represents &ldquo;JPEG_Compress_main&rdquo; <highlight><bold>208</bold></highlight>. Bar <highlight><bold>216</bold></highlight> and bar <highlight><bold>214</bold></highlight> represent almost exactly the same time, so they appear the same size. </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> Next, &ldquo;JPEG_Compress_main&rdquo; <highlight><bold>208</bold></highlight> contains two loops. Very little time is spent in the first loop &ldquo;start wuc&rdquo; <highlight><bold>210</bold></highlight>, so its corresponding bar <highlight><bold>218</bold></highlight> is very small. Since more time is spent in &ldquo;compress&rdquo; <highlight><bold>212</bold></highlight>, its corresponding bar <highlight><bold>220</bold></highlight> is much larger. In this case the children of &ldquo;JPEG_Compress_main&rdquo; (&ldquo;start wuc&rdquo; and &ldquo;compress&rdquo;) contain all the instructions executed within &ldquo;JPEG_Compress_main&rdquo;. So the sum of the child bars <highlight><bold>218</bold></highlight> and <highlight><bold>220</bold></highlight>, equals the size of the parent bar <highlight><bold>216</bold></highlight>. Again, bar <highlight><bold>218</bold></highlight> plus bar <highlight><bold>220</bold></highlight> is equal to bar <highlight><bold>216</bold></highlight>. </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> Finally, the plus sign &ldquo;&plus;&rdquo; in front of the &ldquo;compress&rdquo; loop <highlight><bold>212</bold></highlight> indicates that there is an expandable loop tree structure under &ldquo;compress.&rdquo; The designer clicks the plus &ldquo;&plus;&rdquo; sign <highlight><bold>212</bold></highlight> in order to expand the tree structure and exam the loops nested under &ldquo;compress&rdquo;. </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> shows what happens when the tree structure is expanded under &ldquo;compress&rdquo;. First, notice that the minus sign &ldquo;&minus;&rdquo; <highlight><bold>212</bold></highlight> indicates that the tree under &ldquo;compress&rdquo; <highlight><bold>212</bold></highlight> has been expanded. The loop &ldquo;compress&rdquo; <highlight><bold>212</bold></highlight>, has three direct children, &ldquo;mult<highlight><bold>1</bold></highlight>&rdquo; <highlight><bold>230</bold></highlight>, &ldquo;mult<highlight><bold>2</bold></highlight>&rdquo; <highlight><bold>232</bold></highlight>, and &ldquo;nibble&rdquo; <highlight><bold>234</bold></highlight>. Also, the runtime profile panel <highlight><bold>204</bold></highlight> shows the relative execution time <highlight><bold>236</bold></highlight>, <highlight><bold>238</bold></highlight>, and <highlight><bold>240</bold></highlight>, of each of the direct children. Again, we see that the sum of the child bars <highlight><bold>236</bold></highlight>, <highlight><bold>238</bold></highlight>, and <highlight><bold>240</bold></highlight>, roughly equal the parent <highlight><bold>220</bold></highlight>. Thus, if a designer were interested in selecting a loop for increased efficiency, the loop represented by bar <highlight><bold>238</bold></highlight>, would be a better selection than loop <highlight><bold>240</bold></highlight>, since it represents a greater execution time. However, the shading represents information that may also be valuable in a design decision. </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> Notice that all three child bars <highlight><bold>236</bold></highlight>, <highlight><bold>238</bold></highlight>, and <highlight><bold>240</bold></highlight> contain at least some lighter shade (which in this case appears white). Specifically, bars <highlight><bold>238</bold></highlight> and <highlight><bold>236</bold></highlight> appear all white. This amount of the lighter shade in a bar, signals to the designer, that one of their child loops is doing more work (execution time). The lighter shade <highlight><bold>236</bold></highlight>, <highlight><bold>238</bold></highlight> signals to the designer, that by expanding the tree under loops &ldquo;mult<highlight><bold>1</bold></highlight>&rdquo; <highlight><bold>230</bold></highlight> and &ldquo;mult<highlight><bold>2</bold></highlight>&rdquo; <highlight><bold>232</bold></highlight>, the designer may find a good child candidate loop for unrolling and or pipelining. </paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> When a bar is 100% dark <highlight><bold>244</bold></highlight>, it signals to the designer that it is doing all the work (execution time), and that it does not have a child that would be a good candidate for unrolling or pipelining. If a bar has a dark portion and a light portion <highlight><bold>240</bold></highlight>, the light portion indicates work (execution time) being done by a child loop, and the dark portion indicates the work being done by the loop itself. </paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> In this example, since bars <highlight><bold>236</bold></highlight> and <highlight><bold>238</bold></highlight> indicate they have a child loop doing considerable work, the designer expands the tree structure (by clicking the plus signs), and produces <cross-reference target="DRAWINGS">FIG. 9</cross-reference>. </paragraph>
<paragraph id="P-0068" lvl="0"><number>&lsqb;0068&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 9</cross-reference>, upon expanding the tree under &ldquo;mult<highlight><bold>1</bold></highlight>&rdquo; <highlight><bold>230</bold></highlight>, the designer discovered loop &ldquo;inner<highlight><bold>1</bold></highlight>&rdquo; <highlight><bold>260</bold></highlight> which is mostly a lighter shade <highlight><bold>262</bold></highlight>. The lighter shade indicates work being done by one of its children. So, the designer expands the tree under loop &ldquo;inner<highlight><bold>1</bold></highlight>&rdquo; <highlight><bold>260</bold></highlight>, and discovers a loop &ldquo;inner<highlight><bold>1</bold></highlight>_for&rdquo; <highlight><bold>264</bold></highlight>, which is 100% dark shade <highlight><bold>266</bold></highlight>. This darker shade <highlight><bold>266</bold></highlight> indicates that the loop does most of the work (high execution time). Thus, the runtime profile panel graph has been instrumental in discovering a loop &ldquo;inner<highlight><bold>1</bold></highlight>_for&rdquo; <highlight><bold>264</bold></highlight>, where the relative execution time is very high. Notice also, that &ldquo;inner<highlight><bold>1</bold></highlight>_for&rdquo; loop has no children. This is apparent since the box directly in front of &ldquo;inner<highlight><bold>1</bold></highlight>_for&rdquo; <highlight><bold>264</bold></highlight> contains no plus sign (&ldquo;&plus;&rdquo;). Since it has no children loops, no portion of its bar <highlight><bold>266</bold></highlight>, has any white indicating work done by a child. Further, since &ldquo;inner<highlight><bold>1</bold></highlight>&rdquo; <highlight><bold>260</bold></highlight> has only one child, &ldquo;inner<highlight><bold>1</bold></highlight>_for&rdquo; <highlight><bold>264</bold></highlight>, the dark shade in the child bar <highlight><bold>266</bold></highlight>, is equal to the light shade in the parent bar <highlight><bold>262</bold></highlight>. </paragraph>
<paragraph id="P-0069" lvl="0"><number>&lsqb;0069&rsqb;</number> Finally, when expanding the tree under &ldquo;mult<highlight><bold>2</bold></highlight>&rdquo; <highlight><bold>232</bold></highlight>, the designer discovered loop &ldquo;inner<highlight><bold>2</bold></highlight>&rdquo; <highlight><bold>266</bold></highlight> which is mostly a lighter shade bar <highlight><bold>268</bold></highlight>. The lighter shade indicates a child loop doing a majority of the work. So the designer then expands the tree under loop &ldquo;inner<highlight><bold>2</bold></highlight>&rdquo; <highlight><bold>266</bold></highlight>, and discovers a loop &ldquo;inner<highlight><bold>2</bold></highlight>_for&rdquo; <highlight><bold>270</bold></highlight> which is 100% dark shade <highlight><bold>272</bold></highlight>. The dark shade indicates that the loop does most of the work. Thus, the runtime profile panel graph has been instrumental in discovering a loop &ldquo;inner<highlight><bold>1</bold></highlight>_for&rdquo; <highlight><bold>264</bold></highlight>, where the relative execution time is very high. By discovering a few loops with high relative execution time <highlight><bold>266</bold></highlight>, <highlight><bold>272</bold></highlight>, the designer now knows several good candidates for unrolling or pipelining. </paragraph>
<paragraph id="P-0070" lvl="0"><number>&lsqb;0070&rsqb;</number> Thus, <cross-reference target="DRAWINGS">FIG. 9</cross-reference> shows a relative relationship between loops and their corresponding execution time. In general, we see that work done within a loop can be represented in one color or shade, while work done within a child loop or loops can be represented as a different shade or color. Information organized in this way is particularly valuable to a designer who can reduce latency by focusing on areas of the design (i.e., loops) with the greatest relative execution time. For example, if a designer unrolls or pipelines only a few loops that together represent the a high relative execution time as compared to other loops (e.g., as represented by bars <highlight><bold>266</bold></highlight> and <highlight><bold>272</bold></highlight>), then latency can be reduced efficiently. </paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10</cross-reference> shows a flyer over feature of the process schedule user interface <highlight><bold>120</bold></highlight>. When a user places the cursor over the horizontal line representing the loop &ldquo;compress&rdquo; <highlight><bold>282</bold></highlight>, a pop-up window supplies the designer with relevant information. For example the name of the loop, whether the loop is pipelined and/or unrolled or not, the number of cycles in the loop, the number of cycles under the loop, the total time for the loop, the relative time, etc. </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 11</cross-reference> shows an area versus latency graph used to show the present condition of the proposed hardware circuit under design. The X axis shows the number of cycles (i.e., latency) needed to run the source code using the proposed hardware circuit design. The Y axis shows the area required to hold the hardware for the proposed hardware circuit design. In some cases, the designer has restricted area but more time. In other cases the designer has restricted time but more area. In yet other cases, the designer is constrained in both area and time. After reading in the source code, and identifying loops, the design tool calculates calculates the execution time and produces a data point <highlight><bold>302</bold></highlight> which represents the time and latency for the start state design. If the design needs improvement, the designer has several options. </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> In the illustrated embodiment, the GUI <highlight><bold>300</bold></highlight> presents the designer with certain options in the form of selectable icons (i.e., <highlight><bold>304</bold></highlight>-<highlight><bold>316</bold></highlight>). Selecting these icons, will produce one of the following options, preferably within an interactive GUI. The designer can select the type and speed of the technology for the design <highlight><bold>304</bold></highlight> (not shown). The designer can select the clock speed for the design <highlight><bold>306</bold></highlight> (not shown). The designer can alter the memory used in the design <highlight><bold>308</bold></highlight> (not shown), and make other hardware selections and changes <highlight><bold>310</bold></highlight>. The designer can also unroll or pipeline selected loops <highlight><bold>312</bold></highlight> using the described loop constraints user interface (<cross-reference target="DRAWINGS">FIG. 4, 70</cross-reference>) before or after viewing the runtime profile panel in the process schedule interface (<cross-reference target="DRAWINGS">FIG. 5, 150</cross-reference>). Upon obtaining a desirable data point <highlight><bold>302</bold></highlight>, the designer can complete the hardware design process <highlight><bold>316</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 3</cross-reference>, <highlight><bold>52</bold></highlight>-<highlight><bold>59</bold></highlight>). If the designer selects a loop icon <highlight><bold>312</bold></highlight>, the loop constraint user interface is obtained (<cross-reference target="DRAWINGS">FIG. 12</cross-reference>). </paragraph>
<paragraph id="P-0074" lvl="0"><number>&lsqb;0074&rsqb;</number> The designer can alter the loop constraints using the loop constraint user interface (<cross-reference target="DRAWINGS">FIG. 12</cross-reference>). In this case, since &ldquo;inner<highlight><bold>2</bold></highlight>_for&rdquo; (as shown in <cross-reference target="DRAWINGS">FIG. 9</cross-reference>, bar <highlight><bold>272</bold></highlight>) is a good candidate for unrolling, in <cross-reference target="DRAWINGS">FIG. 12</cross-reference>, the designer selects <highlight><bold>330</bold></highlight> to unroll &ldquo;inner<highlight><bold>2</bold></highlight>_for&rdquo;. Further, in <cross-reference target="DRAWINGS">FIG. 13</cross-reference>, the designer selects a loop for pipelining <highlight><bold>334</bold></highlight>. Upon making several changes in the loop constraint user interface, at <cross-reference target="DRAWINGS">FIG. 14</cross-reference>, the designer applies <highlight><bold>336</bold></highlight> the changes, and then at <cross-reference target="DRAWINGS">FIG. 15</cross-reference>, the view shows how the changes affected the design in the process schedule user interface <highlight><bold>120</bold></highlight>. </paragraph>
<paragraph id="P-0075" lvl="0"><number>&lsqb;0075&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 15</cross-reference>, since the designer rolled out loops &ldquo;inner<highlight><bold>1</bold></highlight>_for&rdquo; and &ldquo;inner<highlight><bold>2</bold></highlight>_for&rdquo;, these loops no longer appear in the loop hierarchy panel <highlight><bold>368</bold></highlight>, but instead they are contained as unrolled within their parents, respectively loop &ldquo;inner<highlight><bold>1</bold></highlight>&rdquo; <highlight><bold>362</bold></highlight> and &ldquo;inner<highlight><bold>2</bold></highlight>&rdquo; <highlight><bold>360</bold></highlight>. Although the work has shifted to their parents&apos; bars, respectively <highlight><bold>364</bold></highlight>, and <highlight><bold>366</bold></highlight>, <cross-reference target="DRAWINGS">FIG. 16</cross-reference> shows that the altered loop constraints have reduced the overall design latency <highlight><bold>380</bold></highlight>. Thus, the relative presentation of calculated execution time (e.g., <cross-reference target="DRAWINGS">FIG. 9</cross-reference>, bars <highlight><bold>266</bold></highlight> and <highlight><bold>272</bold></highlight>) allowed the designer to immediately and efficiently alter the design in a substantial time saving way. </paragraph>
<paragraph id="P-0076" lvl="0"><number>&lsqb;0076&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 17</cross-reference> shows how a numeric or percentage chart could be used to convey the useful information. </paragraph>
<paragraph id="P-0077" lvl="0"><number>&lsqb;0077&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 18</cross-reference> shows how a pie chart could be used to convey the information. </paragraph>
<paragraph id="P-0078" lvl="0"><number>&lsqb;0078&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 19</cross-reference> is a network configuration supporting the illustrated embodiment. In such a network environment a distributed application would have a client computer <highlight><bold>390</bold></highlight> which communicates with a server computer <highlight><bold>392</bold></highlight>. In such an arrangement some functionality of the described behavioral synthesis tool could execute on the client side <highlight><bold>390</bold></highlight>, while other functionality could execute on the server side <highlight><bold>392</bold></highlight>. Data used to support the system could be housed on the client <highlight><bold>390</bold></highlight> or the server <highlight><bold>392</bold></highlight>, or on a database <highlight><bold>396</bold></highlight> accessible to the server possibly at a third location accessible to the server directly <highlight><bold>394</bold></highlight>, or accessible to the client or server over the network <highlight><bold>398</bold></highlight>. The network could be the Internet <highlight><bold>400</bold></highlight>. Such an arrangement may be suitable to an application service provider scenario. In such a case, the client could be a thin client (e.g., an Internet browser). </paragraph>
<paragraph id="P-0079" lvl="0"><number>&lsqb;0079&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 20</cross-reference> shows one embodiment of a distributed system. A client <highlight><bold>420</bold></highlight> could send source code to a server computer <highlight><bold>422</bold></highlight>. The server could load the source code <highlight><bold>432</bold></highlight>, identify loops within the source code <highlight><bold>434</bold></highlight>, calculate execution time for the identified loops <highlight><bold>436</bold></highlight>, and send display data to the client <highlight><bold>438</bold></highlight>. The client could then display the relative runtime results <highlight><bold>424</bold></highlight>. In another embodiment, the interactive design changes described herein, could be employed. For example, design changes could be returned to the server <highlight><bold>430</bold></highlight>, recalculated by the server <highlight><bold>434</bold></highlight>-<highlight><bold>436</bold></highlight>, and new display data returned to the client for display <highlight><bold>438</bold></highlight>. All the same functionality could be provided in such a distributed environment. </paragraph>
<paragraph id="P-0080" lvl="0"><number>&lsqb;0080&rsqb;</number> Having described and illustrated the principles of our invention with reference to an illustrated embodiment, it will be recognized that the illustrated embodiment can be modified in arrangement and detail without departing from such principles. It should be understood that the programs, processes, or methods described herein are not related or limited to any particular type of computer apparatus, unless indicated otherwise. Various types of general purpose or specialized computer apparatus may be used with or perform operations in accordance with the teachings described herein. Elements of the illustrated embodiment shown in software may be implemented in hardware and vice versa. </paragraph>
<paragraph id="P-0081" lvl="0"><number>&lsqb;0081&rsqb;</number> In view of the many possible embodiments to which the principles of our invention may be applied, it should be recognized that the detailed embodiments are illustrative only and should not be taken as limiting the scope of our invention. Rather, we claim as our invention all such embodiments as may come within the scope and spirit of the following claims and equivalents thereto. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">We claim: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. In a behavioral synthesis tool used to design a hardware circuit, a method comprising: 
<claim-text>identifying loops within a source code representation of a hardware circuit; </claim-text>
<claim-text>calculating an estimate of hardware execution time for the identified loops; and </claim-text>
<claim-text>displaying the estimate of hardware execution time in association with the identified loops. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising: 
<claim-text>receiving via a graphical user interface, an indication to unroll a specified loop; </claim-text>
<claim-text>unrolling the specified loop; </claim-text>
<claim-text>calculating the execution time for the unrolled loop; and </claim-text>
<claim-text>displaying the execution time associated with the loops including the unrolled loop. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising: 
<claim-text>receiving via a graphical user interface, an indication to pipeline a specified loop; </claim-text>
<claim-text>pipelining the specified loop; </claim-text>
<claim-text>calculating the execution time for the pipelined loop; and </claim-text>
<claim-text>displaying the execution time associated with the loops including the pipelined loop. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the displayed execution time for the loops is represented as a bar graph, a pie graph, a numeric graph, a graphic comparison or a numeric comparison. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the displayed execution time for a parent loop is represented as a bar graph, and the bar graph of the parent loop represents the execution time of a child loop as a different shade or color. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the displayed execution time for a loop is represented as a bar, and the bar represents the execution time in the loop as a shade or color, and the bar represents the execution time of a descendent loop as a different shade or color. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein the displayed execution time for the identified loops is represented as relative to the execution time of the other identified loops. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein the displayed execution time for the loops are a bar graph, and a bar representing a parent loop is greater than or equal to the sum of the bars representing its child loops. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein calculating comprises: 
<claim-text>for each loop, summing the time required to complete the hardware instructions within the loop; and </claim-text>
<claim-text>multiplying the time required to complete the hardware instructions within a loop by the number of iterations of the loop. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein calculating comprises: 
<claim-text>assigning hardware instructions within a loop to clock cycles within a loop thereby obtaining a number of clock cycles within the loop; </claim-text>
<claim-text>for non-pipelined loops, using the following equation: (number of clock cycles within the loop * number of loop iterations); and </claim-text>
<claim-text>for pipelined loops, using the following equation: (number of clock cycles within the loop&plus;(initiation interval * (number of loop iterations &minus;1))). </claim-text>
</claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein identifying means reading loop directive identifiers in the source code. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the displayed estimate of hardware execution time is within a interactive graphical user interface which includes a representation of hardware operations within loops, and a loop-only button removes hardware operations from the representation. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. A computer-readable medium having computer-executable instructions for performing the method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, wherein unrolling means unrolling without changing the source code. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference>, wherein pipelining means pipelining without changing the source code. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference> wherein an integrated circuit is created containing the unrolled loop. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. An integrated circuit created using the method of <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. In a behavioral synthesis tool used to design an integrated circuit, a method of displaying relative time spent executing in loops, the method comprising: 
<claim-text>reading a source code description associated with the integrated circuit into the behavioral synthesis tool; </claim-text>
<claim-text>storing the source code description as a data structure within memory; </claim-text>
<claim-text>calculating from the data structure, a relative loop execution time; and </claim-text>
<claim-text>displaying the relative loop execution time. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 18</dependent-claim-reference>, further comprising: 
<claim-text>receiving via a graphical user interface, an indication to alter a specified loop; </claim-text>
<claim-text>altering the specified loop in the data structure; </claim-text>
<claim-text>calculating an altered relative loop execution time; and </claim-text>
<claim-text>displaying the altered loop execution time. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. An integrated circuit designed using the method of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference>. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. A computerized system for designing integrated circuits comprising: 
<claim-text>an input device for receiving a source code description of an integrated circuit; </claim-text>
<claim-text>a processor for executing software; </claim-text>
<claim-text>software that identifies loops within the source code; </claim-text>
<claim-text>software that calculates a relative execution time for identified loops; </claim-text>
<claim-text>software that creates displayable output of the relative execution time; and </claim-text>
<claim-text>an output device. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference>, wherein the source code description is at least one of a file, or a series of keyboard strokes. </claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference>, further comprising software that generates an interactive graphical interface for receiving indications to alter identified loops. </claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. A networked server computer method comprising: 
<claim-text>receiving a source code description of a hardware circuit; </claim-text>
<claim-text>identifying loops within the source code; </claim-text>
<claim-text>calculating relative execution time of identified loops; and </claim-text>
<claim-text>sending data representing calculated relative execution times of identified loops. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 24</dependent-claim-reference>, further comprising: 
<claim-text>receiving an indication to alter a specified loop; </claim-text>
<claim-text>altering the specified loop; </claim-text>
<claim-text>re-calculating relative execution time of identified loops; and </claim-text>
<claim-text>re-sending the re-calculated relative execution time of identified loops. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. An integrated circuit containing a loop designed using the method of <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>. </claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. A networked client computer method comprising: 
<claim-text>sending a source code description of a hardware circuit; </claim-text>
<claim-text>receiving data representing relative execution times of identified loops; and </claim-text>
<claim-text>displaying relative execution times of identified loops. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 27</dependent-claim-reference>, further comprising: 
<claim-text>sending an indication to alter a specified loop; </claim-text>
<claim-text>receiving data altered in response to the indication representing relative execution times of identified loops; and </claim-text>
<claim-text>displaying relative execution times of identified loops. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00029">
<claim-text><highlight><bold>29</bold></highlight>. An integrated circuit containing a loop designed using the method of claim <highlight><bold>28</bold></highlight>.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>2</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005404A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005404A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005404A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005404A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005404A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005404A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030005404A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030005404A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030005404A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00009">
<image id="EMI-D00009" file="US20030005404A1-20030102-D00009.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00010">
<image id="EMI-D00010" file="US20030005404A1-20030102-D00010.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00011">
<image id="EMI-D00011" file="US20030005404A1-20030102-D00011.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00012">
<image id="EMI-D00012" file="US20030005404A1-20030102-D00012.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00013">
<image id="EMI-D00013" file="US20030005404A1-20030102-D00013.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00014">
<image id="EMI-D00014" file="US20030005404A1-20030102-D00014.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00015">
<image id="EMI-D00015" file="US20030005404A1-20030102-D00015.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00016">
<image id="EMI-D00016" file="US20030005404A1-20030102-D00016.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00017">
<image id="EMI-D00017" file="US20030005404A1-20030102-D00017.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00018">
<image id="EMI-D00018" file="US20030005404A1-20030102-D00018.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00019">
<image id="EMI-D00019" file="US20030005404A1-20030102-D00019.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00020">
<image id="EMI-D00020" file="US20030005404A1-20030102-D00020.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
