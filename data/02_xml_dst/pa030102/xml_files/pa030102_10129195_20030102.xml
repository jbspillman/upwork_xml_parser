<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030004684A1-20030102-D00000.TIF SYSTEM "US20030004684A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030004684A1-20030102-D00001.TIF SYSTEM "US20030004684A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030004684A1-20030102-D00002.TIF SYSTEM "US20030004684A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030004684A1-20030102-D00003.TIF SYSTEM "US20030004684A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030004684A1-20030102-D00004.TIF SYSTEM "US20030004684A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030004684A1-20030102-D00005.TIF SYSTEM "US20030004684A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030004684A1-20030102-D00006.TIF SYSTEM "US20030004684A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030004684A1-20030102-D00007.TIF SYSTEM "US20030004684A1-20030102-D00007.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030004684</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10129195</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20020502</filing-date>
</domestic-filing-data>
<foreign-priority-data>
<priority-application-number>
<doc-number>99309632.0</doc-number>
</priority-application-number>
<filing-date>19991201</filing-date>
<country-code>EP</country-code>
</foreign-priority-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F015/00</ipc>
</classification-ipc-primary>
<classification-ipc-secondary>
<ipc>G06F011/30</ipc>
</classification-ipc-secondary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>702</class>
<subclass>186000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Apparatus for assessing communication equipment</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>David</given-name>
<family-name>Skingsley</family-name>
</name>
<residence>
<residence-non-us>
<city>Ipswich</city>
<country-code>GB</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Mark</given-name>
<family-name>Barrett</family-name>
</name>
<residence>
<residence-non-us>
<city>Needham Market</city>
<country-code>GB</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>Larry S Nixon</name-1>
<name-2>Nixon &amp;Vanderhye</name-2>
<address>
<address-1>1100 North Glebe Road 8th Floor</address-1>
<city>Arlington</city>
<state>VA</state>
<postalcode>22201-4714</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
<international-conventions>
<pct-application>
<document-id>
<doc-number>PCT/GB00/04548</doc-number>
<document-date>20001129</document-date>
<country-code>WO</country-code>
</document-id>
</pct-application>
</international-conventions>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">Apparatus for testing and/or monitoring the transmission of data packets by communications equipment, the apparatus comprising: </paragraph>
<paragraph id="A-0002" lvl="2">(i) registering means for registering one or more transmission protocols to enable the apparatus to communicate according to any registered protocol; </paragraph>
<paragraph id="A-0003" lvl="2">(ii) submitting means for submitting a request, the request specifying at least one testing and/or monitoring operation; </paragraph>
<paragraph id="A-0004" lvl="2">(iii) decoding means for decoding a received request into one or more processable events in accordance with one or more predetermined rules; </paragraph>
<paragraph id="A-0005" lvl="2">(iv) read/write means for controlling the writing of data packets to, and the reading of data packets from, the communications equipment; and </paragraph>
<paragraph id="A-0006" lvl="2">(v) scheduling means for scheduling decoding of received requests and execution of the one or more processable events in accordance with the read/write means, </paragraph>
<paragraph id="A-0007" lvl="7">such that, when a request is received from the submitting means, the scheduling means schedules: </paragraph>
<paragraph id="A-0008" lvl="2">a) decoding of the request into one or more processable events by the decoding means; </paragraph>
<paragraph id="A-0009" lvl="2">b) initialization of the processable events by the decoding means; and </paragraph>
<paragraph id="A-0010" lvl="2">c) reading and writing of data packets from and to the communications equipment by the read/write means in accordance with the processable events. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> This invention relates to assessing communication equipment and is suitable particularly, but not exclusively, for testing and/or monitoring network equipment. </paragraph>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> The continuing development of networking technology is fundamental to data communication, as this is intrinsic to, among other things, the interconnection of many disparate physical networks, and the transfer of information across multiple information sources. Significant efforts have been, and are continually, directed towards reducing limitations and increasing the flexibility of network equipment, both in the hardware and software areas. However, only a relatively small number of tools that are suitable for testing and evaluating various aspects of both new and existing network equipment have been developed. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> Applications that transfer information over networks rely on network equipment to transport data between source and destination address(es), and are wholly dependent on the robustness of the network equipment for successful data transfer. Often, users of such applications experience &ldquo;slow network traffic&rdquo;, or network failure. An inability to find faults, and to correct for those faults in a reasonable amount of time, can result in significant inconvenience to users and loss of data, and is costly. Thus, if the network equipment could be more effectively monitored, problem areas could be identified, and current levels of inconvenience could be reduced. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> New transmission protocols and router technologies affect the way in which data is transferred between applications, and these applications may require to modify aspects of data formatting in order to effect successful sending and receiving of data. At present the tools that are flexible enough to analyse and test new protocols and technologies are either exceedingly expensive or limited in scope. These include tools such as: </paragraph>
<paragraph id="P-0005" lvl="2"><number>&lsqb;0005&rsqb;</number> &ldquo;SmartBits&trade;&rdquo; by NetComm&trade;, which allows a tester to edit all of the fields in the data packets, and to generate and receive traffic from a variety of media types; </paragraph>
<paragraph id="P-0006" lvl="2"><number>&lsqb;0006&rsqb;</number> &ldquo;NetXray&trade;&rdquo; by Cinco&trade;, which is configurable to probe packets travelling on a network using predetermined tests, and report any problems based on predetermined criteria. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> According to a first aspect of the present invention, there is provided apparatus for testing and/or monitoring the transmission of data packets by communications equipment, the apparatus comprising: </paragraph>
<paragraph id="P-0008" lvl="2"><number>&lsqb;0008&rsqb;</number> (i) registering means for registering one or more transmission protocols to enable the apparatus to communicate according to any registered protocol; </paragraph>
<paragraph id="P-0009" lvl="2"><number>&lsqb;0009&rsqb;</number> (ii) submitting means for submitting a request, the request specifying at least one testing and/or monitoring operation; </paragraph>
<paragraph id="P-0010" lvl="2"><number>&lsqb;0010&rsqb;</number> (iii) decoding means for decoding a received request into one or more processable events in accordance with one or more predetermined rules; </paragraph>
<paragraph id="P-0011" lvl="2"><number>&lsqb;0011&rsqb;</number> (iv) read/write means for controlling the writing of data packets to, and the reading of data packets from, the communications equipment; and </paragraph>
<paragraph id="P-0012" lvl="2"><number>&lsqb;0012&rsqb;</number> (v) scheduling means for scheduling decoding of received requests and execution of the one or more processable events in accordance with the read/write means, </paragraph>
<paragraph id="P-0013" lvl="7"><number>&lsqb;0013&rsqb;</number> such that, when a request is received from the submitting means, the scheduling means schedules: </paragraph>
<paragraph id="P-0014" lvl="2"><number>&lsqb;0014&rsqb;</number> a) decoding of the request into one or more processable events by the decoding means; </paragraph>
<paragraph id="P-0015" lvl="2"><number>&lsqb;0015&rsqb;</number> b) initialisation of the processable events by the decoding means; and </paragraph>
<paragraph id="P-0016" lvl="2"><number>&lsqb;0016&rsqb;</number> c) reading and writing of data packets from and to the communications equipment by the read/write means in accordance with the processable events.</paragraph>
</summary-of-invention>
<brief-description-of-drawings>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> Further aspects, features and advantages of the apparatus for assessing communication equipment will now be described, by way of example only as an embodiment of the present invention, and with reference to the accompanying drawings, in which: </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a schematic diagram of an IP network in operative association with the apparatus for assessing communication equipment; </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a schematic block diagram of the principal components comprising the apparatus for assessing communication equipment, when observing traffic being routed between two host machines; </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a block diagram showing the decoding steps performed by the assessing apparatus; </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a block diagram showing the initialisation processes performed by the assessing apparatus; </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a block diagram showing the receiving processes performed by the read/write means of <cross-reference target="DRAWINGS">FIG. 2</cross-reference>; </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is a block diagram showing the sending processes performed by the read/write means of <cross-reference target="DRAWINGS">FIG. 2</cross-reference>; </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference><highlight><italic>a </italic></highlight>is a schematic diagram of apparatus for emulating network characteristics; </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference><highlight><italic>b </italic></highlight>is a schematic block diagram of the components comprising the apparatus for emulating network characteristics; </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> is a block diagram showing the processes involved when the apparatus for emulating network characteristics is in operative association with the apparatus for assessing communication equipment; and </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference> is a block diagram showing the steps of dropping, delaying and queuing packets performed by the emulating apparatus.</paragraph>
</brief-description-of-drawings>
<detailed-description>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> In the following description, the terms &ldquo;network&rdquo;, &ldquo;packet&rdquo;, &ldquo;traffic&rdquo;, &ldquo;request&rdquo;, &ldquo;event&rdquo;, and &ldquo;command switch&rdquo; are used. These are defined as follows: </paragraph>
<paragraph id="P-0029" lvl="1"><number>&lsqb;0029&rsqb;</number> &ldquo;Network&rdquo;: a series of points or nodes interconnected by communication paths. Networks can interconnect with other networks and contain sub-networks. A given network can be characterised by the type of data transmission technology in use on it (for example, a TCP/IP, SNA, ATM network); </paragraph>
<paragraph id="P-0030" lvl="1"><number>&lsqb;0030&rsqb;</number> &ldquo;Packet&rdquo;: a packet is a unit of data that is routed between an origin and a destination on one or more packet-switched networks (e.g. the Internet, ATM network). When any file (e-mail message, HTML file, GIF file, URL request, and so forth) is sent from one place to another on the Internet, the Transmission Control Protocol (TCP) layer of TCP/IP divides the file into &ldquo;chunks&rdquo; of an efficient size for routing. Each of these packets is separately numbered and includes the Internet address of the destination. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> The individual packets for a given file may travel different routes through the Internet. When they have all arrived, they are reassembled into the original file (by the TCP layer at the receiving end). </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> When the network is an ATM network, the units of data are called cells, and when an IP network is uses the UDP protocol (User Datagram Protocol) the units of data are called datagrams. </paragraph>
<paragraph id="P-0033" lvl="1"><number>&lsqb;0033&rsqb;</number> &ldquo;Traffic&rdquo;: movement of packets (or cells or datagrams) over a network. </paragraph>
<paragraph id="P-0034" lvl="1"><number>&lsqb;0034&rsqb;</number> &ldquo;Request&rdquo;: input command specifying type of test or monitoring to be carried out. </paragraph>
<paragraph id="P-0035" lvl="1"><number>&lsqb;0035&rsqb;</number> &ldquo;Command switch&rdquo;: command line input which may be decoded into system actions e.g. &ldquo;xcopy -s -v&rdquo;: xcopy is system function, and -s -v are flags corresponding to event parameters associated with the function; or &ldquo;-p -O <highlight><bold>2048</bold></highlight>&rdquo;: -p is the function to be performed and -O <highlight><bold>2048</bold></highlight> is a corresponding event parameter. (A request comprises both the function to be performed and the event parameters). </paragraph>
<paragraph id="P-0036" lvl="1"><number>&lsqb;0036&rsqb;</number> &ldquo;event&rdquo;: a process performed by the assessment apparatus, for instance in fulfilling a request. </paragraph>
<paragraph id="P-0037" lvl="7"><number>&lsqb;0037&rsqb;</number> Overview </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> With reference to <cross-reference target="DRAWINGS">FIG. 1</cross-reference> of the accompanying drawings, assessment apparatus <highlight><bold>100</bold></highlight> for assessing a network according to the present invention may be used to test and/or monitor operation of a network, and may generally be referred to as a &lsquo;core&rsquo; <highlight><bold>100</bold></highlight>. The testing and/or monitoring may be effected by analysing network traffic passing through a network arrangement, which traffic has either been injected into the network arrangement by the apparatus, or has been initiated by processes running on machines within the network arrangement. A network arrangement may include a plurality of networks <highlight><bold>101</bold></highlight>, <highlight><bold>103</bold></highlight>, <highlight><bold>105</bold></highlight> as shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, or a single network. A single network may include an arrangement of two computers <highlight><bold>201</bold></highlight>, <highlight><bold>203</bold></highlight> connected to one another, with or without a router (shown in <cross-reference target="DRAWINGS">FIG. 2</cross-reference> with a router), or an arrangement of many computers connected via a plurality of network routers <highlight><bold>107</bold></highlight>, such as CISCO&trade; routers. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> Client machines <highlight><bold>109</bold></highlight>, <highlight><bold>111</bold></highlight> may connect to any one of the networks via routers <highlight><bold>107</bold></highlight>. </paragraph>
<paragraph id="P-0040" lvl="7"><number>&lsqb;0040&rsqb;</number> Core </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> In use, the core <highlight><bold>100</bold></highlight> is loaded on a computer <highlight><bold>215</bold></highlight>, which computer <highlight><bold>215</bold></highlight> may either be dedicated to the core <highlight><bold>100</bold></highlight>, and connected directly to a router as shown in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, or may be a server computer supporting the core <highlight><bold>100</bold></highlight> and other processes and data connected remotely to the network (not shown). Referring to <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, an embodiment of the core <highlight><bold>100</bold></highlight> is shown divided into 4 functional parts: </paragraph>
<paragraph id="P-0042" lvl="2"><number>&lsqb;0042&rsqb;</number> SUBMITTING MEANS <highlight><bold>205</bold></highlight> </paragraph>
<paragraph id="P-0043" lvl="2"><number>&lsqb;0043&rsqb;</number> REGISTERING MEANS <highlight><bold>207</bold></highlight> </paragraph>
<paragraph id="P-0044" lvl="2"><number>&lsqb;0044&rsqb;</number> COMMUNICATIONS MEANS <highlight><bold>209</bold></highlight> </paragraph>
<paragraph id="P-0045" lvl="2"><number>&lsqb;0045&rsqb;</number> SCHEDULING MEANS <highlight><bold>211</bold></highlight> </paragraph>
<paragraph id="P-0046" lvl="3"><number>&lsqb;0046&rsqb;</number> DECODING MEANS <highlight><bold>212</bold></highlight> </paragraph>
<paragraph id="P-0047" lvl="3"><number>&lsqb;0047&rsqb;</number> WRITE/READ MEANS <highlight><bold>213</bold></highlight> </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> The SUBMITTING MEANS <highlight><bold>205</bold></highlight> submits a request defining a type of test or monitoring via a GUI (Graphical User Interface) or command line. When the core <highlight><bold>100</bold></highlight> is running on a dedicated computer, the GUI may be either loaded on to the computer, or may be downloadable onto a computer located remote from the dedicated computer, such that the GUI communicates with the core <highlight><bold>100</bold></highlight> from this remote computer. When the core <highlight><bold>100</bold></highlight> is running on a server computer connected remotely to the network, the GUI may be activated either local to, or remote from, the server computer. When the submitting means receives instructions from the command line, similar conditions apply, but there is no need to download a command line to accept and process the inputs. When a request is received by the submitting means <highlight><bold>205</bold></highlight>, it is passed to the scheduling means <highlight><bold>211</bold></highlight> (described below) for processing. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> The REGISTERING MEANS <highlight><bold>207</bold></highlight> registers transmission protocol processes that are required for transmitting packets of data. These processes include specifying parameters for building a packet, sending a packet and receiving a packet, and are protocol-specific. For example data transmitted over an IP network may involve the use of a transport layer protocol (e.g. TCP) and an internet layer protocol (IPv4), and there is therefore a corresponding build, send and receive function for each of them. The registering of protocols in this manner enables packets to be built and sent as scheduled by the scheduling means <highlight><bold>211</bold></highlight>, which is effected in response to requests submitted by the submitting means <highlight><bold>205</bold></highlight>. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> The COMMUNICATIONS MEANS <highlight><bold>209</bold></highlight> provides a medium for communication between equipment on a network or other processes on the same computer. The communication means <highlight><bold>209</bold></highlight> acts as a port, or a channel, both for receiving requests that have been submitted by the submitting means <highlight><bold>205</bold></highlight> for processing by the core <highlight><bold>100</bold></highlight>, and to send and receive packets of data. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> The SCHEDULING MEANS <highlight><bold>211</bold></highlight> receives requests from the submitting means <highlight><bold>205</bold></highlight>, schedules decoding of the request by the decoding means <highlight><bold>212</bold></highlight> into one or more processable events, and schedules capturing and sending of data packets by the read/write means <highlight><bold>213</bold></highlight>. The scheduling means <highlight><bold>211</bold></highlight> continuously checks for incoming requests, so co-ordinates this activity with the processes performed by the decoding means <highlight><bold>212</bold></highlight> and the read/write means <highlight><bold>213</bold></highlight>. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> The DECODING MEANS <highlight><bold>212</bold></highlight> is used to decode incoming requests, to identify one or more processable events based on the requests, and to initialise these processable events. When requests are input via the command line, the request is formulated using command switches, e.g. -p -<highlight><bold>0</bold></highlight> <highlight><bold>2048</bold></highlight>, and the event that is identified from the command switch (in this example -p) is decoded by the decoding means <highlight><bold>212</bold></highlight> into an event identifier. The event identifier is then used to identify corresponding processable events, which processable events are initialised for running by the read/write means <highlight><bold>213</bold></highlight>. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> The READ/WRITE MEANS <highlight><bold>213</bold></highlight> effects packet sending and packet capturing processes. These processes embed the processable events registered by the decoding means <highlight><bold>212</bold></highlight>, such that data is sent and received as a function of the processable events. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> These functional parts inter-operate in the following manner: </paragraph>
<paragraph id="P-0055" lvl="1"><number>&lsqb;0055&rsqb;</number> A user enters input at the command line in a predetermined format, which input both invokes the submitting means <highlight><bold>205</bold></highlight>, and specifies a request for a network assessment process. The request is parsed through the communication means <highlight><bold>209</bold></highlight> to the scheduling means <highlight><bold>211</bold></highlight>, which passes the request to the decoding means <highlight><bold>212</bold></highlight>. The decoding means <highlight><bold>212</bold></highlight> decodes the incoming request into an event identifier, identifies one or more processable events based on the event identifier, and initialises these processable events via a start event. The decoding means <highlight><bold>212</bold></highlight> is also scheduled to execute a stop event to flush the system of any lingering events. Scheduling means <highlight><bold>211</bold></highlight> then schedules execution of the read/write means <highlight><bold>213</bold></highlight>, which, because the processable events are embedded in the sending and capturing processes providing the read/write means <highlight><bold>213</bold></highlight>, effects sending and capturing of data according to the processable events. </paragraph>
<paragraph id="P-0056" lvl="7"><number>&lsqb;0056&rsqb;</number> Embodiment of the Invention </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> An embodiment of the core <highlight><bold>100</bold></highlight> may be used in conjunction with customised tools that interface with the core <highlight><bold>100</bold></highlight> in a modular, or plug-and-play sense. In other words, the submitting means <highlight><bold>205</bold></highlight>, registering means <highlight><bold>207</bold></highlight>, the communication means <highlight><bold>209</bold></highlight> and the scheduling means <highlight><bold>211</bold></highlight> are independent of the request, which may be &lsquo;plugged&rsquo; in via the processable events. The event identifier decoded by the decoding means <highlight><bold>212</bold></highlight> distinguishes one request from another, and thus the core <highlight><bold>100</bold></highlight> relies on the identified processable events to effect the specific features of the request. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> The following gives a non-exhaustive list of network features that may be examined by the core (when interfacing with an appropriate tool): </paragraph>
<paragraph id="P-0059" lvl="2"><number>&lsqb;0059&rsqb;</number> 1. Quantifying how network equipment deal with packets of varying size; </paragraph>
<paragraph id="P-0060" lvl="2"><number>&lsqb;0060&rsqb;</number> 2. Quantifying how network equipment deal with different packet generation frequencies; </paragraph>
<paragraph id="P-0061" lvl="2"><number>&lsqb;0061&rsqb;</number> 3. Quantifying how an application responds to certain characteristics of a network (all configurable); </paragraph>
<paragraph id="P-0062" lvl="2"><number>&lsqb;0062&rsqb;</number> 4. Quantifying the behaviour of new protocols; </paragraph>
<paragraph id="P-0063" lvl="2"><number>&lsqb;0063&rsqb;</number> 5. Quantifying how the network equipment behave in response to new protocols; </paragraph>
<paragraph id="P-0064" lvl="2"><number>&lsqb;0064&rsqb;</number> 6. Quantifying effectiveness of routing algorithms. </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> As the tools and the present invention inter-relate in a modular sense, the functionality of the core <highlight><bold>100</bold></highlight> is independent of the tool. However, the core <highlight><bold>100</bold></highlight> is described with reference to incoming testing requests, and the way in which the it <highlight><bold>100</bold></highlight> schedules reading and/or writing of data is described in relation to those requests. </paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> The core <highlight><bold>100</bold></highlight> provides a service of communicating with network equipment according to requests received, and, as is well known in the art, all such network services are described by transmission protocols. Protocols provide rules for communication of data. They contain details of message formats, describe how a computer responds when a message arrives, and specify how a computer handles errors or other abnormal conditions. A suitable description of IP network protocols is provided in &ldquo;Computer Networks&rdquo;, Andrew S. Tanenbaum, Pub. &ldquo;Prentice Hall&rdquo;. There are application layer protocols, transport layer protocols and internet layer protocols, and these control how information is passed between the layers and ultimately over a network. Thus, in order for packets of data to be injected into a network, the data requires passing through each of these layers in accordance with the protocol definitions. The core treats protocol definitions as a centralised resource, which can be accessed by any process decoded from a request. Thus, functional definitions of all of the protocols are scheduled for registering before the scheduling means <highlight><bold>211</bold></highlight> looks for any incoming requests. </paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> The registering process is performed by registering means <highlight><bold>207</bold></highlight>. For the specific case of an IP network, such as an ethernet, typical protocols include: </paragraph>
<paragraph id="P-0068" lvl="2"><number>&lsqb;0068&rsqb;</number> Ethernet Protocol, Address Resolution Protocol (ARP) (network interface layer); </paragraph>
<paragraph id="P-0069" lvl="2"><number>&lsqb;0069&rsqb;</number> Internet Group Management Protocol (IGMP), Internet Protocol version 4 (Ipv4), Internet Protocol version 6 (Ipv6) (Internet layer); </paragraph>
<paragraph id="P-0070" lvl="2"><number>&lsqb;0070&rsqb;</number> Transmission Control Protocol (TCP), and User Datagram Protocol (UDP) (transport layer), </paragraph>
<paragraph id="P-0071" lvl="7"><number>&lsqb;0071&rsqb;</number> (TCP/IP protocols can be used with ATM networks as well). </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> The processes for sending and receiving data are actually invoked when the read/write means <highlight><bold>213</bold></highlight> are run, so the function of the registering means <highlight><bold>207</bold></highlight> is to assign processable events for each of the protocols in preparation for actual building of packets, sending and receiving of data. </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> In an embodiment of the present invention the core <highlight><bold>100</bold></highlight> waits for a request to be passed on from the submitting means <highlight><bold>205</bold></highlight>. In a preferred arrangement, the waiting for, and passage of, requests occurs via a socket that provides the communication means <highlight><bold>209</bold></highlight>. As is well known in the art, a socket is a communications port. An application can use a socket to talk to other equipment on a network or other processes on the same computer. It does this by passing information containing identifying information to the operating system. For example, communication with another computer on a network requires identification of the network address of the computer, and communication with another process on the same computer requires identification of a specific file that the process monitors for receiving incoming &lsquo;calls&rsquo;. The embodiment of the present invention utilises a socket in accordance with the latter scenario, and the scheduling means <highlight><bold>211</bold></highlight> is in effect listening for data from the submitting means <highlight><bold>205</bold></highlight>. </paragraph>
<paragraph id="P-0074" lvl="0"><number>&lsqb;0074&rsqb;</number> The submitting means <highlight><bold>205</bold></highlight> may be a process running in operative association with input from either a GUI or the command prompt, such that as soon as a request is received from, for example, the command line, the submitting means <highlight><bold>205</bold></highlight> attempts to parse this request through the socket. When requests are received via the command line, the process invoking the submitting means <highlight><bold>205</bold></highlight>, &ldquo;nbexe&rdquo;, is typed in at the command line, together with one or more predetermined command switches. These command switches define a request, and parameters specifying features of the request, for a network assessment process. </paragraph>
<paragraph id="P-0075" lvl="0"><number>&lsqb;0075&rsqb;</number> The following example shows a request that may be input at the command line: </paragraph>
<paragraph id="P-0076" lvl="1"><number>&lsqb;0076&rsqb;</number> nbexe -c -f test.cap -P <highlight><bold>2048</bold></highlight> </paragraph>
<paragraph id="P-0077" lvl="0"><number>&lsqb;0077&rsqb;</number> Thus nbexe calls the submitting means <highlight><bold>205</bold></highlight>, and the command switch -c specifies a particular procedure to be processed. The remainder of the command switches, -f test.cap -P <highlight><bold>2048</bold></highlight>, are parameters that need to be passed to a procedure corresponding to -c, and which further define the test and/or monitoring process requested. </paragraph>
<paragraph id="P-0078" lvl="0"><number>&lsqb;0078&rsqb;</number> As described above, the submitting means <highlight><bold>205</bold></highlight> parses this request to the scheduling means <highlight><bold>211</bold></highlight>, which passes it to the decoding means <highlight><bold>212</bold></highlight>. With reference to <cross-reference target="DRAWINGS">FIG. 3</cross-reference>, the decoding means <highlight><bold>212</bold></highlight> first performs the following steps: </paragraph>
<paragraph id="P-0079" lvl="2"><number>&lsqb;0079&rsqb;</number> S3.1 Decodes the request into an event identifier (corresponding to -c) and event parameters (corresponding to -f test.cap -P <highlight><bold>2048</bold></highlight> ), in accordance with a set of predetermined conditions, in order to determine which test or monitoring process has been requested; </paragraph>
<paragraph id="P-0080" lvl="2"><number>&lsqb;0080&rsqb;</number> S3.2 Analyses the event identifier in order to identify a corresponding set of one or more corresponding processable events; and </paragraph>
<paragraph id="P-0081" lvl="2"><number>&lsqb;0081&rsqb;</number> S3.3 Assigns processes and a process identifier to these events. </paragraph>
<paragraph id="P-0082" lvl="0"><number>&lsqb;0082&rsqb;</number> Considering the example given above, for an input of </paragraph>
<paragraph id="P-0083" lvl="1"><number>&lsqb;0083&rsqb;</number> nbexe -c -f test.cap -P <highlight><bold>2048</bold></highlight> </paragraph>
<paragraph id="P-0084" lvl="2"><number>&lsqb;0084&rsqb;</number> -c is decoded into event identifier CAPTURE_FTN, which is used to identify a process for capturing data packets; </paragraph>
<paragraph id="P-0085" lvl="2"><number>&lsqb;0085&rsqb;</number> -P is decoded into a command that represents &ldquo;capture data packets that are destined for port <highlight><bold>2048</bold></highlight> only&rdquo;; and </paragraph>
<paragraph id="P-0086" lvl="2"><number>&lsqb;0086&rsqb;</number> -f test.cap is decoded into a command that represents putting captured data into file called test.cap. </paragraph>
<paragraph id="P-0087" lvl="0"><number>&lsqb;0087&rsqb;</number> The event identifier, CAPTURE_FTN, thus identifies one or more corresponding processable events, which include assigning initialisation processes. For example: </paragraph>
<paragraph id="P-0088" lvl="1"><number>&lsqb;0088&rsqb;</number> case CAPTURE_FTN: &lcub;</paragraph>
<paragraph id="P-0089" lvl="2"><number>&lsqb;0089&rsqb;</number> ret&equals;addTask(controller, p, initCapturePackets, output&lsqb;i&rsqb;); processId&lsqb;i&rsqb;&equals;ret;/* Remember the process ID */ &rcub;; break; </paragraph>
<paragraph id="P-0090" lvl="7"><number>&lsqb;0090&rsqb;</number> Where initCapturePackets is the initialisation function relating to capturing packets, and the function addTask registers a start status, finish status and an output status of requests that are received and are to be scheduled for processing by the scheduling means <highlight><bold>211</bold></highlight>. Function addTask also returns a process identifier, ret, which is a numeric identifier that is unique to the request. The statuses are updated during the course of the processing of the request. The identifier is maintained internally by the core and provides a means of distinguishing between requests for protocol, interface assignment etc. </paragraph>
<paragraph id="P-0091" lvl="0"><number>&lsqb;0091&rsqb;</number> The decoding means <highlight><bold>212</bold></highlight> is then scheduled to process a start and a stop event (described below): the start event invokes whichever initialisation process was assigned at step S3.3 by the event identifier, which for the example above is initCapturePackets, and marks the task as initialised: </paragraph>
<paragraph id="P-0092" lvl="1"><number>&lsqb;0092&rsqb;</number> /* Call the intialisation function */ </paragraph>
<paragraph id="P-0093" lvl="2"><number>&lsqb;0093&rsqb;</number> ret&equals;(*(n-&gt;init))(&amp;n-&gt;t); </paragraph>
<paragraph id="P-0094" lvl="7"><number>&lsqb;0094&rsqb;</number> With reference to <cross-reference target="DRAWINGS">FIG. 4</cross-reference> of the accompanying drawings, a number of initialisation processes are effected at this stage: </paragraph>
<paragraph id="P-0095" lvl="2"><number>&lsqb;0095&rsqb;</number> S4.1 Populate operating parameters, which will be passed by the scheduling means <highlight><bold>211</bold></highlight> to the read/write means <highlight><bold>213</bold></highlight>, with values and conditions specific to the event identifier. Most of these operating parameters embed the event parameters that were received at the command line (for the example above: -f test.cap -P <highlight><bold>2048</bold></highlight> and the relevant protocol and interface information that corresponds to a request for capturing data). </paragraph>
<paragraph id="P-0096" lvl="2"><number>&lsqb;0096&rsqb;</number> S4.2 Add Interfaces and Protocols, which are specific to the event identifier, to an interface and a protocol list maintained by the core <highlight><bold>100</bold></highlight> so that data can be read from and/or written to one or more interfaces (when scheduled to do so). There is one interface and one protocol list for each of the event identifiers. The following code fragments show three sets of function calls for protocols corresponding to three different event identifiers:  
<table-cwu id="TABLE-US-00001">
<number>1</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="63PT" align="left"/>
<colspec colname="3" colwidth="119PT" align="left"/>
<thead>
<row>
<entry namest="1" nameend="3" align="center">TABLE 1</entry>
</row>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Switch</entry>
<entry>Event Identifier</entry>
<entry>Protocol function call</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>&minus;c</entry>
<entry>CAPTURE_FTN</entry>
<entry>RegisterProtocol(O, ETHERNET,</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>t&minus;&gt;p.interface, cpp&minus;&gt;buffer, &amp;eh)</entry>
</row>
<row>
<entry>&minus;p</entry>
<entry>PING_FTN</entry>
<entry>RegisterProtocol(O, ETHERNET,</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>p.interface, pp&minus;&gt;buffer,</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>(void*)&amp;eh)</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>RegisterProtocol(O, IPv4,</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>p.interface, pp&minus;&gt;buffer, (void *)&amp;ip)</entry>
</row>
<row>
<entry>&minus;a</entry>
<entry>PROBE_FTN</entry>
<entry>RegisterProtocol(O, ETHERNET,</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>pp&minus;&gt;interface, buffer, (void*)&amp;eh)</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>RegisterProtocol(O, IPv6, pp&minus;&gt;</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>interface, buffer, (void *)&amp;ip)</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0097" lvl="0"><number>&lsqb;0097&rsqb;</number> The function registerProtocol firstly adds an instance of the protocol to a list maintained by the core <highlight><bold>100</bold></highlight>, and secondly calls a protocol function that builds a packet for sending (build packet function set up by the registering means <highlight><bold>207</bold></highlight> as described above). The specific build function that is called, and thus the form of the packet, is determined by the second argument passed via the registerProtocol function: IPv4, IPv6, ETHERNET etc. Building a packet, for the above example of IPv6, creates an IPv6 Header by storing elements selected from the structure ip at a location given by buffer: </paragraph>
<paragraph id="P-0098" lvl="2"><number>&lsqb;0098&rsqb;</number> char *iph&equals;buffer; </paragraph>
<paragraph id="P-0099" lvl="2"><number>&lsqb;0099&rsqb;</number> struct ipv6_header *h&equals;(struct ipv6_header *)ip; </paragraph>
<paragraph id="P-0100" lvl="2"><number>&lsqb;0100&rsqb;</number> IPH_SET_VERSION(iph, 6); </paragraph>
<paragraph id="P-0101" lvl="2"><number>&lsqb;0101&rsqb;</number> IP6H_SET_CLASS(iph, h-&gt;class); </paragraph>
<paragraph id="P-0102" lvl="2"><number>&lsqb;0102&rsqb;</number> IP6H_SET_FLOWLBL(iph, h-&gt;flowLabel); </paragraph>
<paragraph id="P-0103" lvl="2"><number>&lsqb;0103&rsqb;</number> IP6H_LENGTH(iph)&equals;htons(h-&gt;payloadLength); </paragraph>
<paragraph id="P-0104" lvl="2"><number>&lsqb;0104&rsqb;</number> IP6H_NEXTH(iph)&equals;h-&gt;nextHeader; </paragraph>
<paragraph id="P-0105" lvl="2"><number>&lsqb;0105&rsqb;</number> etc. </paragraph>
<paragraph id="P-0106" lvl="7"><number>&lsqb;0106&rsqb;</number> Note that this process merely creates the structure for sending a packet. </paragraph>
<paragraph id="P-0107" lvl="2"><number>&lsqb;0107&rsqb;</number> S4.3 Assign processes for sending and receiving packets of data, and also for ending the transfer of data; these are event identifier specific. For example:  
<table-cwu id="TABLE-US-00002">
<number>2</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="105PT" align="left"/>
<colspec colname="2" colwidth="112PT" align="left"/>
<thead>
<row>
<entry namest="1" nameend="2" align="center">TABLE 2</entry>
</row>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Event identifier: PING_FTN</entry>
<entry>Event identifier: CAPTURE_FTN</entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>t&minus;&gt;end &equals; endPing;</entry>
<entry>t&minus;&gt;end &equals; endCapturePackets;</entry>
</row>
<row>
<entry>t&minus;&gt;receive &equals; receivePing;</entry>
<entry>t&minus;&gt;receive &equals; receiveCapturePackets;</entry>
</row>
<row>
<entry>e.g: endPing (struct task-</entry>
</row>
<row>
<entry>_scheduler *t)</entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0108" lvl="0"><number>&lsqb;0108&rsqb;</number> This assignment of functions allows the functions to be called later, in processing an event to fulfil a request. For example, when t-&gt;end is called by the read/write means <highlight><bold>213</bold></highlight>, in processing a PING_FTN request, this will cause endPing to run. The parameter passed to argument t in function endPing includes the operating parameters translated from the request. </paragraph>
<paragraph id="P-0109" lvl="0"><number>&lsqb;0109&rsqb;</number> The stop event (described below) is scheduled after the start event in order to terminate any residual events corresponding to previous requests (for example from previous instances of running the core <highlight><bold>100</bold></highlight>). </paragraph>
<paragraph id="P-0110" lvl="0"><number>&lsqb;0110&rsqb;</number> Once the start and stop events have been processed by the decoding means <highlight><bold>212</bold></highlight>, the scheduling means <highlight><bold>211</bold></highlight> schedules execution of the read/write means <highlight><bold>213</bold></highlight>. For each request, the read/write means <highlight><bold>213</bold></highlight> effects either of, or a combination of, a read event and a write event. </paragraph>
<paragraph id="P-0111" lvl="0"><number>&lsqb;0111&rsqb;</number> With reference to <cross-reference target="DRAWINGS">FIG. 5</cross-reference>, executing a read event includes the following steps: </paragraph>
<paragraph id="P-0112" lvl="2"><number>&lsqb;0112&rsqb;</number> S5.1 Call a receive function that corresponds to each of the protocols added to the protocol list. All of the protocol receive functions on the list are processed because the read event does not know which packets a process wants: </paragraph>
<paragraph id="P-0113" lvl="1"><number>&lsqb;0113&rsqb;</number> for(k&equals;0; k&lt;n-&gt;protocolStack&lsqb;i&rsqb; &lsqb;j&rsqb;.numberOfProtocols; k&plus;&plus;)&lcub;</paragraph>
<paragraph id="P-0114" lvl="2"><number>&lsqb;0114&rsqb;</number> /* If there is a receive function then call it */ </paragraph>
<paragraph id="P-0115" lvl="1"><number>&lsqb;0115&rsqb;</number> if(schedNBC&lsqb;n-&gt;protocolStack&lsqb;i&rsqb;&lsqb;j&rsqb;. protocols&lsqb;k&rsqb;&rsqb;.tsps.receivePacket&excl;&equals;NULL)&lcub;</paragraph>
<paragraph id="P-0116" lvl="2"><number>&lsqb;0116&rsqb;</number> /* The line below calls a receivePacket function, which was assigned to receiving functions corresponding to each of the protocols by the registering means <highlight><bold>207</bold></highlight>. The actual receivePacket that is called is determined by protocols&lsqb;k&rsqb; */ </paragraph>
<paragraph id="P-0117" lvl="2"><number>&lsqb;0117&rsqb;</number> ret&equals;(*(schedNBC&lsqb;n-&gt;protocolStack&lsqb;i&rsqb;&lsqb;j&rsqb;.protocols&lsqb;k&rsqb;&rsqb;.tsps.receivePacket))(n-&gt;protocolStack&lsqb;i&rsqb; &lsqb;j&rsqb;.protocolData&lsqb;k&rsqb;, &amp;rp); </paragraph>
<paragraph id="P-0118" lvl="2"><number>&lsqb;0118&rsqb;</number> /*This loop (loop on k) calls receive functions for all of the protocols that were registered on the list by registerprotocol for the current request*/ </paragraph>
<paragraph id="P-0119" lvl="2"><number>&lsqb;0119&rsqb;</number> /*the i counter relates to the interface, j relates to the packet to be read and k relates to the protocols registered on the list for the current request*/ </paragraph>
<paragraph id="P-0120" lvl="2"><number>&lsqb;0120&rsqb;</number> &rcub;</paragraph>
<paragraph id="P-0121" lvl="0"><number>&lsqb;0121&rsqb;</number> The function of receivePacket is to validate a packet when it is received. Thus if any of the protocols reject the packet then it is not passed for further processing; if all of the protocols on the list accept the packet then it is passed for an actual read. The order in which the protocols are activated for reading is determined by the protocol layer: thus network layer protocol reading is performed before internet layer reading, which is performed before transport layer reading. </paragraph>
<paragraph id="P-0122" lvl="2"><number>&lsqb;0122&rsqb;</number> S5.2 Process a read event that was pre-assigned by the relevant event identifier at step S4.3: </paragraph>
<paragraph id="P-0123" lvl="3"><number>&lsqb;0123&rsqb;</number> (*(n-&gt;t.receive))(&amp;(n-&gt;t), &amp;rp, j, rp.offset); </paragraph>
<paragraph id="P-0124" lvl="7"><number>&lsqb;0124&rsqb;</number> Re-calling the capture example above, where the event identifier was CAPTURE_FTN, t-&gt;receive was set equal to receiveCapturePackets. Thus calling t.receive invokes a process corresponding to the function receiveCapturePackets. </paragraph>
<paragraph id="P-0125" lvl="0"><number>&lsqb;0125&rsqb;</number> With reference to <cross-reference target="DRAWINGS">FIG. 6</cross-reference>, executing a write event includes the following steps: </paragraph>
<paragraph id="P-0126" lvl="2"><number>&lsqb;0126&rsqb;</number> S6.1 Check whether there are packets to be sent; if so, prepare data to be encapsulated within a packet for sending at a specific time, which in the following code fragment is controlled by variable microtime: </paragraph>
<paragraph id="P-0127" lvl="1"><number>&lsqb;0127&rsqb;</number> While (n &excl;&equals;NULL)&lcub;</paragraph>
<paragraph id="P-0128" lvl="1"><number>&lsqb;0128&rsqb;</number> If(n-&gt;t.nextSendMicrotime&lt;&equals;microtime) </paragraph>
<paragraph id="P-0129" lvl="2"><number>&lsqb;0129&rsqb;</number> (*(n-&gt;t.send))(&amp;n-&gt;t, microtime); </paragraph>
<paragraph id="P-0130" lvl="1"><number>&lsqb;0130&rsqb;</number> n&equals;n-&gt;next; </paragraph>
<paragraph id="P-0131" lvl="1"><number>&lsqb;0131&rsqb;</number> &rcub;</paragraph>
<paragraph id="P-0132" lvl="2"><number>&lsqb;0132&rsqb;</number> /* The condition of n &excl;&equals;NULL, where n identifies a request to be processed, forces the send routine to execute for all of the requests that have been registered at the time of calling the write process (processing of multiple requests is discussed below). </paragraph>
<paragraph id="P-0133" lvl="2"><number>&lsqb;0133&rsqb;</number> */ </paragraph>
<paragraph id="P-0134" lvl="7"><number>&lsqb;0134&rsqb;</number> Re-calling the capture example above, where the event identifier was CAPTURE_FTN, t-&gt;send was set equal to sendCapturePackets. Thus calling n-&gt;t.send invokes a process corresponding to the function sendCapturePackets for request n. </paragraph>
<paragraph id="P-0135" lvl="2"><number>&lsqb;0135&rsqb;</number> S6.2 Process the corresponding send functions for each of the protocols on the protocol list. This step is performed in accordance with the following time constraints: </paragraph>
<paragraph id="P-0136" lvl="1"><number>&lsqb;0136&rsqb;</number> if(schedInterfaceInfo&lsqb;i&rsqb;.taskSI.nextSendTime&lt;&equals;microtime&plus;(i * 2)), where nextSendTime is set up in the t.send call described above and microtime is an initialised time. </paragraph>
<paragraph id="P-0137" lvl="0"><number>&lsqb;0137&rsqb;</number> If the time constraint is satisfied, the following send routine is invoked: </paragraph>
<paragraph id="P-0138" lvl="1"><number>&lsqb;0138&rsqb;</number> for (k&equals;n-&gt;protocolStack&lsqb;i&rsqb; &lsqb;pq-&gt;stackId&rsqb;.numberOfProtocols; k &gt;0; k--) ret&equals;(*schedNBC&lsqb;pps-&gt;protocols&lsqb;k&minus;1&rsqb;&rsqb;.tsps.sendPacket)(pps-&gt;protocolData&lsqb;k&minus;1&rsqb;,pq-&gt;buffer, pps-&gt;offset&lsqb;k&minus;1&rsqb;); </paragraph>
<paragraph id="P-0139" lvl="2"><number>&lsqb;0139&rsqb;</number> /*the i counter relates to the interface, pq-&gt;stackId identifies the packet to be sent out and k relates to the protocols that are registered on the list for the current request*/ </paragraph>
<paragraph id="P-0140" lvl="7"><number>&lsqb;0140&rsqb;</number> This loop decrements through the protocols, to ensure that if more than one protocol is on the list for the current request, then the protocol sendPacket functions are activated in an order consistent with protocol requirements: for example, with reference to <cross-reference target="DRAWINGS">FIG. 6</cross-reference> </paragraph>
<paragraph id="P-0141" lvl="2"><number>&lsqb;0141&rsqb;</number> S6.2.1 The data from step S6.1 is divided into packets and combined with any transport layer packet (application ID, checksum, application source ID) that was built at step S4.2; </paragraph>
<paragraph id="P-0142" lvl="2"><number>&lsqb;0142&rsqb;</number> S6.2.2 The packet that was created at S6.2.1 (transport layer packet) is combined with any internet layer packet that was built at step S4.2 (header information and routing addresses); and </paragraph>
<paragraph id="P-0143" lvl="2"><number>&lsqb;0143&rsqb;</number> S6.2.3 The packet is sent via the network interface layer. </paragraph>
<paragraph id="P-0144" lvl="0"><number>&lsqb;0144&rsqb;</number> As is to be expected, this process is performed in reverse order to the process of reading in packets (S5.2). </paragraph>
<paragraph id="P-0145" lvl="0"><number>&lsqb;0145&rsqb;</number> For passive protocols such as UDP, the function activated by a call to schedNBC&lsqb;pps-&gt;protocols&lsqb;k&minus;1&rsqb;&rsqb;tsps.sendPacket at step S6.2.1 comprises binding the data from step S6.1 with the packet structure built at step S4.2, whereas for active protocols such as ARP, the corresponding send function invokes additional processes, such as broadcasting a request for a hardware address, when it is run. Further information can be found in &ldquo;Internetworking with TCP/IP&rdquo; Volume 1, Prentice Hall Ed., pp.73-81. </paragraph>
<paragraph id="P-0146" lvl="0"><number>&lsqb;0146&rsqb;</number> The above description relates to capturing and processing of a single request. However, the scheduling means <highlight><bold>211</bold></highlight> is operable to receive multiple requests, under the control of a timing loop: </paragraph>
<paragraph id="P-0147" lvl="1"><number>&lsqb;0147&rsqb;</number> if(microtime&minus;schedLastRunTime&gt;500000)&lcub;/*every 0.5 seconds*/ </paragraph>
<paragraph id="P-0148" lvl="2"><number>&lsqb;0148&rsqb;</number> schedLastRunTime&equals;microtime; /*re-set time used for comparison*/ acceptCLICommands( );/*effects receipt of new requests and assigns new event identifiers according to steps S3.1-S3.3*/ </paragraph>
<paragraph id="P-0149" lvl="1"><number>&lsqb;0149&rsqb;</number> if(schedNumberStart&gt;0) schedStart( ); /*effects start process described in steps S4.1-S4.3*/ </paragraph>
<paragraph id="P-0150" lvl="2"><number>&lsqb;0150&rsqb;</number> /* If there are some tasks running then see if they need to be stopped */ </paragraph>
<paragraph id="P-0151" lvl="1"><number>&lsqb;0151&rsqb;</number> if(schedNumberStop&gt;0) schedStop( );/*effects stop process*/ </paragraph>
<paragraph id="P-0152" lvl="1"><number>&lsqb;0152&rsqb;</number> &rcub;</paragraph>
<paragraph id="P-0153" lvl="0"><number>&lsqb;0153&rsqb;</number> The reading and writing of data, described above, is scheduled in response to any new requests received: </paragraph>
<paragraph id="P-0154" lvl="1"><number>&lsqb;0154&rsqb;</number> if(schedNumberOfWriteTasks&gt;0) </paragraph>
<paragraph id="P-0155" lvl="1"><number>&lsqb;0155&rsqb;</number> schedWrite(microtime);/*effects writing of data: steps S6.1 and S6.2*/ </paragraph>
<paragraph id="P-0156" lvl="1"><number>&lsqb;0156&rsqb;</number> if(schedNumberOfReadTasks&gt;0)&lcub;</paragraph>
<paragraph id="P-0157" lvl="2"><number>&lsqb;0157&rsqb;</number> gettimeofday(&amp;tv, NULL); </paragraph>
<paragraph id="P-0158" lvl="2"><number>&lsqb;0158&rsqb;</number> microtime&equals;MICRO0TIME(tv); </paragraph>
<paragraph id="P-0159" lvl="2"><number>&lsqb;0159&rsqb;</number> schedRead(microtime);/*effects reading of data: steps S5.1 and S5.2*/ </paragraph>
<paragraph id="P-0160" lvl="2"><number>&lsqb;0160&rsqb;</number> &rcub;</paragraph>
<paragraph id="P-0161" lvl="7"><number>&lsqb;0161&rsqb;</number> where schedNumberOfWriteTasks and schedNumberOfReadTasks are set up in the initialisation process effected by start event. These processes run in parallel with the timing loop such that if a new request is received, then as soon as either of the variables schedNumberOfWriteTasks or schedNumberOfReadTasks are set, the corresponding read and/or write means will be effected. The embodiment of the core can also effect reading and writing of packets from multiple requests during one read and/or write event. </paragraph>
<paragraph id="P-0162" lvl="0"><number>&lsqb;0162&rsqb;</number> In addition to removing a request, the stop event also enables the core <highlight><bold>100</bold></highlight> to divert its resources to post-processing events, if required. The requirement for post-processing of data is dependent on the request that is received by the scheduling means <highlight><bold>211</bold></highlight>, as this determines which function t.end is assigned to (S4.3). As can be seen from the code fragment above, the stop event is scheduled to run every 0.5 seconds, after checking for new requests and effecting the initialisation events via the start process. The stop event allows the core <highlight><bold>100</bold></highlight> to co-operatively multi-task between (a) post-processing of data and (b) receiving, reading and writing of data described above; thus the scheduling means <highlight><bold>211</bold></highlight> time-slices between the events to ensure that both (a) and (b) processes have a chance to run. If post-processing of the data is required, this is effected after the type (b) events have finished running; the stop event will firstly remove the relevant process from the scheduling means <highlight><bold>211</bold></highlight>, and then divert the resources for the relevant post-processing actions: </paragraph>
<paragraph id="P-0163" lvl="1"><number>&lsqb;0163&rsqb;</number> if(n-&gt;remove &amp;&amp; ((&excl; schedYieldInUse &verbar;&verbar; n-&gt;t.reentrant) &amp;&amp; &excl; n-&gt;inStop) )&lcub;</paragraph>
<paragraph id="P-0164" lvl="2"><number>&lsqb;0164&rsqb;</number> /* schedYieldInUse: This is to prevent multiple processes from yielding at the same time. A stop event will not occur if the yield function has been called, unless the process has indicated that it does not use it (t-&gt;reentrant is set). */ </paragraph>
<paragraph id="P-0165" lvl="2"><number>&lsqb;0165&rsqb;</number> /* Remove the task from the schedule */ </paragraph>
<paragraph id="P-0166" lvl="2"><number>&lsqb;0166&rsqb;</number> ret&equals;(*(n-&gt;t.end))(&amp;n-&gt;t); </paragraph>
<paragraph id="P-0167" lvl="2"><number>&lsqb;0167&rsqb;</number> /*this points to the t.end that was assigned in the initialisation routines&mdash;S4.3 and as shown above in Table 2 */ </paragraph>
<paragraph id="P-0168" lvl="0"><number>&lsqb;0168&rsqb;</number> Thus the function that has been assigned to n-&gt;t.end will determine whether there is any post-processing to be performed. If there is post-processing to be carried out, the scheduling means <highlight><bold>211</bold></highlight> splits the post-processing into a number of sub-processes, and schedules execution of type (b) events (receive and decode requests, execute start events, read events, write events) in between the sub-processes (co-operative multi-tasking). </paragraph>
<paragraph id="P-0169" lvl="0"><number>&lsqb;0169&rsqb;</number> When a request has been processed, the stop event frees up the interfaces, protocols and memory that were added to the list during the initialisation (S4.1, S4.2) for that request. </paragraph>
<paragraph id="P-0170" lvl="7"><number>&lsqb;0170&rsqb;</number> Implementation </paragraph>
<paragraph id="P-0171" lvl="0"><number>&lsqb;0171&rsqb;</number> The submitting means <highlight><bold>205</bold></highlight>, registering means <highlight><bold>207</bold></highlight>, communications means <highlight><bold>209</bold></highlight>, scheduling means <highlight><bold>211</bold></highlight>, decoding means <highlight><bold>212</bold></highlight> and read/write means <highlight><bold>213</bold></highlight> are written in the &lsquo;C&rsquo; programming language. </paragraph>
<paragraph id="P-0172" lvl="0"><number>&lsqb;0172&rsqb;</number> The embodiment of the present invention could be located on: </paragraph>
<paragraph id="P-0173" lvl="2"><number>&lsqb;0173&rsqb;</number> a server that receives input from other computers; </paragraph>
<paragraph id="P-0174" lvl="2"><number>&lsqb;0174&rsqb;</number> a computer (client) that is connected to a router; </paragraph>
<paragraph id="P-0175" lvl="2"><number>&lsqb;0175&rsqb;</number> a computer (client) that is connected to a server; </paragraph>
<paragraph id="P-0176" lvl="7"><number>&lsqb;0176&rsqb;</number> and could be run on any operating system. For illustrative purposes, the following assumes that it is running on the LINUX&trade; operating system: </paragraph>
<paragraph id="P-0177" lvl="0"><number>&lsqb;0177&rsqb;</number> To start the system at boot-up, the following script needs to be placed into directories /etc/rc.d/rc3.d and /etc/rc.d/rc5.d: </paragraph>
<paragraph id="P-0178" lvl="1"><number>&lsqb;0178&rsqb;</number> ./etc/rc.d/init.d/functions </paragraph>
<paragraph id="P-0179" lvl="1"><number>&lsqb;0179&rsqb;</number> ifconfig ethO up </paragraph>
<paragraph id="P-0180" lvl="1"><number>&lsqb;0180&rsqb;</number> &num; bring any other interfaces up here as well </paragraph>
<paragraph id="P-0181" lvl="1"><number>&lsqb;0181&rsqb;</number> daemon /home/napoleon/nbd </paragraph>
<paragraph id="P-0182" lvl="0"><number>&lsqb;0182&rsqb;</number> The submitting means <highlight><bold>205</bold></highlight> discussed earlier in the description may be run from either a command shell located on the same computer as the scheduling means <highlight><bold>211</bold></highlight>, or a GUI loaded on an SNMP (Simple Network Management Protocol) host or an HTTP (Hypertext Transfer Protocol) host. The GUI may be stored in a data store remote from the host machines or on the host machine itself. In these latter two cases, the requests may be communicated to the scheduling means <highlight><bold>211</bold></highlight> either by email or via the internet. </paragraph>
<paragraph id="P-0183" lvl="0"><number>&lsqb;0183&rsqb;</number> The following is a non-exhaustive list of protocols that may be registered by the registering means <highlight><bold>207</bold></highlight> for an internet protocol network: </paragraph>
<paragraph id="P-0184" lvl="2"><number>&lsqb;0184&rsqb;</number> Ethernet; </paragraph>
<paragraph id="P-0185" lvl="2"><number>&lsqb;0185&rsqb;</number> IPv4; </paragraph>
<paragraph id="P-0186" lvl="2"><number>&lsqb;0186&rsqb;</number> IPv6; </paragraph>
<paragraph id="P-0187" lvl="2"><number>&lsqb;0187&rsqb;</number> ARP; </paragraph>
<paragraph id="P-0188" lvl="2"><number>&lsqb;0188&rsqb;</number> IGMP; </paragraph>
<paragraph id="P-0189" lvl="2"><number>&lsqb;0189&rsqb;</number> UDP; </paragraph>
<paragraph id="P-0190" lvl="2"><number>&lsqb;0190&rsqb;</number> TCP; </paragraph>
<paragraph id="P-0191" lvl="2"><number>&lsqb;0191&rsqb;</number> RIP (Routing Information Protocol); </paragraph>
<paragraph id="P-0192" lvl="2"><number>&lsqb;0192&rsqb;</number> OSPF (Open Shortest Path First). </paragraph>
<paragraph id="P-0193" lvl="7"><number>&lsqb;0193&rsqb;</number> where the latter two protocols are routing protocols, and the others have been defined earlier in the description. In addition, if the scheduling means <highlight><bold>211</bold></highlight> is receiving requests and outputting data via SNMP, the protocol is registered by registering means <highlight><bold>207</bold></highlight>. </paragraph>
<paragraph id="P-0194" lvl="0"><number>&lsqb;0194&rsqb;</number> In the description relating to the core, the term request, data, and input are used interchangeably to describe requests that are input to the apparatus for assessing a network. </paragraph>
<paragraph id="P-0195" lvl="7"><number>&lsqb;0195&rsqb;</number> Emulator </paragraph>
<paragraph id="P-0196" lvl="0"><number>&lsqb;0196&rsqb;</number> Apparatus for emulating network characteristics may generally be referred to as an emulator <highlight><bold>701</bold></highlight>. As shown in <cross-reference target="DRAWINGS">FIG. 7</cross-reference><highlight><italic>a</italic></highlight>, the emulator <highlight><bold>701</bold></highlight> intercepts packets of data that are passed between a source machine <highlight><bold>201</bold></highlight> and a destination machine <highlight><bold>203</bold></highlight>, and applies a plurality of predetermined rules to the packet, which effectively changes the transmission characteristics of the network. </paragraph>
<paragraph id="P-0197" lvl="0"><number>&lsqb;0197&rsqb;</number> The aim of the emulator <highlight><bold>701</bold></highlight> is to simulate a variety of network conditions, for a variety of packets that embed a range of protocols, and over a range of types of networks. Thus the variation in packet type is partially a function of the application, for example ftp, telnet, and email, that sends the data across the network. Using means <highlight><bold>703</bold></highlight> to effect a change to the transmission characteristics of the network shown in <cross-reference target="DRAWINGS">FIG. 7</cross-reference><highlight><italic>b</italic></highlight>, the emulator <highlight><bold>701</bold></highlight> subjects these packets to drop, delay, jitter, etc., which allows the associated applications to review their methods for handling such network interruptions. This is extremely valuable, as network software is often tested using highly reliable, low-delay local area networks (LANs), which may not expose potential failures. Furthermore, with applications that use the UDP transport protocol, where the application takes full responsibility for handling problems of reliability, such as message loss, duplication, delay etc, it is often the case that the application does not include adequate mechanisms for dealing with all possible modes of packet-interference. </paragraph>
<paragraph id="P-0198" lvl="0"><number>&lsqb;0198&rsqb;</number> As the emulator <highlight><bold>701</bold></highlight> works on packets of data travelling across a network, it includes capturing means <highlight><bold>705</bold></highlight>, shown in <cross-reference target="DRAWINGS">FIG. 7</cross-reference><highlight><italic>b</italic></highlight>, for capturing packets, and sending means <highlight><bold>707</bold></highlight> for injecting packets into the network. The capturing means and sending means <highlight><bold>705</bold></highlight>, <highlight><bold>707</bold></highlight> may be provided by the read/write means <highlight><bold>213</bold></highlight> of the core <highlight><bold>100</bold></highlight>, or any equivalent means. </paragraph>
<paragraph id="P-0199" lvl="0"><number>&lsqb;0199&rsqb;</number> Thus the means <highlight><bold>703</bold></highlight> to effect a change to the transmission characteristics of the network operates on the packets once they have been captured by the capturing means <highlight><bold>705</bold></highlight>. The modified packet is then passed to the sending means <highlight><bold>707</bold></highlight> for injection back into the network (or not, depending upon predetermined rules). When the emulator <highlight><bold>701</bold></highlight> works in operative association with the core <highlight><bold>100</bold></highlight>, following steps are effected: </paragraph>
<paragraph id="P-0200" lvl="2"><number>&lsqb;0200&rsqb;</number> S8.1 submitting means <highlight><bold>205</bold></highlight> sends a request to the scheduling means <highlight><bold>211</bold></highlight>&mdash;e.g nbexe -n -b <highlight><bold>90</bold></highlight> -x <highlight><bold>10</bold></highlight>, where -n signifies a request for an emulating event. </paragraph>
<paragraph id="P-0201" lvl="2"><number>&lsqb;0201&rsqb;</number> S8.2 scheduling means <highlight><bold>211</bold></highlight> passes the request to decoding means <highlight><bold>212</bold></highlight>, which decodes the request into an event identifier EMULATOR_FTN and event parameters corresponding to -b <highlight><bold>90</bold></highlight> -x <highlight><bold>10</bold></highlight>; </paragraph>
<paragraph id="P-0202" lvl="2"><number>&lsqb;0202&rsqb;</number> S8.3 decoding means <highlight><bold>212</bold></highlight> calls the relevant function to register a process identifier for this request, and assigns the emulator initialisation function via function call </paragraph>
<paragraph id="P-0203" lvl="3"><number>&lsqb;0203&rsqb;</number> addTask(controller, p, initNetworkEmulator, output&lsqb;i&rsqb;); </paragraph>
<paragraph id="P-0204" lvl="3"><number>&lsqb;0204&rsqb;</number> processId&lsqb;i&rsqb;&equals;ret; </paragraph>
<paragraph id="P-0205" lvl="2"><number>&lsqb;0205&rsqb;</number> S8.4 decoding means <highlight><bold>212</bold></highlight> initiates a start event, which calls the function initNetworkEmulator. This function registers the protocols and interfaces needed for the emulating event, and these are added to the list for this request (identified as specific to the emulator by the process identifier): </paragraph>
<paragraph id="P-0206" lvl="3"><number>&lsqb;0206&rsqb;</number> registerProtocol(0, ETHERNET, i, buffer, &amp;eh) </paragraph>
<paragraph id="P-0207" lvl="3"><number>&lsqb;0207&rsqb;</number> registerInterface(0, 1, 1); </paragraph>
<paragraph id="P-0208" lvl="3"><number>&lsqb;0208&rsqb;</number> registerInterface(1, 1, 1); </paragraph>
<paragraph id="P-0209" lvl="7"><number>&lsqb;0209&rsqb;</number> The start event also assigns processes for receiving and sending of data and stopping processing the request: </paragraph>
<paragraph id="P-0210" lvl="2"><number>&lsqb;0210&rsqb;</number> t-&gt;send&equals;sendNetworkEmulator; </paragraph>
<paragraph id="P-0211" lvl="2"><number>&lsqb;0211&rsqb;</number> t-&gt;receive&equals;receiveNetworkEmulator; </paragraph>
<paragraph id="P-0212" lvl="2"><number>&lsqb;0212&rsqb;</number> t-&gt;end&equals;endNetworkEmulator; </paragraph>
<paragraph id="P-0213" lvl="2"><number>&lsqb;0213&rsqb;</number> S8.5 scheduling means <highlight><bold>211</bold></highlight> executes a read and write event. If the network emulating request is the sole request that the core has received at this point, there will not be any data for sending out, and the read/write means <highlight><bold>213</bold></highlight> will only effect a read event. As described in S5.1, the read event firstly processes a receivePacket function, which, as the protocol that was registered on the list for this request was ethernet only, will call function receiveENETPacket only. The read event then processes a t-&gt;receive function, which calls function receiveNetworkEmulator (described below, with reference to <cross-reference target="DRAWINGS">FIG. 9</cross-reference>). As the scheduling means <highlight><bold>211</bold></highlight> operates in a continuous loop (see above), the read/write means <highlight><bold>213</bold></highlight> is scheduled to execute another send event. If the read event has finished processing data according to the processes in function receiveNetworkEmulator, any data that has been prepared for sending into the network will be sent out by the send event, which is controlled by function sendNetworkEmulator. </paragraph>
<paragraph id="P-0214" lvl="2"><number>&lsqb;0214&rsqb;</number> S8.6 Once all of the read and write events have been processed, scheduling means <highlight><bold>211</bold></highlight> executes a stop event via the decoding means <highlight><bold>212</bold></highlight>, and, for a network emulating request, this calls function endNetworkEmulator. </paragraph>
<paragraph id="P-0215" lvl="0"><number>&lsqb;0215&rsqb;</number> The changes that may be effected to the packets at S8.5 include: </paragraph>
<paragraph id="P-0216" lvl="2"><number>&lsqb;0216&rsqb;</number> dropping packets; </paragraph>
<paragraph id="P-0217" lvl="2"><number>&lsqb;0217&rsqb;</number> delaying packets; </paragraph>
<paragraph id="P-0218" lvl="2"><number>&lsqb;0218&rsqb;</number> misordering packets; </paragraph>
<paragraph id="P-0219" lvl="2"><number>&lsqb;0219&rsqb;</number> applying jitter to packets; </paragraph>
<paragraph id="P-0220" lvl="2"><number>&lsqb;0220&rsqb;</number> limiting the bandwidth of the network; </paragraph>
<paragraph id="P-0221" lvl="2"><number>&lsqb;0221&rsqb;</number> queuing the packets; and </paragraph>
<paragraph id="P-0222" lvl="2"><number>&lsqb;0222&rsqb;</number> duplicating packets. </paragraph>
<paragraph id="P-0223" lvl="7"><number>&lsqb;0223&rsqb;</number> The processes that affect network traffic are largely random in nature; thus, in order to realistically simulate network conditions, the packets that are interfered with by the above means are selected randomly by the emulator <highlight><bold>701</bold></highlight>. This can be effected using a fixed pseudo-random number generator, which uses deterministic sources of &ldquo;pseudo-random&rdquo; numbers. These typically start with a &ldquo;seed&rdquo; quantity and use numeric or logical operations to produce a sequence of values. A typical pseudo-random number generation technique, known as a linear congruence pseudo-random number generator, is described in &ldquo;The Art of Computer Programming&rdquo;, Volume 2: Semi-Numerical Algorithms, Chapter 3: Random Numbers; Addison Wesley Publishing Company, Second Edition 1982, Donald E. Knuth. Other means of selecting packets at random include associating each packet with a number that has been randomly selected from a database populated with numbers, or retrieving numbers that have been generated by a random process, such as a Markov process. </paragraph>
<paragraph id="P-0224" lvl="0"><number>&lsqb;0224&rsqb;</number> In all of these cases, the numbers that are generated at random are compared against one or more predetermined thresholds according to predetermined rules, and the treatment of the packet is dependent on the outcome of this comparison. The predetermined thresholds are user-configurable, and may be defined using the submitting means <highlight><bold>205</bold></highlight> of the core <highlight><bold>100</bold></highlight>, or any suitable alternative. </paragraph>
<paragraph id="P-0225" lvl="7"><number>&lsqb;0225&rsqb;</number> Drop, Delay, Jitter and Queuing of Packets: </paragraph>
<paragraph id="P-0226" lvl="0"><number>&lsqb;0226&rsqb;</number> When the thresholds are entered via submitting means <highlight><bold>205</bold></highlight>, as described above with reference to <cross-reference target="DRAWINGS">FIG. 8</cross-reference>, typical thresholds may be: nbexe -n -b <highlight><bold>90</bold></highlight> -x <highlight><bold>10</bold></highlight> -w <highlight><bold>5</bold></highlight> -e <highlight><bold>10</bold></highlight> -o <highlight><bold>1</bold></highlight> -k<highlight><bold>4</bold></highlight> </paragraph>
<paragraph id="P-0227" lvl="7"><number>&lsqb;0227&rsqb;</number> which specifies &ldquo;allow 10% of packets through without interference; drop 10% of all packets; delay the remainder by between 5 and 10 ms; drop/delay between 1 and 4 packets at one time&rdquo;</paragraph>
<paragraph id="P-0228" lvl="0"><number>&lsqb;0228&rsqb;</number> Processing of this request by the emulator <highlight><bold>701</bold></highlight> is illustrated with reference to <cross-reference target="DRAWINGS">FIG. 9</cross-reference>: </paragraph>
<paragraph id="P-0229" lvl="2"><number>&lsqb;0229&rsqb;</number> S9.1 Capture one or more packets (via receiveNetworkEmulator (S8.5) when the emulator <highlight><bold>701</bold></highlight> is in operative association with the core <highlight><bold>100</bold></highlight>); </paragraph>
<paragraph id="P-0230" lvl="2"><number>&lsqb;0230&rsqb;</number> S9.2 Generate a first random number and compare it with interference threshold (b). If the first random number is outside of the threshold, let it go without interference, else pass onto S9.3 </paragraph>
<paragraph id="P-0231" lvl="2"><number>&lsqb;0231&rsqb;</number> S9.3 Generate a second random number and compare it with the drop threshold (x); if second random number is outside of the threshold it must be for delaying&mdash;pass to S9.4, else is for dropping&mdash;just drop </paragraph>
<paragraph id="P-0232" lvl="2"><number>&lsqb;0232&rsqb;</number> S9.4 Generate a third random number, which is used in conjunction with a predetermined delay profile to determine the delay to be applied. The delay profile can either be read from a file, if the file name is specified at the command line. Alternatively, if a delay profile is not specified (i.e. no file name is given), then it is assumed that each millisecond in the delay range has equal weighting. If a profile is specified, then the third random number is used to extrapolate a delay time within the delay period: </paragraph>
<paragraph id="P-0233" lvl="2"><number>&lsqb;0233&rsqb;</number> /* Generate a delay value based on where the delay occurs within the minimum and maximum delays that were specified. If we have a profile then use it; otherwise just calculate where the point is as a fractional quantity */ </paragraph>
<paragraph id="P-0234" lvl="3"><number>&lsqb;0234&rsqb;</number> if(DELAYPROF_SET(t-&gt;p) )&rcub;</paragraph>
<paragraph id="P-0235" lvl="2"><number>&lsqb;0235&rsqb;</number> /* where np-&gt;r is the third random number; this line identifies the nearest point to the delay required*/ </paragraph>
<paragraph id="P-0236" lvl="3"><number>&lsqb;0236&rsqb;</number> num&equals;np-&gt;delayTime&lsqb;(int)(np-&gt;r * 100.0)&rsqb;; </paragraph>
<paragraph id="P-0237" lvl="2"><number>&lsqb;0237&rsqb;</number> /*this identifies the exact delay time*/ </paragraph>
<paragraph id="P-0238" lvl="3"><number>&lsqb;0238&rsqb;</number> while(np-&gt;r&gt;np-&gt;delayProfile&lsqb;num&rsqb;) </paragraph>
<paragraph id="P-0239" lvl="3"><number>&lsqb;0239&rsqb;</number> num&plus;&plus;; </paragraph>
<paragraph id="P-0240" lvl="2"><number>&lsqb;0240&rsqb;</number> /*add the fraction to the minimum*/ </paragraph>
<paragraph id="P-0241" lvl="3"><number>&lsqb;0241&rsqb;</number> np-&gt;delay&equals;num&plus;t-&gt;p.min_delay; </paragraph>
<paragraph id="P-0242" lvl="3"><number>&lsqb;0242&rsqb;</number> &rcub; else &lcub;</paragraph>
<paragraph id="P-0243" lvl="3"><number>&lsqb;0243&rsqb;</number> np-&gt;delay&equals;(int)((((double)(t-&gt;p.max_delay - t-&gt;p.min_delay)/(double)100)* np-&gt;r)&plus;(double)t-&gt;p.min_delay); </paragraph>
<paragraph id="P-0244" lvl="3"><number>&lsqb;0244&rsqb;</number> &rcub;</paragraph>
<paragraph id="P-0245" lvl="2"><number>&lsqb;0245&rsqb;</number> S9.5 Assign a queuing location for the packet(s) in a running cycle, according to the delay time calculated at S9.4. </paragraph>
<paragraph id="P-0246" lvl="0"><number>&lsqb;0246&rsqb;</number> The queuing location is calculated from the current time in the cycle (t<highlight><subscript>posincycle</subscript></highlight>): if a delay time of 14 milliseconds is generated at S9.4, then this means a delay of 14 ms from now, wherever now may be in the current position of the running cycle. If, for example, the running cycle is currently in 5 ms, and the maximum delay for the present cycle is 12 ms (t<highlight><subscript>cycle,max</subscript></highlight>), the delay of 14 ms (t<highlight><subscript>delay</subscript></highlight>)from 5 ms is assigned a queuing position by calculating:</paragraph>
<paragraph lvl="0"><in-line-formula>t<highlight><subscript>delay</subscript></highlight>/t<highlight><subscript>cycle,max</subscript></highlight>: number of revolutions of cycle&plus;t<highlight><subscript>delay</subscript></highlight>&minus;(t<highlight><subscript>cycle,max</subscript></highlight>&minus;t<highlight><subscript>po sin cycle</subscript></highlight>) for position in cycle.</in-line-formula></paragraph>
<paragraph id="P-0247" lvl="7"><number>&lsqb;0247&rsqb;</number> Thus for the example given: </paragraph>
<paragraph id="P-0248" lvl="1"><number>&lsqb;0248&rsqb;</number> 14/13&equals;one revolution of the cycle&plus;14 &minus;(13&minus;5) such that the packet would be queued to be sent at 6 ms in the following revolution of the cycle. </paragraph>
<paragraph id="P-0249" lvl="2"><number>&lsqb;0249&rsqb;</number> S9.6 Send the packet when the queued time is the current time (controlled via sendNetworkEmulator when the emulator <highlight><bold>701</bold></highlight> is in operative association with the core <highlight><bold>100</bold></highlight>). </paragraph>
<paragraph id="P-0250" lvl="0"><number>&lsqb;0250&rsqb;</number> Jitter, defined as a variation in delay between delayed packets, is introduced by applying different delays to packets. As the assignment of a delay is a function of a random number for each packet, one packet is likely to have a different delay compared to others that are being delayed. Therefore jitter is introduced implicitly to the system by the method described above. </paragraph>
<paragraph id="P-0251" lvl="7"><number>&lsqb;0251&rsqb;</number> Duplicating Packets </paragraph>
<paragraph id="P-0252" lvl="0"><number>&lsqb;0252&rsqb;</number> A packet can be duplicated by: </paragraph>
<paragraph id="P-0253" lvl="2"><number>&lsqb;0253&rsqb;</number> capturing a packet; </paragraph>
<paragraph id="P-0254" lvl="2"><number>&lsqb;0254&rsqb;</number> analysing its content; and </paragraph>
<paragraph id="P-0255" lvl="2"><number>&lsqb;0255&rsqb;</number> generating an identical packet to the captured packet. </paragraph>
<paragraph id="P-0256" lvl="7"><number>&lsqb;0256&rsqb;</number> A request for duplicating a packet can be made via the submitting means <highlight><bold>205</bold></highlight>, by specifying alternative event parameters to those included in the request described above. </paragraph>
<paragraph id="P-0257" lvl="1"><number>&lsqb;0257&rsqb;</number> e.g. nbexe -n -f test.cap -t <highlight><bold>60</bold></highlight> -Z, </paragraph>
<paragraph id="P-0258" lvl="7"><number>&lsqb;0258&rsqb;</number> which specifies &ldquo;capture packets for 1 minute, write the characteristics to a file, and reproduce the characteristics by generating packets identical to those captured&rdquo;. Generating a second (identical) packet involves writing a packet, which may be performed using the read/write means <highlight><bold>213</bold></highlight> of the core <highlight><bold>100</bold></highlight> described above (or other suitable means). The second packet may additionally be delayed relative to the first, by specifying a delay profile that controls the timing of writing of packets. </paragraph>
<paragraph id="P-0259" lvl="7"><number>&lsqb;0259&rsqb;</number> Limiting the Bandwidth </paragraph>
<paragraph id="P-0260" lvl="0"><number>&lsqb;0260&rsqb;</number> Bandwidth may be defined as the network&apos;s volume capacity: </paragraph>
<paragraph id="P-0261" lvl="1"><number>&lsqb;0261&rsqb;</number> Number of packets&times;size of packets&times;8. </paragraph>
<paragraph id="P-0262" lvl="7"><number>&lsqb;0262&rsqb;</number> Thus changing either the number of packets or the size of packets will change the bandwidth. The number of packets can be controlled by generating additional packets, or by permanently capturing packets, and the size of packets can be controlled by specifying the packet size when generating a packet. These parameters could either be entered at the command line for receipt by the submitting means <highlight><bold>205</bold></highlight>, when the emulator <highlight><bold>701</bold></highlight> operates in conjunction with the core <highlight><bold>100</bold></highlight>, or could be read in from a file. </paragraph>
<paragraph id="P-0263" lvl="0"><number>&lsqb;0263&rsqb;</number> The bandwidth could also be controlled between certain source and destination addresses, by specifying desired MAC (physical address) and IP source and destination addresses at the command line, or in a file. Thus as an extension to <cross-reference target="DRAWINGS">FIG. 7</cross-reference><highlight><italic>a</italic></highlight>, the emulator <highlight><bold>701</bold></highlight> could be positioned between two or more machines, and control the flow of traffic therebetween. </paragraph>
<paragraph id="P-0264" lvl="0"><number>&lsqb;0264&rsqb;</number> Once the emulator <highlight><bold>701</bold></highlight> has finished processing packets, it outputs statistics summarising how many packets were delayed, and the delay times, the number of packets received on each interface, and the number of packets that were dropped on each interface. </paragraph>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. Apparatus for testing and/or monitoring the transmission of data packets by communications equipment, the apparatus comprising: 
<claim-text>(i) registering means for registering one or more transmission protocols to enable the apparatus to communicate according to any registered protocol; </claim-text>
<claim-text>(ii) submitting means for submitting a request, the request specifying at least one testing and/or monitoring operation; </claim-text>
<claim-text>(iii) decoding means for decoding a received request into one or more processable events in accordance with one or more predetermined rules; </claim-text>
<claim-text>(iv) read/write means for controlling the writing of data packets to, and the reading of data packets from, the communications equipment; and </claim-text>
<claim-text>(v) scheduling means for scheduling decoding of received requests and execution of the one or more processable events in accordance with the read/write means, </claim-text>
<claim-text>such that, when a request is received from the submitting means, the scheduling means schedules: </claim-text>
<claim-text>a) decoding of the request into one or more processable events by the decoding means; </claim-text>
<claim-text>b) initialisation of the processable events by the decoding means; and </claim-text>
<claim-text>c) reading and writing of data packets from and to the communications equipment by the read/write means in accordance with the processable events. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. Apparatus according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the processable events include post-processing of data that has been read from the communications equipment. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. Apparatus according to <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, further including means to allow multiple tasks to run concurrently, such that when there is post-processing to be carried out, the post-processing of data and real-time testing and/or monitoring each take turns to use the resources of the processing means. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. Apparatus according to any one of <dependent-claim-reference depends_on="CLM-00001">claims 1</dependent-claim-reference> to <dependent-claim-reference depends_on="CLM-00003">3</dependent-claim-reference>, wherein the apparatus is configurable to process any one of the following requests: 
<claim-text>a) Capture packets; </claim-text>
<claim-text>b) Replay packets; </claim-text>
<claim-text>c) View packets; </claim-text>
<claim-text>d) Generate packets; </claim-text>
<claim-text>e) Generate multiple streams; </claim-text>
<claim-text>f) Emulate a communications equipment; </claim-text>
<claim-text>g) Generate a packet probe; </claim-text>
<claim-text>h) Change header fields; </claim-text>
<claim-text>i) Bridge; </claim-text>
<claim-text>j) Join multicast groups; and </claim-text>
<claim-text>k) Leave multicast groups. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. Apparatus according to any one of the preceding claims, wherein the communications equipment is either one of an internet protocol network or an asynchronous transfer mode network.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>2</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030004684A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030004684A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030004684A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030004684A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030004684A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030004684A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030004684A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030004684A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
