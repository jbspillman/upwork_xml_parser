<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030004938A1-20030102-D00000.TIF SYSTEM "US20030004938A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030004938A1-20030102-D00001.TIF SYSTEM "US20030004938A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030004938A1-20030102-D00002.TIF SYSTEM "US20030004938A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030004938A1-20030102-D00003.TIF SYSTEM "US20030004938A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030004938A1-20030102-D00004.TIF SYSTEM "US20030004938A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030004938A1-20030102-D00005.TIF SYSTEM "US20030004938A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030004938A1-20030102-D00006.TIF SYSTEM "US20030004938A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030004938A1-20030102-D00007.TIF SYSTEM "US20030004938A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030004938A1-20030102-D00008.TIF SYSTEM "US20030004938A1-20030102-D00008.TIF" NDATA TIF>
<!ENTITY US20030004938A1-20030102-D00009.TIF SYSTEM "US20030004938A1-20030102-D00009.TIF" NDATA TIF>
<!ENTITY US20030004938A1-20030102-D00010.TIF SYSTEM "US20030004938A1-20030102-D00010.TIF" NDATA TIF>
<!ENTITY US20030004938A1-20030102-D00011.TIF SYSTEM "US20030004938A1-20030102-D00011.TIF" NDATA TIF>
<!ENTITY US20030004938A1-20030102-D00012.TIF SYSTEM "US20030004938A1-20030102-D00012.TIF" NDATA TIF>
<!ENTITY US20030004938A1-20030102-D00013.TIF SYSTEM "US20030004938A1-20030102-D00013.TIF" NDATA TIF>
<!ENTITY US20030004938A1-20030102-D00014.TIF SYSTEM "US20030004938A1-20030102-D00014.TIF" NDATA TIF>
<!ENTITY US20030004938A1-20030102-D00015.TIF SYSTEM "US20030004938A1-20030102-D00015.TIF" NDATA TIF>
<!ENTITY US20030004938A1-20030102-D00016.TIF SYSTEM "US20030004938A1-20030102-D00016.TIF" NDATA TIF>
<!ENTITY US20030004938A1-20030102-D00017.TIF SYSTEM "US20030004938A1-20030102-D00017.TIF" NDATA TIF>
<!ENTITY US20030004938A1-20030102-D00018.TIF SYSTEM "US20030004938A1-20030102-D00018.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030004938</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10139544</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20020507</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F017/30</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>707</class>
<subclass>003000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Method of storing and retrieving multi-dimensional data using the hilbert curve</title-of-invention>
</technical-information>
<continuity-data>
<non-provisional-of-provisional>
<document-id>
<doc-number>60290779</doc-number>
<document-date>20010515</document-date>
<country-code>US</country-code>
</document-id>
</non-provisional-of-provisional>
</continuity-data>
<inventors>
<first-named-inventor>
<name>
<given-name>Jonathan</given-name>
<middle-name>Keir</middle-name>
<family-name>Lawder</family-name>
</name>
<residence>
<residence-non-us>
<city>London</city>
<country-code>GB</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
</inventors>
<correspondence-address>
<name-1>JONATHAN KEIR LAWDER</name-1>
<name-2>9 TRURO ROAD</name-2>
<address>
<address-1>WALTHAMSTOW</address-1>
<city>LONDON</city>
<postalcode>E177BY</postalcode>
<country>
<country-code>GB</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">An improved method of partitioning and indexing multi-dimensional data that maps the data to one-dimensional values according to the sequence in which an approximation of a Hilbert space-filling curve passes through all of the points corresponding to potential multi-dimensional data in a data space. Data is partitioned into pages, each corresponding to a length of Hilbert curve. A page identifier is the sequence of the first point on its corresponding Hilbert curve section. The mapping orders data and also orders the data pages that contain data within a database. </paragraph>
<paragraph id="A-0002" lvl="0">Mapping multi-dimensional data to one-dimensional values enables the data to be indexed using any one-dimensional index structure. </paragraph>
<paragraph id="A-0003" lvl="0">The practical application of the indexing method is made viable and useful by the provision of a querying algorithm enabling data to be selectively retrieved in response to queries wherein all or some of the data that lies within a rectangular space within multi-dimensional space is required to be retrieved. </paragraph>
<paragraph id="A-0004" lvl="0">The querying algorithm identifies pages whose corresponding curve sections intersect with a query region. The first intersecting page is found by calculating the lowest one-dimensional value corresponding to a possible multi-dimensional data value or point within the query region, and looking up in the index to find which page may contain this point. The next intersecting page, if it exists, is found by calculating the lowest one-dimensional value equal to or greater than the identifier of the next page to the one just identified. This new lowest one-dimensional, if found, is used to look up in the index and find the next page intersecting with the query region. Subsequent pages to be found, if any, are determined in a similar manner until no more are found. Pages found to intersect the query region can be searched for data lying within the query region. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> The present invention relates to an efficient method of partitioning and indexing multi-dimensional data together with a conceptually simple and computationally efficient method of selectively retrieving subsets of the data, where subsets are defined as the data lying within rectangular regions within multi-dimensional space. </paragraph>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> A file or database of multi-dimensional data contains representations of logical entities, each of which is described by an ordered set of attributes, or &lsquo;dimensions&rsquo; or coordinates. Moreover, these entities need to be organized and stored in some way so that sub-sets can be selectively and &lsquo;efficiently&rsquo; retrieved according to values or ranges of values in one or more of any of their attributes. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> The most commonly applied solution at present is the &lsquo;relational database&rsquo; model, originating from the late 1960s, although this is not specifically a multi-dimensional method. The relational method usually orders data according to values in a set of one or more attributes whose values are placed in a &lsquo;primary index&rsquo;. This facilitates easy access to subsets of data whose primary key values lie within a given range of values. In order to facilitate retrieval of a subset of data whose values in a non primary key subset of one or more attributes lie within a given range of values, secondary indexes are commonly used on one or more subsets of non primary key attributes. This gives rise to a number of problems. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> Firstly, there is a practicable limit to the number of secondary indexes that can be supported. Potentially 2<highlight><superscript>n</superscript></highlight>-2 indexes can be provided for n-dimensional data but to provide all of these requires an excessive amount of storage capacity and an excessive maintenance overhead when data is updated. In practice only a limited amount of secondary indexes is only ever provided. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> Secondly, if a desired secondary index does not exist, some queries require the costly operation of intersecting two or more indexes or intersecting the results of two or more subsidiary queries. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> Thirdly, retrieval of data using any secondary index can never be as efficient as using a primary index, since the underlying data is not actually ordered by the secondary index, thus more pages of data in a database need to be retrieved and searched. In consequence, some forms of query are more efficiently executed than others. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> The relational implementations may have hitherto adapted to changing requirements for handling data but this does not ensure that they will be able to provide universal solutions in the future. Data generation and collection continues to grow at an ever accelerating rate along with aspirations for more sophisticated analysis and processing techniques and capabilities. Data that is being generated and collected is also becoming increasingly high-dimensional in its nature. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> A considerable volume of research has been carried out in the area of indexing multi-dimensional data over many years. Nevertheless, no paradigm appears to have emerged to compare with the pre-eminence of the B-Tree and its variants in the indexing of one-dimensional data. Indeed, the volume of previous and continuing research provokes the conclusion that the development of an optimum strategy for indexing multi-dimensional data very much remains a problem unsolved. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> A design of a &lsquo;true&rsquo; multi-dimensional database organization method attempts to solve the conflicting problems of how to store data compactly while enabling it to be selectively retrieved, or &lsquo;queried&rsquo;, flexibly and efficiently. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> Most file organization methods partition data by dividing the space in which it is embedded into rectangles, or their equivalent in higher dimensions, and an index entry is created for each rectangle. When only a few rectangles are defined the index can be accommodated in memory and serially searched as updates and queries are performed. Once the number of such rectangles exceeds some threshold, they must be partitioned, initially, into 2 sub-sets, each of which is most commonly regarded as a node in a tree index structure. A problem arises, often immediately, in that rectangles enclosing a pair of sub-sets of smaller rectangles may overlap. Thus where data insertion is required, for example, it may be necessary to search more than one path in an index tree to locate the page on which to place the data. Avoiding or accommodating this has been the focus of much of the research into organizing multi-dimensional data. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> The Grid File, described by J&uuml;rg Nievergelt, Hans Hinterberger and Kenneth C. Sevcik in &ldquo;The grid file: An adaptable symmetric multikey file structure&rdquo;, ACM Transactions on Database Systems, 9(1):38-71, 1984, is characterized by an exponential directory growth rate, a need for periodic significant directory reorganization and the requirement for directory lists to be intersected in the execution of queries. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> The R-Tree index, described by Antonin Guttman in &ldquo;R-Trees: A dynamic index structure for spatial searching&rdquo;, SIGMOD&apos;84: Proceedings of the Annual Meeting, volume 14(2) of Sigmod Record, pages 47-57, ACM, 1984, is balanced and simple in comparison with many other methods and not subject to the same degree of reorganization on insertion and deletion of data. However, these benefits are gained at the expense of tolerating overlapping rectangles which can significantly degrade query performance. The R-Tree was designed for indexing multi-dimensional spatial data rather than point data. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> The BANG File, described by M. Freeston in &ldquo;The BANG File: A new kind of grid file&rdquo; in Proceedings of the Association for Computing Machinery Special Interest Group on Management of Data 1987 Annual Conference, San Francisco, May 27-29, 1987, pages 260-269, tolerates overlapping rectangles but in a more controlled manner than in the R-Tree. It requires a complex, although balanced, index structure. This design has been the subject of a number of papers although none addresses algorithms for executing queries. I do not believe that this is because they are dealt with trivially. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> The SS-Tree, described by David A. White and Ramesh Jain in &ldquo;Similarity indexing with the SS-Tree&rdquo; in Proceedings of the Twelfth International Conference on Data Engineering, February 26-Mar. 1, 1996, New Orleans, pages 516-523, IEEE Computer Society, 1996, is a &lsquo;similarity&rsquo; indexing method oriented to the storage of multi-dimensional data in a manner which supports &lsquo;similarity queries&rsquo;. Such queries may be of the forms, &ldquo;find objects similar to a reference&rdquo; and &ldquo;find pairs of objects which are similar&rdquo;, in addition to conventional query forms. Data is transformed into &lsquo;feature vectors&rsquo;, which take account of the varying significances of values in different dimensions. A significant disadvantage, however is that the input of a domain expert is required for this purpose. Space containing feature vectors is then partitioned into spheres which theoretically contain the k-nearest neighbours of their centre points. I say &lsquo;theoretically&rsquo; since, in practice, there is a problem in that spheres may overlap in the way that the rectangles of the R-Tree do. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> The SR-Tree, described by Norio Katayama and Shin&apos;ichi Satoh in &ldquo;The SR-Tree: An Index Structure for High-Dimensional Nearest Neighbor Queries&rdquo; in SIGMOD 1997, Proceedings ACM SIGMOD International Conference on Management of Data, May 13-15, 1997, Tucson, Ariz., USA, ACM Press, 1997, pages 369-380, is similar to the SS-Tree, with its attendant problems, except that feature space is partitioned into regions defined by the intersection of spheres and rectangles (where spheres are not wholly contained within the rectangles). The benefit of this approach is that partitions overlap to a lesser extent than in the SS-Tree. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> The X-Tree, described by Stefan Berchtold, Daniel A. Keim and Hans-Peter Kriegel in &ldquo;The X-Tree An Index Structure for High-Dimensional Data&rdquo;, VLDB&apos;96, Proceedings of 22th International Conference on Very Large Data Bases, Sep. 3-6, 1996, Mumbai (Bombay), India, 1996, pages 28-39, addresses the problem of overlapping regions manifest in the R-Tree. This is achieved at the cost of allowing nodes in a tree to be of variable rather than fixed size. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> If the rectangles in an overfull node cannot be partitioned into 2 roughly equal sized sub-sets whose minimum bounding boxes overlap within the limits defined in some threshold then an &lsquo;overlap-free&rsquo; split is sought. This entails consulting a data structure which records the history of previous splits. At least one overlap-free split can always be found for a node but if it results in one of the new nodes being populated with fewer rectangles than defined in some threshold, then the original node is not split but allowed to become enlarged instead. The X-Tree is thus a hybrid between a linear array index and an R-Tree index. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> Whereas spatial objects may overlap, this is clearly not the case with point data. It is debatable whether data organization methods which permit overlapping regions in the partitioning of point data do so because they are specializations of methods primarily designed for spatial data or because there is some inherent advantage in tolerating overlap. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> The Pyramid-Technique, described by Stefan Berchtold, Christian B&ouml;hm and Hans-Peter Kriegel in &ldquo;The Pyramid-Tree: Breaking the Curse of Dimensionality&rdquo;, SIGMOD 1998, Proceedings ACM SIGMOD International Conference on Management of Data, Jun. 2-4, 1998, Seattle, Wash., USA, ACM Press, 1998, pages 142 153, partitions the data space in a 2-stage process. In the first stage, it is divided into pyramids all of whose apexes lie at the centre of the space. In the second stage, each pyramid is divided into slices, the bases of which are all hyper-planes parallel to the base of the pyramid. Each slice of a pyramid corresponds to a page of the data file. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> Multi-dimensional points are transformed into one-dimensional values by a mapping which is not bijective, thus more than one point may map to the same value, which necessitates an overhead of the storage of both the coordinates of points and their one-dimensional values. A one-dimensional value designates which pyramid a point lies in and its height above its base. The paper describes a query processing algorithm which the authors acknowledge is a &ldquo;complex operation&rdquo;. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> The technique can be adapted to skewed data distributions by moving the apex of all of the pyramids into the centre of a data cluster, creating asymmetrical pyramids. In practice data sets may contain more than one cluster and the locations of clusters may be dynamic. A dynamic pyramid apex location does not, however, appear to be practicable. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> The manner in which pyramids are divided into slices appears to suggest that partitioning may degrade locally such that all points on a page share similar values in one dimension but potentially very diverse values in all others. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> The use of the Hilbert Curve, named after David Hilbert, the German mathematician, in the indexing of multi-dimensional data has been suggested by Christos Faloutsos and Yi Rong in &ldquo;DOT: A Spatial Access Method Using Fractals&rdquo;, Proceedings of the Seventh International Conference on Data Engineering, Apr. 8-12, 1991, Kobe, Japan, IEEE Computer Society, 1991, pages 152-159, but no application other than that of the present inventor has been developed and, most importantly, no querying algorithm has hitherto been invented. Without a querying algorithm, enabling data to be selectively retrieved without searching the entire database, the application of the Hilbert Curve in the indexing of multi-dimensional data is of little value or viability. </paragraph>
</section>
<section>
<heading lvl="1">BRIEF SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> The present invention is a method of organising multi-dimensional data such that it can be easily partitioned into pages of data in a data store that can be easily indexed, together with a method of querying the data in the data store in a flexible and efficient manner. The present invention adapts well to varying numbers of dimensions, varying quantities of multi-dimensional data and to databases whose contents vary over time through insertion of new data and deletion of existing data. The present invention is based of the work contained in the PhD thesis of the inventor: &ldquo;The application of space-filling curves to the storage and retrieval of multi-dimensional data&rdquo; by J. K. Lawder that was awarded by the University of London on Aug. 31, 2000. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> Multi-dimensional data objects are mapped to one-dimensional values using a Hilbert Curve which passes through the points in a particular sequence. Thus a one-dimensional value corresponding to a point is the sequence of the point along the curve. The mapping induces a linear ordering of points in multi-dimensional space and so also orders the data objects. The data objects are then partitioned into ordered subsets corresponding to pages of storage in a data store. Each page, or partition, corresponds to a length of the Hilbert Curve. All of the points on one length of Hilbert Curve (whether they correspond to actual data objects or not) map to lower one-dimensional values than all of the points on the next length of curve, corresponding to the next partition, thus the partitions are ordered. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> The partitions are then indexed using a simple one-dimensional index method, such as the B-Tree, by placing a reference to each partition in the index together with the location of the partition within the data store. A reference to a partition may be the lowest sequence number of a point on the length of the Hilbert Curve to which the partition corresponds. Alternatively, it may be the highest sequence number. Alternatively the reference may be the lowest or highest sequence number of an actual data object stored within the partition. The reference may also be a pair of lowest and highest values of points delimiting a length of Hilbert Curve. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> The execution of a query on the data store, that is to say, the retrieval of data objects that lie within a specified multi-dimensional rectangle, proceeds as follows: firstly, the lowest Hilbert Curve sequence number of any point within the query region is calculated and the page that may contain its corresponding data object, if it exists, is then retrieved and searched for data objects lying within the query region. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> Secondly, the lowest sequence number of any point within the query region which is higher than the sequence number of any point on the section of Hilbert Curve corresponding to the page just searched is calculated, if it exists. The page that may contain this sequence number&apos;s corresponding data object, if it exists, is then retrieved and searched for data objects lying within the query region. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> The previous step is then repeated until no further pages are found to exist that intersect with the query region. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> Alternatively it is possible to identify all of the pages that inetersect a query region before any of them are retrieved from the data store and searched. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> The present invention offers many advantages over the prior art and a combination of advantages not present in any particular method forming part of the prior art. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> The combination of the indexing method, which relies on mapping multi-dimensional objects to one-dimensional values, and the querying algorithm has the effect of simulating the existence of each and every possible secondary index which can be created and used to gain selective access to multi-dimensional data. This is achieved without the storage overhead of actually providing separate secondary indexes. The index is therefore extremely compact in comparison with some alternative methods. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> In simulating the provision of each and every secondary index, the present invention achieves a degree of flexibility which is not practicable where conventional secondary indexes are relied upon. This is particulary the case in higher dimensional data spaces since the total number of possible secondary indexes equals 2<highlight><superscript>n</superscript></highlight>-2. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> The present invention enables the utilization of any simple and well understood one-dimensional indexing structure to be used for the organization and storage of multi-dimensional data. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> The mapping method, in utilizing the Hilbert Curve, partitions data so that, in general, each partition contains data objects that are close to each other in multi-dimensional space. Thus data objects that are in proximity to each other are clustered in the data store. This aids minimizing the number of pages to be searched in the execution of a query. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> The manner in which data is partitioned facilitates achievement of a high storage utilization. That is, the occupancy of pages of storage with actual data objects can be guaranteed to be relatively high and consistently so, in comparison with other methods described in the prior art. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> The index remains compact and grows in proportion to the volume of data placed in the data store. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> The index and page utilization adapts well on update of the data store through insertion and deletion of data objects. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> In identifying pages of data to be searched and searching the pages one at a time, the querying algorithm facilitates the lazy retrieval of data rather than identifying all of the data pages that intersect with a query region before any page is searched, even if only some rather than all matches to a query are required. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> The indexing design and the querying algorithm are scalable both in terms of the number of dimensions that exist in a data space and in terms of the volume of data that is stored. The complexity of the process is proportional to the number of dimensions in the data space and the volume of data. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> The querying algorithm makes viable the application of the Hilbert Curve in the partitioning and indexing of multi-dimensional data. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> The present invention can accommodate different partitioning strategies. For example, pages of data can correspond to contiguous sections of the Hilbert Curve, in which case a single value or derived-key can be used to identify a page. Alternatively, pages of data can correspond to lengths of Hilbert Curve that are not contiguous. Each such page is identified by a pair of values, one being the lowest derived-key of any datum-point stored on the page and the other being the highest derived-key of any datum-point stored on the page. In this second alternative, the index implies sections of Hilbert Curve on which no datum-points stored in the database lie. This arrangement can assist in minimising the number of pages of data that need to be searched in the execution of a query. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> The present invention can be used with any type of multi-dimensional data by mapping individual attribute domains to integers. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> The present invention can be implemented using any method of mapping to the Hilbert Curve. These mapping algorithms can describe any form of curve that conforms with the concepts of the Hilbert Curve, namely its symmetry and the principle that points that map to successive sequence values are adjacent in space. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> The present invention can be implemented using any orientation of the Hilbert Curve. That is to say, the Hilbert Curve may begin in any corner of the data space and terminate at any adjacent corner of the data space. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> The present invention can be implemented using any general purpose computer programming language. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> The present invention can be implemented on any computer architecture. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> The validity of the present invention and its correct functioning have been practically verified and demonstrated by the present inventor by implementing the concepts as a fully functioning computer program. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> A need for a database organization and retrieval method designed specifically to address the problems inherent in large volumes of multi-dimensional data will continue to grow. The present inventor believes that a successful solution must be not just effective in all respects but also simple. The design and implementation of such a solution, that addresses the partitioning and indexing of data, the organization of storage and the execution of queries, is the subject of the present invention. </paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">DRAWING FIGURES </heading>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> The present invention will be described in detail in the following description of preferred embodiments with reference to the following figures, wherein: </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference>: &ldquo;Symbols used in the algorithms&rdquo;. Defines mathematical symbols used in Algorithms <highlight><bold>1</bold></highlight> to <highlight><bold>3</bold></highlight>, shown in FIGS. <highlight><bold>10</bold></highlight>A-<highlight><bold>10</bold></highlight>C. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference>: &ldquo;Key to Variables&rdquo;. A cross-reference between mathematical symbols used in the paper written by Arthur R. Butz, referred in the Section titled &lsquo;Background of the invention&rsquo;, and variable names used in the source code included int the specification. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference>: &ldquo;Partitioning of the Hilbert Curve into Pages&rdquo;. Shows how sections of the Hilbert Curve correspond to pages in a database and exemplifies usage of some terms used in this description. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference>: &ldquo;Approximations of the Hilbert Curve in 2 Dimensions&rdquo;. Illustrates the first order Hilbert Curve in 2 dimensions. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference>: &ldquo;Approximations of the Hilbert Curve in 2 Dimensions&rdquo;. Illustrates the second order Hilbert Curve in 2 dimensions. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference>: &ldquo;Approximations of the Hilbert Curve in 2 Dimensions&rdquo;. Illustrates the third order Hilbert Curve in 2 dimensions. </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference>: &ldquo;The Tree Representation of the Third-order Hilbert Curve in 2 Dimensions&rdquo;. Shows how the Hilbert Curve can be expressed as a tree of nested sub-spaces. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference>: &ldquo;A State Diagram for the Hilbert Curve in 2 Dimensions&rdquo;. An example state diagram used in the process of mapping between n-dimensional points and one-dimensional sequence numbers. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference>: &ldquo;Flow Diagram for the Query Process&rdquo;. Illustrates the process by which a range query is executed. </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10</cross-reference>A: &ldquo;Algorithm <highlight><bold>1</bold></highlight>: Finding a Range Query next-match using a State Diagram&rdquo;. Describes the first part of the algorithm for calculating the lowest sequence number of a point on the Hilbert curve that is equal to or greater than the sequence number of some other point. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10</cross-reference>B: &ldquo;Algorithm <highlight><bold>2</bold></highlight>: Second Loop Referred to in Algorithm <highlight><bold>1</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 10</cross-reference>A)&rdquo;. Describes the second part of the algorithm described in <cross-reference target="DRAWINGS">FIG. 10</cross-reference>A and referred to in that Figure. </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10</cross-reference>C: &ldquo;Algorithm <highlight><bold>3</bold></highlight>: Binary Search of the current-search-space using a State Diagram&rdquo;. Describes the detail of binary searches that take place within the descriptions given in <cross-reference target="DRAWINGS">FIG. 10</cross-reference>A and <cross-reference target="DRAWINGS">FIG. 10B</cross-reference>. </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 11</cross-reference>: &ldquo;Example Query&rdquo;. Illustrates an example query on a 2-dimensional database. </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 12</cross-reference>A: &ldquo;Finding the next-match to a Range Query: Step 1 (of 6)&rdquo;. An example in 2 dimensions showing how the calculate_next_match function, described in <cross-reference target="DRAWINGS">FIG. 10</cross-reference>A-1&deg; C., operates. The example comprises 6 iterations of the algorithm. This figure shows the first iteration. Iterations 2-6 are shown in FIGS. <highlight><bold>12</bold></highlight>B-<highlight><bold>12</bold></highlight>F. </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 12</cross-reference>B: &ldquo;Finding the next-match to a Range Query: Step 2 (of 6)&rdquo;. An example in 2 dimensions showing how the calculate_next_match function operates. </paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 12</cross-reference>C: &ldquo;Finding the next-match to a Range Query: Step 3 (of 6)&rdquo;. An example in 2 dimensions showing how the calculate_next_match function operates. </paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 12</cross-reference>D: &ldquo;Finding the next-match to a Range Query: Step 4 (of 6)&rdquo;. An example in 2 dimensions showing how the calculate_next_match function operates. </paragraph>
<paragraph id="P-0068" lvl="0"><number>&lsqb;0068&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 12</cross-reference>E: &ldquo;Finding the next-match to a Range Query: Step 5 (of 6)&rdquo;. An example in 2 dimensions showing how the calculate_next_match function operates. </paragraph>
<paragraph id="P-0069" lvl="0"><number>&lsqb;0069&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 12</cross-reference>F: &ldquo;Finding the next-match to a Range Query: Step 6 (of 6)&rdquo;. An example in 2 dimensions showing how the calculate_next_match function operates. </paragraph>
<paragraph id="P-0070" lvl="0"><number>&lsqb;0070&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 13</cross-reference>: &ldquo;Examples: how to determine which sub-spaces intersect with a query region&rdquo;. </paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 14</cross-reference>: &ldquo;A Tree Representation of the Fourth Order Hilbert Curve in 2 Dimensions&rdquo;. For the calculate_next_match example illustrated in FIGS. <highlight><bold>12</bold></highlight>A-<highlight><bold>12</bold></highlight>F, shows how the tree representation of the Hilbert Curve is traversed. </paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF THE INVENTION </heading>
<paragraph id="P-0072" lvl="7"><number>&lsqb;0072&rsqb;</number> 1 Data Organization and Indexing </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> The present invention relates to data spaces, or database domains, containing finite numbers of points, or finite numbers of possible actual data values, in which the Hilbert Curve, which is an &lsquo;approximation&rsquo; of the Hilbert Space-filling Curve, passes through all points once and once only. The present invention approaches the organization of multi-dimensional data by regarding the data as points lying on the Hilbert Curve. The Hilbert Curve is described in Section 2 of this description of the present invention and methods of calculating mappings are described in Section 3. </paragraph>
<paragraph id="P-0074" lvl="0"><number>&lsqb;0074&rsqb;</number> The Hilbert Curve is named after the German mathematician David Hilbert. Hilbert represented the coordinates of points in space with a binary radix and this method is also used in the description of the present invention. </paragraph>
<paragraph id="P-0075" lvl="0"><number>&lsqb;0075&rsqb;</number> Each point in any space of finite granularity of points lies a unique distance along the curve from its beginning and thus is placed in order along a one-dimensional line of distance, or sequence, values. Thus points in multi-dimensional space, or n-dimensional space, where n is the number of dimensions in a space, are mapped to or transformed into values in one dimension that may be stored in or indexed by any simple one-dimensional data structure. </paragraph>
<paragraph id="P-0076" lvl="0"><number>&lsqb;0076&rsqb;</number> In order to map multi-dimensional data to one-dimensional values, it is first necessary to map individual attribute values of the data to integers. The Hilbert Curve passes through points in spaces that are squares in 2 dimensions, cubes in 3 dimensions or hyper-cubes in spaces with more than 3 dimensions and so the domain, or range of possible values, of the integers is the same in all dimensions even if the domains of individual attributes are of different size. A maximum integer value is the number that in the binary representation comprises bits or digits of value 1. Thus the maximum value of an integer is defined as 2<highlight><superscript>k</superscript></highlight>&minus;1, where k is chosen as appropriate for the size of the largest attribute domain of any possible item of multi-dimensional data to be stored in the database. The number of binary digits in an integer attribute value therefore equals k. In Section 2 of this description of the present invention this value of k corresponds to what is called the order of curve used in the mapping between multi-dimensional data and one-dimensional values. It is convenient and preferred, although not necessary, in a practical software implementation of the invention if the maximum integer value accommodated for an attribute value is the same as the maximum value accommodated by an unsigned integer data type supported by the computer programming language and its compiler used for the implementation. For example, an unsigned integer data type which comprises 32 binary digits accommodates multi-dimensional data whose largest attribute domain is within the range &lsqb;0 . . . 2<highlight><superscript>32</superscript></highlight>&minus;1&rsqb;. It is also preferred, although not necessary, that the smallest possible data type that can accommodate the maximum attribute value is used in the software implementation, in order to optimize the performance of the implementation. </paragraph>
<paragraph id="P-0077" lvl="0"><number>&lsqb;0077&rsqb;</number> How non-integer attribute values are mapped to integers is independent of this invention and any suitable method may be chosen. </paragraph>
<paragraph id="P-0078" lvl="0"><number>&lsqb;0078&rsqb;</number> The Hilbert Curve has certain interesting properties whereby points that are close to each other in n-dimensional space are, in general, mapped to one-dimensional values that are also in proximity to each other. Points that are consecutive in their ordering, according to the mapping using the Hilbert Curve, are adjacent in space. Thus the mapping achieves a degree of clustering of data with similar values in all attributes or dimensions which is desirable in the absence of prior knowledge of the pattern of queries that will be executed over a collection of data. </paragraph>
<paragraph id="P-0079" lvl="0"><number>&lsqb;0079&rsqb;</number> The multi-dimensional data that make up a database are partitioned into sub-sets. Each sub-set corresponds to a logical unit of storage held on a computer. In this invention, each sub-set is defined as a collection of points lying on a single contiguous section or length of the Hilbert Curve. Actual multi-dimensional data values stored in the database are called here datum-points. Each logical unit of storage is commonly called a page of data. Thus the Hilbert Curve is conceptually cut into sections, each section corresponding to a page. Each section of curve is delimited by a pair of points, one lying at each end of the section. The length of each curve section depends on the local density of datum-points and the physical capacity for datum-points of the page to which it corresponds. </paragraph>
<paragraph id="P-0080" lvl="0"><number>&lsqb;0080&rsqb;</number> A database held in computer memory comprises a set of pages and the size of this set depends on the volume of data, or number of datum-points, contained in the database and the average number of datum-points stored on the pages divided by the capacity of the pages. The set of pages may be held in a single computer file or be distributed between more than one computer file. Pages of datum-points may be stored in volatile or persistent memory. Each page also corresponds to a volume of space within an n-dimensional hyper-cubic space that defines the domain of the database. The form of the data space that corresponds to any particular page may also be a hyper-cube but will usually be more complex. In the preferred embodiment of the invention, the datum-point capacity of each page is the same for all pages. Alternatively, pages may be of variable size, with different pages having different capacities for datum-points. Ideally, datum-points are partitioned into sets such that as much of the capacity of the page of storage as possible is actually utilized for the storage of datum-points, thus minimizing the number of pages in the database. </paragraph>
<paragraph id="P-0081" lvl="0"><number>&lsqb;0081&rsqb;</number> Mapping to the Hilbert Curve induces a logical ordering of pages, similar to the ordering of points on the Hilbert Curve. All of the datum-points on any page map to lower one-dimensional values, that are called derived-keys in this document, than do all of the datum-points contained on all succeeding pages. In the preferred embodiment of the invention, the lowest derived-key corresponding to any datum-point placed on a page, when the page is created, becomes the index key for the page. Such index keys are called page-keys in this description. If the point whose derived-key is its page&apos;s page-key is subsequently deleted, the page&apos;s page-key may be left unchanged or else it may be replaced with the lowest derived-key of any datum-point remaining on the page. The first page is an exception in that it is indexed by the value of zero, corresponding to the first point on the curve. </paragraph>
<paragraph id="P-0082" lvl="0"><number>&lsqb;0082&rsqb;</number> Page-keys are placed in a one-dimensional index together with their corresponding logical page addresses in computer memory. Alternatively, pages can be indexed using page-keys that are the highest derived-keys of datum-points held on the page. </paragraph>
<paragraph id="P-0083" lvl="0"><number>&lsqb;0083&rsqb;</number> A third alternative is to index pages using pairs of page-keys. One is the lowest derived-key of any datum-point stored on the page and the other is the highest. In this variation of the indexing method, pages in the database correspond to consecutive sections of curve that are not contiguous; that is, some sections of curve on which no datum-points lie are not logically held in the database or its index. This method allows the avoidance of searching some parts of the dataspace known not to contain datum-points. </paragraph>
<paragraph id="P-0084" lvl="0"><number>&lsqb;0084&rsqb;</number> Insertion of a datum-point into the database entails mapping the datum-point&apos;s coordinates to its sequence number, or derived-key, and placing or storing the datum-point on the page that corresponds to the section of curve on which it lies. The format in which the datum-point is stored on the page is independent of the present invention and any suitable format can be used. </paragraph>
<paragraph id="P-0085" lvl="0"><number>&lsqb;0085&rsqb;</number> Note that the approach described here partitions data rather than the space in which it lies. It adapts easily on update, that is, insertion and deletion of datum-points. For example, if a page becomes full, half of the datum-points whose derived-keys are greater or less than those of the other half can be moved to a new page or some other similarly defined portion may be moved to a logically adjacent page. In other words, the same approach used for partitioning a collection of one-dimensional values in the one-dimensional B-Tree or one of its variants, such as the B&plus;-Tree, can be used for partitioning multi-dimensional data. Alternatively, the approach adopted in the B*-Tree may be used instead, where the capacity of a page is reached, some of the datum-points are moved to a logically neighbouring page. When two neighbouring pages become &lsquo;full&rsquo;, a new third page is created and the datum-points stored on the original 2 pages are divided between them and the new third page. </paragraph>
<paragraph id="P-0086" lvl="0"><number>&lsqb;0086&rsqb;</number> Mapping multi-dimensional data to one-dimensional values enables the use and exploitation of a single, simple and compact B-Tree index, or one of its variants or any other one-dimensional indexing method, to index for the purpose of gaining access to the data. Use of this type of data structure also enables the processing of updates (insertions of data or deletion of data) without the need for significant reorganization of data within the database. In contrast to other data storage systems comprising the prior art, the present invention is &lsquo;well-behaved&rsquo; in all respects. </paragraph>
<paragraph id="P-0087" lvl="0"><number>&lsqb;0087&rsqb;</number> The B-Tree is described in &ldquo;Organization and maintenance of large ordered indexes&rdquo; by R. Bayer and C. McCreight in <highlight><italic>Acta Informatica, </italic></highlight>1(3):172-189, 1972. The B&plus;-Tree and the B*-Tree are attributed to D. Knuth in &ldquo;The art of computer programming; volume 3: searching and sorting&rdquo;, published by Addison-Wesley, 1973. </paragraph>
<paragraph id="P-0088" lvl="0"><number>&lsqb;0088&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> shows an example of a 2-dimensional database. Pages are labelled with numbers which indicate their address in computer memory. The boundaries of pages within space are shown as broken lines. In the example, all of the pages have the same capacity, the capacity of one page is 4 datum-points and each page&apos;s page-key is taken to be the lowest derived-key of any datum-point stored on the page, except for the first page whose page-key is zero. The set of pages is indexed using a one-dimensional index method. A single index entry comprises a pair of values; one element of this pair being a page-key and the other being a reference or address that enables the corresponding page to be located in computer memory. Page index entries are ordered by their page-key values. Page numbers, or addresses, are assigned, or allocated, in the order in which the pages are created. The index contains the following entries: </paragraph>
<paragraph id="P-0089" lvl="2"><number>&lsqb;0089&rsqb;</number> page-key: 00000000 (0 decimal), page number: 1 </paragraph>
<paragraph id="P-0090" lvl="2"><number>&lsqb;0090&rsqb;</number> page-key: 01001000 (72 decimal), page number: 2 </paragraph>
<paragraph id="P-0091" lvl="2"><number>&lsqb;0091&rsqb;</number> page-key: 01101000 (104 decimal), page number: 3 </paragraph>
<paragraph id="P-0092" lvl="2"><number>&lsqb;0092&rsqb;</number> page-key: 01111100 (124 decimal), page number: 4 </paragraph>
<paragraph id="P-0093" lvl="2"><number>&lsqb;0093&rsqb;</number> page-key: 10000010 (130 decimal), page number: 5 </paragraph>
<paragraph id="P-0094" lvl="2"><number>&lsqb;0094&rsqb;</number> page-key: 10001100 (140 decimal), page number: 6 </paragraph>
<paragraph id="P-0095" lvl="2"><number>&lsqb;0095&rsqb;</number> page-key: 10101100 (172 decimal), page number: 7 </paragraph>
<paragraph id="P-0096" lvl="2"><number>&lsqb;0096&rsqb;</number> page-key: 11100000 (224 decimal), page number: 8 </paragraph>
<paragraph id="P-0097" lvl="0"><number>&lsqb;0097&rsqb;</number> Queries are executed by identifying and searching pages whose corresponding curve sections intersect with the set of curve sections that lie within, or pass through, a query region. A query region is an n-dimensional rectangular volume within the space that defines the domain of the database. The present invention&apos;s strategy for executing queries pivots on an algorithm for calculating the index entries of successive pages that intersect with the query region. This may be done in a &lsquo;lazy&rsquo; manner; that is, successive pages intersecting with the query region are identified, retrieved from the database and searched on demand. Alternatively, all of the pages that intersect with a query region may be determined before any is retrieved and searched. The manner in which pages that intersect with a query region are identified is described in detail in Section 4 of this description of the present invention. </paragraph>
<paragraph id="P-0098" lvl="0"><number>&lsqb;0098&rsqb;</number> In a practical application, the capacity of a page to store datum-points may amount to hundreds or thousands of datum-points. Pages may all have the same fixed datum-point or storage capacity or else they may vary in their capacities. </paragraph>
<paragraph id="P-0099" lvl="7"><number>&lsqb;0099&rsqb;</number> 2 The Hilbert Curve </paragraph>
<paragraph id="P-0100" lvl="0"><number>&lsqb;0100&rsqb;</number> The concept of a space-filling curve is originally attributed to Giuseppe Peano, who, in &ldquo;Sur une courbe, qui remplit toute une aire plane (on a curve which completely fills a planar region)&rdquo; in <highlight><italic>Mathematische Annalen, </italic></highlight>36:157-160, 1890, expressed it in mathematical terms and represented the coordinates of points in space with a ternary radix. The first graphical, or geometrical, representation of space-filling curves is attributed to the mathematician David Hilbert who described the 2-dimensional case in his paper &ldquo;Ueber stetige Abbildung einer Linie auf ein Flachenstuck&rdquo;, <highlight><italic>Mathematische Annalen, </italic></highlight>38:459 460, 1891. </paragraph>
<paragraph id="P-0101" lvl="0"><number>&lsqb;0101&rsqb;</number> Without loss of generality, an understanding of the way in which the Hilbert Curve is drawn is gained from the 2-dimensional embodiment illustrated in FIGS. <highlight><bold>4</bold></highlight> to <highlight><bold>5</bold></highlight> showing the first 3 steps of a potentially infinite process. In <cross-reference target="DRAWINGS">FIG. 4 a</cross-reference> square is initially divided into 4 quadrants, or, more generally, into 2<highlight><superscript>n </superscript></highlight>&lsquo;quadrants&rsquo; in n dimensions, and a line, or &lsquo;first order curve&rsquo;, is drawn through their centre points which are ascribed sequence numbers in the order in which the curve passes through them. The first order 2-dimensional Hilbert Curve is regarded as passing through the 4 points in a space that lie at the centres of the quadrants illustrated. The sequence in which the curve passes through the quadrants defines an ordering of the quadrants. The decimal sequence numbers of these points are shown adjacent to them. Decimal coordinate values are shown along the vertical and horizontal axes. The location in space of each point on a first order curve is defined by coordinate values for each dimension. </paragraph>
<paragraph id="P-0102" lvl="0"><number>&lsqb;0102&rsqb;</number> It was noted in Section 1 of this description of the present invention that the sequence number of a point lying on the Hilbert Curve is called a derived-key in this document. This term is also used to refer to the sequence number of a quadrant within a space containing 4 quadrants in 2 dimensions or 2<highlight><superscript>n </superscript></highlight>&lsquo;quadrants&rsquo; in n dimensions. Whether usage of the term relates to the sequence number of a point on the Hilbert Curve or to a quadrant in a space is clear from the context. </paragraph>
<paragraph id="P-0103" lvl="0"><number>&lsqb;0103&rsqb;</number> The quadrants are ordered such that any two that are adjacent in the ordering share a common edge. In the next step, shown in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>, each of the quadrants of <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is divided into 4 and, in all, 4 &lsquo;scaled-down&rsquo; first order curves are drawn and connected together. This produces a second order curve. Sequence numbers and coordinates are shown as binary numbers in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>. In 2 dimensions the curve passes through a space containing 16 points. Note that the first and last first order curves have different orientations to the one drawn in the first step so that the adjacency property of consecutive squares is maintained. </paragraph>
<paragraph id="P-0104" lvl="0"><number>&lsqb;0104&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> shows the third step, producing a third order curve passing through a space containing 64 points. The first point on the curve lies in the bottom left hand corner and the last, or 64-th, point lies in the bottom right hand corner. </paragraph>
<paragraph id="P-0105" lvl="0"><number>&lsqb;0105&rsqb;</number> To specify the coordinates of the points in the space of <cross-reference target="DRAWINGS">FIG. 4</cross-reference> only a single bit (binary digit) is needed but for the ordinal positions on the line two bits are needed. The ordinal mapping established by the first order Hilbert Curve is thus: </paragraph>
<paragraph id="P-0106" lvl="2"><number>&lsqb;0106&rsqb;</number> &lt;0,0&gt;&rarr;00,&lt;0,1&gt;&rarr;01,&lt;1,1&gt;&rarr;10 and &lt;1,0&gt;&rarr;11. </paragraph>
<paragraph id="P-0107" lvl="0"><number>&lsqb;0107&rsqb;</number> In this notation, the term &lt;1,0&gt;&rarr;11, for example, is read as: the point whose first and second coordinates are 1 and 0 respectively (&lt;1,0&gt;) maps to the sequence number, or derived-key, of 11 (binary) or 3 (decimal). </paragraph>
<paragraph id="P-0108" lvl="0"><number>&lsqb;0108&rsqb;</number> For the points in the space of the second order Hilbert Curve two bits are required for the coordinates and four bits for the ordinal numbers and the mapping established by this curve begins: </paragraph>
<paragraph id="P-0109" lvl="2"><number>&lsqb;0109&rsqb;</number> &lt;00,00&gt;&rarr;0000,&lt;01,00&gt;&rarr;0001,&lt;01,01&gt;&rarr;0010,&lt;00,01&gt;&rarr;0011, . . . </paragraph>
<paragraph id="P-0110" lvl="0"><number>&lsqb;0110&rsqb;</number> In practical applications this potentially infinite process is terminated after k steps to produce an approximation of the Hilbert Space-filling Curve called the Hilbert Curve of order k. This passes through 2<highlight><superscript>2k </superscript></highlight>squares, the centre points of which are regarded as points in a space of finite granularity of points. </paragraph>
<paragraph id="P-0111" lvl="0"><number>&lsqb;0111&rsqb;</number> Hilbert Curves passing through spaces containing more than 2 dimensions are constructed in a similar manner. In 3 dimensions, the first order curve is constructed by dividing a cube into 8 smaller cubes and ordering them so that consecutive cubes share a common face. Each one of the coordinates of a point is also expressed using 1 binary digit and the derived-key of the point is expressed using 3 binary digits. In 4 dimensions, the first order curve is constructed by dividing a hyper-cube into 16 smaller hyper-cubes and ordering them so that consecutive hyper-cubes share a common 3-dimensional hyper-surface. Each one of the coordinates of a point is expressed using 1 binary digit and the derived-key of the point is expressed using 4 binary digits. The concept readily extends both into higher dimensional spaces and to orders of curve higher than 1. </paragraph>
<paragraph id="P-0112" lvl="0"><number>&lsqb;0112&rsqb;</number> Generalizing the concept into n dimensions for the Hilbert Curve of order k, the Hilbert Curve passes through 2<highlight><superscript>nk </superscript></highlight>points. Each coordinate, or attribute, of a point in n dimensions is expressed using k bits and the derived-key of the point is expressed using nk bits. </paragraph>
<paragraph id="P-0113" lvl="0"><number>&lsqb;0113&rsqb;</number> The 2-dimensional examples of the embodiment of the Hilbert Curve shown in FIGS. <highlight><bold>4</bold></highlight> to <highlight><bold>6</bold></highlight> have their first points on the curve in the bottom left hand corners of the illustrations. Other embodiments of the Hilbert Curve can also be used to equal effect where, for example, the orientations of the curves are inverted. In this alternative, the first points on the Hilbert Curves are those lying in the top left hand corners of the illustrations. This notion applies equally in n-dimensional spaces. </paragraph>
<paragraph id="P-0114" lvl="0"><number>&lsqb;0114&rsqb;</number> More generally, alternative embodiments of the n-dimensional Hilbert Curve of order k are constructed by beginning the process by defining the first order curve as starting at any of the points in a space containing 2<highlight><superscript>n </superscript></highlight>points and ending at any point adjacent to the first point. 2 adjacent points on the first order differ in the value of one of their coordinates only. </paragraph>
<paragraph id="P-0115" lvl="0"><number>&lsqb;0115&rsqb;</number> Any embodiment of the Hilbert Curve can be utilized in the present invention for defining the derived-keys of points. </paragraph>
<paragraph id="P-0116" lvl="0"><number>&lsqb;0116&rsqb;</number> A characteristic of the preferred embodiment of the first order Hilbert Curve is that the sequence in which it passes through points is symmetrical about a hyper-plane that passes between the first and last points, where a hyper-plane is the n-dimensional equivalent of a line in 2 dimensions or a 2-dimensional plane in 3 dimensions. It is possible, however, to construct an embodiment of the Hilbert Curve which does not have this characteristic. </paragraph>
<paragraph id="P-0117" lvl="7"><number>&lsqb;0117&rsqb;</number> 3 Techniques for Hilbert Curve Mapping </paragraph>
<paragraph id="P-0118" lvl="0"><number>&lsqb;0118&rsqb;</number> For the present invention to be practicable, a suitable method is required for calculating mappings, that is, for calculating the derived-key of a point with a given set of coordinates in n-dimensional space of finite granularity of points and for calculating the coordinates of the point that corresponds to a particular derived-key. Such a method is also required for the querying algorithm, described later. </paragraph>
<paragraph id="P-0119" lvl="0"><number>&lsqb;0119&rsqb;</number> One method of performing these calculations for points arranged in grids in spaces of 2 or more dimensions is given in &ldquo;Using state diagrams for Hilbert Curve mappings&rdquo; by J. K. Lawder, Technical Report BBKCS-00-02, Birkbeck College, University of London, August 2000, in which state diagrams are utilized. This adapts and extends a generic technique for space-filling curves originally proposed in &ldquo;Space-filling curves: their generation and and their application to bandwidth reduction&rdquo; by Theodore Bially, <highlight><italic>IEEE Transactions on Information Theory, </italic></highlight>IT-15(6):658-664, Nov 1969. State diagrams are stored in the memory, either volatile or permanent, of a computer. The size of a state diagram increases exponentially with the number of dimensions in a space and for practicable purposes they become too large to store in volatile memory for more than about 9 dimensions, given the current state of computer hardware technology. </paragraph>
<paragraph id="P-0120" lvl="0"><number>&lsqb;0120&rsqb;</number> An alternative method of performing the mapping calculations is given in &ldquo;Calculation of mappings between one and n-dimensional values using the Hilbert Space-Filling Curve&rdquo; by J. K. Lawder, Technical Report BBKCS-00-01, Birkbeck College, University of London, August 2000, in which calculations are performed without the aid of state diagrams or the need to store them in the memory of a computer. That report is an adaptation and amplification of a technique describe in a paper &ldquo;Alternative algorithm for Hilbert&apos;s space-filling curve&rdquo;, by Arthur R. Butz, <highlight><italic>IEEE Transactions on Computers, </italic></highlight>20:424-426, April 1971. In effect, the characteristics of any particular state are calculated on demand, or &lsquo;on the fly&rsquo;, as required during a mapping process. </paragraph>
<paragraph id="P-0121" lvl="0"><number>&lsqb;0121&rsqb;</number> Alternatively, the present invention can be implemented using any algorithm for calculating Hilbert Curve mappings between multi-dimensional data and one-dimensional values. </paragraph>
<paragraph id="P-0122" lvl="0"><number>&lsqb;0122&rsqb;</number> Without loss of generality, the mapping process is illustrated for the 2-dimensional case in the following manner. </paragraph>
<paragraph id="P-0123" lvl="0"><number>&lsqb;0123&rsqb;</number> The recursive way in which space is partitioned during the Hilbert Curve construction process can be expressed in a tree structure as exemplified in <cross-reference target="DRAWINGS">FIG. 7</cross-reference>. This conceptual view aids an understanding of the mapping process. Each node corresponds to a first order curve and a collection of nodes at any tree level, k, describes a curve of order k, where the root resides at level 1. Thus the root node corresponds to the first order curve of <cross-reference target="DRAWINGS">FIG. 4</cross-reference> and the leaf nodes correspond to the set of first order curves comprising the third order curve of <cross-reference target="DRAWINGS">FIG. 6</cross-reference>. </paragraph>
<paragraph id="P-0124" lvl="0"><number>&lsqb;0124&rsqb;</number> Alternatively, a node is viewed as a sub-space enclosing 2<highlight><superscript>n </superscript></highlight>nested sub-spaces, or quadrants, except that a leaf node encloses 2<highlight><superscript>n </superscript></highlight>points. The ordering of quadrants in a node reflects the sequence in which the Hilbert Curve passes through points contained in the quadrants. </paragraph>
<paragraph id="P-0125" lvl="0"><number>&lsqb;0125&rsqb;</number> Recall that the binary sequence number of a quadrant within a node (also equivalent to a point on a first order curve) is called the derived-key. Alternatively, it is referred to as a quadrant number. The concatenated (single-bit) coordinates of a &lsquo;quadrant&rsquo; within a square, cube or hyper-cube or of a point on a first order curve is referred to in this description as an n-point. Thus an n-point encapsulates the location within a node or space of a quadrant in relation to other quadrants in the same node or space. </paragraph>
<paragraph id="P-0126" lvl="0"><number>&lsqb;0126&rsqb;</number> Also recall a derived-key of a point lying on a Hilbert Curve of order k contains nk bits; the same as the sum of the bits in all of the coordinates of a point. </paragraph>
<paragraph id="P-0127" lvl="0"><number>&lsqb;0127&rsqb;</number> How the mapping from the coordinates of a point to its derived-key takes place is illustrated with the example of point P lying on a third order Hilbert Curve shown on <cross-reference target="DRAWINGS">FIG. 6</cross-reference> and <cross-reference target="DRAWINGS">FIG. 7</cross-reference>. Its coordinates are &lt;110, 100&gt;. Initially the derived-key of P is unknown and designated by the binary bit string &lsquo;&quest;&quest;&quest;&quest;&quest;&quest;&rsquo;, where a question mark designates a bit of unknown value. </paragraph>
<paragraph id="P-0128" lvl="1"><number>&lsqb;0128&rsqb;</number> Step 1: Concatenate the top (or left-most or most significant) bits of the coordinates of P to form the n-point 11. This locates P in quadrant number 10 in the tree&apos;s root node. This quadrant is emphasized in bold in <cross-reference target="DRAWINGS">FIG. 7</cross-reference>. The derived-key of P is now &lsquo;10&quest;&quest;&quest;&quest;&rsquo;. </paragraph>
<paragraph id="P-0129" lvl="1"><number>&lsqb;0129&rsqb;</number> Step 2: Concatenate the next lower (ie middle) bits of the coordinates of P to form the n-point 10. Locate this n-point within the tree level 2 node pointed to by the quadrant identified in the root, in step 1. This places the point in the quadrant number is 11. The derived-key of P is now &lsquo;1011&quest;&quest;&rsquo;. </paragraph>
<paragraph id="P-0130" lvl="1"><number>&lsqb;0130&rsqb;</number> Step 3: Concatenate the bottom (or right-most or least significant) bits of the coordinates of P to form the n-point 00. Locate this n-point within the tree level 3 node pointed to by the quadrant identified in the previous step. This places the point in the quadrant number 10. The derived-key of P is now &lsquo;101110&rsquo;. </paragraph>
<paragraph id="P-0131" lvl="0"><number>&lsqb;0131&rsqb;</number> An inverse mapping, from a derived-key to the coordinates of a point, is carried out in a similar manner. </paragraph>
<paragraph id="P-0132" lvl="0"><number>&lsqb;0132&rsqb;</number> It is not practicable to store the tree representation of the Hilbert Curve in memory for calculating mappings for any useful value of order of curve. However, a tree contains a finite number of types of node. Different types of node (equivalent to different orientations of first order curve) can be regarded as being different states enabling the tree structure to be expressed more compactly as a state diagram. </paragraph>
<paragraph id="P-0133" lvl="0"><number>&lsqb;0133&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 7</cross-reference>, different nodes that are the same type are labelled with the same node type number. Each distinct type corresponds to a distinct state in a state diagram. </paragraph>
<paragraph id="P-0134" lvl="0"><number>&lsqb;0134&rsqb;</number> A graphical representation of the state diagram that summarises and encapsulates the tree shown in <cross-reference target="DRAWINGS">FIG. 7</cross-reference> is shown in <cross-reference target="DRAWINGS">FIG. 8</cross-reference>. In <cross-reference target="DRAWINGS">FIG. 8</cross-reference>, the vertical axis and horizontal axis coordinates of the centre point of a sub-square are shown concatenated and enclosed in round brackets. Corresponding sequence numbers are shown in square brackets. Whereas the tree shown in <cross-reference target="DRAWINGS">FIG. 7</cross-reference> encapsulates an embodiment of the third order Hilbert Curve, the state diagram encapsulates the Hilbert Curve of any order, or tree of any height. Different state diagrams encapsulate different embodiments of the Hilbert Curve. </paragraph>
<paragraph id="P-0135" lvl="0"><number>&lsqb;0135&rsqb;</number> The minimum number of states, or orientations of first order curves, required to encapsulate the Hilbert Curve of any order is given by the expression 2<highlight><superscript>n&minus;1</superscript></highlight>. </paragraph>
<paragraph id="P-0136" lvl="0"><number>&lsqb;0136&rsqb;</number> A method of constructing state diagrams for the Hilbert Curve is given in the aforementioned PhD thesis of the present inventor. </paragraph>
<paragraph id="P-0137" lvl="0"><number>&lsqb;0137&rsqb;</number> Referring to states in a state diagram is a convenient and concise way of describing the mapping process. Nevertheless, mappings may be calculated instead without the aid of state diagrams, for example, using the techniques described in the aforementioned Technical Report number BBKCS-00-01. </paragraph>
<paragraph id="P-0138" lvl="0"><number>&lsqb;0138&rsqb;</number> As noted previously, the mapping techniques can readily be applied to spaces of more than 2 dimensions. In 3 dimensions, a node in the tree, corresponding to an instance of a state or a first order curve, comprises 8 cubes, if it is a non-leaf node, or 8 points if it is a leaf node. In 4 dimensions, a node comprises 16 hyper-cubes or points. Generally, in n dimensions, a node comprises 2<highlight><superscript>n </superscript></highlight>hyper-cubes or points. </paragraph>
<paragraph id="P-0139" lvl="0"><number>&lsqb;0139&rsqb;</number> For convenience, this description uses the term quadrant to refer to squares, cubes and hyper-cubes, regardless of the value of n (number of dimensions in the space). </paragraph>
<paragraph id="P-0140" lvl="0"><number>&lsqb;0140&rsqb;</number> The precise form of the Hilbert Curve used in the storage and retrieval of multi-dimensional data is determined by the mapping algorithm used. </paragraph>
<paragraph id="P-0141" lvl="0"><number>&lsqb;0141&rsqb;</number> The preferred embodiment of the Hilbert Curve used in the description of the present invention is defined by using either the state diagram method for mapping between n-dimensional and one-dimensional values described in the aforementioned Technical Report BBKCS-00-02 and the PhD thesis of the present inventor or by using the calculation method described in the aforementioned Technical Report BBKCS-00-01 and the PhD thesis of the inventor. However, any other mapping algorithm can be used to equal effect. </paragraph>
<paragraph id="P-0142" lvl="0"><number>&lsqb;0142&rsqb;</number> In the preferred embodiment of the Hilbert Curve of order k, all of the coordinates of the first and last points on the curve are zero-valued except for the first coordinate of the last point which has the value 2<highlight><superscript>k</superscript></highlight>&minus;1. The present invention can be adapted to suit any embodiment of the Hilbert Curve for which mapping algorithms can be defined. </paragraph>
<paragraph id="P-0143" lvl="0"><number>&lsqb;0143&rsqb;</number> Ways in which mapping algorithms to suit alternative embodiments of the symmetrical Hilbert Curve can be generated are described in the aforementioned PhD thesis of the present inventor. </paragraph>
<paragraph id="P-0144" lvl="7"><number>&lsqb;0144&rsqb;</number> 4 The Data Retrieval Process </paragraph>
<paragraph id="P-0145" lvl="0"><number>&lsqb;0145&rsqb;</number> The present invention most importantly includes a method to enable the identification for retrieval of datum-points lying within hyper-rectangular query regions, or query ranges. A hyper-rectangle is the equivalent in n-dimensional space of a rectangle in 2-dimensional space, where n&gt;2. The data retrieval method is described in this Section and assumes that the mapping algorithms described in Section 3 of this description of the present invention are used to define the form of the Hilbert Curve. The retrieval method can be adapted to suit alternative embodiments of the Hilbert Curve and alternative ways of indexing pages of data. </paragraph>
<paragraph id="P-0146" lvl="7"><number>&lsqb;0146&rsqb;</number> 4.1 The Querying Strategy </paragraph>
<paragraph id="P-0147" lvl="0"><number>&lsqb;0147&rsqb;</number> The description that follows assumes the embodiment of the invention in which each page of data is indexed using the page-key that is the lowest derived-keys of any datum-point placed on it. </paragraph>
<paragraph id="P-0148" lvl="0"><number>&lsqb;0148&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference> shows the querying strategy of the preferred embodiment of the invention. This process includes identifying the pages that intersect with a query region. </paragraph>
<paragraph id="P-0149" lvl="0"><number>&lsqb;0149&rsqb;</number> Initially a query <highlight><bold>80</bold></highlight> is specified by defining a hyper-rectangular query region. Each query region is defined by a pair of points in the data space. One is called the lower bound and all of its coordinate values are equal to the minimum coordinate values of any point in the query region. The other is called the upper bound and all of its coordinate values are equal to the maximum coordinate values of any point in the query region. The coordinates of these points are, respectively, &lt;l<highlight><subscript>1</subscript></highlight>, l<highlight><subscript>2</subscript></highlight>, . . . l<highlight><subscript>n</subscript></highlight>&gt; and &lt;u<highlight><subscript>1</subscript></highlight>, u<highlight><subscript>2</subscript></highlight>, . . . u<highlight><subscript>n</subscript></highlight>&gt; such that min<highlight><subscript>i</subscript></highlight>&lE;l<highlight><subscript>i</subscript></highlight>&lE;u<highlight><subscript>i</subscript></highlight>&lE;max<highlight><subscript>i</subscript></highlight>. The value min<highlight><subscript>i </subscript></highlight>is the minimum coordinate value of any point in the query region and the value max<highlight><subscript>i </subscript></highlight>is the maximum coordinate value of any point in the query region. This type of query is called a range query. </paragraph>
<paragraph id="P-0150" lvl="0"><number>&lsqb;0150&rsqb;</number> The identification of pages intersecting with the query region is effected by a function or algorithm referred to in this description as calculate_next_match. This function calculates the lowest derived-key that is greater than or equal to another derived-key, called the current-page-key in this description, and which is the derived-key of a point within a specified query region. This lowest derived-key is called a next-match in this description. </paragraph>
<paragraph id="P-0151" lvl="0"><number>&lsqb;0151&rsqb;</number> Before the calculate_next_match function is called for the first time, the current-page-key is initialized to the value of <highlight><bold>82</bold></highlight> the derived-key of the first page in the database. </paragraph>
<paragraph id="P-0152" lvl="0"><number>&lsqb;0152&rsqb;</number> The calculate_next_match function is called <highlight><bold>84</bold></highlight> and its output is checked <highlight><bold>86</bold></highlight> to see if a next-match was found. The first time this function is called a next-match is always found and this is the lowest derived-key of any point lying within the query region is identified. The index is searched and the page that contains this point, if it is a datum-point, is identified <highlight><bold>90</bold></highlight>. This page is then retrieved <highlight><bold>92</bold></highlight> from the database into an area of computer memory where it can be searched, if the page cannot be searched in-situ. The page is then searched for datum-points lying within the query region <highlight><bold>94</bold></highlight>. </paragraph>
<paragraph id="P-0153" lvl="0"><number>&lsqb;0153&rsqb;</number> In the next step, the page most recently identified as intersecting with the query region is checked to see if it is that last page indexed; that is, the page with the highest page-key <highlight><bold>96</bold></highlight>. If it is the last page the query process terminates <highlight><bold>98</bold></highlight>, otherwise, the current-page-key is set to the page-key of the next page listed in the index <highlight><bold>100</bold></highlight> and the calculate_next_match function is called again <highlight><bold>84</bold></highlight>. Once no further next-matches can be found, the query process terminates <highlight><bold>88</bold></highlight>. </paragraph>
<paragraph id="P-0154" lvl="0"><number>&lsqb;0154&rsqb;</number> The second and subsequent times that the calculate_next_match function is called, it finds, if it exists, the lowest derived-key of a point lying within the query region that is equal to or greater than the page-key (called the current-page-key) of the successor page to the one just searched. This derived-key is called a next-match in this description. Thus the function takes the current-page-key as input and outputs the next-match, if it exists. The current-page-key is initialized to zero in order to find the first next-match. </paragraph>
<paragraph id="P-0155" lvl="0"><number>&lsqb;0155&rsqb;</number> In the preferred embodiment of the invention, if the next-match is found, the page that may contain its corresponding datum-point is identified by searching the index for the highest page-key that is less than the next-match. The page indexed by this page-key is then retrieved from the database and searched for datum-points lying within the query region, either immediately or once all pages intersecting the query region have been identified. The process continues in this manner until no further next-matches can be found. The number of times that calculate_next_match is called equals the number of pages intersecting with the query region plus one. </paragraph>
<paragraph id="P-0156" lvl="0"><number>&lsqb;0156&rsqb;</number> Each query region intersects one or more curve sections. The Hilbert Curve can enter, leave and re-enter a query region a number of times or a query region can contain a single section of Hilbert Curve. The querying strategy identifies for retrieval and searching only those pages stored in the database whose corresponding sections of the Hilbert Curve intersect the query region. </paragraph>
<paragraph id="P-0157" lvl="0"><number>&lsqb;0157&rsqb;</number> Applying the process shown in <cross-reference target="DRAWINGS">FIG. 9</cross-reference> to the example database illustrated in <cross-reference target="DRAWINGS">FIG. 10, a</cross-reference> query region is shown shaded and defined by lower and upper bound points. The current-page-key is initially the derived-key of the first point on the Hilbert Curve in the bottom left hand corner. The first time the calculate_next_match function is called, the derived-key of point B is calculated as the first next-match. The next-match is looked up in the index and found to lie between the page-keys of pages 3 and 4 which are the derived-keys of points A and G respectively. Page 3 is retrieved and searched for points lying within the query region. Next, the derived-key of point G becomes the current-page-key since it is the page-key of the successor page to the one just searched. The calculate_next_match function calculates the derived-key of point G itself as the next-match as it lies within the query region. Page 4 is then retrieved and searched. In the next iteration, the derived-key of point L is the current-page-key input to calculate_next_match and the next-match output is the derived-key of point N since it lies within the query region. Page 6 is retrieved and searched. In the final call to calculate_next_match, no next-match is found which is greater than the derived-key of point Q and the query terminates. </paragraph>
<paragraph id="P-0158" lvl="0"><number>&lsqb;0158&rsqb;</number> It can be seen that only pages intersecting with the query are retrieved and searched. Intervening curve sections corresponding to the other pages shown in the Figure are effectively &lsquo;stepped over&rsquo;, that is, not retrieved from the database for searching since they do not intersect with the query region. </paragraph>
<paragraph id="P-0159" lvl="0"><number>&lsqb;0159&rsqb;</number> In the preferred embodiment of the invention, pages to be searched are identified &lsquo;lazily&rsquo;, or on demand, in ascending page-key order. Each page intersecting the query region is searched before identifying the next page that intersects the query region. Alternatively, all of the pages can be identified before the first page is retrieved for searching. </paragraph>
<paragraph id="P-0160" lvl="0"><number>&lsqb;0160&rsqb;</number> Depending on the aims of the query, it may not be necessary to identify all of the pages that intersect with a query region or to search any or all of the intersecting pages. These aims are for the user of the invention to determine. The invention, however, accommodates these different aims. </paragraph>
<paragraph id="P-0161" lvl="0"><number>&lsqb;0161&rsqb;</number> In contrast to some approximations of space-filling curves other than the Hilbert Curve, knowledge of the derived-key values of the lower and upper bound points of the query region does not assist in the query process where the Hilbert Curve is used for mapping between n and one dimensions. </paragraph>
<paragraph id="P-0162" lvl="7"><number>&lsqb;0162&rsqb;</number> 4.2 The Algorithm for the Calculate_Next_Match Function </paragraph>
<paragraph id="P-0163" lvl="7"><number>&lsqb;0163&rsqb;</number> This Section describes the calculate_next_match function in detail. </paragraph>
<paragraph id="P-0164" lvl="0"><number>&lsqb;0164&rsqb;</number> A number of terms are used in the description of the querying algorithm. The terms datum-point, derived-key, page-key and hyper-cube are defined in Section 1 of this description of the present invention. The terms n-point and quadrant are defined in Section 3. The terms query region, query range, lower bound, upper bound, hyper-rectangle, next-match and current-page-key are defined in Section 4.1. </paragraph>
<paragraph id="P-0165" lvl="0"><number>&lsqb;0165&rsqb;</number> A number of other terms are defined here as follows: </paragraph>
<paragraph id="P-0166" lvl="2"><number>&lsqb;0166&rsqb;</number> A range query is a query in which a query region is specified as being a space from which datum-points are searched for and retrieved. </paragraph>
<paragraph id="P-0167" lvl="2"><number>&lsqb;0167&rsqb;</number> A current-page-key-point is a point, expressed as a set of coordinates, corresponding to a page-key. </paragraph>
<paragraph id="P-0168" lvl="2"><number>&lsqb;0168&rsqb;</number> A current-search-space is a space that is a hyper-cube in form and in which is pursued the next-match in a particular iteration of the querying process. In the first iteration, the current-search-space is the whole space and in subsequent iterations it is a sub-space that is &frac12;<highlight><superscript>n </superscript></highlight>of the previous iteration&apos;s current-search-space. </paragraph>
<paragraph id="P-0169" lvl="2"><number>&lsqb;0169&rsqb;</number> A current-query-region is a hyper-rectangular space that is a sub-space of both the query region and the current-search-space in which is pursued the next-match in a particular iteration of the querying process. In the first iteration, the current-query-region is the originally specified query region and in subsequent steps it is the intersection of the current-search-space and the current-query-region of the previous iteration. </paragraph>
<paragraph id="P-0170" lvl="2"><number>&lsqb;0170&rsqb;</number> A current-quadrant is the quadrant within the current-search-space to which the latter is restricted at the end of an iteration of the querying algorithm. </paragraph>
<paragraph id="P-0171" lvl="2"><number>&lsqb;0171&rsqb;</number> A current-tree-level is a measure of the current level of the tree representation of the Hilbert Curve where the search for the next-match takes place during any particular iteration of the algorithm. </paragraph>
<paragraph id="P-0172" lvl="0"><number>&lsqb;0172&rsqb;</number> Initially, at the root of the tree, this is set to 1. It is incremented in each iteration of the search as the tree is descended. The height of the tree corresponds to the order of the Hilbert Curve used in the mapping. As noted previously, the order of the Hilbert Curve together with the number of dimensions in the data space determines the total number of points (potential datum-points) through which the Hilbert Curve passes. </paragraph>
<paragraph id="P-0173" lvl="2"><number>&lsqb;0173&rsqb;</number> A current-state encapsulates the ordering of quadrants, expressed as n-points, within the current-search-space; that is, a mapping between sequence numbers and quadrants. This term is also referred to as the current-node. </paragraph>
<paragraph id="P-0174" lvl="2"><number>&lsqb;0174&rsqb;</number> A next-state is defined similarly to the current-state except that it encapsulates the ordering of quadrants within the current-quadrant. </paragraph>
<paragraph id="P-0175" lvl="7"><number>&lsqb;0175&rsqb;</number> 4.2.1 Overview of the Algorithm </paragraph>
<paragraph id="P-0176" lvl="0"><number>&lsqb;0176&rsqb;</number> The approach of the present invention to finding the next-match utilizes an iterative process (that, alternatively, can be implemented recursively) of partitioning of the current-search-space, that is initially the whole data-space. During each iteration, the current-search-space is conceptually divided into quadrants and these are searched to find a single quadrant, called the current-quadrant, in which to restrict and continue the search in the next iteration. </paragraph>
<paragraph id="P-0177" lvl="0"><number>&lsqb;0177&rsqb;</number> This approach allows a view of the data-space as a hierarchy of nested sub-spaces, each of which contains 2<highlight><superscript>n </superscript></highlight>quadrants and this hierarchy is equivalent to the tree representation of the Hilbert Curve described in Section 3 of this description of the present invention. The set of 2<highlight><superscript>n </superscript></highlight>quadrants within a sub-space is equivalent to a node in the tree. The search for the next-match is then equivalent to descending the tree from the root to a member of a leaf. Thus with each successive iteration of the algorithm, the tree is conceptually descended by one level (except where &lsquo;back-tracking&rsquo; takes place, as described below). Except at the leaf level of the tree, the current-quadrant is the &lsquo;parent&rsquo; of a node at the next lower level in the conceptual tree and this node becomes the current-search-space used in the next iteration. At the leaf level, the current-search-space contains 2<highlight><superscript>n </superscript></highlight>points and the current-quadrant, if successfully found, is one of these points and it corresponds to the next-match. Finding the current-quadrant is not straightforward where mapping to the Hilbert Curve is utilized since quadrants in space may be ordered differently in different nodes as exemplified in <cross-reference target="DRAWINGS">FIG. 7</cross-reference>. That is, quadrants with the same derived-keys but within different nodes may have different coordinate or n-point values. Recall that where state diagrams are utilized, a unique ordering of quadrants by their Hilbert Curve derived-keys within a node is referred to as a &lsquo;state&rsquo; in a state diagram. </paragraph>
<paragraph id="P-0178" lvl="0"><number>&lsqb;0178&rsqb;</number> Initially, the next-match is an empty bit-string and once successfully calculated it contains nk bits, where n is the number of dimensions in the data space and k is the order of the Hilbert Curve. As the tree representation of the Hilbert Curve is descended, successively lower groups of n bits are calculated. </paragraph>
<paragraph id="P-0179" lvl="0"><number>&lsqb;0179&rsqb;</number> Once identified, the current-quadrant within the current-search-space is the quadrant that intersects with the current-query-region and either encloses the current-page-key-point or, if the latter does not lie within it, contains points whose derived-keys are minimally greater than the current-page-key. In preparation for the next iteration in the preferred embodiment of the invention, in addition to restricting the current-search-space to that part that intersects with the current-quadrant, the current-query-region is also restricted in a similar manner. </paragraph>
<paragraph id="P-0180" lvl="0"><number>&lsqb;0180&rsqb;</number> On successful completion of each iteration, n bits of the value of the next-match are, at least tentatively, identified and appended to any previously identified (higher) bits in the next-match that is in the process of being calculated. These n bits are specifically the derived-key of the current-quadrant, that is, the sequence number of the current-quadrant within the current-search-space. </paragraph>
<paragraph id="P-0181" lvl="0"><number>&lsqb;0181&rsqb;</number> If, during any iteration of the algorithm, the current-query-region is found to coincide with the current-search-space, then the search can be completed immediately, without it being necessary to continue searching nodes at successively lower levels within the tree. When such a coincidence occurs, either the current-page-key-point also lies within the query region or else it does not. If the current-page-key-point does lie within the query region then the current-page-key is itself the next-match to the query. Otherwise, where the current-page-key-point does not lie within the current-search-space the next-match is the lowest derived-key of any point within the current-query-region and all unresolved bit values within the next-match are immediately set to zero. Thus the coincidence of the current-query-region and the current-search-space can enable the next-match to be determined in a number of iterations less than the height of the tree, or order of the curve. </paragraph>
<paragraph id="P-0182" lvl="0"><number>&lsqb;0182&rsqb;</number> If nodes are required to be searched at all levels down to and including the leaf level of the tree and a current-quadrant lying within the query region is found then it contains a single point whose derived-key is the next-match. </paragraph>
<paragraph id="P-0183" lvl="0"><number>&lsqb;0183&rsqb;</number> In order, at the end of each iteration of the algorithm, to identify the current-quadrant that maps to the lowest suitable derived-key in which to restrict the search, conceptually, a representation of nodes is utilized in which quadrants are ordered by their derived-keys. The search of a node then takes the form of an iterative binary search of the derived-keys of the quadrants within the node. In each iteration of this binary search, what remains of the current-search-space (initially a whole node) is divided into two halves, each of which contains one or more quadrants. In the next iteration (of the binary search), the search is restricted to one or the other of these halves, thus one half is discarded. The derived-keys of the quadrants in one half are all lower than those of the other. These are referred to as lower and upper halves. These terms do not relate to the locations in space of the quadrants (ie, their coordinates or n-points) but to their derived-keys. </paragraph>
<paragraph id="P-0184" lvl="0"><number>&lsqb;0184&rsqb;</number> Recall, however, that the current-query-region is expressed as the coordinates of the lower and upper bound points. The derived-keys of these points say little about which quadrant sequence numbers of the current-search-space intersect with the region. Thus, given a set or sub-set of ordered derived-keys representing the sequence in which the Hilbert Curve passes through quadrants within a node, a method is needed for determining whether the current-query-region intersects with the lower half of the quadrant derived-keys or the upper half of the quadrant derived-keys or both. This method is given in Algorithm <highlight><bold>3</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 10C</cross-reference>) and in the description of the detail of its implementation, in Section 4.2.2 of this description of the present invention. </paragraph>
<paragraph id="P-0185" lvl="0"><number>&lsqb;0185&rsqb;</number> Sometimes, where the current-query-region intersects with a sub-set of quadrants containing the current-page-key-point, the search for the next-match ultimately fails at a lower level in the tree. This occurs when no current-quadrant can be found in which to continue the search. That is, where the quadrant containing the page-key-point doesn&apos;t intersect with the query region and no quadrant with a higher derived-key intersects with the query region. </paragraph>
<paragraph id="P-0186" lvl="0"><number>&lsqb;0186&rsqb;</number> In such cases, it will be possible to back-track, that is, to conceptually ascend the tree and revisit a node at a higher level, and continue the search in another sub-set of quadrants if and only if a sub-set was previously found to intersect with the current-query-region and it contains quadrants enclosing points mapping to higher derived-keys than the current-page-key. Any such sub-set of quadrants will correspond to a search-space that is larger than the current-search-space. This sub-set will not correspond to the whole of a node within the tree. As the binary searches of nodes progress, details of sub-spaces to which back-tracking can take place, if necessary, need therefore to be identified and recorded. Every such sub-space that is found is smaller than any other found previously and thus it renders them obsolete. </paragraph>
<paragraph id="P-0187" lvl="0"><number>&lsqb;0187&rsqb;</number> Back-tracking to a higher level in the tree requires the removal of n lower order bits from the, as yet incompletely calculated next-match. n bits are removed for each level of ascension. The current-search-space is restored to a larger space previously &lsquo;visited&rsquo; during an earlier iteration of the algorithm. The corresponding earlier current-state and current-tree-level are also restored. </paragraph>
<paragraph id="P-0188" lvl="0"><number>&lsqb;0188&rsqb;</number> In the absence of any sub-space having been identified to which the search may return, a requirement to back-track implies that no next-match equal to or greater than the current-page-key exists and, therefore, that the query process is complete. Conversely, an opportunity to back-track implies that the next-match is guaranteed to exist, whether or not this opportunity is subsequently required. </paragraph>
<paragraph id="P-0189" lvl="0"><number>&lsqb;0189&rsqb;</number> Generally, it is noted that while the search for the next-match continues, it is tentative either until after back-tracking has taken place, if it is required, or until the current-query-region is found to coincide with the current-search-space. </paragraph>
<paragraph id="P-0190" lvl="0"><number>&lsqb;0190&rsqb;</number> If and once back-tracking to some sub-space (sub-set of quadrants in a node at a higher level in the tree searched in the previous iteration of the algorithm) does takes place, the search may proceed in a more straightforward manner and without regard to the value of the current-page-key since the search will be satisfied by the lowest derived-key of any point within that part of the query region that intersects with the sub-space. Note that all points enclosed within this sub-space map to higher derived-keys than the current-page-key. It is no longer necessary to identify further sub-spaces to which back-tracking may return since this process is only required at most once in any search. </paragraph>
<paragraph id="P-0191" lvl="0"><number>&lsqb;0191&rsqb;</number> The algorithm described in this Section is implemented by examining the values of one bit from each coordinate of both the lower and upper bounds of the query region and n bits from the current-page-key at each level of the tree during each iteration of the algorithm, starting with the most significant bits and progressing to the least significant bits. </paragraph>
<paragraph id="P-0192" lvl="0"><number>&lsqb;0192&rsqb;</number> It is instructive to consider the notion that if an n-point A is defined by taking the top bit from each of the coordinates of a point B, then A approximates the position in a space of point B. Thus, if a space is divided into quadrants then A specifies in which of these that point B lies. This quadrant can be labelled quad<highlight><subscript>A</subscript></highlight>. In a similar fashion, it can be seen that an n-point C can be defined by taking the second from top bit from each of the coordinates of point B and it approximates the position of B within quad<highlight><subscript>A</subscript></highlight>. This process can be repeated to a depth equal to the number of bits that are used to represent a coordinate value. These concepts, related to points, are readily applied to ranges since they are specified by 2 points; the upper and lower bound points. </paragraph>
<paragraph id="P-0193" lvl="0"><number>&lsqb;0193&rsqb;</number> Recalling the definition of an n-point it is noted that in the present context an n-point is a set of one-bit coordinates, that locate a quadrant within a current-search-space, concatenated into a single n-bit value. A mapping to a first order curve is established by ordering the n-points and ascribing them with their sequence numbers. </paragraph>
<paragraph id="P-0194" lvl="7"><number>&lsqb;0194&rsqb;</number> 4.2.2 Detailed Description of the Algorithm </paragraph>
<paragraph id="P-0195" lvl="0"><number>&lsqb;0195&rsqb;</number> In this Section, the algorithm is presented for the Hilbert Curve that is implemented as the calculate_next_match function. The description is followed with a commentary on how the main operations performed within it can be implemented. </paragraph>
<paragraph id="P-0196" lvl="0"><number>&lsqb;0196&rsqb;</number> References to &lsquo;states&rsquo; are made in the algorithm. In this context, a state encapsulates the ordering of quadrants within the space corresponding to a node in the tree according to their derived-keys. Thus a state is a particular type of node in the tree representation of the Hilbert Curve and it encapsulates a mapping between derived-keys and n-points of quadrants in a node. Where state diagrams are used for mapping calculations, a state is represented by its state number in the state diagram. Given the number of the current-state and the derived-key of a quadrant, its n-point can be looked-up in the state diagram as can its next-state number for use in the next iteration of the algorithm. The initial state is taken to be the first state in the state diagram, usually numbered state 0. </paragraph>
<paragraph id="P-0197" lvl="0"><number>&lsqb;0197&rsqb;</number> Where state diagrams are not used, a state is encapsulated by the values of a number of variables. An example of a set of such variables is given in Section 4.2.3 of this description of the present invention below and they are called J, {tilde over (&tgr;)} and &ohgr; in that Section. Each distinct state is characterised by a different set of values for these variables. Their values are used in calculation processes described below to find the n-point of a quadrant with a particular derived-key in a particular state and its next-state. Initially, these variables are all given 0 as their values. The algorithm described in this Section contains two loops. Each of these loops includes a binary search. The first loop (see <cross-reference target="DRAWINGS">FIG. 10</cross-reference>A, Algorithm <highlight><bold>1</bold></highlight>) is executed until one of three possible conditions arises: </paragraph>
<paragraph id="P-0198" lvl="2"><number>&lsqb;0198&rsqb;</number> 1. the current-page-key is found to be its own next-match. </paragraph>
<paragraph id="P-0199" lvl="2"><number>&lsqb;0199&rsqb;</number> 2. the current-page-key is found not to be its own next-match but that the next-match does exist. </paragraph>
<paragraph id="P-0200" lvl="2"><number>&lsqb;0200&rsqb;</number> 3. it is found that the next-match does not exist. </paragraph>
<paragraph id="P-0201" lvl="0"><number>&lsqb;0201&rsqb;</number> The first condition arises when it is found that the current-page-key-point lies within the current-search-space that is coincident with the current-query-region. This signifies completion of the search for the next-match. In this case the second loop is not executed. </paragraph>
<paragraph id="P-0202" lvl="0"><number>&lsqb;0202&rsqb;</number> The second condition arises when it is found that the current-page-key-point does not lie within the query region but that the latter intersects with a part of the search space whose points map to higher derived-keys than the current-page-key. This will occur once back-tracking takes place but may also occur when it is not required. In this case, execution breaks out of the first loop and the second loop is entered. </paragraph>
<paragraph id="P-0203" lvl="0"><number>&lsqb;0203&rsqb;</number> The third condition arises when it is found that the current-page-key-point lies within a quadrant whose derived-key is greater than that of any that intersects with a current-query-region and that no sub-space has previously been identified to which back-tracking may return. Both the search for the next-match and the execution of the query now terminate, since the current-page-key is greater than the highest derived-key of any point within the query region. In this case the second loop (see <cross-reference target="DRAWINGS">FIG. 10</cross-reference>B, Algorithm <highlight><bold>2</bold></highlight>) is not executed. </paragraph>
<paragraph id="P-0204" lvl="0"><number>&lsqb;0204&rsqb;</number> During execution of the first loop, successively lower sets of n bits of the next-match are calculated, but only tentatively, as explained previously. Sub-spaces to which back-tracking may return if required are also identified during its execution. </paragraph>
<paragraph id="P-0205" lvl="0"><number>&lsqb;0205&rsqb;</number> When the second condition arises, control is passed to the second loop that behaves in a similar but simpler manner than the first loop. Its purpose is to find the lowest derived-key of any point within the current-query-region and, therefore, the value of the current-page-key is no longer of interest. Iteration of the second loop may terminate early without it being necessary to search nodes at all levels down to the leaf level of the tree if the current-query-region is coincident with the current-search-space. </paragraph>
<paragraph id="P-0206" lvl="0"><number>&lsqb;0206&rsqb;</number> Once the second loop has been entered, no requirement to back-track will ever arise. </paragraph>
<paragraph id="P-0207" lvl="0"><number>&lsqb;0207&rsqb;</number> The total number of iterations of both loops cannot exceed twice the order of the curve used in the mapping, and depends on whether back-tracking and/or a search of nodes at all levels down to the leaf level of the tree is required. This defines the upper bound to the computational complexity of the algorithm. </paragraph>
<paragraph id="P-0208" lvl="0"><number>&lsqb;0208&rsqb;</number> Binary searches of nodes or states are performed in both loops. </paragraph>
<paragraph id="P-0209" lvl="0"><number>&lsqb;0209&rsqb;</number> The algorithm that calculates the next-match is broken into three parts and is given in FIGS. <highlight><bold>10</bold></highlight>A-<highlight><bold>10</bold></highlight>C. The first is an overview, given in Algorithm <highlight><bold>1</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 10A</cross-reference>). It does not include the detail of the second loop referred to above but indicates where control is passed to it. Neither does it include the detail of the binary search of quadrants within a node. The second part details the operation of the second loop and is given in Algorithm <highlight><bold>2</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 10B</cross-reference>). The third part, in Algorithm <highlight><bold>3</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 10C</cross-reference>), provides the detail of the binary search of a node containing the quadrants that make up the current-search-space. Symbols used in the Algorithms are defined in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. </paragraph>
<paragraph id="P-0210" lvl="0"><number>&lsqb;0210&rsqb;</number> Comments within the Algorithms are enclosed in &lsquo;curly braces&rsquo;: &lsquo;&lcub;&rsquo; and &lsquo;&rcub;&rsquo;. </paragraph>
<paragraph id="P-0211" lvl="0"><number>&lsqb;0211&rsqb;</number> Initially the current-search-space is the whole of the data space through which the Hilbert Curve passes, by implication. </paragraph>
<paragraph id="P-0212" lvl="0"><number>&lsqb;0212&rsqb;</number> This Section is concluded with a commentary on the main operations performed in the algorithm, given in the order of their execution. </paragraph>
<paragraph id="P-0213" lvl="7"><number>&lsqb;0213&rsqb;</number> Step 1: (Algorithm <highlight><bold>1</bold></highlight>:<cross-reference target="DRAWINGS">FIG. 10</cross-reference>A, Line &num;8: Algorithm <highlight><bold>2</bold></highlight>:<cross-reference target="DRAWINGS">FIG. 10</cross-reference>B, Line &num;6) </paragraph>
<paragraph id="P-0214" lvl="0"><number>&lsqb;0214&rsqb;</number> By visualizing space as a hierarchy, ie a tree, a query region lower bound (or upper bound) point is located within a particular quadrant of the root node by examining the top, or most significant, bit of each of its coordinates. Lower bits are examined at lower levels in the tree representation of the Hilbert Curve. Similarly, the k-th bits of the coordinates determine the quadrant at the k-th level of the tree in which the point lies. Thus at each iteration of the statement in this step of the Algorithm, the k-th bits of the coordinates of the lower and upper bound points of the current-query-region are extracted. For both points these n single-bit values are concatenated into n-points for use in other steps. These values are referred to below as Q<highlight><subscript>lower </subscript></highlight>and Q<highlight><subscript>upper</subscript></highlight>. </paragraph>
<paragraph id="P-0215" lvl="7"><number>&lsqb;0215&rsqb;</number> Step 2: (Algorithm <highlight><bold>1</bold></highlight>:<cross-reference target="DRAWINGS">FIG. 10</cross-reference>A, Line &num;9) </paragraph>
<paragraph id="P-0216" lvl="0"><number>&lsqb;0216&rsqb;</number> A similar operation is performed by the statement in this step except that in each iteration n bits of the current-page-key are extracted, starting with the most significant bits when the current-tree-level is 1, corresponding to the root. These n bits are the derived-key of the quadrant within the current-search-space containing the current-page-key-point. It is noted that this step is not required in Algorithm <highlight><bold>2</bold></highlight>. </paragraph>
<paragraph id="P-0217" lvl="7"><number>&lsqb;0217&rsqb;</number> Step 3: (Algorithm <highlight><bold>1</bold></highlight>:<cross-reference target="DRAWINGS">FIG. 10</cross-reference>A, Line &num;10: Algorithm <highlight><bold>3</bold></highlight>:<cross-reference target="DRAWINGS">FIG. 10C</cross-reference>) </paragraph>
<paragraph id="P-0218" lvl="0"><number>&lsqb;0218&rsqb;</number> During each iteration of the binary search, the number of quadrants within the current-search-space is reduced, in which the next-match is pursued, by half until finally the current-quadrant remains (if the binary search completes successfully). The quadrants are ordered under the mapping and so their derived-keys, in the range &lsqb;0, . . . , 2<highlight><superscript>n</superscript></highlight>&minus;1&rsqb;, are known by implication. Their coordinates are not known but may be found from the state diagram in which they are stored as n-points. Alternatively, they are calculated, for example, in the manner described in Section 4.2.3 of this description of the present invention if state diagrams are not used. </paragraph>
<paragraph id="P-0219" lvl="0"><number>&lsqb;0219&rsqb;</number> Whether the query intersects with the half of the sub-set of quadrants of current interest whose derived-keys are the lowest is determined in the manner described below. </paragraph>
<paragraph id="P-0220" lvl="0"><number>&lsqb;0220&rsqb;</number> If the derived-keys of a sub-set of quadrants are in the range </paragraph>
<paragraph id="P-0221" lvl="2"><number>&lsqb;0221&rsqb;</number> &lsqb;lowest, . . . , max-lower, min-higher, . . . , highest&rsqb;</paragraph>
<paragraph id="P-0222" lvl="7"><number>&lsqb;0222&rsqb;</number> then all of the quadrants whose derived-keys are in the lower sub-range </paragraph>
<paragraph id="P-0223" lvl="2"><number>&lsqb;0223&rsqb;</number> &lsqb;lowest, . . . , max-lower&rsqb;</paragraph>
<paragraph id="P-0224" lvl="7"><number>&lsqb;0224&rsqb;</number> have the same value, 0 or 1, in their coordinates in one particular dimension, i. Similarly, all of the quadrants whose derived-keys are in the higher sub-range </paragraph>
<paragraph id="P-0225" lvl="2"><number>&lsqb;0225&rsqb;</number> &lsqb;min-higher, . . . , highest&rsqb;</paragraph>
<paragraph id="P-0226" lvl="7"><number>&lsqb;0226&rsqb;</number> have the opposite coordinate value, 1 or 0, in the same dimension, i. This characteristic does not apply in any other dimension. </paragraph>
<paragraph id="P-0227" lvl="0"><number>&lsqb;0227&rsqb;</number> Recall that quadrants whose derived-keys are consecutive are adjacent in space. Thus the n-digit number that contains a single non-zero bit corresponding to the dimension, i, that divides this range into two is evaluated by </paragraph>
<paragraph lvl="0"><in-line-formula>partitioning_dimension &larr;<highlight><italic>d</italic></highlight>_to<highlight><subscript>&mdash;</subscript></highlight><highlight><italic>c </italic></highlight>(max-lower) &oplus; <highlight><italic>d</italic></highlight>_to<highlight><subscript>&mdash;</subscript></highlight><highlight><italic>c </italic></highlight>(min-higher)&emsp;&emsp;(1) </in-line-formula></paragraph>
<paragraph id="P-0228" lvl="7"><number>&lsqb;0228&rsqb;</number> where d_to_c is a function that takes the derived-key of a quadrant as its parameter and returns its coordinates expressed as an n-point by looking up its value in the state diagram (or by calculating it where state diagrams are not used, in the manner described, for example, in Section 4.2.3) of this description of the present invention. </paragraph>
<paragraph id="P-0229" lvl="0"><number>&lsqb;0229&rsqb;</number> It now remains to be found whether the quadrants whose derived-keys are in the lower sub-range all have the value of 0 or all have the value of 1 in dimension i. This is done by testing the value of the expression </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>d</italic></highlight>_to<highlight><subscript>&mdash;</subscript></highlight><highlight><italic>c </italic></highlight>(max-lower) &Lgr; partitioning_dimension&emsp;&emsp;(2) </in-line-formula></paragraph>
<paragraph id="P-0230" lvl="7"><number>&lsqb;0230&rsqb;</number> If this expression evaluates to non-zero, then these quadrants all have the value 1 in dimension i, otherwise they have the value 0. </paragraph>
<paragraph id="P-0231" lvl="0"><number>&lsqb;0231&rsqb;</number> Knowledge of this value enables it to be determined whether the query region intersects with quadrants mapping to derived-keys in the lower half of a sub-set of quadrant derived-keys or with quadrants mapping to derived-keys in the upper half of a sub-set of quadrant derived-keys or with quadrants mapping to derived-keys in both halves. </paragraph>
<paragraph id="P-0232" lvl="0"><number>&lsqb;0232&rsqb;</number> Finally, recall that in each iteration of the algorithms in Algorithm <highlight><bold>1</bold></highlight> and Algorithm <highlight><bold>2</bold></highlight>, the current-query-region is successively restricted to the intersection of the originally specified query region and successively smaller current-search-spaces. Thus for the current-query-region to intersect with the quadrants whose derived-keys are in the lower sub-range, either or both of the lower and upper bounds of the current-query-region must have the same value in its coordinate for dimension i as these quadrants. </paragraph>
<paragraph id="P-0233" lvl="0"><number>&lsqb;0233&rsqb;</number> Whether the current-query-region intersects with the half of the sub-set of quadrants of current interest during an iteration of the binary search whose derived-keys are in the higher sub-range is determined in a similar manner to that described above. </paragraph>
<paragraph id="P-0234" lvl="0"><number>&lsqb;0234&rsqb;</number> Once the binary search has been completed, the derived-key of a single quadrant, called the current-quadrant, is identified. This, at least tentatively, contains the next-match and so the current-search-space is restricted to it prior to the next iteration of the algorithm. This is described below in &lsquo;Step 4&rsquo;. </paragraph>
<paragraph id="P-0235" lvl="7"><number>&lsqb;0235&rsqb;</number> Step 4: (Algorithm <highlight><bold>1</bold></highlight>:<cross-reference target="DRAWINGS">FIG. 10</cross-reference>A, Lines &num;14-17: Algorithm <highlight><bold>2</bold></highlight>:<cross-reference target="DRAWINGS">FIG. 10</cross-reference>B, Lines &num;8-11) </paragraph>
<paragraph id="P-0236" lvl="0"><number>&lsqb;0236&rsqb;</number> Once the coordinates, expressed as an n-point, of the current-quadrant in which to pursue the search in the next iteration of the algorithm (Algorithm <highlight><bold>1</bold></highlight> and Algorithm <highlight><bold>2</bold></highlight>) have been identified, restricting the current-query-region is achieved by comparing this n-point with the values of Q<highlight><subscript>lower </subscript></highlight>and Q<highlight><subscript>upper </subscript></highlight>found in step 1. </paragraph>
<paragraph id="P-0237" lvl="0"><number>&lsqb;0237&rsqb;</number> Coordinates of the current-query-region&apos;s lower bound are set to zero in dimensions corresponding to bits that are set to 1 following an EXCLUSIVE-OR operation between the quadrant&apos;s n-point and Q<highlight><subscript>lower</subscript></highlight>. Bits in upper bounds coordinates are all set to to 1 following a similar EXCLUSIVE-OR operation between the n-point and Q<highlight><subscript>upper</subscript></highlight>. </paragraph>
<paragraph id="P-0238" lvl="0"><number>&lsqb;0238&rsqb;</number> Adjusting the coordinates of the current-query-region&apos;s bounds in this simple manner corrupts bit values in the query region&apos;s lower and upper bounds corresponding to higher levels than the current-tree-level. This is not important since their original values will have been processed in previous iterations of the algorithm. </paragraph>
<paragraph id="P-0239" lvl="7"><number>&lsqb;0239&rsqb;</number> Step 5: (Algorithm <highlight><bold>1</bold></highlight>:<cross-reference target="DRAWINGS">FIG. 10</cross-reference>A, Lines &num;18-21) </paragraph>
<paragraph id="P-0240" lvl="0"><number>&lsqb;0240&rsqb;</number> In order to determine whether the current-query-region coincides with the current-search-space, two n-bit variables, one for each of the query bounds, are maintained. Whenever a query region&apos;s lower or upper bound coordinate is adjusted in step 4, the corresponding bit is set to 1 in one of these variables. When all of the bits in both of these variables have been set to 1, this signifies that the current-query-region coincides with the current-search-space. This enables the descent of the tree to be curtailed since the current-page-key-point must lie within the query region and so the current-page-key must be its own next-match. </paragraph>
<paragraph id="P-0241" lvl="0"><number>&lsqb;0241&rsqb;</number> Similarly, in lines 2-5 of Algorithm <highlight><bold>2</bold></highlight>, coincidence of the current-query-region and the current-search-space enables further searching of nodes in the tree to be avoided since the next-match must be the lowest derived-key within the current-search-space. All unresolved lower bits within the next-match can immediately be set to zero. </paragraph>
<paragraph id="P-0242" lvl="7"><number>&lsqb;0242&rsqb;</number> 4.2.3 Application of the Algorithm in Higher Dimensions </paragraph>
<paragraph id="P-0243" lvl="0"><number>&lsqb;0243&rsqb;</number> The algorithm for the calculate_next_match function described above can be applied where mapping to the Hilbert curve is performed by calculation without the aid of state diagrams. Thus the algorithm can be applied where the number of dimensions in space exceed the upper limit imposed by main memory requirements of state diagrams. </paragraph>
<paragraph id="P-0244" lvl="0"><number>&lsqb;0244&rsqb;</number> The design and functionality of the algorithm do not need to be modified to avoid the usage of state diagrams but the detail of the implementation of those parts of the algorithm that pertain to mapping or partial mapping calculations and the definition of the current-state and next-state need to be adapted to suit the particular mapping method used. That this is possible and the preferred manner in which to do this is demonstrated using a working example of source code listing written in the ANSI Standard &lsquo;C&rsquo; computer programming language given in Section 4.2.4 of this description. This example also aids the understanding of the algorithm. </paragraph>
<paragraph id="P-0245" lvl="0"><number>&lsqb;0245&rsqb;</number> This example utilizes the embodiment of the Hilbert Curve defined by the mapping technique described in the aforementioned Technical Report BBKCS-00-01, in the aforementioned PhD thesis of the present inventor and in the aforementioned paper by Arthur R. Butz. </paragraph>
<paragraph id="P-0246" lvl="0"><number>&lsqb;0246&rsqb;</number> Similarly, the algorithm for calculating the next-match can be implemented where any other calculated mapping procedure is available for the Hilbert Curve. </paragraph>
<paragraph id="P-0247" lvl="0"><number>&lsqb;0247&rsqb;</number> A commentary of the calculations carried out in the example program is given in this Section, in Section 4.2.4 of this description of the present invention and also in &lsquo;comments&rsquo; included in the source code. Comments are delimited in the &lsquo;C&rsquo; programming language by the character pairs &lsquo;/*&rsquo; and &lsquo;*/&rsquo;. Names of variables used in the source code are correlated with variable names used in Technical Report BBKCS-00-01 and in the paper by Arthur R. Butz, in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>. The semantics of these variables is given in the PhD thesis of the present inventor. </paragraph>
<paragraph id="P-0248" lvl="0"><number>&lsqb;0248&rsqb;</number> Note that Butz&apos; method of mapping from derived-keys to coordinates (and the inverse mapping) also conceptually entails an iterative descent of the tree representation of the Hilbert Curve in a similar way that mappings using state diagrams do. In each iteration, n bits of the derived-key are taken and transformed into the coordinates of a point. </paragraph>
<paragraph id="P-0249" lvl="0"><number>&lsqb;0249&rsqb;</number> Three critical variables are required in the mapping process. These variables are referred to as J, {tilde over (&tgr;)} and &ohgr; in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>. They encapsulate the characteristics of the current state, or the type of node at a particular level in the tree representation of the Hilbert Curve, and so enable the order or sequence of any quadrant within the tree node, or state, to be determined. A full account of the significance of these variables and how they correspond to the definition of a state in a state diagram is given in the PhD thesis of the present inventor. On commencement of the calculate_next_match algorithm, these variables are all initialized to zero and they are updated during each iteration for use in the next iteration. </paragraph>
<paragraph id="P-0250" lvl="0"><number>&lsqb;0250&rsqb;</number> Several calculations are performed during each iteration of the function calculate_next_match that implements this algorithm and these are described below and in the source code. </paragraph>
<paragraph id="P-0251" lvl="0"><number>&lsqb;0251&rsqb;</number> In &lsquo;Step 3&rsquo; of the commentary in Section 4.2.2 of this description of the present invention, it was seen that the coordinates of two quadrants are required in each iteration of the binary search. The derived-keys of these quadrants were referred to as max-lower and min-higher. In the source code, they are referred to as LoHi_H and HiLo_H respectively. Their coordinates, expressed as n-points, enable it to be determined which dimension partitions a set of (ordered) quadrants, whose derived-keys only are known, into two halves. This was referred to as the partitioning_dimension in equation (1). In practice, however, it is possible to find the partitioning_dimension without having to perform complete mappings to both of these n-points. </paragraph>
<paragraph id="P-0252" lvl="0"><number>&lsqb;0252&rsqb;</number> In accordance with Butz&apos; mapping algorithm, it is first necessary to calculate a values for each of the quadrants max-lower and min-higher. A &sgr; value is the n-point representation of a point, with a particular sequence number (derived-key), lying specifically on a first order curve of the same orientation as the one that defines the first step in the process of constructing the curve of any order. These are referred to here as L_&sgr; and H_&sgr; (and as variables tSL and tSH respectively in the source code). In practice, their calculation may be effected more simply than in the manner described by Butz, as </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>L</italic></highlight>_&sgr;&larr;max-lower &oplus; (max-lower/2)&emsp;&emsp;(3) </in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>H</italic></highlight>_&sgr;&larr;min-higher &oplus; (min-higher/2)&emsp;&emsp;(4) </in-line-formula></paragraph>
<paragraph id="P-0253" lvl="0"><number>&lsqb;0253&rsqb;</number> From these two values, corresponding {tilde over (&sgr;)} values are found by performing right circular bit-wise shifts to produce L_&sgr; and H_&sgr;. In the source code, these values are assigned to the variables tSL and tSH. </paragraph>
<paragraph id="P-0254" lvl="0"><number>&lsqb;0254&rsqb;</number> Instead of completing the mappings from max-lower and min-higher to their n-points (coordinates) and finding the partitioning_dimension in the combined operation: </paragraph>
<paragraph lvl="0"><in-line-formula>(<highlight><italic>L</italic></highlight>_{tilde over (&sgr;)}&oplus;&ohgr;&oplus;{tilde over (&tgr;)})&oplus;(<highlight><italic>H</italic></highlight>_{tilde over (&sgr;)}&oplus;&ohgr;&oplus;{tilde over (&tgr;)})&emsp;&emsp;(5) </in-line-formula></paragraph>
<paragraph id="P-0255" lvl="7"><number>&lsqb;0255&rsqb;</number> it is only necessary to perform the calculation </paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>L</italic></highlight>_{tilde over (&sgr;)}&oplus;<highlight><italic>H</italic></highlight>_{tilde over (&sgr;)}&emsp;&emsp;(6) </in-line-formula></paragraph>
<paragraph id="P-0256" lvl="7"><number>&lsqb;0256&rsqb;</number> This simplification is possible since the EXCLUSIVE-OR operation is both commutative and associative and since a&oplus;a&equals;0 and a&oplus;0&equals;a. Nevertheless, the coordinates of max-lower need to be calculated in order to carry out the computation given previously in equation (2). </paragraph>
<paragraph id="P-0257" lvl="0"><number>&lsqb;0257&rsqb;</number> Once the binary search has been completed, the derived-key of the current-quadrant is known. The coordinates of this quadrant are required in order to restrict the current-search-space for the next iteration of the algorithm (or recursive function call). There is a 50% probability that the derived-key of the current-quadrant is the same as max-lower from the final iteration of the binary search and so its coordinates will already have been calculated. At any rate, the values of &sgr; and {tilde over (&sgr;)} of the current-quadrant will already have been calculated. </paragraph>
<paragraph id="P-0258" lvl="0"><number>&lsqb;0258&rsqb;</number> The three critical variables, J, {tilde over (&tgr;)} and &ohgr;, must also be updated at the end of each iteration of the querying algorithm for use in the next. Their new values depend on the combination of their current values and the derived-key of the current-quadrant identified at the end of a binary search. The critical variables, once updated in the manner described by Butz, encapsulate the characteristics of the next-state corresponding to the derived-key of the current-quadrant in the current state. </paragraph>
<paragraph id="P-0259" lvl="7"><number>&lsqb;0259&rsqb;</number> 4.2.4 Notes on the Source Code </paragraph>
<paragraph id="P-0260" lvl="0"><number>&lsqb;0260&rsqb;</number> The example software implementation, given at the end of this Section, is expressed iteratively but can quite easily be adapted to be implemented recursively. The implementation assumes that the order of curve used is the same as the number of binary digits (bits) that make up a variable of type &lsquo;unsigned int&rsquo; in the ANSI &lsquo;C&rsquo; programming language. The detail of the implementation can be adapted where other orders of curve are required or where an &lsquo;unsigned int&rsquo; (or its equivalent in a different programming language) contains a different number of bits to the order of curve. </paragraph>
<paragraph id="P-0261" lvl="0"><number>&lsqb;0261&rsqb;</number> The calculation of the next-match (a derived-key) that is equal to or greater than a page-key (a derived-key) is invoked by calling the function &lsquo;H_nextmatch_RQ&rsquo; that in turn calls the function &lsquo;HB_nextmatch_RQ&rsquo;. The latter makes use of a supplementary function HB_matches_RQ that has the dual purpose of determining the n-point of the quadrant identified as the current-quadrant at the end of the binary search and also of determining the characteristics of the next-state for the next iteration of the algorithm. The next-state encapsulates the ordering of the quadrants within the current-quadrant at the next lower level of the tree representation of the Hilbert Curve. H_nextmatch_RQ returns a value of 0 if no next-match exists otherwise, the next-match is placed in the memory location pointed to by the next_match parameter. </paragraph>
<paragraph id="P-0262" lvl="0"><number>&lsqb;0262&rsqb;</number> The value DIM denotes the number of dimensions in the data space, hitherto referred to as n in this document. </paragraph>
<paragraph id="P-0263" lvl="0"><number>&lsqb;0263&rsqb;</number> Parameters passed to HB_nextmatch_RQ are as follows: </paragraph>
<paragraph id="P-0264" lvl="1"><number>&lsqb;0264&rsqb;</number> LoBound: the coordinates of the point at the lower bound of the query. </paragraph>
<paragraph id="P-0265" lvl="1"><number>&lsqb;0265&rsqb;</number> HiBound: the coordinates of the point at the upper bound of the query. </paragraph>
<paragraph id="P-0266" lvl="1"><number>&lsqb;0266&rsqb;</number> next_match: a pointer to a derived-key variable in which is placed the next-match, if found. </paragraph>
<paragraph id="P-0267" lvl="1"><number>&lsqb;0267&rsqb;</number> page_key: a pointer to a derived-key variable that contains the current-page-key. </paragraph>
<paragraph id="P-0268" lvl="1"><number>&lsqb;0268&rsqb;</number> K: a measure of the current level of the tree representation of the Hilbert Curve. Initially, at the root this is set to &lsquo;ORDER-1 &rsquo; (ORDER is defined in the source code). It is decremented in each iteration of the search as the tree is descended. It corresponds to the current-tree-level referred to in the algorithms described earlier. </paragraph>
<paragraph id="P-0269" lvl="1"><number>&lsqb;0269&rsqb;</number> xJ: one of the three variables encapsulating the current-state. </paragraph>
<paragraph id="P-0270" lvl="1"><number>&lsqb;0270&rsqb;</number> tT: one of the three variables encapsulating the current-state. </paragraph>
<paragraph id="P-0271" lvl="1"><number>&lsqb;0271&rsqb;</number> W: one of the three variables encapsulating the current-state. </paragraph>
<paragraph id="P-0272" lvl="1"><number>&lsqb;0272&rsqb;</number> LoMask: used with HiMask to determine whether the current-quadrant lies wholly within the query region. Both are initially 0. </paragraph>
<paragraph id="P-0273" lvl="0"><number>&lsqb;0273&rsqb;</number> The main local variables used are as follows (other working variables are described in or clear from their use in the source code): </paragraph>
<paragraph id="P-0274" lvl="1"><number>&lsqb;0274&rsqb;</number> H: the K-th order DIM bits taken from the page-key. In the first iteration of the algorithm it is the DIM most significant bits of the page-key. DIM designates the number of dimensions in the space. </paragraph>
<paragraph id="P-0275" lvl="1"><number>&lsqb;0275&rsqb;</number> qLo: an n-point; the K-th DIM bits from LoBound. Where K equals zero, this holds the least significant bits of the coordinates of the lower bound of the query region. </paragraph>
<paragraph id="P-0276" lvl="1"><number>&lsqb;0276&rsqb;</number> qHi: similar to qLo; the K-th DIM bits from HiBound. </paragraph>
<paragraph id="P-0277" lvl="1"><number>&lsqb;0277&rsqb;</number> L_xor_H: a DIM-bit value holding bit values of 1 where qLo and qHi have the same values in the same dimension eg, where DIM equals 2, values of 1 in both bits indicates the current-query-region lies wholly within the same quadrant. </paragraph>
<paragraph id="P-0278" lvl="1"><number>&lsqb;0278&rsqb;</number> Lo: initially, the lowest derived-key in a state or node; ie 0. </paragraph>
<paragraph id="P-0279" lvl="1"><number>&lsqb;0279&rsqb;</number> Hi: initially, the highest derived-key in a state or node; ie NUMPOINTS-1. (NUMPOINTS is defined in the source code). </paragraph>
<paragraph id="P-0280" lvl="1"><number>&lsqb;0280&rsqb;</number> region: the n-point of the current-quadrant whose derived-key is Lo; identified at the end of the binary search of a node or state. If the search for the next-match progresses to a lower level in the tree then region will define the new current-search-space. </paragraph>
<paragraph id="P-0281" lvl="1"><number>&lsqb;0281&rsqb;</number> LoHi_H: initially, the highest derived-key of a quadrant in the bottom half of a state. See also Section 4.2.3 of this description of the present invention. </paragraph>
<paragraph id="P-0282" lvl="1"><number>&lsqb;0282&rsqb;</number> HiLo_H: initially, the lowest derived-key of a quadrant in the top half of a state. </paragraph>
<paragraph id="P-0283" lvl="1"><number>&lsqb;0283&rsqb;</number> LoHi_C: the n-point corresponding to LoHi_H. </paragraph>
<paragraph id="P-0284" lvl="1"><number>&lsqb;0284&rsqb;</number> partitioning_dimension: the dimension in which the points in the bottom half (or part) of a state differ from the points in the top half. See also Section 4.2.3 of this description of the present invention. </paragraph>
<paragraph id="P-0285" lvl="1"><number>&lsqb;0285&rsqb;</number> R_xor_L: a DIM-bit value holding values of 1 for dimensions in which the n-point of the quadrant containing the (tentative) next-match has a higher value than the query lower bound (qLo), enabling lower bits in the query lower bound to be set to values of 0. This enables the current-query-region to be restricted to that part that intersects with the current-quadrant to be used in the next iteration of the algorithm. </paragraph>
<paragraph id="P-0286" lvl="1"><number>&lsqb;0286&rsqb;</number> R_xor_H: a DIM-bit value holding values of 1 for dimensions in which the n-point of the quadrant containing the (tentative) next-match has a lower value than the query upper bound (qHi), enabling lower bits in the query upper bound to be set to values of 1. This enables the current-query-region to be restricted to that part that intersects with the current-quadrant to be used in the next iteration of the algorithm. </paragraph>
<paragraph id="P-0287" lvl="0"><number>&lsqb;0287&rsqb;</number> The example source code must be compiled using a 32-bit compiler for the ANSI &lsquo;C&rsquo; programming language and that defines unsigned integers as being 32-bit words. The inventor successfully compiled the source code using the &lsquo;cc&rsquo; compiler supplied with the Sun Solaris 5.7 operating system.  
<table-cwu id="TABLE-US-00001">
<number>1</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>&num;define DIM &lt;specified as the number of dimensions in the space&gt;</entry>
</row>
<row>
<entry>&num;define ORDER 32 /* the order of the curve */</entry>
</row>
<row>
<entry>/* assumes the variable type &lsquo;unsigned int&rsquo; is a 32-bit word;</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>ie contains &lsquo;ORDER&rsquo; bits */</entry>
</row>
<row>
<entry>typedef unsigned int U_int;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="70PT" align="left"/>
<colspec colname="2" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry>typedef struct &lcub;U_int</entry>
<entry>hcode&lsqb;DIM&rsqb;;&rcub;Hcode;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry>typedef Hcode Point;</entry>
</row>
<row>
<entry>int NUMPOINTS &equals; 1&lt;&lt; DIM;</entry>
</row>
<row>
<entry>U_int g_all_ones &equals; (1 &lt;&lt; DIM)&minus;1 ;</entry>
</row>
<row>
<entry>static int HB_matches_RQ (U_int P, U_int Lo, U_int L_xor_H,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="84PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>U_int *A, U_int *xJ, U_int *tT, U_int *W)&lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="210PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>U_int</entry>
<entry>J, S, tS, T, local_W &equals; *W, temp1, temp2; int j;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>S &equals; P {circumflex over (&thinsp;)} P / 2;</entry>
</row>
<row>
<entry></entry>
<entry>if (*xJ % DIM &excl;&equals; 0)&lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="84PT" align="left"/>
<colspec colname="2" colwidth="147PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>temp1 &equals; S &gt;&gt; *xJ % DIM;</entry>
<entry>temp2 &equals; S &lt;&lt; DIM &minus; *xJ % DIM;</entry>
</row>
<row>
<entry></entry>
<entry>tS &equals; temp1 &verbar; temp2;</entry>
<entry>tS &amp;&equals; ((U_int)1 &lt;&lt; DIM) &minus; 1;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>else tS &equals; S;</entry>
</row>
<row>
<entry></entry>
<entry>local_W {circumflex over (&thinsp;)}&equals; *tT;</entry>
</row>
<row>
<entry></entry>
<entry>*A &equals; local_W {circumflex over (&thinsp;)} tS;</entry>
</row>
<row>
<entry></entry>
<entry>if ((*A &amp; L_xor_H) &equals;&equals; (Lo &amp; L_xor_H))&lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>*W &equals; local_W;</entry>
</row>
<row>
<entry></entry>
<entry>if (P &lt; 3) T &equals; 0;</entry>
</row>
<row>
<entry></entry>
<entry>else</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>if (P % 2)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>T &equals; (P &minus; 1) {circumflex over (&thinsp;)} (P &minus; 1) / 2;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>else</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>T &equals; (P &minus; 2) {circumflex over (&thinsp;)} (P &minus; 2) / 2;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>if (*xJ % DIM &excl;&equals; 0&lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="84PT" align="left"/>
<colspec colname="2" colwidth="133PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>temp1 &equals; T &gt;&gt; *xJ % DIM;</entry>
<entry>temp2 &equals; T &lt;&lt; DIM &minus; *xJ % DIM;</entry>
</row>
<row>
<entry></entry>
<entry>*tT &equals; temp1 &verbar; temp2;</entry>
<entry>*tT &amp;&equals; ((U_int)1 &lt;&lt; DIM) &minus; 1;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>else *tT &equals; T;</entry>
</row>
<row>
<entry></entry>
<entry>J &equals; DIM;</entry>
</row>
<row>
<entry></entry>
<entry>for (j &equals; 1; j &lt; DIM; j&plus;&plus;)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>if ((P &gt;&gt; j &amp; 1) &equals;&equals; (P &amp; 1)) continue;</entry>
</row>
<row>
<entry></entry>
<entry>else break;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>if (j &excl;&equals; DIM) J &minus;&equals; j;</entry>
</row>
<row>
<entry></entry>
<entry>*xJ &plus;&equals; J &minus; 1;</entry>
</row>
<row>
<entry></entry>
<entry>return 1;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>return 0;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry>&rcub;</entry>
</row>
<row>
<entry>static U_int HB_nextmatch_RQ (Point LoBound, Point HiBound,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Hcode *next_match, Hcode *page_key, int K,</entry>
</row>
<row>
<entry></entry>
<entry>U_int xJ, U_int tT, U_int W, U_int LoMask, U_int HiMask)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry>&lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>U_int</entry>
<entry>mask, qLo, qHi, L_xor_H, R_xor_L, R_xor_H, region,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>H, element, temp, partioning_dimension,</entry>
</row>
<row>
<entry></entry>
<entry>Lo, Hi, LoHi_H, HiLo_H, LoHi_C, tSL, tSH, temp1, temp2, i;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>int</entry>
<entry>j, N;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry>/* variables used for &lsquo;saving&rsquo; current values of variables</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>in case back-tracking is required */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>U_int</entry>
<entry>qLoBAK, qHiBAK, L_xor_HBAK, HBAK, xJBAK, tTBAK, WBAK,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>LoMaskBAK, HiMaskBAK, LoBAK, HiBAK, Backup &equals; FALSE;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Hcode</entry>
<entry>next_matchBAK;</entry>
</row>
<row>
<entry></entry>
<entry>Point</entry>
<entry>LoBoundBAK, HiBoundBAK;</entry>
</row>
<row>
<entry></entry>
<entry>int</entry>
<entry>KBAK;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>while (K &gt;&equals; 0) &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>mask &equals; 1 &lt;&lt; K;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry>/* step 1: find the n-points of the quadrants in which the</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>for (i &equals; qLo &equals; qHi &equals; 0; i &lt; DIM; i&plus;&plus;) &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>if (LoBound.hcode&lsqb;i&rsqb; &amp; mask) qLo &verbar;&equals; 1 &lt;&lt; (DIM&minus;1&minus;i);</entry>
</row>
<row>
<entry></entry>
<entry>if (HiBound.hcode&lsqb;i&rsqb; &amp; mask) qHi &verbar;&equals; 1 &lt;&lt; (DIM&minus;1&minus;i);</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry>/* step 2: extract DIM consecutive bits from page_key */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>element &equals; (DIM * K) / ORDER;</entry>
</row>
<row>
<entry></entry>
<entry>H &equals; page_key&minus;&gt;hcode&lsqb;element&rsqb;;</entry>
</row>
<row>
<entry></entry>
<entry>if ((DIM * K) % ORDER &gt; ORDER &minus; DIM)&lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>temp &equals; page_key&minus;&gt;hcode&lsqb;element &plus; 1&rsqb;;</entry>
</row>
<row>
<entry></entry>
<entry>H &gt;&gt;&equals; (DIM * K) % ORDER;</entry>
</row>
<row>
<entry></entry>
<entry>temp &lt;&lt;&equals; ORDER &minus; (DIM * K) % ORDER; H &verbar;&equals; temp;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>else H &gt;&gt;&equals; (DIM * K) % ORDER;</entry>
</row>
<row>
<entry></entry>
<entry>if (DIM &lt; ORDER) H &amp;&equals; (1 &lt;&lt; DIM) &minus;1;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry>/* step 3: find in which dimensions the query lower and upper</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>bounds have the same values */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>L_xor_H &equals; qLo - qHi; L_xor_H &equals; <highlight><superscript>&tilde;</superscript></highlight>L_xor_H;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry>/* step 4: do a binary search of the derived-keys of the quadrants</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>in the current-state to find the quadrant with the lowest</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>derived-key that is greater than or equal to the value of H and</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>which is within the query range SEE ALGORITHM 3 (<cross-reference target="DRAWINGS">FIG.10C</cross-reference>) */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>for (Lo &equals; 0, Hi &equals; NUMPOINTS &minus; 1 ; Lo &excl;&equals; Hi ; )&lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry>/* the middle 2 ordered derived-keys of quadrants in a state or</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>part of a state. They enable us to divide it in 2; one is the</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>upper bound of the lower part and the other is the lower</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>bound of the upper part */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>LoHi_H &equals; Lo &plus; (Hi &minus; Lo) / 2; HiLo_H &equals; LoHi_H &plus; 1;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry>/* find the partitioning-dimension */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>tSL &equals; LoHi_H {circumflex over (&thinsp;)} LoHi_H / 2; tSH &equals; HiLo_H {circumflex over (&thinsp;)} HiLo_H / 2;</entry>
</row>
<row>
<entry></entry>
<entry>if (xJ % DIM &excl;&equals; 0)&lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry>/* right circular shift tSL and tSH by xJ bits */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>temp1 &equals; tSL &gt;&gt; xJ % DIM; temp2 &equals; tSL &lt;&lt; DIM &minus; xJ % DIM;</entry>
</row>
<row>
<entry></entry>
<entry>tSL&thinsp;&thinsp;&ensp;&equals; temp1 &verbar; temp2; tSL &amp;&equals; ((U_int)1 &lt;&lt; DIM) &minus; 1;</entry>
</row>
<row>
<entry></entry>
<entry>temp1 &equals; tSH &gt;&gt; xJ % DIM; temp2 &equals; tSH &lt;&lt; DIM &minus; xJ % DIM;</entry>
</row>
<row>
<entry></entry>
<entry>tSH&thinsp;&thinsp;&ensp;&equals; temp1 &verbar; temp2; tSH &amp;&equals; ((U_int)1 &lt;&lt; DIM) &minus; 1;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry>/* the dimension in which all points in the lower half of the</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>state (or part) have the same value and the points in the</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>upper half have the opposite value */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>partioning_dimension &equals; tSL - tSH;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry>/* The n-point of the quadrant with the highest derived-key in</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>the &lsquo;lower&rsquo; half of the state (or part) */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>LoHi_C &equals; W {circumflex over (&thinsp;)} tT {circumflex over (&thinsp;)} tSL;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry>/* check to see if the query intersects with the lower half of</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>the state (or part) i.e. if its lower bound is within it (the</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>first test checks whether the query intersects both halves -</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>both parts of the test are needed. NB &lsquo;partioning_dimension&rsquo;</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>and &lsquo;LoHi_C&rsquo; change as the loop iterates) */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>if (&excl;(partioning_dimension &amp; L_xor_H) &verbar;&verbar;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>((partioning_dimension &amp; LoHi_C) &equals;&equals;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="70PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>(partioning_dimension &amp; qLo)))&lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry>/* there is a match in the lower half of the state; either the range</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>spans both halves (so far as the partioning_dimension</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>dimension is concerned) or LoHi_C is within the. . . */</entry>
</row>
<row>
<entry>/* check to see if H is in the lower half of the state (or part) */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>if (LoHi_H &gt;&equals; H)&lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry>/* H is in the lower half of the state (or part). If the query</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>spans both halves of the state (or part), record the limits</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>of the top half of the state and note that search may continue</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>there by assigning &lsquo;TRUE&rsquo; to &lsquo;Backup&rsquo;. If a next-match is not</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>subsequently found in the lower half of the state the search</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>may in the upper half (this is back-tracking) */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="70PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>if (&excl;(partioning_dimension &amp; L_xor_H))&lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="84PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>qLoBAK &equals; qLo; qHiBAK &equals; qHi;</entry>
</row>
<row>
<entry></entry>
<entry>L_xor_HBAK &equals; L_xor_H; HBAK &equals; H;</entry>
</row>
<row>
<entry></entry>
<entry>xJBAK &equals; xJ; tTBAK &equals; tT; WBAK &equals; W; KBAK &equals; K;</entry>
</row>
<row>
<entry></entry>
<entry>next_matchBAK &equals; *next_match;</entry>
</row>
<row>
<entry></entry>
<entry>LoBoundBAK &equals; LoBound; HiBoundBAK &equals; HiBound;</entry>
</row>
<row>
<entry></entry>
<entry>LoMaskBAK &equals; LoMask; HiMaskBAK &equals; HiMask;</entry>
</row>
<row>
<entry></entry>
<entry>LoBAK &equals; HiLo_H; HiBAK &equals; Hi; Backup &equals; TRUE;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="70PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry>/* set (reduce) the &lsquo;Hi&rsquo; value for the next iteration of the</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>binary search */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="70PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Hi &equals; LoHi_H;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>else</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry>/* . . .but H is in the upper half of the state (or part),</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>therefore check if the range also intersects with the upper</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>half. . .if so, set (increase) the &lsquo;Lo&rsquo; value for the next</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>iteration of the binary search */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="70PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>if (&excl;(partioning_dimension &amp; L_xor_H))</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="84PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Lo &equals; HiLo_H;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="70PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>else</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry>/*. . .otherwise H is in the upper half of the state (or part) but</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>the query doesn&apos;t intersect with it; therefore, if we</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>previously found a (larger) half state (or part) with which</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>the query intersects, backtrack to it, restoring the values of</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>working variables accordingly */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="84PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>if (Backup)&lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="98PT" align="left"/>
<colspec colname="1" colwidth="161PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>qLo &equals; qLoBAK; qHi &equals; qHiBAK;</entry>
</row>
<row>
<entry></entry>
<entry>L_xor_H &equals; L_xor_HBAK; H &equals; HBAK;</entry>
</row>
<row>
<entry></entry>
<entry>xJ &equals; xJBAK; tT &equals; tTBAK; W &equals; WBAK; K &equals; KBAK;</entry>
</row>
<row>
<entry></entry>
<entry>*next_match &equals; next_matchBAK;</entry>
</row>
<row>
<entry></entry>
<entry>LoBound &equals; LoBoundBAK; HiBound &equals; HiBoundBAK;</entry>
</row>
<row>
<entry></entry>
<entry>LoMask &equals; LoMaskBAK; HiMask &equals; HiMaskBAK;</entry>
</row>
<row>
<entry></entry>
<entry>Lo &equals; LoBAK; Hi &equals; HiBAK; Backup &equals; FALSE;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="84PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>else return 0; /* no next_match exists */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>else</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry>/* the query region does not intersect with the upper half of</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>the state (or part), therefore set (increase) the value of</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>&lsquo;Lo&rsquo; for the next iteration of the binary search */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Lo &equals; HiLo_H;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub; /* end of binary search */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry>/* determine the characteristics of the next-state for the quadrant</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>whose derived-key is &lsquo;Lo&rsquo; (using variables xJ, tT and W).</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>&lsquo;region&rsquo; is set to be the n-point corresponding to the quadrant</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>whose derived-key is &lsquo;Lo&rsquo;. */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>if (&excl;HB_matches_RQ(Lo, qLo L_xor_H, &amp;region, &amp;xJ, &amp;tT, &amp;W))</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>exit(1); /* an error has occurred */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>if (K &gt; 0)&lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry>/* restrict the query region (LoBound and HiBound) to that part</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>which intersects the region containing the next-match, if it</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>exists, i.e. &lsquo;Lo&rsquo;. &lsquo;R_xor_L&rsquo; has bits set to 1 if &lsquo;region&rsquo;</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>and &lsquo;qlo&rsquo; have different values in the corresponding</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>dimensions. Since &lsquo;region&rsquo; is within the query range, its</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>bits will be 1 and qLo&apos;s will be 0 therefore in restricting</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>the query range, we increase the value of the current order&apos;s</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>bit in the query to 1 and set the lower bits to 0. Since at</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>higher orders we are only going to encounter 0 bits in qLo</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>values, it&apos;s simplest to set the whole value of the query</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>lower bound to 0. A similar logic applies to &lsquo;R_xor_H&rsquo; if the</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>query region was wholly within the subspace which is defined</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>by &lsquo;region&rsquo; then both &lsquo;R_xor_L&rsquo; and &lsquo;R_xor_H&rsquo; would be 0 in</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>all bits and the query region would not get changed */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>for (R_xor_L &equals; region {circumflex over (&thinsp;)} qLo, N &equals; DIM &minus; 1;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="70PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>R_xor_L; R_xor_L &gt;&gt;&equals; 1, N&minus;&minus;)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>if (R_xor_L &amp; 1)&lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="70PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>LoBound.hcode&lsqb;N&rsqb; &equals; 0; LoMask &verbar;&equals; 1 &lt;&lt; (DIM&minus;1&minus;N);</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>for (R_xor_H &equals; region {circumflex over (&thinsp;)} qHi, N &equals; DIM &minus; 1;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="70PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>R_xor_H; R_xor_H &gt;&gt;&equals; 1, N&minus;&minus;)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>if (R_xor_H &amp; 1) &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="70PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>HiBound.hcode&lsqb;N&rsqb; &equals; U_int_MAX;</entry>
</row>
<row>
<entry></entry>
<entry>HiMask &verbar;&equals; 1 &lt;&lt; (DIM&minus;1&minus;N);</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>if (Lo &equals;&equals; H)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>if (LoMask &equals;&equals; g_all_ones &amp;&amp; HiMask &equals;&equals; g_all_ones) &lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>*next_match &equals; *page_key;</entry>
</row>
<row>
<entry></entry>
<entry>return 2; /* the next-match has been found */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry>/* step 6: add in DIM bits of the current-quadrant&apos;s</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>derived-key into the next-match */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>element (DIM * K) / ORDER;</entry>
</row>
<row>
<entry></entry>
<entry>if ((DIM * K) % ORDER &gt; ORDER &minus; DIM)&lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>next_match&minus;&gt;hcode&lsqb;element&rsqb; &verbar;&equals; Lo &lt;&lt; (DIM * K) % ORDER;</entry>
</row>
<row>
<entry></entry>
<entry>next_match&minus;&gt;hcode&lsqb;element &plus; 1&rsqb; &verbar;&equals;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Lo &gt;&gt; ORDER &minus; (DIM * K) % ORDER;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>else</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>next_match&minus;&gt;hcode&lsqb;element&rsqb; &verbar;&equals;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="84PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Lo &lt;&lt; (DIM * K) &minus; element * ORDER;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>K&minus;&minus;;</entry>
</row>
<row>
<entry></entry>
<entry>if (Lo &gt; H) break; /* search can be completed more simply */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;/* end of while loop */</entry>
</row>
<row>
<entry></entry>
<entry>if ( K &lt; 0 )</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>return 1; /* the next-match has been found */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry>/* SEE ALGORITHM 2 (<cross-reference target="DRAWINGS">FIG.10B</cross-reference>) */</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>for (j &equals; K; j &gt; 0; j--)&lcub;</entry>
</row>
<row>
<entry>/* at his stage, we are no longer interseted in the value of bits in</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>the page-key; a next-match is guaranteed to exist - all that is</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>needed now is to find the lowest derived-key in the</entry>
</row>
<row>
<entry><highlight><superscript>&emsp;</superscript></highlight>current query region. */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>if (LoMask &equals;&equals; g_all_ones &amp;&amp; HiMask &equals;&equals; g_all_ones)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>return 1; /* the next-match has been found */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>mask &equals; 1 &lt;&lt; j;</entry>
</row>
<row>
<entry></entry>
<entry>for (i &equals; qLo &equals; qHi &equals; 0; i &lt; DIM; i&plus;&plus;)&lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>if (LoBound.hcode&lsqb;i&rsqb; &amp; mask) qLo &verbar;&equals; 1 &lt;&lt; (DIM&minus;1&minus;i);</entry>
</row>
<row>
<entry></entry>
<entry>if (HiBound.hcode&lsqb;i&rsqb; &amp; mask) qHi &verbar;&equals; 1 &lt;&lt; (DIM&minus;1&minus;i);</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>L_xor_H &equals; qLo {circumflex over (&thinsp;)} qHi; L_xor_H &equals; <highlight><superscript>&tilde;L</superscript></highlight>_xor_H;</entry>
</row>
<row>
<entry></entry>
<entry>for (Lo &equals; 0, Hi &equals; NUMPOINTS &minus; 1; Lo &excl;&equals; Hi ;)&lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>LoHi_H &equals; Lo &plus; (Hi &minus; Lo) / 2; HiLo_H &equals; LoHi_H &plus; 1;</entry>
</row>
<row>
<entry></entry>
<entry>tSL &equals; LoHi_H {circumflex over (&thinsp;)} LoHi_H / 2; tSH &equals; HiLo_H {circumflex over (&thinsp;)} HiLo_H / 2;</entry>
</row>
<row>
<entry></entry>
<entry>if (xJ % DIM &excl;&equals; 0)&lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>temp1 &equals; tSL &gt;&gt; xJ % DIM; temp2 &equals; tSL &lt;&lt; DIM &minus; xJ % DIM;</entry>
</row>
<row>
<entry></entry>
<entry>tSL&thinsp;&thinsp;&ensp;&equals; temp1 &verbar; temp2; tSL &amp;&equals; ((U_int)1 &lt;&lt; DIM) &minus; 1;</entry>
</row>
<row>
<entry></entry>
<entry>temp1 &equals; tSH &gt;&gt;xJ % DIM; temp2 &equals; tSH &lt;&lt; DIM &minus; xJ % DIM;</entry>
</row>
<row>
<entry></entry>
<entry>tSH&thinsp;&thinsp;&ensp;&equals; temp1 &verbar; temp2; tSH &amp;&equals; ((U_int)1 &lt;&lt; DIM) &minus; 1;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>partioning_dimension &equals; tSL {circumflex over (&thinsp;)} tSH;</entry>
</row>
<row>
<entry></entry>
<entry>LoHi_C &equals; W {circumflex over (&thinsp;)} tT {circumflex over (&thinsp;)} tSL;</entry>
</row>
<row>
<entry></entry>
<entry>if (&excl;(partioning_dimension &amp; L_xor_H) &verbar;&verbar;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>((partioning_dimension &amp; LoHi_C) &equals;&equals;</entry>
</row>
<row>
<entry></entry>
<entry>&thinsp;(partioning_dimension &amp; qLo)))</entry>
</row>
<row>
<entry></entry>
<entry>Hi &equals; LoHi_H;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>else Lo &equals; HiLo_H;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>if (&excl;HB_matches_RQ (Lo, qLo, L_xor_H, &amp;region, &amp;xJ, &amp;tT, &amp;W))</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>exit(1); /* an error has occurred */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>if (j &gt; 0)&lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>for (R_xor_L &equals; region {circumflex over (&thinsp;)} qLo, N &equals; DIM &minus; 1; R_xor_L;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="70PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>R_xor_L &gt;&gt;&equals; 1, N&minus;&minus;)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>if (R_xor_L &amp; 1)&lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="70PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>LoBound.hcode&lsqb;N&rsqb; &equals; 0; LoMask &verbar;&equals; 1 &lt;&lt; (DIM&minus;1&minus;N);</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>for (R_xor_H &equals; region {circumflex over (&thinsp;)} qHi, N &equals; DIM &minus; 1; R_xor_H;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="70PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>R_xor_H &gt;&gt;&equals; 1, N&minus;&minus;)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>if (R_xor_H &amp; 1)&lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="70PT" align="left"/>
<colspec colname="1" colwidth="189PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>HiBound.hcode&lsqb;N&rsqb; &equals; U_int_MAX;</entry>
</row>
<row>
<entry></entry>
<entry>HiMask &verbar;&equals; 1 &lt;&lt; (DIM&minus;1&minus;N);</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="56PT" align="left"/>
<colspec colname="1" colwidth="203PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>element &equals; (DIM * j) / ORDER;</entry>
</row>
<row>
<entry></entry>
<entry>if ((DIM * j) % ORDER &gt; ORDER &minus; DIM)</entry>
</row>
<row>
<entry></entry>
<entry>&lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>next_match&minus;&gt;hcode&lsqb;element&rsqb; &verbar;&equals; Lo &lt;&lt; (DIM * j) % ORDER;</entry>
</row>
<row>
<entry></entry>
<entry>next_match&minus;&gt;hcode&lsqb;element&plus;1&rsqb; &verbar;&equals;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="112PT" align="left"/>
<colspec colname="1" colwidth="147PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Lo &gt;&gt; ORDER &minus; (DIM * j) % ORDER;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>else</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="217PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>next_match&minus;&gt;hcode&lsqb;element&rsqb; &verbar;&equals;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="112PT" align="left"/>
<colspec colname="1" colwidth="147PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Lo &lt;&lt; (DIM * j) &minus; element * ORDER;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&rcub;</entry>
</row>
<row>
<entry></entry>
<entry>return 1; /* the next-match has been found */</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry>&rcub;</entry>
</row>
<row>
<entry>U_int H_nextmatch_RQ (Point LoBound, Point HiBound,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="231PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>Hcode *next_match, Hcode *page_key)&lcub;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="245PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>/* the 6-th to 8-th parameters are xJ, tT and W */</entry>
</row>
<row>
<entry></entry>
<entry>return HB_nextmatch_RQ (LoBound, HiBound, next_match,</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="OFFSET" colwidth="84PT" align="left"/>
<colspec colname="1" colwidth="175PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>page_key, ORDER &minus; 1, 0, 0, 0, 0, 0);</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259PT" align="left"/>
<tbody valign="top">
<row>
<entry>&rcub;</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0288" lvl="7"><number>&lsqb;0288&rsqb;</number> 5 Preferred Method of Use of the Invention </paragraph>
<paragraph id="P-0289" lvl="0"><number>&lsqb;0289&rsqb;</number> This Section describes the preferred method of use of the invention. </paragraph>
<paragraph id="P-0290" lvl="0"><number>&lsqb;0290&rsqb;</number> It is preferred that the order of curve used in the mapping is the same as the number of bits used by the unsigned integer data type supported by the computer programming language and its compiler used in the software implementation and that the smallest possible data type be used that can accommodate all values of any attribute domain of the multi-dimensional data. That is, the smallest practicable order of curve should be used, for reasons of computational efficiency. This is amplified further above in Section 1. </paragraph>
<paragraph id="P-0291" lvl="0"><number>&lsqb;0291&rsqb;</number> It is preferred that mapping calculations between n-dimensional values and one-dimensional values are carried out with the aid of state diagrams held in the volatile, or &lsquo;main&rsquo;, memory of the computer where the number of dimensions in the space, or the number of attributes of the multi-dimensional data, is less than or equal to 8 dimensions. Where a larger number of dimensions is required, mappings should be carried out by calculation without the aid of state diagrams. Use of state diagrams in 8 dimensions or less maximises the computational efficiency of the application, given the prior art in computer hardware technology. </paragraph>
<paragraph id="P-0292" lvl="0"><number>&lsqb;0292&rsqb;</number> Although any one-dimensional data structure may be used for the purposes of indexing, use of the B*-Tree is preferred since it is a simple, compact and well understood data structure. It is also preferred that the method of utilizing the storage capacity of pages of data is based on the design of this data structure in order for the database to be as compact as possible. </paragraph>
<paragraph id="P-0293" lvl="0"><number>&lsqb;0293&rsqb;</number> Although data pages need not be fixed-sized, it is preferred that they are as this simplifies the implementation and should be adequate for general purpose use of the invention. </paragraph>
<paragraph id="P-0294" lvl="0"><number>&lsqb;0294&rsqb;</number> It is preferred that the orientation of the Hilbert Curve used in the mapping is the same as that used in the description and examples in this document. There is no apparent benefit of choosing one orientation over another. Usage of the preferred orientation allows mapping and querying algorithms given in the aforementioned Technical Reports BBKCS-00-01 and BBKCS-00-02 and in the PhD thesis of the inventor to be used. These algorithms have been implemented and thoroughly tested for correctness of operation by the inventor. </paragraph>
<paragraph id="P-0295" lvl="0"><number>&lsqb;0295&rsqb;</number> How records of data are organized, ordered and represented on pages of storage is independent of the present invention. The detail of this aspect of the implementation of the invention needs only to allow for the redistribution of data between pages as they become full or when the number of datum-points stored on a page falls below a predetermined threshold. </paragraph>
<paragraph id="P-0296" lvl="0"><number>&lsqb;0296&rsqb;</number> Choice of the data capacity of a page of data is independent of the present invention but, for reasons of efficiency of operation, should ideally be a multiple of the size of the unit of transfer of data between secondary storage and main memory that is determined by the computer hardware on which the software is run and the characteristics of the computer operating system. The optimum capacity is likely to be influenced by the number of dimensions of the multi-dimensional data, the volume of data and how the database is used in terms of volume of updates and querying. The optimum capacity is likely to be chosen following practical experimentation. </paragraph>
<paragraph id="P-0297" lvl="0"><number>&lsqb;0297&rsqb;</number> The results of practical experimentation by the inventor suggest that whether the calculate_next_match algorithm is implemented iteratively or recursively is of little importance. A recursive implementation is, however, less difficult to effect, particularly in the case where calculation is used without the aid of state diagrams. </paragraph>
<paragraph id="P-0298" lvl="7"><number>&lsqb;0298&rsqb;</number> 5.1 An Example of the Querying Algorithm </paragraph>
<paragraph id="P-0299" lvl="0"><number>&lsqb;0299&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 11</cross-reference> shows the example 2 dimensional database given in <cross-reference target="DRAWINGS">FIG. 3</cross-reference> overlain by an example range query shown as a shaded rectangle. </paragraph>
<paragraph id="P-0300" lvl="0"><number>&lsqb;0300&rsqb;</number> FIGS. <highlight><bold>12</bold></highlight>A-<highlight><bold>12</bold></highlight>F illustrate an example of the operation of the calculate_next_match function described above and illustrated in FIGS. <highlight><bold>10</bold></highlight>A-<highlight><bold>10</bold></highlight>C. </paragraph>
<paragraph id="P-0301" lvl="0"><number>&lsqb;0301&rsqb;</number> The example shows how to calculate the next-match that is greater than the derived-key of a point lying outside of the query region and where the latter is greater than the previously calculated next-match. In relation to <cross-reference target="DRAWINGS">FIG. 11</cross-reference>, it shows how to calculate the derived-key of point N when the current-page-key is known to be the derived-key of point L. This example also illustrates how the search for the next-match can require a number of iterations that is greater than the order of the curve or height of the tree conceptual view of the Hilbert Curve. This occurs when an initially chosen search path fails to lead to the next-match and back-tracking is required to a higher and previously visited level of the tree prior to a second descent along an alternative path. </paragraph>
<paragraph id="P-0302" lvl="0"><number>&lsqb;0302&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 14</cross-reference> shows how the tree representation of the Hilbert Curve is traversed during the execution of the example query. </paragraph>
<paragraph id="P-0303" lvl="0"><number>&lsqb;0303&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 13</cross-reference> shows examples of how to determine which hyper-rectangular sub-spaces intersect with a query region in 2 dimensions. </paragraph>
</section>
<section>
<heading lvl="1">DESCRIPTION AND OPERATION-ALTERNATIVE EMBODIMENTS </heading>
<paragraph id="P-0304" lvl="0"><number>&lsqb;0304&rsqb;</number> The querying strategy already described in assumes that each page of data is indexed using the page-key that is the lowest derived-keys of any datum-point placed on it. </paragraph>
<paragraph id="P-0305" lvl="0"><number>&lsqb;0305&rsqb;</number> Where the page-key is the highest derived-key of any datum-point placed on it, current-page-key used in the algorithm is taken to be zero for the first time that the calculate_next_match function. In subsequent calls to the function, the current-page-key is taken to be the page-key of the page just searched plus one. </paragraph>
<paragraph id="P-0306" lvl="0"><number>&lsqb;0306&rsqb;</number> Where a pair of page-keys is used to index pages, once the next-match has been calculated by the calculate_next_match function, the index is searched and if the next-match is not found to lie between any page-key pair, the function is called again. The next time the function is called, it is passed the lowest page-key of a pair found in the index which is greater than or equal to the next-match as its page-key, or current-page-key, parameter. </paragraph>
<paragraph id="P-0307" lvl="0"><number>&lsqb;0307&rsqb;</number> The algorithm for the calculate_next_match function already described assumes an embodiment of the Hilbert Curve as defined by using either the state diagram method for mapping between n-dimensional and one-dimensional values described in the aforementioned Technical Report BBKCS-00-02 and the PhD thesis of the inventor or by using the calculation method described in the aforementioned Technical Report BBKCS-00-01 and the PhD thesis of the inventor. </paragraph>
<paragraph id="P-0308" lvl="0"><number>&lsqb;0308&rsqb;</number> An implementation of the calculate_next_match function that uses state diagrams can be used with any state diagram. A state diagram that defines one embodiment of the Hilbert Curve can simply be replaced by another state diagram that defines another embodiment. </paragraph>
<paragraph id="P-0309" lvl="0"><number>&lsqb;0309&rsqb;</number> Where mapping is carried out without the aid of state diagrams, the algorithm for calculating the next-match can be implemented in a similar manner to that already described. That is, those parts of the implementation which pertain to mapping or partial mapping calculations and the definition of the current-state and next-state need to be adapted to suit the particular mapping method used. </paragraph>
</section>
<section>
<heading lvl="1">CONCLUSION, RAMIFICATIONS AND SCOPE </heading>
<paragraph id="P-0310" lvl="0"><number>&lsqb;0310&rsqb;</number> The present invention includes the first algorithm devised to facilitate the querying of multi-dimensional data indexed using the Hilbert Curve. Thus for the first time it makes the utilization of the Hilbert Curve viable and so enables it to be practicably and usefully exploited to efficiently organise multi-dimensional data using a simple and compact yet flexible indexing method. </paragraph>
<paragraph id="P-0311" lvl="0"><number>&lsqb;0311&rsqb;</number> The indexing method when used with the querying algorithm effectively simulates the provision of all possible secondary indexes for multi-dimensional data without actually requiring them and which would not be practicable. </paragraph>
<paragraph id="P-0312" lvl="0"><number>&lsqb;0312&rsqb;</number> The partitioning strategy is simple and can be applied automatically without the intervention of a domain expert. </paragraph>
<paragraph id="P-0313" lvl="0"><number>&lsqb;0313&rsqb;</number> The querying algorithm facilitates the lazy retrieval of data in response to a query. </paragraph>
<paragraph id="P-0314" lvl="0"><number>&lsqb;0314&rsqb;</number> The partitioning method achieves a guaranteed high data page storage utilization. </paragraph>
<paragraph id="P-0315" lvl="0"><number>&lsqb;0315&rsqb;</number> The data store adapts well on update through insertion and deletion of data objects. </paragraph>
<paragraph id="P-0316" lvl="0"><number>&lsqb;0316&rsqb;</number> The index remains compact, typically its size is less than about 2 percent of the size of the data store itself. </paragraph>
<paragraph id="P-0317" lvl="0"><number>&lsqb;0317&rsqb;</number> While the above description contains many specificities, these should not be construed as limitations on the scope of the present invention, but rather as an exemplification of one preferred embodiment thereof. Many other variations are possible, as discussed below. </paragraph>
<paragraph id="P-0318" lvl="0"><number>&lsqb;0318&rsqb;</number> The querying algorithm can generally be stated as enabling the calculation of the lowest sequence number of a point lying on the Hilbert Curve and also lying within a rectangle in multi-dimensional space which is greater than or equal to the sequence number of some other arbitrary point in multi-dimensional space. As such, its application is not restricted to data storage and retrieval application. </paragraph>
<paragraph id="P-0319" lvl="0"><number>&lsqb;0319&rsqb;</number> The order in which the Hilbert Curve passes through points in multi-dimensional space can be determined differently by different mapping algorithms and any such algorithm is suitable in the data storage and retrieval application described here. Thus the Hilbert Curve is a concept that can be defined in more ways than one. </paragraph>
<paragraph id="P-0320" lvl="0"><number>&lsqb;0320&rsqb;</number> Similarly, any orientation of the Hilbert Curve, as defined by which &lsquo;corners&rsquo; of multi-dimensional space it begins and ends in, can be applied in the application. </paragraph>
<paragraph id="P-0321" lvl="0"><number>&lsqb;0321&rsqb;</number> The application and examples described refer to the &lsquo;C&rsquo; Programming language but any general purpose programming language may be used to implement the application. </paragraph>
<paragraph id="P-0322" lvl="0"><number>&lsqb;0322&rsqb;</number> Reference has been made to the B&plus; tree as a method of constructing the index but in practice any one dimensional indexing method can be utilized. </paragraph>
<paragraph id="P-0323" lvl="0"><number>&lsqb;0323&rsqb;</number> The present invention as described assumes fixed sized pages of storage but this is not a requirement. The implementation can equally support variable page sizes. </paragraph>
<paragraph id="P-0324" lvl="0"><number>&lsqb;0324&rsqb;</number> The present invention as described above regards pages of storage as corresponding to contiguous lengths of Hilbert Curve, some of the points on which correspond to data objects. In the preferred embodiment, the point with the lowest Hilbert Curve sequence number on a curve section is used as the index reference to the page. In an alternative embodiment, the highest sequence number of a point on a page&apos;s curve section can be used as the index reference. Alternatively, a page may be indexed using a pair of Hilbert Curve sequence numbers, one being the lowest sequence number of a data object stored on the page and the other being the highest sequence number of a data object stored on the page. In such an embodiment, successive pages in the data store correspond to sections of curve which are not contiguous. Between a pair of successive pages exist curve sections on which no actual data objects lie. This embodiment may assist in minimizing the number of pages which need to be searched in the complete execution of a query. If either or both of the data objects with the lowest and highest sequence numbers are subsequently deleted, the page&apos;s index entry may or may not be updated, depending on the detail of the implementation. </paragraph>
<paragraph id="P-0325" lvl="0"><number>&lsqb;0325&rsqb;</number> Accordingly, the scope of the present invention should be determined not by the embodiments illustrated, but by the appended claims and their legal equivalents. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">I claim: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method of storing multi-dimensional data, or multi-dimensional data points, in a multi-dimensional database and retrieving subsets of said multi-dimensional data according to the specification of a query comprising: 
<claim-text>providing a computer memory which is able to store said multi-dimensional data at a series of addresses in said memory, </claim-text>
<claim-text>providing a means of transforming by calculation of multi-dimensional points including said multi-dimensional data into one-dimensional values by mapping said multi-dimensional data to one-dimensional distance values along an approximation of a Hilbert space-filling curve that passes through all multi-dimensional points corresponding to possible data values in the domain of said multi-dimensional database, </claim-text>
<claim-text>providing a means of partitioning said multi-dimensional data into an ordered sequence of approximately equal sized subsets of said multi-dimensional data so that each said subset of said multi-dimensional data comprises multi-dimensional data that maps to lower said one-dimensional distance values than all succeeding said subsets of said multi-dimensional data, </claim-text>
<claim-text>providing a means of identifying each said subset of said multi-dimensional data together with the location in said computer memory in which each said subset of multi-dimensional data is stored, </claim-text>
<claim-text>providing a means of indexing locations in said computer memory of said subsets of said multi-dimensional data, </claim-text>
<claim-text>providing a means of specifying a query as a multi-dimensional rectangular region within said domain of said database, </claim-text>
<claim-text>providing a means of identifying for retrieval and searching which said subsets of said multi-dimensional data intersect with any said query, </claim-text>
<claim-text>whereby said database and its index adapt efficiently to insertion and deletion of said multi-dimensional data, and </claim-text>
<claim-text>whereby subsets of multi-dimensional data that intersect with a query region can be identified efficiently for searching and retrieval of multi-dimensional data that lies within the query region. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. A method according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein said means of identifying for retrieval and searching which said subsets of said multi-dimensional data intersect with any said query region comprises of the steps of: 
<claim-text>calculating the lowest said one-dimensional value corresponding to a multi-dimensional point lying within said query region and identifying from said index which subset of said multi-dimensional data will contain said multi-dimensional point, if it exists as a multi-dimensional data point in said database, and identifying from said index the location in said computer memory of said subset of said multi-dimensional data, </claim-text>
<claim-text>calculating the lowest one-dimensional value, if it exists, corresponding to a multi-dimensional point lying within said query region which is greater than or equal to the lowest one-dimensional value corresponding to any multi-dimensional point that may exist as a multi-dimensional data point and be contained within the succeeding subset of said multi-dimensional data identified in the previous step, </claim-text>
<claim-text>repeating the previous step zero or more times to identify further subsets of said multi-dimensional data that intersect with said query region. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. A method according to <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, wherein subsets of said multi-dimensional data that intersect with any specified query region which are identified are retrieved from said computer memory and searched for multi-dimensional data points that exist in said database, which are then outputted. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. A method of storing and querying multi-dimensional data comprising the steps of, 
<claim-text>A method for transforming multi-dimensional data points into one-dimensional values, using a bijective mapping between multi-dimensional points and one-dimensional values determined by the sequence in which an approximation of a Hilbert space-filling curve passes through the multi-dimensional points in the domain of a multi-dimensional database, which are stored in a one-dimensional index structure, comprising the steps of, </claim-text>
<claim-text>splitting data into a plurality of subsets, each corresponding to a length of the Hilbert space-filling curve, </claim-text>
<claim-text>computing an identifier for each subset selected from the group consisting of the one-dimensional distance value of the start of a section of Hilbert space-filling curve corresponding to the subset of data from the beginning of the Hilbert space-filling curve, the one-dimensional distance value of the end of a section of Hilbert space-filling curve corresponding to the subset of data from the beginning of the Hilbert space-filling curve and a pair of distance values on the section of Hilbert space-filling curve corresponding to the subset of data, wherein one is the lowest and the other is the highest one-dimensional value corresponding actual data points stored in the database and lying on the section of Hilbert space-filling curve, </claim-text>
<claim-text>storing each said subset in said index using the subset identifier as an index key. </claim-text>
<claim-text>using the index in calculating which subsets of said multi-dimensional intersect with the query, </claim-text>
<claim-text>using the index to retrieve candidate subsets of data, </claim-text>
<claim-text>searching candidate subsets of data and outputting data points which lie within the query region.</claim-text>
</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>14</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030004938A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030004938A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030004938A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030004938A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030004938A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030004938A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030004938A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030004938A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030004938A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00009">
<image id="EMI-D00009" file="US20030004938A1-20030102-D00009.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00010">
<image id="EMI-D00010" file="US20030004938A1-20030102-D00010.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00011">
<image id="EMI-D00011" file="US20030004938A1-20030102-D00011.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00012">
<image id="EMI-D00012" file="US20030004938A1-20030102-D00012.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00013">
<image id="EMI-D00013" file="US20030004938A1-20030102-D00013.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00014">
<image id="EMI-D00014" file="US20030004938A1-20030102-D00014.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00015">
<image id="EMI-D00015" file="US20030004938A1-20030102-D00015.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00016">
<image id="EMI-D00016" file="US20030004938A1-20030102-D00016.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00017">
<image id="EMI-D00017" file="US20030004938A1-20030102-D00017.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00018">
<image id="EMI-D00018" file="US20030004938A1-20030102-D00018.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
