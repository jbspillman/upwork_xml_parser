<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030002631A1-20030102-D00000.TIF SYSTEM "US20030002631A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030002631A1-20030102-D00001.TIF SYSTEM "US20030002631A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030002631A1-20030102-D00002.TIF SYSTEM "US20030002631A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030002631A1-20030102-D00003.TIF SYSTEM "US20030002631A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030002631A1-20030102-D00004.TIF SYSTEM "US20030002631A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030002631A1-20030102-D00005.TIF SYSTEM "US20030002631A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030002631A1-20030102-D00006.TIF SYSTEM "US20030002631A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030002631A1-20030102-D00007.TIF SYSTEM "US20030002631A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030002631A1-20030102-D00008.TIF SYSTEM "US20030002631A1-20030102-D00008.TIF" NDATA TIF>
<!ENTITY US20030002631A1-20030102-D00009.TIF SYSTEM "US20030002631A1-20030102-D00009.TIF" NDATA TIF>
<!ENTITY US20030002631A1-20030102-D00010.TIF SYSTEM "US20030002631A1-20030102-D00010.TIF" NDATA TIF>
<!ENTITY US20030002631A1-20030102-D00011.TIF SYSTEM "US20030002631A1-20030102-D00011.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030002631</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10150227</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20020517</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>H05G001/00</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>378</class>
<subclass>210000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>K-space based graphic application development system for a medical imaging system</title-of-invention>
</technical-information>
<continuity-data>
<continuations>
<continuation-in-part-of>
<parent-child>
<child>
<document-id>
<doc-number>10150227</doc-number>
<kind-code>A1</kind-code>
<document-date>20020517</document-date>
</document-id>
</child>
<parent>
<document-id>
<doc-number>09839055</doc-number>
<document-date>20010420</document-date>
<country-code>US</country-code>
</document-id>
</parent>
<parent-status>PENDING</parent-status>
</parent-child>
</continuation-in-part-of>
</continuations>
<continuations>
<continuation-in-part-of>
<parent-child>
<child>
<document-id>
<doc-number>09839055</doc-number>
<document-date>20010420</document-date>
<country-code>US</country-code>
</document-id>
</child>
<parent>
<document-id>
<doc-number>09721233</doc-number>
<document-date>20001122</document-date>
<country-code>US</country-code>
</document-id>
</parent>
<parent-status>PENDING</parent-status>
</parent-child>
</continuation-in-part-of>
</continuations>
</continuity-data>
<inventors>
<first-named-inventor>
<name>
<given-name>Ajeetkumar</given-name>
<family-name>Gaddipati</family-name>
</name>
<residence>
<residence-us>
<city>Waukesha</city>
<state>WI</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Conrad</given-name>
<middle-name>J.</middle-name>
<family-name>Dirckx</family-name>
</name>
<residence>
<residence-us>
<city>Milwaukee</city>
<state>WI</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Roshy</given-name>
<middle-name>James</middle-name>
<family-name>Francis</family-name>
</name>
<residence>
<residence-us>
<city>Waukesha</city>
<state>WI</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Gabriel</given-name>
<family-name>Fernandez</family-name>
</name>
<residence>
<residence-us>
<city>Menomonee Falls</city>
<state>WI</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Mark</given-name>
<middle-name>T.</middle-name>
<family-name>Radick</family-name>
</name>
<residence>
<residence-us>
<city>Muskego</city>
<state>WI</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>QUARLES &amp; BRADY LLP</name-1>
<name-2></name-2>
<address>
<address-1>411 E. WISCONSIN AVENUE</address-1>
<address-2>SUITE 2040</address-2>
<city>MILWAUKEE</city>
<state>WI</state>
<postalcode>53202-4497</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A sequence description defining the events for traversing k-space during a medical imaging scan is defined through a k-space graphical view, thereby providing an easy programming interface for MR physicists. From the k-space view, data elements can be generated by object-oriented sequence description components in the form of predefined sequences. The data elements generated by the predefined sequences are stored in a table, the lines in the table defining an ordered list of pulse segments associated with each trajectory in k-space, the table can also hold information on time ordering or sequencing of k-space trajectories, desired triggering for each k-space trajectory and similar data objects. The k-space description/configuration of sequences is then translated to a group of downloadable sequence components. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> The field of the invention is medical imaging systems, and particularly, systems for developing software applications for such imaging systems. </paragraph>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> There are many types of medical imaging systems. The primary distinction between the different systems is the medical imaging modality that is used, such as, x-ray, magnetic resonance, ultrasound or nuclear. In addition, a broad range of capabilities and features are typically offered in each imaging modality. For example, a magnetic resonance imaging (&ldquo;MRI&rdquo;) system may be offered with a range of polarizing magnetic strengths and configurations and with a range of different optional features such as magnetic resonance angiography (&ldquo;MRA&rdquo;), cardiac imaging and functional magnetic resonance imaging (&ldquo;fMRI&rdquo;). </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> Despite the many differences, medical imaging systems have a number of basic functions in common. All medical imaging systems include an operator interface which enables a particular image acquisition to be prescribed, a data acquisition apparatus which uses one of the imaging modalities to acquire data from the subject, an image reconstruction processor for reconstructing an image using acquired data, and storage apparatus for storing images and associated patient information. Typically, hardware is designed to carry out these functions and system software is designed and written for each hardware configuration. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> A medical imaging system contains application programs which direct the imaging system to perform particular types of scans, image reconstructions and post processing applications. For example, an MRI system may include application software which directs the imaging system to perform a fast spin-echo scan, or a fast gradient-recalled echo scan, or a functional MRI scan, or a cardiac cine scan. The application software also directs the imaging system to reconstruct images from acquired data. Typically, a medical imaging system will include software programs to reconstruct one or more images from a set of acquired data, wherein the example, either stationary skeletal or tissue images, or images of blood flow through a body. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> In each of these systems, pulse waveforms, sequencing including RF and gradient waveform synchronization, slice control, and other sequencing functions, and signal acquisition control is achieved by programming the system using conditional logic structures, typically with a high level language such as C, C&plus;&plus;, Java or other common programming languages. While these types of programming methods are well-suited to computer scientists and other professionals, the MR physicists responsible for programming pulse sequences on MRI systems are generally not trained in programming, but rather to design diagnostic imaging applications by changing pulses, pulse parameters, and the order in which the pulses are played for different parts of K-space. Therefore, MR physicists typically must be trained to program pulse sequences on the job. Presently, the average time for MR physicists to become proficient in pulse sequence design is said to be around two years. Even after this training period, MR physicists often make mistakes or introduce software bugs in this part of MR Image acquisition applications. Because of the need to program these pulse sequences, typical MR systems therefore waste time and efficiency. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> Problems associated with sequence programming are, rather than diminishing, becoming increasingly acute as pulse sequences and acquisition methods become increasingly fast and increasingly complex. As a result of increased complexity, it is also becoming increasingly challenging to keep track of the various synchronization points between RF and gradient waveforms and control packets and, further, to change these parameters depending on the image acquisition protocol state. Currently, an application often switches pulse segments being played (in both number and order) based on current &lsquo;phase encode&rsquo;, current &lsquo;slice&rsquo;, current &lsquo;number of excitation&rsquo; or current acquisition, and any combination of these states. When more demanding control tasks (e.g., cardiac and respiratory gating/compensation sequencing logic) are added, the complexity of the design is increased quickly. These sequences, therefore, are difficult and time consuming to program correctly, and to monitor to determine whether the programming has been accomplished correctly. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> Furthermore, as the number of applications grows, the amount and complexity of the application software code becomes increasingly difficult to maintain. As a result, the addition of new applications to the imaging system becomes increasingly difficult. Furthermore, because of the difficulty of writing and compiling application software, it is extremely difficult for users of medical imaging systems to experiment with new methods of scanning and particularly, of reconstructing data. To modify the scan and reconstruction procedures, trained programmers and a significant degree of down time of the machine can be required. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> The present invention is a method for programming a medical imaging scan sequence in k-space. A user is provided with an interface including a graphic view of k-space for a medical imaging scan illustrating a plurality of case-based trajectories in the k-space. Canned program parameters are assigned to executable sequence description components to provide conditional data directing the flow of logic for sequencing the traversal of k-space. The method can be used to program the events for traversing k-space, or to modify events. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> A general object of the invention is to provide a method for programming a sequence description for traversing k-space in a medical imaging system, wherein object data is assigned to each of a plurality of executable sequence description components which define a sequence of events for traversing of k-space. The object data is stored in a class diagram table which provides an ordered list of pulse sequences to be performed in run time. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> Preferably, the application development system comprises a series of predefined, executable code segments with defined input and output links. The executable code segments can be dragged and dropped onto a graphic building area, and linked together graphically through the connection points to provide application code, which is serialized and downloaded to application specific processors for execution. The graphic building area comprises a plurality of icons which can be easily linked together with a mouse or other input device, thereby making construction and compilation of an imaging application or a specific segment of an imaging application very easy. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> In addition to providing a simple and easy way to program applications, the graphical building area is particularly suited to the development and manipulation of image reconstruction pipelines. Data processing steps for image reconstruction can be graphically modified in real time to modify or improve both collected and visualized data. During real-time processing of an image, the user can modify various parameters, including filtering and threshold parameters, dynamic range and sampling parameters, image resolution, and data flow control in and out of a reconstruction processing pipeline. After a modification has been made, an indication of a change of process and the programming code for processing the acquired data is serialized and downloaded to a data processing board. The data processing board and/or an associated processor preferably translates the programming code to a low level language such as C or assembly which can operate at an appropriate speed to process real-time data. During real-time data acquisition and processing, therefore, a number of data processing parameters and reconstruction parameters can be modified and forwarded to the processing board to modify or improve data imaging and reconstruction.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a block diagram of an MRI system which employs the preferred embodiment of the invention; </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a block diagram of functional components in a workstation which forms part of the MRI system of <cross-reference target="DRAWINGS">FIG. 1</cross-reference>; </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a block diagram of the software architecture of a preferred embodiment of an application development system which employs the present invention; </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a pictorial representation of a display produced by a visual component assembler which forms part of the software architecture of <cross-reference target="DRAWINGS">FIG. 3</cross-reference>; </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a block diagram of an imaging system which employs the present invention; </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is a pictorial display of an alternative embodiment of a workspace region in the display of <cross-reference target="DRAWINGS">FIG. 4</cross-reference>; </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> is a pictorial display of a preferred embodiment of a framework, workspace region and graphic building area in the display of <cross-reference target="DRAWINGS">FIG. 4</cross-reference>; </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> is a pictorial display of a properties portion of the display in <cross-reference target="DRAWINGS">FIG. 4</cross-reference> depicting an rf pulse component; and </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference> is a pictorial display showing a graphic plot of the rf pulse component of <cross-reference target="DRAWINGS">FIG. 8</cross-reference>. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10</cross-reference> is a pictorial display of a graphic plot of the traversal of k-space as defined by a sequence description and associated menu for revising the description. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 11</cross-reference> is a block diagram illustrating entry of data into the k-space graphical view, the associated conditional data table, and the resultant executable code. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 12</cross-reference> is a pictorial display of a graphical building area illustrating the nesting of conditional logical structures. </paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">GENERAL DESCRIPTION OF THE INVENTION </heading>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> Referring particularly to <cross-reference target="DRAWINGS">FIG. 5, a</cross-reference> medical imaging system includes imaging apparatus <highlight><bold>110</bold></highlight> comprised of mechanical and electrical hardware elements that are operated during a scan to acquire image data. The imaging system also includes data processing apparatus <highlight><bold>112</bold></highlight> that is operated to reconstruct images using the acquired image data. To operate the system and to enter a scan prescription an operator input device <highlight><bold>114</bold></highlight>, such as a keyboard and control panel, is provided, a display device <highlight><bold>116</bold></highlight> is provided to present the images for visualization and a storage device <highlight><bold>117</bold></highlight>, such as a hard disc drive, is provided to archive acquired images. The particular imaging modality used, and the complexity and power of these hardware elements varies substantially from one system to the next. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> The system includes a workstation <highlight><bold>118</bold></highlight> which is programmed in a machine independent language, such as Java<highlight><bold>198</bold></highlight> , to provide a user interface <highlight><bold>120</bold></highlight> that enables an operator to enter scan parameters using the operator input device <highlight><bold>114</bold></highlight>. The workstation <highlight><bold>118</bold></highlight> is programmed to produce a scan description <highlight><bold>122</bold></highlight>, which in its simplest configuration contains image acquisition description components and data processing description components that contain information required by the imaging apparatus <highlight><bold>110</bold></highlight> and data processing apparatus <highlight><bold>112</bold></highlight> to perform the prescribed scan. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> Prior to run time, a snap shot of the scan description <highlight><bold>122</bold></highlight> is downloaded to a plurality of servers which control the imaging system hardware apparatus. In the simplest configuration these include an image acquisition server <highlight><bold>124</bold></highlight> and a data processing server <highlight><bold>126</bold></highlight> which operate the respective imaging apparatus <highlight><bold>110</bold></highlight> and data processing apparatus <highlight><bold>112</bold></highlight>. When provided with the scan description components, the servers&apos; programs direct the image system hardware apparatus to perform the prescribed scan. A data store server <highlight><bold>113</bold></highlight> directs the storage device <highlight><bold>117</bold></highlight> to save the images along with associated patient information. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> The particular scan or operation that is performed by the medical imaging system is directed by an application program stored in the workstation <highlight><bold>118</bold></highlight>. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> The application program is produced using an application development system that runs on the workstation <highlight><bold>118</bold></highlight> or a separate workstation (not shown). The application development system enables the user to create a new application program by selecting objects, or components, written in an object-oriented programming language, from a component library, and assemble them using a visual component assembler. The instance variables of selected components are displayed and may be edited for the new application program. The assembled components are instantiated and saved as a new application program which may be reconstituted for use on the medical imaging system. Instantiation is achieved using a serialization process in which the hierarchical relationship of components and their instance variables are stored. </paragraph>
</section>
<section>
<heading lvl="1">DESCRIPTION OF THE PREFERRED EMBODIMENT </heading>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> Referring particularly to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, the preferred embodiment of the invention is employed to operate an MRI system. The MRI system includes a workstation <highlight><bold>10</bold></highlight> having a display <highlight><bold>12</bold></highlight> and a keyboard <highlight><bold>14</bold></highlight>. The workstation <highlight><bold>10</bold></highlight> includes a processor <highlight><bold>16</bold></highlight> which is a programmable machine commercially available from Silicon Graphics, Inc. It is based on a 64-bit microprocessor manufactured by Intel and it runs the Linux operating system. The workstation <highlight><bold>10</bold></highlight> provides the operator interface which enables scan prescriptions to be entered into the MRI system. As will be described in more detail below, the workstation <highlight><bold>10</bold></highlight> will run one or more Java&trade; virtual machines which will run code which is programmed in the Java&trade; language that is fully transportable to any other programmable machine which is Java&trade; compatible. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> The workstation <highlight><bold>10</bold></highlight> is coupled to four servers: a pulse sequence server <highlight><bold>18</bold></highlight>; a data acquisition server <highlight><bold>20</bold></highlight>; a data processing server <highlight><bold>22</bold></highlight>, and a data store server <highlight><bold>23</bold></highlight>. In the preferred embodiment the data store server <highlight><bold>23</bold></highlight> is performed by the workstation processor <highlight><bold>16</bold></highlight> and associated disc drive interface circuitry. The remaining three servers <highlight><bold>18</bold></highlight>, <highlight><bold>20</bold></highlight> and <highlight><bold>22</bold></highlight> are performed by separate processors mounted in a single enclosure and interconnected using a 64-bit backplane bus structure based on the PCI standard for industrial and telecommunications applications called &ldquo;CompactPCI&rdquo;. The pulse sequence server <highlight><bold>18</bold></highlight> employs a 366 MHz microprocessor model PPC750 and a quad communication controller model MPC860T manufactured by Motorola, Inc. The data acquisition server <highlight><bold>20</bold></highlight> and data processing server <highlight><bold>22</bold></highlight> both employ the same 366 MHz microprocessor and the data processing server <highlight><bold>22</bold></highlight> further includes one or more array processors based on parallel vector processors commercially available from Mercury Computer Systems, Inc. as the PowerPC<highlight><superscript>198 </superscript></highlight>. Another 366 MHz microprocessor (not shown) serves as a hardware controller on the PCI bus structure and it controls a quad communication controller model MPC860T manufactured by Motorola, Inc. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> The workstation <highlight><bold>10</bold></highlight> and each processor for the servers <highlight><bold>18</bold></highlight>, <highlight><bold>20</bold></highlight> and <highlight><bold>22</bold></highlight> are connected to a 100 Base T Ethernet serial communications network. This serial network conveys data that is downloaded to the servers <highlight><bold>18</bold></highlight>, <highlight><bold>20</bold></highlight> and <highlight><bold>22</bold></highlight> from the workstation <highlight><bold>10</bold></highlight> and it conveys tag data that is communicated between the servers and between the workstation and the servers. In addition, a high speed data link using the BIT3 protocol is provided between the data processing server <highlight><bold>22</bold></highlight> and the workstation <highlight><bold>10</bold></highlight> in order to convey image data to the data store server <highlight><bold>23</bold></highlight>. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> The pulse sequence server <highlight><bold>18</bold></highlight> functions in response to program elements downloaded from the workstation <highlight><bold>10</bold></highlight> to operate a gradient system <highlight><bold>24</bold></highlight> and an RF system <highlight><bold>26</bold></highlight>. Gradient waveforms necessary to perform the prescribed scan are produced and applied to the gradient system <highlight><bold>24</bold></highlight> which excites gradient coils in an assembly <highlight><bold>28</bold></highlight> to produce the magnetic field gradients G<highlight><subscript>x</subscript></highlight>, G<highlight><subscript>y </subscript></highlight>and G<highlight><subscript>z </subscript></highlight>used for position encoding NMR signals. The gradient coil assembly <highlight><bold>28</bold></highlight> forms part of a magnet assembly <highlight><bold>30</bold></highlight> which includes a polarizing magnet <highlight><bold>32</bold></highlight> and a whole-body RF coil <highlight><bold>34</bold></highlight>. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> RF excitation waveforms are applied to the RF coil <highlight><bold>34</bold></highlight> by the RF system <highlight><bold>26</bold></highlight> to perform the prescribed magnetic resonance sequence. Responsive NMR signals detected by the RF coil <highlight><bold>34</bold></highlight> are received by the RF system <highlight><bold>26</bold></highlight>, amplified, demodulated, filtered and digitized under direction of commands produced by the pulse sequence server <highlight><bold>18</bold></highlight>. Exemplary RF systems are described in U.S. Pat. No. 4,952,877 and U.S. Pat. No. 4,992,736. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> The pulse sequence server <highlight><bold>18</bold></highlight> also optionally receives patient data from a physiological acquisition controller <highlight><bold>36</bold></highlight>. The controller <highlight><bold>36</bold></highlight> receives signals from a number of different sensors connected to the patient, such as ECG signals from electrodes or respiratory signals from a bellows. Such signals are typically used by the pulse sequence server <highlight><bold>18</bold></highlight> to synchronize the performance of the scan. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> The pulse sequence server <highlight><bold>18</bold></highlight> also connects to a scan room interface circuit <highlight><bold>38</bold></highlight> which receives signals from various sensors associated with the condition of the patient and the magnet system. It is also through the scan room interface circuit <highlight><bold>38</bold></highlight> that a patient positioning system <highlight><bold>40</bold></highlight> receives commands to move the patient to desired positions during the scan. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> It should be apparent that the pulse sequence server <highlight><bold>18</bold></highlight> performs real-time control of MRI system elements during a scan. As a result, it is necessary that its hardware elements be operated with program instructions that are executed in a timely manner. As will be explained in more detail below, the pulse sequence server <highlight><bold>18</bold></highlight> is controlled during run-time by programs written in a low level programming language such as assembler, C or C&plus;&plus;. The description components for a scan prescription are downloaded from the workstation <highlight><bold>10</bold></highlight> in the form of objects. The pulse sequence server <highlight><bold>18</bold></highlight> contains programs which receive these objects using a serialization mechanism. The pulse sequence server <highlight><bold>18</bold></highlight> also includes a program which converts the objects to C&plus;&plus; objects that are employed by the run-time programs. In the preferred embodiment Java<highlight><superscript>198</superscript></highlight> objects are downloaded and the Java&trade; serialization mechanism is employed. The pulse sequence server <highlight><bold>18</bold></highlight> thus includes both hardware independent programs written in Java&trade; and hardware dependent programs. It is contemplated that Java&trade; interpreters will eventually become fast enough that nearly all programs run on the pulse sequence server <highlight><bold>18</bold></highlight> will be written in hardware independent form. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> The digitized NMR signal samples produced by the RF system <highlight><bold>26</bold></highlight> are received by the data acquisition server <highlight><bold>20</bold></highlight>. The data acquisition server <highlight><bold>20</bold></highlight> operates in response to description components downloaded from the workstation <highlight><bold>10</bold></highlight> to receive the real-time NMR data and provide buffer storage such that no data is lost by data overrun. In some scans the data acquisition server <highlight><bold>20</bold></highlight> does little more than pass the acquired NMR data to the data processor server <highlight><bold>22</bold></highlight>. However, in scans which require information derived from acquired NMR data to control the further performance of the scan, the data acquisition server <highlight><bold>20</bold></highlight> is programmed to produce such information and convey it to the pulse sequence server <highlight><bold>18</bold></highlight>. For example, during prescans NMR data is acquired and used to calibrate the pulse sequence performed by the pulse sequence server <highlight><bold>18</bold></highlight>. Navigator signals may be acquired during a scan and used to adjust RF or gradient system operating parameters or to control the view order in which k-space is sampled. And, the data acquisition server <highlight><bold>20</bold></highlight> may be employed to process NMR signals used to detect the arrival of contrast agent in an MRA scan as described in co-pending U.S. Pat. appln. Ser. No. 08/635,078 filed Apr. 19, 1996 and entitled &ldquo;Method For Performing Magnetic Resonance Angiography Using a Contrast Agent&rdquo;. In all these examples the data acquisition server <highlight><bold>20</bold></highlight> acquires NMR data and processes it in real-time to produce information which is used to control the scan. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> As with the pulse sequence server <highlight><bold>18</bold></highlight>, the hardware elements of the data acquisition server <highlight><bold>20</bold></highlight> are operated at run-time with program instructions in a programming language such as assembler, C or C&plus;&plus;. As will be explained in more detail below, the directions for its operation during a scan are downloaded from the workstation <highlight><bold>10</bold></highlight> in the form of objects. A server proxy receives the objects using the serialization mechanism and the downloaded objects are converted to C&plus;&plus; objects that are employed to operate the data acquisition server <highlight><bold>20</bold></highlight> during run-time. As indicated above, Java&trade; objects are downloaded in the preferred embodiment using the Java&trade; serialization mechanism. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> The data processing server <highlight><bold>22</bold></highlight> receives NMR data from the data acquisition server <highlight><bold>20</bold></highlight> and processes it in accordance with description components downloaded from the workstation <highlight><bold>10</bold></highlight>. Such processing may include, for example: Fourier transformation of raw k-space NMR data to produce two or three-dimensional images; the application of filters to a reconstructed image; the performance of a back projection image reconstruction of acquired NMR data; the calculation of functional MR images; the calculation of motion or flow images, etc. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> Images reconstructed by the data processing server <highlight><bold>22</bold></highlight> are conveyed back to the workstation <highlight><bold>10</bold></highlight> where they are stored. Real-time images are stored in a data base memory cache (not shown) from which they may be output to operator display <highlight><bold>12</bold></highlight> or a display <highlight><bold>42</bold></highlight> which is located near the magnet assembly <highlight><bold>30</bold></highlight> for use by attending physicians. Batch mode images or selected real time images are stored in a host database on disc storage <highlight><bold>44</bold></highlight>. When such images have been reconstructed and transferred to storage, the data processing server <highlight><bold>22</bold></highlight> notifies the data store server <highlight><bold>23</bold></highlight> on the workstation <highlight><bold>10</bold></highlight>. The workstation <highlight><bold>10</bold></highlight> may be used by an operator to archive the images, produce films, or send the images via a network to other facilities. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> Directions for the particular operations to be performed by the data processing server <highlight><bold>22</bold></highlight> are downloaded from the workstation <highlight><bold>10</bold></highlight>. The time critical functions are performed with programs written in assembler, C or C&plus;&plus; and the downloaded Java&trade; object directions must be converted to corresponding executable code as described above. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> As indicated above, the workstation <highlight><bold>10</bold></highlight> is a Java&trade; virtual machine which executes programs written in the Java&trade; programming language. The workstation software is structured to perform &ldquo;applications&rdquo; which may be selected and run by an operator. Such applications correspond to clinical imaging procedures and may include, for example: </paragraph>
<paragraph id="P-0043" lvl="2"><number>&lsqb;0043&rsqb;</number> perform a scan using an FSE pulse sequence; </paragraph>
<paragraph id="P-0044" lvl="2"><number>&lsqb;0044&rsqb;</number> conduct a CEMRA dynamic study; </paragraph>
<paragraph id="P-0045" lvl="2"><number>&lsqb;0045&rsqb;</number> perform an fMRI study; </paragraph>
<paragraph id="P-0046" lvl="2"><number>&lsqb;0046&rsqb;</number> perform a runoff vascular study </paragraph>
<paragraph id="P-0047" lvl="2"><number>&lsqb;0047&rsqb;</number> perform image post processing </paragraph>
<paragraph id="P-0048" lvl="2"><number>&lsqb;0048&rsqb;</number> filming </paragraph>
<paragraph id="P-0049" lvl="2"><number>&lsqb;0049&rsqb;</number> networking </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> An application is a collection of Java&trade; objects stored in an &ldquo;application container&rdquo; that may be selected by an operator to perform a scan. Referring particularly to <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, each application container includes a Java&trade; application controller component <highlight><bold>46</bold></highlight> which directs other Java&trade; components in the container to perform the scan. These other components include a prescription controller <highlight><bold>52</bold></highlight> which includes a user interface component <highlight><bold>53</bold></highlight> and a prescription assistant component <highlight><bold>55</bold></highlight> that enable an operator to control the procedure performed by the application. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> The application container also includes scan descriptions <highlight><bold>50</bold></highlight>. These scan descriptions are downloaded to the servers <highlight><bold>18</bold></highlight>, <highlight><bold>20</bold></highlight>, <highlight><bold>22</bold></highlight> and <highlight><bold>23</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 1</cross-reference>) and used by those servers to perform the prescribed scan. The stored scan descriptions <highlight><bold>50</bold></highlight> are unique for every different application. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> The preferred embodiment of the present invention is an application development system which produces application programs for this MRI system. This application program is a collection of interrelated Java&trade; objects within the application container Java&trade; object. These objects are selected and edited using tools in the application development system. The application development system may reside on the MRI system workstation <highlight><bold>10</bold></highlight>, or it may reside on a separate, stand alone workstation of similar structure and capability. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> After the application program is developed, the application container object is serialized and stored in the disc storage <highlight><bold>44</bold></highlight>. When the operator of the MRI system selects the application program, the corresponding serialized application container object is read from the disc memory <highlight><bold>44</bold></highlight> and reconstituted as shown in <cross-reference target="DRAWINGS">FIG. 2</cross-reference> to operate the MRI system. To better understand the requirements of the application development system, the operations performed by the MRI system under the direction of the application program will now be described. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> The application controller <highlight><bold>46</bold></highlight> includes an application state object <highlight><bold>48</bold></highlight> which maintains the state of the application as the scan is performed. The possible states during a life cycle of an application are as follows: </paragraph>
<paragraph id="P-0055" lvl="2"><number>&lsqb;0055&rsqb;</number> Initialization </paragraph>
<paragraph id="P-0056" lvl="2"><number>&lsqb;0056&rsqb;</number> Prescribing </paragraph>
<paragraph id="P-0057" lvl="2"><number>&lsqb;0057&rsqb;</number> Prescribed </paragraph>
<paragraph id="P-0058" lvl="2"><number>&lsqb;0058&rsqb;</number> Downloading </paragraph>
<paragraph id="P-0059" lvl="2"><number>&lsqb;0059&rsqb;</number> Downloaded </paragraph>
<paragraph id="P-0060" lvl="2"><number>&lsqb;0060&rsqb;</number> Prescanning </paragraph>
<paragraph id="P-0061" lvl="2"><number>&lsqb;0061&rsqb;</number> Prescanned </paragraph>
<paragraph id="P-0062" lvl="2"><number>&lsqb;0062&rsqb;</number> Batch Scanning </paragraph>
<paragraph id="P-0063" lvl="2"><number>&lsqb;0063&rsqb;</number> Real Time Scanning </paragraph>
<paragraph id="P-0064" lvl="2"><number>&lsqb;0064&rsqb;</number> Scan Paused </paragraph>
<paragraph id="P-0065" lvl="2"><number>&lsqb;0065&rsqb;</number> Scanned </paragraph>
<paragraph id="P-0066" lvl="2"><number>&lsqb;0066&rsqb;</number> Reconstructed </paragraph>
<paragraph id="P-0067" lvl="2"><number>&lsqb;0067&rsqb;</number> Visualized. </paragraph>
<paragraph id="P-0068" lvl="7"><number>&lsqb;0068&rsqb;</number> This life cycle is driven by commands from the application container (like initialize application), by commands from the operator (like start scan) and by commands generated internally by the application (like scan done). </paragraph>
<paragraph id="P-0069" lvl="0"><number>&lsqb;0069&rsqb;</number> When the operator initially selects the application, the application initializes and changes to the &ldquo;prescribing state&rdquo; and the prescription controller <highlight><bold>52</bold></highlight> is enabled to interact with the scan description components <highlight><bold>50</bold></highlight> to determine what scan parameters must be specified by the operator (e.g. TR, number of slices, location of FOV, flip angle) and determine if the prescription is complete and valid. The prescription controller <highlight><bold>52</bold></highlight> then signals the application state object <highlight><bold>48</bold></highlight> to switch to the &ldquo;prescribed&rdquo; state and download, prescan and scan buttons on the control panel are enabled. </paragraph>
<paragraph id="P-0070" lvl="0"><number>&lsqb;0070&rsqb;</number> If the operator hits the &ldquo;download&rdquo; button, the application state object <highlight><bold>48</bold></highlight> changes to the &ldquo;download state&rdquo; and the application controller <highlight><bold>46</bold></highlight> employs a snap shot controller <highlight><bold>54</bold></highlight> to issue snap shot and download commands. As will be described in more detail below, these commands cause the scan descriptions <highlight><bold>50</bold></highlight> to be downloaded to the servers <highlight><bold>18</bold></highlight>, <highlight><bold>20</bold></highlight>, <highlight><bold>22</bold></highlight> and <highlight><bold>23</bold></highlight>. The snap shot controller <highlight><bold>54</bold></highlight> receives &ldquo;download done&rdquo; notification back from each of the servers <highlight><bold>18</bold></highlight>, <highlight><bold>20</bold></highlight>, <highlight><bold>22</bold></highlight> and <highlight><bold>23</bold></highlight>, and when all four servers have been downloaded, the application state object <highlight><bold>48</bold></highlight> is changed to the &ldquo;downloaded&rdquo; state. </paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> If the operator hits the scan button, the application state object <highlight><bold>48</bold></highlight> will change to the scan mode and a scan controller <highlight><bold>56</bold></highlight> is employed to issue a scan command to the pulse sequence server <highlight><bold>18</bold></highlight>. The next state transition is governed by the scanning mode i.e., real-time or batch. The behavior of the application in the two modes is very different and so there are two different scanning states. If in real-time mode, the application is set to a &ldquo;real-time scanning&rdquo; state and if in batch mode, the application state is set to a &ldquo;batch scanning&rdquo; state. When in the real-time mode, if the user chooses to pause the scan, the application will transition to a &ldquo;scan paused&rdquo; state. If scanning is resumed, the application goes back to the real-time scanning state. In real-time scanning state, the application can be edited and edited descriptions will be downloaded even while the scanning is in progress. However, the application will not make a state transition; instead, the same state will be characterized to allow editing and downloading. It is this behavior of the real-time scanning state that differentiates it from the batch scanning state. </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> The application will make a transition to the &ldquo;scanned&rdquo; state when the operator hits the &ldquo;stop scan&rdquo; button. Also, if the application is in the batch scanning mode of operation, the pulse sequence server <highlight><bold>18</bold></highlight> notifies the application controller <highlight><bold>46</bold></highlight> when the scan is completed. The application state object changes to the &ldquo;scanned&rdquo; state in either event. </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> When the data processing server <highlight><bold>22</bold></highlight> completes reconstruction of the acquired images, the application controller <highlight><bold>46</bold></highlight> is notified and the application state object <highlight><bold>48</bold></highlight> is changed to the &ldquo;reconstructed&rdquo; state. This indicates to the workstation <highlight><bold>10</bold></highlight> that reconstructed images are available on disk <highlight><bold>44</bold></highlight> for display or further processing. </paragraph>
<paragraph id="P-0074" lvl="0"><number>&lsqb;0074&rsqb;</number> The scan descriptions <highlight><bold>50</bold></highlight> contain a set of components that serve to collect scan parameters using the prescription controller <highlight><bold>52</bold></highlight>, and to organize those prescription scan parameters into a set of smaller components that can be downloaded to the servers <highlight><bold>18</bold></highlight>, <highlight><bold>20</bold></highlight>, <highlight><bold>22</bold></highlight> and <highlight><bold>23</bold></highlight>. On the servers <highlight><bold>18</bold></highlight>, <highlight><bold>20</bold></highlight>, <highlight><bold>22</bold></highlight> and <highlight><bold>23</bold></highlight>, those downloaded components direct the operation of the hardware in order to carry out the prescribed scan. </paragraph>
<paragraph id="P-0075" lvl="0"><number>&lsqb;0075&rsqb;</number> There are different description types within each application to provide logical groupings of components to deal with different aspects of executing an MR scan. These description types are: </paragraph>
<paragraph id="P-0076" lvl="2"><number>&lsqb;0076&rsqb;</number> Pulse Description; </paragraph>
<paragraph id="P-0077" lvl="2"><number>&lsqb;0077&rsqb;</number> Sequence Description; </paragraph>
<paragraph id="P-0078" lvl="2"><number>&lsqb;0078&rsqb;</number> Acquisition Description; </paragraph>
<paragraph id="P-0079" lvl="2"><number>&lsqb;0079&rsqb;</number> Data Processing Description; </paragraph>
<paragraph id="P-0080" lvl="2"><number>&lsqb;0080&rsqb;</number> Data Store Description. </paragraph>
<paragraph id="P-0081" lvl="7"><number>&lsqb;0081&rsqb;</number> The pulse description includes components that define and control the waveforms to be played out on the gradient system and the RF system hardware, along with hardware control components. These components control the dynamic aspects of the waveforms and hardware in response to events produced at run-time by components of the sequence description. This description also includes components that control the filtering of NMR signals received by the RF system <highlight><bold>26</bold></highlight>. These components collectively define a unique set of gradient/RF/control pulses which are used to excite, encode, and readout the NMR signals. Examples are pulse descriptions for 2D spin echo, 2D gradient-echo, 2D fast spin-echo, and 3D gradient-echo sequences. </paragraph>
<paragraph id="P-0082" lvl="0"><number>&lsqb;0082&rsqb;</number> The sequence description includes a set of components that control the order of pulse sequences played out, and define a series of prescribed events along the scan timeline. These prescribed events defined by the sequence description trigger the dynamic behavior of the pulse components in the pulse description. These components prescribe a unique acquisition ordering used to define the slice and k-space sampling order. Examples are 2D sequential, 2D interleaved, 3D sequential, 3D elliptical centric, and multi-slice CINE. </paragraph>
<paragraph id="P-0083" lvl="0"><number>&lsqb;0083&rsqb;</number> The acquisition description includes a set of components that prescribe the real-time processing of NMR signals acquired by the RF system <highlight><bold>26</bold></highlight>. These components direct the performance of operations on acquired NMR signals to produce information that is fed back to components in the sequence description to affect subsequent scanner operation. These components may, for example, process NMR signals during a calibration prescan to feedback changes in the power or frequency of RF pulses produced during the subsequent scan; or process NMR signals to detect when a bolus of contrast agent arrives in a region of interest and trigger the start of a centric view order acquisition; or process &ldquo;navigator&rdquo; NMR signals to produce phase correction information which may be used to alter the view order of the scan or alter the demodulation reference frequency of the RF system <highlight><bold>26</bold></highlight>. There are scans commonly used in clinical applications which do not require this capability, however, and in those applications, the components in the acquisition description simply buffer or filter the acquired NMR signals and make them available to the data processing server <highlight><bold>22</bold></highlight>. </paragraph>
<paragraph id="P-0084" lvl="0"><number>&lsqb;0084&rsqb;</number> The data processing description contains components that direct the data processing server <highlight><bold>22</bold></highlight> to transform acquired NMR signals into a meaningful form. Spectroscopy processing can be defined by these components, in which case the form that results is an image of the spectra of the acquired NMR signals. Image reconstruction is, however, the most common function and the resulting form is a 2D or 3D image of the subject being scanned. Image reconstruction components can include image manipulation functions such as rotating and transposing images; various types of transformation functions including fourier transforms; data sampling, windowing, and filtering functions; sorting and directing collected and manipulated data between a number of possible data manipulation applications, and other applications. Properties of these components can also be modified during scanning to modify the stored and visualized images, as discussed more fully below. Certain components can also be modified during processing of an acquired image, either during operation of a scan or during off-line image processing. These components can include, for example: data filter parameters, threshold values, image resolution values, the control of pipeline parameters directed to data processing, and other data processing parameters. </paragraph>
<paragraph id="P-0085" lvl="0"><number>&lsqb;0085&rsqb;</number> The data store description contains components that define the images which are stored in the database during a scan. In addition to the reconstructed images, this may include patient information and scan parameter information which is to appear annotated on the image along with the patient anatomic or spectrographic information. </paragraph>
<paragraph id="P-0086" lvl="0"><number>&lsqb;0086&rsqb;</number> As indicated above, the application development system is implemented on a workstation having a memory, a display, an input device such as a keyboard and mouse and a processor programmed to perform the functions now to be described. Referring particularly to <cross-reference target="DRAWINGS">FIGS. 3 and 4</cross-reference>, the programs and data which form the software architecture of the application development system includes a visual component assembler <highlight><bold>60</bold></highlight> which produces a window display <highlight><bold>62</bold></highlight> to the user that contains three areas: a framework area <highlight><bold>64</bold></highlight>; a workspace area <highlight><bold>66</bold></highlight>; and a properties area <highlight><bold>68</bold></highlight>. The application program is developed by selecting components from the component library <highlight><bold>72</bold></highlight> which are displayed in the framework area <highlight><bold>64</bold></highlight> and dragging them into the workspace area <highlight><bold>66</bold></highlight>. Such selected components are stored in workspace storage <highlight><bold>67</bold></highlight>. The properties of a selected component in the workspace area <highlight><bold>66</bold></highlight> are displayed in the properties area <highlight><bold>66</bold></highlight>, and these properties can be changed using an property editor <highlight><bold>70</bold></highlight>. </paragraph>
<paragraph id="P-0087" lvl="0"><number>&lsqb;0087&rsqb;</number> The components displayed in the framework area <highlight><bold>64</bold></highlight> are Java&trade; classes, or objects stored in a component library <highlight><bold>72</bold></highlight>. These components are typically developed using a commercially available integrated development environment <highlight><bold>74</bold></highlight> such as that sold under the trademark &ldquo;Forte for Java&rdquo; by Sun Microsystems or &ldquo;JBuilder&rdquo; sold by Inprise. The components are written in Java&trade; source code and compiled into binary instructions called byte code. These byte code components are saved to the appropriate packages in the component library <highlight><bold>72</bold></highlight>. It can be appreciated that many Java components are commercially available and these can be used along with custom written Java components to create more complex components specifically applicable to performing the MRI functions described above. The objective is to create and store enough components in the component library <highlight><bold>72</bold></highlight> such that a user can build any desired application by selecting existing components. In such case, the user does not need to write any software code to implement new applications, but is simply requested to select and aggregate the desired functionality. </paragraph>
<paragraph id="P-0088" lvl="0"><number>&lsqb;0088&rsqb;</number> Referring particularly to <cross-reference target="DRAWINGS">FIGS. 3, 4</cross-reference> and <highlight><bold>6</bold></highlight>, as components are dragged into the workspace <highlight><bold>66</bold></highlight> from the framework area <highlight><bold>64</bold></highlight>, the visual component assembler <highlight><bold>60</bold></highlight> establishes the hierarchical relationship between the components. These relationships are illustrated in one preferred manner in <cross-reference target="DRAWINGS">FIG. 4</cross-reference> by the indentation of containee component icons beneath their related container component icon. An alternative embodiment of the display of this hierarchical relationship of components in the workspace <highlight><bold>66</bold></highlight> is shown in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>. In this embodiment, arrows point from each superclass component icon to its related subclass component icons. </paragraph>
<paragraph id="P-0089" lvl="0"><number>&lsqb;0089&rsqb;</number> It can be appreciated that the display of a complete application requires more display area than is available and that scroll bars may be used to display different portions of the application in the workspace <highlight><bold>66</bold></highlight>. </paragraph>
<paragraph id="P-0090" lvl="0"><number>&lsqb;0090&rsqb;</number> To build an application, the user first loads the framework area <highlight><bold>64</bold></highlight> with the library of components. The components are displayed and an application container component <highlight><bold>76</bold></highlight> is selected. When this component <highlight><bold>76</bold></highlight> is dragged to the workspace <highlight><bold>66</bold></highlight>, components for all of its children are also identified. This initiates the building of an application, but the user must know what further components are required to complete the build. To assist in this effort any component in the workspace <highlight><bold>66</bold></highlight> can be selected with a right click of the mouse and a description of the function performed by that component is displayed in the format known as Javodoc<highlight><superscript>198 </superscript></highlight>. </paragraph>
<paragraph id="P-0091" lvl="0"><number>&lsqb;0091&rsqb;</number> Each component in the workspace <highlight><bold>66</bold></highlight> has properties, which include numeric variables, Boolean variables and other class type or named variables. The visual component assembler enables the user to display these properties in the properties area <highlight><bold>68</bold></highlight> by left clicking on a selected component. If the user then left clicks to select one of the displayed properties in the properties area <highlight><bold>66</bold></highlight>, the property editor tool <highlight><bold>70</bold></highlight> is employed to enable the user to make the change. It is contemplated that most of the new applications created in clinical settings will be limited to changing the properties in components of existing applications. In other words, existing applications are dragged from the framework area <highlight><bold>64</bold></highlight>; the properties in selected components therein are edited; and the result is saved back to the component library <highlight><bold>72</bold></highlight> as a new application. </paragraph>
<paragraph id="P-0092" lvl="0"><number>&lsqb;0092&rsqb;</number> When the application is completed the selected components assembled in the workspace area <highlight><bold>66</bold></highlight> are then persisted. This is currently accomplished by storing the application using the above described serialization mechanism, however, other persistence mechanisms are known and may be used. The persistence mechanism stores the hierarchical relationship (&ldquo;graph&rdquo;) between the selected components as well as the instance variable (property) values. The byte code for each component in the application is not stored with the persisted application. The medical imaging system which employs the application must itself store the byte code for all the components used in applications. When the persisted application is restored, or &ldquo;deserialized&rdquo;, on the MRI system, it directs the loading of the byte code indicated by the persisted object graph and instance variable. </paragraph>
<paragraph id="P-0093" lvl="0"><number>&lsqb;0093&rsqb;</number> Referring now to <cross-reference target="DRAWINGS">FIG. 7</cross-reference>, an application in which the application development environment includes a framework area <highlight><bold>64</bold></highlight> and workspace <highlight><bold>66</bold></highlight> in combination with a graphical building area <highlight><bold>200</bold></highlight> is shown. The workspace <highlight><bold>66</bold></highlight> includes a main application container <highlight><bold>202</bold></highlight>, and hierarchically arranged beneath the main folder, a plurality of application description folders. Among the folder structures is a data processing description <highlight><bold>204</bold></highlight>, including a plurality of component folders of executable code for providing various data processing functions. The data processing description <highlight><bold>204</bold></highlight> will be used by way of example for explaining the graphic building area <highlight><bold>200</bold></highlight> below. However, it will be apparent that the graphic building method described can be applied to a number of different medical imaging applications, either for performing discrete segments such as scan pulses, or for providing an overall imaging acquisition and reconstruction program. </paragraph>
<paragraph id="P-0094" lvl="0"><number>&lsqb;0094&rsqb;</number> Referring now to the graphical building area <highlight><bold>200</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 7</cross-reference>, three basic types of icons are displayed. These include: containers <highlight><bold>300</bold></highlight>, components <highlight><bold>302</bold></highlight>, and connection points <highlight><bold>304</bold></highlight>. The containers <highlight><bold>300</bold></highlight>, which are structural elements which provide a storage location for a number of executable components <highlight><bold>302</bold></highlight>, are represented as oblongs. The executable components <highlight><bold>302</bold></highlight> are represented as rectangular icons. Each of the components <highlight><bold>302</bold></highlight> receives and/or transmits data and therefore includes one or more connection point <highlight><bold>308</bold></highlight> which can be an input <highlight><bold>310</bold></highlight> and/or output <highlight><bold>312</bold></highlight>. The inputs <highlight><bold>310</bold></highlight> and outputs <highlight><bold>312</bold></highlight> can receive or provide signals in the form of events or data. Generally, the connection point <highlight><bold>308</bold></highlight> is tied to related data through a code representation such as an address. </paragraph>
<paragraph id="P-0095" lvl="0"><number>&lsqb;0095&rsqb;</number> Properties of each of the containers <highlight><bold>300</bold></highlight> and components <highlight><bold>302</bold></highlight> can be accessed by right clicking on the respective icon with a mouse, thereby accessing the properties of the object allowing the user to edit the properties through an input device <highlight><bold>14</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 1</cross-reference>). Properties of the connection point <highlight><bold>308</bold></highlight> are accessed by dragging a mouse over the icon and activating a tip point or other graphical means of display. Information displayed can include a name of the connection point <highlight><bold>308</bold></highlight> and the type of data expected at or transmitted from. </paragraph>
<paragraph id="P-0096" lvl="0"><number>&lsqb;0096&rsqb;</number> To build an application or an application segment such as the data processing segment shown, a container <highlight><bold>300</bold></highlight> is initially dragged and dropped onto the graphic building area <highlight><bold>200</bold></highlight> with an input device such as a mouse. The container <highlight><bold>300</bold></highlight> can be an empty object to which components <highlight><bold>302</bold></highlight> are added from the workspace <highlight><bold>66</bold></highlight>, or a container <highlight><bold>300</bold></highlight> such as the data processing description <highlight><bold>204</bold></highlight> shown, which already contains a plurality of components <highlight><bold>302</bold></highlight>. When a container <highlight><bold>300</bold></highlight> which includes components <highlight><bold>302</bold></highlight> is dropped onto the graphic building area <highlight><bold>200</bold></highlight>, the relationship between the container <highlight><bold>300</bold></highlight> and the components <highlight><bold>302</bold></highlight> is shown graphically with a plurality of graphic links <highlight><bold>304</bold></highlight>. Other components <highlight><bold>302</bold></highlight> can be selected from the framework <highlight><bold>64</bold></highlight> or workspace <highlight><bold>66</bold></highlight> areas and dropped onto the container <highlight><bold>300</bold></highlight> to add these components to the container. When components <highlight><bold>302</bold></highlight> are added in this way, graphical links <highlight><bold>304</bold></highlight> between the container <highlight><bold>300</bold></highlight> and the added components <highlight><bold>302</bold></highlight> are also shown. </paragraph>
<paragraph id="P-0097" lvl="0"><number>&lsqb;0097&rsqb;</number> As each component <highlight><bold>302</bold></highlight> is dropped onto the graphic building area <highlight><bold>200</bold></highlight>, connection points <highlight><bold>308</bold></highlight> illustrating input <highlight><bold>310</bold></highlight> and output <highlight><bold>312</bold></highlight> connections for transmitting data or events to and from the component <highlight><bold>302</bold></highlight> are shown as icons. A predetermined number of input <highlight><bold>310</bold></highlight> and output <highlight><bold>312</bold></highlight> connection points <highlight><bold>308</bold></highlight> are associated with each component <highlight><bold>302</bold></highlight>. Using a mouse, keyboard, or other input device <highlight><bold>14</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 1</cross-reference>), the user graphically links successive inputs <highlight><bold>310</bold></highlight> and outputs <highlight><bold>312</bold></highlight> by means of a graphical assembly link <highlight><bold>314</bold></highlight> to provide a data flow through the executable code. The graphical assembly link <highlight><bold>314</bold></highlight> provides each of the connected components with software references to one another, and thus provides a hierarchical linking of the components <highlight><bold>302</bold></highlight>. </paragraph>
<paragraph id="P-0098" lvl="0"><number>&lsqb;0098&rsqb;</number> After the components <highlight><bold>302</bold></highlight> are linked, the code can be serialized and downloaded, as described above, either by linking a specialized download component to the assembled code, or by selecting a download button from the user interface <highlight><bold>14</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 1</cross-reference>) of the primary application. </paragraph>
<paragraph id="P-0099" lvl="0"><number>&lsqb;0099&rsqb;</number> The graphical workspace of <cross-reference target="DRAWINGS">FIG. 7</cross-reference> is particularly useful in manipulating a data processing pipeline, allowing users to modify the flow and processing of data graphically in both development and real-time processing operations. As an example, <cross-reference target="DRAWINGS">FIG. 7</cross-reference> illustrates a data processing container <highlight><bold>302</bold></highlight> including a fast Fourier transform component <highlight><bold>314</bold></highlight>. The fast Fourier transform component <highlight><bold>314</bold></highlight> receives one input signal <highlight><bold>316</bold></highlight> and provides two output signals <highlight><bold>318</bold></highlight> and <highlight><bold>320</bold></highlight>, respectively. The input <highlight><bold>316</bold></highlight> to the Fourier transform is preferably a data stream of acquired image data. The output <highlight><bold>318</bold></highlight> can comprise an array of magnitude data, while the output <highlight><bold>320</bold></highlight> comprises an array of phase data, each providing a separate set of information about the acquired image, both of which are useful in processing image data. As shown, a graphic assembly link <highlight><bold>322</bold></highlight> couples the output <highlight><bold>318</bold></highlight> to an input <highlight><bold>324</bold></highlight> to a bulk transfer process <highlight><bold>326</bold></highlight>, which transfers the data for further processing. During a processing application, however, it may be desirable to process the phase data of output <highlight><bold>320</bold></highlight>. To change the processing, the user employs an input device such as a mouse to move the graphic assembly link <highlight><bold>322</bold></highlight> from the output <highlight><bold>318</bold></highlight> to the output <highlight><bold>320</bold></highlight>. </paragraph>
<paragraph id="P-0100" lvl="0"><number>&lsqb;0100&rsqb;</number> By including a specialized program component <highlight><bold>302</bold></highlight> designed to download an application segment such as the data processing segment shown, the revised application can be downloaded to the data processing server as a separate component, without the need to download an entire image processing application. The workstation <highlight><bold>118</bold></highlight> downloads the revised code, in this case to the data processing server <highlight><bold>126</bold></highlight> and data processing apparatus <highlight><bold>112</bold></highlight> which, in turn, modifies the data flow to provide the phase data represented as output <highlight><bold>320</bold></highlight> to the bulk transfer process. </paragraph>
<paragraph id="P-0101" lvl="0"><number>&lsqb;0101&rsqb;</number> Because many of the components in MRI applications relate to the production of pulses and pulse sequences, another feature of the present invention is the display of waveforms or other data produced by a component. Referring particularly to <cross-reference target="DRAWINGS">FIGS. 3, 8</cross-reference> and <highlight><bold>9</bold></highlight>, all components, may include a property called a &ldquo;visible.&rdquo; In the case of a pulse waveform component, when the visible property is switched to &ldquo;true&rdquo;, a waveform plotter <highlight><bold>78</bold></highlight> is enabled and a pulse sequence plotter window <highlight><bold>80</bold></highlight> is produced and displayed. This window <highlight><bold>80</bold></highlight> displays the waveforms <highlight><bold>82</bold></highlight> and <highlight><bold>84</bold></highlight> which are produced by this instance of the component. If a property is changed using the editor <highlight><bold>70</bold></highlight>, the displayed waveforms may also change. This is illustrated in <cross-reference target="DRAWINGS">FIG. 8</cross-reference> when the property &ldquo;pulse type&rdquo; is about to be changed. </paragraph>
<paragraph id="P-0102" lvl="0"><number>&lsqb;0102&rsqb;</number> Referring now to <cross-reference target="DRAWINGS">FIG. 5</cross-reference>, as noted above, a sequence description comprising a set of components for controlling the ordering of pulse sequences in a scan is included as part of the scan description <highlight><bold>122</bold></highlight>. As described above, the sequence description prescribes acquisition ordering for defining the sequence of events performed while traversing k-space. Referring now also to <cross-reference target="DRAWINGS">FIG. 10</cross-reference>, as described above with reference to the pulse description, the sequence description can be viewed graphically on the new interface <highlight><bold>120</bold></highlight> of the workstation <highlight><bold>118</bold></highlight> by selecting a &ldquo;visible property&rdquo; as shown in the Properties screen <highlight><bold>68</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, which activates the plotter <highlight><bold>78</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 3</cross-reference>) to provide a graphic view of k-space <highlight><bold>400</bold></highlight>, and of the traversal of k-space by the selected sequence description. </paragraph>
<paragraph id="P-0103" lvl="0"><number>&lsqb;0103&rsqb;</number> Referring still to <cross-reference target="DRAWINGS">FIG. 10</cross-reference>, the graphical view of k-space <highlight><bold>400</bold></highlight> illustrates a plurality of k-space trajectories <highlight><bold>402</bold></highlight> and associated data including, for example, view order number <highlight><bold>408</bold></highlight>, echo number <highlight><bold>410</bold></highlight>, number of excitations (NEX) <highlight><bold>412</bold></highlight> per line, and a description of the pulse sequence or segment to be provided on the selected trajectory <highlight><bold>414</bold></highlight>. Data associated with the sequence of events for traversal of k-space can be shown using both alphanumeric characters, and graphically. Here, for example, view ordering is illustrated graphically, as a function of the color of the trajectory <highlight><bold>402</bold></highlight>. The echo number is also illustrated graphically, as a function of the length of the selected trajectory <highlight><bold>402</bold></highlight>, and numerically in column <highlight><bold>3</bold></highlight>. Although specified as part of a pulse description rather than the sequence description, the pulse sequence <highlight><bold>414</bold></highlight> to be applied in each trajectory of the k-space are shown in column <highlight><bold>4</bold></highlight>. </paragraph>
<paragraph id="P-0104" lvl="0"><number>&lsqb;0104&rsqb;</number> Referring still to <cross-reference target="DRAWINGS">FIG. 10</cross-reference>, the k-space sequence description can also be programmed through or modified through the graphical k-space screen to define the events for traversing k-space during a medical imaging scan. From the k-space view, data elements can be generated by object-oriented sequence description components in the form of predefined sequences. The data elements generated by the predefined sequences are stored in a table, the lines in the table defining an ordered list of pulse segments associated with each trajectory in k-space. The table can also hold information on time ordering or sequencing of k-space trajectories, desired triggering for each k-space trajectory and similar data objects. The k-space description/configuration of sequences are then translated to a group of downloadable sequence components whose interconnection through input/output nodes and use of associated tables allow capturing complex looping and conditional logic associated with MR pulse sequencing (<cross-reference target="DRAWINGS">FIG. 11</cross-reference>). These components and tables are serialized and downloaded to a runtime server for medical imaging system operation. The software architecture allows for decoupling of the description of sequence acquisition, as defined in k-space, from the downloadable sequence control components used to execute the scan. Each of these steps will be defined more fully below. </paragraph>
<paragraph id="P-0105" lvl="0"><number>&lsqb;0105&rsqb;</number> Referring still to <cross-reference target="DRAWINGS">FIG. 10, a</cross-reference> menu structure <highlight><bold>404</bold></highlight> allows the user to select between a plurality of sequence description executable components for controlling View Order, Slice Select, Number of Excitations (NEX) and other sequencing description parameters. From the menu <highlight><bold>404</bold></highlight> associated with each sequence component, a user can select among one or more predefined sequence orders <highlight><bold>406</bold></highlight>, which associate object data with the object-oriented sequence components. Shown, for example, is a menu <highlight><bold>414</bold></highlight> for View Ordering, and associated predefined sequence orders <highlight><bold>406</bold></highlight>. Here, the predefined sequence orders include a Top Down, Bottom Up, Random, Reverse Centric, Center Out, and TE Centric view order. Selecting between these orders associates a defined set of objects for performing the selected function with the selected sequence description component. Note that, in some applications, as shown below, a shot control is used in place of the view order. The shot control provides greater flexibility by allowing groups of trajectories to be programmed together. </paragraph>
<paragraph id="P-0106" lvl="0"><number>&lsqb;0106&rsqb;</number> Referring now to <cross-reference target="DRAWINGS">FIG. 11</cross-reference>, each menu selection in the k-space graphical view <highlight><bold>400</bold></highlight> is associated with an object-oriented executable component <highlight><bold>302</bold></highlight> providing a conditional logic structure for performing a sequencing function, and the selected predefined sequence order <highlight><bold>406</bold></highlight> provides condition data for controlling the flow of logic through the conditional logic structures. After the predefined sequence orders are selected, the conditional data associated with each of the selected programs is stored in a data table <highlight><bold>409</bold></highlight> which provides the information required by the sequence description components <highlight><bold>302</bold></highlight> to make appropriate branches and loops. Other data required for execution, such as the ordered list of pulse segments <highlight><bold>414</bold></highlight>, can also be included in the data table <highlight><bold>409</bold></highlight>. The tabular data can include, for example, an acquisition number providing conditional data to an acquisition logic component, view number providing conditional data to the view order component, number of excitations providing conditional data to a NEX component, number of slices providing conditional data to a slice component, and ordered list of pulse segments indicating the type of pulse sequence to be executed at each trajectory in k-space. The table <highlight><bold>409</bold></highlight> can also include triggering data for the trajectory, and other data required to control the sequence component at run time. The table <highlight><bold>409</bold></highlight> therefore provides an ordered list of pulse sequences to be executed by the executable components <highlight><bold>302</bold></highlight> as described below. </paragraph>
<paragraph id="P-0107" lvl="0"><number>&lsqb;0107&rsqb;</number> Referring still to <cross-reference target="DRAWINGS">FIG. 11</cross-reference>, here, as an example, an object oriented NEX component <highlight><bold>302</bold></highlight> is shown in the menu <highlight><bold>404</bold></highlight>. At the menu <highlight><bold>404</bold></highlight>, a predefined sequence order <highlight><bold>406</bold></highlight> is associated with the NEX component <highlight><bold>302</bold></highlight>, and object data, including conditional data for determining the flow of logic through conditional logic structures related to the predefined sequence order <highlight><bold>406</bold></highlight>, is stored in column <highlight><bold>407</bold></highlight> of the table <highlight><bold>409</bold></highlight>. As a result of the selected programs <highlight><bold>406</bold></highlight>, the ordering of events for traversing k-space is fully defined and can be displayed graphically, as in the graphic building area <highlight><bold>200</bold></highlight> discussed below. By associating the object data of the predefined sequence orders <highlight><bold>406</bold></highlight> with the sequence description component <highlight><bold>302</bold></highlight>, required conditional logic data for traversing k-space in the manner described by the selected sequence description is provided without the need for traditional programming of conditional loops. </paragraph>
<paragraph id="P-0108" lvl="0"><number>&lsqb;0108&rsqb;</number> Referring now to <cross-reference target="DRAWINGS">FIG. 12</cross-reference>, after the sequence description has been defined in the k-space graphical view <highlight><bold>400</bold></highlight> and condition data stored in the data table <highlight><bold>409</bold></highlight>, the flow of logic associated with the sequence description can be viewed and altered in the graphic building area <highlight><bold>200</bold></highlight>, described above. Here, the sequence description is provided in a container <highlight><bold>300</bold></highlight> including sequence description executable components <highlight><bold>302</bold></highlight>. As described above, each of the components <highlight><bold>302</bold></highlight> include input connection points <highlight><bold>310</bold></highlight>, through which both data and commands are received, and output connection points <highlight><bold>312</bold></highlight> through which data and commands are transmitted. Also as described above, by dragging the graphical links <highlight><bold>304</bold></highlight> between the input <highlight><bold>310</bold></highlight> and output <highlight><bold>312</bold></highlight> connection points, the direction of program flow can be controlled graphically. The graphic building area <highlight><bold>200</bold></highlight>, therefore, provides another level of programming control for reconfiguring a sequence description which is particularly useful to more advanced programmers who wish to customize application sequencing. Although a single table <highlight><bold>409</bold></highlight> is described and shown in <cross-reference target="DRAWINGS">FIG. 11, a</cross-reference> number of tables associated with various sequence description components can be provided. For example, a one dimensional table <highlight><bold>319</bold></highlight> and a two dimensional <highlight><bold>321</bold></highlight> are shown associated with correlating sequence components in <cross-reference target="DRAWINGS">FIG. 12</cross-reference>. </paragraph>
<paragraph id="P-0109" lvl="0"><number>&lsqb;0109&rsqb;</number> Referring still to <cross-reference target="DRAWINGS">FIG. 12</cross-reference>, each of the components <highlight><bold>302</bold></highlight> in the sequence description comprises a conditional logic structure. The building area <highlight><bold>200</bold></highlight> provides a graphical view of loop structure and the nesting of loops in the sequence description which can be dynamically modified through the graphical links <highlight><bold>304</bold></highlight>. Components <highlight><bold>302</bold></highlight> providing conditional logic include input <highlight><bold>310</bold></highlight> and output <highlight><bold>312</bold></highlight> connection points for controlling the flow of logic. For example, the components <highlight><bold>302</bold></highlight> can include an &ldquo;Activate Loop&rdquo; input <highlight><bold>311</bold></highlight>, a &ldquo;Loop Continue&rdquo; input <highlight><bold>313</bold></highlight>, a &ldquo;Loop Stop&rdquo; input <highlight><bold>317</bold></highlight>, and a &ldquo;Loop complete&rdquo; output <highlight><bold>315</bold></highlight>. By selectively connecting these loop control input and output connection points, the logic flow and nesting of loops can be re-configured dynamically. The sequence description components <highlight><bold>302</bold></highlight> can also be combined with other executable components such as, for example, a cardiac trigger which can be applied, for example, to an &ldquo;Activate Loop&rdquo; input <highlight><bold>311</bold></highlight> or in other ways to control sequencing. </paragraph>
<paragraph id="P-0110" lvl="0"><number>&lsqb;0110&rsqb;</number> Referring still to <cross-reference target="DRAWINGS">FIG. 12</cross-reference>, here the sequence description <highlight><bold>300</bold></highlight> includes an acquisition control <highlight><bold>323</bold></highlight>, for controlling the acquisition of image data during the sequence; a shot control <highlight><bold>325</bold></highlight>, which controls the order in which shots, or groupings of k-space trajectories, are played out during a scan; a NEX control <highlight><bold>327</bold></highlight>, which controls the number of excitations which are played out on each shot; and a slice control <highlight><bold>329</bold></highlight> which maps logical slice data to physical slices. The segment player <highlight><bold>331</bold></highlight> controls the actual playing of sequences in k-space as defined by the components described above. </paragraph>
<paragraph id="P-0111" lvl="0"><number>&lsqb;0111&rsqb;</number> Referring again to <cross-reference target="DRAWINGS">FIG. 5</cross-reference>, each of the components <highlight><bold>302</bold></highlight> and associated data tables <highlight><bold>409</bold></highlight> are serialized and downloaded to a clinical medical imaging system for run time operation as part of the scan description <highlight><bold>122</bold></highlight>, as described below. </paragraph>
<paragraph id="P-0112" lvl="0"><number>&lsqb;0112&rsqb;</number> When the application is complete, the application container object is serialized and saved to storage. As indicated above, this serialized form of the application program may be restarted in another virtual Java&trade; machine such as the MRI system described above and reconstituted into an object-oriented application program ready for execution. </paragraph>
<paragraph id="P-0113" lvl="0"><number>&lsqb;0113&rsqb;</number> One advantage of the serialized configuration of the stored application program is that it can efficiently be downloaded to clinical MRI systems from remote sites. This may be done through direct serial connection using a private Intranet or a public telephone system, or it may be done through the Internet public system, satellite links, or various network connections. In any case, the transfer of the application program is a serialized object stream which carries the class name of each object, or component, as well as that component&apos;s instance data which is described by attribute name, type, and value. Also transferred is the relationships between components which allows a graph of the components in the application program to be collected in the serial stream received at the MRI system and then recreated, or reconstituted, on the MRI system. The serialization mechanism follows all relationships between objects. Each object, or component in the graph is only serialized once. Should a component be referenced more than one time, the serialization process recognizes the repeat and inserts a reference to the previous occurrence in the graph. This prevents duplication of objects and reduces the magnitude of the download task. </paragraph>
<paragraph id="P-0114" lvl="0"><number>&lsqb;0114&rsqb;</number> The serialization process also eliminates the need for downloading byte code. This presumes that any MRI system that receives a downloaded application program has a library which stores the byte code for all components contained in the application program. Updates to clinical systems may, therefore, include both the downloading of new applications as well as the downloading of any necessary new components for the MRI system library. </paragraph>
<paragraph id="P-0115" lvl="0"><number>&lsqb;0115&rsqb;</number> Of course, the serialization process also enables applications to be uploaded from clinical MRI systems. This enables applications and/or components developed at clinical research systems to be uploaded to the MRI system manufacturer for review and analysis. </paragraph>
<paragraph id="P-0116" lvl="0"><number>&lsqb;0116&rsqb;</number> The application development system can also be operated in a simulation mode to try out the application program before an actual scan is performed on the MRI system hardware. This simulation capability is facilitated by the fact that the application program will run on any Java&trade; virtual machine with a suitable component library. It is also facilitated by the fact that the user interface is a component of the application, such that the simulation uses the same interface and displays the same information as when running on an MRI system. Simulation environment is a mode of operation of the application development system which allows a developer to test and debug his/her application in a near-scanner like environment. The Java application loaded in the component assembler collection can be first saved and then simulation may be started. During simulation, the servers are in &ldquo;simulation mode&rdquo; and thus certain hardware interfaces are emulated or non-functional. Typically raw data is injected into the server imaging chain to be processed as it would if received by the transceiver. </paragraph>
<paragraph id="P-0117" lvl="0"><number>&lsqb;0117&rsqb;</number> During application simulation, the developer will have the opportunity to do certain levels of message tracing and component debug. The developer is provided with several levels of component message tracing, which can be set dynamically during application simulation. The developer may also invoke several levels of debug. During component and application development, the developer can set a &ldquo;debug&equals;TRUE&rdquo; property in each component in order to access custom debug behavior for that component. Or, there may be several levels of debug for a property, with &ldquo;0&rdquo; being none or &ldquo;debug off&rdquo;. For example, the sequencing component of the sequence description may provide for single stepping of the slice and phase encoding looping. Any custom user interfaces required for a given component are provided by that component in debug mode. </paragraph>
<paragraph id="P-0118" lvl="0"><number>&lsqb;0118&rsqb;</number> There may also be one or more simulation user interfaces which can be accessed during simulation to provide access to more global operations, such as observing the internal behavior of a specific server, inter-server tag communications or perhaps observing detailed behavior of a specific server, including tags and agent behavior. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method for programming a scan sequence in k-space on a medical imaging system, the method comprising the following steps: 
<claim-text>providing a user interface including a graphic view of k-space for a medical imaging scan, the graphic illustration including a plurality of case based trajectories in the k-space; and </claim-text>
<claim-text>displaying at least one sequence description component associated with the k-space through the user interface, the sequence description component defining a parameter for traversing k-space; and </claim-text>
<claim-text>assigning a predefined order parameter to the sequence description component, the predefined order parameters associating conditional data with the downloadable sequence description component for sequencing the traversal of k-space. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method as defined in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the assigned sequence description component comprises at least one of a number of excitations in each of the lines of k-space, a view ordering for ordering the lines in k-space, and a segment use correlating at least one pulse segment to at least one of the k-space lines. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method as defined in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the downloadable sequence components and their associated conditional data are serialized and transmitted to a run time server to be deserialized in a real time operating environment. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method as defined in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the pulse sequence components include a number of excitations control, a view ordering control and a slice select control. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method as defined in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, the graphical k-space view further comprising an alphanumeric character for illustrating the conditional data. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method as defined in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising the step of graphically illustrating at least one of the sequence description components by assigning one or more color to the trajectories. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The method as defined in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising the step of graphically illustrating at least one of the sequence description components as a function of the length of the trajectories. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The method as defined in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising the step of providing a graphical view of a sequence description defined by the selected sequence description components and conditional data, the graphical view of the sequence description including at least one input connection point and one output connection point to each sequence component and a graphical link between the input connection point and output connection point of successive components, wherein the graphical link defines the flow of logic through the sequence description. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The method as defined in <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference>, further comprising the step of dragging and dropping the graphical link to change the direction of the flow of logic. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The method as defined in <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference>, wherein each of the sequence description components in the graphical view further comprise at least one input connection point and at least one output connection point for providing a looping function. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The method as defined in <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein the graphical links between the input connection point and the output connection point for providing a looping function provide a nesting of loops. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. A method for programming a sequence description for traversing k-space in a medical imaging system, the method comprising the following steps: 
<claim-text>assigning object data to each of a plurality of downloadable sequence components, the sequence components defining events for traversing k-space; and </claim-text>
<claim-text>storing the object data in a downloadable table, the table providing an ordered list of pulse sequences to be performed in run time. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The method as defined in <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, further comprising the step of: 
<claim-text>serializing the object data with sequence components and downloading them to a medical imaging system for execution in run time. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The method as defined in <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, wherein the downloadable table includes conditional data for determining the flow of logic through the sequence components to traverse k-space. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The method as defined in <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, wherein the sequence description components include at least one of a number of excitations (NEX) component, a view ordering component, and a slice component. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The method as defined in <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, further comprising the step of graphically illustrating k-space and selected sequence description components and associated data defining selected events for traversing k-space. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The method as defined in <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, further comprising the step of illustrating the selected sequence description components and associated data graphically. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The method as defined in <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, further comprising the step of illustrating the selected sequence description components and associated data using alphanumeric characters. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The method as defined in <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, further comprising the step of providing a graphical view of the flow of logic provided in the sequence description, the flow of logic being dynamically modifiable by moving a graphical link between input and output connections associated with each sequence component. </claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The method as defined in <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference>, wherein the sequence components include at least one of an acquisition logic, a view ordering, a slice select, a shot acquisition, and a number of excitations.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>1</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030002631A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030002631A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030002631A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030002631A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030002631A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030002631A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030002631A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030002631A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030002631A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00009">
<image id="EMI-D00009" file="US20030002631A1-20030102-D00009.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00010">
<image id="EMI-D00010" file="US20030002631A1-20030102-D00010.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00011">
<image id="EMI-D00011" file="US20030002631A1-20030102-D00011.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
