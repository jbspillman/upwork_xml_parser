<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030004977A1-20030102-D00000.TIF SYSTEM "US20030004977A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030004977A1-20030102-D00001.TIF SYSTEM "US20030004977A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030004977A1-20030102-D00002.TIF SYSTEM "US20030004977A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030004977A1-20030102-D00003.TIF SYSTEM "US20030004977A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030004977A1-20030102-D00004.TIF SYSTEM "US20030004977A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030004977A1-20030102-D00005.TIF SYSTEM "US20030004977A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030004977A1-20030102-D00006.TIF SYSTEM "US20030004977A1-20030102-D00006.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030004977</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10150494</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20020516</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F012/00</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>707</class>
<subclass>201000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Distributing and synchronizing objects</title-of-invention>
</technical-information>
<continuity-data>
<continuations>
<continuation-of>
<parent-child>
<child>
<document-id>
<doc-number>10150494</doc-number>
<kind-code>A1</kind-code>
<document-date>20020516</document-date>
</document-id>
</child>
<parent>
<document-id>
<doc-number>09309246</doc-number>
<document-date>19990510</document-date>
<country-code>US</country-code>
</document-id>
</parent>
<parent-status>GRANTED</parent-status>
<parent-patent>
<document-id>
<doc-number>6430576</doc-number>
<country-code>US</country-code>
</document-id>
</parent-patent>
</parent-child>
</continuation-of>
</continuations>
</continuity-data>
<inventors>
<first-named-inventor>
<name>
<given-name>Patrick</given-name>
<family-name>Gates</family-name>
</name>
<residence>
<residence-us>
<city>San Francisco</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Craig</given-name>
<family-name>Federighi</family-name>
</name>
<residence>
<residence-us>
<city>Los Altos</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Eric</given-name>
<family-name>Noyau</family-name>
</name>
<residence>
<residence-us>
<city>Mountain View</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>THE HECKER LAW GROUP</name-1>
<name-2></name-2>
<address>
<address-1>1925 CENTURY PARK EAST</address-1>
<address-2>SUITE 2300</address-2>
<city>LOS ANGELES</city>
<state>CA</state>
<postalcode>90067</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A method and apparatus for distributing and synchronizing objects. One or more embodiments of the invention provide for distributing copies of the objects locally. By copying objects (including the data and behavior for the object) into local address space, the object&apos;s methods may be executed locally thereby avoiding excessive network traffic. The state of the various object copies across a network may not be synchronized due to local changes and modifications. To synchronize the objects, one or more embodiments of the invention provide for the use of a policy that specifies conditions as to when objects are synchronized. Embodiments of the invention provide flexibility in setting the policy to accommodate varying applications. For example, a policy may provide for synchronization that is based temporally (e.g., every 10 minutes or daily at 10:00 P.M.). Alternatively, a policy may provide for synchronization based on the type or number of messages transmitted. In one or more embodiments, a default policy may be utilized that provides for the synchronization of local objects whenever a client issues a request from the remote server. In such an embodiment, the remote server transmits any updated object information when it responds to the local object request. The updated object information may be utilized to synchronize the objects. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> 1. Field of the Invention </paragraph>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> This invention relates to the field of computer networks, and, more specifically, to a method an apparatus for distributing and synchronizing objects across a network. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> Portions of the disclosure of this patent document contain material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office file or records, but otherwise reserves all copyright rights whatsoever. Apple, Macintosh, AppleTalk, AppleScript, and all Apple-based trademarks and logos are trademarks or registered trademarks of Apple Computer, Inc. in the United States and other countries. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> 2. Background Art </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> In a computer, applications, information, and processes may be controlled and executed by objects. Such objects may contain information (referred to as data) and may contain methods and applications (referred to as behavior) that can manipulate the data. In a computer network environment, multiple computers are linked together and one computer on a network may contain the object (and its associated data and behavior) that another computer desires to access or utilize. To provide the ability for multiple computers on a network to access and utilize an object located on a particular remote computer, a local computer may be provided with a &ldquo;proxy object&rdquo; that sends messages to and receives messages from the desired object (referred to as a remote object). However, when numerous computers are linked together (each with their own proxy object), the number of messages generated and transmitted across the network create excessive network traffic such that many applications cannot execute properly. These problems can be better understood by reviewing object oriented programming and networks and how they work. </paragraph>
<paragraph id="P-0006" lvl="7"><number>&lsqb;0006&rsqb;</number> Object-Oriented Programming </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> Object-oriented programming is a method of creating computer programs by combining certain fundamental building blocks, and creating relationships among and between the building blocks. The building blocks in object-oriented programming systems are called &ldquo;objects.&rdquo; An object is a programming unit that groups together a data structure (one or more instance variables) and the behavior/operations (methods) that can use or affect that data. Thus, an object consists of data and one or more operations or procedures that can be performed on that data. The joining of data and operations into a unitary building block is called &ldquo;encapsulation.&rdquo; </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> An object can be instructed to perform one of its methods when it receives a &ldquo;message.&rdquo; A message is a command or instruction sent to the object to execute a certain method. A message consists of a method selection (e.g., method name) and a plurality of arguments. A message tells the receiving object what operations to perform. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> One advantage of object-oriented programming is the way in which methods are invoked. When a message is sent to an object, it is not necessary for the message to instruct the object how to perform a certain method. It is only necessary to request that the object execute the method. This greatly simplifies program development. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> Object-oriented programming languages are predominantly based on a &ldquo;class&rdquo; scheme. The class-based object-oriented programming scheme is generally described in Lieberman, &ldquo;Using Prototypical Objects to Implement Shared Behavior in Object-Oriented Systems,&rdquo; OOPSLA 86 Proceedings, September 1986, pp. 214-223. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> An object is a generic term that is used in the object-oriented programming environment to refer to a module that contains related code and variables. A software application can be written using an object-oriented programming language whereby the program&apos;s functionality is implemented using objects. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> Software applications can take advantage of a distributed computing capability referred to as distributed objects. Using distributed objects, a first object (a client object) can send a message to a second object (a server object or remote object) regardless of the physical location of either object. That is, the client and server objects can reside on different machines. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> The distributed object technology uses a name server and a local proxy to allow a client object to communicate with a server object. A name server is used to register the server object. A client accesses the name server to look up the name of the server object. Using the name information, the client object directs a message to the server object. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> Instead of going directly from the client to the server, the message is actually received by a proxy object that resides on the same machine as the client object. The proxy object uses specialized methods to repackage a method invocation request and sends it to the remote object. Thus, the proxy object forwards the message to the server object on the server object&apos;s machine. A response generated by the server object is forwarded to the client object via the proxy object. The client object need not know the location of the server object. As far as the client object is concerned, the proxy object is the server object. However, the proxy object is only a vehicle for forwarding the message to the server object via the network. The details of the network communication is therefore hidden from the client object. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> Using distributed objects, every message sent to the proxy has to cross a network, thereby increasing network traffic. Due to the increase in network traffic, developers are forced to design applications taking the increased traffic into account. For example, a developer may desire some objects to be stored locally because increased network traffic would significantly impact the execution speed of an application if the object were stored remotely with messages transmitted through a proxy object. In some situations, an application may not work at all if an object is stored remotely (e.g., thousands of messages transmitted across a network may cause an application to execute too slowly or cause errors to occur if the application is time sensitive). It is desirable for programmers and developers to implement an application without considering the impact of network traffic or the affect a distributed object environment will have on the application. </paragraph>
<paragraph id="P-0016" lvl="7"><number>&lsqb;0016&rsqb;</number> Networks </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> In modern computing environments, it is commonplace to employ multiple computers or workstations linked together in a network to communicate between, and share data with, network users. A network also may include resources, such as printers, modems, file servers, etc., and may also include services, such as electronic mail (email). A network may include multiple computers, resources, and services or may consist of one computer/user. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> A network can be a small system (a local area network or &ldquo;LAN&rdquo;), or several separate networks can be connected together to form a larger network (a wide area network or &ldquo;WAN&rdquo;). Other types of networks include the internet, tel-com networks, the World Wide Web, intranets, extranets, wireless networks, and other networks over which electronic, digital, and/or analog data may be communicated. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> The Internet is a worldwide network of interconnected computers. An Internet client accesses a computer on the network via an Internet provider. An Internet provider is an organization that provides a client (e.g., an individual or other organization) with access to the Internet (via analog telephone line or Integrated Services Digital Network line, for example). A client can, for example, read information from, download a file from or send an electronic mail message to another computer/client using the Internet. Thus, the internet consists of multiple networks connected to each other into one large network. Networks commonly utilize a server that provides information such as email or web pages to a requesting user (referred to as a client) that is requesting the information. A server may be a designated computer or may exist on an end user&apos;s computer. Additionally, a server may be viewed as any computer or processor on a network that provides and processes information. Further, multiple servers may coexist on the same network. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> An addressing scheme is employed to identify Internet resources and networks from each other. This addressing scheme is called Uniform Resource Locator (URL). A URL may contain the application protocol to use when accessing the server (e.g., HTTP (hypertext transfer protocol)), the Internet domain name (also referred to as the server host name) of the site on which the server is running, and the location of the resource in the file structure of the server. For example, the URL &ldquo;http://www.apple.com/index.html&rdquo; specifies the application protocol (&ldquo;http&rdquo;), the server host name (&ldquo;www.apple.com&rdquo;), and the filename to be retrieved (&ldquo;index.html&rdquo;). The host name may be utilized to uniquely identify a network on the internet. For example, the host name &ldquo;www.apple.com&rdquo; identifies an Apple network. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> A method and apparatus for distributing and synchronizing objects. Using traditional distributed objects, a proxy object is utilized to transmit messages and information to a remote object across a network. When applications are resource intensive or when numerous proxy objects are utilized, traditional proxy objects create and utilize excessive network traffic. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> One or more embodiments of the invention provide for distributing copies of the objects locally. By copying objects (including the data and behavior for the object) into local address space, the object&apos;s methods may be executed locally thereby avoiding excessive network traffic. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> The state of the various object copies across a network may not be synchronized due to local changes and modifications. To synchronize the objects, one or more embodiments of the invention provide for the use of a policy that specifies conditions as to when objects are synchronized. Embodiments of the invention provide flexibility in setting the policy to accommodate varying applications. For example, a policy may provide for synchronization that is based temporally (e.g., every 10 minutes or daily at 10:00 P.M.). Alternatively, a policy may provide for synchronization based on the type or number of messages transmitted. In one or more embodiments, a default policy may be utilized that provides for the synchronization of local objects whenever a client issues a request from the remote server. In such an embodiment, the remote server transmits any updated object information when it responds to the local object request. The updated object information may be utilized to synchronize the objects. </paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a block diagram of one embodiment of a computer system capable of providing a suitable execution environment for one or more embodiments of the invention. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> illustrates the copying and use of objects locally across a network in accordance with one or more embodiments of the invention. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> demonstrates the distribution and synchronization of objects in accordance with one or more embodiments of the invention. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> demonstrates the synchronization of objects in accordance with one or more embodiments of the invention. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> demonstrates the use of editing contexts to provide for object synchronization in accordance with one or more embodiments of the invention. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> demonstrates the transmission of objects in accordance with one or more embodiments of the invention. </paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF THE INVENTION </heading>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> The invention is a method and apparatus for distributing and synchronizing objects. In the following description, numerous specific details are set forth to provide a more thorough description of embodiments of the invention. It is apparent, however, to one skilled in the art, that the invention may be practiced without these specific details. In other instances, well known features have not been described in detail so as not to obscure the invention. </paragraph>
<paragraph id="P-0031" lvl="7"><number>&lsqb;0031&rsqb;</number> Embodiment of Computer Execution Environment (Hardware) </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> An embodiment of the invention can be implemented as computer software in the form of computer readable code executed on a general purpose computer such as computer <highlight><bold>100</bold></highlight> illustrated in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, or in the form of bytecodes running on a processor (or devices enabled to process bytecodes) existing in a distributed environment (e.g., one or more processors on a network), or in the form of bytecode class files executable within a Java runtime environment running on such a computer. A keyboard <highlight><bold>110</bold></highlight> and mouse <highlight><bold>111</bold></highlight> are coupled to a system bus <highlight><bold>118</bold></highlight>. The keyboard and mouse are for introducing user input to the computer system and communicating that user input to processor <highlight><bold>113</bold></highlight>. Other suitable input devices may be used in addition to, or in place of, the mouse <highlight><bold>111</bold></highlight> and keyboard <highlight><bold>110</bold></highlight>. I/O (input/output) unit <highlight><bold>119</bold></highlight> coupled to system bus <highlight><bold>118</bold></highlight> represents such I/O elements as a printer, A/V (audio/video) I/O, etc. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> Computer <highlight><bold>100</bold></highlight> includes a video memory <highlight><bold>114</bold></highlight>, main memory <highlight><bold>115</bold></highlight> and mass storage <highlight><bold>112</bold></highlight>, all coupled to system bus <highlight><bold>118</bold></highlight> along with keyboard <highlight><bold>110</bold></highlight>, mouse <highlight><bold>111</bold></highlight> and processor <highlight><bold>113</bold></highlight>. The mass storage <highlight><bold>112</bold></highlight> may include both fixed and removable media, such as magnetic, optical or magnetic optical storage systems or any other available mass storage technology. Bus <highlight><bold>118</bold></highlight> may contain, for example, thirty-two address lines for addressing video memory <highlight><bold>114</bold></highlight> or main memory <highlight><bold>115</bold></highlight>. The system bus <highlight><bold>118</bold></highlight> also includes, for example, a 64-bit data bus for transferring data between and among the components, such as processor <highlight><bold>113</bold></highlight>, main memory <highlight><bold>115</bold></highlight>, video memory <highlight><bold>114</bold></highlight> and mass storage <highlight><bold>112</bold></highlight> Alternatively, multiplex data/address lines may be used instead of separate data and address lines. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> In one embodiment of the invention, the processor <highlight><bold>113</bold></highlight> is a microprocessor manufactured by Motorola, such as the 680X0 processor or a microprocessor manufactured by Intel, such as the 80X86, or Pentium processor, or a SPARC microprocessor. However, any other suitable microprocessor or microcomputer may be utilized. Main memory <highlight><bold>115</bold></highlight> is comprised of dynamic random access memory (DRAM). Video memory <highlight><bold>114</bold></highlight> is a dual-ported video random access memory. One port of the video memory <highlight><bold>114</bold></highlight> is coupled to video amplifier <highlight><bold>116</bold></highlight>. The video amplifier <highlight><bold>116</bold></highlight> is used to drive the cathode ray tube (CRT) raster monitor <highlight><bold>117</bold></highlight>. Video amplifier <highlight><bold>116</bold></highlight> is well known in the art and may be implemented by any suitable apparatus. This circuitry converts pixel data stored in video memory <highlight><bold>114</bold></highlight> to a raster signal suitable for use by monitor <highlight><bold>117</bold></highlight>. Monitor <highlight><bold>117</bold></highlight> is a type of monitor suitable for displaying graphic images. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> Computer <highlight><bold>100</bold></highlight> may also include a communication interface <highlight><bold>120</bold></highlight> coupled to bus <highlight><bold>118</bold></highlight>. Communication interface <highlight><bold>120</bold></highlight> provides a two-way data communication coupling via a network link <highlight><bold>121</bold></highlight> to a local network <highlight><bold>122</bold></highlight>. For example, if communication interface <highlight><bold>120</bold></highlight> is an integrated services digital network (ISDN) card or a modem, communication interface <highlight><bold>120</bold></highlight> provides a data communication connection to the corresponding type of telephone line, which comprises part of network link <highlight><bold>121</bold></highlight>. If communication interface <highlight><bold>120</bold></highlight> is a local area network (LAN) card, communication interface <highlight><bold>120</bold></highlight> provides a data communication connection via network link <highlight><bold>121</bold></highlight> to a compatible LAN. Wireless links are also possible. In any such implementation, communication interface <highlight><bold>120</bold></highlight> sends and receives electrical, electromagnetic or optical signals which carry digital data streams representing various types of information. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> Network link <highlight><bold>121</bold></highlight> typically provides data communication through one or more networks to other data devices. For example, network link <highlight><bold>121</bold></highlight> may provide a connection through local network <highlight><bold>122</bold></highlight> to local server computer <highlight><bold>123</bold></highlight> or to data equipment operated by an Internet Service Provider (ISP) <highlight><bold>124</bold></highlight>. ISP <highlight><bold>124</bold></highlight> in turn provides data communication services through the world wide packet data communication network now commonly referred to as the &ldquo;Internet&rdquo; <highlight><bold>125</bold></highlight>. Local network <highlight><bold>122</bold></highlight> and Internet <highlight><bold>125</bold></highlight> both use electrical, electromagnetic or optical signals which carry digital data streams. The signals through the various networks and the signals on network link <highlight><bold>121</bold></highlight> and through communication interface <highlight><bold>120</bold></highlight>, which carry the digital data to and from computer <highlight><bold>100</bold></highlight>, are exemplary forms of carrier waves transporting the information. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> Computer <highlight><bold>100</bold></highlight> can send messages and receive data, including program code, through the network(s), network link <highlight><bold>121</bold></highlight>, and communication interface <highlight><bold>120</bold></highlight>. In the Internet example, remote server computer <highlight><bold>126</bold></highlight> might transmit a requested code for an application program through Internet <highlight><bold>125</bold></highlight>, ISP <highlight><bold>124</bold></highlight>, local network <highlight><bold>122</bold></highlight> and communication interface <highlight><bold>120</bold></highlight>. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> The received code may be executed by processor <highlight><bold>113</bold></highlight> as it is received, and/or stored in mass storage <highlight><bold>112</bold></highlight>, or other non-volatile storage for later execution. In this manner, computer <highlight><bold>100</bold></highlight> may obtain application code in the form of a carrier wave. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> Application code may be embodied in any form of computer program product. A computer program product comprises a medium configured to store or transport computer readable code, or in which computer readable code may be embedded. Some examples of computer program products are CD-ROM disks, ROM cards, floppy disks, magnetic tapes, computer hard drives, servers on a network, and carrier waves. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> The computer systems described above are for purposes of example only. An embodiment of the invention may be implemented in any type of computer system or programming or processing environment. </paragraph>
<paragraph id="P-0041" lvl="7"><number>&lsqb;0041&rsqb;</number> Embodiment of Software Apparatus </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> One embodiment of the invention provides for a method and apparatus for distributing and synchronizing objects across a network. In one or more embodiments, an object is copied from the server into local address space (including the code/methods of the object). As a result, when the object receives a message, the object&apos;s methods are executed locally. Consequently, there is no implicit network traffic. Further, if a user desires to send a message to a remote object (using a traditional distributed object approach), such remote messaging is still permitted. <cross-reference target="DRAWINGS">FIG. 2</cross-reference> illustrates the copying and use of objects locally across a network. Objects A, B, and C are on server <highlight><bold>208</bold></highlight>. Instead of creating a proxy object on client <highlight><bold>1</bold></highlight>, client <highlight><bold>2</bold></highlight>, or client <highlight><bold>3</bold></highlight>, the objects may be copied across network <highlight><bold>206</bold></highlight> to one or more clients. Consequently, object A and object B may be copied to client <highlight><bold>1</bold></highlight>. Similarly object C may be copied to client <highlight><bold>2</bold></highlight> and object A may be copied to client <highlight><bold>3</bold></highlight>. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> Using one or more embodiments of the invention, multiple objects across a network are utilized. However, since an object&apos;s methods may be executing and an object&apos;s data may be modified, the various objects and their associated states may not be synchronized. For example, data on the copy of object A on Client <highlight><bold>1</bold></highlight> may have been modified by Client <highlight><bold>1</bold></highlight>. Once the data has been modified locally on Client <highlight><bold>1</bold></highlight>, the modified data will not match the data of the copy of object A on Client <highlight><bold>3</bold></highlight> or Server <highlight><bold>208</bold></highlight>. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> One or more embodiments of the invention provide for the synchronization of state between objects across a network. In such an embodiment, the synchronization of objects occurs automatically and transparently to the user. In one or more embodiments, a flexible policy provides for synchronization upon compliance with specified conditions. The policy may provide for one or more conditions that may vary significantly. For example, a policy may be based on the processing of a number of messages (e.g., synchronization may occur when 10 messages have been processed by a local object). Alternatively, a policy may be based on the processing of a certain type of message (e.g., the execution of a particular message or the modification of particular data), for example. Additionally, a policy may be temporally based such that synchronization occurs when a specified time (e.g., 10:00 A.M.) has been reached or occurs every fifteen (15) minutes. In another embodiment, a policy may provide for the occurrence of a user action such as the activation of a &ldquo;save&rdquo; button. In one or more embodiments of the invention, the policy may be based on a heuristic. (e.g., requirements obtained due to experimentation and trial and error). A heuristic may be determined dynamically by obtaining and evaluating messages transmitted between a local object and remote object, for example. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> After a policy&apos;s conditions have been met, one or more embodiments of the invention synchronize the copies of the objects with each other by transmitting the minimum amount of information necessary to reflect the differences to the remote counterpart of the object. The remote counterpart of the object may then propagate the differences to other systems/copies of the object. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> demonstrates the distribution and synchronization of objects in accordance with one or more embodiments of the invention. Referring to <cross-reference target="DRAWINGS">FIG. 2</cross-reference> and <cross-reference target="DRAWINGS">FIG. 3</cross-reference>, at step <highlight><bold>300</bold></highlight>, an object (e.g., object A, object B, or object C) may be copied from server <highlight><bold>208</bold></highlight> to a client (e.g., client <highlight><bold>1</bold></highlight>, client <highlight><bold>2</bold></highlight>, or client <highlight><bold>3</bold></highlight>). At step <highlight><bold>302</bold></highlight>, a policy indicating when synchronization is to occur is obtained. A default policy or a policy set by a developer may be utilized, for example. At step <highlight><bold>304</bold></highlight>, a determination is made regarding whether the conditions of the policy have been met (e.g., have the actions that indicate when synchronization should occur been reached). Once the various conditions have been met, the objects are synchronized at step <highlight><bold>306</bold></highlight>. The process continues at step <highlight><bold>304</bold></highlight> via A <highlight><bold>308</bold></highlight>. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> provides additional details regarding the synchronization of objects as provided in step <highlight><bold>306</bold></highlight>. At step <highlight><bold>400</bold></highlight>, a client (e.g., client <highlight><bold>1</bold></highlight>, client <highlight><bold>2</bold></highlight>, or client <highlight><bold>3</bold></highlight>) may transmit any changed information to a remote counterpart (e.g., server <highlight><bold>208</bold></highlight>). At step <highlight><bold>402</bold></highlight>, the changes are propagated to additional copies of the object. For example, if client <highlight><bold>1</bold></highlight> modifies object A, the changed information of object A is transmitted to server <highlight><bold>208</bold></highlight>. Server <highlight><bold>208</bold></highlight> may then update the resident object (i.e., object A). At step <highlight><bold>402</bold></highlight>, server <highlight><bold>208</bold></highlight> transmits the changes to client <highlight><bold>3</bold></highlight> so that client <highlight><bold>3</bold></highlight> can update its copy of object A. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> At times, the code or business logic of a method may be confidential, sensitive, or secure. Additionally, the execution of a particular method may be resource intensive requiring the use of significant resources (e.g., a database) that may reside remotely. To maintain application security and avoid the network traffic associated with copying numerous resources to a local address space, one or more embodiments of the invention provide for the execution of certain object methods remotely. Before remote execution, any pending changes to local objects may be pushed/transmitted to their remote counterparts so that the remote method is executed in the same environment as if it were executed locally. Once a method is executed remotely, the results, object state, and context may be pushed/transmitted to the local copies of the object. The local copies of the object may then be synchronized with the remote object. Alternatively, the result, object state, and context may only be pushed to the local object that requested the method&apos;s execution with synchronization of the remaining objects to occur as set forth in a policy. Such an implementation may provide for multiple copies of an object with restrictions on the local copies that require remote execution of identified methods. Consequently, remote method execution and local method execution may be set as desired. Further, from a programmer&apos;s/developer&apos;s perspective, all of the methods appear to execute locally. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> Objects may contain confidential data that should be accessible only by trusted, secure business logic. To provide this security, one or more embodiments of the invention provide for the mutation of objects as they are copied. For example, in one or more embodiments, a subset of the object data that is confidential is omitted in the response to a user-defined mapping of the object definition (e.g., only non-confidential information is transmitted with the object). Such an implementation may also provide for the creation of a superset of the object data where the resulting copy is populated with data derived from the original object data, or with any permutation of omitted and derived data. Additionally, in order to further reduce complexity from a developer&apos;s perspective, some embodiments may provide a mechanism for transmitting an entirely (or partially different) object class during copying, so that the resulting local copy has both different methods and different data than its remote counterpart. Despite the differences in class definitions, one-to-one correspondence may still be maintained between an object and its remote counterparts. Thus, from a developer&apos;s perspective, the copies are &ldquo;the same&rdquo; despite having different class definitions. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> When multiple copies of objects are distributed across a network, one or more of the objects may attempt to modify the same or related data. For example, one object may modify a salary, while another object may modify the percentage of the salary that is for a bonus, while yet another object may modify the bonus amount. However, as this example demonstrates, the modifications made by the various objects conflict with each other (i.e., the bonus amount is being adjusted while the amount that the bonus is based on and the percentage that determines the bonus is altered). One or more embodiments of the invention provide for a policy that sets forth exceptions to modifying the data or behavior of an object and may prioritize certain modifications. Using the above example, a policy may provide that adjustments to bonus percentages and salaries are given higher priority than adjustments to bonus amounts. Consequently, modifications to specified object data may occur before allowing modifications to other related data. If two or more objects modify data that is unrelated, those changes may be merged together into the object without interference. For example, if one object changes the salary and another changes the last name, the resulting object data will reflect both changes. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> In one or more embodiments of the invention, a default synchronization policy provides for always synchronizing all objects whenever a request to save occurs. In one or more embodiments of the invention, whenever a client issues a request (e.g., for a new object, to save an object, or to invoke a remote object method), the response by the server includes updates to other objects (that have occurred on the remote object but have not been updated to the client) that the client has previously accessed. Thus, each time a client issues a request, all local objects are synchronized with their remote counterparts. Since most applications and objects view more data than they change (referred to as &ldquo;read mostly&rdquo;), synchronizing the objects according to such a policy alleviates network traffic and ensures the &ldquo;reading&rdquo; of accurate data. Synchronization in this manner may be supplemented by specifying conditions when additional synchronization is to occur in the policy. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> demonstrates the use of editing contexts to provide for object synchronization in accordance with one or more embodiments of the invention. One or more embodiments of the invention use object graph editing contexts <highlight><bold>500</bold></highlight>-<highlight><bold>506</bold></highlight> to manage the synchronization of objects. An object graph (e.g., object graph <highlight><bold>1</bold></highlight>, object graph <highlight><bold>2</bold></highlight>, or object graph <highlight><bold>3</bold></highlight>) provides a particular view (e.g., a hierarchy or listing of objects) of objects that a particular client may be accessing or utilizing. In an implementation using editing contexts and object graphs, editing contexts <highlight><bold>500</bold></highlight>-<highlight><bold>504</bold></highlight> on clients <highlight><bold>508</bold></highlight>-<highlight><bold>512</bold></highlight> have as their object store <highlight><bold>516</bold></highlight> a remote editing context <highlight><bold>506</bold></highlight> on the server <highlight><bold>514</bold></highlight>. When object updates are pushed/transmitted from a client (e.g., clients <highlight><bold>508</bold></highlight>-<highlight><bold>512</bold></highlight>) to the server <highlight><bold>514</bold></highlight>, the editing context ensures that the minimal set of changes is sent from each client to the server. When new object data updates are received by an editing context on the client or server, that editing context correctly merges the changes into local objects (that may be located using the object graphs). Editing contexts and object graphs are more fully described in pending U.S. patent application Ser. No. 08/682,198 entitled &ldquo;Object Graph Editing Context and Methods of Use&rdquo; which is hereby fully incorporated by reference. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> The determination of whether objects should be copied into local address space (also referred to as populating a local graph of objects) may be performed in a variety of manners. One or more embodiments of the invention provide a method for populating a local graph of objects by retrieving remote object data on an as-needed basis in two ways: (1) by explicit request, or (2) by traversing previously unused segments of an object graph. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> One of the methods for retrieving remote object data is by explicit request (also referred to as &ldquo;lazy population&rdquo;). The developer may need to retrieve copies of all objects of a particular type, or some set of objects which match a specified set of criteria. In one embodiment, a request may be made within business logic or by a user interface for a set of objects managed by an editing context. The request for the objects is transmitted to its object store. Subsequently, the object store transmits the resulting local copies to the object that made the request. <cross-reference target="DRAWINGS">FIG. 6</cross-reference> demonstrates the transmission of objects in accordance with one or more such embodiments. Client application <highlight><bold>600</bold></highlight> transmits the request for objects to client editing context <highlight><bold>602</bold></highlight>. The request is transmitted across a network <highlight><bold>604</bold></highlight> where it is received by server application <highlight><bold>606</bold></highlight>. Server application <highlight><bold>606</bold></highlight> transmits the request to server editing context <highlight><bold>608</bold></highlight>. Server editing context <highlight><bold>608</bold></highlight> transmits the request to object store <highlight><bold>610</bold></highlight> where the objects are stored. Object store <highlight><bold>610</bold></highlight> transmits local copies of the objects back through server editing context <highlight><bold>608</bold></highlight>, server application <highlight><bold>606</bold></highlight>, network <highlight><bold>604</bold></highlight>, and client editing context <highlight><bold>602</bold></highlight> where the local objects may be delivered to client application <highlight><bold>600</bold></highlight>. The results of the request (i.e., the copies of the local objects) may also be reflected in the client object graph <highlight><bold>612</bold></highlight>. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> A second method for retrieving objects is by traversing previously unused segments of an object graph (also referred to as &ldquo;faulting&rdquo;). Part of an object&apos;s data may be references to other objects, and in order to avoid retrieving the entire remote object graph at once, the editing context at first retrieves only the object data which does not reference other objects. The first time a reference from one object to another is traversed (e.g., an object needs the data or method of another object), the editing context automatically makes a request to its object store for the second object&apos;s data, and the second object is populated with the resulting data. In this way only the portion of the object graph traversed by business logic is populated. Thus, an object is only retrieved or populated when it is needed or when a &ldquo;fault&rdquo; occurs (i.e., a request for a method or data of an object is issued and the object is not present in local address space (resulting in an error)). </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> One or more embodiments of the invention provide for an object persistence mechanism (i.e., a mechanism wherein objects may be stored or remain persistent in local or remote address space) that takes advantage of remote object synchronization. Such a system uses an editing context to manage and populate a local object graph as described above. Another editing context in the remote address space propagates requests to its object store, which in turn provides a connection to an external repository such as a relational database or file system. Thus, referring to <cross-reference target="DRAWINGS">FIG. 5</cross-reference>, local editing contexts <highlight><bold>500</bold></highlight>-<highlight><bold>504</bold></highlight> manage and populate local objects graphs (e.g., object graph <highlight><bold>1</bold></highlight>, object graph <highlight><bold>2</bold></highlight>, and object graph <highlight><bold>3</bold></highlight>). Editing contexts <highlight><bold>500</bold></highlight>-<highlight><bold>504</bold></highlight> transmit requests through a distribution channel (that may include a local object store) across a network to server <highlight><bold>514</bold></highlight>. Server editing context <highlight><bold>506</bold></highlight> propagates requests to object store <highlight><bold>516</bold></highlight>. Object store <highlight><bold>516</bold></highlight> provides a connection to an external repository such as relational database <highlight><bold>518</bold></highlight> or file system <highlight><bold>520</bold></highlight> where the objects may remain persistent. </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> Thus, a method and apparatus for distributing and synchronizing objects is described in conjunction with one or more specific embodiments. The invention is defined by the claims and their full scope of equivalents. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method for synchronizing objects comprising: 
<claim-text>copying an object having data and behavior from a first computer across a network to a second computer; </claim-text>
<claim-text>obtaining a policy for synchronizing said data and behavior between said first computer and said second computer; and </claim-text>
<claim-text>synchronizing said data and behavior between said first computer and said second computer based on said policy. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein said policy is temporally based. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein said policy is based on a type of message. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein said policy is based on a quantity of messages. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> further comprising a developer configuring said policy. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein said policy provides for synchronizing at least one object when a request is transmitted from said first computer to said second computer. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein said policy is based on user input. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. A system comprising 
<claim-text>a first computer; </claim-text>
<claim-text>an object having data and behavior stored on said first computer; </claim-text>
<claim-text>a second computer configured to obtain a copy of said object from said first computer; </claim-text>
<claim-text>a policy for synchronizing said object and said copy of said object; and </claim-text>
<claim-text>code configured to synchronize said object and said copy of said object based on said policy. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference> wherein said policy is temporally based. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference> wherein said policy is based on a type of message. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference> wherein said policy is based on a quantity of messages. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference> wherein said policy may be configured by a developer. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference> wherein said policy provides for synchronizing at least one object when a request is transmitted from said first computer to said second computer. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference> wherein said policy is based on user input. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. A computer program product comprising 
<claim-text>a computer usable medium having computer readable program code embodied therein configured to synchronize objects, said computer program product comprising: </claim-text>
<claim-text>computer readable code configured to cause a second computer to obtain a copy of an object having data and behavior from a first computer across a network; </claim-text>
<claim-text>computer readable code configured to cause a computer to obtain a policy for synchronizing said data and behavior between said first computer and said second computer; and </claim-text>
<claim-text>computer readable program code configured to cause a computer to synchronize said data and behavior between said first computer and said second computer based on said policy. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The computer program product to <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference> wherein said policy is temporally based. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The computer program product to <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference> wherein said policy is based on a type of message. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The computer program product to <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference> wherein said policy is based on a quantity of messages. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The computer program product to <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference> wherein said policy may be configured by a developer. </claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The computer program product to <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference> wherein said policy provides for synchronizing at least one object when a request is transmitted from said first computer to said second computer. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The computer program product to <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference> wherein said policy is based on user input. </claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. An apparatus for synchronizing objects comprising: 
<claim-text>means for copying an object having data and behavior from a first computer across a network to a second computer; </claim-text>
<claim-text>means for obtaining a policy for synchronizing said data and behavior between said first computer and said second computer; and </claim-text>
<claim-text>means for synchronizing said data and behavior between said first computer and said second computer based on said policy. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 22</dependent-claim-reference> wherein said policy is temporally based. </claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 22</dependent-claim-reference> wherein said policy is based on a type of message. </claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 22</dependent-claim-reference> wherein said policy is based on a quantity of messages. </claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 22</dependent-claim-reference> further comprising means for configuring said policy by a developer. </claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 22</dependent-claim-reference> wherein said policy provides for means for synchronizing at least one object when a request is transmitted from said first computer to said second computer. </claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 22</dependent-claim-reference> wherein said policy is based on user input.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>1</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030004977A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030004977A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030004977A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030004977A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030004977A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030004977A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030004977A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
