<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030004671A1-20030102-D00000.TIF SYSTEM "US20030004671A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030004671A1-20030102-D00001.TIF SYSTEM "US20030004671A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030004671A1-20030102-D00002.TIF SYSTEM "US20030004671A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030004671A1-20030102-D00003.TIF SYSTEM "US20030004671A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030004671A1-20030102-D00004.TIF SYSTEM "US20030004671A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030004671A1-20030102-D00005.TIF SYSTEM "US20030004671A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030004671A1-20030102-D00006.TIF SYSTEM "US20030004671A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030004671A1-20030102-D00007.TIF SYSTEM "US20030004671A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030004671A1-20030102-D00008.TIF SYSTEM "US20030004671A1-20030102-D00008.TIF" NDATA TIF>
<!ENTITY US20030004671A1-20030102-D00009.TIF SYSTEM "US20030004671A1-20030102-D00009.TIF" NDATA TIF>
<!ENTITY US20030004671A1-20030102-D00010.TIF SYSTEM "US20030004671A1-20030102-D00010.TIF" NDATA TIF>
<!ENTITY US20030004671A1-20030102-D00011.TIF SYSTEM "US20030004671A1-20030102-D00011.TIF" NDATA TIF>
<!ENTITY US20030004671A1-20030102-D00012.TIF SYSTEM "US20030004671A1-20030102-D00012.TIF" NDATA TIF>
<!ENTITY US20030004671A1-20030102-D00013.TIF SYSTEM "US20030004671A1-20030102-D00013.TIF" NDATA TIF>
<!ENTITY US20030004671A1-20030102-D00014.TIF SYSTEM "US20030004671A1-20030102-D00014.TIF" NDATA TIF>
<!ENTITY US20030004671A1-20030102-D00015.TIF SYSTEM "US20030004671A1-20030102-D00015.TIF" NDATA TIF>
<!ENTITY US20030004671A1-20030102-D00016.TIF SYSTEM "US20030004671A1-20030102-D00016.TIF" NDATA TIF>
<!ENTITY US20030004671A1-20030102-D00017.TIF SYSTEM "US20030004671A1-20030102-D00017.TIF" NDATA TIF>
<!ENTITY US20030004671A1-20030102-D00018.TIF SYSTEM "US20030004671A1-20030102-D00018.TIF" NDATA TIF>
<!ENTITY US20030004671A1-20030102-D00019.TIF SYSTEM "US20030004671A1-20030102-D00019.TIF" NDATA TIF>
<!ENTITY US20030004671A1-20030102-D00020.TIF SYSTEM "US20030004671A1-20030102-D00020.TIF" NDATA TIF>
<!ENTITY US20030004671A1-20030102-D00021.TIF SYSTEM "US20030004671A1-20030102-D00021.TIF" NDATA TIF>
<!ENTITY US20030004671A1-20030102-D00022.TIF SYSTEM "US20030004671A1-20030102-D00022.TIF" NDATA TIF>
<!ENTITY US20030004671A1-20030102-D00023.TIF SYSTEM "US20030004671A1-20030102-D00023.TIF" NDATA TIF>
<!ENTITY US20030004671A1-20030102-D00024.TIF SYSTEM "US20030004671A1-20030102-D00024.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030004671</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10155070</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20020528</filing-date>
</domestic-filing-data>
<foreign-priority-data>
<priority-application-number>
<doc-number>2001-196796 (P)</doc-number>
</priority-application-number>
<filing-date>20010628</filing-date>
<country-code>JP</country-code>
</foreign-priority-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G01M019/00</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>702</class>
<subclass>123000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Remote debugging apparatus for executing procedure preregistered in database at program breakpoint</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Isao</given-name>
<family-name>Minematsu</family-name>
</name>
<residence>
<residence-non-us>
<city>Hyogo</city>
<country-code>JP</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
</inventors>
<assignee>
<organization-name>Mitsubishi Denki Kabushiki Kaisha</organization-name>
<assignee-type>03</assignee-type>
</assignee>
<correspondence-address>
<name-1>McDERMOTT, WILL &amp; EMERY</name-1>
<name-2></name-2>
<address>
<address-1>600 13th Street, N.W.</address-1>
<city>Washington</city>
<state>DC</state>
<postalcode>20005-3096</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A remote debugging apparatus that uses a development terminal coupled to an evaluation board with a plurality of processing modules including a processor in a master-slave configuration, includes: a setting module for pre-setting a breakpoint in a program executed in the evaluation board; and a registering module for registering a procedure in a database provided either on the evaluation board or on the development terminal. The procedure is performed for a memory on the evaluation board when the breakpoint is hit. The apparatus further includes; an execution-commencing module for starting the program in the evaluation board; and an execution-controlling module for referencing the database in response to a hit on the breakpoint, and controlling the processing module of the evaluation board to execute a procedure required to be done on the memory of the evaluation board. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> 1. Field of the Invention </paragraph>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> The present invention relates to a software-debugging apparatus that operate in a system configured of a main processor and another processor (such as a coprocessor or a direct memory access controller (DMAC) processor) that can operate in parallel with the main processor. More particularly, the present invention relates to a so-called remote debugging apparatus for debugging software for embedded applications in a master-slave system by using a development terminal. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> 2. Description of the Background Art </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> Conventionally, a typical board (a system) for embedded applications includes a single processor, a memory including a RAM (random access memory) and a ROM (read-only memory), and a logic unit. However, with recent diversities in arithmetic operations and advances in the integration density, so-called multiprocessor configurations are increasingly used. In the multiprocessor configuration, multiple processors are integrated on a board (or, within one chip to be mounted on a board). </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> From the viewpoint of the way of combining processors, multiprocessor architecture is divided into two types. The first type is a parallel type that uses a plurality of identical processors equally related to each other. The second type is a so-called master-slave type in which a master or slave function is explicitly assigned to the individual processors. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> The multiprocessor architecture is also divided into two types in view of the way of connecting processors. The first type is a closely coupled type in which the processors are coupled to each other by using dedicated signal-line interfaces. The second type is a loosely coupled type in which the processors are coupled by using buses or switches. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> Multiprocessor configurations include many types of configurations of intermediate types, in addition to the above-described typical types. Further, the configurations include those built by combining the aforementioned types. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> In the multiprocessor system, programs are executed in multiple processors to thereby implement the overall system function. The aforementioned characteristics make program debugging to be problematic. To solve the problem, improvement needs to be made for, for example, the debug functions, the debugger, and processor-processor interfaces. An example is a processor-processor interface proposed in Japanese Patent Laying-Open No. 10-187486/1998. The processor-processor interface is used in a multiprocessor system of a parallel, and a loosely coupled type. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> In most cases, software for embedded applications on board with a mounted processor is debugged using a development terminal, such as an engineering workstation (EWS). This type of debugging is called &ldquo;remote debugging&rdquo;, and a debugging program is called a &ldquo;remote debugger&rdquo;. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> The remote debugger includes two module sections: one is a front-end section, and the other is a resident monitor section. The front-end section serves as a human-machine interface, activated by the development terminal that is operated by a user (such as a programmer) and the resident monitor section resides on the board. These modules mutually exchange, for example, commands and command-execution results, by using the development terminal and communication functions (such as RS232C, Ethernet(R), and JTAG (Joint Test Action Group)). </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> Primary functions of the debugger include a debugging function using breakpoints. In the breakpoint debugging function, program execution terminates when control of the program execution has reached an instruction at a specified address. The memory address of such an instruction address is called a &ldquo;breakpoint&rdquo;. Generally, when a breakpoint is set, the debugger replaces a specified address in a debug-target program with a specific instruction. During the program execution, when an execution instruction address has reached the specified breakpoint, control branches to a software interrupt handler corresponding to the specific instruction. The interrupt handler saves context of the debug-target program, then passes control to the resident monitor section. Upon receipt of control, the resident monitor section notifies the front-end section that the instruction-execution address has reached the specified breakpoint. Subsequently, control is passed to the front-end section. Thereby, a user can perform debugging. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> For the user to continue the program execution by using a user command, the resident monitor section restores the context of the debug-target program. Then, a return instruction from the software interrupt dispatches execution of the debug-target program to be continued to the resident monitor section. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> In the remote debugging method, to debug a memory-mapped input/output device on a board, even when a user uses a memory-referencing function provided to reference the status of the input/output device after detection of a breakpoint, latency occurs momentary after the breakpoint is reached (hit). This raises problems in that the status when the breakpoint is reached cannot be accurately known, and debugging encounters difficulties. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> These problems are caused not only in software debugging using an ordinary input/output device such as a DMA controller (DMA: direct memory access), but also in a multiprocessor system of the loosely coupled type. In particular, in a multiprocessor system of the master-slave type, even if a program running in the master processor has reached a breakpoint, a program running in the slave processor does not stop immediately. This raises another problem that makes it difficult to debug the overall system. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> The present invention is made to solve the above-described problems, and one of its objects is to provide a remote debugging apparatus that enable the status on an evaluation board at the time of breakpoint hit to be reflected on debugging at higher accuracy in a master-slave type multiprocessor system. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> Another object of the present invention is to provide a remote debugging apparatus that enable the status on an evaluation board at the time of breakpoint hit to be obtained at a higher speed and to be reflected on debugging. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> According to one aspect of the present invention, a remote debugging apparatus, implemented by a computer, for debugging a program executed on an evaluation board including a plurality of processing modules in a master-slave configuration by using a development terminal coupled to the evaluation board includes: a module for pre-setting a breakpoint in the program executed on the evaluation board; a module for registering a procedure to be conducted when a breakpoint is hit in a database; a module for initiating the execution of the program on the evaluation board; and a module for dispatching execution of a procedure on a processing module on the evaluation board to be done upon a memory on the evaluation board by referencing the database in response to a hit on the breakpoint. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> The procedure required when the breakpoint is hit is pre-registered in the database. When the breakpoint is hit, the procedure is read out of the database, and is executed. Compared to a case where a user specifies the procedure when a specified breakpoint is hit, the delay can be reduced in executing debugging operation after a breakpoint is hit. Consequently, the status of the breakpoint-hit-time evaluation board can be accurately reflected on the debugging. Furthermore, the debugging can be facilitated. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> Preferably, the database is provided on the evaluation board. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> With the database provided on the evaluation board, communication need not be performed in the development terminal when the breakpoint is hit. This reduces the overhead for communication, and reduces the delay in executing debugging procedure after a breakpoint-hit. Consequently, the status of the evaluation board at the time of a breakpoint-hit can be reflected more accurately on the debug procedure. Furthermore, the debugging can be facilitated. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> Alternatively, the database may be provided in the development terminal. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> With the database provided in the development terminal, different from the case where the database is provided on the evaluation board, only a function of performing communication with the development terminal needs to be implemented on the evaluation board when the breakpoint is hit. In this case, a debug-dedicated remote resident section of the evaluation board can be minimized. This makes it easy to design the evaluation board. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> The module for registering preferably includes a module for preliminarily registering an address in the memory of the evaluation board into the database provided either on the evaluation board or on the development terminal. The address to be registered into the database is required to be accessed when the breakpoint is hit. The module for dispatching may include a module for referencing the database in response to a hit on the breakpoint in execution of the program, reading out data in the memory of the evaluation board at an address read out of the database, and controlling the processing module to notify the read-out data to the development terminal; and a module for outputting to an outputting module the data notified to the development terminal. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> When the breakpoint is hit, the data can be read out of the evaluation-board memory at the address pre-registered in the database, and the data can be displayed. The time required to read out the data after the breakpoint is hit can be reduced. This enables the status of the evaluation board at the time of a breakpoint-hit to be known even more accurately. Consequently, the debugging of software executed in the evaluation board is facilitated. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> Preferably, the module for registering includes a module for pre-registering in the database an address in the memory of the evaluation board and data required to be written at the address. The address is required to be accessed when the breakpoint is hit, and the database is provided either on the evaluation board or on the development terminal. Furthermore, the module for dispatching may include a module for referencing the database in response to a hit on the breakpoint in execution of the program, and controlling the processing module of the evaluation board to write data read out of the database in the memory of the evaluation board at an address read out of the database. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> When the breakpoint is hit, data pre-registered in the database can be written in the memory of the evaluation board at the address pre-registered in the database. Thereby, the time required to write the data after the breakpoint is hit can be reduced. This enables the status of the evaluation board at the time of a breakpoint-hit to be reflected on the debug even more accurately. Consequently, the debugging of the evaluation board is facilitated. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> The module for registering preferably includes a module for generating an instruction sequence dependent from the processing module required to be executed by the processor of the evaluation board according to a command from a user at the development terminal when the breakpoint is hit to be registered in the database that is provided on the evaluation board. The module for dispatching may include a module for referencing the database in response to a hit on the breakpoint in execution of the program, and providing the processing module with the instruction sequence read out of the database to be executed. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> In the preferable case, a procedure to be executed when the breakpoint is hit is converted into the instruction sequence, and the converted instruction sequence is registered. When the breakpoint is hit, the processing module of the evaluation board is controlled to directly execute the instruction sequence. Thereby, high-rate execution can be achieved for the procedure to be performed for the debug procedure when the breakpoint is hit. Hence, reduction can be achieved for the delay in executing debugging after the breakpoint is hit. That is, the time required to read out the data after the breakpoint is hit can be reduced. This enables the status of the evaluation board at the time of a breakpoint-hit to be known even more accurately. Consequently, the debugging of the evaluation board is facilitated. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> In another aspect of the present invention, the instruction sequence may be created in a machine language that is dependent on the processor configuring the processing module. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> The procedure to be executed by the processing module of the evaluation board at the time of a breakpoint hit is pre-registered in the database in the corresponding machine language. The procedure at the time of a breakpoint-hit can be executed at a high rate. Thereby, the status of the evaluation board at the time of a breakpoint-hit can be known even more accurately. Consequently, the debugging of the evaluation board is facilitated. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> In accordance with still another aspect of the present invention, the module for pre-setting a breakpoint may include a module for receiving information specifying the breakpoint from a user at the development terminal; and a module for replacing an instruction of a debug-target program on the evaluation board, the instruction corresponding to the information specifying the breakpoint, with a branching instruction that branches control to a handler provided to handle a breakpoint-hit. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> The handler is provided to handle a breakpoint hit, and the handler is controlled through a branching instruction to branch control of the procedure to the handler when the breakpoint is hit. Therefore, the procedure at the time of a breakpoint hit can be simplified and executed at a high rate. Thereby, the status of the evaluation board at the time of a breakpoint-hit can be known even more accurately. Consequently, the debugging of the evaluation board is facilitated. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> The foregoing and other objects, features, aspects and advantages of the present invention will become more apparent from the following detailed description of the present invention when taken in conjunction with the accompanying drawings.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a block diagram showing an example configuration of a multiprocessor system; </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a block diagram showing an example configuration of a coprocessor; </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> shows a memory map of the coprocessor as viewed from a master processor; </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> shows the overall configuration of a remote debugger system according to a first embodiment of the present invention; </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a table listing the names and functions of the commands used in the remote debugger system of the first embodiment; </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is a block diagram of a front-end section of the remote debugger system according to the first embodiment; </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 7 and 8</cross-reference> are block diagrams each showing a target board including a resident monitor section of a remote debugger system according to the first embodiment; </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference> is a flowchart showing a control structure of a procedure executed at a breakpoint-setting time in the front-end section of the remote debugger system according to the first embodiment; </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10</cross-reference> is a flowchart showing a control structure of a procedure executed at a breakpoint-setting time in the resident monitor section of the remote debugger system according to the first embodiment; </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 11</cross-reference> is a flowchart showing a control structure of a procedure executed at a debugging time in the front-end section of the remote debugger system according to the first embodiment; </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 12</cross-reference> is a flowchart showing a control structure of a procedure executed at a debugging time in the resident monitor section of the remote debugger system according to the first embodiment; </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 13</cross-reference> shows a display example at a debugging time in the remote debugger system according to the first embodiment; </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 14</cross-reference> shows another display example at a debugging time in the remote debugger system according to the first embodiment; </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 15</cross-reference> shows the overall configuration of a remote debugger system according to a second embodiment of the present invention; </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 16</cross-reference> is a block diagram of a front-end section of the remote debugger system according to the second embodiment; </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 17 and 18</cross-reference> are block diagrams each showing a target board including a resident monitor section of a remote debugger system according to the second embodiment; </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 19</cross-reference> is a flowchart showing a control structure of a procedure executed at a breakpoint-setting time in the front-end section of the remote debugger system according to the second embodiment; </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 20</cross-reference> is a flowchart showing a control structure of a procedure executed at a breakpoint-setting time in the resident monitor section of the remote debugger system according to the second embodiment; </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 21</cross-reference> is a flowchart showing a control structure of a procedure executed at a debugging time in the front-end section of the remote debugger system according to the second embodiment; </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 22</cross-reference> is a flowchart showing a control structure of a procedure executed at a debugging time in the resident monitor section of the remote debugger system according to the second embodiment; </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 23</cross-reference> shows the overall configuration of a remote debugger system according to a third embodiment of the present invention; </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 24</cross-reference> is a block diagram of a front-end section of the remote debugger system according to the third embodiment; </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 25</cross-reference> is a block diagram of a target board including a resident monitor section of a remote debugger system according to the third embodiment; </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 26</cross-reference> shows a configuration of a breakpoint attribute database (DB) in the remote debugger system of the third embodiment; </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 27</cross-reference> is a block diagram of a target board including a resident monitor section of the remote debugger system according to the third embodiment; </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 28</cross-reference> is a flowchart showing a control structure of a procedure executed at a breakpoint-setting time in the front-end section of the remote debugger system according to the third embodiment; </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 29</cross-reference> is a flowchart showing a control structure of a procedure executed at a breakpoint-setting time in the resident monitor section of the remote debugger system according to the third embodiment; </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 30</cross-reference> is a flowchart showing a control structure of a procedure executed at a debugging time in the front-end section of the remote debugger system according to the third embodiment; and </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 31</cross-reference> is a flowchart showing a control structure of a procedure executed at a debugging time in the resident monitor section of the remote debugger system according to the third embodiment.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DESCRIPTION OF THE PREFERRED EMBODIMENTS </heading>
<paragraph id="P-0063" lvl="7"><number>&lsqb;0063&rsqb;</number> First Embodiment </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a functional block diagram showing an example configuration of a multiprocessor system <highlight><bold>50</bold></highlight> as a target for remote debugging system according to a first embodiment of the present invention. Referring to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, multiprocessor system <highlight><bold>50</bold></highlight> includes: a processor (MCU) <highlight><bold>52</bold></highlight> for executing a program to be debugged; a bus <highlight><bold>54</bold></highlight> to which MCU <highlight><bold>52</bold></highlight> is connected; a communication interface <highlight><bold>56</bold></highlight> connected to bus <highlight><bold>54</bold></highlight> for communicating with a remote debugger running on another engineering workstations or the like; ROM <highlight><bold>62</bold></highlight> and RAM <highlight><bold>64</bold></highlight> each connected to bus <highlight><bold>54</bold></highlight>; a DMAC <highlight><bold>58</bold></highlight> connected to bus <highlight><bold>54</bold></highlight>; a coprocessor <highlight><bold>60</bold></highlight> connected to bus <highlight><bold>54</bold></highlight>; and a bus interface <highlight><bold>66</bold></highlight> connected to bus <highlight><bold>54</bold></highlight> for controlling input/output to/from circuits external to the board. </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> MCU <highlight><bold>52</bold></highlight> includes functions for implementing regular breakpoints. Specifically, MCU <highlight><bold>52</bold></highlight> includes (1) a software-interrupt generation instruction, (2) a return instruction from a software-interrupt, and (3) an operational mode allowing one-instruction execution (single step mode). </paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, coprocessor <highlight><bold>60</bold></highlight> includes: a serial interface (SIF) section <highlight><bold>70</bold></highlight> for interfacing coprocessor <highlight><bold>60</bold></highlight> to bus <highlight><bold>54</bold></highlight>; a local instruction memory <highlight><bold>74</bold></highlight> for storing instructions; a local data memory <highlight><bold>76</bold></highlight> for storing data; and a core section <highlight><bold>72</bold></highlight> that includes an arithmetic and logic unit, a memory access controller, and a program-counter (PC) controller. </paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a memory map (viewed from the portion of MCU <highlight><bold>52</bold></highlight>) of control registers included in SIF <highlight><bold>70</bold></highlight>, local instruction and data memories <highlight><bold>74</bold></highlight> and <highlight><bold>76</bold></highlight>. When viewed from MCU <highlight><bold>52</bold></highlight>, coprocessor <highlight><bold>60</bold></highlight> operates as a memory-mapped device through a general-purpose bus. Referring to <cross-reference target="DRAWINGS">FIG. 3, a</cross-reference> HALT_CNT register provided in SIF <highlight><bold>70</bold></highlight> for referencing and controlling the coprocessor is allocated to the head portion of the memory map followed by a PC_CNT register also provided in SIF <highlight><bold>70</bold></highlight> for setting and reading of a program counter (PC). </paragraph>
<paragraph id="P-0068" lvl="0"><number>&lsqb;0068&rsqb;</number> MCU <highlight><bold>52</bold></highlight> references and controls the operation of coprocessor <highlight><bold>60</bold></highlight> through the HALT_CNT register. Specifically, MCU <highlight><bold>52</bold></highlight> writes &ldquo;1&rdquo; to the HALT_CNT register to activate coprocessor <highlight><bold>60</bold></highlight> and &ldquo;0&rdquo; to the HALT_CNT register to terminate coprocessor <highlight><bold>60</bold></highlight>. When &ldquo;0&rdquo; is written to the HALT_CNT register, the operation of coprocessor <highlight><bold>60</bold></highlight> is stopped. When data in the HALT_CNT register read out by MCU <highlight><bold>52</bold></highlight> is &ldquo;1&rdquo;, coprocessor <highlight><bold>60</bold></highlight> is active and when the read-out data is &ldquo;0&rdquo;, coprocessor <highlight><bold>60</bold></highlight> is inactive. </paragraph>
<paragraph id="P-0069" lvl="0"><number>&lsqb;0069&rsqb;</number> By writing a value to the PC_CNT register, a PC count can be set where coprocessor <highlight><bold>60</bold></highlight> starts execution. Furthermore, when coprocessor <highlight><bold>60</bold></highlight> is inactive, a PC value to be executed next can be read out of the PC_CNT register. </paragraph>
<paragraph id="P-0070" lvl="0"><number>&lsqb;0070&rsqb;</number> In multiprocessor system <highlight><bold>50</bold></highlight> illustrated in FIGS. <highlight><bold>1</bold></highlight> to <highlight><bold>3</bold></highlight>, after coprocessor <highlight><bold>60</bold></highlight> is activated, MCU <highlight><bold>52</bold></highlight> need not await completion of the operation of coprocessor <highlight><bold>60</bold></highlight> even while MCU <highlight><bold>52</bold></highlight> operates. Thus, MCU <highlight><bold>52</bold></highlight> and coprocessor <highlight><bold>60</bold></highlight> form a master-slave type and loose-coupled type multiprocessor system wherein MCU <highlight><bold>52</bold></highlight> and coprocessor <highlight><bold>60</bold></highlight> can operate in parallel (simultaneously). </paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> shows the overall configuration of a debugging system using a multiprocessor system according to the first embodiment of the present invention. Referring to <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, the debugging system includes a development terminal <highlight><bold>80</bold></highlight> and a target board <highlight><bold>82</bold></highlight> coupled to development terminal <highlight><bold>80</bold></highlight> via a communication path <highlight><bold>84</bold></highlight>. Target board <highlight><bold>82</bold></highlight> corresponds to multiprocessor system <highlight><bold>50</bold></highlight> shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> In development terminal <highlight><bold>80</bold></highlight>, a front-end section of a debugger operates. The front-end section accepts a command operation of a programmer, and displays the status of software executed on target board <highlight><bold>82</bold></highlight>. On target board <highlight><bold>82</bold></highlight>, a debug-target program is executed, and a resident monitor section of the debugger resides on target board <highlight><bold>82</bold></highlight>. Various types of communication are performed between development terminal <highlight><bold>80</bold></highlight> and target board <highlight><bold>82</bold></highlight> through communication path <highlight><bold>84</bold></highlight> and communication interfaces provided in each unit. </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a table of commands used in the debugging system according to the present invention. In <cross-reference target="DRAWINGS">FIG. 5</cross-reference>, commands are shown in the left column, and their respective functions are shown in the right column. </paragraph>
<paragraph id="P-0074" lvl="0"><number>&lsqb;0074&rsqb;</number> For example, by issuing a &ldquo;break&rdquo; command with a specific address, a desired breakpoint can be set at the address. A serial number (identification (ID) number) is assigned to the breakpoint set by the &ldquo;break&rdquo; command. By issuing an &ldquo;atbreak&rdquo; command with a specific ID number as one of parameters, what should be done when the breakpoint is hit can be specified as a breakpoint attribute. </paragraph>
<paragraph id="P-0075" lvl="0"><number>&lsqb;0075&rsqb;</number> The syntax of the &ldquo;atbreak&rdquo; command is as follows: </paragraph>
<paragraph id="P-0076" lvl="2"><number>&lsqb;0076&rsqb;</number> atbreak n address (value) (size) </paragraph>
<paragraph id="P-0077" lvl="0"><number>&lsqb;0077&rsqb;</number> Here, the above parameters are, from the left, a breakpoint number (ID number) &ldquo;n&rdquo;, the &ldquo;address&rdquo; of the read/write target memory, a &ldquo;value&rdquo; to be written at a write, and the read/write memory size &ldquo;size&rdquo;. The parameters in parentheses can be omitted. When the parameter &ldquo;value&rdquo; is omitted, memory values are at an address specified by the parameter &ldquo;address&rdquo; is read out at the breakpoint &ldquo;n&rdquo;. When the parameter &ldquo;value&rdquo; is specified, the parameter &ldquo;value&rdquo; is written to the address specified by the parameter &ldquo;address&rdquo;. When the parameter &ldquo;size&rdquo; is omitted, the memory read/write size is set to a default size (four bytes). </paragraph>
<paragraph id="P-0078" lvl="0"><number>&lsqb;0078&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> shows functions in the front-end section of development terminal <highlight><bold>80</bold></highlight> for implementing the aforementioned &ldquo;atbreak&rdquo; command, in the form of a block diagram. Referring to <cross-reference target="DRAWINGS">FIG. 6</cross-reference>, development terminal <highlight><bold>80</bold></highlight> includes: a communication interface <highlight><bold>102</bold></highlight> connected to communication path <highlight><bold>84</bold></highlight>; a monitor <highlight><bold>96</bold></highlight> and an input unit <highlight><bold>98</bold></highlight> for providing interactive operations with a programmer and for accepting and outputting commands or data; and a program-executing unit <highlight><bold>90</bold></highlight> connected to communication I/F <highlight><bold>102</bold></highlight>, monitor <highlight><bold>96</bold></highlight> and input unit <highlight><bold>98</bold></highlight> for controlling execution of a program on the target board in response to programmer&apos;s commands. Development terminal <highlight><bold>80</bold></highlight> further includes: a breakpoint-setting unit <highlight><bold>92</bold></highlight> connected to communication I/F <highlight><bold>102</bold></highlight>, monitor <highlight><bold>96</bold></highlight> and input unit <highlight><bold>98</bold></highlight> for setting a breakpoint in a program to be executed on the target board; a breakpoint attribute DB <highlight><bold>100</bold></highlight> for storing a procedure, for each break point, to be done on the target board when the breakpoint is hit (In this specification, the processing is referred to as an &ldquo;attribute&rdquo; of a breakpoint.); and a break-time process registration unit <highlight><bold>94</bold></highlight> connected to breakpoint-setting unit <highlight><bold>98</bold></highlight>, monitor <highlight><bold>96</bold></highlight> and input unit <highlight><bold>98</bold></highlight> for receiving an attribute to a breakpoint from the programmer every time a breakpoint is established and for registering the attribute of the breakpoint in DB <highlight><bold>100</bold></highlight>. </paragraph>
<paragraph id="P-0079" lvl="0"><number>&lsqb;0079&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 7</cross-reference>, target board <highlight><bold>82</bold></highlight> includes: a program-executing unit <highlight><bold>114</bold></highlight> with a MCU; a program counter (PC) <highlight><bold>112</bold></highlight> for specifying an address of an instruction to be executed by program execution unit <highlight><bold>114</bold></highlight>; an instruction memory <highlight><bold>116</bold></highlight> for storing instructions to be executed by program executing unit <highlight><bold>114</bold></highlight>; and a data memory <highlight><bold>122</bold></highlight>. Command memory <highlight><bold>116</bold></highlight> and data memory <highlight><bold>122</bold></highlight> are coupled to a bus <highlight><bold>142</bold></highlight>. </paragraph>
<paragraph id="P-0080" lvl="0"><number>&lsqb;0080&rsqb;</number> The resident monitor section of the debugger running on target board <highlight><bold>82</bold></highlight> includes: a communication interface <highlight><bold>56</bold></highlight> coupled to communication path <highlight><bold>84</bold></highlight>; a PC-setting unit <highlight><bold>110</bold></highlight> for setting a value of PC <highlight><bold>112</bold></highlight> in accordance with a programmer&apos;s command and for starting the execution of a program in program execution unit <highlight><bold>114</bold></highlight>; and a replacement-processing unit <highlight><bold>118</bold></highlight> coupled to communication interface <highlight><bold>56</bold></highlight> for replacing an instruction at an address in program <highlight><bold>130</bold></highlight> designated by development terminal <highlight><bold>80</bold></highlight> as a breakpoint with a specific breakpoint instruction <highlight><bold>132</bold></highlight> and for creating a program backup before the replacement. </paragraph>
<paragraph id="P-0081" lvl="0"><number>&lsqb;0081&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 8</cross-reference>, resident monitor section further includes a process handler <highlight><bold>140</bold></highlight> coupled to communication interface <highlight><bold>56</bold></highlight>, being activated by a breakpoint instruction <highlight><bold>132</bold></highlight> executed by program execution unit <highlight><bold>114</bold></highlight>, for performing a procedure of debugging, including data write/read access to a location in data memory <highlight><bold>122</bold></highlight> that corresponds to the HALT_CNT register. </paragraph>
<paragraph id="P-0082" lvl="0"><number>&lsqb;0082&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference> shows a procedure executed when a breakpoint is set in the front-end section of the debugger in development terminal <highlight><bold>80</bold></highlight>. Referring to <cross-reference target="DRAWINGS">FIG. 9</cross-reference>, first, at step <highlight><bold>170</bold></highlight>, parameters entered are verified for, for example, the validity of an entered breakpoint ID number and the memory-address alignment. At step <highlight><bold>170</bold></highlight>, if the parameters are determined to be invalid, the procedure terminates. If the parameters are determined to be valid in step <highlight><bold>170</bold></highlight>, control is then passed to step <highlight><bold>172</bold></highlight>. </paragraph>
<paragraph id="P-0083" lvl="0"><number>&lsqb;0083&rsqb;</number> At step <highlight><bold>172</bold></highlight>, the specified breakpoint ID number and breakpoint-hit-time memory-readout/write procedure associated with the breakpoint are registered in breakpoint attribute DB <highlight><bold>100</bold></highlight> allocated in an internal storage of development terminal <highlight><bold>80</bold></highlight>. </paragraph>
<paragraph id="P-0084" lvl="0"><number>&lsqb;0084&rsqb;</number> Subsequently, at step <highlight><bold>174</bold></highlight>, the breakpoint ID number and the address of a breakpoint instruction are notified to replacement-processing unit <highlight><bold>118</bold></highlight> in the resident monitor section. The front-end section waits for a response from replacement-processing unit <highlight><bold>118</bold></highlight> in the resident monitor section (step <highlight><bold>176</bold></highlight>) and terminates its procedure upon the response from the resident monitor section. </paragraph>
<paragraph id="P-0085" lvl="0"><number>&lsqb;0085&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 10</cross-reference>, the procedure done in the resident monitor section is as follows. First, at step <highlight><bold>180</bold></highlight>, a backup is created for the program specified to be a debug target. Subsequently, at step <highlight><bold>182</bold></highlight>, the instruction at the specified address is replaced with a breakpoint instruction. In practice, the breakpoint instruction generates a software interrupt that transfers control to a handler corresponding to the instruction at the breakpoint. Then, at step <highlight><bold>184</bold></highlight>, the resident monitor section notifies completion of the procedure to development terminal <highlight><bold>80</bold></highlight>, and terminates the procedure. </paragraph>
<paragraph id="P-0086" lvl="0"><number>&lsqb;0086&rsqb;</number> The above-described procedure completes the preparation for the intended debugging. </paragraph>
<paragraph id="P-0087" lvl="0"><number>&lsqb;0087&rsqb;</number> In practice, the following procedure is executed at the time of debugging. Referring to <cross-reference target="DRAWINGS">FIG. 11</cross-reference>, in the front-end section of development terminal <highlight><bold>80</bold></highlight>, first, at step <highlight><bold>190</bold></highlight>, in response to a command entered by a programmer, a start address of a debug-target program is specified, and the execution commencement of the debug-target program is notified to the resident monitor section. Then, the front-end section waits for a response from the resident monitor section (step <highlight><bold>192</bold></highlight>). PC-setting unit <highlight><bold>110</bold></highlight> in the resident monitor section sets the specified start address into PC <highlight><bold>112</bold></highlight> and dispatches execution of the program to be commenced to program-executing unit <highlight><bold>114</bold></highlight>. When the program executed by program-executing unit <highlight><bold>114</bold></highlight> reaches the breakpoint (shown by reference numeral <highlight><bold>152</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 8</cross-reference>), a software-interrupt generating instruction <highlight><bold>132</bold></highlight> in place of the original instruction is executed (reference numeral <highlight><bold>154</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 8</cross-reference>) and control transfers to process handler <highlight><bold>140</bold></highlight> (reference numeral <highlight><bold>156</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 8</cross-reference>). The transfer of the control and the ID number of the hit breakpoint are notified to the front-end section. </paragraph>
<paragraph id="P-0088" lvl="0"><number>&lsqb;0088&rsqb;</number> Upon receipt of the response from the resident monitor section that the breakpoint is reached, the front-end section accesses breakpoint attribute DB <highlight><bold>100</bold></highlight> with the returned ID number as a key and retrieves the information of the breakpoint-hit-time procedure. The retrieved information is notified to the resident monitor section (step <highlight><bold>196</bold></highlight>). In response to the information, resident monitor section performs a procedure corresponding to the notified procedure, and if the notified procedure is a memory-read, the contents read out of the memory are forwarded to the front-end section. </paragraph>
<paragraph id="P-0089" lvl="0"><number>&lsqb;0089&rsqb;</number> At step <highlight><bold>198</bold></highlight>, the front-end section determines whether the breakpoint-hit-time procedure is a memory-read. If not, the front-end section terminates the procedure. If the procedure is determined to be a memory-read, the front-end section waits for a memory-read-result notification from the resident monitor section (step <highlight><bold>200</bold></highlight>). Upon receipt of the notification, the front-end section controls monitor <highlight><bold>96</bold></highlight> to display the contents of the memory (at step <highlight><bold>202</bold></highlight>). Then, the procedure terminates. </paragraph>
<paragraph id="P-0090" lvl="0"><number>&lsqb;0090&rsqb;</number> When the breakpoint is hit, the resident monitor section executes a procedure shown in <cross-reference target="DRAWINGS">FIG. 12</cross-reference>. The procedure commences with an automatic control branch to process handler <highlight><bold>140</bold></highlight> in conjunction with the execution of software-interrupt generating instruction <highlight><bold>132</bold></highlight> (reference numerals <highlight><bold>152</bold></highlight>, <highlight><bold>154</bold></highlight>, and <highlight><bold>156</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 8</cross-reference> in this order), which is replaced with the original instruction when the breakpoint is set. A function for implementing step <highlight><bold>210</bold></highlight> is at the head of process handler <highlight><bold>140</bold></highlight>. That is, the function is built-in as a part of the resident monitor section. At step <highlight><bold>210</bold></highlight>, the context (register contents) of the debug target software is saved in part of data memory <highlight><bold>122</bold></highlight> allocated to the resident monitor section. Subsequently, at step <highlight><bold>211</bold></highlight>, the resident monitor section notifies the front-end section of the breakpoint-hit instance and an ID number of the hit breakpoint. According to this notification, control transfers to the front-end section (step <highlight><bold>194</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 11</cross-reference>). At step <highlight><bold>212</bold></highlight>, in response to the notification, the front-end section notifies the resident monitor section of the type of the breakpoint-hit-time procedure and the attribute. At step <highlight><bold>214</bold></highlight>, upon receipt of necessary information, the resident monitor section performs a procedure of a type determined according to the information. Specifically, when the breakpoint-hit-time procedure is a read out for reading out data from the memory at a predetermined address, the memory contents are read out. Alternatively, when the breakpoint-hit-time procedure is a memory write for writing data to the memory at a prescribed address, the data transferred from the front-end section is written into the memory at the address (reference numeral <highlight><bold>158</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 8</cross-reference>). </paragraph>
<paragraph id="P-0091" lvl="0"><number>&lsqb;0091&rsqb;</number> Subsequently, at step <highlight><bold>216</bold></highlight>, the resident monitor section determines whether the executed procedure is a memory-read. If not, the resident monitor section terminates the procedure. If it is a memory-read, at step <highlight><bold>218</bold></highlight>, the resident monitor section notifies the front-end section of the read result. Then, procedure terminates. </paragraph>
<paragraph id="P-0092" lvl="0"><number>&lsqb;0092&rsqb;</number> So far, the overall debug operation performed in the system according to the first embodiment is described. <cross-reference target="DRAWINGS">FIG. 13</cross-reference> shows an output example 220 of operation of the debugger according to the present embodiment. In <cross-reference target="DRAWINGS">FIG. 13</cross-reference>, the boldface represents items entered by the user (programmer), and others present items output by the debugger. As shown in the figure, a debug target program is loaded in response to a &ldquo;load&rdquo; command <highlight><bold>222</bold></highlight>. Then, a breakpoint is set in response to a &ldquo;break&rdquo; command <highlight><bold>224</bold></highlight> subsequently entered. In example 220 shown in <cross-reference target="DRAWINGS">FIG. 13</cross-reference>, from the debugger output item subsequent to the &ldquo;break&rdquo; command <highlight><bold>224</bold></highlight>, the identification number of the breakpoint can be known to be &ldquo;1&rdquo;. Moreover, with an &ldquo;atbreak&rdquo; command <highlight><bold>226</bold></highlight> entered, an attribute is set for the breakpoint. In this particular case, a readout operation for the address &ldquo;0&times;40001000&rdquo; at the breakpoint &ldquo;1&rdquo; is set for the attribute. Since no value is specified after the address parameter, the hit-time operation can be known to be &ldquo;readout&rdquo;. </paragraph>
<paragraph id="P-0093" lvl="0"><number>&lsqb;0093&rsqb;</number> Subsequently, a &ldquo;run&rdquo; command <highlight><bold>228</bold></highlight> specifies that the program is executed from the address &ldquo;0&rdquo;. As a result, the program is executed in the resident monitor section. Then, when the breakpoint of the identification number &ldquo;1&rdquo; is hit, the monitor displays the contents of the memory address specified by the &ldquo;atbreak&rdquo; command <highlight><bold>226</bold></highlight> (reference numeral <highlight><bold>230</bold></highlight>). </paragraph>
<paragraph id="P-0094" lvl="0"><number>&lsqb;0094&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 14</cross-reference> shows another example 240 representing operation and output of the debugger according to the present embodiment. In the example 240, the PC value in the coprocessor at the time the MCU of the target board hits a breakpoint is examined. For a program loaded in response to a &ldquo;load&rdquo; command, the breakpoint is set to a predetermined address. In the example 240, the breakpoint is set at address &ldquo;100&rdquo;, and the identification number is set to &ldquo;1&rdquo;. </paragraph>
<paragraph id="P-0095" lvl="0"><number>&lsqb;0095&rsqb;</number> Subsequently, an &ldquo;atbreak&rdquo; command <highlight><bold>242</bold></highlight> sets an attribute of the breakpoint (reference numeral <highlight><bold>242</bold></highlight>). In the particular example, at the breakpoint of the identification number &ldquo;1&rdquo;, the command <highlight><bold>242</bold></highlight> specifies the operation of writing &ldquo;0&rdquo; into the HALT_CNT register that is mapped to the address &ldquo;0&times;400000000&rdquo;. Specifically, the command has specified termination of the coprocessor when the breakpoint is hit. </paragraph>
<paragraph id="P-0096" lvl="0"><number>&lsqb;0096&rsqb;</number> Subsequently, the program is executed in response to a &ldquo;run&rdquo; command, and the monitor displays a message <highlight><bold>244</bold></highlight> that the breakpoint <highlight><bold>1</bold></highlight> is hit. In this particular case, the programmer examines the value of the PC_CNT register mapped to the address &ldquo;0&times;40000004&rdquo;. </paragraph>
<paragraph id="P-0097" lvl="0"><number>&lsqb;0097&rsqb;</number> In the present embodiment, simplified items have been used with reference to, for example, the target-board configuration, coprocessor specifications, debugger commands for the simplicity purposes. However, as a matter of course, the remote debugger employing the idea of the present embodiment may be implemented with a more complicated configuration. For example, the embodiment is not limited by an example where the programmer enters the debugger commands on the command lines, and the command entry may be instead implemented by using, for example, a GUI (graphical user interface). In addition, the configuration in the coprocessor and the internal resources that can be referenced from the side of the MCU are not limited to the examples shown in the present embodiment. </paragraph>
<paragraph id="P-0098" lvl="0"><number>&lsqb;0098&rsqb;</number> The system of the first embodiment advantageously dispenses with hardware dedicated to debugging on MCU to implement the debugging of a system including an MCU and slave-type loosely coupled processor (which may be a DMCA). In addition, because of the above-described functions for debugging, termination of a coprocessor, examination of the status of a coprocessor or the like can be easily implemented without a debugger dedicated to the coprocessor. That is, a debugging environment can be established that is parasitic on the debugger for MCU <highlight><bold>52</bold></highlight>. Consequently, the user can perform the overall software debugging only by operating the single debugger and therefore, this facilitates the debugging of a software configuration in which programs in an MCU and a coprocessor operate in cooperation. </paragraph>
<paragraph id="P-0099" lvl="7"><number>&lsqb;0099&rsqb;</number> (Second Embodiment) </paragraph>
<paragraph id="P-0100" lvl="0"><number>&lsqb;0100&rsqb;</number> In the debugging environment according to the first embodiment, development terminal <highlight><bold>80</bold></highlight> is notified that the control has reached a breakpoint. In response, development terminal <highlight><bold>80</bold></highlight> retrieves the procedure contents, and sends the retrieval result to the resident monitor section. Then, the resident monitor section performs a procedure corresponding to the contents sent from the development terminal. However, the control more or less involves a delay between the time when control reached the breakpoint and the time the actual memory-readout/write procedure is done. Because the coprocessor (or DMAC processor) continues operation in that time delay; therefore, the shorter the delay, the easier it is to obtain accurate information at the breakpoint-hit time. A debugger of a second embodiment is configured to be capable of reducing the delay. </paragraph>
<paragraph id="P-0101" lvl="0"><number>&lsqb;0101&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 15</cross-reference>, similarly to the first embodiment, the debugger system of the second embodiment includes a development terminal <highlight><bold>250</bold></highlight> and a target board <highlight><bold>252</bold></highlight> coupled to development terminal <highlight><bold>250</bold></highlight> via communication path <highlight><bold>84</bold></highlight>. As described above, in the debugger system of the first embodiment, breakpoint attribute DB <highlight><bold>100</bold></highlight> is included in the front-end section of development terminal <highlight><bold>250</bold></highlight>. However, in the second embodiment, a breakpoint attribute DB <highlight><bold>272</bold></highlight> (shown in <cross-reference target="DRAWINGS">FIG. 17</cross-reference>) corresponding to DB <highlight><bold>100</bold></highlight> is allocated in a resident monitor section of target board <highlight><bold>252</bold></highlight>. This enables the debugger of the second embodiment to reduce the aforementioned delay. </paragraph>
<paragraph id="P-0102" lvl="0"><number>&lsqb;0102&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 16</cross-reference>, the front-end section of development terminal <highlight><bold>250</bold></highlight> according to the second embodiment is different from the front-end section of the first embodiment shown in <cross-reference target="DRAWINGS">FIG. 6</cross-reference> in that: the front-end section of development terminal <highlight><bold>250</bold></highlight> does not include a database corresponding to breakpoint attribute DB <highlight><bold>100</bold></highlight> of the first embodiment shown in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>; and that the front-end section of the second embodiment includes, instead of unit <highlight><bold>94</bold></highlight> that registers the breakpoint-hit-time procedure to DB <highlight><bold>100</bold></highlight>, a break-time process registration unit <highlight><bold>260</bold></highlight> coupled to monitor <highlight><bold>96</bold></highlight> and input unit <highlight><bold>98</bold></highlight> for notifying the resident monitor section what procedure should be done (entered by a programmer through monitor <highlight><bold>96</bold></highlight> and input unit <highlight><bold>98</bold></highlight>) when control hits a breakpoint, thereby causing the procedure to be registered in breakpoint attribute DB provided in the resident monitor section. Other functional blocks of the front-end section are the same as those of the front-end section shown in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>. In <cross-reference target="DRAWINGS">FIG. 16</cross-reference>, therefore, the same names and reference numerals denote the same component members as shown in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>. Hence, the detailed descriptions thereof will not repeated here. </paragraph>
<paragraph id="P-0103" lvl="0"><number>&lsqb;0103&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIGS. 17 and 18</cross-reference>, the resident monitor section of target board <highlight><bold>252</bold></highlight> according to the second embodiment is different from the resident monitor section according to the first embodiment shown in <cross-reference target="DRAWINGS">FIGS. 7 and 8</cross-reference>, as follows. Referring to <cross-reference target="DRAWINGS">FIG. 17</cross-reference>, in addition to the process blocks of configuration members shown in <cross-reference target="DRAWINGS">FIG. 7</cross-reference>, the resident monitor section includes a database registration unit <highlight><bold>270</bold></highlight> that receives the contents of the breakpoint-hit-time procedure from break-time process registration unit <highlight><bold>260</bold></highlight> of the front-end section and registers the aforementioned data in breakpoint attribute DB <highlight><bold>272</bold></highlight> allocated to an internal storage. </paragraph>
<paragraph id="P-0104" lvl="0"><number>&lsqb;0104&rsqb;</number> In addition, referring to <cross-reference target="DRAWINGS">FIG. 18</cross-reference>, instead of handler <highlight><bold>140</bold></highlight> shown in <cross-reference target="DRAWINGS">FIG. 8</cross-reference>, the resident monitor section includes a handler <highlight><bold>280</bold></highlight> as a functional block used in debugging. Different from process handler <highlight><bold>140</bold></highlight>, handler <highlight><bold>280</bold></highlight> does not handle the notification of breakpoint-hit-time data to the front-end section via the communication interface. Handler <highlight><bold>280</bold></highlight> references breakpoint attribute DB <highlight><bold>272</bold></highlight> provided in the resident monitor section, determines the type of procedure required at the breakpoint-hit time, and performs the determined procedure. </paragraph>
<paragraph id="P-0105" lvl="0"><number>&lsqb;0105&rsqb;</number> In <cross-reference target="DRAWINGS">FIGS. 17 and 18</cross-reference> and <cross-reference target="DRAWINGS">FIGS. 7 and 8</cross-reference>, the same blocks are labeled with the same reference numerals and names. Hence, the detailed descriptions thereof will not be repeated here. </paragraph>
<paragraph id="P-0106" lvl="0"><number>&lsqb;0106&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 19</cross-reference> is a flowchart of procedure executed when a breakpoint is set in the front-end section of the debugger system according to the second embodiment. Referring to <cross-reference target="DRAWINGS">FIG. 19</cross-reference>, the entered parameters are checked. For example, the validity of an entered breakpoint ID number and the memory-address alignment (step <highlight><bold>170</bold></highlight>) and the like are checked. If the parameters are not valid, procedure terminates. If the parameters are valid, control proceeds to step <highlight><bold>290</bold></highlight>. </paragraph>
<paragraph id="P-0107" lvl="0"><number>&lsqb;0107&rsqb;</number> At step <highlight><bold>290</bold></highlight>, replacement-processing unit <highlight><bold>118</bold></highlight> and database registration unit <highlight><bold>270</bold></highlight> are notified of the ID number of a specified breakpoint, the instruction address at the breakpoint, and the contents of breakpoint-hit-time memory-readout/write procedure associated with the breakpoint. </paragraph>
<paragraph id="P-0108" lvl="0"><number>&lsqb;0108&rsqb;</number> Subsequently, at step <highlight><bold>292</bold></highlight>, the front-end section waits for a response from the resident monitor section. When a response is received from the resident monitor section, the procedure terminates. </paragraph>
<paragraph id="P-0109" lvl="0"><number>&lsqb;0109&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 20</cross-reference> is a flowchart of the procedure performed in the resident monitor section in response to the notification received from the front-end section at step <highlight><bold>290</bold></highlight>. Referring to <cross-reference target="DRAWINGS">FIG. 20</cross-reference>, first, at step <highlight><bold>316</bold></highlight>, a procedure is performed to register the notified contents of the breakpoint-hit-time procedure into breakpoint attribute DB <highlight><bold>272</bold></highlight>. The procedure of step <highlight><bold>316</bold></highlight> corresponds to the registration to database registration unit <highlight><bold>270</bold></highlight> shown in <cross-reference target="DRAWINGS">FIG. 17</cross-reference>. Subsequently, at step <highlight><bold>180</bold></highlight>, a backup of program <highlight><bold>130</bold></highlight> is created. Then, at step <highlight><bold>182</bold></highlight>, the instruction at the notified address is replaced with software-interrupt generating instruction <highlight><bold>132</bold></highlight> that transfers the control to handler <highlight><bold>280</bold></highlight>. Then, at step <highlight><bold>184</bold></highlight>, the resident monitor section notifies the front-end-section of the completion of the procedure. The procedure of the above-described steps corresponds to the procedure that is executed by the function of replacement-processing unit <highlight><bold>118</bold></highlight> shown in <cross-reference target="DRAWINGS">FIG. 17</cross-reference>. </paragraph>
<paragraph id="P-0110" lvl="0"><number>&lsqb;0110&rsqb;</number> As described above, through the procedure shown in <cross-reference target="DRAWINGS">FIGS. 19 and 20</cross-reference>, the instruction of program <highlight><bold>130</bold></highlight> at the breakpoint is replaced with software-interrupt generating instruction <highlight><bold>132</bold></highlight> that transfers the control to the handler. In addition, the breakpoint-hit-time procedure is registered in breakpoint attribute DB <highlight><bold>272</bold></highlight>. </paragraph>
<paragraph id="P-0111" lvl="0"><number>&lsqb;0111&rsqb;</number> Debug procedure will be described below. Referring to <cross-reference target="DRAWINGS">FIG. 21</cross-reference>, first, at step <highlight><bold>190</bold></highlight>, in response to the command entered by the programmer, a start address of a debug-target program is specified, and the execution commencement of the program is notified to the resident monitor section. Subsequently, at step <highlight><bold>198</bold></highlight>, the front-end section determines whether the breakpoint-hit-time procedure is a memory-read. If not, the procedure terminates. If it is a memory-read, the front-end section waits for a memory-read-result notification (step <highlight><bold>200</bold></highlight>). Upon receipt of the notification, at step <highlight><bold>202</bold></highlight>, the front-end section controls monitor <highlight><bold>96</bold></highlight> to display the contents of the memory. Then, procedure terminates. </paragraph>
<paragraph id="P-0112" lvl="0"><number>&lsqb;0112&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 22, a</cross-reference> description will be made in the following on the procedure performed by the resident monitor section. Referring to <cross-reference target="DRAWINGS">FIG. 22</cross-reference>, when a breakpoint is hit, instead of passing control to the front-end section, the resident monitor section of the second embodiment accesses at step <highlight><bold>320</bold></highlight> the breakpoint attribute DB <highlight><bold>272</bold></highlight> provided in a memory area allocated on target board <highlight><bold>252</bold></highlight> for the resident monitor section. The resident monitor section reads out information and at step <highlight><bold>214</bold></highlight>, it performs a procedure determined according to the read-out information. Specifically, if the breakpoint-hit-time procedure is reading data from the memory at a predetermined address, the memory contents are read out. Alternatively, when the breakpoint-hit-time procedure is writing data into the memory at a predetermined address, the data transferred from the front-end section is written into the memory area at the predetermined address (as shown by reference numeral <highlight><bold>158</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 18</cross-reference>). </paragraph>
<paragraph id="P-0113" lvl="0"><number>&lsqb;0113&rsqb;</number> Subsequently, at step <highlight><bold>216</bold></highlight>, the resident monitor section determines whether the executed procedure is a memory-read (step <highlight><bold>216</bold></highlight>). If not, the procedure terminates. If it is a memory-read, at step <highlight><bold>218</bold></highlight> the resident monitor section notifies the front-end section of the read-out result. Then, the procedure terminates. </paragraph>
<paragraph id="P-0114" lvl="0"><number>&lsqb;0114&rsqb;</number> As described above, in the second embodiment, after the breakpoint is hit, communication is not performed in the front-end section and the resident monitor section before the execution of the memory-readout/write. However, the information required can instead be obtained on target board <highlight><bold>252</bold></highlight>. Hence, the overhead for communication with the front-end section is reduced, and the delay can be reduced between the breakpoint-hit time and the execution time of the memory-readout/write. Consequently, even more accurate breakpoint-hit-time information can be examined, and even more efficient debugging can be performed for coprocessors and other units. </paragraph>
<paragraph id="P-0115" lvl="7"><number>&lsqb;0115&rsqb;</number> (Third Embodiment) </paragraph>
<paragraph id="P-0116" lvl="0"><number>&lsqb;0116&rsqb;</number> In the remote debugger according to the second embodiment, breakpoint attribute DB <highlight><bold>272</bold></highlight> is used to register procedure items, such as the type of readout/write and target addresses of the readout/write when the breakpoint attributes are to be set. In debugging, breakpoint attribute DB <highlight><bold>272</bold></highlight> is referenced when a breakpoint is hit before the associated information is retrieved, and actual procedure is determined according to the contents of the retrieved information. </paragraph>
<paragraph id="P-0117" lvl="0"><number>&lsqb;0117&rsqb;</number> In the debugger of the second embodiment, however, latency is caused since the procedure type is selected according to the result of referencing to breakpoint attribute DB <highlight><bold>272</bold></highlight>. The latency causes a delay in the period from the breakpoint-hit time up to the execution time of the memory-readout/write procedure. Hence, if the delay is reduced, the accuracy of the breakpoint-hit-time information can further be improved; that is, even more accurate breakpoint-hit-time information can be obtained. </paragraph>
<paragraph id="P-0118" lvl="0"><number>&lsqb;0118&rsqb;</number> To reduce the delay, the remote debugger system of the third embodiment is configured such that the procedure items such as the type of readout/write and the address are not registered in breakpoint attribute DB <highlight><bold>272</bold></highlight> but that process handlers (subroutines) are created and prestored in RAM <highlight><bold>64</bold></highlight> that will be directly invoked at the time of debugging. The handlers are each composed of an instruction sequence (created in an MCU-dependent language) that can be executed by MCU provided for implementing the readout/write procedure. Each of the process handlers is formed of a machine-language instruction sequence dedicated to a corresponding breakpoint and therefore, the procedure can be performed at a higher rate, compared to the case where a general-purpose handler is used. </paragraph>
<paragraph id="P-0119" lvl="0"><number>&lsqb;0119&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 23</cross-reference> shows an overall configuration of a remote debugger system according to the third embodiment of the present invention. Referring to <cross-reference target="DRAWINGS">FIG. 23</cross-reference>, the debugger system of the third embodiment includes a development terminal <highlight><bold>330</bold></highlight> upon which a front end section operates that has a function of creating the above-described subroutines, and a target board <highlight><bold>332</bold></highlight> coupled to development terminal <highlight><bold>330</bold></highlight> via communication path <highlight><bold>84</bold></highlight> upon which a resident monitor section operates. The resident monitor section has a function for executing a corresponding one of the subroutines when a breakpoint is reached. Development terminal <highlight><bold>330</bold></highlight> corresponds to multiprocessor system <highlight><bold>50</bold></highlight> as shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. </paragraph>
<paragraph id="P-0120" lvl="0"><number>&lsqb;0120&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 24</cross-reference> is a functional block diagram of the front-end section of development terminal <highlight><bold>330</bold></highlight>. The front-end section is different from that of the second embodiment shown in <cross-reference target="DRAWINGS">FIG. 16</cross-reference> in that, in place of unit <highlight><bold>260</bold></highlight> that only transfers breakpoint-hit-time procedure items to the resident monitor section, the front-end section of development terminal <highlight><bold>330</bold></highlight> includes a break-time process registration unit <highlight><bold>340</bold></highlight> that has a function to generate data dependent on the processor in the debug-target system (that is, the data represents subroutines each composed of an instruction sequence that can be executed by the processor), and transfers the data (subroutine) to the resident monitor section. This function is executed according to the breakpoint-hit-time procedure items entered through a program. </paragraph>
<paragraph id="P-0121" lvl="0"><number>&lsqb;0121&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 24</cross-reference>, the same components as those in <cross-reference target="DRAWINGS">FIG. 16</cross-reference> are labeled with the same names and reference numerals in <cross-reference target="DRAWINGS">FIG. 16</cross-reference>. Hence, the detailed descriptions thereof will not repeated here. </paragraph>
<paragraph id="P-0122" lvl="0"><number>&lsqb;0122&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 25 and 27</cross-reference> each show a configuration of the resident monitor section that operates on target board <highlight><bold>332</bold></highlight>. As shown in the <cross-reference target="DRAWINGS">FIG. 25</cross-reference>, the resident monitor section of target board <highlight><bold>332</bold></highlight> according to the third embodiment is different from that of the second embodiment shown in <cross-reference target="DRAWINGS">FIG. 17</cross-reference>, as follows. In the configuration shown in <cross-reference target="DRAWINGS">FIG. 25</cross-reference>, in place of database registration unit <highlight><bold>270</bold></highlight> that registers data to breakpoint attribute DB <highlight><bold>272</bold></highlight>, the resident monitor section of the third embodiment includes a subroutine database registration unit <highlight><bold>350</bold></highlight> coupled to communication interface <highlight><bold>56</bold></highlight> for storing subroutines <highlight><bold>354</bold></highlight>, <highlight><bold>356</bold></highlight>, <highlight><bold>358</bold></highlight> and so forth in instruction memory <highlight><bold>116</bold></highlight>, that are received from front-end section via communication interface <highlight><bold>56</bold></highlight>, to be executed at a breakpoint hit and for registering data as shown in <cross-reference target="DRAWINGS">FIG. 26</cross-reference> into breakpoint attribute DB <highlight><bold>352</bold></highlight>. Specifically, the registration data represents associated data of addresses of memory fields storing individual subroutines and ID numbers of breakpoints corresponding to the individual subroutines. </paragraph>
<paragraph id="P-0123" lvl="0"><number>&lsqb;0123&rsqb;</number> The resident monitor section shown in <cross-reference target="DRAWINGS">FIG. 27</cross-reference> is different from the resident monitor section of the second embodiment shown in <cross-reference target="DRAWINGS">FIG. 18</cross-reference>, as follows. The resident monitor section shown in <cross-reference target="DRAWINGS">FIG. 27</cross-reference> includes a process handler <highlight><bold>360</bold></highlight> in place of handler <highlight><bold>280</bold></highlight> that accesses breakpoint attribute DB <highlight><bold>272</bold></highlight>, reads out procedure items, and performs a procedure specified in the procedure items. Process handler <highlight><bold>360</bold></highlight> accesses breakpoint attribute DB <highlight><bold>352</bold></highlight> (as shown by reference numeral <highlight><bold>370</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 27</cross-reference>) with a key of the ID number of a corresponding breakpoint. Then, process handler <highlight><bold>360</bold></highlight> reads out the address where a corresponding one of the subroutines is stored, and sets the read-out address into PC <highlight><bold>112</bold></highlight> (as shown by reference numeral <highlight><bold>372</bold></highlight>). Concurrently, process handler <highlight><bold>360</bold></highlight> passes control to program-executing unit <highlight><bold>114</bold></highlight> so that the program is executed from the address set into PC <highlight><bold>112</bold></highlight>. </paragraph>
<paragraph id="P-0124" lvl="0"><number>&lsqb;0124&rsqb;</number> Program-executing unit <highlight><bold>114</bold></highlight> executes the subroutine (as shown by reference numeral <highlight><bold>376</bold></highlight>) specified by PC <highlight><bold>112</bold></highlight> (as shown by reference numeral <highlight><bold>374</bold></highlight>). Thereby, the procedure specified in data memory <highlight><bold>122</bold></highlight> for debugging is performed. </paragraph>
<paragraph id="P-0125" lvl="0"><number>&lsqb;0125&rsqb;</number> As shown in <cross-reference target="DRAWINGS">FIG. 26</cross-reference>, breakpoint attribute DB <highlight><bold>352</bold></highlight> stores breakpoint numbers (ID numbers). It also stores the addresses of memory fields storing corresponding subroutines generated according to procedure items that should be executed when the breakpoint is hit. The breakpoint numbers and the addresses are stored in association with each other. </paragraph>
<paragraph id="P-0126" lvl="0"><number>&lsqb;0126&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 28</cross-reference>, front-end section according to the third embodiment operates as follows at a breakpoint-setting time. In the figure, first, entered parameters are checked. For example, the validity of an entered breakpoint ID number and the memory-address alignment (step <highlight><bold>170</bold></highlight>) are checked. If the parameters are not valid, the procedure terminates. If the parameters are valid, control proceeds to step <highlight><bold>380</bold></highlight>. </paragraph>
<paragraph id="P-0127" lvl="0"><number>&lsqb;0127&rsqb;</number> At step <highlight><bold>380</bold></highlight>, a subroutine for implementing memory-readout/write procedure when the specified breakpoint is hit is created in a machine-language sequence that is dependent on MCU <highlight><bold>52</bold></highlight> provided on evaluation board <highlight><bold>332</bold></highlight>. Subsequently, at step <highlight><bold>382</bold></highlight>, the ID number of the specified breakpoint and the corresponding subroutine is notified to the resident monitor section. At step <highlight><bold>176</bold></highlight>, the front-end section waits for a response from replacement-processing unit <highlight><bold>118</bold></highlight> in the resident monitor section. When a response is received from the resident monitor section, the procedure terminates. </paragraph>
<paragraph id="P-0128" lvl="0"><number>&lsqb;0128&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 29, a</cross-reference> procedure executed at a breakpoint-setting time in the resident monitor has following control structure. The procedure in the resident monitor section commences with receiving the notification issued at step <highlight><bold>382</bold></highlight> (shown in <cross-reference target="DRAWINGS">FIG. 28</cross-reference>) from the front-end section. </paragraph>
<paragraph id="P-0129" lvl="0"><number>&lsqb;0129&rsqb;</number> Then, at step <highlight><bold>390</bold></highlight>, the received subroutine is stored in instruction memory <highlight><bold>116</bold></highlight>. At step <highlight><bold>392</bold></highlight>, the associated storage addresses and breakpoint ID numbers are stored in breakpoint attribute DB <highlight><bold>352</bold></highlight>. </paragraph>
<paragraph id="P-0130" lvl="0"><number>&lsqb;0130&rsqb;</number> Subsequently, at step <highlight><bold>180</bold></highlight>, a backup is created for program <highlight><bold>130</bold></highlight> specified as a debug target. Then, at step <highlight><bold>182</bold></highlight>, the instruction at the specified address is replaced with software-interrupt generating instruction <highlight><bold>132</bold></highlight> that transfers the control to handler <highlight><bold>360</bold></highlight>. At step <highlight><bold>184</bold></highlight>, the resident monitor section notifies the front-end section of the completion of the procedure. Then, the procedure terminates. </paragraph>
<paragraph id="P-0131" lvl="0"><number>&lsqb;0131&rsqb;</number> The above-described procedure completes the preparation for debugging. </paragraph>
<paragraph id="P-0132" lvl="0"><number>&lsqb;0132&rsqb;</number> Debug-related procedure executed in the front-end section includes a control structure shown in <cross-reference target="DRAWINGS">FIG. 30</cross-reference>. Referring to <cross-reference target="DRAWINGS">FIG. 30</cross-reference>, in the front-end section of development terminal <highlight><bold>330</bold></highlight>, at step <highlight><bold>190</bold></highlight>, in response to a command entered by a user (for example, programmer), the start address of a debug-target program is specified, and the execution commencement is notified to the resident monitor section. Subsequently, at step <highlight><bold>198</bold></highlight>, the front-end section determines whether the breakpoint-hit-time procedure is a memory-read. If the procedure is determined not to be a memory-read, the procedure terminates. Then, at step <highlight><bold>200</bold></highlight>, the front-end section enters a standby state awaiting a memory-readout-result notification. When the notification is received, at step <highlight><bold>202</bold></highlight> the contents of the notification are displayed. Then, the procedure terminates. </paragraph>
<paragraph id="P-0133" lvl="0"><number>&lsqb;0133&rsqb;</number> Debug-related procedure executed in the resident monitor section according to the third embodiment includes a control structure shown in <cross-reference target="DRAWINGS">FIG. 31</cross-reference>. The procedure commences when the specified breakpoint is hit. Then, the front-end section accesses breakpoint attribute DB <highlight><bold>352</bold></highlight>, and reads out the subroutine address corresponding to the ID number of the hit breakpoint. The read-out address is then set into PC <highlight><bold>112</bold></highlight> (as shown in reference numeral <highlight><bold>372</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 27</cross-reference>). Program-executing unit <highlight><bold>114</bold></highlight> is controlled to commence program execution from the address specified by PC <highlight><bold>112</bold></highlight>. In the procedure, as shown by reference numerals <highlight><bold>374</bold></highlight> and <highlight><bold>376</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 27</cross-reference>, program-executing unit <highlight><bold>114</bold></highlight> executes, for example, subroutine <highlight><bold>354</bold></highlight> as a corresponding subroutine. As described above, subroutine <highlight><bold>354</bold></highlight> is composed of an instruction sequence for performing a read/write of the contents of the specified address in data memory <highlight><bold>122</bold></highlight>. That is, the subroutine execution implements procedure corresponding to the breakpoint, as shown by reference numeral <highlight><bold>378</bold></highlight>. </paragraph>
<paragraph id="P-0134" lvl="0"><number>&lsqb;0134&rsqb;</number> As described above, the remote debugger of the third embodiment does not use general-purpose functions to perform a memory-read/write, but the remote debugger instead uses the subroutines each composed of the MCU-dependent instruction sequence dedicated for the read/write for the corresponding breakpoint. In this case, the latency is less than that in the case where a general-purpose function is executed with a result of database reference. In addition, the subroutine composed of the dedicated instruction sequence can be executed by using a smaller number of instructions than the general-purpose functions. This reduces the execution time. Hence, compared to the case of the second embodiment, a further reduction can be implemented for the delay in the period from the breakpoint-hit time up to the execution time of the memory-readout/write procedure. Consequently, the third embodiment enables the examination of even more accurate breakpoint-hit-time information. Furthermore, the debug precision can be improved. Still furthermore, the third embodiment further facilitates the debug procedure. </paragraph>
<paragraph id="P-0135" lvl="0"><number>&lsqb;0135&rsqb;</number> According to the above-described embodiments of the present invention, compared to a case where a user specifies the contents of a procedure when a specific breakpoint is hit, the delay can be reduced in execution of debugging after the breakpoint is hit. </paragraph>
<paragraph id="P-0136" lvl="0"><number>&lsqb;0136&rsqb;</number> In addition, since the breakpoint attribute database is included in the evaluation board, the breakpoint-hit-time communication overhead is reduced. This reduces the delay in executing of debugging process after the breakpoint-hit time. </paragraph>
<paragraph id="P-0137" lvl="0"><number>&lsqb;0137&rsqb;</number> Furthermore, since the breakpoint attribute database is included in the development terminal, the debug-dedicated remote resident section on the evaluation board can be minimized. This makes it easy to design the evaluation board. </paragraph>
<paragraph id="P-0138" lvl="0"><number>&lsqb;0138&rsqb;</number> Furthermore, when a breakpoint is hit, the relevant data can be read out of the evaluation-board memory address pre-registered in the breakpoint attribute database, and the data can be displayed. Thereby, the time required to read out the data after the breakpoint is hit can be reduced. This enables the status of the evaluation board at the time of the breakpoint-hit to be known even more accurately. </paragraph>
<paragraph id="P-0139" lvl="0"><number>&lsqb;0139&rsqb;</number> Still furthermore, when a breakpoint is hit, data pre-registered in the breakpoint attribute database can be written in a memory at the address pre-registered in the breakpoint attribute database. Thereby, the time required to write the data after the breakpoint is hit can be reduced. This enables the status of the evaluation board at the time of breakpoint-hit to be reflected upon the debugging even more accurately. </paragraph>
<paragraph id="P-0140" lvl="0"><number>&lsqb;0140&rsqb;</number> Still furthermore, the procedure to be executed when a breakpoint is hit is converted into the processor-dependent instruction sequence. When the breakpoint is hit, the processing module of the evaluation board is controlled to directly execute the instruction sequence. Thereby, high-rate execution can be achieved for the procedure to be performed for the debug procedure when the breakpoint is hit. In addition, the delay will be reduced in executing debugging process after the breakpoint-hit. That is, the time required to read out the data after the breakpoint is hit can be reduced. This enables the status of the evaluation board at the time of breakpoint-hit to be known even more accurately. </paragraph>
<paragraph id="P-0141" lvl="0"><number>&lsqb;0141&rsqb;</number> In the case where the breakpoint-hit-time procedure to be executed by the processing module of the evaluation board is pre-registered in the database in a corresponding machine language, the breakpoint-hit-time procedure can be executed at a high rate. Thereby, the status of the evaluation board at the time of the breakpoint-hit can be known even more accurately. </paragraph>
<paragraph id="P-0142" lvl="0"><number>&lsqb;0142&rsqb;</number> Yet further more, a handler is provided to execute a procedure at the time of breakpoint-hit, and the control of execution is transferred to the handler through a branching instruction when a breakpoint is hit. Therefore, the procedure at the time of the breakpoint-hit can be simplified, and can be executed at a high rate. Thereby, the status of the evaluation board at the time of the breakpoint-hit can be known even more accurately. </paragraph>
<paragraph id="P-0143" lvl="0"><number>&lsqb;0143&rsqb;</number> Although the present invention is described and illustrated in detail, it is clearly understood that the same is by way of illustration and example only and is not to be taken by way of limitation, the spirit and scope of the present invention being limited only by the terms of the appended claims. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A remote debugging apparatus that uses a development terminal coupled to an evaluation board to perform debugging of a program executed in said evaluation board including a plurality of processing modules including a processor in a master-slave configuration, said remote debugging apparatus comprising: 
<claim-text>setting means for pre-setting a breakpoint in said program executed in said evaluation board; </claim-text>
<claim-text>registering means for registering a procedure in a database provided in one of said evaluation board and said development terminal, the procedure being required to be performed for a memory on said evaluation board when said breakpoint is hit; </claim-text>
<claim-text>execution-commencing means for commencing the execution of said program in said evaluation board; and </claim-text>
<claim-text>execution-controlling means of referencing said database in response to a hit on said breakpoint in execution of said program, and controlling the processing module of said evaluation board to execute a procedure required to be done on the memory of said evaluation board. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The apparatus according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein: 
<claim-text>said registering means includes means for pre-registering an address in the memory of said evaluation board in said database provided in one of said evaluation board and said development terminal, the address being required to be accessed when said breakpoint is hit; and </claim-text>
<claim-text>said execution-controlling means includes: </claim-text>
<claim-text>means for referencing said database in response to a hit on said breakpoint in execution of said program, reading out data in the memory of said evaluation board at an address read out of said database, and controlling the processing module to notify the read-out data to said development terminal; and </claim-text>
<claim-text>means for outputting to outputting means the data notified to said development terminal. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The apparatus according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein said setting means includes: 
<claim-text>means for receiving information specifying said breakpoint from a user in said development terminal; and </claim-text>
<claim-text>means for replacing an instruction of a debug-target program in said evaluation board, the instruction corresponding to the information specifying said breakpoint, with a branching instruction that branches control to a handler provided to handle the breakpoint-hit. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The apparatus according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein: 
<claim-text>said registering means includes means for pre-registering in said database an address in the memory of said evaluation board and data required to be written at the address, the address being required to be accessed when said breakpoint is hit, and said database being provided in one of said evaluation board and said development terminal; and </claim-text>
<claim-text>said execution-controlling means includes means for referencing said database in response to a hit on said breakpoint in execution of said program, and controlling the processing module of said evaluation board to write data read out of said database in the memory of said evaluation board at an address read out of said database. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The apparatus according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein: 
<claim-text>said registering means includes means for generating an instruction sequence dependent upon the processing module required to be executed by the processor of said evaluation board according to a command from a user at said development terminal when said breakpoint is hit; and </claim-text>
<claim-text>said execution-controlling means includes means for referencing said database in response to a hit on said breakpoint in execution of said program, and providing the processing module with said instruction sequence read out of said database to be executed. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The apparatus according to <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference>, wherein said instruction sequence is created in a machine language that is dependent on the processor configuring said processing module.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>3</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030004671A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030004671A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030004671A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030004671A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030004671A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030004671A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030004671A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030004671A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030004671A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00009">
<image id="EMI-D00009" file="US20030004671A1-20030102-D00009.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00010">
<image id="EMI-D00010" file="US20030004671A1-20030102-D00010.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00011">
<image id="EMI-D00011" file="US20030004671A1-20030102-D00011.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00012">
<image id="EMI-D00012" file="US20030004671A1-20030102-D00012.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00013">
<image id="EMI-D00013" file="US20030004671A1-20030102-D00013.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00014">
<image id="EMI-D00014" file="US20030004671A1-20030102-D00014.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00015">
<image id="EMI-D00015" file="US20030004671A1-20030102-D00015.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00016">
<image id="EMI-D00016" file="US20030004671A1-20030102-D00016.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00017">
<image id="EMI-D00017" file="US20030004671A1-20030102-D00017.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00018">
<image id="EMI-D00018" file="US20030004671A1-20030102-D00018.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00019">
<image id="EMI-D00019" file="US20030004671A1-20030102-D00019.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00020">
<image id="EMI-D00020" file="US20030004671A1-20030102-D00020.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00021">
<image id="EMI-D00021" file="US20030004671A1-20030102-D00021.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00022">
<image id="EMI-D00022" file="US20030004671A1-20030102-D00022.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00023">
<image id="EMI-D00023" file="US20030004671A1-20030102-D00023.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00024">
<image id="EMI-D00024" file="US20030004671A1-20030102-D00024.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
