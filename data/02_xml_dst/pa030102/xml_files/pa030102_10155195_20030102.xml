<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005434A1-20030102-D00000.TIF SYSTEM "US20030005434A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005434A1-20030102-D00001.TIF SYSTEM "US20030005434A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005434A1-20030102-D00002.TIF SYSTEM "US20030005434A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005434A1-20030102-D00003.TIF SYSTEM "US20030005434A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005434A1-20030102-D00004.TIF SYSTEM "US20030005434A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005434A1-20030102-D00005.TIF SYSTEM "US20030005434A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030005434A1-20030102-D00006.TIF SYSTEM "US20030005434A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030005434A1-20030102-D00007.TIF SYSTEM "US20030005434A1-20030102-D00007.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005434</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10155195</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20020524</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>H04N007/16</ipc>
</classification-ipc-primary>
<classification-ipc-secondary>
<ipc>H04N007/167</ipc>
</classification-ipc-secondary>
<classification-ipc-secondary>
<ipc>G09G005/00</ipc>
</classification-ipc-secondary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>725</class>
<subclass>025000</subclass>
</uspc>
</classification-us-primary>
<classification-us-secondary>
<uspc>
<class>345</class>
<subclass>741000</subclass>
</uspc>
</classification-us-secondary>
<classification-us-secondary>
<uspc>
<class>380</class>
<subclass>239000</subclass>
</uspc>
</classification-us-secondary>
</classification-us>
<title-of-invention>Conditional access filter as for a packet video signal inverse transport system</title-of-invention>
</technical-information>
<continuity-data>
<division-of>
<parent-child>
<child>
<document-id>
<doc-number>10155195</doc-number>
<kind-code>A1</kind-code>
<document-date>20020524</document-date>
</document-id>
</child>
<parent>
<document-id>
<doc-number>08759912</doc-number>
<document-date>19961204</document-date>
<country-code>US</country-code>
</document-id>
</parent>
<parent-status>ABANDONED</parent-status>
</parent-child>
</division-of>
</continuity-data>
<inventors>
<first-named-inventor>
<name>
<given-name>Michael</given-name>
<middle-name>S.</middle-name>
<family-name>Deiss</family-name>
</name>
<residence>
<residence-us>
<city>Zionsville</city>
<state>IN</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Gregory</given-name>
<middle-name>G.</middle-name>
<family-name>Tamer</family-name>
</name>
<residence>
<residence-us>
<city>Indianapolis</city>
<state>IN</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>John</given-name>
<middle-name>W.</middle-name>
<family-name>Chaney</family-name>
</name>
<residence>
<residence-us>
<city>Gilroy</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>James</given-name>
<middle-name>E.</middle-name>
<family-name>Hailey</family-name>
</name>
<residence>
<residence-us>
<city>Indianapolis</city>
<state>IN</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>JOSEPH S. TRIPOLI</name-1>
<name-2>THOMSON MULTIMEDIA LICENSING INC.</name-2>
<address>
<address-1>2 INDEPENDENCE WAY</address-1>
<address-2>P. O. BOX 5312</address-2>
<city>PRINCETON</city>
<state>NJ</state>
<postalcode>08543-5312</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">Apparatus in a receiver, for processing transmitted entitlement control information, includes a packet transport processor for selecting signal packets having payloads containing a conditional access payload header and a remaining payload of entitlement data. Respective payload headers include groups of bytes which are coded in a manner to allow or disallow the respective receiver from processing the entitlement data. A conditional access filter preprogrammed with a subscriber specific conditional access codeword examines respective byte groupings of the conditional access header for a match with the subscriber specific conditional access codeword. Only if a match occurs is the processor permitted to process the entitlement data. The entitlement data is thereafter utilized to generate decryption keys for descrambling portions of the transmitted signal. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> This invention relates to apparatus for processing packets of program component data from a packet video signal and more particularly to circuitry for detecting packet payloads to which a subscriber has conditional access for entitlement information. </paragraph>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> It is known from, for example, U.S. Pat. No. 5,168,356 and U.S. Pat. No. 5,289,276, that it is advantageous to transmit compressed video signal in packets, with respective packets affording a measure of error protection/correction. The systems in the foregoing patents transmit and process a single television program, albeit with a plurality of program components, from respective transmission channels. These systems utilize inverse transport processors to extract the video signal component of respective programs for further processing to condition the video component for reproduction. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> It is known, from for example, THE SATELLITE BOOK, A COMPLETE GUIDE TO SATELLITE TV THEORY AND PRACTICE, Swift Television Publications, 17 Pittsfield, Cricklade, Wilts, England, that transmitted television signal reception can be limited to particular subscribers by scrambling the signal. The limitations may be altered at the will of the broadcaster by periodically transmitting different entitlement data. The entitlement data is processed by smart cards located in respective receivers to generate decryption or descrambling keys, for use by decryption or descrambling devices in only those receivers entitled to reproduce the associated program material. In a packet video system of the aforementioned type, entitlement data may be included in specific packets which are recognizable as containing such data for easy access by smart card circuitry. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> A large area broadcast system, such as a direct broadcast satellite system targeted for North America, will have very large numbers of subscribers. This number will be so large as to preclude changing the entitlement data of specific receivers on very short notice. Consider, for example, that a broadcaster is required to black out the area local to a sports stadium in the event that tickets for the sporting event are not sold out. This information may not be available until immediately before the event. The broadcaster of course will want to wait until the last possible minute before making the decision to black out the local region. The present invention provides a method and apparatus whereby entitlement data is layered to provide denial of entitlements to receive program material on short notice. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> The present invention is a system/method for layered entitlement data transmission/reception. A receiver embodiment includes a packet transport processor for selecting packets having payloads containing a conditional access payload header and a remaining payload of entitlement data. Respective payload headers include groups of bytes which are coded in a manner to allow or disallow the respective receiver from processing the entitlement data. A conditional access filter preprogrammed with a subscriber specific conditional access codeword examines respective byte groupings of the conditional access header for a match with the subscriber specific conditional access codeword. Only if a match occurs is the processor permitted to process the entitlement data.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> The invention will be described with reference to the drawings, wherein: </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a pictorial representation of a time division multiplexed packet television signal; </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a pictorial representation of respective signal packets; </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a block diagram of a receiver for selecting and processing packets of multiplexed component signals embodying the present invention; </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a block diagram of a conditional access filter/start code detector; </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a flow chart of the conditional access filter operation; </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is a block diagram of an alternative conditional access filter; </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> is a block diagram of exemplary memory management circuitry which may be implemented for element <highlight><bold>17</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 3</cross-reference>; </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> is a pictorial representation showing memory address formation for service channel data. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference> is a flow chart of operation of the memory address control.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION </heading>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> shows a packet signal stream consisting of a string of boxes which represent signal packets that contain components of a plurality of different television or interactive television programs. These program components are assumed to be formed of compressed data and as such the quantity of video data for respective images is variable. The packets are of fixed length. Packets with letters having like subscripts represent components of a single program. For example, V<highlight><subscript>i</subscript></highlight>, A<highlight><subscript>i</subscript></highlight>, D<highlight><subscript>i </subscript></highlight>represent video, audio and data packets and packets designated V<highlight><subscript>1</subscript></highlight>, A<highlight><subscript>1</subscript></highlight>, D<highlight><subscript>1</subscript></highlight>, represent video, audio and data components for program <highlight><bold>1</bold></highlight>, and V<highlight><subscript>3</subscript></highlight>, A<highlight><subscript>31</subscript></highlight>, A<highlight><subscript>32</subscript></highlight>, D<highlight><subscript>3</subscript></highlight>, represent video, audio <highlight><bold>1</bold></highlight>, audio <highlight><bold>2</bold></highlight> and data components of program <highlight><bold>3</bold></highlight>. The data packets D<highlight><subscript>i </subscript></highlight>may contain e.g. control data to initiate certain action within a receiver, or they may include executable code forming an application to be executed by e.g., a microprocessor located within or associated with a receiver. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> In the upper line of the string of packets the respective components of a particular program are shown grouped together. However there is no necessity of packets from the same program being grouped as is indicated by the entire string of packets. Nor is there any particular order for the sequence of occurrence of respective components. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> The respective packets are arranged to include a prefix and a payload as shown in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>. The prefix of this example includes two 8-bit bytes comprising five fields, four (P, BB, CF, CS) of which are 1-bit fields, and one (SCID) of which is a 12-bit field. The SCID field is the signal component identifier. The field CF contains a flag to indicate whether the payload of the packet is scrambled, and the field CS contains a flag which indicates which of two alternative unscrambling keys is to be utilized to unscramble scrambled packets. The prefix of every packet is packet aligned, thus the location of the respective fields are easily identifiable. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> Within every payload is a header which contains a continuity count, CC, modulo <highlight><bold>16</bold></highlight>, and a TOGGLE flag bit which are program component specific. The continuity count is simply a successive numbering of sequential packets of the same program component. The TOGGLE flag bit is a one bit signal which changes logic level or toggles on the occurrence of a picture layer start code in an MPEG compressed video component. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> illustrates in block form, a portion of a digital television signal receiver including elements of an inverse transport processor. Signal is detected by an antenna <highlight><bold>10</bold></highlight> and applied to a tuner detector, <highlight><bold>11</bold></highlight>, which extracts a particular frequency band of received signals, and provides baseband compressed signal in a binary format. The frequency band is selected by the user through a microprocessor <highlight><bold>19</bold></highlight> by conventional methods. Nominally broadcast digital signals will have been error encoded using, for example, Reed-Solomon forward error correcting (FEC) coding. The baseband signals will thus be applied to a FEC decoder, <highlight><bold>12</bold></highlight>. The FEC decoder <highlight><bold>12</bold></highlight> synchronizes the received video and provides an error corrected stream of signal packets of the type illustrated in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. The FEC <highlight><bold>12</bold></highlight> may provide packets at regular intervals, or on demand, by for example, memory controller <highlight><bold>17</bold></highlight>. In either case a packet framing or synchronizing signal is provided by the FEC circuit, which indicates the times that respective packet information is transferred from the FEC <highlight><bold>12</bold></highlight>. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> The detected frequency band may contain a plurality of time division multiplexed programs in packet form. To be useful, only packets from a single program should be passed to the further circuit elements. In this example it is assumed that the user has no knowledge of which packets to select. This information is contained in a program guide, which in itself is a program consisting of data which interrelates program signal components through SCID&apos;s, and may include information relating to, for example, subscriber entitlements. The program guide is a listing for each program, of the SCID&apos;s for the audio, video, data etc. components of respective programs. The program guide (packets D<highlight><bold>4</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>) is assigned a fixed SCID. When power is applied to the receiver, the microprocessor <highlight><bold>19</bold></highlight> is programmed to load the SCID associated with the program guide into one of a bank of similar programmable SCID registers <highlight><bold>13</bold></highlight>. The SCID fields of the prefix portion of respective detected packets of signal from the FEC <highlight><bold>12</bold></highlight> are successively loaded in a further SCID register <highlight><bold>14</bold></highlight>. The programmable registers and the received SCID register are coupled to respective input ports of a comparator circuit <highlight><bold>15</bold></highlight>, and the received SCID is compared with the program guide SCID. If the SCID for a packet matches the program guide SCID, the comparator <highlight><bold>15</bold></highlight> conditions a memory controller <highlight><bold>17</bold></highlight> to route that packet to a predetermined location in the memory <highlight><bold>18</bold></highlight> for use by the microprocessor. If the received SCID does not match the program guide SCID, the corresponding packet is simply dumped. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> The microprocessor waits for a programming command from the user via an interface <highlight><bold>20</bold></highlight>, which is shown as a computer keyboard, but which may be a conventional remote control, or receiver front panel switches. The user may request to view a program provided on channel <highlight><bold>4</bold></highlight> (in the vernacular of analog TV systems). The microprocessor <highlight><bold>19</bold></highlight> is programmed to scan the program guide list that was loaded in the memory <highlight><bold>18</bold></highlight> for the respective SCID&apos;s of the channel <highlight><bold>4</bold></highlight> program components, and to load these SCID&apos;s in respective other ones of the programmable registers of the bank of registers <highlight><bold>13</bold></highlight> which are associated with corresponding component signal processing paths. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> Received packets of audio, video or data program components, for a desired program, must ultimately be routed to the respective audio <highlight><bold>23</bold></highlight>, video <highlight><bold>22</bold></highlight>, or auxiliary data <highlight><bold>21</bold></highlight>, (<highlight><bold>24</bold></highlight>) signal processors respectively. The data is received at a relatively constant rate, but the signal processors nominally require input data in bursts (according to the respective types of decompression for example). The exemplary system of <cross-reference target="DRAWINGS">FIG. 3</cross-reference>, first routes the respective packets to predetermined memory locations in the common memory <highlight><bold>18</bold></highlight>. Thereafter the respective processors <highlight><bold>21</bold></highlight>-<highlight><bold>24</bold></highlight> request the component packets from the memory <highlight><bold>18</bold></highlight>. Routing the components through the common memory provides a measure of desired signal data rate buffering or throttling. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> The audio, video and data packets are loaded into respective predetermined memory locations to enable the signal processors convenient buffered access to the component data. In order that the payloads of respective component packets are loaded in the appropriate memory areas, the respective SCID comparators are associated with those memory areas. This association may be hardwired in the memory controller <highlight><bold>17</bold></highlight>, or the association may be programmable. If the former, specific ones of the programmable registers <highlight><bold>13</bold></highlight> will always be assigned the audio, video and data SCID&apos;s respectively. If the latter, the audio, video and data SCID&apos;s may be loaded in any of the programmable registers <highlight><bold>13</bold></highlight>, and the appropriate association will be programmed in the memory controller <highlight><bold>17</bold></highlight> when the respective SCID&apos;s are loaded in the programmable registers. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> In the steady state, after the program SCID&apos;s have been stored in the programmable registers <highlight><bold>13</bold></highlight>, the SCID&apos;s of received signal packets are compared with all of the SCID&apos;s in the programmable SCID registers. If a match is made with either a stored audio, video or data SCID, the corresponding packet payload will be stored in the audio, video or data memory area or block respectively. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> The respective signal packets are coupled from the FEC <highlight><bold>12</bold></highlight> to the memory controller <highlight><bold>17</bold></highlight> via a signal decryptor <highlight><bold>16</bold></highlight>. Only the signal payloads are scrambled and the packet headers are passed by the decryptor unaltered. Whether or not a packed is to be descrambled is determined by the CF flag in the packet prefix, and how it is to be descrambled (one of two alternative descrambling keys) is determined by the CS flag. If no SCID match is had for a respective packet, the decryptor may simply be disabled from passing any data. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> The decryptor is programmed with decryption keys provided by the smart card apparatus <highlight><bold>31</bold></highlight>. The smart card is responsive to entitlement information contained in particular packets of the program guide to generate appropriate decryption keys. The system of the present example incorporates two levels of encryption or program access, entitlement control messages, ECM&apos;s, and entitlement management messages, EMM&apos;s. Program entitlement control and management information is regularly transmitted in packets identifiable with specific SCID&apos;s included in the packet stream comprising the program guide. The ECM information contained in these packets is used by the smart card to generate the decryption keys used by the decryptor. The EMM information included in these packets is used by the subscriber specific smart card to determine program material to which the subscriber is entitled. EMM entitlement information within these packets may be made geographically specific, or group specific or subscriber specific. For example, the present system will include a modem (not shown) for communicating billing information from the smart card to the program provider, e.g., the satellite broadcaster. The smart card may be programmed with, for example, the area code and telephone exchange of the receiver location. The EMM may include data, which when processed by the smart card, will entitle or deny reception of particular programs in particular area codes. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> The program provider may want the ability to entitle certain subscribers with very short lead time, as for example for pay-per-view programs. The identification of particular subscribers may not be available until shortly before airing of the particular program. With such short lead time it may not be possible to program EMM&apos;s on a subscriber basis. A further layer of coding may be instantly impressed on the entitlement information by including a conditional access code to permit/prohibit reception of the EMM and ECM data within respective packets, and thereby allow substantially instant permission/prohibition to certain programs. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> Packet payloads containing the EMM and ECM entitlement data include a payload header of 128 bits arranged in specially coded 4 groups of 32 bits. Each of the groups is coded with a conditional access code and each conditional access code may be coded differently. Each subscriber is assigned a specific conditional access code. A matched filter or E-code decoder <highlight><bold>30</bold></highlight>, is arranged to detect a subscriber specific bit pattern within the 128 bit header. If a match is detected the decoder communicates with the memory controller <highlight><bold>17</bold></highlight> and the smart card <highlight><bold>31</bold></highlight> to make the remainder of the entitlement payload available to the smart card (via the memory <highlight><bold>18</bold></highlight>). If a match is not detected, the payload is not accepted by the specific receiver. The conditional access codes may be periodically changed if the matched filter <highlight><bold>30</bold></highlight> is made programmable. These codes may be periodically provided by the smart card. For more specific details on smart card operation as related to viewer entitlements the reader is invited to review Section <highlight><bold>25</bold></highlight> of THE SATELLITE BOOK, A COMPLETE GUIDE TO SATELLITE TV THEORY AND PRACTICE,. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> The matched filter or E-code decoder is arranged to perform a second function, which is to detect particular MPEG video headers. These headers are 32-bit start codes, (which is the reason the headers of entitlement payloads are coded in 32 bit groups). If video data is lost, an MPEG video decoder can only restart decompressing video data at particular data entry points. These entry points coincide with MPEG start codes. The decoder may be arranged to communicate with the memory controller <highlight><bold>17</bold></highlight> to inhibit the flow of video data to memory after video packet losses, and to resume writing video payloads to memory only after the next MPEG start code is detected by the decoder <highlight><bold>30</bold></highlight>. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> illustrates exemplary apparatus for detecting packets which include conditional access information or MPEG start codes (decoder <highlight><bold>30</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 3</cross-reference>). Whether the decoder <highlight><bold>30</bold></highlight> is conditioned to detect entitlement payloads or MPEG start codes is a function of the SCID currently being received. In <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, it is assumed that data provided from the decryptor <highlight><bold>16</bold></highlight> is in 8-bit bytes and packet aligned. That is, the first byte of an entitlement payload or the first byte of an MPEG start code is aligned precisely with a particular byte position, e.g., the beginning of a packet payload, such that for detecting specific header or start codewords, their position in the bit/byte stream is precisely known. Data from the decryptor <highlight><bold>16</bold></highlight> is applied to an 8 bit register <highlight><bold>250</bold></highlight>, which has an 8-bit parallel output port coupled to respective first input connections of a comparator <highlight><bold>254</bold></highlight> which may be configured of, for example, a bank of eight two-input exclusive NOR (XNOR) circuits having respective output connections coupled to an AND gate and a latch. The latch may be a data latch arranged to latch the results of the AND gate at each byte interval. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> A 32-bit MPEG start code is stored as four bytes in an 8-bit register bank <highlight><bold>265</bold></highlight>. Conditional access codes are stored as 8-bit bytes in a bank of 16 8-bit registers <highlight><bold>257</bold></highlight>. Loading of the register banks <highlight><bold>251</bold></highlight> and <highlight><bold>265</bold></highlight> is controlled by the microprocessor <highlight><bold>19</bold></highlight> and/or by the smart card. The start code registers <highlight><bold>265</bold></highlight> are coupled to a four to one multiplexer <highlight><bold>266</bold></highlight>, and the conditional access code registers are coupled to a sixteen to one multiplexer <highlight><bold>257</bold></highlight>. Output ports of the multiplexers <highlight><bold>257</bold></highlight> and <highlight><bold>266</bold></highlight> are coupled to a two to one multiplexer <highlight><bold>249</bold></highlight>. Respective output connections of the multiplexer <highlight><bold>249</bold></highlight> are coupled to respective corresponding second input terminals of the comparator <highlight><bold>254</bold></highlight>. (Note the input and output connections of the multiplexers <highlight><bold>249</bold></highlight>, <highlight><bold>257</bold></highlight> and <highlight><bold>266</bold></highlight> are 8-bit busses.) If the respective values exhibited at the respective output connections of the register <highlight><bold>250</bold></highlight> are correspondingly the same as the output values exhibited by the respective output connections of the multiplexer <highlight><bold>249</bold></highlight>, a true signal is generated by the comparator <highlight><bold>254</bold></highlight> circuit for the corresponding data byte. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> For start code detection, the multiplexer <highlight><bold>266</bold></highlight> is scanned by the counter <highlight><bold>258</bold></highlight> to sequentially couple the four different registers <highlight><bold>265</bold></highlight> to the comparator in synchronism with the occurrence of the first four payload data bytes from the decryptor <highlight><bold>16</bold></highlight>. Alternatively, for conditional access code detection, the multiplexer <highlight><bold>257</bold></highlight> is scanned by the counter <highlight><bold>258</bold></highlight> to sequentially couple different ones of the registers <highlight><bold>265</bold></highlight> to the comparator circuit <highlight><bold>254</bold></highlight>. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> The output of the comparator circuit is applied to an accumulate and test circuit <highlight><bold>255</bold></highlight>. The circuit <highlight><bold>255</bold></highlight> determines if any of a predetermined number of byte matching conditions have occurred, and if they have, it generates a write enable signal for the entitlement data in the remaining portion of the particular payload under examination. In the present system the entitlement payload header contains 128 bits arranged in four 32-bit conditional access codes. The conditional access filters <highlight><bold>30</bold></highlight> of different subscribers will be arranged to look for different combinations of bytes of the 128 bits. For example one subscriber apparatus may be arranged to match the first four bytes of the conditional access codes. Another subscriber apparatus may be arranged to match the second four bytes of the conditional access codes and so forth. In either of these exemplary situations the circuitry <highlight><bold>255</bold></highlight> will determine if a match has occurred for the appropriate four consecutive bytes. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> The use of 16 registers in the bank for a subscriber specific conditional access codes somewhat simplifies the circuit structure. Since each subscriber has a four byte conditional access code, the code may be loaded four times in the set of 16 registers. At the transmitter, the broadcaster need not then be concerned about the relative location, with respect to the four groups of four bytes, of the conditional access codes being transmitted. An alternative arrangement may incorporate only a single group of four registers to hold the subscriber specific conditional access code, and these registers may be repeatedly scanned, modulo four, through the 128 bits of the entitlement payload header. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> It is not practical to transmit each of the 232 possible entitlement codes for every function, as this would undesirably limit the system bandwidth for other services and would also simply take too much time. This limitation may be somewhat alleviated by arranging the conditional access code according to some logical groupings, wherein the groupings are defined by three bytes of respective four byte conditional access codes. In this manner all subscribers in a group may be addressed by conditioning respective receivers of the group to ignore one byte of the four byte conditional access code. In this instance each four byte access code will represent 256 subscribers. The filter conditioning is effected by sending for example all zeroes in the first four byte positions and arranging the conditional access filter to detect this condition. If the condition is satisfied, the conditional access filter is electrically restructured to detect a match of only three bytes of respective groups of four bytes. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> A third variant is provided to permit all subscribers conditional access. This is effected by coding the entitlement payload header with all zeroes (or all ones). The conditional access filter is therefore arranged to also include an all zero detector (elements <highlight><bold>261</bold></highlight>-<highlight><bold>263</bold></highlight>). </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> The bits of respective arriving bytes of data are coupled to respective terminals of the 8-bit OR gate <highlight><bold>263</bold></highlight>. If any one of the bits is a logic one the OR gate <highlight><bold>263</bold></highlight> generates a logic one output. The output of the OR gate <highlight><bold>263</bold></highlight> is coupled to one input of a two-input OR gate <highlight><bold>262</bold></highlight>, which has an output and second input coupled respectively to the data-input and Q-output terminals of a D-type latch <highlight><bold>261</bold></highlight>. The D-type latch is clocked by the timing circuit <highlight><bold>259</bold></highlight> synchronously with the arrival of incoming data bytes. If any bit in any of the data bytes which occurs after the latch is reset is a logic one, the latch <highlight><bold>261</bold></highlight> will exhibit a logic one at its Q-output until the next reset pulse. The Q-output of latch <highlight><bold>261</bold></highlight> is coupled to an inverter which exhibits a zero output level whenever the latch exhibits a one output level. Thus, if after the 128 bits (16 bytes) of the header have been passed through register <highlight><bold>250</bold></highlight>, the output of the inverter is high, then the 128 bits are zero valued. The latch is reset prior to the reception of each new payload. Responsive to detection of a high output level from the inverter after passage of the entitlement payload header, the circuitry <highlight><bold>255</bold></highlight> will generate a data write enable signal. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a flow chart of the operation of the conditional access filter <highlight><bold>30</bold></highlight>. The process is started by the detection of the associated SCID. Once the appropriate SCID has been detected the payload is applied &lcub;<highlight><bold>300</bold></highlight>&rcub; to the filter <highlight><bold>30</bold></highlight>. A comparison &lcub;<highlight><bold>302</bold></highlight>&rcub; is made of the first four bytes of the header with the subscriber specific conditional access code. If a match occurs, an entitlement data write enable is generated &lcub;<highlight><bold>310</bold></highlight>&rcub; If not the first four bytes are examined &lcub;<highlight><bold>306</bold></highlight>&rcub; for all zeroes. If all zeroes are not detected, the second four bytes of the header are compared &lcub;<highlight><bold>308</bold></highlight>&rcub; with the subscriber specific conditional access code. If they match &lcub;<highlight><bold>312</bold></highlight>&rcub;, a write enable is generated &lcub;<highlight><bold>310</bold></highlight>&rcub;. If not the third set of four bytes is compared &lcub;<highlight><bold>314</bold></highlight>&rcub; with the subscriber specific conditional access code. If they match &lcub;<highlight><bold>316</bold></highlight>&rcub;, a write enable is generated &lcub;<highlight><bold>310</bold></highlight>&rcub;. If not, the fourth set of four bytes is compared &lcub;<highlight><bold>317</bold></highlight>&rcub; with the subscriber specific conditional access code. If they match &lcub;<highlight><bold>318</bold></highlight>&rcub;, a write enable is generated &lcub;<highlight><bold>310</bold></highlight>&rcub;. If not, the last 12 bytes of the header are examined for all zeroes &lcub;<highlight><bold>320</bold></highlight>&rcub;. If all zeroes are detected in the last 12 bytes, a write enable is generated &lcub;<highlight><bold>310</bold></highlight>&rcub; and if not a write enable is not generated and the process waits &lcub;<highlight><bold>300</bold></highlight>&rcub; for the next packet. In an alternative arrangement, at step &lcub;<highlight><bold>320</bold></highlight>&rcub; the system may be programmed to look for all zeroes in all 16 bytes of the header. It should also be appreciated that some other fixed pattern may be utilized other than all zeroes, such as all ones or an alternating pattern of zeroes and ones for example At step &lcub;<highlight><bold>306</bold></highlight>&rcub; if the first four bytes are all zeroes, three of the second four bytes of the header are compared &lcub;<highlight><bold>354</bold></highlight>&rcub; with the subscriber specific conditional access code. In the <cross-reference target="DRAWINGS">FIG. 4</cross-reference> apparatus this may be accomplished by arranging the element <highlight><bold>255</bold></highlight> to look for three matches for exclusive groups of four bytes. If three of the four bytes match &lcub;<highlight><bold>326</bold></highlight>&rcub; a write enable is generated &lcub;<highlight><bold>322</bold></highlight>&rcub; and if not, three of the third set of four header bytes are compared &lcub;<highlight><bold>330</bold></highlight>&rcub; with the subscriber specific conditional access code. If three of the four bytes match &lcub;<highlight><bold>332</bold></highlight>&rcub;, a write enable is generated &lcub;<highlight><bold>322</bold></highlight>&rcub;, and if not, three of the last four bytes are compared &lcub;<highlight><bold>336</bold></highlight>&rcub; with the subscriber specific conditional access code. If they match, a write enable is generated &lcub;<highlight><bold>322</bold></highlight>&rcub; and if not the all zero condition is examined &lcub;<highlight><bold>320</bold></highlight>&rcub;. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> Note a further level of detection may be incorporated similar to the steps &lcub;<highlight><bold>324</bold></highlight>-<highlight><bold>340</bold></highlight>&rcub; where only two of respective groups of four bytes are matched. This may be conditioned by arranging the first eight bytes to be all zeroes or the first four bytes to be all ones, for example. In this instance the respective groups being enabled by the conditional access codes becomes much larger. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> Regarding storing entitlement payloads in the memory <highlight><bold>18</bold></highlight>, the system writes the payload header to memory as it is received and examined for conditional access codes. If a conditional access code is detected, the write enable which is detected simply allows the memory control to continue writing the payload. Conversely if a conditional access code is not detected within the first 16 bytes of the payload, the remainder of the payload is not written to memory, and the memory address for a conditional access payload is reset to overwrite the 16 bytes of payload conditional access header. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is an alternative conditional access filter which compares as many as 32 bits (four bytes) at a time. This permits detection of start codes without foreknowledge of the byte position of the start code. The start code is stored in 8-bit registers <highlight><bold>265</bold></highlight>. (Eight bit registers are used because an 8-bit &mgr;PC bus is employed.) The output ports of the registers are coupled to a first set of inputs of a multiplexer <highlight><bold>298</bold></highlight>. The subscriber specific conditional access code is stored in a second register bank <highlight><bold>299</bold></highlight>, which have respective output ports coupled to a second set of inputs to the multiplexer <highlight><bold>298</bold></highlight>. The multiplexer <highlight><bold>298</bold></highlight> has a set of outputs connected to respective first 8-bit input ports of comparators <highlight><bold>270</bold></highlight>-<highlight><bold>273</bold></highlight>. Whether the output ports of registers <highlight><bold>265</bold></highlight> or <highlight><bold>299</bold></highlight> are coupled to the comparators is controlled by the accumulate and test circuitry <highlight><bold>297</bold></highlight> responsive to the upC. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> Input bytes from the decryptor <highlight><bold>16</bold></highlight> are coupled to the parallel/serial registers <highlight><bold>274</bold></highlight>-<highlight><bold>277</bold></highlight>. The respective registers <highlight><bold>274</bold></highlight>-<highlight><bold>277</bold></highlight> have parallel output ports coupled respectively to second 8-bit input ports of the comparators <highlight><bold>270</bold></highlight>-<highlight><bold>273</bold></highlight>. The system is timed such that four successive bytes of the input signal are currently loaded into the registers <highlight><bold>274</bold></highlight>-<highlight><bold>277</bold></highlight>. The output terminals of the comparators are coupled to the accumulate and test circuit <highlight><bold>297</bold></highlight> via respective OR gates <highlight><bold>278</bold></highlight>-<highlight><bold>281</bold></highlight>. Second input terminals of the OR circuits are coupled to respective control output connections of the accumulate and test circuit <highlight><bold>297</bold></highlight>. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> As in the <cross-reference target="DRAWINGS">FIG. 4</cross-reference> apparatus, the apparatus of <cross-reference target="DRAWINGS">FIG. 6</cross-reference> includes an all zeroes detector <highlight><bold>261</bold></highlight>-<highlight><bold>263</bold></highlight> for detecting all zeroes in the first four bytes and all sixteen bytes. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> For four byte conditional access code detection, successive exclusive groups of four bytes are loaded into the registers <highlight><bold>274</bold></highlight>-<highlight><bold>277</bold></highlight> and tested against the subscriber specific conditional access code contained in the registers <highlight><bold>299</bold></highlight>. If all four comparators detect a match, the AND gate <highlight><bold>283</bold></highlight> produces a logic one indicating a match. If one of the comparators fails to detect a match the AND gate produces a logic zero. For three out of sets of four input byte conditional access code detection, the accumulate and test circuit <highlight><bold>297</bold></highlight> applies a logic one value to one of the control lines coupled to the OR gates. This forces the output of that OR gate to a logic one, effectively forcing a match from the associated comparator. Conditional access code detection is then performed on successive exclusive groups of four bytes as for four byte detection. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> For start code detection, the control lines of all of the OR gates are held at a logic zero. Input bytes are sequentially applied to the cascade connection of registers <highlight><bold>274</bold></highlight>-<highlight><bold>277</bold></highlight> and a test for match with the start code stored in the registers <highlight><bold>265</bold></highlight> is made on each successive inclusive set of four input bytes. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> illustrates exemplary apparatus for the memory controller <highlight><bold>17</bold></highlight> shown in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>. Each program component is stored in a different contiguous block of the memory <highlight><bold>18</bold></highlight>. In addition other data, such as data generated by the microprocessor <highlight><bold>19</bold></highlight> or the Smart Card (not shown) may be stored in the memory <highlight><bold>18</bold></highlight>. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> Addresses are applied to the memory <highlight><bold>18</bold></highlight> by a multiplexor <highlight><bold>105</bold></highlight>, and input data is applied to the memory <highlight><bold>18</bold></highlight> by a multiplexor <highlight><bold>99</bold></highlight>. Output data from the memory management circuitry is provided to the signal processors by a further multiplexor <highlight><bold>104</bold></highlight>. Output data provided by the multiplexor <highlight><bold>104</bold></highlight> is derived from the microprocessor <highlight><bold>19</bold></highlight>, the memory <highlight><bold>18</bold></highlight> or directly from the multiplexor <highlight><bold>99</bold></highlight>. Program data is presumed to be of standard picture resolution and quality, and occurring at a particular data rate. On the other hand high definition television signals, HDTV, which may be provided by this receiver, occur at a significantly higher data rate. Practically all data provided by the FEC will be routed through the memory <highlight><bold>18</bold></highlight> via the multiplexor <highlight><bold>99</bold></highlight> and memory I/O circuit <highlight><bold>102</bold></highlight>, except for the higher rate HDTV signals which may be routed directly from the multiplexer <highlight><bold>99</bold></highlight> to the multiplexor <highlight><bold>104</bold></highlight>. Data is provided to the multiplexer <highlight><bold>99</bold></highlight> from the decryptor <highlight><bold>16</bold></highlight>, the smart card circuitry, the microprocessor <highlight><bold>19</bold></highlight>, and a source of a media error codes <highlight><bold>100</bold></highlight>. The term &ldquo;media error codes as used herein, means special codewords to be inserted in a data stream, to condition the respective signal processor (decompressor) to suspend processing until detection of a predetermined codeword such as a start code, and then to resume processing in accordance with the e.g. start code. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> Memory addresses are provided to the multiplexor <highlight><bold>105</bold></highlight>, from program addressing circuitry <highlight><bold>79</bold></highlight>-<highlight><bold>97</bold></highlight>, from the microprocessor <highlight><bold>19</bold></highlight>, from the Smart Card apparatus <highlight><bold>31</bold></highlight> and from the auxiliary packet address counter <highlight><bold>78</bold></highlight>. Selection of the particular address at any particular time period is controlled by a direct memory access DMA, circuit <highlight><bold>98</bold></highlight>. The SCID control signals from the comparator <highlight><bold>15</bold></highlight> and &ldquo;data needed&rdquo; signals from respective signal processors are applied to the DMA <highlight><bold>98</bold></highlight>, and responsive thereto, memory access contention is arbitrated. The DMA <highlight><bold>98</bold></highlight> cooperates with a Service Pointer Controller <highlight><bold>93</bold></highlight>, to provide the appropriate read or write addresses for respective program signal components. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> The respective addresses for the various signal component memory blocks are generated by four groups of program component or service pointer registers <highlight><bold>83</bold></highlight>, <highlight><bold>87</bold></highlight>, <highlight><bold>88</bold></highlight>, and <highlight><bold>92</bold></highlight>. The starting pointers for respective blocks of memory, into which respective signal components are stored, are contained in registers <highlight><bold>87</bold></highlight> for the respective signal components. The start pointers may be fixed values, or they may be calculated by conventional memory management methods in the microprocessor <highlight><bold>19</bold></highlight>. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> Pointers for the last address of respective blocks are stored in the bank of service registers <highlight><bold>88</bold></highlight>, one for each potential program component. Similar to the start addresses, the end or last addresses may be fixed values or they may be calculated values provided by the microprocessor <highlight><bold>19</bold></highlight>. Using calculated values for starting and end pointers is preferred because it provides a more versatile system with less memory. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> The memory write pointers or head pointers are generated by the adder <highlight><bold>80</bold></highlight> and the service head registers <highlight><bold>83</bold></highlight>. There is a service head register for each potential program component. A write or head pointer value is stored in a register <highlight><bold>83</bold></highlight>, and provided to the address multiplexor <highlight><bold>105</bold></highlight> during a memory write cycle. The head pointer is also coupled to the adder <highlight><bold>80</bold></highlight>, wherein it is incremented by one unit, and the incremented pointer is stored in the appropriate register <highlight><bold>83</bold></highlight> for the next write cycle. The registers <highlight><bold>83</bold></highlight> are selected by the service pointer controller, <highlight><bold>93</bold></highlight>, for the appropriate program component currently being serviced. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> In this example it is assumed that the start and end pointers are 16-bit pointers. The registers <highlight><bold>83</bold></highlight> provides 16 bit write or head pointers. 16-bit pointers were selected to facilitate use of 16-bit or 8-bit busses for loading the start and end pointers in the registers <highlight><bold>87</bold></highlight> and <highlight><bold>88</bold></highlight>. The memory <highlight><bold>18</bold></highlight>, on the other hand, has 18-bit addresses. The 18-bit write addresses are formed by concatenating the two most significant bits of the start pointers to the 16-bit head pointers, with the start pointer bits in the most significant bit positions of the combined 18-bit write address. The start pointers are provided by the respective registers <highlight><bold>87</bold></highlight> to the service pointer controller <highlight><bold>93</bold></highlight>. The service pointer controller parses the more significant start pointer bits from the start pointers stored in registers <highlight><bold>87</bold></highlight>, and associates these bits with the 16-bit head pointer bus. This is illustrated by the bus <highlight><bold>96</bold></highlight> shown being combined with the head pointer bus exiting the multiplexor <highlight><bold>85</bold></highlight>, and by <cross-reference target="DRAWINGS">FIG. 8</cross-reference> with reference to the bold arrows. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 8</cross-reference>, the top middle and bottom rows of boxes represent the bits of a start pointer, an address and a head or tail pointer respectively. The higher numbered boxes represent more significant bit positions. The arrows indicate from which bit positions of the start or head/tail pointers the respective bits of an address are derived. In this derivation the bold arrows represent steady state operation. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> Similarly, memory read pointers or tail pointers are generated by the adder <highlight><bold>79</bold></highlight> and the service tail registers <highlight><bold>92</bold></highlight>. There is a service tail register for each potential program component. A read or tail pointer value is stored in a register <highlight><bold>92</bold></highlight>, and provided to the address multiplexor <highlight><bold>105</bold></highlight> during a memory read cycle. The tail pointer is also coupled to the adder <highlight><bold>79</bold></highlight>, wherein it is incremented by one unit, and the incremented pointer is stored in the appropriate register <highlight><bold>92</bold></highlight> for the next read cycle. The registers <highlight><bold>92</bold></highlight> are selected by the service pointer controller, <highlight><bold>93</bold></highlight>, for the appropriate program component currently being serviced. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> The registers <highlight><bold>92</bold></highlight> provides 16 bit tail pointers. 18-bit read addresses are formed by concatenating the two most significant bits of the start pointers to the 16 bit tail pointers, with the start pointer bits in the most significant bit positions of the combined 18-bit write address. The service pointer controller parses the more significant start pointer bits from the start pointers stored in registers <highlight><bold>87</bold></highlight>, and associates these bits with the 16-bit tail pointer bus. This is illustrated by the bus <highlight><bold>94</bold></highlight> shown being combined with the tail pointer bus exiting the multiplexor <highlight><bold>90</bold></highlight>. </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> Data is stored in the memory <highlight><bold>18</bold></highlight> at the calculated address. After storing a byte of data, the head pointer is incremented by one and compared to the end pointer for this program component, and if they are equal the more significant bits of the head pointer are replaced with the lower 14 bits of the start pointer and zeros are placed in the lower two bit positions of the head pointer portion of the address. This is illustrated in <cross-reference target="DRAWINGS">FIG. 8</cross-reference> with reference to the hatched arrows between the start pointers and the address. This operation is illustrated by the arrow <highlight><bold>97</bold></highlight> pointing from the service pointer controller <highlight><bold>93</bold></highlight> to the head pointer bus from the multiplexor <highlight><bold>85</bold></highlight>. It is presumed that application of the lower <highlight><bold>14</bold></highlight> start pointer bits override the head pointer bits. Replacing the head pointer bits with the lower start pointer bits in the address for this one write cycle, causes the memory to scroll through the memory block designated by the upper two start pointer bits, thus obviating reprogramming write addresses at the start of each packet to a unique memory location within a block. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> If the head pointer ever equals the tail pointer (used to indicate where to read data from the memory <highlight><bold>18</bold></highlight>) a signal is sent to the interrupt section of the microprocessor to indicate that a head-tail crash has occurred. Further writing to the memory <highlight><bold>18</bold></highlight> from this program channel is disabled until the microprocessor re-enables the channel. This case is very rare and should not occur in normal operation. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> Data is retrieved from the memory <highlight><bold>18</bold></highlight> at the request of the respective signal processors, at addresses calculated by the adder <highlight><bold>79</bold></highlight> and registers <highlight><bold>92</bold></highlight>. After reading a byte of stored data, the tail pointer is incremented by one unit and compared to the end pointer for this logical channel in the service pointer controller <highlight><bold>93</bold></highlight>. If the tail and end pointers are equal then the more significant bits of the tail pointer are replaced with the lower 14 bits of the start pointer and zeros are placed in the lower two bit positions of the tail pointer portion of the address. This is illustrated by the arrow <highlight><bold>95</bold></highlight> emanating from controller <highlight><bold>93</bold></highlight> and pointing to the tail pointer bus from the multiplexor <highlight><bold>90</bold></highlight>. If the tail pointer is now equal to the head pointer, then the respective memory block is defined as empty and no more bytes will be sent to the associated signal processor until more data is received from the FEC for this program channel. The actual replacement of the head or tail pointer portions of the respective write or read addresses by the lower 14 bits of the start pointer may be accomplished by appropriate multiplexing, or the use of three state interconnects. </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> Memory read/write control is performed by the service pointer controller and direct memory access, DMA, elements <highlight><bold>93</bold></highlight> and <highlight><bold>94</bold></highlight>. The DMA is programmed to schedule read and write cycles. Scheduling is dependent upon whether the FEC <highlight><bold>12</bold></highlight> is providing data to be written to memory or not. FEC data write operations take precedence so that no incoming signal component data is lost. In the exemplary apparatus illustrated in <cross-reference target="DRAWINGS">FIG. 7</cross-reference>, there are four types of apparatus which may access the memory. These are Smart Card, the FEC <highlight><bold>12</bold></highlight> (more precisely the decryptor <highlight><bold>16</bold></highlight>), the microprocessor <highlight><bold>19</bold></highlight> and the application devices such as the audio and video processors. Memory contention is handled in the following manner. The DMA, responsive to data requests from the various processing elements listed above, allocates blocks of memory for respective program components. Access to the memory is provided in 95 nS time slots during which a byte of data is read from or written to the memory <highlight><bold>18</bold></highlight>. There are two major modes of access allocation, defined by &ldquo;FEC Providing Data&rdquo;, or &ldquo;FEC Not Providing Data&rdquo; respectively. For each of these modes the time slots are allocated and prioritized as follows, assuming a maximum FEC data rate of 5 Mbytes/second, or one byte for each 200 nS. These are: </paragraph>
<paragraph id="P-0061" lvl="7"><number>&lsqb;0061&rsqb;</number> FEC Providing Data </paragraph>
<paragraph id="P-0062" lvl="1"><number>&lsqb;0062&rsqb;</number> 1) FEC data write; </paragraph>
<paragraph id="P-0063" lvl="1"><number>&lsqb;0063&rsqb;</number> 2) Application device read/Microprocessor read/write; </paragraph>
<paragraph id="P-0064" lvl="1"><number>&lsqb;0064&rsqb;</number> 3) FEC data write; </paragraph>
<paragraph id="P-0065" lvl="1"><number>&lsqb;0065&rsqb;</number> 4) Microprocessor read/write; and for </paragraph>
<paragraph id="P-0066" lvl="7"><number>&lsqb;0066&rsqb;</number> FEC Not Providing Data </paragraph>
<paragraph id="P-0067" lvl="1"><number>&lsqb;0067&rsqb;</number> 1) Smart Card read/write; </paragraph>
<paragraph id="P-0068" lvl="1"><number>&lsqb;0068&rsqb;</number> 2) Application device read/Microprocessor read/write; </paragraph>
<paragraph id="P-0069" lvl="1"><number>&lsqb;0069&rsqb;</number> 3 ) Smart Card read/write; </paragraph>
<paragraph id="P-0070" lvl="1"><number>&lsqb;0070&rsqb;</number> 4) Microprocessor read/write. </paragraph>
<paragraph id="P-0071" lvl="7"><number>&lsqb;0071&rsqb;</number> Because FEC data writes cannot be deferred, the FEC (or more correctly the decryptor), when providing data must be guaranteed memory access during each 200 nS interval. Alternate time slots are shared by the application devices and the microprocessor. When there is no data available for the requesting devices, the microprocessor is provided use of the application time slots. </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> The Controller <highlight><bold>93</bold></highlight> communicates with the SCID detector to determine which of the respective Start, head and end pointer registers to access for memory write operations. The controller <highlight><bold>93</bold></highlight> communicates with the DMA to determine which of the start, end and tail registers to access for memory read operations. The DMA <highlight><bold>98</bold></highlight> controls selection of the corresponding addresses and data by the multiplexers <highlight><bold>99</bold></highlight>, <highlight><bold>104</bold></highlight> and <highlight><bold>105</bold></highlight>. </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference> illustrates an exemplary flow chart of the DMA <highlight><bold>98</bold></highlight> memory access process. The DMA responds &lcub;<highlight><bold>200</bold></highlight>&rcub; to detection or non detection of a received packet via detection of SCID&apos;s. If a SCID has been detected indicating the presence of data from the decryptor <highlight><bold>16</bold></highlight> to be written to memory, one byte of program data from the decryptor is written &lcub;<highlight><bold>201</bold></highlight>&rcub; to the buffer memory <highlight><bold>18</bold></highlight>. The block of memory to which it is written is determined by the processor <highlight><bold>93</bold></highlight> responsive to the current SCID. Next the DMA determines &lcub;<highlight><bold>202</bold></highlight>&rcub; if any of the program component processors, including the smart card and &mgr;PC are requesting data or read/write (R/W) access to the memory <highlight><bold>18</bold></highlight>. If no data requests are made on the DMA the process returns to step &lcub;<highlight><bold>200</bold></highlight>&rcub;. If a data R/W request has been made, the DMA determines &lcub;<highlight><bold>203</bold></highlight>&rcub; the priority of the request. This will be accomplished by a conventional interrupt routine or alternatively, by sequential one byte service in an arbitrary order of those program processors requesting data. For example, assume that an arbitrary order of access priority is video, audio I, audio II, smart card, and &mgr;PC. Assume also that only the video, audio II and &mgr;PC are requesting memory access. During the current operation of step &lcub;<highlight><bold>203</bold></highlight>&rcub; a byte of video will be read from memory. During the next operation of step &lcub;<highlight><bold>203</bold></highlight>&rcub; a byte of audio II will be read from memory, and During the next subsequent occurrence of step &lcub;<highlight><bold>203</bold></highlight>&rcub; a byte of &mgr;PC data will be written to- or read from memory <highlight><bold>18</bold></highlight> and so forth. Note that addresses for smart card and &mgr;PC access are provided by the smart card and &mgr;PC respectively, but addresses for video, audio and program guide are available from the address pointer arrangement (<highlight><bold>80</bold></highlight>-<highlight><bold>93</bold></highlight>). </paragraph>
<paragraph id="P-0074" lvl="0"><number>&lsqb;0074&rsqb;</number> Once priority access has been established &lcub;<highlight><bold>203</bold></highlight>&rcub;, the requisite program processor is serviced &lcub;<highlight><bold>204</bold></highlight>&rcub; with one byte of data written to- or read from memory <highlight><bold>18</bold></highlight>. Next a byte of data from the decryptor <highlight><bold>16</bold></highlight> is written &lcub;<highlight><bold>205</bold></highlight>&rcub; to memory. A check &lcub;<highlight><bold>206</bold></highlight>&rcub; is made to determine if the &mgr;PC is requesting access. If the &mgr;PC is requesting access, it is serviced &lcub;<highlight><bold>207</bold></highlight>&rcub; with one byte of data. If the &mgr;PC is not requesting access the process jumps to step &lcub;<highlight><bold>202</bold></highlight>&rcub; to determine if any of the program processors are requesting access. In this manner the incoming data is always guaranteed access to every other memory access period, and the intervening memory access periods are spread amongst the program processors. </paragraph>
<paragraph id="P-0075" lvl="0"><number>&lsqb;0075&rsqb;</number> If data is not presently available from the decryptor <highlight><bold>16</bold></highlight>, i.e. an SCID is not currently detected, the process &lcub;<highlight><bold>208</bold></highlight>-<highlight><bold>216</bold></highlight>&rcub; is followed. First the smart card is examined &lcub;<highlight><bold>208</bold></highlight>&rcub; to determine if it is requesting memory access. If it is, it is given a one byte memory access &lcub;<highlight><bold>209</bold></highlight>&rcub;, else a check is made &lcub;<highlight><bold>210</bold></highlight>&rcub; to determine if any of the program processors is requesting memory access. If a data R/W request has been made, the DMA determines &lcub;<highlight><bold>211</bold></highlight>&rcub; the priority of the request. The appropriate processor is serviced &lcub;<highlight><bold>212</bold></highlight>&rcub; with a one byte memory read or write access. If a data R/W request has not been made by the program processors, the process jumps to step &lcub;<highlight><bold>213</bold></highlight>&rcub; where a test is performed to determine if the smart card is requesting memory access. If it is it is serviced &lcub;<highlight><bold>216</bold></highlight>&rcub; with a one byte memory access, else the process jumps to step &lcub;<highlight><bold>200</bold></highlight>&rcub;. </paragraph>
<paragraph id="P-0076" lvl="0"><number>&lsqb;0076&rsqb;</number> It should be recognized that in the present preferred example, when in the &ldquo;FEC Not Providing Data&rdquo; mode, the smart card is provided a two-to-one access precedence over all other program processors. This priority is programmed into a programmable state machine within the DMA apparatus and is subject to being changed by the &mgr;PC. As mentioned earlier, the system is intended to provide interactive services, and the &mgr;PC <highlight><bold>19</bold></highlight> will be responsive to interactive data to perform at least in part the interactive operation. In this role, the &mgr;PC <highlight><bold>19</bold></highlight> will use the memory <highlight><bold>18</bold></highlight> both for application storage and working memory. In these instances, the system operator may change the memory access priority to provide the &mgr;PC <highlight><bold>19</bold></highlight> with memory access of greater frequency. The reprogramming of memory access priority may be included as a subset of interactive application instructions. </paragraph>
<paragraph id="P-0077" lvl="0"><number>&lsqb;0077&rsqb;</number> It is advantageous to insert media error codes into the video component signal stream when packets are lost, to condition the video signal decompressor to suspend decompression until a particular signal entry point occurs in the data stream. It is not practical to predict where and in which video packet the next entry point may occur. In order to find the next entry point as fast as possible, it is necessary to include a media error code at the beginning of the first video packet after detection that a packet is lost. The circuitry of <cross-reference target="DRAWINGS">FIG. 7</cross-reference> places a media error code at the beginning of every video packet and then excises the media error code in respective packets if there is no loss of a preceding packet. The media error code is inserted in the first M memory address locations reserved for the current video packet payload, by writing to memory <highlight><bold>18</bold></highlight> for M write cycles prior to the video payload arriving from the decryptor. Concurrently the multiplexor <highlight><bold>99</bold></highlight> is conditioned by the DMA <highlight><bold>98</bold></highlight>, to apply the media error code from the source <highlight><bold>100</bold></highlight> to the memory <highlight><bold>18</bold></highlight> I/O. M is simply the integer number of memory locations required to store the media error code. Assuming the memory to store 8-bit bytes, and the media error code to be 32 bits, M will equal 4. </paragraph>
<paragraph id="P-0078" lvl="0"><number>&lsqb;0078&rsqb;</number> The addresses for loading the media error code in memory are provided by the respective video component service register <highlight><bold>83</bold></highlight> via the multiplexer <highlight><bold>82</bold></highlight> and multiplexer <highlight><bold>85</bold></highlight>. It will be appreciated that the first M addresses provided from the pointer register <highlight><bold>83</bold></highlight> for loading the media error code into the memory locations that would otherwise be loaded with video component data, will simply be the next M sequential addresses that would normally be produced by the video head pointer. These same addresses are coupled into an M-stage delay element <highlight><bold>84</bold></highlight>, so that immediately after the last byte of the media error code is stored in the memory <highlight><bold>18</bold></highlight>, the first of the M addresses is available at the output of the delay element <highlight><bold>84</bold></highlight>. </paragraph>
<paragraph id="P-0079" lvl="0"><number>&lsqb;0079&rsqb;</number> The timing of the loading of the media error code into memory coincides with the determination of a lost packet. Packet error or loss detection is performed by an error detector <highlight><bold>101</bold></highlight> which is responsive to the CC and HD data of the current packet. </paragraph>
<paragraph id="P-0080" lvl="0"><number>&lsqb;0080&rsqb;</number> If a packet loss is detected, the video component of the current packet is stored in memory <highlight><bold>18</bold></highlight>, starting at the next or (M&plus;1)<highlight><superscript>th </superscript></highlight>address location. This is accomplished by conditioning the multiplexer <highlight><bold>85</bold></highlight> to continue to pass undelayed head pointers from the appropriate register <highlight><bold>83</bold></highlight>. Alternatively, if a packet loss is not detected, the first M bytes of the video component in the current packet are stored in the memory locations in which the media error code was immediately previously stored. </paragraph>
<paragraph id="P-0081" lvl="0"><number>&lsqb;0081&rsqb;</number> Packet error or loss detection is performed by an error detector <highlight><bold>101</bold></highlight> which is responsive to the CC and HD data of the current packet. The detector <highlight><bold>101</bold></highlight> examines the continuity count CC in the current packet to determine if it differs from the CC of the previous packet by one unit. In addition the TOGGLE bit in the current packet is examined to determine if it exhibits the proper state for the respective video frame. If the CC value is incorrect, the state of the TOGGLE bit is examined. Depending if one or both of the CC and TOGGLE bit are in error, first or second modes of error remediation are instituted respectively. In the second mode, initiated by both CC and TOGGLE bits being erroneous, the system is conditioned to reset to a packet containing a picture layer header. In the first mode, where only the CC is erroneous, the system is conditioned to reset to a packet containing a slice layer header. (A slice layer is a subset of compressed data within a frame.) In both the first and second modes, the media error code written to memory is retained in the respective payload to alert the decompressor to institute remedial action. </paragraph>
<paragraph id="P-0082" lvl="0"><number>&lsqb;0082&rsqb;</number> It has been found to be particularly efficient to partition the system such that the SCID detector, the decryptor, the addressing circuitry, the conditional access filter, and the smart card interface are all included on a single integrated circuit. This limits the number of external paths which may lead to critical timing constraints. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method of transmitting conditional access information including entitlement management and control data comprising: 
<claim-text>forming N-byte conditional access codes; </claim-text>
<claim-text>concatenating M different N-byte conditional access codes; </claim-text>
<claim-text>selecting one of said N-byte conditional access codes or a special N-byte code of predetermined logic state; </claim-text>
<claim-text>forming a payload including a) said selected one of said N-byte conditional access codes or said special N-byte code, b) concatenating the selected code with said M different N-byte conditional access codes and c) concatenating the concatenated codes with said entitlement management and control data; and </claim-text>
<claim-text>forming a transport packet having a) a header identifying such transport packet as containing entitlement data, and b) said payload. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method set forth in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> further including: 
<claim-text>providing an (M&plus;1) times N byte code in which R groups of N-bytes all have bits in a predetermined logic state (R, M, N all integers and R times N is less than or equal to (M&plus;1) times N), and wherein the step of forming a payload comprises </claim-text>
<claim-text>a) selecting one of said N-byte conditional access codes or an N-byte code of all one logic state, b) concatenating the selected code with said M different N-byte conditional access codes and c) selecting said (M&plus;1) times N byte code or the concatenated code and d) concatenating the last selected code with said entitlement management and control data; and </claim-text>
</claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. Apparatus in a packet signal receiver for processing entitlement data included in signal packets having a header identifying such packets as containing entitlement data, and having a payload having said entitlement data and a payload header including a conditional access code, said apparatus comprising: 
<claim-text>means for applying said packet signal; </claim-text>
<claim-text>a transport processor, responsive to said packet signal, for selecting signal packets identified as containing entitlement data, and extracting payloads from selected packets; </claim-text>
<claim-text>memory means for storing extracted payload data as it is received; </claim-text>
<claim-text>a conditional access filter arranged to examine payload header data of extracted payloads for subscriber specific conditional access codes, and on failure of detection of a subscriber specific payload inhibiting storing of extracted payload data in said memory means. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The apparatus set forth in <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference> further including a smart card coupled to said memory means for utilizing entitlement data stored in said memory means from respective said payloads having entitlement data. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The apparatus set forth in <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference> wherein said conditional access filter comprises; 
<claim-text>a register for storing a N-byte subscriber specific conditional access code; </claim-text>
<claim-text>means, including a comparator, for comparing said payload header data in exclusive N-byte groups, with said N-byte subscriber specific conditional access code contained in said register, and if a match is made of said subscriber specific conditional access code with any of said exclusive N-byte groups, generating an enable signal to write said entitlement data to said memory means. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The apparatus set forth in <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference> wherein said conditional access filter comprises: 
<claim-text>a register for storing a N-byte subscriber specific conditional access code; </claim-text>
<claim-text>means, including a comparator for, 
<claim-text>a) determining if the first N-bytes of said payload header data contain a code of all one logic state; </claim-text>
<claim-text>b) if said first N-bytes do contain a code of all one logic state, comparing N&minus;1 bytes of said subscriber specific conditional access code with said payload header data in exclusive N-byte groups, and if a match is made of N&minus;1 bytes of said subscriber specific conditional access code with N&minus;1 bytes of any of said exclusive N-byte groups, generating an enable signal to write said entitlement data to said memory means; </claim-text>
<claim-text>c) else comparing said payload header data in exclusive N-byte groups, with said N-byte subscriber specific conditional access code contained in said register, and if a match is made of said subscriber specific conditional access code with any of said exclusive N-byte groups, generating an enable signal to write said entitlement data to said memory means. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The apparatus set forth in <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference> further including a detector for detecting if a predetermined number of N-byte groups of said conditional access code in said payload header data are of like logic state, and if so, generating said enable signal. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The apparatus set forth in <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference> further including a detector for detecting if a predetermined number of N-byte groups of said conditional access code in said payload header data have all zero valued bits, and if so, generating said enable signal. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The apparatus set forth in <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference> further including a detector for detecting if all bytes of said conditional access code in said payload header data are of like logic state, and if all bytes of said conditional access code in said payload header data are of like logic state, generating an enable signal to write payload entitlement data to said memory means. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The apparatus set forth in <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference> wherein said register for storing a N-byte subscriber specific conditional access code comprises N 1-byte registers, and said conditional access filter further comprises: 
<claim-text>A multiplexer having N input ports respectively coupled to said N 1-byte registers; </claim-text>
<claim-text>counting circuitry for conditioning said multiplexer to scan its input ports to sequentially provide data from said N 1-byte registers, to said means including a comparator. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The apparatus set forth in <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference> wherein said conditional access filter is programmable to perform a dual function of detecting conditional access codes in a first mode and detecting video component start codes in a second mode. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The apparatus set forth in <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference> wherein said conditional access filter comprises; 
<claim-text>a register for storing a N-byte subscriber specific conditional access code; </claim-text>
<claim-text>a register for storing a N-byte video component start code; </claim-text>
<claim-text>a multiplexer, responsive to a control signal for selecting one of said subscriber specific conditional access code or said video component start code; </claim-text>
<claim-text>means, including a comparator, coupled to said multiplexer, for comparing said payload header data in N-byte groups, with said N-byte subscriber specific conditional access code or said video component start code selected by said multiplexer, and if a match is made of said subscriber specific conditional access code with an N-byte group of the payload header, generating an enable signal to write said entitlement data to said memory means, or if a match is made of said video component start code with an N-byte group of the payload header, generating an start code indicating signal. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The apparatus set forth in <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference> wherein said means, including a comparator is arranged to functionally perform, in said first mode; 
<claim-text>a) determining if the first N-bytes of said payload header data contain a code of all one logic state; </claim-text>
<claim-text>b) if said first N-bytes do contain a code of all one logic state, comparing N&minus;1 bytes of said subscriber specific conditional access code with said payload header data in exclusive N-byte groups, and if a match is made of N&minus;1 bytes of said subscriber specific conditional access code with N&minus;1 bytes of any of said exclusive N-byte groups, generating an enable signal to write said entitlement data to said memory means; </claim-text>
<claim-text>c) else comparing said payload header data in exclusive N-byte groups, with said N-byte subscriber specific conditional access code contained in said register, and if a match is made of said subscriber specific conditional access code with any of said exclusive N-byte groups, generating an enable signal to write said entitlement data to said memory means.</claim-text>
</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>3</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005434A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005434A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005434A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005434A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005434A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005434A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030005434A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030005434A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
