<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005175A1-20030102-D00000.TIF SYSTEM "US20030005175A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005175A1-20030102-D00001.TIF SYSTEM "US20030005175A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005175A1-20030102-D00002.TIF SYSTEM "US20030005175A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005175A1-20030102-D00003.TIF SYSTEM "US20030005175A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005175A1-20030102-D00004.TIF SYSTEM "US20030005175A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005175A1-20030102-D00005.TIF SYSTEM "US20030005175A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030005175A1-20030102-D00006.TIF SYSTEM "US20030005175A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030005175A1-20030102-D00007.TIF SYSTEM "US20030005175A1-20030102-D00007.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005175</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10159209</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20020530</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F009/46</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>709</class>
<subclass>318000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Method and apparatus for providing a state machine operating on a real-time operating system</title-of-invention>
</technical-information>
<continuity-data>
<non-provisional-of-provisional>
<document-id>
<doc-number>60294201</doc-number>
<document-date>20010530</document-date>
<country-code>US</country-code>
</document-id>
</non-provisional-of-provisional>
</continuity-data>
<inventors>
<first-named-inventor>
<name>
<given-name>Matt</given-name>
<family-name>Brocco</family-name>
</name>
<residence>
<residence-us>
<city>Debary</city>
<state>FL</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Dennis</given-name>
<family-name>Cutillo</family-name>
</name>
<residence>
<residence-us>
<city>Sanford</city>
<state>FL</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Mike</given-name>
<family-name>Shaffer</family-name>
</name>
<residence>
<residence-us>
<city>Lake Mary</city>
<state>FL</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>Siemens Corporation</name-1>
<name-2>Intellectual Property Department</name-2>
<address>
<address-1>186 Wood Avenue South</address-1>
<city>Iselin</city>
<state>NJ</state>
<postalcode>08830</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A software state event machine for software based process control systems permits state and events to be unified within a common set of data structures for one or more tasks sharing common state numbers. This method reduces overall memory requirements in systems with extensive states and events among multiple tasks. </paragraph>
</subdoc-abstract>
<subdoc-description>
<cross-reference-to-related-applications>
<heading lvl="1">CROSS REFERENCE TO RELATED APPLICATIONS </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> This application claims the benefit of priority under 35 U.S.C. 119(e) to copending U.S. Patent Provisional Applications, Ser. No. 60/294,201 and filed on May 30, 2001, the contents of said application being incorporated by reference herein in its entirely. </paragraph>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> This application is also related to the following U.S. Patent Applications: U.S. patent application Ser. No.______ filed May 30, 2002 entitled AN INTEGRATED ACCESS PLATFORM; U.S. patent application Ser. No. ________ filed May 30, 2002 entitled METHOD FOR OPERATING AND APPARATUS FOR A BACK-PLANE SUPPORTING REDUNDANT CIRCUIT CARDS; U.S. patent application Ser. No. filed May 30, 2002 entitled METHOD AND APPARATUS OF TESTING A POTS CIRCUIT AND DSL CIRCUIT THROUGH A SPLITTER; U.S. patent application Ser. No. ______filed May 30, 2002 entitled METHOD AND APPARATUS FOR LOADING A MIRROR IMAGE SOFTWARE COPY ACROSS CIRCUIT CARDS; U.S. patent application Ser. No. filed May 30, 2002 entitled METHOD AND APPARATUS FOR A COMMON MANAGEMENT SOFTWARE SYSTEM; U.S. patent application Ser. No. filed May 30, 2002 entitled METHOD AND APPARATUS FOR PROVIDING A COMMON TEXT MESSAGING SYSTEM WITHIN A SOFTWARE ARCHITECTURE; and U.S. patent application Ser. No. filed May 30, 2002 entitled METHOD AND APPARATUS FOR ADMINISTERING MULTIPLE PROVISIONABLE OBJECTS, the contents of each of said applications being incorporated by reference herein in their entirely. </paragraph>
</cross-reference-to-related-applications>
<summary-of-invention>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> 1. Field of the Invention </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> The present invention generally relates to real-time software state machine system and method within a communications system. More specifically, state machine processing is integrated with a Real-time Operating System (RTOS) execution environment. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> 2. Background Description </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> Various types of process control systems employing microprocessors and software to manage the functions of real time activities have been common in many industries. Whether the system is a complex air-traffic control system, manufacturing process control system, a reservation system, or a communication system, the on-going management of the system is crucial to long-term success. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> The nature of process control systems such as in communication packet or circuit switches involve the control of substantial hardware interfaces. These interfaces provide basic and advanced capabilities towards creating a comprehensive communications network for reliably transporting various types of data such as video media, voice traffic, or transactional data. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> The communications industry provides features and functionality that combine essential reliable basic services along with specialized services and capabilities that are delivered through new technologies at varying stages of deployment and maturity. As communications systems are deployed, they often contain both traditional hardware interfaces along with new technology hardware interfaces that provides a basis for increased functionality or evolutionary incremental infrastructure that is meant to deliver more robust communications based on this expanded functionality or based on economic changes in technology. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> Software programming that provides control logic to these communication systems is subject to increasing complexity. This complexity is driven by the newer technologies themselves such as voice over packet switching, new distributed hardware topologies, higher demanded bandwidths, or by reliability and management requirements such as better human interfaces, maintenance and diagnostic capabilities, or operational ease of management. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> In communication systems for example, one necessary aspect of the operational management of the system is a capability to view the ongoing internal operations of the system. In a complex system, the internal operations of the system can contain large numbers of independent functional software tasks which process messages and events in connection with the operation of the system hardware interfaces. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> These software tasks were managed in turn by a Real-time Operating System (RTOS). As inter-task messages were created and sent to other tasks, reference to a logical or physical device such as a port was contained in the message. Also contained in the inter-task messaged typically was a new event, such as a timer time-out or a hardware detected input such as an off-hook of a phone. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> Typically, in the past, every task running under a RTOS had a set of state tables created to service the events based on the event received. The task would be self-contained with all awareness of the state-event data structure linkages for all functions managed and process by that task. The software system would contain many tasks each with their own collection of state-event tables. Under this typical scenario the RTOS was isolated from the task processing and the tasks were isolated from the RTOS. Under this arrangement, the structure of the task&apos;s state machine was unknown to the support functions within the RTOS. This resulted in difficulties in maintaining these state machines and inefficiencies were created since the tasks could not take advantage of pre-existing functions already available within the RTOS. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> It is therefore an object of the invention to provide a method and apparatus for state event handling to occur using a data structure that combines state, event, message ID, and state transition routine address. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> It is another object of the invention to provide a method to reduce the amount of memory required to support state event handling mechanisms in large process control systems. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> It is another objective of the invention to permit a real time operating system to directly execute state transition routines. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> It is another objective of the invention to permit reuse of state numbers among several subsystems. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> According to the invention there is a software state event machine for software based process control systems that permits state and events to be unified within a common set of data structures for one or more tasks sharing common state numbers. This method reduces overall memory requirements in systems with extensive states and events among multiple tasks. This is a method of processing a software state machine of a communication system such as the Siemens Accession product. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> A collection of functions known as VxGex (Gex) implements a state machine RTOS for use, for example, with Vx Works&reg; (Vx Works&reg; is a registered trademark of Wind River Systems) or similar operating systems (OS). VxGex integrates state machine processing with the RTOS execution environment. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> An operating system is able to have multiple state machines associated with it. Each state machine under an operating system task has a data structure, called an Event Control Block (ECB). The ECB is used to store data that must be preserved across state transitions. The data in the ECB includes the current state of the state machine and the ECB type. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> The ECB type is distinguished between different types of state machines. For example, a plain old telephone (POTS) port state machine can have loop start and ground start ports. The ECB allows state machines under the same task to behave differently. The events are received from a standard OS message queue. The message header contains the event being received, the Message ID, and optionally, the ECB number that the event is intended. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> The Message ID is a way to categorize the messages by function, for example, Call Processing, Administration, Status, etc. This allows event codes to be reused over message ID. If there is no ECB number specified in the message, a user defined preprocessor is invoked to determine the ECB number. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> The OS will schedule state transition routines based on the event received and the current state of the machine. The proper state transition routine to schedule is based on a state event table. The first section of the state event table is an array of pointers to type event tables. The state event table is indexed by a state. If the pointer is NULL, an error routine is called and the next message is received. If the pointer is not NULL, the type event table is sequentially searched for a match on ECB type, message ID and event. If a match is found an error routine is called and the next message received.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> The foregoing and other objects, aspects and advantages will be better understood from the following detailed description of a preferred embodiment of the invention with reference to the drawings, in which: </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is an exemplary block diagram of a communication system utilizing the present invention; </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is an exemplary block diagram of a software architecture contain illustrative tasks utilizing inter-task messaging within the system of <cross-reference target="DRAWINGS">FIG. 1</cross-reference>; </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a block diagram showing the relationship of components of the present invention; </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a memory layout table of a TSF Message used in inter-task messaging; </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a memory layout table of an Event Control Block; </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is a memory layout and relationship diagram of the present invention&apos;s state machine data structures; and </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> is a flow diagram of using the data structures of <cross-reference target="DRAWINGS">FIGS. 4, 5</cross-reference>, and <highlight><bold>6</bold></highlight>.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF A DETAILED EMBODIMENT OF THE INVENTION </heading>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, an exemplary communication system is shown as an Integrated Access Platform (IAP) <highlight><bold>100</bold></highlight>, which is a system to provide data and voice communications functionality. The IAP may be a modular system with various interface modules present to build a tailored system as required by a customer. The IAP provides the hardware and software functionality for subscribers to process and manage a wide range of communication features. The IAP contains a central processing unit (CPU) <highlight><bold>101</bold></highlight> and associated memory <highlight><bold>102</bold></highlight>, for implementing software programming and operating system. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> The IAP is connected, in this example, to an Asynchronous Transfer Mode (ATM) network and also to a Public Switch Telephone Network <highlight><bold>120</bold></highlight>. The IAP also provides interfaces of various kinds to subscribers and customers. Three examples of these interface types are illustrated. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> At the bottom left, an IAP Symmetrical Digital Subscriber Line (SDSL) interface is connected to an Integrated Access Device (IAD) <highlight><bold>130</bold></highlight>, which in turn supports a voice-over-digital subscriber line (VODSL) phone <highlight><bold>140</bold></highlight> and a data terminal <highlight><bold>150</bold></highlight>. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> At the middle left, a asymmetric digital subscriber line (ADSL) interface connects a ADSL phone <highlight><bold>160</bold></highlight>, a data terminal <highlight><bold>170</bold></highlight>, and a plain old telephone service phone (POTS) <highlight><bold>180</bold></highlight> to the IAP. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> At the top left, a POTS line connects a POTS phone <highlight><bold>190</bold></highlight> and a V.<highlight><bold>90</bold></highlight>N.<highlight><bold>34</bold></highlight> data terminal <highlight><bold>195</bold></highlight> to the IAP. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> In a computer based process controlled system such as in a communication system, the ability to oversee and manage the operations of the system is essential. The User Interface to the system can be any of a number of device types such as a display, personal computer, or audio device. The User Interface <highlight><bold>122</bold></highlight> is where a user can oversee the operations of the system and is where text is provided as messages in a session with the system. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> The hardware components of a system can be of varying purposes and each component can in turn be controlled by its own computer processor complex, which may be in communication with other processor complexes throughout the system. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> In a communications system or other process control systems, many functions of the system are performed by the hardware interfaces such as telephone interfaces, power interfaces, data and voice signaling interfaces, data and voice transport interfaces such as asynchronous transport mode (ATM), and support interfaces such as alarms and diagnostics. These interfaces have their own specific function in relation to the system as a whole. These interfaces are typically under control of software logic control running on one or more microprocessors. The system may contain redundant processor capability with one complex in standby mode. The processors include memory. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> In a communications system the operating software is typically comprises a plurality of individual tasks. These tasks may run under the same or multiple processors. Each task is given time slices of the overall processor execution capacity typically under control of the operating system (OS) software. Each task is meant to contribute a particular control aspect on behalf of the system such as, for example, a user feature or a hardware diagnostic function. In order for the software system to operate in a collaborative fashion, these tasks are capable of creating inter-task messages to cause advancement of process control sequences. In the case of a communication system, the process control sequence, for example, could be the establishment of a call session between subscribers or recognize a request for call completion from the PSTN or ATM network. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> In the course of typical operation, the hardware interfaces create inputs to the software. The software generates event messages to represent the inputs of the hardware and thereafter controls the sequences of operations by passing inter-task messages to various system tasks responsible for progressing action of a specific type of message. Likewise, a software task may cause a message to be created in response to a prior event that eventually causes a hardware component to provide a service such as, for example, tone generation in a voice path. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> Referring now to <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, exemplary software sub-system architecture suitable for a communication system is illustrated. This sub-system is one of several software sub-systems that may exist within a larger operating system (OS) context. This sub-system represents the Maintenance and Administration (M&amp;A) sub-system of an IAP communication system. It provides the necessary controls and feedback to oversee and manage the overall operation of the system by people responsible for the ongoing performance of the system. It includes a User Interface Task, which controls the User Interface hardware. This sub-system is the primary access for viewing the status and activity of the hardware components of the system and for configuring the system for optimum compliance to the desires of an operating company or other entity using an IAP. This sub-system typically shares one or more common processors and is given access to the processor by an operating system. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is organized to show three distinct levels of functional control. At the bottom, delineated by dash line <highlight><bold>260</bold></highlight>, are software target tasks <highlight><bold>200</bold></highlight>, responsible for directly controlling and monitoring specific hardware interfaces such as POTS, ADSL, and Integrated Access Controller (IAC). These tasks are capable of generating and receiving inter-task messaging represented by the solid lines <highlight><bold>299</bold></highlight>, which are bi-directional paths. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> The Common Management (CM) layer, delineated between lines <highlight><bold>260</bold></highlight> and <highlight><bold>270</bold></highlight>, include software tasks of a comprehensive maintenance and administration which control and interact with the target tasks, <highlight><bold>200</bold></highlight>, and the M&amp;A User Interface, <highlight><bold>250</bold></highlight>, and with one another. The Common Management task, <highlight><bold>235</bold></highlight>, receives and sends messages to other sub-systems (not shown) within the IAP and distributes messages to proper CM layer tasks as necessary. Shown also in <cross-reference target="DRAWINGS">FIG. 2</cross-reference> are exemplary tasks CM Admin <highlight><bold>205</bold></highlight>, CM Config Controller <highlight><bold>210</bold></highlight>, CM Debug <highlight><bold>215</bold></highlight>, CM Status Controller <highlight><bold>220</bold></highlight>, CM Test Controller <highlight><bold>225</bold></highlight>, CM Database Management System <highlight><bold>230</bold></highlight>, CM Alarm &amp; Message processing <highlight><bold>245</bold></highlight>, and CM Gather Active Alarms <highlight><bold>240</bold></highlight>. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> CM Admin <highlight><bold>205</bold></highlight> provides process control to administer system features as required by the system manager personnel through the M&amp;A User interface <highlight><bold>250</bold></highlight>. CM Config <highlight><bold>210</bold></highlight> provides system hardware configuration control as requested by the M &amp; A User Interface. CM Debug Controller <highlight><bold>215</bold></highlight> provides in-depth monitoring and feedback of detailed system information of system performance as requested by system managers. The CM Status Controller <highlight><bold>220</bold></highlight> provides general status information of hardware and software elements and components via the M&amp;A User Interface. CM Test Controller <highlight><bold>225</bold></highlight> provides mechanisms to check and verify operational health of system components via the M&amp;A User Interface. CM Active Alarms <highlight><bold>240</bold></highlight> and CM Alarm Message Processing <highlight><bold>245</bold></highlight> provide error and alarm detection and reporting control. CM Database Management system task <highlight><bold>230</bold></highlight> controls access to and from the System Database in order to synchronize, isolate, and protect the system data. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 3</cross-reference>, this is another a block diagram showing element relationships of the present invention. The IAP <highlight><bold>100</bold></highlight> is shown and illustrates a communications system that contains a software environment. The RTOS, is shown as <highlight><bold>320</bold></highlight> and is shown running on a processor based board <highlight><bold>310</bold></highlight>. Shown also is the VxGex subroutine library <highlight><bold>330</bold></highlight>, which is a collection of functions that implement a state machine on a RTOS platform. Task A and Task B <highlight><bold>340</bold></highlight> are generalized tasks representative of tasks in a communication system such as Administration, Call Processing, and tasks of <cross-reference target="DRAWINGS">FIG. 2</cross-reference>. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> Each of these tasks communicates with each other with an inter-task message as shown in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>. An IAP Transport Function Service (TFS) Message Header structure <highlight><bold>400</bold></highlight> shows exemplary contents of an inter-task message. Other configurations and contents are possible. An inter-task message may include various informational and data elements as necessary to the nature of the message. Some of the fields shown in <cross-reference target="DRAWINGS">FIG. 4</cross-reference> include message byte count <highlight><bold>405</bold></highlight> which designates the total size of the TFS message and the originating Gex task ID <highlight><bold>410</bold></highlight> is the task sending the message. The origination event control block number (ECB) number <highlight><bold>415</bold></highlight> is shown as byte offset <highlight><bold>18</bold></highlight>. ECBs are data structures to store data across state transitions for every logical and physical port or device within the system. The originating ECB is the port sending the message. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> Also shown in <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is the destination ECB <highlight><bold>425</bold></highlight>, or the port to which the message is being sent. Message ID number <highlight><bold>430</bold></highlight> is a high level designation associated with subsystem, e.g., Call Processing or Administration, etc. that this message is associated. This higher level designation permits the numbering of the next field, Event <highlight><bold>435</bold></highlight> to be reused as required within different state machines associated with different subsystems. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 5</cross-reference>, an exemplary IAP ECB header <highlight><bold>500</bold></highlight> is shown. This is a data structure that contains a device or port specific transitory information. An ECB is defined for every port or device in the system. Different layouts and contents may exist for device specific data structures. The layouts and contents are typically related to the nature of the port or device. This is the data structure referenced in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, fields <highlight><bold>415</bold></highlight> and <highlight><bold>425</bold></highlight>. ECBs are defined in task specific data modules. This separates different task&apos;s ECBs into non-contiguous data space to help guard against ECB overwrites resulting from bad indexes into an ECB. ECBs, however, are globally accessible to allow for inter-task ECB access (state bashing). </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> The ECB includes a byte count <highlight><bold>505</bold></highlight>, a Gex task ID <highlight><bold>510</bold></highlight>, which is the task identifier that processes this type of ECB. The current state <highlight><bold>515</bold></highlight>, of the device is shown as is the current event <highlight><bold>516</bold></highlight>, which is to be processed. This field <highlight><bold>516</bold></highlight>, is copied from the TFS field <highlight><bold>435</bold></highlight> when the TFS message is de-queued and processed by the RTOS. The device previous state, <highlight><bold>517</bold></highlight>, and previous event, <highlight><bold>518</bold></highlight>, is also maintained in the ECB for historical logic validation and sequencing in cases when the previous state or event is a necessary qualifier to decisions. Field <highlight><bold>520</bold></highlight> is the ECB number of this particular data structure so that it can be easily identified in circumstances such as memory dumps, sanity checks, or housekeeping routines. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> The ECB type <highlight><bold>525</bold></highlight>, is the device or port type which the ECB represents such as phone, loop start trunk, etc. The Identity field <highlight><bold>530</bold></highlight>, is the Message ID type, which is the subsystem that this ECB is associated and is the same as field <highlight><bold>430</bold></highlight>, of the TFS. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> The following illustrative pseudo-code in Table A shows how the data structure for a state machine is organized and defined. The pseudo-code can be implemented in a variety of programming languages such as C or C&plus;&plus;. The exemplary task is OCCUPANCY_TSK, which could be a task that monitors the processor duty burden or occupancy statistics. This task is representative of any number of tasks that could be managed under this present invention. Two states are shown UNEQ_S and ACTIVE_S for the OCCUPANCY_TSK, which could have any number of actual states. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> There are four fields in the data structure. Type defines the type of task, i.e., Occupancy Task for each entry. The field Event defines possible events that could be received by this state. Message ID is the task that is permitted to use this state event table and is cross-checked during event processing to insure that the task is a valid task for receiving and processing the event. Transition routine field is the state/event processing routine destination that is designated to advance process control for the event in this state. Note that some events are ignored (ignore_event). Note that a DBG_OCC_E event is valid only for a Message ID (task) of DBG_RQ_M (these represent a debug event and task) otherwise the event is not processed. The Messagep_ID of ANY_ID is a type of wild card that means that the event is valid for any Message ID. So as can be seen, the task Message ID is embedded in the state definitions. In the past, a data structure would have two dimensions of state and event for a given single task (i.e., Message ID) so the system&apos;s overall state machine would necessarily be expanded in size.  
<table-cwu id="TABLE-US-00001">
<number>1</number>
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="287PT" align="left"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center">TABLE A</entry>
</row>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>OCCUPANCY_TSK</entry>
</row>
<row>
<entry>;</entry>
</row>
<row>
<entry>;</entry>
</row>
<row>
<entry>UNEQ_S</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="63PT" align="left"/>
<colspec colname="2" colwidth="84PT" align="left"/>
<colspec colname="3" colwidth="49PT" align="left"/>
<colspec colname="4" colwidth="91PT" align="left"/>
<tbody valign="top">
<row>
<entry>/* Type</entry>
<entry>Event</entry>
<entry>Message ID</entry>
<entry>Transition Routine</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="147PT" align="left"/>
<colspec colname="2" colwidth="49PT" align="left"/>
<colspec colname="3" colwidth="91PT" align="left"/>
<tbody valign="top">
<row>
<entry>;</entry>
<entry></entry>
<entry></entry>
</row>
<row>
<entry>OCCUPANCY_TYPE, INIT_IE,</entry>
<entry>ANY_MID</entry>
<entry>coccupancy_uneq_init_tr</entry>
</row>
<row>
<entry>OCCUPANCY_TYPE, MINUTE_IE,</entry>
<entry>ANY_MID</entry>
<entry>coccupancy_uneq_min_tr</entry>
</row>
<row>
<entry>OCCUPANCY_TYPE, QUARTER_HOUR_IE,</entry>
<entry>ANY_MID</entry>
<entry>ignore_event</entry>
</row>
<row>
<entry>OCCUPANCY_TYPE, HOUR_IE,</entry>
<entry>ANY_MID</entry>
<entry>ignore_event</entry>
</row>
<row>
<entry>OCCUPANCY_TYPE, DBG_OCC_E,</entry>
<entry>DBG_RQ_M</entry>
<entry>coccupancy_act_poll_tr</entry>
</row>
<row>
<entry>;</entry>
</row>
<row>
<entry>ACTIVE_S</entry>
</row>
<row>
<entry>OCCUPANCY_TYPE, MINUTE_IE,</entry>
<entry>ANY_MID</entry>
<entry>coccupancy_act_minute_tr</entry>
</row>
<row>
<entry>OCCUPANCY_TYPE, QUARTER_HOUR_IE</entry>
<entry>ANY_MID</entry>
<entry>coccupancy_act_qhour_tr</entry>
</row>
<row>
<entry>OCCUPANCY_TYPE, HOUR_IE</entry>
<entry>ANY_MID</entry>
<entry>coccupancy_act_hour_tr</entry>
</row>
<row>
<entry>OCCUPANCY_TYPE, DBG_OCC_E,</entry>
<entry>DBG_RQ_M</entry>
<entry>coccupancy_act_poll_tr</entry>
</row>
<row>
<entry>OCCUPANCY_TYPE, INIT_IE</entry>
<entry>ANY_MID</entry>
<entry>coccupancy_uneq_init_tr</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 6</cross-reference>, the exemplary pseudo-code of TABLE A is represented pictorially. In addition to the UNEQ_S and ACTIVE_S states, <highlight><bold>602</bold></highlight> <highlight><bold>5</bold></highlight> and <highlight><bold>606</bold></highlight> respectively, three additional states are shown, IDLE_S, MOS_S, and FOS_S, <highlight><bold>603</bold></highlight>, <highlight><bold>604</bold></highlight> and <highlight><bold>605</bold></highlight> resepctively. A State Pointer table (also known as a state/event table) for this given task <highlight><bold>600</bold></highlight>, provides pointers to one or more Type Event Tables <highlight><bold>620</bold></highlight>. Multiple State Pointer Tables may exist in a system. Typically, there is one for each subsystem in the system. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> The pointer for the UNEQ_S state <highlight><bold>602</bold></highlight>, shown as <highlight><bold>690</bold></highlight>, is accompanied by a count field, <highlight><bold>607</bold></highlight>. The amount of events defined for this state is five. The pointer for the ACTIVE_S state <highlight><bold>606</bold></highlight>, shown as <highlight><bold>680</bold></highlight>, also has count field <highlight><bold>608</bold></highlight>, which defines five events. The Type Event Table <highlight><bold>620</bold></highlight>, has four fields. The first field is a Type field <highlight><bold>622</bold></highlight>, labeled as OCCUPANCY_TYPE, which is the ECB type. The second field is the Event field <highlight><bold>625</bold></highlight>, and defines the events permissible in this state. The third field is the Message ID field <highlight><bold>630</bold></highlight>, which indicate the task valid for this event in this state. When an event is processed, this field is double-checked and matched against the task involved. The fourth field <highlight><bold>640</bold></highlight> is the address of the event handler routine. Any state with no permitted events are designated such with a NULL pointer <highlight><bold>609</bold></highlight>, in the State Pointer table <highlight><bold>600</bold></highlight>. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> Referring now to <cross-reference target="DRAWINGS">FIG. 7</cross-reference> and previous drawings, the flow diagram presents the steps to use this present invention and begins at step <highlight><bold>700</bold></highlight>. The flow assumes an inter-task TSF message is present to dequeue from the RTOS message queue for a given task; otherwise this flow is not executed. At step <highlight><bold>710</bold></highlight> a pending TSF message is dequeued by the RTOS, a VxGex function checks whether a valid destination ECB <highlight><bold>425</bold></highlight>, is present in the TSF message. If not present or NULL, a preprocessor function is called at step <highlight><bold>725</bold></highlight> which analysis the <highlight><bold>5</bold></highlight> TSF to determine which ECB is appropriate given the detailed contents of the TSF and field <highlight><bold>435</bold></highlight> is updated in the TSF. Usually the ECB is provided in the TSF by the originating Gex task and this step is often not necessary. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> The next step in either case is step <highlight><bold>730</bold></highlight> where a pointer is retrieved from the State Pointer table of the current task. The current state <highlight><bold>515</bold></highlight> is used to index this table. If the event table pointer is NULL, as checked in step <highlight><bold>740</bold></highlight>, this is a fault condition and an appropriate fault handler shown at step <highlight><bold>790</bold></highlight> is called to log this instance. The current message is then ignored and the next message processed at step <highlight><bold>710</bold></highlight>. Debug information may also be recorded of the state and event information for later retrieval at step <highlight><bold>790</bold></highlight>. </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> If the event table pointer is not NULL at step <highlight><bold>740</bold></highlight>, then a search is made, at step <highlight><bold>750</bold></highlight>, of a Type Event Table <highlight><bold>620</bold></highlight> pointed to by the appropriate entry of the State Pointer table <highlight><bold>600</bold></highlight>. The count field, such as <highlight><bold>607</bold></highlight> or <highlight><bold>608</bold></highlight>, is used to control the search limits. A search is made of three elements for a match that includes the Type field <highlight><bold>622</bold></highlight>, the Message ID field <highlight><bold>630</bold></highlight>, and the Event field <highlight><bold>625</bold></highlight>. These are matched to the Type field <highlight><bold>525</bold></highlight>, the Identity field <highlight><bold>530</bold></highlight>, and Event field <highlight><bold>516</bold></highlight>, respectively. If a match is found, the corresponding state transition routine is called using pointer field <highlight><bold>640</bold></highlight>, as shown in step <highlight><bold>760</bold></highlight>. Once the transition routine completes, process control continues at step <highlight><bold>710</bold></highlight>. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> If the comparison of step <highlight><bold>750</bold></highlight> does not provide a match, then a test at step <highlight><bold>770</bold></highlight> is made to see if all entries within the Type Event Table has been checked. If another entry is available, the pointer to the Type Event is incremented at step <highlight><bold>780</bold></highlight>. The next entry is then checked for a match at step <highlight><bold>750</bold></highlight>. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> If all entries of the Type Event table have been checked at step <highlight><bold>770</bold></highlight>, the result is considered a fault since no pre-established entry to process the event for the Message ID and Type exists. Fault processing is called at step <highlight><bold>790</bold></highlight>. Which processes the fault and continues with step <highlight><bold>710</bold></highlight>. </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> The process continues as long as a message is available in the message queue. The RTOS provides to this access to the processor as needed by pre-established time-slicing arrangements. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> While the invention has been described in terms of preferred embodiments, those skilled in the art will recognize that the invention can be practiced with modifications and in the spirit and scope of the appended claims. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">Having thus described our invention, what we claim as new and desire by Letters Patent is as follows: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A state machine for use in a process control system for managing processing of inter-task messages between tasks under control of a real-time operating system, the inter-task messages created as a result of hardware events and software events, the state machine comprising: 
<claim-text>a first data structure containing one or more first entries, each said one or more first entries including: 
<claim-text>a pointer to a second data structure, and </claim-text>
<claim-text>a counffield, said one or more first entries each representative of a state, and said count field representative of a count of events valid for said state; and </claim-text>
<claim-text>a said second data structure containing one or more second entries, each said one or more second entries including a Type field, an Event field, a Message ID field, and a state transition routine pointer for providing the address of the state transition routine. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The state machine as recited in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein said first data structure comprises a plurality of said first data structures. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The state machine as recited in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein said second data structure comprises a plurality of said second data structures. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The state machine as recited in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein said Type field represents a task identification. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The state machine as recited in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein said Event field represents one of either a hardware event or a software event. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The state machine as recited in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein said count field comprises a NULL field. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The state machine as recited in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising a third data structure, said third data structure being an Event Control Block comprising: 
<claim-text>a second Message ID field; and </claim-text>
<claim-text>a second event field, said second event field used to match a said first event field and said second Message ID field used to match a said first Message ID field. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. A state machine method for use in a process control system for managing processing of inter-task messages between tasks under control of a real-time operating system(RTOS), the inter-task messages created as a result of hardware events and software events, the method comprising the steps of: 
<claim-text>dequeuing an inter-task message; </claim-text>
<claim-text>checking said inter-task message for a known Event Control Block entry; </claim-text>
<claim-text>getting a pointer to a State Pointer table; </claim-text>
<claim-text>checking State Pointer table entry for a NULL pointer; </claim-text>
<claim-text>accessing a Type Event table using a second pointer; </claim-text>
<claim-text>comparing a Type Event table Message ID field to an Identity field of said inter-task message; </claim-text>
<claim-text>comparing an Type Event table Event field to a second Event field of said inter-task message; and </claim-text>
<claim-text>comparing a Type Event table Type field to a second Type field of an inter-task message. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The state machine method as recited in <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference>, further including the step of calling a call state transition routine. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The state machine method as recited in <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference>, wherein when any one comparison step is false the method includes incrementing said second pointer. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The state machine method as recited in <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference>, wherein said second pointer is obtained from said State Pointer Table. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The state machine method as recited in <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference>, wherein when the checking State Pointer table entry for a NULL pointer step is true the method includes calling a fault routine. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The state machine method as recited in <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein the incrementing said second pointer step further includes: 
<claim-text>checking whether all entries in said Type Event table have been checked; and </claim-text>
<claim-text>calling a fault routine in the case where all entries have been checked.</claim-text>
</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>7</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005175A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005175A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005175A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005175A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005175A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005175A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030005175A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030005175A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
