<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005413A1-20030102-D00000.TIF SYSTEM "US20030005413A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005413A1-20030102-D00001.TIF SYSTEM "US20030005413A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005413A1-20030102-D00002.TIF SYSTEM "US20030005413A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005413A1-20030102-D00003.TIF SYSTEM "US20030005413A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005413A1-20030102-D00004.TIF SYSTEM "US20030005413A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005413A1-20030102-D00005.TIF SYSTEM "US20030005413A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030005413A1-20030102-D00006.TIF SYSTEM "US20030005413A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030005413A1-20030102-D00007.TIF SYSTEM "US20030005413A1-20030102-D00007.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005413</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10159952</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20020531</filing-date>
</domestic-filing-data>
<foreign-priority-data>
<priority-application-number>
<doc-number>A 861/2001</doc-number>
</priority-application-number>
<filing-date>20010601</filing-date>
<country-code>AT</country-code>
</foreign-priority-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F009/44</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>717</class>
<subclass>125000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Method for testing of software</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Armin</given-name>
<family-name>Beer</family-name>
</name>
<residence>
<residence-non-us>
<city>Baden</city>
<country-code>AT</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Joachim</given-name>
<family-name>Manz</family-name>
</name>
<residence>
<residence-non-us>
<city>Munchen</city>
<country-code>DE</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Stefan</given-name>
<family-name>Mohacsi</family-name>
</name>
<residence>
<residence-non-us>
<city>Wien</city>
<country-code>AT</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Christian</given-name>
<family-name>Stary</family-name>
</name>
<residence>
<residence-non-us>
<city>Wien</city>
<country-code>AT</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<assignee>
<organization-name>Siemens AG Osterreich</organization-name>
<assignee-type>03</assignee-type>
</assignee>
<correspondence-address>
<name-1>Paul D. Greeley, Esq.</name-1>
<name-2>Ohlandt, Greeley, Ruggiero &amp; Perle, L.L.P.</name-2>
<address>
<address-1>One Landmark Square, 10th Floor</address-1>
<city>Stamford</city>
<state>CT</state>
<postalcode>06901-2682</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">There is provided a method for the automated testing of software, which has a graphic user interface. With at least one graphic editor, at least the dynamic and the semantic behavior of the user interface of the software is specified. Test cases are generated by a test case generator software using the thus specified behavior of the user interface, which are then executed by a software for automatic running test running either immediately or in a later step. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">CROSS REFERENCE TO RELATED APPLICATIONS </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> The present application is claiming priority of Austrian Patent Application A 861/2001, filed on Jun. 1, 2001. </paragraph>
</section>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> 1. Field of the Invention </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> The invention concerns a method for the automated testing of software, which has a graphic user interface, wherein a test case generator software is used that can be executed on a data processing device, by means of which test cases are generated and these are checked out with a software for automatic running of a test on a data processing device. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> Furthermore, the invention concerns a method for testing of software with a graphic user interface, wherein test cases are checked out with a software for automatic running of a test on a data processing device, which are generated with a test case generator software, wherein to test a transition between two states of the user interface of the software being tested at least one test case is generated that contains the corresponding transition. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> Finally, the invention also concerns a method for determining a path to a specifiable transition in an expanded diagram of state, for example, in a software with a graphic user interface. Testing is in general an activity with the goal of finding errors in a software and forming confidence for its correct mode of operation. The test is one of the most important quality assurance measures in software development. However, the test is often underestimated in terms of time, costs, and systematics in the software development process. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> 2. Description of the Prior Art </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> The design of effective test cases, i.e., such which </paragraph>
<paragraph id="P-0008" lvl="2"><number>&lsqb;0008&rsqb;</number> find customer-relevant errors, </paragraph>
<paragraph id="P-0009" lvl="2"><number>&lsqb;0009&rsqb;</number> optionally enable a more or less complete coverage of the tested object, </paragraph>
<paragraph id="P-0010" lvl="2"><number>&lsqb;0010&rsqb;</number> also contain complex test scenarios whose organization requires not only much preparation time, but also costly and hard-to-find expert knowledge, and </paragraph>
<paragraph id="P-0011" lvl="2"><number>&lsqb;0011&rsqb;</number> can also be used for automatic regression testing, </paragraph>
<paragraph id="P-0012" lvl="7"><number>&lsqb;0012&rsqb;</number> is a very demanding and time and money-consuming activity. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> A test case is defined as follows by IEEE90: &ldquo;A set of test inputs, execution conditions, and expected results developed for a particular objective, such as to exercise a particular program path to verify compliance with a specific requirement.&rdquo; The possibility of carrying out such a demanding activity with a software tool is therefore of outstanding importance to each software development project in terms of the three known critical aspects of functionality, timeliness, and cost. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> Semantic-oriented test scenarios guarantee the error-free running of the stipulated functionality in keeping with the sequences requested by the customer. The generation and executability of test scenarios through a software tool contribute significantly to meeting deadlines and also economize on development costs. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> Another weakness in the release of many software projects consists in that, at the end of an often many-year development period, it is no longer transparent whether the released product can fulfill the properties which were agreed upon in the beginning and documented in the specifications. This means there is a lack of a bridge between design and test documentation, making it difficult or sometimes impossible to make accurate quality predictions about the product being delivered. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> Various methods have been used for the testing of software, such as StP-T (Poston R. M., <highlight><italic>Automated Testing from object models; Comm. of the ACM, </italic></highlight>September 1994, Vol. 37, No. 9, pp. 48-58) or Rational Test Factory (<highlight><italic>Rational, User Manual, Test Factory, </italic></highlight>1999). In these methods, however, complicated processes are running with alternate manual and automated activities. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> In other software tools such as Mockingbird (Wood J., <highlight><italic>Automatic Test Generation Software Tools; Siemens Corporate Research, Technical Report </italic></highlight>406, December 1992), it is not possible to generate any executable test cases, while in the case of the Titan Tool (Wood J., <highlight><italic>Automatic Test Generation Software Tools; Siemens Corporate Research, Technical Report </italic></highlight>406, December 1992), test data are generated from a test scheme and test matrices. In any case, these methods are hardly user-friendly enough for successful use in complex software systems. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> Various methods are also used to generate test cases, such as generation of test cases by means of search mechanisms of &ldquo;artificial intelligence&rdquo;, in which the backtracking mechanism of PROLOG is used. Another method consists in the generation of individual state transition sequences from a complex state transition graph with cycles from a start state to a target state, wherein the changes in state are triggered by user inputs. The drawback to these familiar methods is, in particular, that they face the problem of a large number of redundant test cases. Furthermore, there are no intelligent algorithms for the test case generation, which in addition to generating &ldquo;good cases&rdquo; can also generate &ldquo;bad cases&rdquo; and reveal specific errors. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> According to what has been said above, one object of the invention is to indicate methods by which a user-friendly testing of software is possible, and the above drawbacks are avoided. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> Furthermore, another object of the invention is to enable design and testing processes even in large projects under heavy time and cost pressure. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> These objects are accomplished with a method for automated testing of software as mentioned in the outset, in that according to the invention </paragraph>
<paragraph id="P-0022" lvl="2"><number>&lsqb;0022&rsqb;</number> a) at least the dynamic and the semantic behavior of the user interface of the software is specified with at least one editor, and a graphic editor is used as the editor, and </paragraph>
<paragraph id="P-0023" lvl="2"><number>&lsqb;0023&rsqb;</number> b) through the thus specified behavior of the user interface, test cases are generated by the test case generator software, which immediately thereafter or in a remote step </paragraph>
<paragraph id="P-0024" lvl="2"><number>&lsqb;0024&rsqb;</number> c) are executed by the software for the automatic test running. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> Thanks to the use of a graphic editor, the behavior of the user interface of the software being tested can be specified in an extremely user-friendly way and manner. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> Advisedly before step a) of the invented method, static information of the user interface is entered by the editor. Usually, the static information will be entered by a monitor screen analysis software or from a resource file. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> The static information comprises at least one layout and/or attributes of the elements of the graphic user interface. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> In order to allow a flexible configuration of the invented method and permit interventions by a user for the most effective possible testing, the static information with regard to the layout and/or the attributes can be amplified by a user. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> The method according to the invention can be configured especially user-friendly when the dynamic behavior of the software/user interface is specified by entering status transitions, in particular, when the status transitions are represented by graphic symbols. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> In this way, one has the original precise picture of a dialogue in front of them, and the individual status transitions can be defined especially easily, for example, by drawing arrows. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> In an especially advantageous embodiment of the invention, the status transitions are associated with semantic conditions and/or syntactical conditions, and to specify the dynamic behavior of the user interface it is only necessary to indicate the status transitions whose events are associated with syntactical or semantic conditions. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> The formal specification now present in the form of a status transition diagram describes the dynamic behavior of the user interface in exact form and is the input for a test case generator. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> A test case generating algorithm searches&mdash;as will be described further below&mdash;for suitable paths in the status transition graph, wherein all elements of the graphic user interface are addressed at least once by the test case generator software and all status transitions depending on semantic and/or syntactical conditions are covered by the test case generator software with at least one correct and at least one wrong transition value. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> Furthermore, the above-mentioned tasks are accomplished with a method for the testing of software as mentioned in the beginning, using a graphic user interface, in that according to the invention, in order to generate the at least one test case </paragraph>
<paragraph id="P-0035" lvl="2"><number>&lsqb;0035&rsqb;</number> a) a first path of transitions is generated, which starts with an initial status of the user interface and ends in an intermediate status, the intermediate status being a state which fulfills all entry conditions necessary for the transition being checked, and </paragraph>
<paragraph id="P-0036" lvl="2"><number>&lsqb;0036&rsqb;</number> b) at least one additional path of transitions is generated, which starts in the state generated by the transition being tested and ends in the final state of the graphic user interface, and </paragraph>
<paragraph id="P-0037" lvl="2"><number>&lsqb;0037&rsqb;</number> c) the two paths are joined together with the transition. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> Advisedly, the test case generated is then stored in a test case database. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> A path is generated to a given transition by a method as mentioned in the beginning, wherein according to the invention </paragraph>
<paragraph id="P-0040" lvl="2"><number>&lsqb;0040&rsqb;</number> a) at least one set of permitted input conditions is determined, for which the transition being tested can be executed, </paragraph>
<paragraph id="P-0041" lvl="2"><number>&lsqb;0041&rsqb;</number> b) suitable values are determined for all variables on which the input conditions depend, so that all input conditions are fulfilled, and for each variable on which the condition depends, starting with a first variable </paragraph>
<paragraph id="P-0042" lvl="2"><number>&lsqb;0042&rsqb;</number> c) at least one transition is sought, which sets the variable at the desired value, and then the status of the status diagram is changed to a value corresponding to the value of the altered variable and </paragraph>
<paragraph id="P-0043" lvl="2"><number>&lsqb;0043&rsqb;</number> d) step c) is carried out for the next variable of the condition. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> In one embodiment of the invention, the path is determined by calling up a search function. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> Favorably, no path is generated in the event that the present state of the status diagram of the user interface coincides with a set of permitted input conditions. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> In an especially advantageous embodiment of the invention, the variables have a given sequence and the variables are worked off in a particular sequence per step c) and d). </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> Furthermore, in step c) if the value of a variable agrees with the desired value the method continues with the next variable, and if no suitable values are found in step c) an error is output. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> The method according to the invention proves especially effective in that, when no transition is found for a variable, it returns at least to the immediately preceding variable that was worked off, generates a new transition for it, and then again searches for a transition for the variable per step c). Furthermore, a path is determined for each transition. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> In one specific embodiment of the invention, the path is determined by recursive invoking of the search function. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> Furthermore, in the event that no path to the transition is found, a different transition is determined. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> Moreover, when a path is found, a check is made as to whether one or more variables already set at a desired value are changed by the path, and if at least one variable is changed by a path, a new path to the transition is sought. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> Finally, if no solution is found, the sequence for working off the variables is altered, and if no solution is found in step b), different variables are sought. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> In conclusion, when a path is determined it is added to an outcome path, and after all paths have been added the outcome path is output. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> It is then also necessary to determine a path to an end state of the status diagram. For this, according to the method of the invention, a transition is sought which immediately terminates the application, and a path to the transition which starts from a current state of the status diagram is sought. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> Advisedly, no path is sought when the current state of the application is the end state.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> The invention shall now be explained more closely hereafter by means of the drawing. This shows: </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1 a</cross-reference> flow chart of the method according to the invention, </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2 a</cross-reference> sample view of a window hierarchy editor for editing the static information of a graphic user interface, </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3 a</cross-reference> sample view of a window properties editor for editing the static information of a window of a graphic user interface, </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4 a</cross-reference> sample view of a window editor for editing the dynamic information of a window of a graphic user interface, furthermore </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5 a</cross-reference> view of a menu editor for editing the dynamic information of the menu of a window of a graphic user interface, </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6 a</cross-reference> view of a condition editor for editing the semantic information of a graphic user interface, furthermore </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7 a</cross-reference> view of an action editor for editing of semantic information of a graphic user interface, </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8 a</cross-reference> sample input mask for generating test cases with a software tool based on the method according to the invention, </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9 a</cross-reference> sample output window for test cases, wherein subsequent editing of the test cases is also possible, </paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10</cross-reference> an example of an output file generated with a software for automatic test running, which has been generated by means of test cases produced with the method of the invention, </paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 11</cross-reference> an example of the generating of a test case, </paragraph>
<paragraph id="P-0068" lvl="0"><number>&lsqb;0068&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 12</cross-reference> an example of a test case structure, </paragraph>
<paragraph id="P-0069" lvl="0"><number>&lsqb;0069&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 13</cross-reference> an example of a structure of a function reference, </paragraph>
<paragraph id="P-0070" lvl="0"><number>&lsqb;0070&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 14</cross-reference> an example of a condition tree, </paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 15 a</cross-reference> sample view of a login window of a graphic user interface, and </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 16 a</cross-reference> structure of the function references during a sample test case generation.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DESCRIPTION OF THE INVENTION </heading>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> Hereinafter, the invented method and a software adapted appropriately to carry out the method are explained in detail by means of FIGS. <highlight><bold>1</bold></highlight>-<highlight><bold>16</bold></highlight>. <cross-reference target="DRAWINGS">FIG. 1</cross-reference> shows the basic sequence of the method, the portion critical to the invention being designated as IDATG. According to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, first of all a graphic user interface (GUI) being tested is described in terms of its static properties, for example, using an appropriate software, such as a so-called &ldquo;GUI Builder&rdquo;. This static information is then saved in a resource file. Another possibility is to determine the static information by means of monitor screen analysis software (&ldquo;GUI Spy&rdquo;). A detailed explanation of the static structure of a GUI will be given further on. </paragraph>
<paragraph id="P-0074" lvl="0"><number>&lsqb;0074&rsqb;</number> The static information saved in the resource file or entered with the monitor screen analysis software is now read into the IDATG software used according to the invention, amplified with the dynamic and semantic information about the GUI, and by means of all this information, as is further explained in detail hereinafter, test cases are generated, which can ultimately be executed with a corresponding program, such as &ldquo;WinRunner&rdquo;. </paragraph>
<paragraph id="P-0075" lvl="0"><number>&lsqb;0075&rsqb;</number> FIGS. <highlight><bold>2</bold></highlight>-<highlight><bold>8</bold></highlight> show various editors and dialogue windows for describing the graphic user interface, which we shall explain in detail hereafter. For subsequent editing of the static information of the GUI, a window hierarchy editor is used, as shown by example in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, in which the window hierarchy of the GUI is indicated as a tree. This hierarchy can then be worked on with the editor by means of Drag and Drop. </paragraph>
<paragraph id="P-0076" lvl="0"><number>&lsqb;0076&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 3 and 4</cross-reference> show a window properties editor for editing the static information of a window of a graphic user interface, as well as a window editor for editing the dynamic properties of a window of the graphic user interface. The dynamic behavior of the OK button is described with the arrows of the graphic editor shown in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>. If the user input is correct, the focus jumps back to the first field, in this case, &ldquo;Name&rdquo;, and a new person can be entered with the corresponding data in the input mask. If, instead, a wrong input is made, such as a negative age in the &ldquo;Age&rdquo; field, a corresponding message is output in an error message window. </paragraph>
<paragraph id="P-0077" lvl="0"><number>&lsqb;0077&rsqb;</number> With the menu editor shown in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>, menus of a GUI can be edited, and transitions can be indicated and triggered by selecting the corresponding menu entry (in the depicted example, by selecting &ldquo;Close&rdquo; a file is closed and there is a branch going to different windows depending on whether or not the file was previously edited). </paragraph>
<paragraph id="P-0078" lvl="0"><number>&lsqb;0078&rsqb;</number> With the condition editor shown in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>, yet additional semantic information can be edited, e.g., that the indicated gender must not be male when a maiden name (&num;MaidenName&num;) is entered. </paragraph>
<paragraph id="P-0079" lvl="0"><number>&lsqb;0079&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> shows an actions editor, which shall be discussed further below, and <cross-reference target="DRAWINGS">FIG. 8</cross-reference> shows a typical selection window for the software used, revealing that two types of test cases can be generated in a well-proven embodiment of the invention, namely, a transition test for transitions between particular transitions, and a syntax test for input fields. </paragraph>
<paragraph id="P-0080" lvl="0"><number>&lsqb;0080&rsqb;</number> Finally, <cross-reference target="DRAWINGS">FIG. 9</cross-reference> shows an output editor for generated test cases, with which the test cases can be further edited afterwards and certain additional test cases, such as manually created ones, can also be added, and <cross-reference target="DRAWINGS">FIG. 10</cross-reference> shows the outcome of a test run with an automatic testing software&mdash;such as WinRunner&mdash;using test cases generated by the method of the invention. </paragraph>
<paragraph id="P-0081" lvl="0"><number>&lsqb;0081&rsqb;</number> A simple example of the generating of a test case is shown in <cross-reference target="DRAWINGS">FIG. 11</cross-reference>. The purpose of the test case is to test the &ldquo;Delete&rdquo; button of an application. However, this is only active when a data record has previously been sought by &ldquo;Search&rdquo;. The searching, in turn, is only possible when a name has previously been entered as the search term. All this information is specified in advance as conditions and actions. The generating algorithm is able to create a correct test case step by step from this information. </paragraph>
<paragraph id="P-0082" lvl="0"><number>&lsqb;0082&rsqb;</number> For a better understanding of the invention, a graphic user interface shall now be described by means of formal terminology. </paragraph>
<paragraph id="P-0083" lvl="0"><number>&lsqb;0083&rsqb;</number> Graphic user interfaces consist of objects, the so-called &ldquo;Windows&rdquo;. There are various definitions for the term &ldquo;Window&rdquo;. In the following description, all GUI objects shall be termed &ldquo;Windows&rdquo;, i.e., dialogues, buttons, input fields and even static text will also be designated as windows, regardless of the actual position of the window in the hierarchy of the graphic user interface. Each window is assigned a distinct ID. Thus, a graphic user interface can be described as a set of windows: GUI_Objects&equals;&lcub;W<highlight><subscript>1</subscript></highlight>, W<highlight><subscript>2</subscript></highlight>, . . . W<highlight><subscript>n</subscript></highlight>&rcub;, with the W<highlight><subscript>i </subscript></highlight>representing the corresponding window IDs. </paragraph>
<paragraph id="P-0084" lvl="0"><number>&lsqb;0084&rsqb;</number> Each window can be described by a set of properties, termed hereinafter &ldquo;designators&rdquo; and always enclosed by a &lsquo;&num;&rsquo; character. One can distinguish three basic types: </paragraph>
<paragraph id="P-0085" lvl="2"><number>&lsqb;0085&rsqb;</number> Designators already defined by the class library of the GUI. These include strings such as the ID or the caption, numbers like the coordinates, and Boolean values which indicate whether the window is active or not. The names of these designators have the following pattern: &num;WindowID:$PropertyName&num;. For example, &num;IDOK:$Enabled&num;. The character &lsquo;$&rsquo; is used to distinguish predefined designators from other types. </paragraph>
<paragraph id="P-0086" lvl="2"><number>&lsqb;0086&rsqb;</number> Many window types accept user input, which is indicated as the window contents. For example, input fields can contain strings or numbers, check boxes can contain Boolean values. The window ID is sufficient to address these values, e.g., &num;IDC_NAME&num;. </paragraph>
<paragraph id="P-0087" lvl="2"><number>&lsqb;0087&rsqb;</number> In addition, a user can define additional designators for a window, in order to describe certain application-specific properties. For example, a dialogue can have different modes, such as one mode for creating a new data record and another mode for editing an existing data record. In this case, it is convenient for the user to define a new Boolean designator which indicates the present mode, for example. The following pattern is used as the syntax in this case: &num;WindowID:PropertyName&num;. For example, &num;IDD_HUMAN:Mode&num;. In this case, the property name contains no &lsquo;$&rsquo;. </paragraph>
<paragraph id="P-0088" lvl="0"><number>&lsqb;0088&rsqb;</number> A window W is now defined by a n-tuple of designators (properties): W&equals;(D<highlight><subscript>1</subscript></highlight>, D<highlight><subscript>2</subscript></highlight>, . . . D<highlight><subscript>n</subscript></highlight>). The number and the types of the designators depend on the class library used for the GUI and other application-specific properties. This n-tuple of designators describes a momentary condition, since the values of the designators can change dynamically when the application is executed. For example, a user can change the contents of a window or its size. </paragraph>
<paragraph id="P-0089" lvl="0"><number>&lsqb;0089&rsqb;</number> Since the GUI consists exclusively of windows and each state can be represented by a tuple, the entire status of the GUI can also be described as a combination C of all these tuples: </paragraph>
<paragraph id="P-0090" lvl="2"><number>&lsqb;0090&rsqb;</number> C&equals;(W<highlight><subscript>1</subscript></highlight>, W<highlight><subscript>2</subscript></highlight>, . . . W<highlight><subscript>n</subscript></highlight>)&equals;(D<highlight><subscript>1,1</subscript></highlight>, D<highlight><subscript>1,2</subscript></highlight>, . . . D<highlight><subscript>1,m</subscript></highlight>, D<highlight><subscript>2,1</subscript></highlight>, D<highlight><subscript>2,2</subscript></highlight>, . . . D<highlight><subscript>2,p</subscript></highlight>, D<highlight><subscript>n,1</subscript></highlight>, D<highlight><subscript>n,2</subscript></highlight>, . . . D<highlight><subscript>n,q</subscript></highlight>). </paragraph>
<paragraph id="P-0091" lvl="0"><number>&lsqb;0091&rsqb;</number> The initial state of the GUI is termed the starting combination C<highlight><subscript>s</subscript></highlight>, it contains all initial values of the GUI designators. </paragraph>
<paragraph id="P-0092" lvl="0"><number>&lsqb;0092&rsqb;</number> When the GUI application is terminated, no more windows exist, the end combination is empty: C<highlight><subscript>e</subscript></highlight>&equals;( ). </paragraph>
<paragraph id="P-0093" lvl="7"><number>&lsqb;0093&rsqb;</number> Static Structure of a GUI </paragraph>
<paragraph id="P-0094" lvl="0"><number>&lsqb;0094&rsqb;</number> Each window of a GUI can have an unlimited number of so-called &ldquo;child windows&rdquo;. On the other hand, each &ldquo;child window&rdquo; has precisely one &ldquo;parent window&rdquo;, or in the case of a top-level window, no parent window. The father-child relation R between two windows with IDs p and c can be defined as follows: pRc, wherein p is the parent window of c. Cycles such as R&equals;&lcub;(a, b), (b, c), (c, a)&rcub; are not permitted. Thus, the windows of a GUI are arranged hierarchically in the form of a tree. Actually, it is more of a forest than a tree, since several subtrees can exist, which are not connected to each other. </paragraph>
<paragraph id="P-0095" lvl="0"><number>&lsqb;0095&rsqb;</number> The semantic connections of a parent-child relation are as follows: a child can only exist if its father also exists. Likewise, a child can only be activated if the father is also activated. On the other hand, of course, the father can exist without the existence of the child being necessary. Moreover, it is not possible for a child to dynamically alter its father. </paragraph>
<paragraph id="P-0096" lvl="7"><number>&lsqb;0096&rsqb;</number> Behavior of a GUI </paragraph>
<paragraph id="P-0097" lvl="0"><number>&lsqb;0097&rsqb;</number> By the use of combinations, the behavior of a GUI can be expressed as a machine of finite states (state automaton). It must be realized, however, that the number of possible states, even for small GUls, can be very large and thus makes it practically impossible to be represented in an ordinary state transition diagram. For this reason, it is necessary to make certain amplifications to the concept of a state automaton in order to handle this complexity. </paragraph>
<paragraph id="P-0098" lvl="0"><number>&lsqb;0098&rsqb;</number> In the preceding paragraphs, the description of the momentary states of a GUI has been explained. In addition, it is also necessary to describe the changes in state that occur during the running of a GUI. These changes in state are termed transitions (T) and are triggered by a user input or an internal event. A transition is a 3-tuple T&equals;(E, S, &tgr;), which comprises </paragraph>
<paragraph id="P-0099" lvl="2"><number>&lsqb;0099&rsqb;</number> the event E which triggers the transition, </paragraph>
<paragraph id="P-0100" lvl="2"><number>&lsqb;0100&rsqb;</number> a set S of correct (valid) input combinations for this transition, and </paragraph>
<paragraph id="P-0101" lvl="2"><number>&lsqb;0101&rsqb;</number> a function &tgr;(C)&rarr;C, which is defined for each valid input combination. </paragraph>
<paragraph id="P-0102" lvl="0"><number>&lsqb;0102&rsqb;</number> This transforms the input combination into a new combination. </paragraph>
</section>
<section>
<heading lvl="1">EXAMPLE </heading>
<paragraph id="P-0103" lvl="0"><number>&lsqb;0103&rsqb;</number> When the user presses the OK button (event is triggered) and all fields are properly filled (definition of correct input states), the input focus should go back to the first input field (definition of the transformation function). </paragraph>
<paragraph id="P-0104" lvl="0"><number>&lsqb;0104&rsqb;</number> Instead of listing all valid input combinations, it is usually easier to describe the valid set of correct input functions by means of conditions. Accordingly, a combination is valid for a particular transition when all conditions are fulfilled for the transition of the values of the designators in the combination. Otherwise the combination is invalid. Usually not all designators have direct influence on the condition. </paragraph>
</section>
<section>
<heading lvl="1">EXAMPLE </heading>
<paragraph id="P-0105" lvl="0"><number>&lsqb;0105&rsqb;</number> the condition &num;IDOK:$Enabled&num;&equals;TRUE refers only to a single designator of the combination, the other values are irrelevant. Thus, all combinations for which &num;IDOK:$Enabled&num;&equals;TRUE are valid. </paragraph>
<paragraph id="P-0106" lvl="0"><number>&lsqb;0106&rsqb;</number> Likewise, most transition functions do not impact all values of the input combination. Thus, a function can be expressed more easily by the number of elementary value changes which are termed &ldquo;actions&rdquo;. For example, the action SetAffribute(&num;IDOK:$Enabled&num;, TRUE) affects only one designator of the combination. In many cases, the designators depend on each other, which means that when a designator is set at a new value, one or more other designators are also set at a new value. For example, if a window is closed, all of its children are also closed. </paragraph>
<paragraph id="P-0107" lvl="0"><number>&lsqb;0107&rsqb;</number> Special languages are necessary to describe events, conditions and actions. These are explained in detail hereafter. </paragraph>
<paragraph id="P-0108" lvl="7"><number>&lsqb;0108&rsqb;</number> Event Language </paragraph>
<paragraph id="P-0109" lvl="0"><number>&lsqb;0109&rsqb;</number> Each transition is triggered by an event. A transition will then be executed only when the event occurs and all conditions for the transition are fulfilled. Thus, an event can be considered a precondition for a transition. The difference from the other conditions is that events are momentary (they have no duration), while other conditions are present for a particular duration. </paragraph>
<paragraph id="P-0110" lvl="0"><number>&lsqb;0110&rsqb;</number> The events which can occur for a GUI can be divided into two groups: </paragraph>
<paragraph id="P-0111" lvl="2"><number>&lsqb;0111&rsqb;</number> Events which are triggered by a user, for example, by a mouse click or by pressing a key of the keyboard </paragraph>
<paragraph id="P-0112" lvl="2"><number>&lsqb;0112&rsqb;</number> Events which are triggered by the system, such as the signal of a clock or an internal message. </paragraph>
<paragraph id="P-0113" lvl="0"><number>&lsqb;0113&rsqb;</number> Both types depend heavily on the hardware and software of the system being tested, for example, the layout of the keyboard or the operating system. Therefore, it is hardly possible to develop a language which can describe all possible events of a computer system. The language developed for the software used in the context of the invention (IDATG) covers all keyboard and mouse events which are executed by a user on a personal computer under MS Windows&reg;, yet it can be easily adapted to other systems. </paragraph>
<paragraph id="P-0114" lvl="0"><number>&lsqb;0114&rsqb;</number> Each user event refers to a particular window, for which the event is intended. The fundamental syntax for the description of an event is Event/WindowID. For example, &lt;MClickL&gt;/IDOK designates a click of the left mouse button, while the mouse cursor is positioned above the OK button. If no window ID is specified, the software of the invention assumes that the affected window is the one in which the entry focus is located at the moment. (This information is contained in the input combination of the transition.) </paragraph>
<paragraph id="P-0115" lvl="0"><number>&lsqb;0115&rsqb;</number> The event language makes no distinction between upper and lowercase (&lt;MClickL&gt; and &lt;mclickl&gt; mean the same thing). However, it is important to use the correct notation in string constants which occur in the tested application (i.e., &lt;select&ldquo;ListItem&rdquo;&gt; does not mean the same as &lt;select&ldquo;listitem&rdquo;&gt;). A transition without a triggering event may be necessary in rare cases and will be expressed as &lt; &gt;. </paragraph>
<paragraph id="P-0116" lvl="0"><number>&lsqb;0116&rsqb;</number> Events triggered by the keyboard have the following syntax in the invented software: if the key name has a length of more than one character, it must be indicated in angle brackets, for example &lt;Enter&gt;. Groups of keys to be pressed at the same time are enclosed in the same angle brackets and are separated by hyphens, such as &lt;Ctrl-Shift-F10&gt;. </paragraph>
<paragraph id="P-0117" lvl="0"><number>&lsqb;0117&rsqb;</number> A more detailed presentation will not be given here, since it is not very important to the concept of the invention, and only a few other examples shall be given here, namely </paragraph>
<paragraph id="P-0118" lvl="2"><number>&lsqb;0118&rsqb;</number> Functions and cursor keys: </paragraph>
<paragraph id="P-0119" lvl="3"><number>&lsqb;0119&rsqb;</number> &lt;Esc&gt;, &lt;F1&gt;-&lt;F12&gt;, &lt;PrtScr&gt;, &lt;ScrlLock&gt;, &lt;Pause&gt; &lt;Ins&gt;, &lt;Del&gt;, &lt;Home&gt;, &lt;End&gt;, &lt;PgUp&gt;, &lt;PgDn&gt; &lt;Left&gt;, &lt;Right&gt;, &lt;Up&gt;, &lt;Down&gt;</paragraph>
<paragraph id="P-0120" lvl="2"><number>&lsqb;0120&rsqb;</number> important keys of the main keyboard: </paragraph>
<paragraph id="P-0121" lvl="3"><number>&lsqb;0121&rsqb;</number> &lt;Backspace&gt;, &lt;Tab&gt;, &lt;CapsLock&gt;, &lt;Enter&gt;, &lt;Space&gt; &lt;Divide&gt;(/), &lt;Minus&gt;(&minus;), &lt;Greater&gt;(&gt;), &lt;Less&gt;(&lt;) </paragraph>
<paragraph id="P-0122" lvl="2"><number>&lsqb;0122&rsqb;</number> special keys (normally the plain name is enough. If it is important whether the right or left key is pressed, L or R will be added): </paragraph>
<paragraph id="P-0123" lvl="3"><number>&lsqb;0123&rsqb;</number> &lt;Shift&gt;, &lt;ShiftL&gt;, &lt;ShiftR&gt; &lt;Ctrl&gt;, &lt;CtrlL&gt;, &lt;CtrlR&gt; &lt;Alt&gt;, &lt;AltL&gt;, &lt;AltR&gt;, &lt;AltGr&gt; (on German keyboards) &lt;Win&gt;, &lt;WinL&gt;, &lt;WinR&gt;, &lt;Menu&gt; (additional keys, e.g., for Win95/98);  
<table-cwu id="TABLE-US-00001">
<number>1</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217PT" align="center"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Events triggered by the mouse are likewise written in angle brackets:</entry>
</row>
<row><entry namest="1" nameend="1" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="28PT" align="left"/>
<colspec colname="1" colwidth="70PT" align="left"/>
<colspec colname="2" colwidth="119PT" align="left"/>
<tbody valign="top">
<row>
<entry></entry>
<entry>&lt;MClickL&gt;</entry>
<entry>Click with left mouse key</entry>
</row>
<row>
<entry></entry>
<entry>&lt;MClickR&gt;</entry>
<entry>Click with right mouse key</entry>
</row>
<row>
<entry></entry>
<entry>&lt;MDblClickL&gt;</entry>
<entry>Double click with left mouse key</entry>
</row>
<row>
<entry></entry>
<entry>&lt;MDblClickR&gt;</entry>
<entry>Double click with right mouse</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>key</entry>
</row>
<row>
<entry></entry>
<entry>&lt;MPressL&gt;</entry>
<entry>Press and hold down the left</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>mouse key</entry>
</row>
<row>
<entry></entry>
<entry>&lt;MPressR&gt;</entry>
<entry>Press and hold down the right</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>mouse key</entry>
</row>
<row>
<entry></entry>
<entry>&lt;MReleaseL&gt;</entry>
<entry>Release the left mouse key</entry>
</row>
<row>
<entry></entry>
<entry>&lt;MReleaseR&gt;</entry>
<entry>Release the right mouse key</entry>
</row>
<row>
<entry></entry>
<entry>&lt;MMove&gt;</entry>
<entry>Move the mouse</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0124" lvl="7"><number>&lsqb;0124&rsqb;</number> Condition Language </paragraph>
<paragraph id="P-0125" lvl="0"><number>&lsqb;0125&rsqb;</number> Conditions are necessary to define a set of valid input combinations for a transition. Such a set of valid input combinations is defined implicitly by a specifying of certain restrictions on some or all designators in the combination, which limits the set of possible GUI states to those states which are valid for the transition. We shall now briefly discuss the necessary syntax for the description of such conditions. </paragraph>
<paragraph id="P-0126" lvl="0"><number>&lsqb;0126&rsqb;</number> In the software used according to the method of the invention, both upper and lowercase letters are accepted, and spaces can but need not be used between operators and operands. Likewise, brackets can be used, but they are only necessary to alter the priority of the operators. </paragraph>
<paragraph id="P-0127" lvl="0"><number>&lsqb;0127&rsqb;</number> The language obeys the mathematical and logical rules of priority. Expressions are written in &ldquo;infix&rdquo; notation, which means that binary operators stand between their two operands and unary operators stand in front of their operands. Conditions must always yield a Boolean value, since conditions can only be TRUE or FALSE. </paragraph>
<paragraph id="P-0128" lvl="0"><number>&lsqb;0128&rsqb;</number> The language of the software used (IDATG) recognizes four basic types of value, namely:  
<table-cwu id="TABLE-US-00002">
<number>2</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="161PT" align="left"/>
<thead>
<row>
<entry></entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
<entry>NUM</entry>
<entry>an integer value (32 bits)</entry>
</row>
<row>
<entry></entry>
<entry>BOOL</entry>
<entry>a Boolean value, which can be TRUE or FALSE</entry>
</row>
<row>
<entry></entry>
<entry>STRING</entry>
<entry>a string (maximum length &equals; 255 characters)</entry>
</row>
<row>
<entry></entry>
<entry>DATE</entry>
<entry>a valid date in format DD.MM.YYYY</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0129" lvl="0"><number>&lsqb;0129&rsqb;</number> Operators which are accepted by the software can be divided into four classes: </paragraph>
<paragraph id="P-0130" lvl="2"><number>&lsqb;0130&rsqb;</number> Logical operators </paragraph>
<paragraph id="P-0131" lvl="3"><number>&lsqb;0131&rsqb;</number> IDATG accepts the standard operators AND, OR, XOR and NOT. OR signifies an inclusive Or, which yields TRUE if at least one of its operands is TRUE; XOR is an exclusive Or, which yields TRUE when only one operand is TRUE and the other is FALSE. </paragraph>
<paragraph id="P-0132" lvl="2"><number>&lsqb;0132&rsqb;</number> Comparison operators </paragraph>
<paragraph id="P-0133" lvl="3"><number>&lsqb;0133&rsqb;</number> Operands can be compared by using the operators &equals;, &excl;&equals;, &lt;, &gt;, &lt;&equals; and &gt;&equals;. While the last four operators are only permitted for numerical expressions and date entries, the equal (&equals;) and the unequal (&excl;&equals;) signs are used for all data types. The software automatically decides whether a mathematical or a string comparison is being done. </paragraph>
<paragraph id="P-0134" lvl="2"><number>&lsqb;0134&rsqb;</number> Numerical operators </paragraph>
<paragraph id="P-0135" lvl="3"><number>&lsqb;0135&rsqb;</number> The basic operators &plus;, &minus;, * and / can be used. </paragraph>
<paragraph id="P-0136" lvl="2"><number>&lsqb;0136&rsqb;</number> Special operators </paragraph>
<paragraph id="P-0137" lvl="3"><number>&lsqb;0137&rsqb;</number> The operator SYN checks whether the present content of a field corresponds to the specified syntax of same or not. The operator expects the ID of the input field as the argument. For example, if the syntax C2 (2 characters) is defined for the input field IDC_NAME, then the expression SYN &num;IDC_NAME&num; yields TRUE if the field contains, say, &ldquo;ab&rdquo;, and FALSE if it contains &ldquo;abc&rdquo;. </paragraph>
<paragraph id="P-0138" lvl="0"><number>&lsqb;0138&rsqb;</number> Furthermore, there are three different types of operands: </paragraph>
<paragraph id="P-0139" lvl="2"><number>&lsqb;0139&rsqb;</number> Constant values: the notation depends on the type of value. NUM values are written as usual (45, &minus;3), BOOLEAN values can be TRUE or FALSE. STRING values are written between quotation marks (&ldquo;text&rdquo;, &ldquo;Jerry Steiner&rdquo;). A backslash (&bsol;) ensures that the next character is interpreted as text (e.g., &ldquo;te&bsol;&ldquo;xt&rdquo;). DATE values are written as DD.MM.YYYY (e.g., 08.03.1994, 29.02.2000). </paragraph>
<paragraph id="P-0140" lvl="2"><number>&lsqb;0140&rsqb;</number> Designators (variables): designators can be addressed by writing the corresponding name between &lsquo;&num;&rsquo; characters (e.g., &num;IDC_NAME&num;). It is important that each variable have exactly the type which the particular operator requires. For example, it is not possible to compare the designator &num;IDOK:$Enabled&num; (BOOL type) with the constant value 5 (NUM type). </paragraph>
<paragraph id="P-0141" lvl="2"><number>&lsqb;0141&rsqb;</number> Compound expressions: there are no limitations on the complexity of expressions; accordingly, it is possible to use operands which are compound expressions and themselves contain operators. For example, the BOOLEAN expression &lsquo;&num;IDC_NAME&num;&equals;&ldquo;Mr. Holmes&rdquo;&rsquo; can be used with every logical operator and &lsquo;(&num;IDC_AGE&num;*3)&plus;5&rsquo; with every numerical one. </paragraph>
<paragraph id="P-0142" lvl="7"><number>&lsqb;0142&rsqb;</number> Action Language </paragraph>
<paragraph id="P-0143" lvl="0"><number>&lsqb;0143&rsqb;</number> Actions are used to define the transition function which transforms an input combination into an output combination, for which an action editor such as that shown in <cross-reference target="DRAWINGS">FIG. 7</cross-reference> is used. The simplest possibility for specifying such a function is to define a set of fundamental actions, which each alter an individual designator of the combination. For example, SetAttribute(&num;IDOK:$Enabled&num;, TRUE) alters only the Boolean designator &num;IDOK:$Enabled&num;. </paragraph>
<paragraph id="P-0144" lvl="0"><number>&lsqb;0144&rsqb;</number> However, it is often more comfortable to specify more complex actions, which produce a changing of more than one designator. These actions depend on the functionality of the GUI class library used, since they must describe typical processes of the GUI. For example, the action CallDialog(&num;IDD_HUMAN&num;) not only sets the designator &num;IDD_HUMAN:$Exist&num; at TRUE, but also the $Exist designator of all children of the dialogue. In this case, it is obviously more simple to define a single action, instead of defining an individual action for each child window. </paragraph>
<paragraph id="P-0145" lvl="0"><number>&lsqb;0145&rsqb;</number> In addition, it is also important to define the sequence in which the actions are to be executed, since it is possible that two actions will determine the value of one and the same designator. Furthermore, it is possible for one action to depend on an outcome of a previous action. </paragraph>
<paragraph id="P-0146" lvl="0"><number>&lsqb;0146&rsqb;</number> Basically, each action has a distinct name and expects a particular number of arguments, very similar to a function reference in a programming language. Arguments must agree with the prescribed type and can be any expression covered by the condition language. In this way, it is possible to make reference to designators with action arguments or to use complex expressions. Example: SetCheckBox(&num;IDC_PHD&num;, NOT &num;IDC_MBA&num;), SetInputField(&num;IDC_AGE&num;, 5*3&plus;4). </paragraph>
<paragraph id="P-0147" lvl="0"><number>&lsqb;0147&rsqb;</number> In summary, we can say that the following information is necessary for the formal description of a GUI: a set W, which contains all windows of the GUI, a start combination C<highlight><subscript>s</subscript></highlight>, which defines the starting condition for all properties of the windows in W, a binary relation R on W, which describes the mother-child relationship between the windows, and a set of transitions T, which describes the dynamic behavior of the GUI. Thus, a GUI can be formally written as GUI&equals;(W, C<highlight><subscript>s</subscript></highlight>, R, T). </paragraph>
<paragraph id="P-0148" lvl="7"><number>&lsqb;0148&rsqb;</number> Algorithm for Generating the Test Case </paragraph>
<paragraph id="P-0149" lvl="7"><number>&lsqb;0149&rsqb;</number> Test Case Generation </paragraph>
<paragraph id="P-0150" lvl="0"><number>&lsqb;0150&rsqb;</number> The following section discusses a possible application of the formal GUI specification language, namely, test case generation. </paragraph>
<paragraph id="P-0151" lvl="0"><number>&lsqb;0151&rsqb;</number> An ordered sequence of transitions P&equals;(T<highlight><subscript>1</subscript></highlight>, T<highlight><subscript>2</subscript></highlight>, . . . T<highlight><subscript>n</subscript></highlight>) is termed a path (P) when the following conditions are fulfilled: </paragraph>
<paragraph id="P-0152" lvl="0"><number>&lsqb;0152&rsqb;</number> &forall; i&gE;1: i&lE;n &tgr;<highlight><subscript>i</subscript></highlight>(C<highlight><subscript>i</subscript></highlight>)&equals;C<highlight><subscript>i&plus;1</subscript></highlight>: C<highlight><subscript>i </subscript></highlight>&egr; S<highlight><subscript>i </subscript></highlight>(each transition produces a combination representing a valid input for the next transition). C<highlight><subscript>n&plus;1 </subscript></highlight>is the output combination of the path. Thus, the path can also be considered a meta-transition with the function &phgr;(C<highlight><subscript>1</subscript></highlight>)&equals;C<highlight><subscript>n&plus;1</subscript></highlight>&equals;&tgr;<highlight><subscript>n</subscript></highlight>(&tgr;<highlight><subscript>n&equals;1</subscript></highlight>( . . . (&tgr;<highlight><subscript>2</subscript></highlight>(&tgr;<highlight><subscript>1</subscript></highlight>(C<highlight><subscript>1</subscript></highlight>))))). </paragraph>
<paragraph id="P-0153" lvl="0"><number>&lsqb;0153&rsqb;</number> A path is termed a test path (TC) if it begins in the starting state of the GUI and ends in the end state of the GUI, which means that the application is terminated. TC&equals;(T<highlight><subscript>1</subscript></highlight>, T<highlight><subscript>2</subscript></highlight>, . . . T<highlight><subscript>n</subscript></highlight>), C<highlight><subscript>1</subscript></highlight>&equals;C<highlight><subscript>s</subscript></highlight>, C<highlight><subscript>n&plus;1</subscript></highlight>&equals;C<highlight><subscript>e</subscript></highlight>. The goal of the test case generation (TCG) is to find a set of test cases which covers all specific transitions and, thus, the entire GUI. In order to test a special transition, one needs an algorithm to find test cases which contains this special transition. </paragraph>
<paragraph id="P-0154" lvl="7"><number>&lsqb;0154&rsqb;</number> Finding a Test Case for a Particular Transition </paragraph>
<paragraph id="P-0155" lvl="0"><number>&lsqb;0155&rsqb;</number> Two paths need to be found in order to find a test case which contains a special transition T<highlight><subscript>n</subscript></highlight>&equals;(E<highlight><subscript>n</subscript></highlight>, S<highlight><subscript>n</subscript></highlight>, &tgr;<highlight><subscript>n</subscript></highlight>): </paragraph>
<paragraph id="P-0156" lvl="2"><number>&lsqb;0156&rsqb;</number> A path P<highlight><subscript>1</subscript></highlight>&equals;(T<highlight><subscript>1</subscript></highlight>, T<highlight><subscript>2</subscript></highlight>, . . . T<highlight><subscript>n</subscript></highlight>), which begins in the starting state of the GUI and ends in a valid input state for the transition being tested. C<highlight><subscript>1</subscript></highlight>&equals;C<highlight><subscript>s</subscript></highlight>, C<highlight><subscript>n </subscript></highlight>&egr; S<highlight><subscript>n</subscript></highlight>. The path can be empty if C<highlight><subscript>s </subscript></highlight>&egr; S<highlight><subscript>n</subscript></highlight>. </paragraph>
<paragraph id="P-0157" lvl="2"><number>&lsqb;0157&rsqb;</number> A path P<highlight><subscript>2</subscript></highlight>&equals;(T<highlight><subscript>n&plus;1</subscript></highlight>, T<highlight><subscript>n&plus;2</subscript></highlight>, . . . T<highlight><subscript>m</subscript></highlight>), which begins in that state which is generated by the transition being tested, and which ends in the end state of the GUI. C<highlight><subscript>n&plus;1 </subscript></highlight>&egr; S<highlight><subscript>n&plus;1</subscript></highlight>, C<highlight><subscript>m&plus;1</subscript></highlight>&equals;C<highlight><subscript>e</subscript></highlight>. The path is empty if C<highlight><subscript>n&plus;1 </subscript></highlight>&equals;C<highlight><subscript>c</subscript></highlight>. </paragraph>
<paragraph id="P-0158" lvl="0"><number>&lsqb;0158&rsqb;</number> This situation is represented in <cross-reference target="DRAWINGS">FIG. 12</cross-reference>. Thus, the generation algorithm works as follows (in pseudo-code): </paragraph>
<paragraph id="P-0159" lvl="0"><number>&lsqb;0159&rsqb;</number> Function GenerateTC (Input: Transition T<highlight><subscript>n</subscript></highlight>) </paragraph>
<paragraph id="P-0160" lvl="2"><number>&lsqb;0160&rsqb;</number> Initialize the GUI variables corresponding to Cs. Note: the state of the tested GUI is simulated by these variables. </paragraph>
<paragraph id="P-0161" lvl="2"><number>&lsqb;0161&rsqb;</number> Search for the first path P<highlight><subscript>1 </subscript></highlight>by invoking the function SearchPathToTrans(T<highlight><subscript>n</subscript></highlight>, C<highlight><subscript>s</subscript></highlight>) </paragraph>
<paragraph id="P-0162" lvl="2"><number>&lsqb;0162&rsqb;</number> If no path is found, an error is output (inconsistent specification) </paragraph>
<paragraph id="P-0163" lvl="2"><number>&lsqb;0163&rsqb;</number> Search for the second path P<highlight><subscript>2 </subscript></highlight>by invoking the function SearchPathToEnd(C<highlight><subscript>n&plus;1</subscript></highlight>) </paragraph>
<paragraph id="P-0164" lvl="2"><number>&lsqb;0164&rsqb;</number> If no path is found, an error is output (inconsistent specification) </paragraph>
<paragraph id="P-0165" lvl="7"><number>&lsqb;0165&rsqb;</number> Finding a Path to a Particular Transition </paragraph>
<paragraph id="P-0166" lvl="0"><number>&lsqb;0166&rsqb;</number> The function SearchPathToTrans tries to find a path P<highlight><subscript>1 </subscript></highlight>which begins in the starting state of the GUI and ends in a state which permits the execution of the special transition T<highlight><subscript>n</subscript></highlight>. Many graph search algorithms begin from a starting state of the system and try to reach the desired state via random paths. The enormous number of possible combinations and user inputs, however, make it impossible to arrive at an outcome in a reasonable time when using this technique. Thus, one needs an algorithm such that one can systematically achieve a particular state in which all conditions for this state are fulfilled one after the other. </paragraph>
<paragraph id="P-0167" lvl="0"><number>&lsqb;0167&rsqb;</number> Function SearchPath To Trans (Input: Transition T<highlight><subscript>n</subscript></highlight>, present GUI state C<highlight><subscript>i</subscript></highlight>) </paragraph>
<paragraph id="P-0168" lvl="2"><number>&lsqb;0168&rsqb;</number> 1. Determine the set of valid input combinations S<highlight><subscript>n</subscript></highlight>, or in other words, the conditions which must be fulfilled in order to execute T<highlight><subscript>n </subscript></highlight></paragraph>
<paragraph id="P-0169" lvl="2"><number>&lsqb;0169&rsqb;</number> 2. If C<highlight><subscript>i </subscript></highlight>&egr; S<highlight><subscript>n</subscript></highlight>, no path is necessary&equals;&gt;successful completion </paragraph>
<paragraph id="P-0170" lvl="2"><number>&lsqb;0170&rsqb;</number> 3. Search for suitable values for all variables on which the condition is dependent, so that the condition becomes TRUE. This can be accomplished by invoking the function FulfillCondition(S<highlight><subscript>n</subscript></highlight>, TRUE). </paragraph>
<paragraph id="P-0171" lvl="2"><number>&lsqb;0171&rsqb;</number> 4. If no solution is found, an error is output </paragraph>
<paragraph id="P-0172" lvl="2"><number>&lsqb;0172&rsqb;</number> 5. The following is performed for all variables on which the condition is dependent: </paragraph>
<paragraph id="P-0173" lvl="1"><number>&lsqb;0173&rsqb;</number> &lcub;</paragraph>
<paragraph id="P-0174" lvl="2"><number>&lsqb;0174&rsqb;</number> 6. If the present value of the variable agrees with the desired one, the method continues with the next variable </paragraph>
<paragraph id="P-0175" lvl="2"><number>&lsqb;0175&rsqb;</number> 7. Search for a transition T<highlight><subscript>x</subscript></highlight>, which sets the variable at the desired value </paragraph>
<paragraph id="P-0176" lvl="2"><number>&lsqb;0176&rsqb;</number> 8. If no transition is found, backtracking is commenced, returning to the preceding variable </paragraph>
<paragraph id="P-0177" lvl="2"><number>&lsqb;0177&rsqb;</number> 9. Recursive invoking of SearchPath To Trans(T<highlight><subscript>x</subscript></highlight>, C<highlight><subscript>i</subscript></highlight>) in order to find a path to T<highlight><subscript>x </subscript></highlight></paragraph>
<paragraph id="P-0178" lvl="2"><number>&lsqb;0178&rsqb;</number> 10. If no solution is found, search for another transition by jumping back to step 7 </paragraph>
<paragraph id="P-0179" lvl="2"><number>&lsqb;0179&rsqb;</number> 11. Check to see whether the new path alters variables which were already set in an earlier run-through </paragraph>
<paragraph id="P-0180" lvl="2"><number>&lsqb;0180&rsqb;</number> 12. If so, search for a new path by jumping back to step 9 </paragraph>
<paragraph id="P-0181" lvl="2"><number>&lsqb;0181&rsqb;</number> 13.Add the new path to the outcome path, set C<highlight><subscript>i </subscript></highlight>appropriately and continue with the next variable </paragraph>
<paragraph id="P-0182" lvl="1"><number>&lsqb;0182&rsqb;</number> &rcub;</paragraph>
<paragraph id="P-0183" lvl="2"><number>&lsqb;0183&rsqb;</number> 14. If no solution was found, an attempt is made to alter the sequence of the variables or find other suitable variables by jumping back to step 3 </paragraph>
<paragraph id="P-0184" lvl="2"><number>&lsqb;0184&rsqb;</number> 15. Output of the outcome path </paragraph>
<paragraph id="P-0185" lvl="0"><number>&lsqb;0185&rsqb;</number> As can be seen, the algorithm uses backtracking, i.e., returning to an earlier program state if no solution could be found. Furthermore, if the function delivers an unsuitable outcome, the function can be invoked again to output an alternative solution. This can be repeated until no more alternative solutions exist. </paragraph>
<paragraph id="P-0186" lvl="0"><number>&lsqb;0186&rsqb;</number> Another property of the algorithm is its complex recursive structure. Unlike conventional recursive functions, which produce a linear sequence of function references, the structure of the function references in this algorithm resembles a tree, as shown in <cross-reference target="DRAWINGS">FIG. 13</cross-reference>. Each instance of the function starts a recursion for each variable that needs to be set. The recursion ends when no path is required to set the variables, because these variables already have the correct value. The resulting path can be determined by joining together the leaves of the tree from left to right. </paragraph>
<paragraph id="P-0187" lvl="0"><number>&lsqb;0187&rsqb;</number> Backtracking in combination with the treelike recursion structure makes it exceptionally difficult to follow the generation process. For this reason, a logging technique should be used, which writes information about the process into a logfile. </paragraph>
<paragraph id="P-0188" lvl="0"><number>&lsqb;0188&rsqb;</number> Furthermore, suitable measures must be adopted to avoid infinite recursions. First, the maximum recursion depth can be limited with a simple counter. When the limit is reached, the function SearchPath To Trans outputs an error. Secondly, the number of occurrence of a particular transition in a path can be limited. The limit is checked after searching for a transition in step 7. If the limit is reached, the transition is rejected and an alternative is sought. </paragraph>
<paragraph id="P-0189" lvl="7"><number>&lsqb;0189&rsqb;</number> Finding a Path to the End State </paragraph>
<paragraph id="P-0190" lvl="0"><number>&lsqb;0190&rsqb;</number> After SearchPath To Trans has returned a path P<highlight><subscript>1</subscript></highlight>, which begins with the starting state of the GUI and ends with the desired transition T<highlight><subscript>n</subscript></highlight>, it is necessary to find the test case by discovering a path P<highlight><subscript>2 </subscript></highlight>from T<highlight><subscript>n </subscript></highlight>to the end state C<highlight><subscript>e </subscript></highlight>of the GUI. This goal can be achieved by the function SearchPath To End, which is basically a simplified version of SearchPath To Trans. </paragraph>
<paragraph id="P-0191" lvl="0"><number>&lsqb;0191&rsqb;</number> Function SearchPathToEnd (Input: status of the GUI C<highlight><subscript>n&plus;i</subscript></highlight>) </paragraph>
<paragraph id="P-0192" lvl="2"><number>&lsqb;0192&rsqb;</number> 1. If C<highlight><subscript>n&plus;1</subscript></highlight>&equals;C<highlight><subscript>e</subscript></highlight>, no path is necessary&equals;&gt;successful completion </paragraph>
<paragraph id="P-0193" lvl="2"><number>&lsqb;0193&rsqb;</number> 2. Search for a transition T<highlight><subscript>x </subscript></highlight>which ends the application </paragraph>
<paragraph id="P-0194" lvl="2"><number>&lsqb;0194&rsqb;</number> 3. If no transition is found, an error is output (inconsistent specification) </paragraph>
<paragraph id="P-0195" lvl="2"><number>&lsqb;0195&rsqb;</number> 4. Invoke the function SearchPath To Trans(T<highlight><subscript>x</subscript></highlight>, C<highlight><subscript>n&plus;1</subscript></highlight>) to find a path to T<highlight><subscript>x </subscript></highlight></paragraph>
<paragraph id="P-0196" lvl="2"><number>&lsqb;0196&rsqb;</number> 5. If no solution is found, a new transition is sought by jumping back to step 2 </paragraph>
<paragraph id="P-0197" lvl="2"><number>&lsqb;0197&rsqb;</number> 6. Output of the outcome path </paragraph>
<paragraph id="P-0198" lvl="7"><number>&lsqb;0198&rsqb;</number> Fulfillment of a Condition </paragraph>
<paragraph id="P-0199" lvl="0"><number>&lsqb;0199&rsqb;</number> In order to find a path to a particular transition, one needs to know how the condition on which the transition depends can be fulfilled. This means that a suitable value has to be found for all variables occurring in the condition, so that the condition is fulfilled. </paragraph>
<paragraph id="P-0200" lvl="0"><number>&lsqb;0200&rsqb;</number> A condition can be represented as a tree, with operands representing child-nodes of its operators, as is shown for example in <cross-reference target="DRAWINGS">FIG. 14</cross-reference>. Once again, a recursive algorithm which uses backtracking is used to find solutions for this condition tree. </paragraph>
<paragraph id="P-0201" lvl="0"><number>&lsqb;0201&rsqb;</number> The heart of the algorithm is the procedure FulfillCondition(nodes, value). This is called up recursively for each node of the condition tree. The input parameters are the present node and the required value for the subexpression represented by this node. The algorithm can be started by calling up the function FulfillCondition(RootNode, &ldquo;TRUE&rdquo;). Each node tries to furnish the value required of it by requiring suitable values from its child-nodes. Depending on the type of node, different strategies are used to fulfill the desired condition. The recursion ends at the leaf nodes of the tree, which are either constant values or variables. While constant values cannot be changed to fulfill a condition, it is of course possible to assign new values to variables. </paragraph>
<paragraph id="P-0202" lvl="0"><number>&lsqb;0202&rsqb;</number> As an example, take the condition (&num;Age&num;&gt;60) AND (&num;Female&num; XOR &num;Male&num;) for an entry in a data form; this situation is represented by the condition tree in <cross-reference target="DRAWINGS">FIG. 14</cross-reference>. The tree is worked off from top to bottom as follows: </paragraph>
<paragraph id="P-0203" lvl="2"><number>&lsqb;0203&rsqb;</number> The root node &lsquo;AND&rsquo; is invoked with the required value &lsquo;TRUE&rsquo;. In order to fulfill the condition, it likewise requires the value &lsquo;TRUE&rsquo; from its child-nodes. </paragraph>
<paragraph id="P-0204" lvl="2"><number>&lsqb;0204&rsqb;</number> The left child-node &lsquo;&gt;&rsquo; checks whether one of its own child-nodes has a constant value. Since its right successor always returns 60, the only way to fulfill the condition (&num;Age&num;&gt;60) is to require a suitable value (e.g., 70) from its left successor. </paragraph>
<paragraph id="P-0205" lvl="2"><number>&lsqb;0205&rsqb;</number> The nodes &num;Age&num; represents the content of an input field and is now set at the value 70. If this value proves unsuitable in the course of the test case generating, and backtracking is initiated, the parent-node tries the same procedure with other possible values such as 61, 1000, 10000 etc. Only if all these attempts fail does the parent-node also output an error. </paragraph>
<paragraph id="P-0206" lvl="2"><number>&lsqb;0206&rsqb;</number> The node &lsquo;XOR&rsquo; (exclusive or) has two possibilities of fulfilling the condition, since both children-nodes do not have a constant value. First, it attempts to require &lsquo;TRUE&rsquo; from the left node and &lsquo;FALSE&rsquo; from the right branch. If this does not lead to the desired success, the desired values are reversed. </paragraph>
<paragraph id="P-0207" lvl="2"><number>&lsqb;0207&rsqb;</number> The nodes &num;Female&num; and &num;Male&num; represent the values of two check boxes. Very similar to the input field &num;Age&num;, their values are set by the parent-node. </paragraph>
<paragraph id="P-0208" lvl="0"><number>&lsqb;0208&rsqb;</number> If all nodes have succeeded in furnishing the required values, the source-node finally returns a success message to the calling function. </paragraph>
<paragraph id="P-0209" lvl="0"><number>&lsqb;0209&rsqb;</number> If a variable occurs more often than once in a condition, semantic contradictions need to be avoided. Thus, e.g., the value 70 would be invalid in a condition like (&num;Age&num;&gt;60) AND (&num;Age&num;&lt;65). In this case, the following occurs: </paragraph>
<paragraph id="P-0210" lvl="2"><number>&lsqb;0210&rsqb;</number> The value of &num;Age&num; is set at 70 by the first subtree (&num;Age&num;&gt;60) </paragraph>
<paragraph id="P-0211" lvl="2"><number>&lsqb;0211&rsqb;</number> The second subtree (&num;Age&num;&lt;65) determines that the value of &num;Age&num; has been set by another node and that this value is not suitable to fulfill the condition. An error is output. </paragraph>
<paragraph id="P-0212" lvl="2"><number>&lsqb;0212&rsqb;</number> Backtracking is started and the first subtree tries to find a different value (e.g., 61) </paragraph>
<paragraph id="P-0213" lvl="2"><number>&lsqb;0213&rsqb;</number> Now the condition of the second subtree is also fulfilled and the function is successfully ended. </paragraph>
<paragraph id="P-0214" lvl="0"><number>&lsqb;0214&rsqb;</number> Often it is also desirable to generate test cases which do not fulfill certain conditions. The goal of such a procedure is to test how the GUI will respond to wrong user input. This goal can be accomplished in simple fashion by requiring &lsquo;FALSE&rsquo; instead of &lsquo;TRUE&rsquo; from a condition node. </paragraph>
<paragraph id="P-0215" lvl="7"><number>&lsqb;0215&rsqb;</number> Case Study </paragraph>
<paragraph id="P-0216" lvl="0"><number>&lsqb;0216&rsqb;</number> In this section, the methodology for representing a GUI and the subsequent test case generation will now be explained by a simple example. In practice, a large amount of the following described formalism remains hidden from the user, since the invented software provides powerful visual editors for the description of the GUI. We shall assume that it is necessary to specify and test a login window (see <cross-reference target="DRAWINGS">FIG. 15</cross-reference>). </paragraph>
<paragraph id="P-0217" lvl="0"><number>&lsqb;0217&rsqb;</number> At first, we need the definition of the GUI object, i.e., the set of windows: W&equals;&lcub;LoginDialog, Username, Password, OK&rcub;. The abbreviations &lcub;L, U, P, O&rcub; shall be used for these hereafter. In order to describe these windows, the following designators are necessary: </paragraph>
<paragraph id="P-0218" lvl="2"><number>&lsqb;0218&rsqb;</number> For all window types: (Caption &lsqb;String&rsqb;, Enabled &lsqb;Boolean&rsqb;, Visible &lsqb;Boolean&rsqb;, Focused &lsqb;Boolean&rsqb;, coordinates &lsqb;4 integers&rsqb;). </paragraph>
<paragraph id="P-0219" lvl="2"><number>&lsqb;0219&rsqb;</number> In addition, the two input fields U and P have a designator Value &lsqb;String&rsqb;. </paragraph>
<paragraph id="P-0220" lvl="0"><number>&lsqb;0220&rsqb;</number> In the software being used, information about the window layout can be advantageously put in from resource files or using a &ldquo;GUI Spy&rdquo;. </paragraph>
<paragraph id="P-0221" lvl="0"><number>&lsqb;0221&rsqb;</number> As the next step, it is necessary to define the starting status of the GUI by establishing the starting value of each designator. </paragraph>
<paragraph id="P-0222" lvl="2"><number>&lsqb;0222&rsqb;</number> L&equals;(&ldquo;Login&rdquo;, TRUE, TRUE, TRUE, 0,0,139,87) </paragraph>
<paragraph id="P-0223" lvl="2"><number>&lsqb;0223&rsqb;</number> U&equals;(&ldquo;Username&rdquo;, TRUE, TRUE, TRUE, 7,16,132,31,&ldquo;&rdquo;) </paragraph>
<paragraph id="P-0224" lvl="2"><number>&lsqb;0224&rsqb;</number> P&equals;(&ldquo;Password&rdquo;, FALSE, TRUE, FALSE, 7,45,132,60,&ldquo;&rdquo;) </paragraph>
<paragraph id="P-0225" lvl="2"><number>&lsqb;0225&rsqb;</number> O&equals;(&ldquo;OK&rdquo;, FALSE, TRUE, FALSE, 43,67,93,81) </paragraph>
<paragraph id="P-0226" lvl="0"><number>&lsqb;0226&rsqb;</number> As is evident, P and O are initially enabled and the focus is at U (and also at L, which is the child of U). </paragraph>
<paragraph id="P-0227" lvl="0"><number>&lsqb;0227&rsqb;</number> Now a starting combination can be defined by linking up all the designators: </paragraph>
<paragraph id="P-0228" lvl="2"><number>&lsqb;0228&rsqb;</number> C<highlight><subscript>s</subscript></highlight>&equals;(&ldquo;Login&rdquo;, TRUE, . . . 43,67,93,81). </paragraph>
<paragraph id="P-0229" lvl="0"><number>&lsqb;0229&rsqb;</number> As already mentioned above, this information can be imported in the software which we are using or be manually edited with the properties editors. </paragraph>
<paragraph id="P-0230" lvl="0"><number>&lsqb;0230&rsqb;</number> Furthermore, the parent-child relations are also required, which are relatively easy in this &ldquo;little&rdquo; application: L is the mother of U, P and O. R&equals;&lcub;(L, U), (L, P)&lt;(L, O)&rcub;. </paragraph>
<paragraph id="P-0231" lvl="0"><number>&lsqb;0231&rsqb;</number> In the software used, the parent-child relations are visualized and edited in a tree view. </paragraph>
<paragraph id="P-0232" lvl="0"><number>&lsqb;0232&rsqb;</number> Furthermore, it is also necessary to describe the dynamic behavior of the GUI. For this, the transitions which can occur in this sample application are specified. However, a considerable portion of the behavior of the GUI is already defined by the platform used and the window type, and therefore we shall only go into those transitions which represent additional GUI properties that are implemented by a programmer. </paragraph>
<paragraph id="P-0233" lvl="0"><number>&lsqb;0233&rsqb;</number> The first transition T<highlight><subscript>1 </subscript></highlight>describes the behavior of the OK button. The event is a mouse click on OK: </paragraph>
<paragraph id="P-0234" lvl="2"><number>&lsqb;0234&rsqb;</number> E<highlight><subscript>1</subscript></highlight>&equals;&lt;MClickL&gt;/&num;O&num;</paragraph>
<paragraph id="P-0235" lvl="0"><number>&lsqb;0235&rsqb;</number> The set of possible input combinations is defined by the following conditions: </paragraph>
<paragraph id="P-0236" lvl="2"><number>&lsqb;0236&rsqb;</number> S<highlight><subscript>1</subscript></highlight>&equals;&num;O:$Enabled&num; AND &num;O:$Visible&num;</paragraph>
<paragraph id="P-0237" lvl="0"><number>&lsqb;0237&rsqb;</number> The transition is described by the following action: </paragraph>
<paragraph id="P-0238" lvl="2"><number>&lsqb;0238&rsqb;</number> &tgr;<highlight><subscript>1</subscript></highlight>&equals;CloseApplication( ) </paragraph>
<paragraph id="P-0239" lvl="0"><number>&lsqb;0239&rsqb;</number> As can be noticed, the OK button has to be enabled before it can be activated. One must now specify how it can take on this value. </paragraph>
<paragraph id="P-0240" lvl="0"><number>&lsqb;0240&rsqb;</number> The transition T<highlight><subscript>2 </subscript></highlight>describes the &ldquo;Password&rdquo; field: the event is left open, since there is no corresponding event here that would have the meaning &ldquo;enter a value into the field&rdquo;. One could only define an event if a special value were used for P. Yet this implies that only that special value can be entered in the field, which is not the case. In order to solve this problem, namely, the fact that any given value can be entered, the following notation is used: </paragraph>
<paragraph id="P-0241" lvl="2"><number>&lsqb;0241&rsqb;</number> E<highlight><subscript>2</subscript></highlight>&equals;&lt; &gt;</paragraph>
<paragraph id="P-0242" lvl="2"><number>&lsqb;0242&rsqb;</number> S<highlight><subscript>2</subscript></highlight>&equals;&num;P:$Enabled&num; AND &num;P:$Visible&num; AND &num;P&num; &excl;&equals;&ldquo;&rdquo;</paragraph>
<paragraph id="P-0243" lvl="0"><number>&lsqb;0243&rsqb;</number> After a password has been entered, the OK button is enabled: </paragraph>
<paragraph id="P-0244" lvl="2"><number>&lsqb;0244&rsqb;</number> &tgr;<highlight><subscript>2</subscript></highlight>&equals;SetAftribute(&num;O:$Enabled&num;, TRUE) </paragraph>
<paragraph id="P-0245" lvl="0"><number>&lsqb;0245&rsqb;</number> Finally, we also have to specify how P can be enabled: the transition T<highlight><subscript>3 </subscript></highlight>refers to the behavior of the &ldquo;Username&rdquo; field. Again, the event is described indirectly through the following condition: </paragraph>
<paragraph id="P-0246" lvl="2"><number>&lsqb;0246&rsqb;</number> E<highlight><subscript>3</subscript></highlight>&equals;&lt; &gt;</paragraph>
<paragraph id="P-0247" lvl="2"><number>&lsqb;0247&rsqb;</number> S<highlight><subscript>3</subscript></highlight>&equals;&num;U:$Enabled&num; AND &num;U:$Visible&num; AND &num;U&num; &excl;&equals;&ldquo;&rdquo;</paragraph>
<paragraph id="P-0248" lvl="0"><number>&lsqb;0248&rsqb;</number> After a username has been entered, P is enabled: </paragraph>
<paragraph id="P-0249" lvl="2"><number>&lsqb;0249&rsqb;</number> &tgr;<highlight><subscript>3</subscript></highlight>&equals;SetAttribute(&num;P:$Enabled&num;, TRUE) </paragraph>
<paragraph id="P-0250" lvl="0"><number>&lsqb;0250&rsqb;</number> Keep in mind that it is not possible to specify which username and which password will actually be accepted by the application, since this information is saved in a database and changes dynamically. However, sufficient information now exists to generate a sample test case for a GUI. After the generation, the tester can either replace the generated values with actual values from a database, or he can place these values in the specification of the GUI as E<highlight><subscript>2 </subscript></highlight>and E<highlight><subscript>3</subscript></highlight>. </paragraph>
<paragraph id="P-0251" lvl="7"><number>&lsqb;0251&rsqb;</number> Generation of a GUI Test Case </paragraph>
<paragraph id="P-0252" lvl="0"><number>&lsqb;0252&rsqb;</number> The generating of the test case for T<highlight><subscript>1 </subscript></highlight>will now be demonstrated, thereby furnishing an approximate idea of the difficulties even with simple GUIs. The generation is rather cumbersome, even though only a few transitions occur and no backtracking is necessary. <cross-reference target="DRAWINGS">FIG. 16</cross-reference> shows the structure of the function references for easier understanding: </paragraph>
<paragraph id="P-0253" lvl="7"><number>&lsqb;0253&rsqb;</number> Function GenerateTC(T<highlight><subscript>1</subscript></highlight>) </paragraph>
<paragraph id="P-0254" lvl="2"><number>&lsqb;0254&rsqb;</number> Initialize the GUI variables per C<highlight><subscript>s </subscript></highlight></paragraph>
<paragraph id="P-0255" lvl="2"><number>&lsqb;0255&rsqb;</number> Seek the path P<highlight><subscript>1 </subscript></highlight>by calling up the function </paragraph>
<paragraph id="P-0256" lvl="7"><number>&lsqb;0256&rsqb;</number> SearchPathToTrans(T<highlight><subscript>1</subscript></highlight>, C<highlight><subscript>s</subscript></highlight>) </paragraph>
<paragraph id="P-0257" lvl="7"><number>&lsqb;0257&rsqb;</number> Function SearchPathToTrans(T<highlight><subscript>1</subscript></highlight>, C<highlight><subscript>s</subscript></highlight>) </paragraph>
<paragraph id="P-0258" lvl="7"><number>&lsqb;0258&rsqb;</number> &lsqb;Recursion Depth 1&rsqb;</paragraph>
<paragraph id="P-0259" lvl="2"><number>&lsqb;0259&rsqb;</number> 1. Determine the set of permitted input combinations SI &equals;&num;O:$Enabled&num; AND &num;O:$Visible&num;</paragraph>
<paragraph id="P-0260" lvl="2"><number>&lsqb;0260&rsqb;</number> 2. C<highlight><subscript>s </subscript></highlight>&notin; S<highlight><subscript>1</subscript></highlight>&equals;&gt;a path is necessary </paragraph>
<paragraph id="P-0261" lvl="2"><number>&lsqb;0261&rsqb;</number> 3. Seek suitable values for all variables by invoking the function FulfillCondition(S<highlight><subscript>1</subscript></highlight>, TRUE) </paragraph>
<paragraph id="P-0262" lvl="2"><number>&lsqb;0262&rsqb;</number> 4. The function outputs a solution: &num;O:$Enabled&num; and &num;O:$Visible&num; require the value TRUE </paragraph>
<paragraph id="P-0263" lvl="2"><number>&lsqb;0263&rsqb;</number> 5. The following is now performed for both variables: </paragraph>
<paragraph id="P-0264" lvl="1"><number>&lsqb;0264&rsqb;</number> &lcub;</paragraph>
<paragraph id="P-0265" lvl="1"><number>&lsqb;0265&rsqb;</number> (First loop for &num;O:$Enabled&num;): </paragraph>
<paragraph id="P-0266" lvl="2"><number>&lsqb;0266&rsqb;</number> 6. The present value of the variable (FALSE) does not coincide with the necessary value (TRUE)&equals;&gt;a prior path has to be sought, which sets the variable </paragraph>
<paragraph id="P-0267" lvl="2"><number>&lsqb;0267&rsqb;</number> 7. A suitable transition is sought </paragraph>
<paragraph id="P-0268" lvl="2"><number>&lsqb;0268&rsqb;</number> 8. A solution is found: T<highlight><subscript>2 </subscript></highlight>activates O&excl;</paragraph>
<paragraph id="P-0269" lvl="2"><number>&lsqb;0269&rsqb;</number> 9. Recursive invoking of SearchPath To Trans(T<highlight><subscript>2</subscript></highlight>, C<highlight><subscript>s</subscript></highlight>) to find a path to T<highlight><subscript>2 </subscript></highlight></paragraph>
<paragraph id="P-0270" lvl="7"><number>&lsqb;0270&rsqb;</number> Function SearchPathToTrans(T<highlight><subscript>2</subscript></highlight>, C<highlight><subscript>s</subscript></highlight>) </paragraph>
<paragraph id="P-0271" lvl="7"><number>&lsqb;0271&rsqb;</number> &lsqb;Recursion Depth 2&rsqb;</paragraph>
<paragraph id="P-0272" lvl="2"><number>&lsqb;0272&rsqb;</number> 1. Determine the set of permitted input combinations S<highlight><subscript>2</subscript></highlight>&equals;&num;P:$Enabled&num; AND &num;P:$Visible&num; AND &num;P&num; &excl;&equals;&ldquo;&rdquo;</paragraph>
<paragraph id="P-0273" lvl="2"><number>&lsqb;0273&rsqb;</number> 2. C<highlight><subscript>s </subscript></highlight>&notin; S<highlight><subscript>2</subscript></highlight>&equals;&gt;a path is necessary </paragraph>
<paragraph id="P-0274" lvl="2"><number>&lsqb;0274&rsqb;</number> 3. Seek suitable values for all variables by invoking the function FulfillCondition(S<highlight><subscript>2</subscript></highlight>, TRUE) </paragraph>
<paragraph id="P-0275" lvl="2"><number>&lsqb;0275&rsqb;</number> 4. The function outputs a solution: &num;P:$Enabled&num; and &num;P:$Visible&num; require the value TRUE, &num;P&num; has to be set at value &ldquo;x&rdquo;. </paragraph>
<paragraph id="P-0276" lvl="2"><number>&lsqb;0276&rsqb;</number> 5. The following is now performed for all three variables: </paragraph>
<paragraph id="P-0277" lvl="1"><number>&lsqb;0277&rsqb;</number> (First loop for &num;P:$Enabled&num;): </paragraph>
<paragraph id="P-0278" lvl="2"><number>&lsqb;0278&rsqb;</number> 6. The present value of the variable (FALSE) does not coincide with the required value (TRUE)&equals;&gt;a prior path has to be sought, which sets the variable accordingly </paragraph>
<paragraph id="P-0279" lvl="2"><number>&lsqb;0279&rsqb;</number> 7. A suitable transition is sought </paragraph>
<paragraph id="P-0280" lvl="2"><number>&lsqb;0280&rsqb;</number> 8. A solution is found: T<highlight><subscript>3 </subscript></highlight>activates P&excl;</paragraph>
<paragraph id="P-0281" lvl="2"><number>&lsqb;0281&rsqb;</number> 9. Recursive invoking of SearchPath To Trans(T<highlight><subscript>3</subscript></highlight>, C<highlight><subscript>s</subscript></highlight>) to find a path to T<highlight><subscript>3 </subscript></highlight></paragraph>
<paragraph id="P-0282" lvl="7"><number>&lsqb;0282&rsqb;</number> Function SearchPath To Trans(T<highlight><subscript>3</subscript></highlight>, C<highlight><subscript>s</subscript></highlight>) </paragraph>
<paragraph id="P-0283" lvl="7"><number>&lsqb;0283&rsqb;</number> &lsqb;Recursion Depth 3&rsqb;</paragraph>
<paragraph id="P-0284" lvl="2"><number>&lsqb;0284&rsqb;</number> 1. Determine the set of permitted input combinations S<highlight><subscript>3</subscript></highlight>&equals;&num;U:$Enabled&num; AND &num;U:$Visible&num; AND &num;U&num; &excl;&equals;&ldquo;&rdquo;</paragraph>
<paragraph id="P-0285" lvl="2"><number>&lsqb;0285&rsqb;</number> 2. C<highlight><subscript>s </subscript></highlight>&notin; S<highlight><subscript>3</subscript></highlight>&equals;&gt;a path is necessary </paragraph>
<paragraph id="P-0286" lvl="2"><number>&lsqb;0286&rsqb;</number> 3. Seek suitable values for all variables by invoking the function FulfillCondition(S<highlight><subscript>3</subscript></highlight>, TRUE) </paragraph>
<paragraph id="P-0287" lvl="2"><number>&lsqb;0287&rsqb;</number> 4. The function outputs a solution: &num;U:$Enabled&num; and &num;U:$Visible&num; require the value TRUE, &num;U&num; has to be set at value &ldquo;x&rdquo;. </paragraph>
<paragraph id="P-0288" lvl="2"><number>&lsqb;0288&rsqb;</number> 5. The following is now performed for all three variables: </paragraph>
<paragraph id="P-0289" lvl="1"><number>&lsqb;0289&rsqb;</number> &lcub;</paragraph>
<paragraph id="P-0290" lvl="1"><number>&lsqb;0290&rsqb;</number> (First loop for &num;U:$Enabled&num;): </paragraph>
<paragraph id="P-0291" lvl="2"><number>&lsqb;0291&rsqb;</number> 6. The present value of the variable coincides with the required one&equals;&gt;no prior path is necessary, we continue with the next variable </paragraph>
<paragraph id="P-0292" lvl="1"><number>&lsqb;0292&rsqb;</number> (Second loop for &num;U:$Visible&num;): </paragraph>
<paragraph id="P-0293" lvl="2"><number>&lsqb;0293&rsqb;</number> 6. The present value of the variable coincides with the required one&equals;&gt;no prior path is necessary, we continue with the next variable </paragraph>
<paragraph id="P-0294" lvl="1"><number>&lsqb;0294&rsqb;</number> (Third loop for &num;U&num;): </paragraph>
<paragraph id="P-0295" lvl="2"><number>&lsqb;0295&rsqb;</number> 6. The present value of the variable (&ldquo;&rdquo;)does not coincide with the required value (&ldquo;x&rdquo;)&equals;&gt;a prior path has to be sought, which sets the variable accordingly </paragraph>
<paragraph id="P-0296" lvl="2"><number>&lsqb;0296&rsqb;</number> 7. A suitable transition is sought </paragraph>
<paragraph id="P-0297" lvl="2"><number>&lsqb;0297&rsqb;</number> 8. A solution is found: input fields enable the direct manipulation of their content by the user. This transition is designated hereafter as T<highlight><subscript>u</subscript></highlight>. </paragraph>
<paragraph id="P-0298" lvl="2"><number>&lsqb;0298&rsqb;</number> 9. Recursive invoking of SearchPathToTrans(T<highlight><subscript>u</subscript></highlight>, C<highlight><subscript>s</subscript></highlight>) to find a path to T<highlight><subscript>u </subscript></highlight></paragraph>
<paragraph id="P-0299" lvl="7"><number>&lsqb;0299&rsqb;</number> Function SearchPathToTrans(T<highlight><subscript>u</subscript></highlight>, C<highlight><subscript>s</subscript></highlight>) </paragraph>
<paragraph id="P-0300" lvl="7"><number>&lsqb;0300&rsqb;</number> &lsqb;Recursion Depth 4&rsqb;</paragraph>
<paragraph id="P-0301" lvl="2"><number>&lsqb;0301&rsqb;</number> 1. Determine the set of valid input combinations S<highlight><subscript>u</subscript></highlight>&equals;&num;U:$Enabled&num; AND &num;U:$Visible&num;</paragraph>
<paragraph id="P-0302" lvl="2"><number>&lsqb;0302&rsqb;</number> 2. C<highlight><subscript>s </subscript></highlight>&egr; S<highlight><subscript>u</subscript></highlight>&equals;&gt;successful completion </paragraph>
<paragraph id="P-0303" lvl="7"><number>&lsqb;0303&rsqb;</number> &lsqb;Recursion Depth 3 Continued&rsqb;</paragraph>
<paragraph id="P-0304" lvl="2"><number>&lsqb;0304&rsqb;</number> 10. A solution has been found. Solution path&equals;(T<highlight><subscript>u</subscript></highlight>) </paragraph>
<paragraph id="P-0305" lvl="2"><number>&lsqb;0305&rsqb;</number> 11. Check whether the new path changes any variable that was set in a previous loop. </paragraph>
<paragraph id="P-0306" lvl="2"><number>&lsqb;0306&rsqb;</number> 12. &num;U:$Enabled&num; and &num;U:$Visible&num; are not changed by the path </paragraph>
<paragraph id="P-0307" lvl="2"><number>&lsqb;0307&rsqb;</number> 13. Add the new path to the outcome path (which is presently empty), set the present status C<highlight><subscript>i </subscript></highlight>at &tgr;<highlight><subscript>u</subscript></highlight>(C<highlight><subscript>s</subscript></highlight>). Since no further variables need to be set, the loop is exited. </paragraph>
<paragraph id="P-0308" lvl="1"><number>&lsqb;0308&rsqb;</number> &rcub;</paragraph>
<paragraph id="P-0309" lvl="2"><number>&lsqb;0309&rsqb;</number> 14. A solution has been found </paragraph>
<paragraph id="P-0310" lvl="2"><number>&lsqb;0310&rsqb;</number> 15. Output of the outcome path </paragraph>
<paragraph id="P-0311" lvl="7"><number>&lsqb;0311&rsqb;</number> &lsqb;Recursion Depth 2 Continued&rsqb;</paragraph>
<paragraph id="P-0312" lvl="2"><number>&lsqb;0312&rsqb;</number> 10. A solution has been found. Solution path&equals;(T<highlight><subscript>u</subscript></highlight>, T<highlight><subscript>3</subscript></highlight>) </paragraph>
<paragraph id="P-0313" lvl="2"><number>&lsqb;0313&rsqb;</number> 11. Check whether the new path changes any variable that was set in a previous loop. </paragraph>
<paragraph id="P-0314" lvl="2"><number>&lsqb;0314&rsqb;</number> 12. Since this is the first loop, the path is accepted </paragraph>
<paragraph id="P-0315" lvl="2"><number>&lsqb;0315&rsqb;</number> 13.Add the new path to the outcome path (presently empty), set the present status C<highlight><subscript>i </subscript></highlight>at &tgr;<highlight><subscript>3</subscript></highlight>(&tgr;<highlight><subscript>u</subscript></highlight>(C<highlight><subscript>s</subscript></highlight>)). </paragraph>
<paragraph id="P-0316" lvl="1"><number>&lsqb;0316&rsqb;</number> (Second loop for &num;P:$Visible&num;): </paragraph>
<paragraph id="P-0317" lvl="2"><number>&lsqb;0317&rsqb;</number> 6. The present value of the variable coincides with the required one&equals;&gt;no prior path is necessary, we continue with the next variable </paragraph>
<paragraph id="P-0318" lvl="1"><number>&lsqb;0318&rsqb;</number> (Third loop for &num;P&num;): </paragraph>
<paragraph id="P-0319" lvl="2"><number>&lsqb;0319&rsqb;</number> 6. The present value of the variable (&ldquo;&rdquo;)does not coincide with the required value (&ldquo;x&rdquo;)&equals;&gt; a prior path has to be sought, which sets the variable accordingly </paragraph>
<paragraph id="P-0320" lvl="2"><number>&lsqb;0320&rsqb;</number> 7. A suitable transition is sought </paragraph>
<paragraph id="P-0321" lvl="2"><number>&lsqb;0321&rsqb;</number> 8. A solution is found: input fields enable the direct manipulation of their content by the user. This transition is designated hereafter as T<highlight><subscript>p</subscript></highlight>. </paragraph>
<paragraph id="P-0322" lvl="2"><number>&lsqb;0322&rsqb;</number> 9. Recursive invoking of SearchPath To Trans(T<highlight><subscript>p</subscript></highlight>, C<highlight><subscript>i</subscript></highlight>) to find a path to T<highlight><subscript>p </subscript></highlight></paragraph>
<paragraph id="P-0323" lvl="7"><number>&lsqb;0323&rsqb;</number> Function SearchPathToTrans(T<highlight><subscript>p</subscript></highlight>, C<highlight><subscript>i</subscript></highlight>) </paragraph>
<paragraph id="P-0324" lvl="7"><number>&lsqb;0324&rsqb;</number> &lsqb;Recursion Depth 3&rsqb;</paragraph>
<paragraph id="P-0325" lvl="2"><number>&lsqb;0325&rsqb;</number> 1. Determine the set of valid input combinations S<highlight><subscript>p </subscript></highlight>&num;P:$Enabled&num; AND &num;P:$Visible&num;</paragraph>
<paragraph id="P-0326" lvl="2"><number>&lsqb;0326&rsqb;</number> 2. C<highlight><subscript>i </subscript></highlight>&egr; S<highlight><subscript>p</subscript></highlight>&equals;&gt;successful completion </paragraph>
<paragraph id="P-0327" lvl="7"><number>&lsqb;0327&rsqb;</number> &lsqb;Recursion Depth 2 Continued&rsqb;</paragraph>
<paragraph id="P-0328" lvl="2"><number>&lsqb;0328&rsqb;</number> 10. A solution has been found. Solution path (T<highlight><subscript>p</subscript></highlight>) </paragraph>
<paragraph id="P-0329" lvl="2"><number>&lsqb;0329&rsqb;</number> 11. Check whether the new path changes any variable that was set in a previous loop. </paragraph>
<paragraph id="P-0330" lvl="2"><number>&lsqb;0330&rsqb;</number> 12. &num;P:$Enabled&num; and &num;P:$Visible&num; remain unchanged by the path </paragraph>
<paragraph id="P-0331" lvl="2"><number>&lsqb;0331&rsqb;</number> 13.Add the new path to the outcome path (Tu, T<highlight><subscript>3</subscript></highlight>), set the present status C<highlight><subscript>i </subscript></highlight>at &tgr;<highlight><subscript>p</subscript></highlight>(&tgr;<highlight><subscript>3</subscript></highlight>(&tgr;<highlight><subscript>u</subscript></highlight>(C<highlight><subscript>s</subscript></highlight>))). Since no more variables are present, the loop is exited. </paragraph>
<paragraph id="P-0332" lvl="1"><number>&lsqb;0332&rsqb;</number> &rcub;</paragraph>
<paragraph id="P-0333" lvl="2"><number>&lsqb;0333&rsqb;</number> 14.A solution has been found </paragraph>
<paragraph id="P-0334" lvl="2"><number>&lsqb;0334&rsqb;</number> 15. Output of the outcome path </paragraph>
<paragraph id="P-0335" lvl="7"><number>&lsqb;0335&rsqb;</number> &lsqb;Recursion Depth 1 Continued&rsqb;</paragraph>
<paragraph id="P-0336" lvl="2"><number>&lsqb;0336&rsqb;</number> 10.A solution has been found. Solution path&equals;(T<highlight><subscript>u</subscript></highlight>, T<highlight><subscript>3</subscript></highlight>, T<highlight><subscript>p</subscript></highlight>, T<highlight><subscript>2</subscript></highlight>) </paragraph>
<paragraph id="P-0337" lvl="2"><number>&lsqb;0337&rsqb;</number> 11. Check whether the new path changes any variable that was set in a previous loop. </paragraph>
<paragraph id="P-0338" lvl="2"><number>&lsqb;0338&rsqb;</number> 12. Since this is the first loop, the path is accepted </paragraph>
<paragraph id="P-0339" lvl="2"><number>&lsqb;0339&rsqb;</number> 13.Add the new path to the outcome path, set the present status C<highlight><subscript>i </subscript></highlight>at &tgr;<highlight><subscript>2</subscript></highlight>(&tgr;<highlight><subscript>p</subscript></highlight>(&tgr;<highlight><subscript>3</subscript></highlight>(&tgr;<highlight><subscript>u</subscript></highlight>(C<highlight><subscript>s</subscript></highlight>)))) </paragraph>
<paragraph id="P-0340" lvl="1"><number>&lsqb;0340&rsqb;</number> (Second loop for &num;O:$Visible&num;): </paragraph>
<paragraph id="P-0341" lvl="2"><number>&lsqb;0341&rsqb;</number> 6. The present value of the variable coincides with the required one &equals;&gt; no prior path is necessary, we continue with the next variable. </paragraph>
<paragraph id="P-0342" lvl="1"><number>&lsqb;0342&rsqb;</number> &rcub;</paragraph>
<paragraph id="P-0343" lvl="2"><number>&lsqb;0343&rsqb;</number> 14.A solution has been found </paragraph>
<paragraph id="P-0344" lvl="2"><number>&lsqb;0344&rsqb;</number> 15. Output of the outcome path </paragraph>
<paragraph id="P-0345" lvl="7"><number>&lsqb;0345&rsqb;</number> &lsqb;Function GenerateTC Continued&rsqb;</paragraph>
<paragraph id="P-0346" lvl="0"><number>&lsqb;0346&rsqb;</number> A solution has been found. Solution path P<highlight><subscript>1</subscript></highlight>&equals;(T<highlight><subscript>u</subscript></highlight>, T<highlight><subscript>3</subscript></highlight>, T<highlight><subscript>p</subscript></highlight>, T<highlight><subscript>2</subscript></highlight>, T<highlight><subscript>1</subscript></highlight>) Seek the path P<highlight><subscript>2 </subscript></highlight>by invoking the function </paragraph>
<paragraph id="P-0347" lvl="7"><number>&lsqb;0347&rsqb;</number> SearchPathToEnd(&tgr;<highlight><subscript>1</subscript></highlight>(&tgr;<highlight><subscript>2</subscript></highlight>(&tgr;<highlight><subscript>p</subscript></highlight>(&tgr;<highlight><subscript>3</subscript></highlight>(&tgr;<highlight><subscript>u</subscript></highlight>(C<highlight><subscript>s</subscript></highlight>)))))) </paragraph>
<paragraph id="P-0348" lvl="7"><number>&lsqb;0348&rsqb;</number> Function SearchPathToEnd(&tgr;<highlight><subscript>1</subscript></highlight>(&tgr;<highlight><subscript>2</subscript></highlight>(&tgr;<highlight><subscript>p</subscript></highlight>(&tgr;<highlight><subscript>3</subscript></highlight>(&tgr;<highlight><subscript>u</subscript></highlight>(C<highlight><subscript>s</subscript></highlight>)))))) </paragraph>
<paragraph id="P-0349" lvl="0"><number>&lsqb;0349&rsqb;</number> Successful completion, since the input combination&equals;C<highlight><subscript>e </subscript></highlight>(the last transition T<highlight><subscript>1 </subscript></highlight>closes the application) </paragraph>
<paragraph id="P-0350" lvl="7"><number>&lsqb;0350&rsqb;</number> &lsqb;Function GenerateTC Continued&rsqb;</paragraph>
<paragraph id="P-0351" lvl="0"><number>&lsqb;0351&rsqb;</number> A solution has been found. Solution path P<highlight><subscript>2</subscript></highlight>&equals;( ) Output of the entire test case&equals;(T<highlight><subscript>u</subscript></highlight>, T<highlight><subscript>3</subscript></highlight>, T<highlight><subscript>p</subscript></highlight>, T<highlight><subscript>2</subscript></highlight>, T<highlight><subscript>1</subscript></highlight>) </paragraph>
<paragraph id="P-0352" lvl="0"><number>&lsqb;0352&rsqb;</number> The entire test case is now ready: </paragraph>
<paragraph id="P-0353" lvl="2"><number>&lsqb;0353&rsqb;</number> 1. Enter the username &ldquo;x&rdquo;, thereby activating the field &ldquo;password&rdquo;</paragraph>
<paragraph id="P-0354" lvl="2"><number>&lsqb;0354&rsqb;</number> 2. Enter the password &ldquo;x&rdquo;, thereby activating the OK button </paragraph>
<paragraph id="P-0355" lvl="2"><number>&lsqb;0355&rsqb;</number> 3. Press the OK button, thereby closing the application </paragraph>
<paragraph id="P-0356" lvl="7"><number>&lsqb;0356&rsqb;</number> Concluding Remarks </paragraph>
<paragraph id="P-0357" lvl="0"><number>&lsqb;0357&rsqb;</number> As compared to other algorithms for test case generation, the algorithm presented here is much more efficient. For example, there are solutions in existence based on a Prolog algorithm. This algorithm carries out a recursive search for a path which leads to a transition. However, the search is conducted rather aimlessly, which means that correct paths are only found by accident. Furthermore, the recursion depth cannot be restricted by the user, which leads to very long processing time and often even ends in infinite loops. This Prolog-based algorithm is therefore suitable mainly for small, command line-oriented user interfaces in which the number of possible user actions is very limited. However, this method is not suitable for modern GUIs. </paragraph>
<paragraph id="P-0358" lvl="0"><number>&lsqb;0358&rsqb;</number> In contrast, the present method according to the invention and the software based on it not only automatically determines the necessary values for the GUI, but also attempts to set these values systematically, one after the other. The maximum recursion depth can be controlled by the user, and infinite loops are impossible. </paragraph>
<paragraph id="P-0359" lvl="0"><number>&lsqb;0359&rsqb;</number> The main strength of the invented method and the algorithm derived from it is that it does not search for random paths, and then check to see whether they solve the given problem, but instead it first determines how a correct solution will appear, and only then searches for a way to find this solution. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method for automated testing of software, which has a graphic user interface, wherein a test case generator software which can be executed on a data processing device is used, by means of which test cases are generated and these are checked with a software &lsqb;program&rsqb; for automatic test running on a data processing device, characterized in that 
<claim-text>a) using at least one editor at least the dynamic and the semantic behavior of the user interface of the software is specified, the editor used being a graphic editor, and </claim-text>
<claim-text>b) test cases are generated by the test case generator software by means of the thus specified behavior of the user interface and </claim-text>
<claim-text>c) they are then executed directly or in a later step by the software for automatic test running. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further characterized in that static information on the user interface is entered by the editor prior to step a). </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, further characterized in that the static information is entered from a resource file. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, further characterized in that the static information is entered by means of a monitor screen analysis software. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method according to one of <dependent-claim-reference depends_on="CLM-00002">claims 2</dependent-claim-reference> to <dependent-claim-reference depends_on="CLM-00004">4</dependent-claim-reference>, further characterized in that the static information comprises at least a layout and/or attribute of the elements of the graphic user interface. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method according to one of <dependent-claim-reference depends_on="CLM-00002">claims 2</dependent-claim-reference> to <dependent-claim-reference depends_on="CLM-00005">5</dependent-claim-reference>, further characterized in that the static information is amplified by a user in terms of the layout and/or the attributes. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The method according to one of <dependent-claim-reference depends_on="CLM-00001">claims 1</dependent-claim-reference> to <dependent-claim-reference depends_on="CLM-00006">6</dependent-claim-reference>, further characterized in that the dynamic behavior of the software/user interface is specified by entering status transitions. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference>, further characterized in that the status transitions are represented by graphic symbols. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference> or <highlight><bold>8</bold></highlight>, further characterized in that the status transitions are associated with semantic conditions. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The method according to one of <dependent-claim-reference depends_on="CLM-00007">claims 7</dependent-claim-reference> to <dependent-claim-reference depends_on="CLM-00009">9</dependent-claim-reference>, further characterized in that the status transitions are associated with syntactical conditions. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The method according to one of <dependent-claim-reference depends_on="CLM-00001">claims 1</dependent-claim-reference> to <dependent-claim-reference depends_on="CLM-00010">10</dependent-claim-reference>, further characterized in that all elements of the graphic user interface are addressed at least once by the test case generator software. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The method according to one of <dependent-claim-reference depends_on="CLM-00009">claims 9</dependent-claim-reference> to <dependent-claim-reference depends_on="CLM-00011">11</dependent-claim-reference>, further characterized in that all status transitions dependent upon semantic and/or syntactical conditions are covered by the test case generator software with at least one correct and at least one wrong transition value. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. A method for testing of software with a graphic user interface (GUI), wherein test cases are checked with a software for automatic test running on a data processing device, which are generated with a test case generator software, wherein to test a transition (T<highlight><subscript>n</subscript></highlight>) between two states (C<highlight><subscript>n</subscript></highlight>, C<highlight><subscript>n&plus;1</subscript></highlight>) of the user interface (GUI) of the software being tested at least one test case (TC) is generated, which contains the corresponding transition (T<highlight><subscript>n</subscript></highlight>), characterized in that to generate the at least one test case (TC) 
<claim-text>a) a first path (P<highlight><subscript>1</subscript></highlight>) from transitions (T<highlight><subscript>1</subscript></highlight>, T<highlight><subscript>2</subscript></highlight>, . . . T<highlight><subscript>n&equals;1</subscript></highlight>) is generated, which starts in a starting state (C<highlight><subscript>s</subscript></highlight>) of the user interface (GUI) and ends in an intermediate state (C<highlight><subscript>n</subscript></highlight>), the intermediate state (C<highlight><subscript>n</subscript></highlight>) being a state which fulfills all necessary input conditions (C<highlight><subscript>n </subscript></highlight>&egr; S<highlight><subscript>n</subscript></highlight>) for the transition (T<highlight><subscript>n</subscript></highlight>) being checked, and </claim-text>
<claim-text>b) at least one additional path (P<highlight><subscript>2</subscript></highlight>) from transitions (T<highlight><subscript>n&plus;1</subscript></highlight>, T<highlight><subscript>n&plus;2</subscript></highlight>, . . . T<highlight><subscript>m</subscript></highlight>) is generated, which begins in the state (C<highlight><subscript>n&plus;1</subscript></highlight>) generated by the transition (T<highlight><subscript>n</subscript></highlight>) being tested and ends in the end state (C<highlight><subscript>e</subscript></highlight>) of the graphic user interface (GUI), and </claim-text>
<claim-text>c) the two paths (P<highlight><subscript>1</subscript></highlight>, P<highlight><subscript>2</subscript></highlight>) are joined together by the transition (T<highlight><subscript>n</subscript></highlight>). </claim-text>
</claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. A method according to <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference>, further characterized in that the test case (TC) is stored in a test case database. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. A method for determining a path (P<highlight><subscript>x</subscript></highlight>) to a given transition in an expanded state diagram, characterized in that 
<claim-text>a) at least one set of permitted input conditions (S<highlight><subscript>n</subscript></highlight>) is determined, for which the transition being tested (T<highlight><subscript>n</subscript></highlight>) is executable, </claim-text>
<claim-text>b) suitable values are determined for all variables on which the input conditions (S<highlight><subscript>n</subscript></highlight>) are dependent, so that all input conditions are fulfilled (S<highlight><subscript>n</subscript></highlight>&equals;TRUE), and for each variable on which the condition (S<highlight><subscript>n</subscript></highlight>) is dependent, starting with a first variable </claim-text>
<claim-text>c) at least one transition (T<highlight><subscript>x</subscript></highlight>) is sought, which sets the variable at the desired value, then the state (C<highlight><subscript>i</subscript></highlight>) of the state diagram is changed to a value corresponding to the value of the altered variable and </claim-text>
<claim-text>d) step c) is carried out for the next variable of condition (S<highlight><subscript>n</subscript></highlight>). </claim-text>
</claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference>, further characterized in that the path (P<highlight><subscript>x</subscript></highlight>) is determined by invoking a search function SearchPathToTrans (T<highlight><subscript>x</subscript></highlight>, C<highlight><subscript>i</subscript></highlight>)). </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference> or <highlight><bold>16</bold></highlight>, further characterized in that, if the present status (C<highlight><subscript>i</subscript></highlight>) of the state diagram coincides with a set of permitted input conditions (C<highlight><subscript>n </subscript></highlight>&egr; S<highlight><subscript>n</subscript></highlight>), no path (P<highlight><subscript>x</subscript></highlight>) is generated. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The method according to one of <dependent-claim-reference depends_on="CLM-00015">claims 15</dependent-claim-reference> to <dependent-claim-reference depends_on="CLM-00017">17</dependent-claim-reference>, further characterized in that the variables have a predeterminable sequence and the variables of step c) and d) are worked off in a given sequence. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The method according to one of <dependent-claim-reference depends_on="CLM-00015">claims 15</dependent-claim-reference> to <dependent-claim-reference depends_on="CLM-00018">18</dependent-claim-reference>, further characterized in that, when the value of one variable coincides with the desired value in step c), the method continues with the next variable. </claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The method according to one of <dependent-claim-reference depends_on="CLM-00015">claims 15</dependent-claim-reference> to <dependent-claim-reference depends_on="CLM-00019">19</dependent-claim-reference>, further characterized in that an error is output &lsqb;when&rsqb; no suitable values are found in step c). </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The method according to one of <dependent-claim-reference depends_on="CLM-00015">claims 15</dependent-claim-reference> to <dependent-claim-reference depends_on="CLM-00019">19</dependent-claim-reference>, further characterized in that, if no transition (T<highlight><subscript>x</subscript></highlight>) is found for a variable, the method returns at least to the immediately preceding variable, generates a new transition for it, and then seeks another transition for the variable after step c). </claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The method according to one of <dependent-claim-reference depends_on="CLM-00015">claims 15</dependent-claim-reference> to <dependent-claim-reference depends_on="CLM-00021">21</dependent-claim-reference>, further characterized in that a path is determined for each transition (T<highlight><subscript>x</subscript></highlight>). </claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. Method per <dependent-claim-reference depends_on="CLM-00022">claim 22</dependent-claim-reference>, further characterized in that the path is determined by recursive invoking of the search function (SearchPathToTranse (T<highlight><subscript>x</subscript></highlight>, C<highlight><subscript>i</subscript></highlight>)). </claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The method according to <dependent-claim-reference depends_on="CLM-00022">claim 22</dependent-claim-reference> or <highlight><bold>23</bold></highlight>, further characterized in that a different transition (T<highlight><subscript>x</subscript></highlight>&prime;) is determined in the event that no path is found for the transition (T<highlight><subscript>x</subscript></highlight>). </claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. The method according to one of <dependent-claim-reference depends_on="CLM-00022">claims 22</dependent-claim-reference> to <dependent-claim-reference depends_on="CLM-00024">24</dependent-claim-reference>, further characterized in that, if a path is found, the method checks whether one or more variables already set at a desired value are changed by the path. </claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. The method according to claims <highlight><bold>25</bold></highlight>, further characterized in that, if at least one variable is changed by a path, a new path for the transition (T<highlight><subscript>x</subscript></highlight>) is sought. </claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. The method according to one of <dependent-claim-reference depends_on="CLM-00016">claims 16</dependent-claim-reference> to <dependent-claim-reference depends_on="CLM-00026">26</dependent-claim-reference>, further characterized in that, if a solution is not found, the sequence for working off the variables is modified. </claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. The method according to one of <dependent-claim-reference depends_on="CLM-00016">claims 16</dependent-claim-reference> to <dependent-claim-reference depends_on="CLM-00027">27</dependent-claim-reference>, further characterized in that, if a solution is not found, different variables are sought in step b). </claim-text>
</claim>
<claim id="CLM-00029">
<claim-text><highlight><bold>29</bold></highlight>. The method according to one of <dependent-claim-reference depends_on="CLM-00016">claims 16</dependent-claim-reference> to <dependent-claim-reference depends_on="CLM-00028">28</dependent-claim-reference>, further characterized in that a path when determined is added to an outcome path and the outcome path is output after all paths have been added. </claim-text>
</claim>
<claim id="CLM-00030">
<claim-text><highlight><bold>30</bold></highlight>. The method according to one of <dependent-claim-reference depends_on="CLM-00016">claims 16</dependent-claim-reference> to <dependent-claim-reference depends_on="CLM-00029">29</dependent-claim-reference>, further characterized in that, to determine a path, (P<highlight><subscript>2</subscript></highlight>) to an end state of the status diagram, a transition (T<highlight><subscript>y</subscript></highlight>) is sought, which immediately ends the application, and a path to the transition (T<highlight><subscript>y</subscript></highlight>) is sought starting from a present state (C<highlight><subscript>n&plus;1</subscript></highlight>) of the status diagram. </claim-text>
</claim>
<claim id="CLM-00031">
<claim-text><highlight><bold>31</bold></highlight>. The method according to claim <highlight><bold>30</bold></highlight>, further characterized in that, if the present state of the application is the end state (C<highlight><subscript>n&plus;1</subscript></highlight>&equals;C<highlight><subscript>e</subscript></highlight>), no path is sought.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>1</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005413A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005413A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005413A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005413A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005413A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005413A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030005413A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030005413A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
