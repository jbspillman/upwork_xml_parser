<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005353A1-20030102-M00001.NB SYSTEM "US20030005353A1-20030102-M00001.NB" NDATA NB>
<!ENTITY US20030005353A1-20030102-M00001.TIF SYSTEM "US20030005353A1-20030102-M00001.TIF" NDATA TIF>
<!ENTITY US20030005353A1-20030102-M00002.NB SYSTEM "US20030005353A1-20030102-M00002.NB" NDATA NB>
<!ENTITY US20030005353A1-20030102-M00002.TIF SYSTEM "US20030005353A1-20030102-M00002.TIF" NDATA TIF>
<!ENTITY US20030005353A1-20030102-M00003.NB SYSTEM "US20030005353A1-20030102-M00003.NB" NDATA NB>
<!ENTITY US20030005353A1-20030102-M00003.TIF SYSTEM "US20030005353A1-20030102-M00003.TIF" NDATA TIF>
<!ENTITY US20030005353A1-20030102-D00000.TIF SYSTEM "US20030005353A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005353A1-20030102-D00001.TIF SYSTEM "US20030005353A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005353A1-20030102-D00002.TIF SYSTEM "US20030005353A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005353A1-20030102-D00003.TIF SYSTEM "US20030005353A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005353A1-20030102-D00004.TIF SYSTEM "US20030005353A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005353A1-20030102-D00005.TIF SYSTEM "US20030005353A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030005353A1-20030102-D00006.TIF SYSTEM "US20030005353A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030005353A1-20030102-D00007.TIF SYSTEM "US20030005353A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030005353A1-20030102-D00008.TIF SYSTEM "US20030005353A1-20030102-D00008.TIF" NDATA TIF>
<!ENTITY US20030005353A1-20030102-D00009.TIF SYSTEM "US20030005353A1-20030102-D00009.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005353</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10160640</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20020531</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F012/16</ipc>
</classification-ipc-primary>
<classification-ipc-secondary>
<ipc>G11C029/00</ipc>
</classification-ipc-secondary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>714</class>
<subclass>005000</subclass>
</uspc>
</classification-us-primary>
<classification-us-secondary>
<uspc>
<class>714</class>
<subclass>723000</subclass>
</uspc>
</classification-us-secondary>
</classification-us>
<title-of-invention>Methods and apparatus for storing memory test information</title-of-invention>
</technical-information>
<continuity-data>
<non-provisional-of-provisional>
<document-id>
<doc-number>60296789</doc-number>
<document-date>20010608</document-date>
<country-code>US</country-code>
</document-id>
</non-provisional-of-provisional>
</continuity-data>
<inventors>
<first-named-inventor>
<name>
<given-name>Michael</given-name>
<middle-name>A.</middle-name>
<family-name>Mullins</family-name>
</name>
<residence>
<residence-us>
<city>Durham</city>
<state>NC</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Anthony</given-name>
<middle-name>J.</middle-name>
<family-name>Sauvageau</family-name>
</name>
<residence>
<residence-us>
<city>Raleigh</city>
<state>NC</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>Michael G. Savage, Esquire</name-1>
<name-2>BURNS, DOANE, SWECKER &amp; MATHIS, L.L.P.</name-2>
<address>
<address-1>P.O. Box 1404</address-1>
<city>Alexandria</city>
<state>VA</state>
<postalcode>22313-1404</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">Methods and apparatus for storing memory test information are presented. The method includes the steps of storing a portion of information related to locations and numbers of failed memory cells detected while testing memory, and updating the stored information as failed memory cells are detected to indicate a first type of memory spare is to be assigned to repair a failed memory cell, a second complementary type of memory spare is to be assigned to repair the failed memory cell, or the memory is not repairable. The first type of memory spare corresponds to one of a row and a column portion of memory and the second complementary type of memory spare corresponds to the other of the row and column portions of memory. </paragraph>
</subdoc-abstract>
<subdoc-description>
<cross-reference-to-related-applications>
<heading lvl="1">RELATED APPLICATIONS </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> This application claims priority under 35 U.S.C. &sect; 119(e) to U.S. patent application Ser. No. 60/296,789, entitled &ldquo;Error Storage&rdquo;, filed on Jun. 8, 2001, the entire content of which is hereby incorporated by reference.</paragraph>
</cross-reference-to-related-applications>
<summary-of-invention>
<section>
<heading lvl="1">BACKGROUND </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> What is described are methods and apparatus for storing memory test information. In particular, methods and apparatus for storing memory test information of memory having redundant memory circuitry are presented. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> Conventional memory testing involves both an identification of all failed memory addresses in a memory array and an identification of which bit(s) of those memory addresses have failed. A typical memory test involves writing various data patterns into a memory, then reading and comparing the output of the memory with expected values or patterns. Mismatches between expected and actual read memory values are stored in an external memory map, typically located in the memory tester itself. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> After all of the test patterns have been executed and the failed addresses (and bits) have been identified and stored, the tester may then perform a repair analysis on the stored error data to determine which failed address rows&apos; and/or columns&apos; (or I/Os) bits (or cells) will need to be replaced with available redundant (or spare) memory cells to make the memory fully operational. The failed memory information is typically analyzed at the end of all of the memory testing. This allows the repair algorithm to take all of the failed memory information into consideration in order to determine an optimal repair configuration that maximizes the operation of the memory and that uses the redundant memory cells in the most efficient manner. In addition, by taking all failed memory information into consideration at one time, certain un-repairable memory conditions may be identified early, and the memory discarded, before wasting valuable test and repair time on the un-repairable situation. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> Limitations associated with most conventional testers require that the repair information be generated and used dynamically. This can reduce the overall memory yield by using the redundant memory cells inefficiently. These limitations have also made memory testing a most expensive and time consuming process in the development of faster and denser memory. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> For example, conventional memory testers typically have a relatively slower processing clock speed than the operating frequency of the memory cells that they are used to test. The relatively slower clock speed makes it impossible to determine whether the memory under test will operate correctly at normal operating speeds. Also, collecting error information at the normal operating speed is not possible using these slower conventional testers. Consequently, the tester must be capable of storing large amounts of error data and then analyzing this large amount of data in a repair algorithm that is executed &ldquo;off line&rdquo;. With conventional testers, the error memory must be as large as the total expected number of failed bits. Moreover, as memory densities continue to increase, the already limited tester memory must also increase and the processing power of the tester must be increased in order to be able to process more complex repair algorithm solutions. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> Another limitation associated with conventional testers is their typical limited I/O capability. As memory become more dense, the number of I/Os needed to test the memory must also increase. Testers that are I/O limited will not be able to test the entire memory at one time, requiring that the test program be partitioned into several smaller tests. The partitioning of the memory test leads to an overall increased test time, which contributes greatly to the costs associated with memory manufacture. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> Memory designers have utilized built-in-self-test (or BIST) techniques to address some of these concerns. With BIST, a pattern generator for testing the memory is fabricated on the same semiconductor chip (or wafer) as the memory itself. This allows the BIST circuitry to test the memory &ldquo;at speed&rdquo;, eliminating the concerns of failing to detect errors as a result of testing memory at sub-operating speeds. In addition, BIST circuitry addresses the concerns associated with today&apos;s testers being I/O limited. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> Still, limitations exist with conventional BIST techniques. For example, large amounts of error memory must still be incorporated into the BIST circuitry in order to store the failed memory information. Also, additional storage and processor resources must be incorporated into the memory to perform the repair algorithm processing. Because of space and processor limitations, only limited amounts of error storage and repair code can integrated into the BIST design. Consequently, conventional BIST techniques continue to use a &ldquo;snapshot approach&rdquo; for detecting failed memory locations. This requires that the repair algorithm process failed memory information &ldquo;on the fly&rdquo;, which, as discussed above, leads to an inefficient use of the redundant memory cells included on the memory chip. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> Accordingly, there is a need for improved techniques for storing the failed memory information generated from memory testing that will relieve the error storage requirements placed on the tester and that will reduce the complexity of the repair algorithm to a much simpler task. In particular, there is a need for improved techniques for storing only that failed memory information that is necessary to completely analyze and generate the repair information. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY </heading>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> Accordingly, one object is to provide for on-chip storage of all failed memory information in an efficient manner. Another object is to provide for at-speed storage of all failed memory information. Yet another object is to support the testing of memory having a large number of I/O bus memory. Still another object is to detect certain un-repairable memory failure conditions before initiating a repair algorithm. Another object is to reduce the complexity of the repair algorithm itself. These objects are addressed by methods and apparatus to compact information relating to failed memory locations with a memory. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> According to one aspect, a method for storing memory test information includes the step of storing a portion of information related to locations and numbers of failed memory cells detected while testing memory. The stored information is updated as failed memory cells are detected to indicate a first type of memory spare is to be assigned to repair a failed memory cell, a second complementary type of memory spare is to be assigned to repair the failed memory cell, or the memory is not repairable. The first type of memory spare corresponds to one of a row and a column portion of memory and the second complementary type of memory spare corresponds to the other of the row and column portions of memory. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> According to a related aspect, the stored information is updated to indicate the type of memory spare to be assigned to repair the failed memory cell based in part on whether a number of failed memory cells in a respective row or column portion of memory where the failed memory cell is located exceeds a number of available complementary type memory spares. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> According to yet another related aspect, the information is stored in a table having row and column portions, each row and column portion of the table including at least one address/error-count entry pair for storing an address of the respective row or column portion of memory where the failed memory cell is located and the number of failed memory cells detected in the respective row or column portion of memory. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> According to yet another related aspect, the method further includes the step of determining if a match exists between at least one of the addresses of the row and column portions of memory where the failed memory cell is located and an address entry stored in the table. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> According to yet another related aspect, if a match exists, the method further includes the step of incrementing the error-count entry paired with the matching address entry if the paired error-count entry is equal to the number of available complementary type memory spares. If a match exists in both the row and column portions of the table, the method further includes the step of incrementing the error-count entries paired with the matching address entries if the paired error-count entries are each less than the respective number of available complementary type memory spares. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> According to yet another related aspect, if a match exists in one of the row and column portions of the table, the method further includes the step of determining if the row or column portion of the table not including the matching address entry is full. If the row or column portion of the table not including the matching address entry is not full, the method further includes the steps of incrementing the error-count entry paired with the matching address entry if the paired error-count entry is less than the number of available complementary type memory spares, and adding an address/error-count entry pair to the portion of the table not including the matching address entry, the added entry pair including the address of the row or column portion of memory where the failed memory cell is located not matching an address entry in the table and an error-count of one. If the row or column portion of the table not including the matching address entry is full, the information stored in the table is updated to indicate that the memory is not repairable. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> According to yet another related aspect, if no match exists, the method further includes the step of determining if at least one of the row and column portions of the table are full. If neither of the row or column portions of the table are full, the method further includes the step of adding an address/error-count entry pair to both the row and column portions of the table, each added entry pair including the respective address of the row or column portion of memory where the failed memory cell is located and an error-count of one. If at least one of the row and column portions of the table are full, the information stored in the table is updated to indicate that the memory is not repairable. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> According to yet another related aspect, if a total number of one type of memory spare is greater than a total number of complementary type memory spares, the step of determining if a match exists includes the step of comparing the address of the row or column portion of memory corresponding to the type of memory spare having the greater total number of spares with address entries in the table before comparing the address of the row or column portion of memory corresponding to the type of memory spare having a lesser total number of spares with address entries in the table. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> According to yet another related aspect, if the total number of the first and second types of memory spares are equal, the step of determining if a match exists includes the steps of selecting one of the addresses of the row and column portions of memory where the failed memory cell is located at random, and comparing the address of the row or column portion of memory selected at random with address entries in the table before comparing the address of the row or column portion of memory not selected at random with address entries in the table. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> According to yet another related aspect, the method further includes the step of linking address/error-count entry pairs included in the row portion of the table with associated address/error-count entry pairs included in the column portion of the table. A link identifier entry for storing a unique link ID is added to each address/error-count pair of the row or column portion of the table corresponding to the type of memory spare having a greater total number of spares for linking address/error-count entry pairs included in the row portion of the table with associated address/error-count entry pairs included in the column portion of the table. The number of unique link IDs is equal to the number of memory spares of the type having a lesser total number of spares. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> According to yet another related aspect, the table represents a portion of memory where at least one of the first type of memory spare intersects at least one of the second complementary type of memory spare. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> It should be emphasized that the terms &ldquo;comprises&rdquo; and &ldquo;comprising&rdquo;, when used in this specification as well as the claims, are taken to specify the presence of stated features, steps or components; but the use of these terms does not preclude the presence or addition of one or more other features, steps, components or groups thereof.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> The above objects, features, and advantages will become more apparent in light of the following detailed description in conjunction with the drawings, in which like reference numerals identify similar or identical elements, and in which: </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> illustrates a generalized error storage decision chart; </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 2A and 2B</cross-reference> illustrate the repair of detected memory cell failures using available memory spares; </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 3A and 3B</cross-reference> illustrate row and column portions of an error storage table; </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 4A and 4B</cross-reference> illustrate an exemplary portion of memory having a number of detected failed memory locations; </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 5A, 5B</cross-reference>, and <highlight><bold>5</bold></highlight>C illustrate various stages of the error storage process for the exemplary portion of memory shown in <cross-reference target="DRAWINGS">FIGS. 4A and 4B</cross-reference>; </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> illustrates the repair of the exemplary portion of memory shown in <cross-reference target="DRAWINGS">FIGS. 4A and 4B</cross-reference>; </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> illustrates a top-level flow diagram depicting an exemplary embodiment of an error storage process; </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> illustrates a flow diagram of an exemplary routine for processing errors when only one memory cell error is detected; </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference> illustrates a flow diagram of an exemplary routine for processing errors when more than one memory cell error is detected; and </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10</cross-reference> illustrates a portion of memory having R rows and C columns.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION </heading>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> Preferred embodiments are described below with reference to the accompanying drawings. In the following description, well-known functions and/or constructions are not described in detail to avoid obscuring the description in unnecessary detail. </paragraph>
<paragraph id="P-0036" lvl="7"><number>&lsqb;0036&rsqb;</number> Redundant Circuitry </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> As briefly described above, the redundant circuitry included to effect memory repair is made up of memory arrays that can replace failed memory locations by multiplexing (or mapping) spare memory cells to the identified failed memory locations. Repair information from a repair algorithm indicates how to map the spare row or column cells to the failed memory location. An efficient algorithm for repairing failed memory locations is described in the copending U.S. patent application Ser. No. 60/296,793 titled &ldquo;Repair Analysis Algorithm Suitable for On-Chip Implementation&rdquo;, having a common assignee as this application, the corresponding utility application being filed the same day as this application. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> Only one spare memory cell is required to fix any given failed memory bit. Typically, spare memory cell circuits are constructed with addressable row spare cells and column spare cells. In such arrangements, all memory bits associated with a given row address are replaced when a spare row is mapped to the location. Likewise, mapping a spare column into the memory will replace all memory bits included in that column. Each intersection of a row and column address selects a group of memory bits (or cells). </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> Other redundant circuitry arrangements are capable of mapping spare I/Os as well. These configurations group several column memory arrays into one output driver. This enables an individual data bit existing in multiple column addresses to be replaced with a single spare column. Spare columns replace a group of I/O&apos;s for a column address. Accordingly, the term &ldquo;column&rdquo; is used throughout this document to refer to both column and I/O-type redundant circuitry. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> In memory chips having several memory cores, the spare rows and spare columns included for repairing the various memory cores may be individually configured. The number of spare rows and columns that intersect one another in a given redundant circuit is an important design criteria in determining the configuration of an error storage table associated with that redundant circuit. Each error storage table may be thought to represent one sub-block where spare rows intersect with spare columns in the particular core. Each spare row and spare column can repair a range of row and column addresses. This range defines what is referred to as an &ldquo;analysis block&rdquo;. An analysis block&apos;s row and column address ranges divide a memory core into smaller independent regions. The spare rows and spare columns of analysis block may be shared among multiple sub-blocks. The amount sharing is dependent on the redundant architecture of the particular memory core. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> In addition to being capable of repairing a range of associated row and column addresses, the sub-block also has dedicated spare rows and spare columns that can be used to repair all the failed locations within the sub-block itself. Likewise if the sub-block is configured with spare rows and spare I/Os, this same capability holds true&mdash;the sub-block has dedicated spare rows and spare I/Os that can be used to repair all of the failed locations within the sub-block. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> As indicated above, the number of spare row and column cells or I/Os per sub-block can be varied across the different memory cores residing on a memory chip. Although the exemplary embodiments presented below feature memory cores that use two spare rows and one spare column (or I/O) per sub-block, those skilled in the art will understand that other arrangements using any number of spare cells or I/Os per sub-block are possible. </paragraph>
<paragraph id="P-0043" lvl="7"><number>&lsqb;0043&rsqb;</number> Error Storage Table </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> The error storage table is used to store only that information that is needed by the repair analysis algorithm to generate the necessary repair codes to map the identified failed memory cells to spare locations. This is to be contrasted with conventional error storage techniques that store and all of the failure information for repair processing. As discussed above, each spare cell (or I/O) covers a range of addresses, and can thus repair a number of addresses at one time. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> For example, given a memory core having spare cells that can replace, e.g., four row addresses at one time, the two least significant bits (LSBs) of the address can be considered to be one address. If memory failures are identified on row address one and row address three of a memory core, the spare row will replace row addresses zero, one, two, and three. The error storage table thus interprets row addresses zero, one, two, and three as the same address. This is but one method of reducing the amount of failed memory information that can be stored to drive the repair analysis algorithm. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> depicts a generalized error storage decision chart. Specific decision charts may be derived from the generalized chart based on the numbers of available spare rows and columns (or I/Os) in any given redundant circuitry structure. Important to the error storage table are the rules which govern its table entries. These rules are based on the number of spares available in the sub-block the table represents. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> Two general rules govern the chart entries. First, if a number of failures on a given column address exceeds the number of available spare rows, then a spare column must be used. This situation is depicted in <cross-reference target="DRAWINGS">FIG. 2A</cross-reference>. Second, if the number of failures on a given row address exceeds the number of available spare columns (or I/Os), then a spare row must be used. This situation is depicted in <cross-reference target="DRAWINGS">FIG. 2B</cross-reference>. For the case where spare I/Os are available, an additional table entry rule is required&mdash;when multiple I/Os have failures at the same address and the number of available spare I/Os are exceeded, then a spare row must be used. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> With these general rules in mind, the chart shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is arranged generally to have I/O (or column) information spanning horizontally, and row information spanning vertically across the chart. The vertical <highlight><bold>102</bold></highlight> and horizontal <highlight><bold>104</bold></highlight> chart headers describe the current condition of corresponding row update and column update tables, respectively (see <cross-reference target="DRAWINGS">FIGS. 3A and 3B</cross-reference>). The headers depict whether the respective tables: 1) contain no entries that match the current row and/or column address of the failure being processed and are not full; 2) contain an entry that matches the current row and/or column address of the failure being processed; and 3) are full and contain no entries that match the current row and/or column address of the failure being processed. The headers also contain information indicating the current row and column error counts for the various table entries. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> Each block <highlight><bold>106</bold></highlight> in the decision chart includes information that defines how the row update and column update tables should be modified based on the current table entries and the address location of the failure being processed. The lower-left block entries <highlight><bold>108</bold></highlight> correspond to row update table commands; upper-left cell entries <highlight><bold>110</bold></highlight> represent column update table commands; and the lower-right cell entry <highlight><bold>112</bold></highlight> is either empty or is set to &ldquo;NG&rdquo; to indicate that the memory core being processed is &ldquo;no good&rdquo; or un-repairable. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 3A and 3B</cross-reference> depict the row update and column (or I/O update) tables, respectively. The table sizes and size of the table entries are dependent upon the number of available spare rows and columns (or I/Os) available in a given sub-block. Continuing with the illustrative example of a sub-block having two spare rows and one spare I/O, the number of table row entries is four&mdash;two entries for each available spare row, plus two entries for each intersection of the two available spare rows with the single available spare column. Similarly, the number of table column entries is three&mdash;one entry for the single available spare column, plus two entries for each intersection of the single available spare column with the two available spare rows. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> Each of the row update and column update tables includes entries for a current error count. The size of the error-count entry in the illustrative example is two bits. Each of tables also has corresponding entries for an address of the row and column failure being repaired. Finally, the row update table includes entries that link a given row repair to a corresponding column repair. For this example, the size of the column ID entry is again two bits. Details regarding the size of the error storage table and its various entries are described in detail in the section titled &ldquo;Calculation of the Error Table Size&rdquo; below. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> Conventionally the storage of all the addresses of failed memory cells is necessary in order for the repair analysis algorithm to properly choose how to arrange the spare rows and columns to fix the sub-block. By employing the techniques described herein, each spare cell or I/O can fix several rows simultaneously, allowing several addresses to be represented as one single address in the error table. In the example that follows, each spare row can be addressed to repair four adjacent rows in the memory. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> Other techniques to further reduce the required size of the error storage table include not storing redundant errors in the error table, counting the number of times a given address has an error, not storing errors determined to lie along an already needed spare row or spare column. These techniques are combined to perform a limited repair analysis during the error storage process to effect a preselection of spare cell or I/Os that must be used to repair a given memory core. The techniques also permit the early detection of un-repairable memory devices during testing, saving valuable test time and resources. </paragraph>
<paragraph id="P-0054" lvl="7"><number>&lsqb;0054&rsqb;</number> Illustrative Example </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 4A and 4B</cross-reference> depict an illustrative example of a sub-block having a number of identified failed memory locations. <cross-reference target="DRAWINGS">FIG. 4A</cross-reference> depicts the sub-block having ten errors labeled A through J. The table shown in <cross-reference target="DRAWINGS">FIG. 4B</cross-reference> lists the row and column locations where the errors exist in the sub-block. As described earlier, each spare row in the example is capable of replacing four rows in the sub-block. <cross-reference target="DRAWINGS">FIGS. 5A</cross-reference> to <highlight><bold>5</bold></highlight>D depict the various steps performed when practicing the error storage techniques described above on the exemplary sub-block shown in <cross-reference target="DRAWINGS">FIG. 4A</cross-reference>. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 5</cross-reference>A, when the first error A is detected, the row and I/O tables are checked for current entries. If no entries exist, the tables are updated with a corresponding row and column entry, shown as step <highlight><bold>1</bold></highlight> in the FIGURE. Since error A is the first error detected on row address <highlight><bold>4</bold></highlight>, which is mapped to address <highlight><bold>1</bold></highlight>, the error-count is incremented to <highlight><bold>1</bold></highlight>. A corresponding column entry is made having address <highlight><bold>1</bold></highlight> and an error-count of <highlight><bold>1</bold></highlight>. The ID links the row address to the column address by position. Since the corresponding column address entry is made in location ID&equals;<highlight><bold>0</bold></highlight> in the I/O table, this entry is linked in the row table entry using the same ID. </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> The next error in the list is B. This error is located at row address <highlight><bold>2</bold></highlight> and column address <highlight><bold>3</bold></highlight> of the sub-block. Since these locations do not match any row or column entries in the row or I/O update tables, the tables are again updated with the current error information. This is shown as step <highlight><bold>2</bold></highlight> in the figure. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5B</cross-reference> shows the next stage of error processing. The next detected error in the example is error C. This error is located at row address <highlight><bold>2</bold></highlight> and column address <highlight><bold>1</bold></highlight>. The location of this error matches a current entry in the row update table, so the error-count of the row update table entry having the row address <highlight><bold>2</bold></highlight> is incremented to 2. This is shown as step <highlight><bold>3</bold></highlight> in the FIGURE. Applying the general rules described above, since the error-count for row <highlight><bold>2</bold></highlight> exceeds the number of available column spares (one in this example) the row must be fixed by one of the two available spare rows. Since all errors on row <highlight><bold>2</bold></highlight> will be fixed by the assigned row spare, a corresponding entry for error C need not be added to the column table. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> The next detected error is error D. This error does not match any existing error addresses and the tables are updated with the new error information. This is shown in as step <highlight><bold>4</bold></highlight> in the figure. Note that the column entry table is full after making the entry for error D. Thus, any additional detected errors that do not match any of the current column address entries will make this device un-repairable, allowing the testing cycle to be halted. </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> The next detected error in the example is error E. This error matches a current column entry in the I/O update table, but does not match any current row table entries. Accordingly, the row table is updated with the new error information. Note that the column ID the error E row table entry is set to 0 which is corresponds I/O table identifier associated with column <highlight><bold>1</bold></highlight>. The error-count for ID&equals;0 is incremented to 2 to record the additional detected column error. These updates are shown as step <highlight><bold>5</bold></highlight> in the figure. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5C</cross-reference> depicts the next stage of the error storage process. The next detected error in the example is error F. This error is located at row <highlight><bold>3</bold></highlight> and column <highlight><bold>1</bold></highlight> of the sub-block. The error matches a column entry (ID&equals;0) having an error-count of 2. The error will cause the error-count for the column entry to exceed the number of available row spares. Again applying the general rules discussed above, the single available column spare is assigned to fix the error. Since the error is fixed by the assigned spare column, a corresponding entry need not be made in the row entry table. </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> It is important to note that if the incremented error-count (3) did not exceed the number of spare rows available (2), then the device would have been determined to be un-repairable. The reason for this is that the row entry table is full, and thus it would be impossible to update the row table to add the failed information for row address <highlight><bold>3</bold></highlight>. The table is sized such that all repairable (and some not repairable) error patterns to fit. Thus, exceeding the table entries helps to identify un-repairable devices early in the testing process. </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> The next three errors in the example, errors G, H, and I, all match existing entries and are thus ignored in storage decision process. Identical errors need not be considered at all in the repair analysis process. The final error in the example, error J, is a new error, but it is repaired by a previously assigned row spare. This fact may be identified by the error-count entry in the row table. All error counts in the row entries that have the value of 2 must use a spare row, since this value exceeds the number of available spare columns. All column entries with an entry of <highlight><bold>3</bold></highlight> must be fixed with a column spare, since this value exceeds the number of available spare rows. </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> When the all errors have been processed and the error storage table completed, the repair analysis algorithm interprets the table results to determine if a successful repair can be effected. <cross-reference target="DRAWINGS">FIG. 6</cross-reference> depicts how the repair analysis may interpret the error storage table to effect a repair. Examining the column update portion of the error storage table, a spare column C<highlight><bold>1</bold></highlight> is used to repair column address <highlight><bold>1</bold></highlight> since the error-count for this entry (e.g., <highlight><bold>3</bold></highlight>) exceeds the number of available spare rows (e.g., <highlight><bold>2</bold></highlight>). Next, one of the two available spare rows C<highlight><bold>1</bold></highlight> is used to repair row address <highlight><bold>2</bold></highlight>. Again, the spare row is assigned because the error-count entry for this row address (e.g, <highlight><bold>2</bold></highlight>) exceeds the available number of spare columns (e.g., <highlight><bold>1</bold></highlight>). </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> Finally, the row update portion of the error table is examined to determine how the final available spare row is to be assigned. Recall that the already assigned spare column C<highlight><bold>1</bold></highlight> was assigned to column address <highlight><bold>1</bold></highlight>, having a column ID&equals;<highlight><bold>0</bold></highlight>. Accordingly, all row address error entries having a column ID&equals;<highlight><bold>0</bold></highlight> will be repaired by the already assigned spare column C<highlight><bold>1</bold></highlight>. An examination of the row table indicates that all but the recorded error at row address <highlight><bold>4</bold></highlight> is repaired by either the assigned spare column C<highlight><bold>1</bold></highlight> or the assigned spare row C<highlight><bold>1</bold></highlight>. Accordingly, the final available spare row R<highlight><bold>2</bold></highlight> is assigned to repair error D in row <highlight><bold>4</bold></highlight>, and all of the errors in the sub-block are successfully repaired with spare memory cells or I/Os. </paragraph>
<paragraph id="P-0066" lvl="7"><number>&lsqb;0066&rsqb;</number> Process Flow Diagrams for Illustrated Example </paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> is a top-level flow diagram depicting an exemplary embodiment of an error storage process. The process begins at step <highlight><bold>702</bold></highlight> defined as an idle mode. Next, a determination is made at step <highlight><bold>704</bold></highlight> whether to fetch the error storage (ES) table information from memory, e.g., from SRAM included on the memory chip. The process returns to the idle state <highlight><bold>702</bold></highlight> if a decision to fetch the ES information is not made, but transitions to step <highlight><bold>706</bold></highlight> where the ES information is read from SRAM if a decision to fetch is made. After reading the ES information from the SRAM to process transitions to step <highlight><bold>708</bold></highlight> where a decision to write updated ES information to the SRAM is made. If a decision to update the ES information is made, the ES table is updated at step <highlight><bold>710</bold></highlight> and the process returns to the idle state at step <highlight><bold>702</bold></highlight>. If the ES table is not to be updated, error testing and processing begins at step <highlight><bold>712</bold></highlight>. </paragraph>
<paragraph id="P-0068" lvl="0"><number>&lsqb;0068&rsqb;</number> A sub-block is tested at step <highlight><bold>712</bold></highlight> to determine the number error signals, if any, that are active on the I/O inputs. If more than one error signal is detected, the process transitions to step <highlight><bold>720</bold></highlight> and routine for processing greater than one error signal is executed. If there is one or less error signals detected, the process transitions to step <highlight><bold>714</bold></highlight> where a determination is made whether exactly one error signal has been detected. If exactly one error signal is detected, the process transitions to step <highlight><bold>718</bold></highlight>, and a routine for processing exactly one error signal is executed. If no errors are detected, no action for the current cycle is taken, and the process transitions through step <highlight><bold>716</bold></highlight> to step <highlight><bold>708</bold></highlight> where a decision to update the ES table in SRAM is again made. The process of detecting and process error signals in steps <highlight><bold>712</bold></highlight> through step <highlight><bold>720</bold></highlight> are again executed. </paragraph>
<paragraph id="P-0069" lvl="0"><number>&lsqb;0069&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> is a flow diagram of an exemplary routine for processing errors when only one memory cell error is detected. Some of the steps illustrated in the diagram are specific to the illustrative example that includes a redundant circuit having one spare column (or I/O) and two spare rows. It will be understood that general concepts presented in the diagram may extended to redundant circuits having any number of spare rows and columns. </paragraph>
<paragraph id="P-0070" lvl="0"><number>&lsqb;0070&rsqb;</number> The routine begins at step <highlight><bold>802</bold></highlight>, having been called from, e.g., step <highlight><bold>718</bold></highlight> of the top-level process depicted in <cross-reference target="DRAWINGS">FIG. 7</cross-reference>. The address of the error is compared with entries in the row update table at step <highlight><bold>804</bold></highlight> to determine if a row match exists. If a row match does exist, the routine proceeds to steps <highlight><bold>806</bold></highlight> through <highlight><bold>822</bold></highlight>. In these steps, determinations are made at steps <highlight><bold>808</bold></highlight> and <highlight><bold>814</bold></highlight> as to whether a corresponding I/O address exists, and if so, whether the l/O count is equal to 2 at steps <highlight><bold>810</bold></highlight> and <highlight><bold>816</bold></highlight>. If the I/O count is equal to 2, then if the row count is equal to 1, as determined in step <highlight><bold>806</bold></highlight>, the row count is incremented and the I/O count is set to 3 at step <highlight><bold>812</bold></highlight>. If, however, the row count is not equal to 1 in step <highlight><bold>806</bold></highlight>, only the I/O count is incremented at step <highlight><bold>818</bold></highlight>. </paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> If no I/O matches are found at steps <highlight><bold>808</bold></highlight> and <highlight><bold>814</bold></highlight>, or if the I/O count is not equal to 2 at steps <highlight><bold>810</bold></highlight> and <highlight><bold>816</bold></highlight>, then if the row count is equal to one at step <highlight><bold>806</bold></highlight>, only the row count is incremented at step <highlight><bold>822</bold></highlight>. If, however, the row count is not equal to one at step <highlight><bold>806</bold></highlight>, then no action is taken at step <highlight><bold>820</bold></highlight>. </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> If a row match does not exist as step <highlight><bold>804</bold></highlight>, the routine determines whether or not the row update table is full at step <highlight><bold>838</bold></highlight>. If the row table is not full, the routine examines the I/O update table for an I/O address match at step <highlight><bold>824</bold></highlight>. If an I/O address match is found, the I/O count is examined at step <highlight><bold>826</bold></highlight>. If the I/O count is greater than 2 (the number of spare rows in the example), then the I/O count is set to 3 at step <highlight><bold>828</bold></highlight>, otherwise a new row entry is added and the corresponding I/O count is incremented at step <highlight><bold>830</bold></highlight>. If no I/O match is found at step <highlight><bold>824</bold></highlight>, then a determination is made as to whether the I/O table is full at step <highlight><bold>832</bold></highlight>. If the table is full, then the memory core being examined is tagged as being un-repairable at step <highlight><bold>834</bold></highlight>, otherwise both a new row and I/O table entry is made at step <highlight><bold>836</bold></highlight>. </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> If the row table is found to be full at step,<highlight><bold>838</bold></highlight>, the routine looks for a corresponding I/O address match at step <highlight><bold>840</bold></highlight>. If no match is found, the memory core is again tagged as being un-repairable at step <highlight><bold>834</bold></highlight>. If an I/O match is found, the corresponding error-count is examined at step <highlight><bold>842</bold></highlight>. If the error I/O error-count is 1, then the memory core is tagged as being un-repairable, since no more additional space is available in the row update table. If the I/O count is equal to 1 at step <highlight><bold>842</bold></highlight>, however, the I/O count is set to 3. Control returns to the main error processing routine shown in <cross-reference target="DRAWINGS">FIG. 7</cross-reference> at step <highlight><bold>846</bold></highlight> after each of the table updates is completed. </paragraph>
<paragraph id="P-0074" lvl="0"><number>&lsqb;0074&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference> is a flow diagram of an exemplary routine for processing errors when more than one memory cell error is detected. Again, some of the steps illustrated in the diagram are specific to the illustrative example that includes a redundant circuit having one spare column (or I/O) and two spare rows. As mentioned above, it will be understood that general concepts presented in the diagram may extended to redundant circuits having any number of spare rows and columns. </paragraph>
<paragraph id="P-0075" lvl="0"><number>&lsqb;0075&rsqb;</number> The routine begins at step <highlight><bold>902</bold></highlight>, having been called from, e.g., step <highlight><bold>718</bold></highlight> of the top-level process depicted in <cross-reference target="DRAWINGS">FIG. 7</cross-reference>. The row update table is examined at step <highlight><bold>904</bold></highlight>. If a row match is found, the row error-count is set to 2 at step <highlight><bold>906</bold></highlight>. If, however, no row match is found, a determination is made as to whether the row update full at step <highlight><bold>908</bold></highlight>. If the table is full, the memory core being tested is tagged as being un-repairable at step <highlight><bold>910</bold></highlight>. If the table is not full at step <highlight><bold>908</bold></highlight>, a new row table entry is made with the column ID value set to <highlight><bold>3</bold></highlight> and the error-count is set to 2. Control returns to the main error processing routine shown in <cross-reference target="DRAWINGS">FIG. 7</cross-reference> at step <highlight><bold>914</bold></highlight>. </paragraph>
<paragraph id="P-0076" lvl="7"><number>&lsqb;0076&rsqb;</number> Calculation of the Error Table Size </paragraph>
<paragraph id="P-0077" lvl="0"><number>&lsqb;0077&rsqb;</number> Recall from the above that the error table is sized such that all repairable (and some not repairable) error patterns to fit. The following describes a manner in which the size of the error table may be calculated to achieve this result. <cross-reference target="DRAWINGS">FIG. 10</cross-reference> depicts a memory sub-block having R rows and C columns. The sub-block includes spare columns S<highlight><subscript>C </subscript></highlight>and spare rows S<highlight><subscript>R </subscript></highlight>for repairing failed memory cells within an analysis block. </paragraph>
<paragraph id="P-0078" lvl="0"><number>&lsqb;0078&rsqb;</number> As described above, a separate error storage table is required for each sub-block included within an analysis block. <cross-reference target="DRAWINGS">FIGS. 3A and 3B</cross-reference> depict the row update and column (or I/O) update portions of the error table, respectively. The format of the table entries include address/error-count pairs. An additional ID entry is included in the update table (either row or column) having the most spares. The ID entry provides a link between the row and column portions of the error storage table. </paragraph>
<paragraph id="P-0079" lvl="0"><number>&lsqb;0079&rsqb;</number> The following equations may be used to calculate the sizes of the count/address pairs in the row and column update tables:</paragraph>
<paragraph lvl="0"><in-line-formula>RowCnt&equals;&boxdr;log <highlight><subscript>2</subscript></highlight>(<highlight><italic>S</italic></highlight><highlight><subscript>C</subscript></highlight>&plus;2)&boxdl;</in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula>RowAddr&equals;&boxdr;log <highlight><subscript>2</subscript></highlight>(<highlight><italic>R</italic></highlight>)&boxdl;</in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula>ColumnCnt&equals;&boxdr;log <highlight><subscript>2</subscript></highlight>(<highlight><italic>S</italic></highlight><highlight><subscript>R</subscript></highlight>&plus;2)&boxdl;</in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula>ColumnAddr&equals;&boxdr;log <highlight><subscript>2</subscript></highlight>(<highlight><italic>C</italic></highlight>)&boxdr;</in-line-formula></paragraph>
<paragraph id="P-0080" lvl="7"><number>&lsqb;0080&rsqb;</number> where: S<highlight><subscript>C</subscript></highlight>&equals;Number of spare columns (or I/Os), </paragraph>
<paragraph id="P-0081" lvl="2"><number>&lsqb;0081&rsqb;</number> R&equals;Number of rows in the sub-block, </paragraph>
<paragraph id="P-0082" lvl="2"><number>&lsqb;0082&rsqb;</number> S<highlight><subscript>R</subscript></highlight>&equals;Number of spare rows, and </paragraph>
<paragraph id="P-0083" lvl="2"><number>&lsqb;0083&rsqb;</number> C&equals;Number of columns in the sub-block. </paragraph>
<paragraph id="P-0084" lvl="0"><number>&lsqb;0084&rsqb;</number> The values of the link ID&apos;s and number of link ID&apos;s required N<highlight><subscript>ID </subscript></highlight>may be calculated using the following equations:  
<math-cwu id="MATH-US-00001">
<number>1</number>
<math>
<mrow>
  <mi>ID</mi>
  <mo>=</mo>
  <mrow>
    <mo>{</mo>
    <mrow>
      <mrow>
        <mtable>
          <mtr>
            <mtd>
              <mrow>
                <mrow>
                  <mrow>
                    <mo>&LeftCeiling;</mo>
                    <mrow>
                      <msub>
                        <mi>log</mi>
                        <mn>2</mn>
                      </msub>
                      <mo>&af;</mo>
                      <mrow>
                        <mo>(</mo>
                        <msub>
                          <mi>C</mi>
                          <mi>E</mi>
                        </msub>
                        <mo>)</mo>
                      </mrow>
                    </mrow>
                    <mo>&RightCeiling;</mo>
                  </mrow>
                  <mo>&it;</mo>
                  <mstyle>
                    <mtext>&emsp;</mtext>
                  </mstyle>
                  <mo>&it;</mo>
                  <mstyle>
                    <mtext>if</mtext>
                  </mstyle>
                  <mo>&it;</mo>
                  <mstyle>
                    <mtext>&emsp;</mtext>
                  </mstyle>
                  <mo>&it;</mo>
                  <msub>
                    <mi>R</mi>
                    <mi>E</mi>
                  </msub>
                </mrow>
                <mo>&GreaterEqual;</mo>
                <msub>
                  <mi>C</mi>
                  <mi>E</mi>
                </msub>
              </mrow>
            </mtd>
          </mtr>
          <mtr>
            <mtd>
              <mrow>
                <mrow>
                  <mrow>
                    <mo>&LeftCeiling;</mo>
                    <mrow>
                      <msub>
                        <mi>log</mi>
                        <mn>2</mn>
                      </msub>
                      <mo>&af;</mo>
                      <mrow>
                        <mo>(</mo>
                        <msub>
                          <mi>R</mi>
                          <mi>E</mi>
                        </msub>
                        <mo>)</mo>
                      </mrow>
                    </mrow>
                    <mo>&RightCeiling;</mo>
                  </mrow>
                  <mo>&it;</mo>
                  <mstyle>
                    <mtext>&emsp;</mtext>
                  </mstyle>
                  <mo>&it;</mo>
                  <mstyle>
                    <mtext>if</mtext>
                  </mstyle>
                  <mo>&it;</mo>
                  <mstyle>
                    <mtext>&emsp;</mtext>
                  </mstyle>
                  <mo>&it;</mo>
                  <msub>
                    <mi>C</mi>
                    <mi>E</mi>
                  </msub>
                </mrow>
                <mo>&gt;</mo>
                <msub>
                  <mi>R</mi>
                  <mi>E</mi>
                </msub>
              </mrow>
            </mtd>
          </mtr>
        </mtable>
        <mo>&it;</mo>
        <mstyle>
          <mtext>&NewLine;</mtext>
        </mstyle>
        <mo>&it;</mo>
        <msub>
          <mi>N</mi>
          <mi>ID</mi>
        </msub>
      </mrow>
      <mo>=</mo>
      <mrow>
        <mo>{</mo>
        <mtable>
          <mtr>
            <mtd>
              <mrow>
                <mrow>
                  <msub>
                    <mi>C</mi>
                    <mi>E</mi>
                  </msub>
                  <mo>&it;</mo>
                  <mstyle>
                    <mtext>&emsp;</mtext>
                  </mstyle>
                  <mo>&it;</mo>
                  <mstyle>
                    <mtext>if</mtext>
                  </mstyle>
                  <mo>&it;</mo>
                  <mstyle>
                    <mtext>&emsp;</mtext>
                  </mstyle>
                  <mo>&it;</mo>
                  <msub>
                    <mi>R</mi>
                    <mi>E</mi>
                  </msub>
                </mrow>
                <mo>&GreaterEqual;</mo>
                <msub>
                  <mi>C</mi>
                  <mi>E</mi>
                </msub>
              </mrow>
            </mtd>
          </mtr>
          <mtr>
            <mtd>
              <mrow>
                <mrow>
                  <msub>
                    <mi>R</mi>
                    <mi>E</mi>
                  </msub>
                  <mo>&it;</mo>
                  <mstyle>
                    <mtext>&emsp;</mtext>
                  </mstyle>
                  <mo>&it;</mo>
                  <mstyle>
                    <mtext>if</mtext>
                  </mstyle>
                  <mo>&it;</mo>
                  <mstyle>
                    <mtext>&emsp;</mtext>
                  </mstyle>
                  <mo>&it;</mo>
                  <msub>
                    <mi>C</mi>
                    <mi>E</mi>
                  </msub>
                </mrow>
                <mo>&gt;</mo>
                <msub>
                  <mi>R</mi>
                  <mi>E</mi>
                </msub>
              </mrow>
            </mtd>
          </mtr>
        </mtable>
      </mrow>
    </mrow>
  </mrow>
</mrow>
</math>
<mathematica-file id="MATHEMATICA-00001" file="US20030005353A1-20030102-M00001.NB"/>
<image id="EMI-M00001" wi="216.027" he="57.12525" file="US20030005353A1-20030102-M00001.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0085" lvl="7"><number>&lsqb;0085&rsqb;</number> where: C<highlight><subscript>E</subscript></highlight>&equals;Number of column (or I/O) entries&equals;S<highlight><subscript>R</subscript></highlight>* (S<highlight><subscript>C</subscript></highlight>&plus;1), </paragraph>
<paragraph id="P-0086" lvl="2"><number>&lsqb;0086&rsqb;</number> R<highlight><subscript>E</subscript></highlight>&equals;Number of rows entries&equals;S<highlight><subscript>C</subscript></highlight>* (S<highlight><subscript>R</subscript></highlight>&plus;1), and </paragraph>
<paragraph id="P-0087" lvl="2"><number>&lsqb;0087&rsqb;</number> N<highlight><subscript>ID</subscript></highlight>&equals;Number of link IDs. </paragraph>
<paragraph id="P-0088" lvl="0"><number>&lsqb;0088&rsqb;</number> Using the above equations, the size of the error storage table may be calculated as:  
<math-cwu id="MATH-US-00002">
<number>2</number>
<math>
<mrow>
  <mstyle>
    <mtext>Size</mtext>
  </mstyle>
  <mo>=</mo>
  <mrow>
    <mo>{</mo>
    <mtable>
      <mtr>
        <mtd>
          <mrow>
            <mrow>
              <mrow>
                <msub>
                  <mi>R</mi>
                  <mi>E</mi>
                </msub>
                <mo>*</mo>
                <mrow>
                  <mo>(</mo>
                  <mrow>
                    <mi>RowCnt</mi>
                    <mo>+</mo>
                    <mi>RowAddr</mi>
                    <mo>+</mo>
                    <mi>ID</mi>
                  </mrow>
                  <mo>)</mo>
                </mrow>
              </mrow>
              <mo>+</mo>
              <mrow>
                <msub>
                  <mi>C</mi>
                  <mi>E</mi>
                </msub>
                <mo>*</mo>
                <mrow>
                  <mo>(</mo>
                  <mrow>
                    <mi>ColumnCnt</mi>
                    <mo>+</mo>
                    <mi>ColumnAddr</mi>
                  </mrow>
                  <mo>)</mo>
                </mrow>
                <mo>&it;</mo>
                <mstyle>
                  <mtext>&emsp;</mtext>
                </mstyle>
                <mo>&it;</mo>
                <mstyle>
                  <mtext>if</mtext>
                </mstyle>
                <mo>&it;</mo>
                <mstyle>
                  <mtext>&emsp;</mtext>
                </mstyle>
                <mo>&it;</mo>
                <msub>
                  <mi>R</mi>
                  <mi>E</mi>
                </msub>
              </mrow>
            </mrow>
            <mo>&GreaterEqual;</mo>
            <msub>
              <mi>C</mi>
              <mi>E</mi>
            </msub>
          </mrow>
        </mtd>
      </mtr>
      <mtr>
        <mtd>
          <mrow>
            <mrow>
              <mrow>
                <msub>
                  <mi>R</mi>
                  <mi>E</mi>
                </msub>
                <mo>*</mo>
                <mrow>
                  <mo>(</mo>
                  <mrow>
                    <mi>RowCnt</mi>
                    <mo>+</mo>
                    <mi>RowAddr</mi>
                  </mrow>
                  <mo>)</mo>
                </mrow>
              </mrow>
              <mo>+</mo>
              <mrow>
                <msub>
                  <mi>C</mi>
                  <mi>E</mi>
                </msub>
                <mo>*</mo>
                <mrow>
                  <mo>(</mo>
                  <mrow>
                    <mi>ColumnCnt</mi>
                    <mo>+</mo>
                    <mi>ColumnAddr</mi>
                    <mo>+</mo>
                    <mi>ID</mi>
                  </mrow>
                  <mo>)</mo>
                </mrow>
                <mo>&it;</mo>
                <mstyle>
                  <mtext>&emsp;</mtext>
                </mstyle>
                <mo>&it;</mo>
                <mstyle>
                  <mtext>if</mtext>
                </mstyle>
                <mo>&it;</mo>
                <mstyle>
                  <mtext>&emsp;</mtext>
                </mstyle>
                <mo>&it;</mo>
                <msub>
                  <mi>C</mi>
                  <mi>E</mi>
                </msub>
              </mrow>
            </mrow>
            <mo>&gt;</mo>
            <msub>
              <mi>R</mi>
              <mi>E</mi>
            </msub>
          </mrow>
        </mtd>
      </mtr>
    </mtable>
  </mrow>
</mrow>
</math>
<mathematica-file id="MATHEMATICA-00002" file="US20030005353A1-20030102-M00002.NB"/>
<image id="EMI-M00002" wi="274.11615" he="27.13095" file="US20030005353A1-20030102-M00002.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0089" lvl="0"><number>&lsqb;0089&rsqb;</number> Certain terms have been used for convenience in describing the exemplary embodiments, but should not be used to limit the general concepts described herein. For example, any specific reference to &ldquo;row&rdquo; or &ldquo;column&rdquo; portions of memory or types of memory spares can be interpreted to embrace either of these portions of memory or types of memory spares. In the case of memory spares, the specific terms represent complementary types of memory spares in that if one type of memory spare is not used to repair a given memory cell location, the other complementary type of memory spare may be used to repair the location. Moreover, the term &ldquo;cell&rdquo; or &ldquo;memory cell&rdquo; can be interpreted to represent one or memory cells or locations in the memory. </paragraph>
<paragraph id="P-0090" lvl="0"><number>&lsqb;0090&rsqb;</number> Various aspects have been described in connection with a number of exemplary embodiments. To facilitate an understanding of these embodiments, many aspects were described in terms of sequences of actions that may be performed by elements of a computer system or micro-controller. For example, it will be recognized that in each of the embodiments, the various actions could be performed by specialized circuits (e.g., discrete logic gates interconnected to perform a specialized function), by program instructions being executed by one or more processors, or by a combination of both. </paragraph>
<paragraph id="P-0091" lvl="0"><number>&lsqb;0091&rsqb;</number> Moreover, the exemplary embodiments can be considered part of any form of computer readable storage medium having stored therein an appropriate set of computer instructions that would cause a processor to carry out the techniques <highlight><bold>5</bold></highlight> described herein. Thus, the various aspects may be embodied in many different forms, and all such forms are contemplated to be within the scope of what has been described. For each of the various aspects, any such form of embodiment may be referred to herein as &ldquo;logic configured to&rdquo; perform a described action, or alternatively as &ldquo;logic that&rdquo; performs a described action. </paragraph>
<paragraph id="P-0092" lvl="0"><number>&lsqb;0092&rsqb;</number> Although various exemplary embodiments have been described, it will be understood by those of ordinary skill in this art that these embodiments are merely illustrative and that many other embodiments are possible. The intended scope of the invention is defined by the following claims rather than the preceding description, and all variations that fall within the scope of the claims are intended to be embraced therein. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method for storing memory test information, the method comprising the steps of: 
<claim-text>storing a portion of information related to locations and numbers of failed memory cells detected while testing memory; and </claim-text>
<claim-text>updating the stored information as failed memory cells are detected to indicate a first type of memory spare is to be assigned to repair a failed memory cell, a second complementary type of memory spare is to be assigned to repair the failed memory cell, or the memory is not repairable; </claim-text>
<claim-text>wherein the first type of memory spare corresponds to one of a row and a column portion of memory and the second complementary type of memory spare corresponds to the other of the row and column portions of memory. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the stored information is updated to indicate the type of memory spare to be assigned to repair the failed memory cell based in part on whether a number of failed memory cells in a respective row or column portion of memory where the failed memory cell is located exceeds a number of available complementary type memory spares. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, wherein the information is stored in a table having row and column portions, each row and column portion of the table including at least one address/error-count entry pair for storing an address of the respective row or column portion of memory where the failed memory cell is located and the number of failed memory cells detected in the respective row or column portion of memory. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference>, further comprising the step of: 
<claim-text>determining if a match exists between at least one of the addresses of the row and column portions of memory where the failed memory cell is located and an address entry stored in the table. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00004">claim 4</dependent-claim-reference>, wherein if a match exists, the method further comprises the step of: 
<claim-text>incrementing the error-count entry paired with the matching address entry if the paired error-count entry is equal to the number of available complementary type memory spares. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00004">claim 4</dependent-claim-reference>, wherein if a match exists in both the row and column portions of the table, the method further comprises the step of: 
<claim-text>incrementing the error-count entries paired with the matching address entries if the paired error-count entries are each less than the respective number of available complementary type memory spares. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00004">claim 4</dependent-claim-reference>, wherein if a match exists in one of the row and column portions of the table, the method further comprises the step of: 
<claim-text>determining if the row or column portion of the table not including the matching address entry is full. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference>, wherein if the row or column portion of the table not including the matching address entry is not full, the method further comprises the steps of: 
<claim-text>incrementing the error-count entry paired with the matching address entry if the paired error-count entry is less than the number of available complementary type memory spares; and </claim-text>
<claim-text>adding an address/error-count entry pair to the portion of the table not including the matching address entry, the added entry pair including the address of the row or column portion of memory where the failed memory cell is located not matching an address entry in the table and an error-count of one. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference>, wherein if the row or column portion of the table not including the matching address entry is full, the information stored in the table is updated to indicate that the memory is not repairable. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00004">claim 4</dependent-claim-reference>, wherein if no match exists, the method further comprises the step of: 
<claim-text>determining if at least one of the row and column portions of the table are full. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein if neither of the row or column portions of the table are full, the method further comprises the step of: 
<claim-text>adding an address/error-count entry pair to both the row and column portions of the table, each added entry pair including the respective address of the row or column portion of memory where the failed memory cell is located and an error-count of one. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein if at least one of the row and column portions of the table are full, the information stored in the table is updated to indicate that the memory is not repairable. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00004">claim 4</dependent-claim-reference>, wherein if a total number of one type of memory spare is greater than a total number of complementary type memory spares, the step of determining if a match exists comprises the step of: 
<claim-text>comparing the address of the row or column portion of memory corresponding to the type of memory spare having the greater total number of spares with address entries in the table before comparing the address of the row or column portion of memory corresponding to the type of memory spare having a lesser total number of spares with address entries in the table. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00004">claim 4</dependent-claim-reference>, wherein if the total number of the first and second types of memory spares are equal, the step of determining if a match exists comprises the steps of: 
<claim-text>selecting one of the addresses of the row and column portions of memory where the failed memory cell is located at random; and </claim-text>
<claim-text>comparing the address of the row or column portion of memory selected at random with address entries in the table before comparing the address of the row or column portion of memory not selected at random with address entries in the table. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference>, further comprising the step of: 
<claim-text>linking address/error-count entry pairs included in the row portion of the table with associated address/error-count entry pairs included in the column portion of the table. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference>, wherein a link identifier entry for storing a unique link ID is added to each address/error-count pair of the row or column portion of the table corresponding to the type of memory spare having a greater total number of spares for linking address/error-count entry pairs included in the row portion of the table with associated address/error-count entry pairs included in the column portion of the table. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, wherein the number of unique link IDs is equal to the number of memory spares of the type having a lesser total number of spares. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference>, wherein the table represents a portion of memory where at least one of the first type of memory spare intersects at least one of the second complementary type of memory spare. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference>, wherein the size of the table is determined by the equation: </claim-text>
<claim-text> 
<math-cwu id="MATH-US-00003">
<number>3</number>
<math>
<mrow>
  <mstyle>
    <mtext>Size</mtext>
  </mstyle>
  <mo>=</mo>
  <mrow>
    <mo>{</mo>
    <mtable>
      <mtr>
        <mtd>
          <mrow>
            <mrow>
              <mrow>
                <msub>
                  <mi>R</mi>
                  <mi>E</mi>
                </msub>
                <mo>*</mo>
                <mrow>
                  <mo>(</mo>
                  <mrow>
                    <mi>RowCnt</mi>
                    <mo>+</mo>
                    <mi>RowAddr</mi>
                    <mo>+</mo>
                    <mi>ID</mi>
                  </mrow>
                  <mo>)</mo>
                </mrow>
              </mrow>
              <mo>+</mo>
              <mrow>
                <msub>
                  <mi>C</mi>
                  <mi>E</mi>
                </msub>
                <mo>*</mo>
                <mrow>
                  <mo>(</mo>
                  <mrow>
                    <mi>ColumnCnt</mi>
                    <mo>+</mo>
                    <mi>ColumnAddr</mi>
                  </mrow>
                  <mo>)</mo>
                </mrow>
                <mo>&it;</mo>
                <mstyle>
                  <mtext>&emsp;</mtext>
                </mstyle>
                <mo>&it;</mo>
                <mstyle>
                  <mtext>if</mtext>
                </mstyle>
                <mo>&it;</mo>
                <mstyle>
                  <mtext>&emsp;</mtext>
                </mstyle>
                <mo>&it;</mo>
                <msub>
                  <mi>R</mi>
                  <mi>E</mi>
                </msub>
              </mrow>
            </mrow>
            <mo>&GreaterEqual;</mo>
            <msub>
              <mi>C</mi>
              <mi>E</mi>
            </msub>
          </mrow>
        </mtd>
      </mtr>
      <mtr>
        <mtd>
          <mrow>
            <mrow>
              <mrow>
                <msub>
                  <mi>R</mi>
                  <mi>E</mi>
                </msub>
                <mo>*</mo>
                <mrow>
                  <mo>(</mo>
                  <mrow>
                    <mi>RowCnt</mi>
                    <mo>+</mo>
                    <mi>RowAddr</mi>
                  </mrow>
                  <mo>)</mo>
                </mrow>
              </mrow>
              <mo>+</mo>
              <mrow>
                <msub>
                  <mi>C</mi>
                  <mi>E</mi>
                </msub>
                <mo>*</mo>
                <mrow>
                  <mo>(</mo>
                  <mrow>
                    <mi>ColumnCnt</mi>
                    <mo>+</mo>
                    <mi>ColumnAddr</mi>
                    <mo>+</mo>
                    <mi>ID</mi>
                  </mrow>
                  <mo>)</mo>
                </mrow>
                <mo>&it;</mo>
                <mstyle>
                  <mtext>&emsp;</mtext>
                </mstyle>
                <mo>&it;</mo>
                <mstyle>
                  <mtext>if</mtext>
                </mstyle>
                <mo>&it;</mo>
                <mstyle>
                  <mtext>&emsp;</mtext>
                </mstyle>
                <mo>&it;</mo>
                <msub>
                  <mi>C</mi>
                  <mi>E</mi>
                </msub>
              </mrow>
            </mrow>
            <mo>&gt;</mo>
            <msub>
              <mi>R</mi>
              <mi>E</mi>
            </msub>
          </mrow>
        </mtd>
      </mtr>
    </mtable>
  </mrow>
</mrow>
</math>
<mathematica-file id="MATHEMATICA-00003" file="US20030005353A1-20030102-M00003.NB"/>
<image id="EMI-M00003" wi="274.11615" he="27.13095" file="US20030005353A1-20030102-M00003.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</claim-text>
<claim-text>where C<highlight><subscript>E</subscript></highlight>&equals;Number of entries in column portion of table&equals;S<highlight><subscript>R</subscript></highlight>* (S<highlight><subscript>C</subscript></highlight>&plus;1); 
<claim-text>R<highlight><subscript>E</subscript></highlight>&equals;Number of entries in row portion of table&equals;S<highlight><subscript>C</subscript></highlight>* (S<highlight><subscript>R</subscript></highlight>&plus;1); </claim-text>
<claim-text>RowCnt&equals;Size of error-count in row portion of table&equals;log<highlight><subscript>2</subscript></highlight>(S<highlight><subscript>C</subscript></highlight>&plus;2); </claim-text>
<claim-text>RowAddr&equals;Size of address in row portion of table&equals;log<highlight><subscript>2</subscript></highlight>(R); </claim-text>
<claim-text>ColumnCnt&equals;Size of error-count in column portion of table&equals;log<highlight><subscript>2</subscript></highlight>(S<highlight><subscript>R</subscript></highlight>&plus;2); </claim-text>
<claim-text>ColumnAddr&equals;Size of address in column portion of table&equals;log<highlight><subscript>2</subscript></highlight>(C); </claim-text>
<claim-text>R&equals;Number of rows in row portion of memory; </claim-text>
<claim-text>S<highlight><subscript>R</subscript></highlight>&equals;Number of first or second type of memory spares; </claim-text>
<claim-text>S<highlight><subscript>C</subscript></highlight>&equals;Number of complementary type of memory spares; </claim-text>
<claim-text>C&equals;Number of columns in column portion of memory; and </claim-text>
<claim-text>ID&equals;Size of link ID&equals;&boxdr;log<highlight><subscript>2</subscript></highlight>(C<highlight><subscript>E</subscript></highlight>)&boxdl;, if R<highlight><subscript>E</subscript></highlight>&lE;C<highlight><subscript>E</subscript></highlight>; &boxdr;log<highlight><subscript>2</subscript></highlight>(R<highlight><subscript>E</subscript></highlight>)&boxdl;, if C<highlight><subscript>E</subscript></highlight>&gt;R<highlight><subscript>E</subscript></highlight>. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the row portion of memory includes at least one row of memory and the column portion of memory includes at least one column of memory. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the column portion of memory includes at least one input/output (I/O) device, the at least one I/O device providing an input and output path for at least one column of memory. </claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. An apparatus for storing memory test information, comprising: 
<claim-text>logic that stores a portion of information related to locations and numbers of failed memory cells detected while testing memory; and </claim-text>
<claim-text>logic that updates the stored information as failed memory cells are detected to indicate a first type of memory spare is to be assigned to repair a failed memory cell, a second complementary type of memory spare is to be assigned to repair the failed memory cell, or the memory is not repairable; </claim-text>
<claim-text>wherein the first type of memory spare corresponds to one of a row and a column portion of memory and the second complementary type of memory spare corresponds to the other of the row and column portions of memory. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 22</dependent-claim-reference>, wherein the stored information is updated to indicate the type of memory spare to be assigned to repair the failed memory cell based in part on whether a number of failed memory cells in a respective row or column portion of memory where the failed memory cell is located exceeds a number of available complementary type memory spares. </claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 23</dependent-claim-reference>, further comprising: 
<claim-text>a table for storing the information, the table having row and column portions, each row and column portion of the table including at least one address/error-count entry pair for storing an address of the respective row or column portion of memory where the failed memory cell is located and the number of failed memory cells detected in the respective row or column portion of memory. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 24</dependent-claim-reference>, further comprising: 
<claim-text>logic that determines if a match exists between at least one of the addresses of the row and column portions of memory where the failed memory cell is located and an address entry stored in the table. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>, further comprising: 
<claim-text>logic that increments the error-count entry paired with the matching address entry when a match exists if the paired error-count entry is equal to the number of available complementary type memory spares. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>, further comprising: 
<claim-text>logic that increments the error-count entries paired with the matching address entries when a match exists in both the row and column portions of the table if the paired error-count entries are each less than the respective number of available complementary type memory spares. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>, further comprising: 
<claim-text>logic that determines if the row or column portion of the table not including the matching address entry is full when a match exists in one of the row and column portions of the table. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00029">
<claim-text><highlight><bold>29</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 28</dependent-claim-reference>, further comprising: 
<claim-text>logic that increments the error-count entry paired with the matching address entry when a match exists in one of the row and column portions of the table if the paired error-count entry is less than the number of available complementary type memory spares; and </claim-text>
<claim-text>logic that adds an address/error-count entry pair to the portion of the table not including the matching address entry when a match exists in one of the row and column portions of the table, the added entry pair including the address of the row or column portion of memory where the failed memory cell is located not matching an address entry in the table and an error-count of one. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00030">
<claim-text><highlight><bold>30</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 28</dependent-claim-reference>, further comprising: 
<claim-text>logic that indicates that the memory is not repairable when the row or column portion of the table not including the matching address entry is full. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00031">
<claim-text><highlight><bold>31</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>, further comprising: 
<claim-text>logic that determines if at least one of the row and column portions of the table are full when no match exists. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00032">
<claim-text><highlight><bold>32</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00033">claim 31</dependent-claim-reference>, further comprising: 
<claim-text>logic that adds an address/error-count entry pair to both the row and column portions of the table when no match exists, each added entry pair including the respective address of the row or column portion of memory where the failed memory cell is located and an error-count of one. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00033">
<claim-text><highlight><bold>33</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00033">claim 31</dependent-claim-reference>, further comprising: 
<claim-text>logic that indicates that the memory is not repairable when at least one of the row and column portions of the table are full. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00034">
<claim-text><highlight><bold>34</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>, wherein the logic that determines if a match exists comprises: 
<claim-text>logic that compares the address of the row or column portion of memory corresponding to the type of memory spare having the greater total number of spares with address entries in the table before comparing the address of the row or column portion of memory corresponding to the type of memory spare having a lesser total number of spares with address entries in the table when a total number of one type of memory spare is greater than a total number of complementary type memory spares. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00035">
<claim-text><highlight><bold>35</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>, wherein the logic that determines if a match exists comprises: 
<claim-text>logic that selects one of the addresses of the row and column portions of memory where the failed memory cell is located at random when the total number of the first and second types of memory spares are equal; and </claim-text>
<claim-text>logic that compares the address of the row or column portion of memory selected at random with address entries in the table before comparing the address of the row or column portion of memory not selected at random with address entries in the table when the total number of the first and second types of memory spares are equal. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00036">
<claim-text><highlight><bold>36</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 24</dependent-claim-reference>, further comprising: 
<claim-text>logic that links address/error-count entry pairs included in the row portion of the table with associated address/error-count entry pairs included in the column portion of the table. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00037">
<claim-text><highlight><bold>37</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00033">claim 36</dependent-claim-reference>, further comprising: 
<claim-text>logic that adds a link identifier entry for storing a unique link ID to each address/error-count pair of the row or column portion of the table corresponding to the type of memory spare having a greater total number of spares for linking address/error-count entry pairs included in the row portion of the table with associated address/error-count entry pairs included in the column portion of the table. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00038">
<claim-text><highlight><bold>38</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00033">claim 37</dependent-claim-reference>, wherein the number of unique link IDs is equal to the number of memory spares of the type having a lesser total number of spares. </claim-text>
</claim>
<claim id="CLM-00039">
<claim-text><highlight><bold>39</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00022">claim 24</dependent-claim-reference>, wherein the table represents a portion of memory where at least one of the first type of memory spare intersects at least one of the second complementary type of memory spare.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>1</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005353A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005353A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005353A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005353A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005353A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005353A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030005353A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030005353A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030005353A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00009">
<image id="EMI-D00009" file="US20030005353A1-20030102-D00009.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
