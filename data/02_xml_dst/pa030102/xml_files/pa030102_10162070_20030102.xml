<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005365A1-20030102-D00000.TIF SYSTEM "US20030005365A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005365A1-20030102-D00001.TIF SYSTEM "US20030005365A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005365A1-20030102-D00002.TIF SYSTEM "US20030005365A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005365A1-20030102-D00003.TIF SYSTEM "US20030005365A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005365A1-20030102-D00004.TIF SYSTEM "US20030005365A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005365A1-20030102-D00005.TIF SYSTEM "US20030005365A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030005365A1-20030102-D00006.TIF SYSTEM "US20030005365A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030005365A1-20030102-D00007.TIF SYSTEM "US20030005365A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030005365A1-20030102-D00008.TIF SYSTEM "US20030005365A1-20030102-D00008.TIF" NDATA TIF>
<!ENTITY US20030005365A1-20030102-D00009.TIF SYSTEM "US20030005365A1-20030102-D00009.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005365</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10162070</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20020605</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>H02H003/05</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>714</class>
<subclass>038000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Conditional execution per lane</title-of-invention>
</technical-information>
<continuity-data>
<non-provisional-of-provisional>
<document-id>
<doc-number>60296757</doc-number>
<document-date>20010611</document-date>
<country-code>US</country-code>
</document-id>
</non-provisional-of-provisional>
</continuity-data>
<inventors>
<first-named-inventor>
<name>
<given-name>Sophie</given-name>
<family-name>Wilson</family-name>
</name>
<residence>
<residence-non-us>
<city>Cambridge</city>
<country-code>GB</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
</inventors>
<assignee>
<organization-name>Broadcom Corporation</organization-name>
<assignee-type>03</assignee-type>
</assignee>
<correspondence-address>
<name-1>STERNE, KESSLER, GOLDSTEIN &amp; FOX PLLC</name-1>
<name-2></name-2>
<address>
<address-1>1100 NEW YORK AVENUE, N.W., SUITE 600</address-1>
<city>WASHINGTON</city>
<state>DC</state>
<postalcode>20005-3934</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A computer system for conditionally performing an operation defined in a computer instruction, an execution unit of the computer system comprises at least one operand store for holding operands on which an operation defined in an instruction is to be performed, wherein said operand store defines a plurality of lanes each holding an object, a plurality of operators associated respectively with the lanes for carrying out an operation specified in an instruction on objects in the operand lanes, a destination store for holding objects resulting from the operation on a lane by lane basis, a plurality of control stores each comprising a plurality of indicators to control for each lane whether or not an operation defined in an instruction is to be performed on that lane, and control circuitry for controlling which of said plurality of control stores is to be used to control per lane execution of an instruction, the control circuitry being operative to select a control store from the plurality of control stores based on a field contained in the instruction. A method and computer program for performing conditional execution are also claimed. </paragraph>
</subdoc-abstract>
<subdoc-description>
<cross-reference-to-related-applications>
<heading lvl="1">CROSS-REFERENCE TO RELATED APPLICATIONS </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> This application claims priority to Provisional U.S. patent application Ser. No. 60/296,757, filed Jun. 11, 2001.</paragraph>
</cross-reference-to-related-applications>
<summary-of-invention>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
</section>
<section>
<heading lvl="1">FIELD OF THE INVENTION </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> The present invention relates to a computer system for conditionally carrying out an operation defined in a computer instruction, to an execution unit for use in the computer system and to a method of executing instructions. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> Computer systems are known which act on so-called packed operands. That is, each operand comprises a plurality of packed objects held in respective lanes of the operand. The degree of packing can vary and for 64 bit operands it is known to provide 8-bit packed objects (eight objects per 64 bit operand), 16-bit packed objects (four objects per 64 bit operand) and 32-bit packed objects (two objects per 64 bit operand). A known computer system can conditionally execute instructions on a per operand lane basis according to respective condition codes held in a condition code register. The computer system also includes a test register holding a test code. The test register is addressed by the instruction to compare the test code with the condition codes and thereby conditionally execute the instruction on operand lanes for which the test condition applies. A problem with this type of known system is the need to manage the contents of the test register by means of additional operations to control which lanes are executed. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> The present invention seeks to provide an improved method and apparatus for conditionally executing instructions. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> According to one aspect of the present invention there is provided a computer system for conditionally performing an operation defined in a computer instruction, the execution unit comprising: at least one operand store for holding operands on which an operation defined in an instruction is to be performed, wherein said operand store defines a plurality of lanes each holding an object; a plurality of operators associated respectively with the lanes for carrying out an operation specified in an instruction on objects in the operand lanes; a destination store for holding objects resulting from the operation on a lane by lane basis; a plurality of control stores each comprising a plurality of indicators to control for each lane whether or not an operation defined in an instruction is to be performed on that lane; and control circuitry for controlling which of said plurality of control stores is to be used to control per lane execution of an instruction, the control circuitry being operative to select a control store from the plurality of control stores based on a field contained in the instruction. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> According to another aspect of the present invention, there is provided a method of executing instructions on operands comprising a plurality of packed objects, the method including: accessing at least one source operand store holding a plurality of packed objects in respective lanes; determining which of a plurality of control stores is to control per lane execution of an instruction based on a field of the instruction; accessing a control store to determine for each lane whether or not to perform the instruction on that lane, the control store comprising a plurality of indicators indicating for each lane whether or not an operation defined in the instruction is to be performed on that lane; and performing the operation and updating a destination store only in those lanes for which the indicators indicate that the operation should be performed. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> According to another aspect of the present invention, there is provided a computer program for performing preferred methods. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> In this embodiment, the control stores are predicate registers and flags in each predicate register are set TRUE or FALSE and there is one corresponding to each byte lane. If a lane is predicated TRUE, then the result of the conditional operation will be written into that byte lane of the destination register. If a lane is predicated FALSE then the result of the conditional operation is not written to that byte lane of the destination register. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> According to another aspect of the present invention, there is provided a computer system for performing operations on a variety of lane sizes, wherein a mechanism for conditional execution of the smallest lane size is provided, together with a mechanism for setting conditional execution flags individually or in predetermined numbers. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> According to another aspect of the present invention, there is provided a method for setting indicators in a control store of a computer system for conditionally performing operations, comprising: providing a control store setting instruction defining an execution condition and specifying a control store to be set according to the condition; specifying in the instruction an operand lane size over which a setting operation is to be performed, the operand lane size specified being selected from a plurality of predetermined operand lane sizes; performing the setting operation defined in the setting instruction on a per operand lane basis over a plurality of operand lanes; writing the result of the setting operation to the control store specified in the instruction to set a plurality of indicators on a lane by lane basis, wherein one or a predetermined plurality of indicators is set for each operand lane in dependence on the size of the operand lane defined in the instruction. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> Additional objects, advantages and novel features of the invention will be set forth in part in the description which follows, and in part will become apparent to those skilled in the art upon examination of the following and the accompanying drawings or may be learned by practice of the invention. The objects and advantages of the invention may be realized and attained by means of the instrumentalities and combinations particularly pointed out in the appended claims.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> For a better understanding of the present invention and as to how the same may be carried into effect, reference will now be made by way of example to the accompanying drawings in which: </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a schematic block diagram illustrating a computer system embodying the present invention; </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a diagram illustrating general formats for encoding instructions processed by the computer system of <cross-reference target="DRAWINGS">FIG. 1</cross-reference>; </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> illustrates differing degrees of packing in a general purpose register for holding packed objects defining operand lanes; </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a schematic diagram illustrating how an operation is performed on respective lanes of a packed operand; </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a schematic block diagram illustrating a predicate register; </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6A</cross-reference> illustrates a number of 64-bit long instruction words; </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6B</cross-reference> illustrates a number of 32-bit instruction formats suitable for inclusion in a 64-bit instruction; </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7A</cross-reference> schematically illustrates an operation performed conditionally on byte sized packed objects; </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7B</cross-reference> schematically illustrates an operation performed conditionally on word sized packed objects; </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8A</cross-reference> schematically illustrates a first example of a predicate register setting operation; </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8B</cross-reference> schematically illustrates a second example of a predicate register setting operation; </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9A</cross-reference> illustrates a third example of a predicate register setting operation; </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9B</cross-reference> illustrates a fourth example of a predicate register setting operation; </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10</cross-reference> illustrates a fifth example of a predicate register setting operation; and </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 11</cross-reference> schematically illustrates a sequence of instructions performed by the computer system of <cross-reference target="DRAWINGS">FIG. 1</cross-reference>.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS </heading>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> Reference now is made in detail to the presently preferred embodiments of the invention, examples of which are illustrated in the accompanying drawings and discussed below. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> illustrates a computer system embodying the present invention. The computer system is a 64 bit long instruction word machine including two identical Single Instruction Multiple Data (SIMD) units designated by reference numerals X and Y. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> The computer system includes an instruction cache <highlight><bold>3</bold></highlight> for receiving and holding instructions from a program memory (not shown). The instruction cache <highlight><bold>3</bold></highlight> is connected to instruction fetch/decode circuitry <highlight><bold>4</bold></highlight>. The fetch/decode circuitry <highlight><bold>4</bold></highlight> issues addresses in the program memory from which instructions are to be fetched and receives on each fetch operation a 64 bit instruction from the cache <highlight><bold>3</bold></highlight> (or program memory). </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> The computer system has two SIMD execution units <highlight><bold>8</bold></highlight><highlight><italic>x, </italic></highlight><highlight><bold>8</bold></highlight><highlight><italic>y, </italic></highlight>one on the X-side of the machine and one on the Y-side. Each of the SIMD execution units <highlight><bold>8</bold></highlight><highlight><italic>x, </italic></highlight><highlight><bold>8</bold></highlight><highlight><italic>y </italic></highlight>includes three data processing units, namely: a Multiplier Accumulator Unit MAC, an Integer Unit INT and a Galois Field Unit GFU. A Load/Store Unit LSU <highlight><bold>6</bold></highlight><highlight><italic>x, </italic></highlight><highlight><bold>6</bold></highlight><highlight><italic>y </italic></highlight>is provided on each of the X and Y-side SIMD units. The computer system includes a dual port data cache <highlight><bold>15</bold></highlight> connected to both the X and Y-side SIMD units and a data memory (not shown). The fetch decode circuitry <highlight><bold>4</bold></highlight> evaluates the opcode and transmits control signals along the channels <highlight><bold>5</bold></highlight><highlight><italic>x, </italic></highlight><highlight><bold>5</bold></highlight><highlight><italic>y </italic></highlight>to control the movement of data between designated registers and the MAC, INT, GFU and LSU functional units. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> The computer system includes four M-registers <highlight><bold>10</bold></highlight> for holding multiply-accumulate results and sixty-four general purpose registers <highlight><bold>11</bold></highlight> including R-registers, each of which is 64 bits wide and &ldquo;programmer visible&rdquo;. The M-registers are wider than the R-registers, the additional precision being used to accommodate the results of multiply accumulate operations. The computer system has a plurality of control registers <highlight><bold>13</bold></highlight>. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> The control registers <highlight><bold>13</bold></highlight> include a Processor State Register PSR, a Machine State Register MSR, a Program Counter PC register and eight predicate registers <highlight><bold>18</bold></highlight>. Processor status information is stored in the PSR and the MSR sticky bits. Rounding and saturation modes and multiply-accumulate pipe control information is stored in the MSR. The predicate registers <highlight><bold>18</bold></highlight> provide a means for conditionally carrying out operations on a per SIMD lane basis. The processor also has a further set of DIR registers (not shown) which allow interrupt status and timers to be managed. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> With reference to <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, each 64 bit instruction is a long instruction word. The long instruction word may define a single operation according to a long instruction format <highlight><bold>20</bold></highlight> or two independent operations (Inst <highlight><bold>1</bold></highlight>, Inst <highlight><bold>2</bold></highlight>) according to a shorter 32-bit instruction format <highlight><bold>22</bold></highlight>. Examples of long and short instruction formats are provided later with reference to <cross-reference target="DRAWINGS">FIGS. 6A and 6B</cross-reference>. Each of the X and Y sides of the machine are thus capable of 64 bit execution on multiple data units, for example on four <highlight><bold>16</bold></highlight> bit packed operands at once under the control of the relevant 32-bit instruction. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> Each of the MAC, INT, GFU and LSU operate on a Single Instruction Multiple Data (SIMD) principle according to the SIMD lane expressed in the instruction. Data processing operations operate on 64 bits of information at the same time, but may treat the information as eight bytes, four half words, two words or one long word according to a protocol defining the degree of packing of objects for packed data processing operations. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> The degree of packing of objects is defined according to the following protocol: </paragraph>
<paragraph id="P-0037" lvl="2"><number>&lsqb;0037&rsqb;</number> B&mdash;8 bit objects (also referred to as bytes B<highlight><subscript>0 </subscript></highlight>. . . B<highlight><subscript>7</subscript></highlight>); </paragraph>
<paragraph id="P-0038" lvl="2"><number>&lsqb;0038&rsqb;</number> H&mdash;16 bit objects (also referred to as half words H<highlight><subscript>0 </subscript></highlight>. . . H<highlight><subscript>3</subscript></highlight>); </paragraph>
<paragraph id="P-0039" lvl="2"><number>&lsqb;0039&rsqb;</number> W&mdash;32 bit objects (also referred to as words W<highlight><subscript>0 </subscript></highlight>. . . W<highlight><subscript>1</subscript></highlight>); </paragraph>
<paragraph id="P-0040" lvl="2"><number>&lsqb;0040&rsqb;</number> L&mdash;64 bit objects (also referred to as long words L); </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> A Dual operation is a special type of operation which uses even/odd pairs of registers to perform operations on 128 bits of information at the same time: </paragraph>
<paragraph id="P-0042" lvl="2"><number>&lsqb;0042&rsqb;</number> DL&mdash;128 bit objects (also referred to as double long words DL). </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> In the case of floating point processing operations data may be handled with two differing degrees of precision, namely: </paragraph>
<paragraph id="P-0044" lvl="2"><number>&lsqb;0044&rsqb;</number> S&mdash;32 bit floating point values (also referred to as single precision); and </paragraph>
<paragraph id="P-0045" lvl="2"><number>&lsqb;0045&rsqb;</number> D&mdash;64 bit floating point values (also referred to as double precision). </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> Simultaneous execution in the twin X and Y-side units under the control of a single 32 bit instruction portion is referred to herein as Dual Instruction Multiple Data (DIMD). However, such operations may be regarded as two SIMD instructions being performed in parallel. In general, data operations employ a first operand and a second operand (which may be an immediate value) to produce a result. Each operand is obtained from a source register (unless it is an immediate value) and the result is sent to a destination register. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> illustrates how a general purpose register such as an R-register <highlight><bold>30</bold></highlight> may contain 64 bits of information allocated as eight bytes (B<highlight><subscript>0</subscript></highlight>-B<highlight><subscript>7</subscript></highlight>), four half words (H<highlight><subscript>0</subscript></highlight>-H<highlight><subscript>3</subscript></highlight>), two words (W<highlight><subscript>0</subscript></highlight>, W<highlight><subscript>1</subscript></highlight>) or a single long word (L<highlight><subscript>0</subscript></highlight>). Similarly, floating point values may be stored as 32 bit single precision values S<highlight><subscript>0</subscript></highlight>, S<highlight><subscript>1 </subscript></highlight>or as 64 bit double precision values. Some of the R-registers may be reserved for special purposes. For example in this embodiment, Register <highlight><bold>63</bold></highlight> is hard wired to zero (referred to herein as the &ldquo;Zero Register&rdquo;). Register <highlight><bold>62</bold></highlight> is hard wired to ones (referred to herein as the &ldquo;Ones Register&rdquo;). Registers <highlight><bold>61</bold></highlight> and <highlight><bold>60</bold></highlight> are banked registers. Registers <highlight><bold>56</bold></highlight>-<highlight><bold>59</bold></highlight> are also banked for interrupt purposes. The Zero Register may be used for providing zero as an input to operations and nullifying actions (e.g. discarding the permanent link in branches). Some data processing operations use even/odd pairs of registers as source and destination. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> M-registers are able to contain a double sized product plus a single byte for each SIMD lane. For example, an M-register used to accumulate byte multiplies contains 8 sets of 16&plus;8 bits, where 16 bits is the double size product for a byte and 8 bits is the overflow allowed in the accumulator. Likewise, when used to accumulate half word multiplies an M-register contains 4 sets of 32&plus;8 bits and contains 2 sets of 64&plus;8 bits when used to accumulate word multiplies. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> For each channel <highlight><bold>5</bold></highlight><highlight><italic>x, </italic></highlight><highlight><bold>5</bold></highlight><highlight><italic>y, </italic></highlight>if the instruction defines a data processing unit it is supplied to the appropriate unit of the MAC, INT and the GFU and if it defines a load/store operation it is supplied to the LSU. Data values may be loaded to and from the MAC data processing units into and out of the M-registers <highlight><bold>10</bold></highlight> along register-access paths <highlight><bold>12</bold></highlight><highlight><italic>x </italic></highlight>and <highlight><bold>12</bold></highlight><highlight><italic>y. </italic></highlight>Data values may be loaded to and from the INT, GFU and load/store units into and out of the R-registers along register access paths <highlight><bold>14</bold></highlight><highlight><italic>x </italic></highlight>and <highlight><bold>14</bold></highlight><highlight><italic>y. </italic></highlight>Each register access path can carry register data between the accessing unit, two source addresses src<highlight><bold>1</bold></highlight>, src<highlight><bold>2</bold></highlight> and a destination address dest as specified in the instruction. The register access paths also carry control data to and from the control registers <highlight><bold>13</bold></highlight>. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> In the case of data processing operations, the source addresses src<highlight><bold>1</bold></highlight>, src<highlight><bold>2</bold></highlight> define registers in the register files <highlight><bold>10</bold></highlight> and <highlight><bold>11</bold></highlight>, which hold source operands for processing by the data processing unit. The destination address dest identifies a destination register into which the result of the data processing operation is placed. An optional field in the instruction defines a predicate register in cases where the operation defined in the instruction is to be performed conditionally on multiple SIMD lanes. The operands and results are thus conveyed between the register files <highlight><bold>10</bold></highlight>, <highlight><bold>11</bold></highlight> and the respective functional unit via the access paths <highlight><bold>12</bold></highlight>, <highlight><bold>14</bold></highlight>. In certain types of data processing operations src<highlight><bold>2</bold></highlight> may be replaced by an immediate value as will be explained later. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> In the case of load/store operations, instruction formats use predefined addressing modes to allow memory access addresses Ax, Ay to be formulated from data values held in the registers. The load/store units access a common address space in the form of a data memory (not shown) via the dual ported data cache <highlight><bold>15</bold></highlight>. For this purpose each load/store unit has a 64 bit data bus Dx, Dy and a 64 bit address bus Ax, Ay. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> illustrates schematically how data processing operations performed in the various functional units are capable of acting on 64 bits of information simultaneously on a per SIMD lane basis. In general, operations may be regarded as working in vertical lanes having a width corresponding to the size of the packed objects of the operands. Assume a 32-bit instruction causes an ADD data processing operation. The ADD instruction has the following semantics ADD&lcub;B/H/W&rcub;, dest, src<highlight><bold>1</bold></highlight>, src<highlight><bold>2</bold></highlight>. The operation shown in <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is an ADDB operation and thus treats the data as byte packed data. The instruction specifies first and second 64-bit source registers src<highlight><bold>1</bold></highlight>, src<highlight><bold>2</bold></highlight>, each source register containing byte packed operands for the addition operation. The instruction also specifies a 64-bit destination register dest for holding the result of the addition operation. A first plurality of byte sized operands B<highlight><subscript>0</subscript></highlight>-B<highlight><subscript>7 </subscript></highlight>are held in the first source register src<highlight><bold>1</bold></highlight>. A second plurality of byte sized operands are held in the second source register src<highlight><bold>2</bold></highlight>. Addition circuitry <highlight><bold>40</bold></highlight> connected between the source and destination registers comprises eight operators, in this case addition circuits. Each operator is connected to receive two byte sized objects, one from each lane B<highlight><subscript>0</subscript></highlight>-B<highlight><subscript>7 </subscript></highlight>of the source registers src<highlight><bold>1</bold></highlight>, src<highlight><bold>2</bold></highlight> (only selected connections are shown in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>). The operators perform the ADD operation on the byte packed objects and the results are sent to equivalent bit locations in the destination register dest. Alternative versions of the ADD instruction, namely ADDW and ADDH, treat the 64-bits of data as two words and four half words respectively. It is of course possible for some operations to work horizontally (i.e. across columns in a row). </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> The computer system of <cross-reference target="DRAWINGS">FIG. 1</cross-reference> provides for conditional execution of multiple data processing operations on a per SIMD lane basis, lane size being defined by the degree of packing of operands. To achieve this the control registers <highlight><bold>13</bold></highlight> include eight predicate registers pr<highlight><bold>0</bold></highlight>-pr<highlight><bold>7</bold></highlight> such as that illustrated in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>. Each predicate register <highlight><bold>50</bold></highlight> is eight bits 0-7 in size, having one bit value (TRUE or FALSE) for each of the eight byte lanes B<highlight><subscript>0</subscript></highlight>-B<highlight><subscript>7</subscript></highlight>. The individual bits of a predicate register can be set TRUE or FALSE as desired. When an SIMD instruction is processed the operation defined in the instruction is only performed on byte lanes where the controlling predicate register bit is TRUE. No operations are executed on byte lanes where the controlling predicate register bits are FALSE. In this embodiment, one predicate register pr<highlight><bold>7</bold></highlight> is permanently set with all bits TRUE. The predicate registers can be accessed from both the X and Y-sides of the machine for the purposes being set and of controlling conditional execution. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> An instruction for an operation which is to be conditionally executed per lane includes a field indicating which of the eight predicate registers should control the operation defined in the instruction. The decode circuitry includes control circuitry for determining a controlling predicate register from this field, and flags within the controlling predicate register are checked by predicate checking circuitry. Each bit <highlight><bold>0</bold></highlight>-<highlight><bold>7</bold></highlight> of the designated predicate register controls the correspondingly numbered byte lane B<highlight><subscript>0</subscript></highlight>-B<highlight><subscript>7 </subscript></highlight>used in the operation. That is, bit i of the designated predicate register controls the conditional execution of SIMD byte lane i. Non-SIMD instructions are controlled by bit <highlight><bold>0</bold></highlight> of the designated predicate register and therefore the entire non-SIMD operation is executed in dependence on whether or not that bit is TRUE or FALSE. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 6A and 6B</cross-reference> show examples of instruction formats for use with the computer system of <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. The instruction formats use 64-bit long instruction words. The X and Y side operations are generally independent, although registers may be shared. An opcode major field comprises the first two bits of each instruction portion (i.e. bits <highlight><bold>63</bold></highlight>, <highlight><bold>62</bold></highlight>; <highlight><bold>31</bold></highlight>, <highlight><bold>30</bold></highlight>). The opcode major field in combination with the opcode field defines the type of operation to be performed. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 6</cross-reference>A, the normal long instruction format <highlight><bold>20</bold></highlight><highlight><italic>a </italic></highlight>comprises an X-side 32-bit instruction portion and a Y-side 32-bit instruction portion packed into a single 64-bit instruction. Each 32-bit instruction portion may take any of the 32-bit formats disclosed in <cross-reference target="DRAWINGS">FIG. 6B</cross-reference>. These 32-bit instruction formats may define a single operation or two separate operations which may be freely mixed (i.e. used in any combination). For example, it is possible to perform eight separate byte adds and four separate half word multiplies at the same time, the add and multiply operations being defined in separate halves of the long instruction. In this example, the X-side opcode major field defined by bits <highlight><bold>63</bold></highlight>, <highlight><bold>62</bold></highlight> takes a value from 0-2, with bits <highlight><bold>61</bold></highlight>-<highlight><bold>32</bold></highlight> available as an X-side opcode field. Likewise, the Y-side opcode major field defined by bits <highlight><bold>31</bold></highlight>, <highlight><bold>30</bold></highlight> takes a value from 0-2, with bits <highlight><bold>29</bold></highlight>-<highlight><bold>0</bold></highlight> available as a Y-side opcode field. Thus, in the case of normal instructions these opcode major fields take values from 0-2, with the value of 3 being reserved for special operations. </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> This embodiment also supports a long immediate instruction <highlight><bold>20</bold></highlight><highlight><italic>b </italic></highlight>in which a 32 bit immediate value is defined by bits in both the X and Y-side portions of the instruction. The X-side of the instruction defines the beginning of the long immediate value and the Y-side of the instruction carries the extra bits to make up the long immediate value. The X-side opcode major field defined by bits <highlight><bold>63</bold></highlight>, <highlight><bold>62</bold></highlight> takes a value 0-2 and opcode bits <highlight><bold>61</bold></highlight>-<highlight><bold>32</bold></highlight> define a first operand together with a first 8 bit portion of the long immediate value. The Y-side opcode major field defined by bits <highlight><bold>31</bold></highlight>, <highlight><bold>30</bold></highlight> takes a value of 1 and the opcode bits <highlight><bold>29</bold></highlight>-<highlight><bold>0</bold></highlight> contain the additional 24 bits required to specify a 32-bit immediate value. Long immediate instructions are thus 64-bit instructions which allow most of the Register/Immediate ALU operations to be performed using a 32-bit immediate value. Long immediate instructions are performed on the X-side of the machine while the Y-side of the machine is redundant. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> A data processing operation may be combined with a load store operation. The data processing operation is defined in the X-side instruction portion (bits <highlight><bold>63</bold></highlight>-<highlight><bold>32</bold></highlight>) and the load/store operation is defined in the Y-side instruction portion (bits <highlight><bold>31</bold></highlight>-<highlight><bold>0</bold></highlight>). According to a special case, dualable load/store operations allow movement of 128 bit values into and out of consecutive (paired) 64 bit registers and may be combined with dual execute operations (e.g. ALU<highlight><bold>2</bold></highlight> or MAC<highlight><bold>2</bold></highlight> operations) which act on all operands held in the paired registers at the same time. Dual execute operations use even/odd pairs of registers for the two source registers and the destination register and execute on both the X and Y sides of the machine simultaneously. Dual execute operations can be performed conditionally under the control of pairs of predicate registers. Referring to the long instruction format designated by reference numeral <highlight><bold>20</bold></highlight><highlight><italic>c, </italic></highlight>the X-side opcode major field defined by bits <highlight><bold>63</bold></highlight>, <highlight><bold>62</bold></highlight> takes a value of 0-2 and the X-side opcode bits <highlight><bold>61</bold></highlight>-<highlight><bold>32</bold></highlight> define an operation (for example, an ALU or ALU<highlight><bold>2</bold></highlight> operation). The load/store operation is defined by the opcode major field (bits <highlight><bold>31</bold></highlight>, <highlight><bold>30</bold></highlight>) which takes a value of 3 and opcode bits <highlight><bold>29</bold></highlight>-<highlight><bold>0</bold></highlight>. The load/store operation runs on the Y-side of the machine. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> Another long instruction format <highlight><bold>20</bold></highlight><highlight><italic>d </italic></highlight>using an X-side instruction portion having an opcode major field of <highlight><bold>3</bold></highlight> and Y-side opcode major bits taking a value of 0-3 is reserved for special functions not defined herein. </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6B</cross-reference> shows examples of 32-bit instruction formats which this embodiment uses to define the or each operation in the long instruction word. In each case an optional predicate register field (Psrc) indicates which of the eight predicate registers controls per lane execution of the operation defined in the instruction. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> In general, all src/link fields designate R registers. The src<highlight><bold>1</bold></highlight> and dest fields may designate R register pairs. The dest field may designate an R-, M- or predicate register. </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> Register/Register instructions <highlight><bold>22</bold></highlight><highlight><italic>a </italic></highlight>provide a full set of SIMD data processing operations. Operands are taken from first and second register sources and the result is allocated to a destination register. In general Register/Register 32 bit instruction formats <highlight><bold>22</bold></highlight><highlight><italic>a </italic></highlight>include a controlling predicate field (Psrc, bits <highlight><bold>0</bold></highlight>-<highlight><bold>2</bold></highlight>), a destination register field (Gdest, bits <highlight><bold>3</bold></highlight>-<highlight><bold>8</bold></highlight>) and two source register fields (Gsrc<highlight><bold>1</bold></highlight>, bits <highlight><bold>9</bold></highlight>-<highlight><bold>14</bold></highlight>; and Gsrc <highlight><bold>2</bold></highlight>, bits <highlight><bold>15</bold></highlight>-<highlight><bold>20</bold></highlight>) and an opcode major field taking a zero value (bits <highlight><bold>31</bold></highlight>, <highlight><bold>30</bold></highlight>). The remaining bits are available as opcode bits to define the operation. For compare/test operations the Gdest field indicates a predicate register to be written to as will be illustrated later. For MAC operations the Gdest field designates an M-register. </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> Register/Immediate instructions <highlight><bold>22</bold></highlight><highlight><italic>b </italic></highlight>provide a set of SIMD data processing operations using as operands the contents of a source register and a (replicated) immediate value. The result is placed in another register. To perform this type of operation the second source register is replaced with an 8-bit immediate value Imm8. Thus, Register/Immediate instructions <highlight><bold>22</bold></highlight><highlight><italic>b </italic></highlight>include a controlling predicate field (Psrc, bits <highlight><bold>0</bold></highlight>-<highlight><bold>2</bold></highlight>), a destination register field (Gdest, bits <highlight><bold>3</bold></highlight>-<highlight><bold>8</bold></highlight>), a source register field (Gsrc<highlight><bold>1</bold></highlight>, bits <highlight><bold>9</bold></highlight>-<highlight><bold>14</bold></highlight>), an immediate field (bits <highlight><bold>15</bold></highlight>-<highlight><bold>22</bold></highlight>) and an opcode major field taking a value of 1 (bits <highlight><bold>31</bold></highlight>, <highlight><bold>30</bold></highlight>), with remaining bits available to define the operation. The immediate field is an 8-bit value representing a number between 0-255. Immediate values are extended by zeros to the lane size of the SIMD operation (b, h, w, <highlight><bold>1</bold></highlight>) and then replicated across each of the SIMD lanes. </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> As mentioned with reference to <cross-reference target="DRAWINGS">FIG. 6A</cross-reference> long immediate instructions are 64 bit instructions allowing register/immediate operations to be performed with 32 bit immediate values. Long immediate instructions are run on the X-side of the machine. A 24 bit immediate extension is needed on the Y-side of the machine. An example of a 32-bit instruction portion indicating a 24 bit immediate extension value is designated by reference numeral <highlight><bold>22</bold></highlight><highlight><italic>c. </italic></highlight>Instruction portions carrying 24 bit immediate extensions have an opcode major field taking a value of 1 (bits <highlight><bold>31</bold></highlight>, <highlight><bold>30</bold></highlight>). </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> Thus, it will be apparent that in 32-bit data processing instruction formats 2 bits are used in the opcode major field, 6 bits are used in each register field to indicate source and/or destination registers, 3 bits are used in a predicate field to indicate which, if any, of the eight predicate registers should control conditional execution per lane. The remaining opcode field bits are generally used to provide information on the type of operation, which information is decoded taking into account the values in the X- and Y-side opcode major fields. Where 8 bit or 32 bit immediate values are specified in instructions additional bits are required over and above those required to indicate a register holding a value. That is, two further bits are required to specify an 8 bit immediate value and a total of 26 further bits are required to specify a 32 bit immediate value. </paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> The instruction formats <highlight><bold>22</bold></highlight><highlight><italic>d, </italic></highlight><highlight><bold>22</bold></highlight><highlight><italic>e </italic></highlight>and <highlight><bold>22</bold></highlight><highlight><italic>f </italic></highlight>specify load/store operations employing a range of standard addressing modes. According to this embodiment, loads fetch a single value, i.e. a byte, half word, word or a long word from memory into a register. Where a small value is loaded, the value is loaded into the bottom of the register in question. Where a full 64-bit register has been loaded the value may be treated as a single long word, as two words, four half words or eight bytes. Store operations write a single value, i.e. a byte, half word, word, long word (or double long word) from a register to memory. Where a value is smaller than a register being used, the bottom part of the register is used. Where a full 64-bit value is stored, the contents can be treated as a single long word, two words, four half words, or eight bytes. Even/odd register pairs are provided to accommodate double long word (i.e. 128 bit) load/store operations. </paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> Referring to the 32 bit instruction format <highlight><bold>22</bold></highlight><highlight><italic>d </italic></highlight>load/store register/register operations move register data between a register Gdata and memory. The instruction format <highlight><bold>22</bold></highlight><highlight><italic>d </italic></highlight>includes a controlling predicate field (Psrc, bits <highlight><bold>0</bold></highlight>-<highlight><bold>2</bold></highlight>), a base register field (Gbase, bits <highlight><bold>3</bold></highlight>-<highlight><bold>8</bold></highlight>), a data register field (Gdata, bits <highlight><bold>9</bold></highlight>-<highlight><bold>14</bold></highlight>), an index field (Gsrc<highlight><bold>2</bold></highlight> (index), bits <highlight><bold>15</bold></highlight>-<highlight><bold>20</bold></highlight>), a scale field (scale, bits <highlight><bold>21</bold></highlight>, <highlight><bold>22</bold></highlight>), a word indicator field (W<highlight><subscript>1/0</subscript></highlight>, bit <highlight><bold>24</bold></highlight>), a write back indicator field (W<highlight><subscript>6</subscript></highlight>, bit <highlight><bold>25</bold></highlight>) and an opcode major field (bits <highlight><bold>30</bold></highlight>, <highlight><bold>31</bold></highlight>) taking a value of 0. </paragraph>
<paragraph id="P-0068" lvl="0"><number>&lsqb;0068&rsqb;</number> Referring to the 32-bit instruction format <highlight><bold>22</bold></highlight><highlight><italic>e </italic></highlight>load/store register/offset operations permit load/store operations with data locations defined by an offset coded as a 9 bit twos complement value. This instruction format has some fields in common with the instruction format <highlight><bold>22</bold></highlight><highlight><italic>d </italic></highlight>and these fields have the same definitions here. Load/store register/offset instructions include a 9-bit immediate value (Imm 9, bits <highlight><bold>15</bold></highlight>-<highlight><bold>23</bold></highlight>) used to specify an offset in place of the index value register field. Also included is an &ldquo;address modify&rdquo; indicator field (am, bit <highlight><bold>25</bold></highlight>) and an opcode major field (bits <highlight><bold>30</bold></highlight>, <highlight><bold>31</bold></highlight>) taking a value of 2. </paragraph>
<paragraph id="P-0069" lvl="0"><number>&lsqb;0069&rsqb;</number> Referring to the 32-bit instruction format <highlight><bold>22</bold></highlight><highlight><italic>f, </italic></highlight>a special class of dualable load/store operations may be placed on the Y-side of the machine at the same time as a data processing operation is placed on the X-side of the machine. A dualable load/store instruction includes a type field (Id, bit <highlight><bold>27</bold></highlight>) specifying either a load or a store function, a Y-side dual indicator field (Is<highlight><bold>2</bold></highlight>, bit <highlight><bold>28</bold></highlight>) controlling whether the contents of one or two registers should be transferred in the load store operation, an X-side dual indicator field (ps<highlight><bold>2</bold></highlight>, bit <highlight><bold>29</bold></highlight>) controlling whether or not the X-side data processing operation is to be mirrored on the Y-side, and an opcode major field taking a value of <highlight><bold>3</bold></highlight>. Where the load/store operation is dualled two memory addresses are generated. For example, the bit sequence representing an offset would be supplied from the original Y-side instruction position to both the X- and Y-side load/store units. In this embodiment, the path to the Y-side load/store unit supplies the offset unaltered to the Y-side load/store unit, whereas the path to the X-side load/store unit includes a unitary operator which selectively alters the logical value of at least one bit in the offset bit sequence such that a different memory address is accessed by the X-side. When an X-side data processing operation is mirrored on the Y-side, the various fields of the data processing instruction are additionally transferred to the relevant units(s) on the Y-side with relevant values thereof having been adjusted as necessary. For example, where the X-side data processing operation is mirrored on the Y-side, &ldquo;even&rdquo; source and destination register addresses are supplied to the relevant functional unit on the Y-side, whereas corresponding &ldquo;odd&rdquo; register addresses are supplied to the functional unit on the Y-side. </paragraph>
<paragraph id="P-0070" lvl="0"><number>&lsqb;0070&rsqb;</number> The above load/store instruction formats can define load/store instructions using six standard addressing modes. These address modes are illustrated in Table 1.  
<table-cwu id="TABLE-US-00001">
<number>1</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="84PT" align="left"/>
<colspec colname="2" colwidth="112PT" align="left"/>
<thead>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center">TABLE 1</entry>
</row>
<row>
<entry></entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
<row>
<entry></entry>
<entry>Semantics</entry>
<entry>Function</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="center"/>
<colspec colname="2" colwidth="84PT" align="left"/>
<colspec colname="3" colwidth="112PT" align="left"/>
<tbody valign="top">
<row>
<entry>1</entry>
<entry>&lsqb;&lt;rbase&gt;, &lt;reg&gt;, &lcub;W<highlight><subscript>0</subscript></highlight>/W<highlight><subscript>1</subscript></highlight>&rcub;</entry>
<entry>base &plus; scaled pre-indexed</entry>
</row>
<row>
<entry></entry>
<entry>&lcub;&lt;&lt;shift&rcub;&rsqb;</entry>
</row>
<row>
<entry>2</entry>
<entry>&lsqb;&lt;rbase&gt;, &lt;reg&gt;, &lcub;W<highlight><subscript>0</subscript></highlight>/W<highlight><subscript>1</subscript></highlight>&rcub;</entry>
<entry>base &plus; scaled pre-indexed with write</entry>
</row>
<row>
<entry></entry>
<entry>&lcub;&lt;&lt;shift&rcub;&rsqb; &excl;</entry>
<entry>back</entry>
</row>
<row>
<entry>3</entry>
<entry>&lsqb;&lt;rbase&gt;, &num; &lt;offset&gt;&rsqb;</entry>
<entry>base &plus; offset pre-indexed</entry>
</row>
<row>
<entry>4</entry>
<entry>&lsqb;&lt;rbase&gt;, &num; &lt;offset&gt;&rsqb;</entry>
<entry>base &plus; offset scaled pre-indexed</entry>
</row>
<row>
<entry>5</entry>
<entry>&lt;rbase&gt;, &num; &lt;offset&gt; &excl;</entry>
<entry>base &plus; offset pre-indexed with write</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>back</entry>
</row>
<row>
<entry>6</entry>
<entry>&lsqb;&lt;rbase&gt;&rsqb;, &num; &lt;offset&gt; &excl;</entry>
<entry>base &plus; offset post-indexed with write</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>back</entry>
</row>
<row><entry namest="1" nameend="3" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> In Table 1, &lt; &gt; denotes a mandatory field, &lcub; &rcub; denotes an optional field and / delimits a list of choices. Where &lcub; W<highlight><subscript>0</subscript></highlight>/W<highlight><subscript>1 </subscript></highlight>&rcub; is present but not specified the default id W<highlight><subscript>0</subscript></highlight>. Scale values may be &lt;&lt;1, &lt;&lt;2, or &lt;&lt;3. </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> A first type of address mode (1) uses a base register plus a scaled register pre-indexed addressing mode. According to this mode the address is the unsigned 64-bit contents of the base register plus the signed 32-bit contents of the index register, optionally shifted by the shift amount. </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> A second type of address mode (2) employs a base register plus scaled register pre-indexed address mode with a write back function. According to this mode the address is the unsigned 64-bit contents of the base register plus the signed 32-bit contents of the index register, optionally shifted by a shift amount. The value generated is then written back to the base register. </paragraph>
<paragraph id="P-0074" lvl="0"><number>&lsqb;0074&rsqb;</number> A third type of address mode (3) uses a base register and an immediate offset (pre-indexed). According to his mode the address is the unsigned 64 bit contents of the base register plus an immediate offset. The immediate offset can of course be a positive or negative value. </paragraph>
<paragraph id="P-0075" lvl="0"><number>&lsqb;0075&rsqb;</number> A fourth type of address mode (4) uses a base register and an immediate offset scaled to long words (pre-indexed). In this case the address is the unsigned 64 bit contents of the base register plus the immediate offset scaled to long words. The assembler works out which of the two address forms is required, for example using the non-scaled form. </paragraph>
<paragraph id="P-0076" lvl="0"><number>&lsqb;0076&rsqb;</number> A fifth type of address mode (5) uses a base register and an immediate offset (pre-indexed) with a write back function. The address is the unsigned 64-bit contents of the base register plus the immediate offset and is written back to the base register. </paragraph>
<paragraph id="P-0077" lvl="0"><number>&lsqb;0077&rsqb;</number> A sixth type of address mode (6) uses a base register and an immediate offset (post-indexed) with a write back function. In this case the address is the unsigned 64-bit contents of the base register. However, the value of the base register plus the immediate offset is computed and written back to the base register. </paragraph>
<paragraph id="P-0078" lvl="0"><number>&lsqb;0078&rsqb;</number> The instruction formats <highlight><bold>22</bold></highlight><highlight><italic>g </italic></highlight>and <highlight><bold>22</bold></highlight><highlight><italic>h </italic></highlight>of <cross-reference target="DRAWINGS">FIG. 6B</cross-reference> specify branch operations which in this embodiment may only be issued on the X-side of the machine. The machine can perform long and short branches. Branch instructions to be executed conditionally test the TRUE/FALSE values of bits in predicate registers designated in the Psrc field of the instructions. Long and short instructions are used to implement conditional branches in essentially the same manner as will be described below. A branch may be taken if a particular predicate register bit is TRUE or FALSE and if any or no bits in the predicate register are TRUE. If the branch condition is met, a branch target address is generated and the result is placed back in the PC register. The execution unit thus moves to the branch target address on the next fetch cycle. The old PC register value can be saved in a link register, this allows the called routine to return to the next instruction at a later time. If the branch condition is not met, then no branch target address is generated and the computer system continues executing by moving to the next instruction in the sequence. </paragraph>
<paragraph id="P-0079" lvl="0"><number>&lsqb;0079&rsqb;</number> The 32-bit instruction format <highlight><bold>22</bold></highlight><highlight><italic>g </italic></highlight>is a short instruction format defining the branch target address by means of a value held in a register. Such register values represent a way to change the program counter to an absolute value, to a value from a call saved in a link register or on a stack, or to a calculated value. The instruction format has an opcode major field taking a value of zero. The Gsrc field defined by bits <highlight><bold>15</bold></highlight>-<highlight><bold>20</bold></highlight> designates the register holding the branch target address information. The instruction includes an optional predicate register field Psrc (bits <highlight><bold>0</bold></highlight>-<highlight><bold>2</bold></highlight>) which indicates the predicate register to be accessed in order to establish whether or not to take the branch. The link register field Gdest (bits <highlight><bold>3</bold></highlight>-<highlight><bold>8</bold></highlight>) defines a register for saving the current program count. If a link register field designates the zero register the program count is in effect discarded. The P-bit field (bits <highlight><bold>12</bold></highlight>-<highlight><bold>14</bold></highlight>) is an optional field indicating a specific bit in the designated predicate register. This field is used in branch operations performed conditionally in dependence on the state of a single bit TRUE/FALSE value within a predicate register. The hint field (bit <highlight><bold>24</bold></highlight>) indicates whether or not a branch is likely to be taken. Enabling a programmer to set this field removes the need to store large quantities of history information in order to predict likelihoods. </paragraph>
<paragraph id="P-0080" lvl="0"><number>&lsqb;0080&rsqb;</number> The 32-bit instruction format <highlight><bold>22</bold></highlight><highlight><italic>h </italic></highlight>may be used to define another type of short branch instruction. This instruction format has an opcode major field of 1. This instruction format has a number of fields in common with the instruction format <highlight><bold>22</bold></highlight><highlight><italic>g. </italic></highlight>These common fields serve corresponding purposes and are not discussed again here. An offset is used to define the branch target address. The Imm9 field (bits <highlight><bold>15</bold></highlight>-<highlight><bold>23</bold></highlight>) specifies the offset in the form of a 9-bit immediate value. </paragraph>
<paragraph id="P-0081" lvl="0"><number>&lsqb;0081&rsqb;</number> Where an offset is defined by an immediate value, an immediate extension field may be used to extend the 9-bit immediate value to a 32-bit immediate value. This is achieved by combining instruction format <highlight><bold>22</bold></highlight><highlight><italic>h </italic></highlight>with the instruction format <highlight><bold>22</bold></highlight><highlight><italic>c </italic></highlight>to generate a long branch instruction defined by a 64-bit instruction word. Short branch instructions may be performed in parallel with other instructions, whereas long branch instructions cannot. For an immediate offset, a value of 0 causes the execution unit to move to the next instruction and a value of 1 causes a branch to the next but one instruction. The total range of a long branch instruction is &minus;2147483648 instructions to &plus;2147483647 instructions. The range of short branch instructions is &minus;256 instructions to &plus;255 instructions. </paragraph>
<paragraph id="P-0082" lvl="0"><number>&lsqb;0082&rsqb;</number> The full instruction set will depend on the application. For example, the instruction set is generally capable of executing standard computer languages (such as C, C&plus;&plus; and Java) but is primarily designed for special purpose functions employed in, for example, encoding/decoding communication signals, video processing (e.g. compression, decompression and filtering signals), three-dimensional graphics, image processing, compressing and decompressing moving images and sound, performing voice and/or image recognition functions. A skilled person would readily appreciate that to achieve efficient implementation over a variety of applications it may be necessary for the binary code to differ from one embodiment to another. However, it is possible for all implementations to be compatible at assembly language level and higher levels. </paragraph>
<paragraph id="P-0083" lvl="0"><number>&lsqb;0083&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 7A and 7B</cross-reference> illustrate how operations defined by the instruction formats of <cross-reference target="DRAWINGS">FIGS. 6A and 6B</cross-reference> may be performed conditionally on individual SIMD lanes irrespective of the lane size. <cross-reference target="DRAWINGS">FIG. 7A</cross-reference> is an example of byte level conditional execution and <cross-reference target="DRAWINGS">FIG. 7B</cross-reference> is an example of word level conditional execution. For clarity, the predicate registers illustrated schematically in <cross-reference target="DRAWINGS">FIGS. 7A and 7B</cross-reference> are shown enlarged such that individual bits of the predicate registers correspond in size to byte lanes of the operands. </paragraph>
<paragraph id="P-0084" lvl="0"><number>&lsqb;0084&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7A</cross-reference> shows per lane conditional execution of a SIMD ADDB instruction which treats the register data as eight separate bytes of information. In this example, the ADDB data processing instruction has the following semantics: &lcub;Psrc&rcub;.ADDB dest, src<highlight><bold>1</bold></highlight>, src<highlight><bold>2</bold></highlight>. Thus, the instruction specifies a first 64-bit source register src<highlight><bold>1</bold></highlight>, a second 64-bit source register src<highlight><bold>2</bold></highlight> and a destination register dest. The optional Psrc field specifies a predicate register to control conditional execution of each of the SIMD lanes. Each source register src<highlight><bold>1</bold></highlight>, src<highlight><bold>2</bold></highlight> contains a plurality of byte sized operands for the addition operation and the destination register dest is for holding the results. The Psrc field indicates the predicate register pr<highlight><bold>5</bold></highlight> as the controlling predicate register for the operation. The ADDB operation is executed conditionally on a per lane B<highlight><subscript>0</subscript></highlight>-B<highlight><subscript>7 </subscript></highlight>basis with byte level predication determined by the TRUE/FALSE values of the corresponding bits <highlight><bold>0</bold></highlight>-<highlight><bold>7</bold></highlight> of the predicate register. Corresponding byte sized objects are supplied to addition circuitry <highlight><bold>40</bold></highlight> as described in relation to <cross-reference target="DRAWINGS">FIG. 4</cross-reference>. An output from predicate checking logic controls a set of switches <highlight><bold>52</bold></highlight>, one for each byte lane B<highlight><subscript>0</subscript></highlight>-B<highlight><subscript>7</subscript></highlight>. These switches control whether or not the results of the addition operation are written to the corresponding byte lane of the dest register. Since in this example bits <highlight><bold>0</bold></highlight>, <highlight><bold>3</bold></highlight>, <highlight><bold>4</bold></highlight>, <highlight><bold>5</bold></highlight>, <highlight><bold>6</bold></highlight> and <highlight><bold>7</bold></highlight> are TRUE only the results for byte lanes B<highlight><subscript>0</subscript></highlight>, B<highlight><subscript>3</subscript></highlight>, B<highlight><subscript>4</subscript></highlight>, B<highlight><subscript>5</subscript></highlight>, B<highlight><subscript>6</subscript></highlight>, B<highlight><subscript>7 </subscript></highlight>are written to the destination register. The results for byte lanes B<highlight><subscript>1 </subscript></highlight>and B<highlight><subscript>2 </subscript></highlight>are not written to the destination register since predicate bits <highlight><bold>1</bold></highlight> and <highlight><bold>2</bold></highlight> are FALSE, as illustrated by the crosses on <cross-reference target="DRAWINGS">FIG. 7A</cross-reference>. </paragraph>
<paragraph id="P-0085" lvl="0"><number>&lsqb;0085&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7B</cross-reference> is a simplified schematic illustration omitting apparatus features. In this example an ADDW instruction specifies that register data should be treated as words the operation is performed at word level. Predication is performed in the same way as before (i.e. at byte level) with bits <highlight><bold>0</bold></highlight>-<highlight><bold>3</bold></highlight> of the predicate register controlling conditional execution of the first word lane W<highlight><subscript>0 </subscript></highlight>and bits <highlight><bold>4</bold></highlight>-<highlight><bold>7</bold></highlight> of the predicate register controlling conditional execution of the second word lane W<highlight><subscript>1</subscript></highlight>. </paragraph>
<paragraph id="P-0086" lvl="0"><number>&lsqb;0086&rsqb;</number> Thus, using the above-described predication technique operations can be performed conditionally on packed objects of any predetermined size. Operations defined in the instruction formats are carried out on each &ldquo;lane&rdquo; of the operand, that is on each pair of corresponding packed objects in respective source registers src<highlight><bold>1</bold></highlight>, src<highlight><bold>2</bold></highlight> or source register and immediate value as the case may be. </paragraph>
<paragraph id="P-0087" lvl="0"><number>&lsqb;0087&rsqb;</number> Setting operations can be used to set bits of the predicate registers in dependence on predetermined test conditions. Predicate setting instructions have the following general form. </paragraph>
<paragraph id="P-0088" lvl="2"><number>&lsqb;0088&rsqb;</number> &lcub;Psrc&rcub;.SETOP TSTID B/H/W, Pr$, src<highlight><bold>1</bold></highlight>, src<highlight><bold>2</bold></highlight> </paragraph>
<paragraph id="P-0089" lvl="0"><number>&lsqb;0089&rsqb;</number> The &lcub;Psrc&rcub; is an optional field which may be used to designate a controlling predicate register if the predicate setting operation is to be predicated. The SETOP field specifies the type of operation which will be used to set the predicate register. For example, the TRUE/FALSE values of the bits in predicate registers can be set by a specific integer arithmetic comparison operation (CMP), a boolean bit test operation (TST) or a floating point comparison operation (FCMP). The TSTID field indicates the test to be performed. For example, in the case of compare operations an arithmetic test is specified in this bit sequence, for boolean test operations a logical test is specified and for floating operations a floating point test is specified. The Pr$ field designates one of the eight predicate registers to be set. The src<highlight><bold>1</bold></highlight> and src<highlight><bold>2</bold></highlight> fields specify first and second operand source registers for the predicate setting operation. Thus, instructions defining predicate setting operations do not have a destination field as such. The 6 bits used to specify a destination register for data processing operations, namely the Gdest field of instruction formats <highlight><bold>22</bold></highlight><highlight><italic>a </italic></highlight>and <highlight><bold>22</bold></highlight><highlight><italic>b </italic></highlight>(see <cross-reference target="DRAWINGS">FIG. 6B</cross-reference>) are used differently. TSTID and Pr$ fields each require 3 bits and occupy a bit sequence equivalent in size to the destination register field of a data processing operation. In this embodiment, the B/H/W/L indication of an instruction is encoded as part of the opcode field. In other embodiments, different encoding schemes may be used. For example, it would be equally feasible to design a binary encoding scheme with a special 2 bit field carrying this information. </paragraph>
<paragraph id="P-0090" lvl="0"><number>&lsqb;0090&rsqb;</number> A class of ORSET tests set the destination predicate register only if the result is TRUE. For example, a &ldquo;compareOR&rdquo; operation sets predicate register bits only if the result of a compare operation is TRUE. That is, a positive result sets to TRUE and a negative result gives no change. This is achieved by predicating the writing of the value in the destination register with the value itself. The instruction CMPORLEB, Pr<highlight><bold>1</bold></highlight>, src<highlight><bold>1</bold></highlight>, src<highlight><bold>2</bold></highlight> provides an OR test applied between the old Pr<highlight><bold>1</bold></highlight> bit value and the result of the comparison operation src<highlight><bold>1</bold></highlight>&lE;src<highlight><bold>2</bold></highlight>. Thus, overall a Pr<highlight><bold>1</bold></highlight> bit value is set TRUE if either the old OR the new result is TRUE. Again, the assembler language may use synonyms for related types of operation (e.g. CMPOR, TSTOR, FCMPOR). </paragraph>
<paragraph id="P-0091" lvl="0"><number>&lsqb;0091&rsqb;</number> Table <highlight><bold>2</bold></highlight> illustrates SETOP and TSTID fields for various types of predicate setting operation. Typically the SETOP and TSTID fields are combined in a single large field.  
<table-cwu id="TABLE-US-00002">
<number>2</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="35PT" align="center"/>
<colspec colname="3" colwidth="98PT" align="left"/>
<colspec colname="4" colwidth="49PT" align="left"/>
<thead>
<row>
<entry namest="1" nameend="4" align="center">TABLE 2</entry>
</row>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="4" align="center" rowsep="1"></entry>
</row>
<row>
<entry>SETOP</entry>
<entry>TSTID</entry>
<entry>FUNCTION</entry>
<entry>EXAMPLE</entry>
</row>
<row><entry namest="1" nameend="4" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>CMP</entry>
<entry>GT</entry>
<entry>Signed greater than</entry>
<entry>e.g. CMPGT</entry>
</row>
<row>
<entry></entry>
<entry>HI</entry>
<entry>Unsigned higher than</entry>
</row>
<row>
<entry></entry>
<entry>LE</entry>
<entry>Signed less than or equal</entry>
</row>
<row>
<entry></entry>
<entry>LS</entry>
<entry>Unsigned lower than or same</entry>
</row>
<row>
<entry>FCMP</entry>
<entry>EQ</entry>
<entry>Equal</entry>
<entry>e.g. FCMPGT</entry>
</row>
<row>
<entry></entry>
<entry>NE</entry>
<entry>Not equal</entry>
</row>
<row>
<entry></entry>
<entry>GE</entry>
<entry>Greater than or equal</entry>
</row>
<row>
<entry></entry>
<entry>GT</entry>
<entry>Greater than</entry>
</row>
<row>
<entry></entry>
<entry>LE</entry>
<entry>Less than or equal</entry>
</row>
<row>
<entry></entry>
<entry>LT</entry>
<entry>Less than</entry>
</row>
<row>
<entry></entry>
<entry>NF</entry>
<entry>Infinity of NaN</entry>
</row>
<row>
<entry></entry>
<entry>UN</entry>
<entry>Unordered</entry>
</row>
<row>
<entry>TST</entry>
<entry>EQ</entry>
<entry>Equal</entry>
<entry>e.g. TSTNE</entry>
</row>
<row>
<entry></entry>
<entry>NE</entry>
<entry>Not equal</entry>
</row>
<row>
<entry></entry>
<entry>ZE</entry>
<entry>Zero (for bitwise AND)</entry>
</row>
<row>
<entry></entry>
<entry>NZ</entry>
<entry>Not zero (for bitwise AND)</entry>
</row>
<row>
<entry></entry>
<entry>BC</entry>
<entry>Bit clear</entry>
</row>
<row>
<entry></entry>
<entry>BS</entry>
<entry>Bit set (dyadic by bit number)</entry>
</row>
<row><entry namest="1" nameend="4" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0092" lvl="0"><number>&lsqb;0092&rsqb;</number> CMPOR type operations can employ the same tests as the CMP type operations. FCMPOR type operations can use any test indicated for FCMP operations. TSTOR operations can use the same tests as TST operations. </paragraph>
<paragraph id="P-0093" lvl="0"><number>&lsqb;0093&rsqb;</number> Predicate setting operations set respective bits of the predicate register designated in the instruction in dependence on the result of the test on each byte lane. In predicate setting instructions the destination register field indicates a predicate register. Byte level tests set respective individual bits in the designated predicate register to the result on each byte lane. Half word tests set adjacent bit pairs in the designated predicate register to the result of the test on each half word lane. Likewise, word level tests set groups of four adjacent bits in the designated predicate register to the result of the test on each word lane and long word tests set all eight bits in a predicate register to the result of the long word test. </paragraph>
<paragraph id="P-0094" lvl="0"><number>&lsqb;0094&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8A</cross-reference> illustrates how a comparison operation, such as a specific integer arithmetic comparison on byte sized packed objects (CMPLTB) can be used to set individual TRUE/FALSE values in a predicate register. An instruction format based on the Register/Register instruction format designated by referenced numeral <highlight><bold>22</bold></highlight><highlight><italic>a </italic></highlight>of <cross-reference target="DRAWINGS">FIG. 6B</cross-reference> is used to define this compare operation. The &ldquo;compare less than&rdquo; instruction has the following semantics: &lcub;Psrc&rcub;.CMPLT&lcub;B/H/W&rcub;, dest, src<highlight><bold>1</bold></highlight>, src<highlight><bold>2</bold></highlight>. The first and second source fields src<highlight><bold>1</bold></highlight>, src<highlight><bold>2</bold></highlight> specify registers holding values to be compared in the operation and the destination register field dest indicates a predicate register to which the results are to be written. The Psrc field is an optional field used to indicate a controlling predicate register. In this example, the instruction CMPLTB Pr<highlight><bold>1</bold></highlight>, src<highlight><bold>1</bold></highlight>, src<highlight><bold>2</bold></highlight> compares byte sized packed objects held in the first source register src<highlight><bold>1</bold></highlight> with corresponding byte sized packed objects in the second source register src<highlight><bold>2</bold></highlight> to test on a per lane B<highlight><subscript>0</subscript></highlight>-B<highlight><subscript>7 </subscript></highlight>basis whether values in src<highlight><bold>1</bold></highlight> are less than corresponding src<highlight><bold>2</bold></highlight> values. The test result for each lane is written to the corresponding bit position <highlight><bold>0</bold></highlight>-<highlight><bold>7</bold></highlight> in the predicate register pr<highlight><bold>1</bold></highlight>. That is, for each lane the corresponding bit in the predicate register pr<highlight><bold>1</bold></highlight> is set TRUE (1) if the less than test applies and FALSE (0) otherwise. In this example, the less than test is positive for byte lanes B<highlight><subscript>0</subscript></highlight>, B<highlight><subscript>1</subscript></highlight>, B<highlight><subscript>2</subscript></highlight>, B<highlight><subscript>4</subscript></highlight>, B<highlight><subscript>6</subscript></highlight>, B<highlight><subscript>7 </subscript></highlight>and negative for byte lanes B<highlight><subscript>3 </subscript></highlight>and B<highlight><subscript>5</subscript></highlight>. As a result, bits <highlight><bold>0</bold></highlight>, <highlight><bold>1</bold></highlight>, <highlight><bold>2</bold></highlight>, <highlight><bold>4</bold></highlight>, <highlight><bold>6</bold></highlight> and <highlight><bold>7</bold></highlight> of the predicate register are set TRUE (1), whereas, bits <highlight><bold>3</bold></highlight> and <highlight><bold>5</bold></highlight> are set FALSE (0). </paragraph>
<paragraph id="P-0095" lvl="0"><number>&lsqb;0095&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8B</cross-reference> is a schematic diagram illustrating that operations on packed objects of any predetermined size may be used to set a plurality of TRUE/FALSE values in predicate registers simultaneously. In this example a word level comparison operation is used to write to sets of 4 bits in a predicate register. According to the instruction CMPLTW Pr<highlight><bold>1</bold></highlight>, src<highlight><bold>1</bold></highlight>, src<highlight><bold>2</bold></highlight>, word sized packed objects held in the first source register src<highlight><bold>1</bold></highlight> are compared with corresponding word sized packed objects in the second source src<highlight><bold>2</bold></highlight> register to test for a less than relationship. The word level comparison performs two comparison sub-operations, rather than eight or four as would be required in byte or half word comparison operations, respectively. Each comparison operation sets four bits of the predicate register at the same time. The predicate bits are set TRUE (1) if the less than condition is met and FALSE (0) otherwise. The first word W<highlight><subscript>0 </subscript></highlight>comparison writes to predicate bits <highlight><bold>0</bold></highlight>, <highlight><bold>1</bold></highlight>, <highlight><bold>2</bold></highlight> and <highlight><bold>3</bold></highlight> and the second word W<highlight><subscript>1 </subscript></highlight>comparison writes to predicate bits <highlight><bold>4</bold></highlight>, <highlight><bold>5</bold></highlight>, <highlight><bold>6</bold></highlight> and <highlight><bold>7</bold></highlight>. </paragraph>
<paragraph id="P-0096" lvl="0"><number>&lsqb;0096&rsqb;</number> There are many types of comparison and other test operations which can apply test conditions to set predicate registers. A predicate register can be set to a state with every bit TRUE by testing the Zero Register for equality with itself. An instruction for this purpose reads TSTEQL Psrc , ZR, ZR. Likewise, a predicate register can be set to a state with every bit FALSE by testing the Zero Register for inequality with itself An instruction for this purpose reads TSTNEL Psrc, ZR, ZR. </paragraph>
<paragraph id="P-0097" lvl="0"><number>&lsqb;0097&rsqb;</number> Thus, in preferred embodiments only byte-wise (per byte) conditional execution need be supported. Predicate register setting processes employ per (operand) lane operations to set a predetermined number of predicate bits in a designated predicate register and, therefore, necessarily generate (fewer bits of condition result than would normally arise from the operation. It is possible to drive the per byte conditional execution of instructions by means of predicate setting operations using operands of any size (eg B/H/W/L). The ability to perform predicate setting operations over different (operand) lane sizes allows predicate bit setting operations to replicate predicate bits as necessary. That is, predicate setting operations can set individual bits or groups of bits simultaneously by specifying in instructions the lane size over which the setting operation is to be performed. </paragraph>
<paragraph id="P-0098" lvl="0"><number>&lsqb;0098&rsqb;</number> Byte level predicate setting operations are used to set individual bits of the predicate register TRUE or FALSE. Higher level (half word, word or long word) predicate register setting operations are used to set groups of predicate register bits TRUE or FALSE. When operations are used to set groups of predicate bits each bit within the group is set to the same TRUE/FALSE value. The predicate bits are generally, but not always, set by an operation having the same lane size as the operation to be predicated. For example, a half word level predicate setting operation is typically performed to set a predicate register for use in the predication of half word level data processing operations. </paragraph>
<paragraph id="P-0099" lvl="0"><number>&lsqb;0099&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 9A and 9B</cross-reference> illustrate predicated execution of predicate register setting operations allowing individual bits within a predicate register to be set conditionally. Two or more consecutive setting operations can be used in combination to provide more sophisticated test conditions. For example in <cross-reference target="DRAWINGS">FIG. 9A</cross-reference> a predicate setting condition using a logical AND test is applied to set a predicate register. A logical AND test can be performed by means of a first predicate register setting operation <highlight><bold>900</bold></highlight> applying a compare greater than test to a first set of values and a second predicate register setting operation <highlight><bold>902</bold></highlight> applying a compare less than test to a second set of values, the second compare operation being conditionally executed on a per bit lane basis under the control of the predicate register set by the first operation. That is, the first and second predicate register setting operations act on the same predicate register Pr<highlight><bold>1</bold></highlight>. Predicating a comparison operation in this way thus has the effect of ANDing the new result and the previous value. The instruction CMPGTB Pr<highlight><bold>1</bold></highlight>, src<highlight><bold>1</bold></highlight><highlight><italic>a, </italic></highlight>src<highlight><bold>2</bold></highlight><highlight><italic>a </italic></highlight>(defining operation <highlight><bold>900</bold></highlight>) followed by the instruction Pr<highlight><bold>1</bold></highlight>. CMPLEB Pr<highlight><bold>1</bold></highlight>, src<highlight><bold>1</bold></highlight><highlight><italic>b, </italic></highlight>src<highlight><bold>2</bold></highlight><highlight><italic>b </italic></highlight>(defining operation <highlight><bold>902</bold></highlight>) causes the predicate register Pr<highlight><bold>1</bold></highlight>* to be finally set with the result of the byte level test (src<highlight><bold>1</bold></highlight><highlight><italic>a&gt;</italic></highlight>src<highlight><bold>2</bold></highlight><highlight><italic>a</italic></highlight>) AND (src<highlight><bold>1</bold></highlight><highlight><italic>b&lE;</italic></highlight>src<highlight><bold>2</bold></highlight><highlight><italic>b</italic></highlight>). The instruction Pr<highlight><bold>1</bold></highlight>.CMPLEB Pr<highlight><bold>1</bold></highlight>, scr<highlight><bold>1</bold></highlight><highlight><italic>b, </italic></highlight>scr<highlight><bold>2</bold></highlight><highlight><italic>b </italic></highlight>replaces respective bit values in the predicate register Pr<highlight><bold>1</bold></highlight> with the AND of the old Pr<highlight><bold>1</bold></highlight> bit value and the byte level comparison scr<highlight><bold>1</bold></highlight><highlight><italic>b&lt;</italic></highlight>scr<highlight><bold>2</bold></highlight><highlight><italic>b. </italic></highlight>This is because where a Pr<highlight><bold>1</bold></highlight> bit value is FALSE it remains so since the operation is not performed on that lane and where a Pr<highlight><bold>1</bold></highlight> bit value is TRUE it is replaced with the result of the comparison operation scr<highlight><bold>1</bold></highlight><highlight><italic>b&lE;</italic></highlight>scr<highlight><bold>2</bold></highlight><highlight><italic>b. </italic></highlight>Thus, overall a Pr<highlight><bold>1</bold></highlight> bit value remains true only if the old AND new result are both TRUE. The assembler language may use synonyms for this and similar special classes of instructions, e.g. CMPAND, TSTAND, FCMPAND. </paragraph>
<paragraph id="P-0100" lvl="0"><number>&lsqb;0100&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 9B</cross-reference> a predicate setting condition using a logical OR test is applied by means of a first compare operation <highlight><bold>904</bold></highlight> applying a greater than operation followed by a second &ldquo;compareOR&rdquo; <highlight><bold>906</bold></highlight> operation applying a less than test. For example, the instruction CMPGTB Pr<highlight><bold>1</bold></highlight>, src<highlight><bold>1</bold></highlight><highlight><italic>a, </italic></highlight>src<highlight><bold>2</bold></highlight><highlight><italic>a, </italic></highlight>followed by CMPORLEB Pr<highlight><bold>1</bold></highlight>, src<highlight><bold>1</bold></highlight><highlight><italic>b, </italic></highlight>src<highlight><bold>2</bold></highlight><highlight><italic>b, </italic></highlight>leads to a predicate register Pr<highlight><bold>1</bold></highlight>* containing the results of the test (src<highlight><bold>1</bold></highlight><highlight><italic>a&gt;</italic></highlight>src<highlight><bold>2</bold></highlight><highlight><italic>a</italic></highlight>) OR (src<highlight><bold>1</bold></highlight><highlight><italic>b&lE;</italic></highlight>src<highlight><bold>2</bold></highlight><highlight><italic>b</italic></highlight>). </paragraph>
<paragraph id="P-0101" lvl="0"><number>&lsqb;0101&rsqb;</number> Further, conditions combining logical AND and logical OR functionality may be used to set predicate registers. For example, the condition A&lt;B AND C&gE;D OR E&equals;F can be coded directly using a sequence comprising comparison, predicated comparison and ORSET operations to produce a single predicate register containing the TRUE/FALSE flags for each SIMD lane of the whole expression. A suitable set of instructions for a word level predicate setting operation of this type reads: CMPLEW Pr<highlight><bold>1</bold></highlight>, srcA, srcB; Pr<highlight><bold>1</bold></highlight>, CMPGTW Pr<highlight><bold>1</bold></highlight>, srcC,srcD and TSTOREQW Pr<highlight><bold>1</bold></highlight>, srcE, srcF. Alternatively the following sequence of instructions may be used to achieve the same result: CMPLEW Pr<highlight><bold>1</bold></highlight>, srcA, srcB; CMPANDGTW Pr<highlight><bold>1</bold></highlight>, srcC, srcD and TSTOREQW Pr<highlight><bold>1</bold></highlight>, srcE, srcF. </paragraph>
<paragraph id="P-0102" lvl="0"><number>&lsqb;0102&rsqb;</number> Thus, predicated (per bit) conditional execution of predicate bit setting operations of the type described allow execution conditions based on logical &ldquo;AND&rdquo; to be set. These conditions can be set in the same manner regardless of operand lane size, for example using a CMPAND or TSTAND instruction. </paragraph>
<paragraph id="P-0103" lvl="0"><number>&lsqb;0103&rsqb;</number> Furthermore, predicate (per bit) conditional execution of predicate bit setting operations can also facilitate logical &ldquo;OR&rdquo; conditions in addition, or in alternative, to the logical AND conditions. All such condition setting operations treat operands of different sizes in the same way and thus provide a versatile and simple way of setting complex execution conditions. </paragraph>
<paragraph id="P-0104" lvl="0"><number>&lsqb;0104&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10</cross-reference> illustrates how it is possible to set predicate registers using operations having a smaller lane size than the lane size of a data processing operation to be predicated. Since predication is always performed at byte level this approach allows operations to be performed conditionally on bytes within a long word, word or half word. A predicate register setting operation <highlight><bold>1000</bold></highlight> employs a byte level &ldquo;less than or equal to&rdquo; comparison to set the predicate register Pr<highlight><bold>1</bold></highlight>. The result is that bits <highlight><bold>0</bold></highlight>-<highlight><bold>3</bold></highlight> and bits <highlight><bold>6</bold></highlight>, <highlight><bold>7</bold></highlight> of the predicate register are set TRUE, whereas bits <highlight><bold>4</bold></highlight> and <highlight><bold>5</bold></highlight> are set FALSE. A word level ADD operation <highlight><bold>1002</bold></highlight> performed after the predicate setting operation <highlight><bold>1000</bold></highlight> is executed in dependence on byte level predication. The word level ADD operation is thus executed on the entire first word W<highlight><subscript>0 </subscript></highlight>since bits <highlight><bold>0</bold></highlight>-<highlight><bold>3</bold></highlight> of the predicate register are TRUE. However, since predicate bits <highlight><bold>4</bold></highlight>, <highlight><bold>5</bold></highlight> are set FALSE and predicate bits <highlight><bold>6</bold></highlight>, <highlight><bold>7</bold></highlight> are set TRUE, the word level ADD operation is performed only on part of the second word W<highlight><subscript>1</subscript></highlight>. The ADD operation is performed on the part word PWA corresponding to the two most significant bytes of word W<highlight><subscript>1 </subscript></highlight>under the control predicate bits <highlight><bold>6</bold></highlight> and <highlight><bold>7</bold></highlight>. The ADD operation is not performed on the part word PW<highlight><subscript>B </subscript></highlight>corresponding to the two least significant bytes of the word W<highlight><subscript>1</subscript></highlight>. </paragraph>
<paragraph id="P-0105" lvl="0"><number>&lsqb;0105&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 11</cross-reference> schematically illustrates a typical sequence of operations performed by preferred computer systems. A first setting instruction <highlight><bold>1100</bold></highlight> defines a predicate setting operation. The instruction defines the predicate setting operation by specifying the type of operation in a SETOP field and the test to be applied in a TSTID field. The instruction also specifies two source registers src<highlight><bold>1</bold></highlight>A, src<highlight><bold>2</bold></highlight>A and a predicate register Pr<highlight><bold>0</bold></highlight> to receive the results for each operand lane. The setting operation may or may not be predicated. Where a predicate register to control the setting operation is designated in a Psrc field it may or may not be the same predicate register as that designated to receive the results. According to the instruction <highlight><bold>1100</bold></highlight>, corresponding objects from the source registers <highlight><bold>1102</bold></highlight>, <highlight><bold>1104</bold></highlight> are supplied to functional logic <highlight><bold>1106</bold></highlight> connected to perform the operation specified in the instruction <highlight><bold>1100</bold></highlight>. The results are written to the predicate register designated in the setting instruction <highlight><bold>1100</bold></highlight> with or without predication <highlight><bold>1108</bold></highlight>. The number of predicate bits written by the setting operation depends on the size of the operand lane B/H/W specified in the setting instruction <highlight><bold>1100</bold></highlight>. </paragraph>
<paragraph id="P-0106" lvl="0"><number>&lsqb;0106&rsqb;</number> One or more further setting operations may be performed <highlight><bold>1110</bold></highlight> with the results written to the same or a different predicate register as desired. Complex predicate setting conditions can be set by performing consecutive setting operations on the same predicate register. </paragraph>
<paragraph id="P-0107" lvl="0"><number>&lsqb;0107&rsqb;</number> Next an instruction <highlight><bold>1120</bold></highlight> to be conditionally executed (e.g. a data processing operation or a branch operation) is fetched and decoded. This instruction <highlight><bold>1120</bold></highlight> designates a controlling predicate register Pr<highlight><bold>0</bold></highlight>. Next an instruction <highlight><bold>1120</bold></highlight> to be conditionally executed is fetched and decoded. The instruction may be a data processing instruction as illustrated here or a branch instruction as described hereinbefore. This instruction <highlight><bold>1120</bold></highlight> includes fields designating a controlling predicate register Pr<highlight><bold>0</bold></highlight> and defining a data processing operation DATAPROC on packed operands of a predetermined size B/H/W. The instruction also includes fields indicating first and second source registers src<highlight><bold>1</bold></highlight>B, src<highlight><bold>2</bold></highlight>B together with a destination register dest. In accordance with the instruction <highlight><bold>1120</bold></highlight> corresponding packed operands are supplied form the source registers <highlight><bold>1122</bold></highlight>, <highlight><bold>1124</bold></highlight> to data processing logic <highlight><bold>1126</bold></highlight>. Predicate checking logic <highlight><bold>1128</bold></highlight> accesses the designated predicate register Pr<highlight><bold>0</bold></highlight> and controls a switching circuit <highlight><bold>1130</bold></highlight> to determine which SIMD lane results are written to the destination register <highlight><bold>1132</bold></highlight>. Only results for operand lanes having a controlling predicate bit set to TRUE are written to the corresponding lane of the destination register <highlight><bold>1132</bold></highlight>. Results for lanes controlled by predicate bits set to FALSE are not written to the destination register <highlight><bold>1132</bold></highlight>. </paragraph>
<paragraph id="P-0108" lvl="0"><number>&lsqb;0108&rsqb;</number> Thus, preferred computer systems are capable of conditionally carrying out an operation defined in an SIMD computer instruction. The computer instruction is implemented on packed operands containing a plurality of packed objects in respective lanes. An operation defined in a computer instruction is conditionally performed per operand lane in dependence upon single bit flags which determine for each operand lane whether or not the operation is to be executed. The flags are stored in a plurality of multi-bit predicate registers. Each predicate register comprises a plurality of flags, one for each lane on which the instruction is to be conditionally executed. Instructions which are to be conditionally executed include a bit sequence designating which of the plurality of predicate registers is to control that instruction. The flags in the designated predicate register control a set of switches, one for each operand lane. These switches control whether or not the result of the operation updates the values in the corresponding lane of the destination register. The flags of a predicate register can be set simultaneously by means of general operations which write results to the predicate register. </paragraph>
<paragraph id="P-0109" lvl="0"><number>&lsqb;0109&rsqb;</number> In some operations results are written to pairs of registers at the same time. An example of an operation which normally writes results to a register pair is &ldquo;Deal&rdquo; bytes from a source register pair to a destination register pair. In such cases, predicate bit i controls the writing of (byte) lane <highlight><bold>2</bold></highlight>*i and (byte) lane <highlight><bold>2</bold></highlight>*i&plus;1. This provides the effect of controlling the destination operand lane in the same way as the predicate bits normally control (byte) lane execution. For example, if a predicate register is set with a compare half word operation and then used to control a multiply half word operation it will control each of the four half word lanes independently. For example, when the predicate register is then used to multiply unsigned half words to produce words in separate registers it will control each of the four (double sized) word lanes in the same way. </paragraph>
<paragraph id="P-0110" lvl="0"><number>&lsqb;0110&rsqb;</number> Another class of operations which write to two pairs of registers at the same time is dual execute operations (eg ALU<highlight><bold>2</bold></highlight> or MAC<highlight><bold>2</bold></highlight> operations). Where desirable, these types of instructions can be conditionally executed in the general manner described herein but using even/odd pairs of predicate registers designated by the instruction. </paragraph>
<paragraph id="P-0111" lvl="0"><number>&lsqb;0111&rsqb;</number> An advantage afforded by the facility to conditionally execute operations on lanes of packed operands according to the preferred embodiment defined herein is that problems associated with managing information contained in test registers are eliminated. </paragraph>
<paragraph id="P-0112" lvl="0"><number>&lsqb;0112&rsqb;</number> A skilled reader would readily appreciate that the invention should not be limited to specific apparatus configurations or method steps disclosed in conjunction with the preferred embodiment described. Those skilled in the art will also recognize that the present invention has a broad range of applications, and the embodiments admit of a wide range of modifications, without departure from the inventive concepts. For example, the preferred embodiment has been described in terms of specifically coded instructions but it will be apparent that different encoding schemes may provide the inventive concepts set out in the claims. </paragraph>
<paragraph id="P-0113" lvl="0"><number>&lsqb;0113&rsqb;</number> In this embodiment, arithmetic operations are supported for operand sizes up to 32 bits and pure bitwise logical operations are supported for operand sizes of up to 64 bits. This is not intended to be limiting. </paragraph>
<paragraph id="P-0114" lvl="0"><number>&lsqb;0114&rsqb;</number> Similarly, the architecture defined herein uses a specific apparatus configuration. However, it will be apparent that any architecture may be used with the invention. For example, the invention may be employed in machines with single or multiple SIMD data paths and with or without instruction/data caches of the type described herein. </paragraph>
<paragraph id="P-0115" lvl="0"><number>&lsqb;0115&rsqb;</number> While the foregoing has described what are considered to be the best mode and/or other preferred embodiments of the invention, it is understood that various modifications may be made therein and that the invention may be implemented in various forms and embodiments, and that it may be applied in numerous applications, only some of which have been described herein. It is intended by the following claims to claim any and all modifications and variations that fall within the true scope of the inventive concepts. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A computer system for conditionally performing an operation defined in a computer instruction and having an execution unit comprising: 
<claim-text>at least one operand store for holding operands on which an operation defined in an instruction is to be performed, wherein said operand store defines a plurality of lanes each holding an object; </claim-text>
<claim-text>a plurality of operators associated respectively with the lanes for carrying out an operation specified in an instruction on objects in the operand lanes; </claim-text>
<claim-text>a destination store for holding objects resulting from the operation on a lane by lane basis; </claim-text>
<claim-text>a plurality of control stores each comprising a plurality of indicators to control for each lane whether or not an operation defined in an instruction is to be performed on that lane; and </claim-text>
<claim-text>control circuitry for controlling which of said plurality of control stores is to be used to control per lane execution of an instruction, the control circuitry being operative to select a control store from the plurality of control stores based on a field contained in the instruction. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. A computer system as in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein each said indicator is settable to a first state or a second state, each state representing a resolved test condition. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. A computer system as in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein each said control store comprises a predicate register and said indicators comprise a plurality of single bit TRUE/FALSE flags. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. A computer system as in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein each of said plurality of indicators is connectable to control conditional execution on an operand lane of a predetermined width. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. A computer system as in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein a plurality of indicators is connectable to control conditional execution on an operand lane having a width greater than a predetermined width. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. A computer system as in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the operators are adapted to receive immediate values. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. A computer system as in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, comprising first and second operand stores for holding operands for data processing operations. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. A computer system as in <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference>, wherein said operators are arranged to perform a data processing operation specified in an instruction on objects in corresponding lanes of said first and second operand stores. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. A computer system as in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the width of an operand lane is defined by an amount of information selected from one or more of the following: 
<claim-text>a byte; </claim-text>
<claim-text>a half-word; </claim-text>
<claim-text>a word; </claim-text>
<claim-text>a long word; </claim-text>
<claim-text>a double long word, and </claim-text>
<claim-text>a predetermined larger amount of information. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. A computer system as in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, comprising first and second single instruction multiple data execution units operable to execute instructions in parallel. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. A computer system as in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, operable to receive long instruction words capable of containing a single instruction or a plurality of instructions. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. A method of executing instructions on operands comprising a plurality of packed objects, the method including: 
<claim-text>accessing at least one source operand store holding a plurality of packed objects in respective lanes; </claim-text>
<claim-text>determining which of a plurality of control stores is to control per lane execution of an instruction based on a field of the instruction; </claim-text>
<claim-text>accessing said control store to determine for each lane whether or not to perform the instruction on that lane, a plurality of indicators indicating for each lane whether or not an operation defined in the instruction is to be performed on that lane; and </claim-text>
<claim-text>performing the operation and updating a destination store only in those lanes for which the indicators indicate that the operation should be performed. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. A method as in <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, wherein each said indicator is set to a first state or a second state, according to a resolved test condition. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. A method as in <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, wherein each said indicator comprises a single bit value. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. A method as in <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference>, wherein each indicator in said first state is set to TRUE. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. A method as in <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference>, wherein each indicator in said second state is set to FALSE. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. A method as in <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, wherein for an operand lane of a predetermined width execution is conditionally performed in dependence on the state of a single indicator. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. A method as in <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, wherein for an operand lane having a width greater than a predetermined width execution is performed conditionally in dependence on the states of a plurality of indicators. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. A method as in <dependent-claim-reference depends_on="CLM-00011">claim 18</dependent-claim-reference>, wherein said plurality of indicators for controlling conditional execution of an operand lane are set to the same state. </claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. A method as in <dependent-claim-reference depends_on="CLM-00011">claim 18</dependent-claim-reference>, wherein said plurality of indicators for controlling conditional execution of an operand lane comprise indicators set to different states such that an operation is performed on part of an operand lane. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. A method as in <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, wherein a predetermined number of indicators which is less than the total number of indicators in a control store is used to determine whether or not an operation should be performed on all operand lanes at the same time. </claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. A method as in <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference>, wherein said predetermined number is 1 and the operation is conditionally performed on the entire contents of the at least one operand store. </claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. A computer program product equipped to perform the method of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>. </claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. A computer program as in <dependent-claim-reference depends_on="CLM-00022">claim 23</dependent-claim-reference>, wherein the program is recorded on a carrier. </claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. A computer system for conditionally performing an operation defined in a computer instruction, the execution unit of the computer system comprising: 
<claim-text>at least one operand store for holding operands on which an operation defined in an instruction is to be performed, wherein said operand store defines a plurality of lanes each holding an object; </claim-text>
<claim-text>a plurality of operators associated respectively with the lanes for carrying out an operation specified in an instruction on objects in the operand lanes; </claim-text>
<claim-text>a destination store for holding objects resulting from the operation on a lane by lane basis; </claim-text>
<claim-text>a plurality of predicate registers each comprising a plurality of predicate bits to control for each lane whether or not an operation defined in an instruction is to be performed on that lane; and </claim-text>
<claim-text>control circuitry for controlling which of said plurality of predicate registers is to be used to control per lane execution of an instruction over said operand lanes simultaneously, the control circuitry being operative to select a predicate register from the plurality of predicate registers based on a field contained in the instruction.</claim-text>
</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>1</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005365A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005365A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005365A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005365A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005365A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005365A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030005365A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030005365A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030005365A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00009">
<image id="EMI-D00009" file="US20030005365A1-20030102-D00009.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
