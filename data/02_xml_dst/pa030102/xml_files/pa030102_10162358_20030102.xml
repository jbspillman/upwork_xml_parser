<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005416A1-20030102-D00000.TIF SYSTEM "US20030005416A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005416A1-20030102-D00001.TIF SYSTEM "US20030005416A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005416A1-20030102-D00002.TIF SYSTEM "US20030005416A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005416A1-20030102-D00003.TIF SYSTEM "US20030005416A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005416A1-20030102-D00004.TIF SYSTEM "US20030005416A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005416A1-20030102-D00005.TIF SYSTEM "US20030005416A1-20030102-D00005.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005416</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10162358</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20020604</filing-date>
</domestic-filing-data>
<foreign-priority-data>
<priority-application-number>
<doc-number>101 27 170.0</doc-number>
</priority-application-number>
<filing-date>20010605</filing-date>
<country-code>DE</country-code>
</foreign-priority-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F009/44</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>717</class>
<subclass>129000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Fault search method and apparatus</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Renate</given-name>
<family-name>Henftling</family-name>
</name>
<residence>
<residence-non-us>
<city>Fuerstenfeldbruck</city>
<country-code>DE</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Wolfgang</given-name>
<family-name>Ecker</family-name>
</name>
<residence>
<residence-non-us>
<city>Muenchen</city>
<country-code>DE</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Andreas</given-name>
<family-name>Zinn</family-name>
</name>
<residence>
<residence-non-us>
<city>Muenchen</city>
<country-code>DE</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Matthias</given-name>
<family-name>Bauer</family-name>
</name>
<residence>
<residence-non-us>
<city>Otterfing</city>
<country-code>DE</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Martin</given-name>
<family-name>Zambaldi</family-name>
</name>
<residence>
<residence-non-us>
<city>Muenchen</city>
<country-code>DE</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>MARSHALL, GERSTEIN &amp; BORUN</name-1>
<name-2></name-2>
<address>
<address-1>6300 SEARS TOWER</address-1>
<address-2>233 SOUTH WACKER</address-2>
<city>CHICAGO</city>
<state>IL</state>
<postalcode>60606-6357</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A fault search method and apparatus for simplified use and control of fault search in a system with several different models such as, for example, a hardware model, a software program and a test bench model. A user activates a uniform debugger, which, in turn, retrieves and executes various subordinate debuggers that are each allocated to a different model. The subordinate debuggers then access the different models allocated to them for the performance of corresponding fault search operations. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">BACKGROUND </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> 1. Field </paragraph>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> The present invention relates to a fault search method for a system with different simulation models such as, for example, a hardware model, a software program and/or a test bench model, and a device for fault search in a system with such different simulation models which can preferably be used in hardware design, such as in the design of electronic circuits (i.e., in this case the system to be simulated is an electronic circuit). </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> 2. Related Art </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> There are systems to be simulated in which, by means of a controlled and instrumented processing of program steps (known as debugging) in a test environment, faults are sought and simulated by various simulation models. In the context of this application, the term &ldquo;simulation model&rdquo; includes, in particular, hardware models, software programs and test bench models. Such a system can be described for example using three classes of language: with one or more hardware description languages (HDL) for hardware; one or more programming languages (PL) for software; and a test language (TL) or hardware verification language (HVL) for the test bench. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> When fault searching in data processing programs, usually the model or program to be examined for faults is executed under the control of a fault search facility or fault search program known as a debugger. Here the fault search program is retrieved, which, in turn, retrieves the model or program to be examined which usually contains an interrupt point. When this interrupt point is reached the further processing of the program to be examined is stopped and the debugger is run back. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> In conventional fault search processes for each class of the above languages, i.e., for each model, a separate fault search program with its own commands and interface is used. The advantage that for each class of language an optimum debugger can be used, is balanced against the disadvantage that the various debuggers for the different models behave differently and the user must monitor many command interfaces and windows on the screen of his computer workstation. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY </heading>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> A fault search method is disclosed for a system simulated by several different simulation models, where the system is described in individual simulation models by description languages of different classes, and where allocated to the individual simulation models are different first fault search facilities for tracing a fault in each case by means of access to the corresponding simulation model. The method includes automatically detecting a user input using a second fault search facility which is of a higher order than the first fault search facilities. Also, the method includes automatically controlling the first fault search facilities by the second fault search facility depending on the user input, in order to find a system fault by access to a relevant simulation model. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> An apparatus is disclosed for fault searching for a system simulated by a plurality of different simulation models, wherein the system is described in the individual simulation model by description languages of different classes. The apparatus includes a plurality of first fault search facilities each allocated to a corresponding simulation model to find a system fault by access to the corresponding simulation model. A second fault search facility that is of a higher order than each of the plurality of first fault search facilities is also provided wherein the second fault search facility is configured to automatically detect a user input and control the first fault search facilities as a function of the user input to find a fault by access to relevant simulation models.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> illustrates a diagrammatic view of a structure of a device for fault search according to the teachings of the present invention. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> illustrates a diagrammatic view of another structure of a device for fault search according to the teachings of the present invention. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a flow diagram illustrative of a function procedure for a fault search method. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a flow diagram illustrative of a further function procedure of a fault search method. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a flow diagram to explain another further function procedure of a fault search method according to the present invention.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF THE PREFERRED EXAMPLES </heading>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> shows a structure of a device for performance of a fault search method. Here, a system <highlight><bold>1</bold></highlight> to be simulated is constructed from three different simulation models <highlight><bold>2</bold></highlight>-<highlight><bold>4</bold></highlight>, referred to below for the sake of simplicity as the model. The models <highlight><bold>2</bold></highlight>, <highlight><bold>3</bold></highlight>, <highlight><bold>4</bold></highlight> (marked I to III in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>) are, for example, a hardware model, a software model/program and a test bench model in which the system is described by the corresponding languages as initially explained. Furthermore the different models <highlight><bold>2</bold></highlight>, <highlight><bold>3</bold></highlight>, <highlight><bold>4</bold></highlight> present in stored form usually communicate with each other. The number of models or classes of language used is not established, where only two languages, e.g., a hardware description language and a test language, can be used, i.e., it is in particular also possible to simulate a system comprising just a hardware model and a software program and search this for faults. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> All models <highlight><bold>2</bold></highlight>, <highlight><bold>3</bold></highlight>, <highlight><bold>4</bold></highlight> of system <highlight><bold>1</bold></highlight> to be simulated have a corresponding interface <highlight><bold>8</bold></highlight>, <highlight><bold>9</bold></highlight>, <highlight><bold>1</bold></highlight> <highlight><bold>0</bold></highlight> to a fault search facility specially matched to the model concerned, in the form of debuggers <highlight><bold>5</bold></highlight> to <highlight><bold>7</bold></highlight>, i.e., each model <highlight><bold>2</bold></highlight>, <highlight><bold>3</bold></highlight>, <highlight><bold>4</bold></highlight> is provided with an optimum debugger with its own different commands. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> In contrast to conventional fault search devices, with the presently disclosed fault search device the user need not work with and control several different special debuggers <highlight><bold>5</bold></highlight>-<highlight><bold>7</bold></highlight>. Rather the user has access to a higher order fault search facility in the form of a uniform debugger <highlight><bold>11</bold></highlight> which the user can use via a suitable user interface <highlight><bold>12</bold></highlight>. This uniform debugger <highlight><bold>11</bold></highlight> has its own command interpreter with its own commands and, where applicable, its own graphic interface. This command interpreter converts its own commands into the relevant commands of the various special debuggers <highlight><bold>5</bold></highlight>, <highlight><bold>6</bold></highlight> and <highlight><bold>7</bold></highlight> and supplies the converted commands to the individual special debuggers <highlight><bold>5</bold></highlight>, <highlight><bold>6</bold></highlight> and <highlight><bold>7</bold></highlight> for processing the corresponding fault search operations by access to the model concerned. Conversely, the command interpreter of the uniform debugger <highlight><bold>11</bold></highlight> converts the commands or outputs and feedback supplied by the various special debuggers <highlight><bold>5</bold></highlight>, <highlight><bold>6</bold></highlight> and <highlight><bold>7</bold></highlight> such that they can be output to the user and shown in a standard form via the user interface <highlight><bold>12</bold></highlight>. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> In the fault search device according to this embodiment the user need not, as in former systems, control several debuggers <highlight><bold>5</bold></highlight>-<highlight><bold>7</bold></highlight> in parallel. Instead, the user operates or controls only the uniform debugger <highlight><bold>11</bold></highlight>. Thus the performance of fault search is considerably simplified for the user. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> An alternative example of a fault search device is shown in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>. The same components of this arrangement carry the same reference figures as in the example of <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> The second example differs from the example shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference> in that the special debugger <highlight><bold>6</bold></highlight> for the software program <highlight><bold>3</bold></highlight> is omitted. This means that the uniform debugger <highlight><bold>11</bold></highlight> in this case accesses the debugger interface <highlight><bold>9</bold></highlight> of the software program <highlight><bold>3</bold></highlight> directly for control and analysis. In the UNIX operating system the term &ldquo;common object format&rdquo; is used in connection with such a debugger interface <highlight><bold>9</bold></highlight>. For the case where such general interfaces <highlight><bold>8</bold></highlight> or <highlight><bold>10</bold></highlight> are provided in relation to the hardware model <highlight><bold>2</bold></highlight> and/or the test bench model <highlight><bold>4</bold></highlight>, in the same way the hardware debugger <highlight><bold>5</bold></highlight> and the test bench debugger <highlight><bold>7</bold></highlight> can be omitted as the uniform debugger <highlight><bold>11</bold></highlight> can act directly on the hardware model <highlight><bold>2</bold></highlight> or the test bench model <highlight><bold>4</bold></highlight>. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> Communication between the uniform debugger <highlight><bold>11</bold></highlight> and the special subordinate debuggers <highlight><bold>5</bold></highlight>, <highlight><bold>6</bold></highlight> and <highlight><bold>7</bold></highlight> used in both disclosed examples of the fault search device is preferably based on a so-called &ldquo;master-slave&rdquo; communication. Throughout the entire simulation, the uniform debugger <highlight><bold>11</bold></highlight> acts as master whereas the individual special debuggers <highlight><bold>5</bold></highlight>, <highlight><bold>6</bold></highlight> and <highlight><bold>7</bold></highlight> work as slaves. Thus each inquiry from the uniform debugger <highlight><bold>11</bold></highlight> to one of the debuggers <highlight><bold>5</bold></highlight>, <highlight><bold>6</bold></highlight> and <highlight><bold>7</bold></highlight> used is acknowledged by this with a confirmation. Such a confirmation can, for example, be merely a prompt, i.e., a renewed input request by the debugger <highlight><bold>5</bold></highlight>-<highlight><bold>7</bold></highlight> concerned. In addition to this confirmation, if required, e.g., if the higher order uniform debugger <highlight><bold>11</bold></highlight> gives a command to a subordinate special debugger <highlight><bold>5</bold></highlight>-<highlight><bold>7</bold></highlight> to calculate the value of an object, the special debugger <highlight><bold>5</bold></highlight>, <highlight><bold>6</bold></highlight>, <highlight><bold>7</bold></highlight> concerned feeds back to the uniform debugger <highlight><bold>11</bold></highlight> further information such as, for example, the value of this object. Thus, communication between the uniform debugger <highlight><bold>11</bold></highlight> and the special debuggers <highlight><bold>5</bold></highlight>-<highlight><bold>7</bold></highlight> is fully automated and computer-supported, i.e., the uniform debugger <highlight><bold>11</bold></highlight> automatically detects a user input and converts this into a corresponding trigger/activation of the special debuggers <highlight><bold>5</bold></highlight>-<highlight><bold>7</bold></highlight>, which, in turn, perform the corresponding fault search operations automatically with computer support. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> Using FIGS. <highlight><bold>3</bold></highlight>-<highlight><bold>5</bold></highlight>, as examples, various function procedures are now explained which can occur in a fault search method with the fault search devices described above. It will be evident to a person skilled in the art that the presently disclosed fault search method is not restricted to the function procedures in FIGS. <highlight><bold>3</bold></highlight>-<highlight><bold>5</bold></highlight>, but these serve merely for better understanding of the invention and the person skilled in the art will automatically be able to transfer the structure disclosed to further function procedures which are required for fault search in systems with several different models. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> shows first the function procedures for a command which is sent by the uniform debugger <highlight><bold>11</bold></highlight> to all available special debuggers <highlight><bold>5</bold></highlight>-<highlight><bold>7</bold></highlight>. In the example shown, the user, via the user interface <highlight><bold>12</bold></highlight>, gives the command &ldquo;start&rdquo; to the uniform debugger <highlight><bold>11</bold></highlight>, for example. The uniform or main debugger <highlight><bold>11</bold></highlight> converts the &ldquo;start&rdquo; command into the equivalent command for the special debuggers <highlight><bold>5</bold></highlight>, <highlight><bold>6</bold></highlight>, <highlight><bold>7</bold></highlight> such as, for example, &ldquo;run&rdquo; or &ldquo;start&rdquo; and passes these converted commands to the individual special debuggers <highlight><bold>5</bold></highlight>, <highlight><bold>6</bold></highlight> and <highlight><bold>7</bold></highlight>. As in the case shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, as special subordinate debuggers are used a hardware (HW) debugger <highlight><bold>5</bold></highlight> with access to a hardware (HW) model <highlight><bold>2</bold></highlight>, a software (SW) debugger <highlight><bold>6</bold></highlight> with access to a software (SW) program/model <highlight><bold>3</bold></highlight>, and a test bench (TB) debugger <highlight><bold>7</bold></highlight> with access to a test bench (TB) model <highlight><bold>4</bold></highlight>. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> After all debuggers <highlight><bold>5</bold></highlight>, <highlight><bold>6</bold></highlight>, <highlight><bold>7</bold></highlight>, because of the start command supplied by the uniform debugger <highlight><bold>11</bold></highlight>, have begun processing their models or programs <highlight><bold>2</bold></highlight>, <highlight><bold>3</bold></highlight>, <highlight><bold>4</bold></highlight>, usually a random sequence of interactions takes place between the models or programs as indicated in <cross-reference target="DRAWINGS">FIG. 3</cross-reference> by arrows. When the execution of models <highlight><bold>2</bold></highlight>, <highlight><bold>3</bold></highlight> and <highlight><bold>4</bold></highlight> has ended, the allocated debuggers <highlight><bold>5</bold></highlight>, <highlight><bold>6</bold></highlight>, <highlight><bold>7</bold></highlight> each send a specific &ldquo;end&rdquo; message to the uniform debugger <highlight><bold>11</bold></highlight>, where these &ldquo;end&rdquo; messages may also be correlated. The main fault search program <highlight><bold>11</bold></highlight> then converts these &ldquo;end&rdquo; messages and outputs a corresponding &ldquo;end&rdquo; feedback to the user interface <highlight><bold>12</bold></highlight>. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> To administer all objects involved in the simulation of system <highlight><bold>1</bold></highlight> the uniform debugger <highlight><bold>11</bold></highlight> must combine the objects of all models <highlight><bold>2</bold></highlight>, <highlight><bold>3</bold></highlight> and <highlight><bold>4</bold></highlight>. This means that different name ranges (hardware, software, test bench) must be administered together. As in principle it is possible, for example, for a variable of the software program <highlight><bold>3</bold></highlight> to have the same name as a signal of the hardware model <highlight><bold>2</bold></highlight>, it is advantageous if the uniform debugger <highlight><bold>11</bold></highlight> is able to expand the local name ranges of the individual models <highlight><bold>2</bold></highlight>, <highlight><bold>3</bold></highlight> and <highlight><bold>4</bold></highlight> internally into global names in order to distinguish them. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> With reference to <cross-reference target="DRAWINGS">FIG. 4</cross-reference> the function procedure is now explained for a command entered by the user to query the value of an object of a particular model. First the uniform debugger <highlight><bold>11</bold></highlight>, using the global object name for which the value is to be checked, must determine in which model <highlight><bold>2</bold></highlight>, <highlight><bold>3</bold></highlight> and <highlight><bold>4</bold></highlight> the required object is present. Then the uniform debugger <highlight><bold>11</bold></highlight> determines the corresponding local name of the object and by means of a corresponding command requests the value of the object from the relevant subordinate special debugger (in the present case the software debugger <highlight><bold>6</bold></highlight>) under whose control the specific model <highlight><bold>3</bold></highlight>, to which the object belongs, is running. The special debugger <highlight><bold>6</bold></highlight> gives the required value of the object back to the uniform debugger <highlight><bold>11</bold></highlight> which passes on this value, where applicable after further processing, to the user interface <highlight><bold>12</bold></highlight>. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> In a similar way, interrupt conditions can be set or deleted by the user or object values set. In such cases the relevant special debugger <highlight><bold>5</bold></highlight>, <highlight><bold>6</bold></highlight> and <highlight><bold>7</bold></highlight>, instead of returning the value of the object as described above, will return merely a confirmation to the uniform debugger <highlight><bold>11</bold></highlight>. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> Finally as a third example of a function procedure, <cross-reference target="DRAWINGS">FIG. 5</cross-reference> shows the processing of a single step command. On the basis of a single step command entered by the user via the user interface <highlight><bold>12</bold></highlight>, the uniform debugger <highlight><bold>11</bold></highlight> generates a corresponding single step command for the desired model (in the present case the test bench model <highlight><bold>4</bold></highlight>) and passes this to the debugger <highlight><bold>7</bold></highlight> allocated to the model <highlight><bold>4</bold></highlight>. Then the model <highlight><bold>4</bold></highlight> is operated in single step mode while the other models <highlight><bold>2</bold></highlight>, <highlight><bold>3</bold></highlight> can run without interruption and not in single step mode. On completion of the single step, the debugger <highlight><bold>7</bold></highlight> sends a confirmation that the single step of model <highlight><bold>4</bold></highlight> is completed back to the uniform debugger <highlight><bold>11</bold></highlight>, which converts this confirmation into a corresponding command for the user interface <highlight><bold>12</bold></highlight>. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> In the function processes described above it is generally irrelevant whether a single step proceeds via a single individual instruction or via several combined single instructions. Also the single step command, depending on the user command, can apply both to one model and to several or all models <highlight><bold>2</bold></highlight>, <highlight><bold>3</bold></highlight>, <highlight><bold>4</bold></highlight>. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> The presently disclosed processes and devices provide a fault search method for a system with different simulation models that is easy for the user to use and control. This is accomplished by a fault search in a system with several different simulation models such as for example a hardware model, a software model/program and a test bench model, the user executes a higher order fault search facility (debugger), which, in turn, communicates with and activates various subordinate fault search facilities (debuggers) each allocated to a different simulation model. Each subordinate fault search facility has access to its allocated simulation model in order to trace a fault in the system (or in the simulation model concerned). By providing the higher order, uniform and common fault search facility, the user has access to a uniform interface with its own commands, own command interpreter and own interface to simplify fault searching in the individual simulation models for the user. At the same time optimum debuggers for the various simulation models can be used as subordinate fault search facilities so that despite the simplified operation for the user, optimum results of the fault search can be guaranteed. Additionally, the higher order fault search facility can intervene directly, i.e. without the intermediary of a corresponding subordinate fault search facility, on the simulation model concerned for control and analysis. Communication takes place preferably between the uniform higher order fault search facility and the individual subordinate and special fault search facilities in the form of a master worker or master slave communication, where the higher order fault search facility acts as the master and the subordinate fault search facilities act as workers or slaves. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> Although certain methods and apparatuses in accordance with the teachings of the invention have been described herein, the scope of coverage of this patent is not limited thereto. On the contrary, this patent covers all embodiments of the teachings of the invention fairly falling within the scope of the appended claims either literally or under the doctrine of equivalents. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A fault search method for a system simulated by several different simulation models, where the system is described in individual simulation models by description languages of different classes, and where allocated to the individual simulation models are different first fault search facilities for tracing a fault in each case by means of access to the corresponding simulation model, the method comprising: 
<claim-text>automatically detecting a user input using a second fault search facility which is of a higher order than the first fault search facilities, and </claim-text>
<claim-text>automatically controlling the first fault search facilities by the second fault search facility depending on the user input, in order to find a system fault by access to a relevant simulation model. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. A fault search method according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein one simulation model is a hardware simulation model in which the system is described by a hardware description language, and a hardware debugger is allocated to the one simulation model as a corresponding first fault search facility. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. A fault search method according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein one simulation model is a test bench simulation model in which the system is described by a test bench language, and a test bench debugger is allocated to the one simulation model as a corresponding first fault search facility. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. A fault search method according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein one simulation model is a software simulation model in which the system is described by a programming language, and a software debugger is allocated to the one simulation model as a corresponding first fault search facility. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. A fault search method according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the higher order second fault search facility accesses at least one simulation model directly without the intervention of a first fault search facility. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. A fault search method according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the second fault search facility automatically converts a user input into corresponding commands for the individual first fault search facilities. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. A fault search method according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the first fault search facility automatically, as a function of the control by the second fault search facility, performs a corresponding fault search operation by access to the relevant simulation model, and wherein the second fault search facility automatically detects and outputs to the user feedback generated by the individual first fault search facilities during a relevant fault operation. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. A fault search method according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein communication between the second fault search facility and the first fault search facilities takes place in the form of a master-slave communication, where the second fault search facility acts as a master and the first fault search facilities act as slaves. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. An apparatus for fault searching for a system simulated by a plurality of different simulation models, wherein the system is described in the individual simulation model by description languages of different classes, the apparatus comprising: 
<claim-text>a plurality of first fault search facilities each allocated to a corresponding simulation model to find a system fault by access to the corresponding simulation model; and </claim-text>
<claim-text>a second fault search facility that is of a higher order than each of the plurality of first fault search facilities; </claim-text>
<claim-text>wherein the second fault search facility is configured to automatically detect a user input and control the first fault search facilities as a function of the user input to find a fault by access to relevant simulation models. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. An apparatus according to <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, wherein one simulation model of the plurality of different simulation models is a hardware simulation model in which the system is described by a hardware description language, and a hardware debugger is allocated to the one simulation model as a corresponding first fault search facility. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. An apparatus according to <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, wherein one simulation model of the plurality of different simulation models is a test bench simulation model in which the system is described by a test bench language, and a test bench debugger is allocated to the one simulation model as a corresponding first fault search facility. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. An apparatus according to <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, wherein one simulation model of the plurality of different simulation models is a software simulation model in which the system is described by a programming language, and a software debugger is allocated to the one simulation model as a corresponding first fault search facility. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. An apparatus according to <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, wherein the second fault search facility acts directly on at least one simulation model without the intervention of a corresponding first fault search facility. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. An apparatus according to <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, wherein the second fault search facility is designed for automatic conversion of the user input into corresponding commands for the individual first fault search facilities. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. An apparatus according to <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, wherein the individual fault search facilities are configured for automatic performance of corresponding fault search operations in accordance with the control by the second fault search facility by access to a relevant simulation model, and that the second fault search facility is configured for automatic detection and output to the user of feedback generated by the first fault search facilities during the respective fault search operations. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. An apparatus according to <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, wherein the individual first fault search facilities and the second fault search facility are configured to perform a master-slave communication between the first fault search facility as the master on one side and the individual second fault search facilities as slaves on the other. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. An apparatus according to <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, wherein an interface for connection to the relevant first fault search facility is respectively allocated to each of the individual simulation models. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. An apparatus according to <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, wherein the individual simulation models comprise facilities designed for mutual communication. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. An apparatus according to <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, wherein the apparatus is utilized for the design of electronic circuits.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>1</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005416A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005416A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005416A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005416A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005416A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005416A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
