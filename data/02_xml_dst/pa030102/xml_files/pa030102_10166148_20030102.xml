<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005426A1-20030102-D00000.TIF SYSTEM "US20030005426A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005426A1-20030102-D00001.TIF SYSTEM "US20030005426A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005426A1-20030102-D00002.TIF SYSTEM "US20030005426A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005426A1-20030102-D00003.TIF SYSTEM "US20030005426A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005426A1-20030102-D00004.TIF SYSTEM "US20030005426A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005426A1-20030102-D00005.TIF SYSTEM "US20030005426A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030005426A1-20030102-D00006.TIF SYSTEM "US20030005426A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030005426A1-20030102-D00007.TIF SYSTEM "US20030005426A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030005426A1-20030102-D00008.TIF SYSTEM "US20030005426A1-20030102-D00008.TIF" NDATA TIF>
<!ENTITY US20030005426A1-20030102-D00009.TIF SYSTEM "US20030005426A1-20030102-D00009.TIF" NDATA TIF>
<!ENTITY US20030005426A1-20030102-D00010.TIF SYSTEM "US20030005426A1-20030102-D00010.TIF" NDATA TIF>
<!ENTITY US20030005426A1-20030102-D00011.TIF SYSTEM "US20030005426A1-20030102-D00011.TIF" NDATA TIF>
<!ENTITY US20030005426A1-20030102-D00012.TIF SYSTEM "US20030005426A1-20030102-D00012.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005426</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10166148</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20020607</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F009/44</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>717</class>
<subclass>169000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Methods and apparatus for upgrading software without affecting system service</title-of-invention>
</technical-information>
<continuity-data>
<non-provisional-of-provisional>
<document-id>
<doc-number>60297217</doc-number>
<document-date>20010608</document-date>
<country-code>US</country-code>
</document-id>
</non-provisional-of-provisional>
</continuity-data>
<inventors>
<first-named-inventor>
<name>
<given-name>Dale</given-name>
<middle-name>A.</middle-name>
<family-name>Scholtens</family-name>
</name>
<residence>
<residence-us>
<city>Lisle</city>
<state>IL</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Robert</given-name>
<family-name>Roden</family-name>
</name>
<residence>
<residence-non-us>
<city>Ennis</city>
<country-code>IE</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Donal</given-name>
<family-name>Cooney</family-name>
</name>
<residence>
<residence-non-us>
<city>Ardnacrusha</city>
<country-code>IE</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Barry</given-name>
<middle-name>J.</middle-name>
<family-name>Glicklich</family-name>
</name>
<residence>
<residence-us>
<city>Warrenville</city>
<state>IL</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Walter</given-name>
<family-name>Slotarski</family-name>
</name>
<residence>
<residence-us>
<city>Palatine</city>
<state>IL</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Wesley</given-name>
<middle-name>R.</middle-name>
<family-name>Decker</family-name>
</name>
<residence>
<residence-us>
<city>Naperville</city>
<state>IL</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Kevin</given-name>
<middle-name>M.</middle-name>
<family-name>Cramer</family-name>
</name>
<residence>
<residence-us>
<city>Parker</city>
<state>CO</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>Kenneth J. Rudofski</name-1>
<name-2>Tellabs Operations, Inc.</name-2>
<address>
<address-1>1415 West Diehl Road, MS 16</address-1>
<city>Naperville</city>
<state>IL</state>
<postalcode>60563</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A method for managing an upgrade on a system that includes a system manager, a subsystem of a first type and a subsystem of a second type that is subordinate to the subsystem of the first type is disclosed. </paragraph>
</subdoc-abstract>
<subdoc-description>
<cross-reference-to-related-applications>
<heading lvl="1">RELATED APPLICATIONS </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> This patent application claims priority to the provisional patent application having the assigned serial No. 60/297,217 filed on Jun. 8, 2001 and entitled METHODS AND APPARATUS FOR UPGRADING SOFTWARE WITHOUT AFFECTING SYSTEM SERVICE.</paragraph>
</cross-reference-to-related-applications>
<summary-of-invention>
<section>
<heading lvl="1">FIELD OF THE INVENTION </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> The present invention relates to procedures for upgrading software in a system. More specifically, the present invention relates to a method and apparatus for upgrading software in a system having heterogeneous integrated subsystems. </paragraph>
</section>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> Software upgrades are often provided to systems to correct software bugs or to introduce new features and capabilities. In order to achieve this, the software upgrade is installed on the system and the system is restarted. In mission critical systems such as telecommunication systems, it is highly desirable, and arguably necessary, to preserve flows of information (e.g., voice calls) present as a system is upgraded. It is similarly necessary to accommodate ongoing demand for services (e.g., new calls) during upgrade. Two elements are critical to upgrading without service interruption: First, it must be possible to gracefully control a system, assuring that its component subsystems are upgraded in an orderly fashion. Second, it must be possible to dynamically accommodate the changes in data schema between old and new versions of software. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> Approaches in the past for upgrading systems addressed various types of subsystems within the systems individually. However, as systems have expanded, the number of subsystems that typically make up a system has also increased. With the increased number of subsystems in a system, addressing subsystems individually becomes more difficult. The likelihood of errors resulting in loss of service increases, which is undesirable. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> According to an embodiment of the present invention, a method for managing upgrade steps on a system that includes a subsystem of a first type and a subsystem of a second type that is subordinate to the subsystem of the first type includes initiating an upgrade step on the subsystem of the first type and initiating the upgrade step on the subsystem of the second type after completion of the upgrade step on the subsystem of the first type. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> According to an embodiment of the present invention, a method for reverting to a prior software after an upgrade to a new software on a system that includes a subsystem of a first type and a subsystem of a second type that is subordinate to the subsystem of the first type includes initiating a reversion on the subsystem of the second type and initiating the reversion on the subsystem of the first type after completion of the reversion on the subsystem of the second type. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> According to an embodiment of the present invention, a method for managing an upgrade to a new software on a subsystem that includes a first non-volatile memory store, a second non-volatile memory store, an active volatile memory store, a standby volatile memory store, active equipment, standby equipment includes upgrading the standby equipment to the new software, synchronizing dynamic data from the active volatile memory store to the standby volatile memory store, synchronizing dynamic data from the active volatile memory store to the first non-volatile memory store, synchronizing dynamic data from the first non-volatile memory store to the second non-volatile memory store, swapping the standby equipment with the active equipment, synchronizing dynamic data from the new active volatile memory store to the new standby volatile memory store, synchronizing dynamic data from the new active volatile memory store to the s econd non-volatile memory store, synchronizing dynamic data from the second non-volatile memory store to the first non-volatile memory store, upgrading the new standby equipment to the new software and synchronizing dynamic data from the new active volatile memory store to the new standby volatile memory store. </paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> The present invention is illustrated by way of example and not by way of limitation in the figures of the accompanying drawings, in which like references indicate similar elements and in which: </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> illustrates a process diagram for an upgrade, according to an exemplary embodiment of the present invention. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> illustrates a subsystem memory model, according to an exemplary embodiment of the present invention. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> illustrates how new software is transferred onto the system, according to an exemplary embodiment of the present invention. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> illustrates how the system manager distributes the software to the various subsystems, according to an exemplary embodiment of the present invention. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> illustrates methods of tiering subsystems for upgrade and chaining subsystem upgrades within groups of subsystems, according to exemplary embodiments of the present invention </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> illustrates the steps of Dividing, Testing, or Committing a subsystem, according to an exemplary embodiment of the present invention. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> illustrates Dividing a subsystem, according to an exemplary embodiment of the present invention. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> illustrates Testing a subsystem, according to an exemplary embodiment of the present invention. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference> illustrates Committing a subsystem, according to an exemplary embodiment of the present invention. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10</cross-reference> illustrates chaining and tiering during a commanded reversion, according to an exemplary embodiment of the present invention. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 11</cross-reference> illustrates chaining and tiering during an autonomous reversion, according to an exemplary embodiment of the present invention. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 12</cross-reference> illustrates synchronization of accounting records during an upgrade, according to an exemplary embodiment of the present invention. </paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION </heading>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> In an exemplary embodiment of the present invention, a system manager is a server that acts in an executive capacity to orchestrate upgrade of the subsystems it manages. The process of upgrade may be initiated by a privileged user of the system manager. The system manager is upgraded first and the subsystems are upgraded second. To simplify administration of upgrades yet minimize complexity associated with changes to protocols operating at subsystem interfaces, subsystems can be upgraded in groups. For example, subsystems of a particular type can be upgraded together as a group. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> In an exemplary embodiment of the present invention, upgrade of any subsystem or group of subsystems follows a set of states. Three major states of a subsystem during an upgrade are Divided, Testing, and Committing. A subsystem is in the Divided state when the subsystem is actively operating with its old software, but is fully prepared to begin executing its new software when commanded. A subsystem is in the Testing state when its equipment is running the new software. A subsystem is in the Committing state when the subsystem is executing the sequence of operations necessary finally accept the new software. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> In an exemplary embodiment of the present invention, transitions between states are ordinarily commanded by the system manager user but may occur autonomously under certain conditions. For example, in case there is a failure that impairs service or causes loss of management control over a subsystem, the failed subsystem autonomously reverts to a configuration that provides service from the originally-operating version of software, and the system manager commands any other subsystems being upgraded to revert to their originally-installed software as well. In the absence of failures, transitions between states upgrades can be hitless: new software can be installed, Tested, and either Committed to permanent use or backed-out all without loss of stable calls and without significant impairment to service. In case of a failure that seriously impairs service, reversion can occur autonomously or can be commanded. After Committing a subsystems or a cluster (a group of one or more subsystems) to use newly installed software, it can be possible to downgrade them to their former software. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> In an exemplary embodiment of the present invention, system services are available throughout the upgrade process. The system preserves already-established calls/connections and handles ongoing demands for service throughout its upgrade. The subsystems rapidly switch between old and new loads without loss of pertinent dynamic data related to the system, such as for example call records, connection records, connections in hardware. Preserving dynamic data will ensure the integrity of bearer channels and permits proper accounting for services. To facilitate rapid switching, each subsystem assures dynamic resource persistence between its &ldquo;old&rdquo; and &ldquo;new&rdquo; software. This persistence is bi-directional. For example, when a subsystem is preparing to run new software, the new software has current knowledge of the state of calls/connections first handled by the old software. Similarly, once a subsystem is commanded to run with its new software, the old software is updated with the current calls/connection information in case reversion is commanded. To assure that switching between loads can be rapidly accomplished, dynamic resource persistence typically requires ongoing synchronization between the new and old copies of software while in Divided and Testing states. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> In an exemplary embodiment of the present invention, the system is aware of services delivered during the course of upgrade to later charge for the service delivered. The system preserves its accounting data through and upgrade or reversion. Moreover, the system formats the data if the new software calls for a different accounting data format. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> In an exemplary embodiment of the present invention, the upgrade process provides for the upgrade independent, disparate subsystems. For example, a set of subsystems associated with call/connection processing can be upgraded simultaneously. Since different subsystems will likely have different rates of progress through upgrade, the upgrade of subsystems can be chained. For example, in an upgrade involving two types of subsystems, subsystems of one type are all advanced to the Divided state before any subsystems of the second type are advanced. Chaining is executed in reverse in the case of a reversion. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> In an exemplary embodiment of the present invention, the system can be highly scalable. Since the system can be very large, an operator may judge that there is significant risk associated with upgrading the entire system at once. Additionally, the logistics of a large-scale upgrade can be complex from the standpoint of assuring all equipment and facilitates are in a state amenable to upgrade. To help manage upgrades of large systems, incremental upgrade of groups of subsystems is permitted. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> In an exemplary embodiment of the present invention, the system is comprised of independent subsystems, with well-defined protocols operating at inter-subsystem interfaces. As features are added to the system over time, inter-subsystem protocols may change. To assure uninterrupted service delivery in the face of protocol changes, the overall process of upgrade is tiered, with subsystems and groups of subsystems upgraded in a particular order. For example, the devices having external control and management interfaces are upgraded first and the devices having internal interfaces are upgraded second. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> illustrates a process flow diagram according to an exemplary embodiment. The system&apos;s entire software bundle is first transferred onto the system manager at step <highlight><bold>100</bold></highlight> and second, the appropriate software is distributed to each managed subsystem at step <highlight><bold>105</bold></highlight>. An embodiment of the present invention can execute certain checks on the transferred and distributed software. For example, at step <highlight><bold>110</bold></highlight>, after both transfers, the integrity of the transferred files can be checked to assure that there has been no corruption in the transfer. Further at step <highlight><bold>115</bold></highlight>, the system checks whether newly distributed software is compatible with the hardware and software presently installed in the system. Incompatibilities can be communicated so that they can be rectified before upgrade is actually attempted. At step <highlight><bold>120</bold></highlight>, the system can also run a configuration check after software distribution and communicate any configuration changes necessary to permit upgrade. As problems are corrected, the system manager user can re-run checks to verify problems have been cleared. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> Next, the system manager is upgraded. At step <highlight><bold>130</bold></highlight>, the system manager Divides, or prepares its new software for execution. At step <highlight><bold>135</bold></highlight>, the system manager Tests the new software by initializing certain of its components with the new software. At step <highlight><bold>140</bold></highlight>, the system manager Commits the new software by executing additional steps to complete the upgrade to the new software. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> After the system manager user commands a cluster (a group of one or more subsystems) to upgrade, the integrity, compatibility and configuration checks are repeated in each of the subsystems in the cluster in the Divide state at step <highlight><bold>145</bold></highlight>. If the checks pass, each subsystem in a cluster prepares its new software for execution, by for example replicating and converting its existing static configuration data to a format which is compatible with the new software at the Test state. At step <highlight><bold>150</bold></highlight> in the Test state, each subsystem in a cluster then initializes certain of its components with the new software and converted data, readying them for actual use. The components are placed into active operation by another command from the system manager user, and Committed to permanent use after a period of Testing in the Commit state at step <highlight><bold>155</bold></highlight>. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> The procedure suggests that database back-ups are to be performed before and after upgrade, at steps <highlight><bold>125</bold></highlight> and <highlight><bold>165</bold></highlight>, with the results of each back up transferred off of the system manager for safekeeping. It is possible, though, to create a back up at any point during the upgrade process. This is desirable to limit risk when a large system is being upgraded and the overall process spans more than one maintenance window, for example, if one cluster is being upgraded per day. It this case, it may be desirable to perform a back up after each maintenance window, that is, after the system manager is upgraded, and as each successive cluster is upgraded. </paragraph>
</section>
<section>
<heading lvl="1">Subsystem Memory Model </heading>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> To gracefully upgrade a set of heterogeneous subsystems, it is necessary to impose some uniformity on upgrade process, such as for example in a memory model for each of the subsystems. In an exemplary embodiment, all upgradeable subsystems, including the system manager, support a standard memory model. The memory model described herein is not intended to impose a particular approach on any subsystem, particularly in regard to volatile memory. At the same time, in an exemplary embodiment, subsystems align with a standard memory model to ensure that the each class of data manipulated is given appropriate and uniform treatment independent of the quantity and types of subsystems being upgraded. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> illustrates a subsystem memory model for an exemplary embodiment. The model splits non-volatile memory into two areas: a first Store A <highlight><bold>200</bold></highlight> and a second Store B <highlight><bold>205</bold></highlight>. It also splits volatile memory into two stores: Standby <highlight><bold>210</bold></highlight> and Active <highlight><bold>215</bold></highlight>. Each non-volatile store contains a program area that holds a software version and associated data that must persist across power cycling. The data in each store have a schema and formatting compatible with that required by the particular software version, in addition to the subsystem&apos;s static configuration data and operational history. There is allowance for two copies of static configuration data reflecting the provisioning of the subsystem, one reflecting the current configuration, the other reflecting its state at a past time. There is also allowance for historical operational data of various types: accounting records (the basis for service billing), and alarm log, and historical operational meters from recently passed collection intervals. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> Each volatile memory store contains a program area and associated static configuration data loaded from one of the non-volatile stores. In addition, each contains dynamic data describing for example existing calls/connections, equipment/facility operational states, and the operational meters being currently being acquired. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> During normal operation, a subsystem re-initializes both of its volatile memory stores from one of the non-volatile memory stores, that store being designated by a binary &ldquo;latch&rdquo; which is itself maintained in non-volatile storage. The other non-volatile memory store is therefore available for use during the upgrade process. Further, a subsystem operating in its normal manner has extra components standing by to provide service in the event of failures, and switchover to these components is hitless from the standpoint of users of the equipment. Therefore, as long as upgrade is conducted at a time when there are no failures present, these standby components are available to be loaded with new software and data, and can be switched-in under manual control to effect an upgrade. The volatile memories can therefore be associated with the active and standby components of a subsystem. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> The process of upgrading a subsystem, then, can broadly be thought of as first updating the unused non-volatile store with a new program and corresponding data, then loading the new program and data into the volatile memory associated with standby components. The upgrade can be tested by making the standby components active. When Committing the upgrade, the content of the unused store is marked as in-use by flipping the latch identifying the Committed store, and the other volatile memory store is loaded with the just-marked store&apos;s content. While this seems straightforward, the requisite synchronization of call/connection data to preserve service, manipulation of accounting data enable customers to be billed (or inter-carrier charges to be reconciled), and preservation of critical management information are carefully kept throughout the upgrade process. </paragraph>
</section>
<section>
<heading lvl="1">Transferring the New Software onto the System </heading>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> illustrates how the new software is transferred onto the system in an exemplary embodiment. The system manager user using a system manager GUI places new software on the system by transferring it from a source <highlight><bold>300</bold></highlight>, e.g., from a CD-ROM on the system manager user&apos;s workstation or direct FTP transfer from another host. The system manager user commands the transfer via the system manager GUI, identifying the source file for the transfer. The destination is, implicitly, an unused program area <highlight><bold>305</bold></highlight> within a non-volatile memory store <highlight><bold>310</bold></highlight> on the system manager. As the transfer takes place, the system manager user receives periodic progress updates. On completion of the transfer, the integrity of the software just loaded is checked, with a successful transfer being indicated if the integrity check passes. </paragraph>
</section>
<section>
<heading lvl="1">Distributing the New Software to the Subsystems </heading>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> illustrates how the system manager distributes the software to the various subsystems in an exemplary embodiment. When commanded to distribute software, the system manager sequentially performs the distribution <highlight><bold>400</bold></highlight> using a standard file transfer protocol and initiates an integrity check <highlight><bold>405</bold></highlight>, a compatibility check <highlight><bold>410</bold></highlight>, and a configuration check <highlight><bold>415</bold></highlight> on each subsystem to be upgraded. </paragraph>
</section>
<section>
<heading lvl="1">Integrity Check </heading>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> This check assures that the software residing in a non-volatile memory store in the system manager or a subsystem has integrity, e.g., through a CRC check on the file(s) comprising the software load and through identification of the file(s) as actually comprising a software load. The result of the integrity check can be revealed through an attribute associated with the non-volatile memory store being checked. The attribute can identify for example either the bundle name if the integrity check passes, or a null value if it fails. This check may also be invoked independently, for example, as part of a periodic audit of the integrity of non-volatile memory. </paragraph>
</section>
<section>
<heading lvl="1">Compatibility Check </heading>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> This check determines whether the software in a standby volatile memory store in the system manager or a subsystem is compatible with the software in the active volatile memory store and the system manager or subsystem&apos;s presently installed hardware components. The result of the check can be revealed through posting/clearing of one or more off-normal conditions. To facilitate correction of incompatibilities prior to upgrade, it is preferred that subsystems log all incompatibilities detected when this check is requested. Incompatibilities can be logged in an alarm log associated with the volatile memory store from which programs are being executed. </paragraph>
</section>
<section>
<heading lvl="1">Configuration Check </heading>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> This check determines whether the system manager or subsystem equipment and facilities are in a state suitable to permit upgrade. For the check to pass, two conditions must be met. First, all equipment in the subsystem must be operating without faults. Second, the state of any major facilities on which the process of upgrade is dependent must be such that upgrade can be completed. Should a configuration check fail, it is incumbent on the subsystem to identify the problem(s) detected. When requested to check its configuration, it is preferred that a subsystem not only check the state equipment and facilities, but also reconfigure itself as necessary in preparation for upgrade, e.g., make all &ldquo;A&rdquo;-side components active and all &ldquo;B&rdquo;-side components standby. </paragraph>
</section>
<section>
<heading lvl="1">Tiering and Chaining the Upgrade of Subsystems and Clusters </heading>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> illustrates exemplary embodiment methods of tiering subsystems for upgrade and chaining subsystem upgrades within groups of subsystems. Possible orderings are suggested in the figure. For example, in one ordering, the system manager <highlight><bold>500</bold></highlight> is upgraded first and after Committing the system manager to its new software, the subsystems and clusters are upgraded. First, the SGs <highlight><bold>505</bold></highlight> are upgraded. After Committing the SGs, each cluster <highlight><bold>511</bold></highlight> of iGCs <highlight><bold>510</bold></highlight> and MGs <highlight><bold>515</bold></highlight> are upgraded as a chained group (multiple clusters could be upgrade in parallel, if desired) because the iGCs and MGs are subordinate to the SGs <highlight><bold>505</bold></highlight>. Finally, after Committing each cluster of iGCs and MGs, IVRs <highlight><bold>520</bold></highlight> are upgraded because the IVRs are subordinate to the iGCs and MGs. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> The orderings illustrated in <cross-reference target="DRAWINGS">FIG. 5</cross-reference> are not the only ones that can be contemplated, however, and the upgrade process of the present invention is therefore developed to allow for orderings to be changed between releases. While it can generally be anticipated that the subsystems which terminate external control and management interfaces must be upgraded early on, an exemplary embodiment upgrades the system manager first and that the system manager is upgraded alone. Since the program logic that orders upgrade is part of the system manager software, the order of subsystem upgrade for a new software release can be changed as desirable with the upgrade of the system manager. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> Note that when upgrading a group of chained subsystems, autonomous reversion of a particular subsystem may cause a loss of service within chained subsystems due to protocol incompatibilities. The system manager is in any case expected to enforce the chaining rule for reversion, since this ensures management control can be exercised over each subsystem and helps preserve service to the extent possible during reversion of subsystems not affected by the failure. </paragraph>
</section>
<section>
<heading lvl="1">Dividing, Testing and Committing </heading>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> illustrates the steps of Dividing, Testing, or Committing a subsystem in an exemplary embodiment. The system manager user initiates these steps through a system manager GUI. In processing a command, the system manager accounts for tiering and chaining of subsystems. For example, the system manager initiates an upgrade step on the subsystems in tier <highlight><bold>1</bold></highlight> at step <highlight><bold>600</bold></highlight> and waits for the upgrade steps to complete before initiating any further upgrade steps in the intermediate subsystems at step <highlight><bold>605</bold></highlight>. The system manager user receives periodic notifications of the progress of the any of these commands when they are conducted on the subsystems. </paragraph>
</section>
<section>
<heading lvl="1">Dividing a Subsystem </heading>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> illustrates Dividing a subsystem in an exemplary embodiment. In a Divide, the standby volatile memory store is upgraded to the new software. The steps of Dividing include: executing integrity, compatibility, and configuration checks on the new software; inhibiting changes to static data on the non-volatile memory store A <highlight><bold>700</bold></highlight>; formatting the static data on non-volatile memory store A <highlight><bold>700</bold></highlight> to be compatible with the new software, copying the formatted static data from the non-volatile memory store A <highlight><bold>700</bold></highlight> to the non-volatile memory store B <highlight><bold>705</bold></highlight>; copying the static data from the non-volatile memory store B <highlight><bold>705</bold></highlight> to the standby volatile memory store <highlight><bold>710</bold></highlight>; copying the new software from the non-volatile memory store B <highlight><bold>705</bold></highlight> to the standby volatile memory store, restarting the standby equipment with the static data and the new software; synchronizing dynamic data from the active volatile memory store <highlight><bold>715</bold></highlight> to the standby volatile memory store <highlight><bold>710</bold></highlight>; synchronizing dynamic data from the active volatile memory store <highlight><bold>715</bold></highlight> to the non-volatile memory store A <highlight><bold>700</bold></highlight>; synchronizing dynamic data from the non-volatile memory store A <highlight><bold>700</bold></highlight> to the non-volatile memory store B <highlight><bold>705</bold></highlight>. Additionally, alarm conditions expected during the upgrade may be inhibited. Moreover, synchronizing dynamic data from the active volatile memory store <highlight><bold>715</bold></highlight> to the standby volatile memory store <highlight><bold>710</bold></highlight> is ongoing throughout the upgrade. Finally, the steps in the Divide need not be executed in the order described. For example, a subsystem might convert all its static data and then re-initialize its components one at a time. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> There are many benefits provided by the steps of the Divide. For example, since the dynamic data is continually synchronized throughout the upgrade, if a reversion ever occurs, a subsystem is able to recover valuable accounting data. In addition, in the event of a problem that causes the standby volatile memory <highlight><bold>710</bold></highlight> (which holds for example the new software and static data formatted to be compatible with the new software) to be lost due to for example power cycling, the non-volatile store B <highlight><bold>705</bold></highlight> holds a copy of this information to enable a subsystem to retry an upgrade. </paragraph>
</section>
<section>
<heading lvl="1">Testing a Subsystem </heading>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> illustrates Testing a subsystem in an exemplary embodiment. In Testing, the standby components (which were restarted with the new software during the Divide) are &ldquo;swapped&rdquo; with the active components. In other words, the standby components are now labeled and recognized by the system as the new active components and the active components are now labeled and recognized by the system as the new standby components. Also, the standby volatile memory is now labeled and recognized by the system as the new active volatile memory and the active volatile memory is now labeled and recognized by the system as the new standby volatile memory. The steps of Testing include: &ldquo;swapping&rdquo; active and standby components; purging alarm log, historical and current operational meters; synchronizing dynamic data from the new active volatile memory store <highlight><bold>815</bold></highlight> to the new standby volatile memory store <highlight><bold>810</bold></highlight>; synchronizing dynamic data from the new active volatile memory store <highlight><bold>815</bold></highlight> to the non-volatile memory store B <highlight><bold>805</bold></highlight>; synchronizing dynamic data from the non-volatile memory store B <highlight><bold>805</bold></highlight> to the non-volatile memory store A <highlight><bold>800</bold></highlight>; and allowing changes to static data. Synchronizing dynamic data from the active volatile memory store <highlight><bold>815</bold></highlight> to the standby volatile memory store <highlight><bold>810</bold></highlight> is ongoing throughout the upgrade. Alternatively, the step of purging alarm log, historical and current operational meters may be executed before transitioning to the Divide state, particularly if purging significantly extends the influences the duration of service denial in transiting to Testing state. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> There are many benefits provided by the steps of the Testing state. For example, because changes to static data are allowed, tests of the new software which require provisioning changes can be executed. By allowing changes to static data in the Testing state, the subsystem can more completely exercise the new software prior to Committing it. Because the alarm log, historical and current operational meters are purged, time is not spent synchronizing then. Current operational meters should not be synchronizes since this information must be determined from the now active equipment. Also, alarm information can be obtained in other ways such as an ongoing alarm audit. For example, since the dynamic data is continually synchronized throughout the upgrade, if a reversion ever occurs, a subsystem is able to recover valuable accounting data. In addition, in the event of a problem that causes the standby volatile memory <highlight><bold>810</bold></highlight> (which holds for example the new software and static data formatted to be compatible with the new software) to be lost due to for example power cycling, the non-volatile store B <highlight><bold>805</bold></highlight> holds a copy of this information to enable a subsystem to retry an upgrade. </paragraph>
</section>
<section>
<heading lvl="1">Committing a Subsystem </heading>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference> illustrates Committing a subsystem in an exemplary embodiment. In Committing a subsystem, the new standby volatile memory store (formerly labeled as the active and currently holding the old software) is upgraded to the new software. The steps of Committing include: copying the static data from the non-volatile memory store B <highlight><bold>905</bold></highlight> to the new standby volatile memory store <highlight><bold>910</bold></highlight> ; copying the new software from the non-volatile memory store B <highlight><bold>905</bold></highlight> to the new standby volatile memory store <highlight><bold>910</bold></highlight>; synchronizing dynamic data from the active volatile memory store <highlight><bold>915</bold></highlight> to the standby volatile memory store <highlight><bold>910</bold></highlight>; and restarting the new standby equipment (formerly labeled as the active equipment) with the static data and the new software. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> There are many benefits provided by the steps of the Commit. For example, since the dynamic data is continually synchronized throughout the upgrade, if a reversion ever occurs, a subsystem is able to recover valuable accounting data. In addition, in the event of a problem that causes the standby volatile memory <highlight><bold>910</bold></highlight> (which holds for example the new software and static data formatted to be compatible with the new software) to be lost due to for example power cycling, the non-volatile store B <highlight><bold>905</bold></highlight> holds a copy of this information to enable a subsystem to retry an upgrade. </paragraph>
</section>
<section>
<heading lvl="1">Commanding a Reversion </heading>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10</cross-reference> illustrates chaining and tiering when a reversion of a system of a system is commanded by the system manager user in an exemplary embodiment. The system manager user initiates these steps through a system manager GUI. In processing a command, the system manager accounts for tiering and chaining of subsystems in the opposite order that the upgrade steps of Dividing, Testing, and Committing were executed. For example, the system manager initiates a reversion on the subsystems in the last tier at step <highlight><bold>1000</bold></highlight> and waits for the reversion to complete before initiating any further reversions in the intermediate subsystems at step <highlight><bold>1005</bold></highlight>. The system manager user receives periodic notifications of the progress of the any of these commands when they are conducted on the subsystems. </paragraph>
</section>
<section>
<heading lvl="1">Autonomous Reversion </heading>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 11</cross-reference> illustrates chaining and tiering during an autonomous reversion in an exemplary embodiment. When a subsystem autonomously reverts, the system manager triggers an orderly reversion, notifies the system manager user controlling the upgrade that reversion is occurring and notifies the system manager user periodically of the progress of reversion. As in a commanded reversion, the system manager accounts for tiering and chaining of subsystems in the opposite order that the upgrade steps of Dividing, Testing, and Committing were executed. For example, the system manager initiates a reversion on the subsystems in the last tier at step <highlight><bold>1100</bold></highlight> and waits for the reversion to complete before initiating any further reversions in the intermediate subsystems at step <highlight><bold>1105</bold></highlight>. </paragraph>
</section>
<section>
<heading lvl="1">Commanding a Downgrade </heading>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> In an exemplary embodiment, downgrade is performed in the event of severe problems with a new load that has already been Committed. The system manager user selects subsystems for downgrade in the same manner as they are selected for upgrade. However, selection of subgroups is relaxed to allow multiple tiers to be chosen simultaneously, with the single exception that the system manager must be downgraded by itself last of all. Chaining is not considered during downgrade since the objective is simply to reinitialize whatever group of subsystems is chosen with their old software as quickly as possible. </paragraph>
</section>
<section>
<heading lvl="1">Synchronizing Accounting Data </heading>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> In an exemplary embodiment, in case of reversion, accounting records produced while operating on the new software are available in a billing format for access by a billing collector. A subsystem ensures that all records in any billing file are produced with the same formatting rules and includes versioning information within the each billing file. This approach addresses with the protocol negotiation problem, enabling the billing collector to properly interpret files. When transitioning from old to new software (or vice versa) any records not yet formatted for billing are immediately formatted and added to the billing file currently being produced. The billing file is then closed by the currently operating software, and a new file started by the other software. Records need not otherwise be synchronized between old and new software. In particular, there is no obligation for new software to allow inspection of records produced by old software, or vice versa. A subsystem continuously synchronizes the accounting record areas in the non-volatile stores without regard to the format of the records in individual files. </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 12</cross-reference> illustrates synchronization of accounting records during an upgrade in an exemplary embodiment. At step <highlight><bold>1200</bold></highlight>, a Divide command has no effect on the file being actively written at the time Dividing is commanded. At step <highlight><bold>1205</bold></highlight>, a Test command causes the creation of the N&plus;2 file to cease since the software now coming active may produce records in a different format. Therefore, an N&plus;3 file is started as the software comes active. At step <highlight><bold>1210</bold></highlight>, a Commit command has the same effect as a Divide command, except that information flows are reversed. At step <highlight><bold>1215</bold></highlight>, a Revert command causes the creation of the N&plus;5 file to cease. An N&plus;6 file is started once the old software becomes active, since it may be producing records in a different format that was used for the N&plus;5 file. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> A more general method to synchronize non-volatile accounting records in an exemplary embodiment is described as follows. A subsystem maintains the version of the records it is producing at any point in time through for example an audit record. Active and standby components of a subsystem exchange billing file names and status changes on an ongoing basis. Each component obtains a copy of closed billing files not directly written to it through for example TFTP. Creation of billing files and formatting of records is driven by the active component on the subsystem. The standby component merely supplements its files with copies of records created by the active component. Whenever an active or standby component makes a state transition, any file currently be written is closed and a new file is started. This allows active and standby components to &ldquo;catch-up&rdquo; on records not directly written to their own non-volatile storage. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> When commanded to Divide, the standby component must &ldquo;catch-up&rdquo; with the active component&apos;s billing files after restarting on its new software. On receiving notice that the standby component is operating, the active component closes its current billing file and starts a new one. By doing this, the standby component can immediately begin synchronization with the new file by supplementing its files with copies of records created by the active component and thus avoids the complexity of catching up to a partially filled file. </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> When commanded to Test, the component transitioning to active status opens a new billing file while the component transitioning to standby status closes its file. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> Reversion can be either commanded or autonomous. When commanded, the operation is the same as when commanded to Divide, except that the direction of information transfer is reversed. When autonomous, the general method described above ensures that the newly-active host obtains all available accounting records. </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> In the foregoing description, the invention is described with reference to specific example embodiments thereof. It will, however, be evident that various modifications and changes may be made thereto, without departing from the broader spirit and scope of the present invention. The specification and drawings are accordingly to be regarded in an illustrative rather than in a restrictive sense. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method of managing upgrade steps on a system that includes a subsystem of a first type and a subsystem of a second type that is subordinate to the subsystem of the first type comprising: 
<claim-text>initiating an upgrade step on the subsystem of the first type; and </claim-text>
<claim-text>initiating the upgrade step on the subsystem of the second type after completion of the upgrade step on the subsystem of the first type. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> further comprising receiving a completion indication from the subsystem of the first type. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein initiating an upgrade step on the subsystem of the first type comprises sending a command to the subsystem of the first type to execute the upgrade step. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein initiating the upgrade step on the subsystem of the second type comprises sending a command to the subsystem of the second type to execute the upgrade step. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein the upgrade step comprises distributing software to the subsystem. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein the upgrade step comprises testing software on the subsystem. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. A method for reverting to a prior software after an upgrade to a new software on a system that includes a subsystem of a first type and a subsystem of a second type that is subordinate to the subsystem of the first type comprising: 
<claim-text>initiating a reversion on the subsystem of the second type; and </claim-text>
<claim-text>initiating the reversion on the subsystem of the first type after completion of the reversion on the subsystem of the second type. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference> further comprising receiving a completion indication from the subsystem of the second type. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference> wherein initiating the upgrade step on the subsystem of the second type comprises sending a command to the subsystem of the second type to revert. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference> wherein initiating the reversion on the subsystem of the second type comprises sending a command to the subsystem of the second type to revert. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. A method for managing an upgrade to a new software on a subsystem that includes a first non-volatile memory store, a second non-volatile memory store, an active volatile memory store, a standby volatile memory store, active equipment, standby equipment comprising: 
<claim-text>upgrading the standby equipment to the new software; </claim-text>
<claim-text>synchronizing dynamic data from the active volatile memory store to the standby volatile memory store; </claim-text>
<claim-text>synchronizing the dynamic data from the active volatile memory store to the first non-volatile memory store; </claim-text>
<claim-text>synchronizing the dynamic data from the first non-volatile memory store to the second non-volatile memory store; </claim-text>
<claim-text>swapping the standby equipment with the active equipment; </claim-text>
<claim-text>synchronizing dynamic data from the new active volatile memory store to the new standby volatile memory store; </claim-text>
<claim-text>synchronizing the dynamic data from the new active volatile memory store to the second non-volatile memory store; </claim-text>
<claim-text>synchronizing the dynamic data from the second non-volatile memory store to the first non-volatile memory store; </claim-text>
<claim-text>upgrading the new standby equipment to the new software; and </claim-text>
<claim-text>synchronizing dynamic data from the new active volatile memory store to the new standby volatile memory store. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference> further comprising 
<claim-text>checking if the new software is in an acceptable condition for an upgrade. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference> further comprising 
<claim-text>checking if the new software and hardware of the subsystem are compatible. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference> further comprising 
<claim-text>checking if the hardware of the subsystem is in a configuration to accept the software. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference> wherein upgrading the standby volatile memory store to the new software comprises: 
<claim-text>inhibiting changes to static data on the first non-volatile memory store; </claim-text>
<claim-text>formatting the static data to be compatible with the new software; </claim-text>
<claim-text>copying the static data to the second non-volatile memory store; </claim-text>
<claim-text>copying the static data to the standby volatile memory store; </claim-text>
<claim-text>copying the new software to the standby volatile memory store; and </claim-text>
<claim-text>restarting the standby equipment with the static data and the new software. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference> wherein swapping the standby equipment with the active equipment comprises: 
<claim-text>labeling the standby equipment as a new active equipment; </claim-text>
<claim-text>labeling the active equipment as a new standby equipment; </claim-text>
<claim-text>labeling the standby volatile memory store as a new active volatile memory store; and </claim-text>
<claim-text>allowing changes to the static data. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference> wherein upgrading the new standby volatile memory store to the new software comprises: 
<claim-text>copying the static data to the new standby volatile memory store; </claim-text>
<claim-text>copying the new software to the new standby volatile memory store; </claim-text>
<claim-text>restarting the new standby equipment with the static data and the new software; and </claim-text>
</claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference> wherein static data comprises provisioning data. </claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference> wherein dynamic data comprises accounting data.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>1</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005426A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005426A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005426A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005426A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005426A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005426A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030005426A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030005426A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030005426A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00009">
<image id="EMI-D00009" file="US20030005426A1-20030102-D00009.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00010">
<image id="EMI-D00010" file="US20030005426A1-20030102-D00010.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00011">
<image id="EMI-D00011" file="US20030005426A1-20030102-D00011.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00012">
<image id="EMI-D00012" file="US20030005426A1-20030102-D00012.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
