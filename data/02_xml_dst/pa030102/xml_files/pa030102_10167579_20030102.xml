<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005392A1-20030102-D00000.TIF SYSTEM "US20030005392A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005392A1-20030102-D00001.TIF SYSTEM "US20030005392A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005392A1-20030102-D00002.TIF SYSTEM "US20030005392A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005392A1-20030102-D00003.TIF SYSTEM "US20030005392A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005392A1-20030102-D00004.TIF SYSTEM "US20030005392A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005392A1-20030102-D00005.TIF SYSTEM "US20030005392A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030005392A1-20030102-D00006.TIF SYSTEM "US20030005392A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030005392A1-20030102-D00007.TIF SYSTEM "US20030005392A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030005392A1-20030102-D00008.TIF SYSTEM "US20030005392A1-20030102-D00008.TIF" NDATA TIF>
<!ENTITY US20030005392A1-20030102-D00009.TIF SYSTEM "US20030005392A1-20030102-D00009.TIF" NDATA TIF>
<!ENTITY US20030005392A1-20030102-D00010.TIF SYSTEM "US20030005392A1-20030102-D00010.TIF" NDATA TIF>
<!ENTITY US20030005392A1-20030102-D00011.TIF SYSTEM "US20030005392A1-20030102-D00011.TIF" NDATA TIF>
<!ENTITY US20030005392A1-20030102-D00012.TIF SYSTEM "US20030005392A1-20030102-D00012.TIF" NDATA TIF>
<!ENTITY US20030005392A1-20030102-D00013.TIF SYSTEM "US20030005392A1-20030102-D00013.TIF" NDATA TIF>
<!ENTITY US20030005392A1-20030102-D00014.TIF SYSTEM "US20030005392A1-20030102-D00014.TIF" NDATA TIF>
<!ENTITY US20030005392A1-20030102-D00015.TIF SYSTEM "US20030005392A1-20030102-D00015.TIF" NDATA TIF>
<!ENTITY US20030005392A1-20030102-D00016.TIF SYSTEM "US20030005392A1-20030102-D00016.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005392</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10167579</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20020613</filing-date>
</domestic-filing-data>
<foreign-priority-data>
<priority-application-number>
<doc-number>2001-197867</doc-number>
</priority-application-number>
<filing-date>20010629</filing-date>
<country-code>JP</country-code>
</foreign-priority-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F017/50</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>716</class>
<subclass>002000</subclass>
</uspc>
</classification-us-primary>
<classification-us-secondary>
<uspc>
<class>716</class>
<subclass>018000</subclass>
</uspc>
</classification-us-secondary>
</classification-us>
<title-of-invention>Method of designing a logic circuit</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Masayoshi</given-name>
<family-name>Tojima</family-name>
</name>
<residence>
<residence-non-us>
<city>Fukuoka</city>
<country-code>JP</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
</inventors>
<assignee>
<organization-name>Matsushita Electric Industrial Co., Ltd.</organization-name>
<assignee-type>03</assignee-type>
</assignee>
<correspondence-address>
<name-1>Jack Q. Lever, Jr.</name-1>
<name-2>McDERMOTT, WILL &amp; EMERY</name-2>
<address>
<address-1>600 Thirteenth Street, N.W.</address-1>
<city>Washington</city>
<state>DC</state>
<postalcode>20005-3096</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">An algorithm C description describing an algorithm of computation or control of a logic circuit in a C language is split into a plurality of states in units of processing, and the execution order of the split processing is described as state transition, to generate a functional C description with a control description embedded therein. A clock description as the conception of time is inserted in the functional C description, to be converted into a RT level C description. The RT level C description is converted into a RT level description in HDL with an existing conversion tool. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> The present invention relates to logic circuit design, and more particularly, to technology of top-down design from C language description. </paragraph>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> Conventionally, hardware of a logic circuit has been designed with a hardware description language (HDL) such as Verilog-HDL and VHDL. In recent years, with the advent of system level description languages called SpecC and SystemC, hardware design with a C language has become a focus of attention. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> One of prior art techniques provides a language with which simulation can be performed at an intermediate level between algorithm description and register transfer (RT) level description (disclosed in Japanese Laid-Open Patent Publication No. 2001-109788). <cross-reference target="DRAWINGS">FIG. 16</cross-reference> illustrates a conventional logic simulation system, in which an algorithm description <highlight><bold>103</bold></highlight> is degraded to clock level description. A plurality of functions of the algorithm description <highlight><bold>103</bold></highlight> are disassembled into partial functions operable in a unit clock, and the partial functions are assembled to enable the plural functions to operate. The plurality of functions are expressed in a language using a register as a variable, in the form of a clock level simulator <highlight><bold>108</bold></highlight> that is a clock level description. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> As shown in <cross-reference target="DRAWINGS">FIG. 16, a</cross-reference> clock level verification section <highlight><bold>106</bold></highlight> is provided between an algorithm verification section <highlight><bold>102</bold></highlight> and a RT level verification section <highlight><bold>116</bold></highlight>. The clock level verification section <highlight><bold>106</bold></highlight> includes a clock level system <highlight><bold>107</bold></highlight>, which includes the clock level simulation model <highlight><bold>108</bold></highlight> as the clock level description and a clock level CPU model <highlight><bold>109</bold></highlight>. The clock level system <highlight><bold>107</bold></highlight> is automatically generated by a build-in C compiler <highlight><bold>111</bold></highlight>, and the description thereof is converted using a register, a tool provided by a general-use function synthesis tool <highlight><bold>112</bold></highlight>, as a term (a word or a linear variable). The algorithm description <highlight><bold>103</bold></highlight> is converted into the clock level simulation model <highlight><bold>108</bold></highlight> with a model conversion tool <highlight><bold>113</bold></highlight> having a tool described in the function synthesis tool <highlight><bold>112</bold></highlight>. The clock level CPU model <highlight><bold>109</bold></highlight> is automatically generated from a C program <highlight><bold>104</bold></highlight> by the build-in C compiler <highlight><bold>111</bold></highlight>. A clock base simulator <highlight><bold>114</bold></highlight> is formed of the clock level simulation model <highlight><bold>108</bold></highlight> and the clock level CPU model <highlight><bold>109</bold></highlight>. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> The prior art technique has the following problems. In recent years, operation synthesis tools and the like enabling direct conversion into RT level description in HDL have become available. However, circuits designed with such tools are not only significantly large in scale but also low in quality, compared with circuits directly designed with RT level description. In addition, since free control of the circuit configuration is not allowed for circuits designed with the above tools, it is very difficult to obtain a circuit intended by the designer, and also very difficult to read a designed circuit. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> In the prior art technique described above, a model is generated considering all of three main hardware components, namely, the data path, the control and the clock. Therefore, the logic verification using the clock level simulator remains complicate although the speed of the verification is faster than RT level verification. In addition, due to the disassembly into functions processible in clock units, the level of abstraction of the resultant description is degraded, resulting in a description as low as the RT level. Therefore, the prior art technique fails to solve the problems relating to the RT level design, such as difficulty in response to change of specifications and complexity in examination of hardware architecture. This still requires detailed design and examination as those required in the RT level design. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> To state more specifically, the description is hardware-oriented to enable clock-unit operation. For example, the clock level verification includes not only the clock but also reset. Although the reset is required to determine the initial state of hardware, it is not required at the stage of examination of hardware architecture and verification of functions. It is rather important to clarify basics of hardware such as the unit of processing, the function block and the unit of control. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> The examination of hardware architecture and design/verification of hardware functions considering clock operation are equivalent to examining three functions of computation function, control function and timing function simultaneously. This complicates the concept. In other words, the clock and the reset are unnecessary during the examination of hardware architecture and the design of hardware functions, and rather cause complexity of the examination. This fails to make use of the advantage of the design in a C language providing a high level of abstraction. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> In the prior art technique described above, to obtain the clock level simulation model <highlight><bold>108</bold></highlight>, it is necessary to write detailed control description by disassembling processing in clock units with a control data flow graph (CDFG) or the like. In this situation, design will be considerably difficult without visualization of hardware in cycle operation. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> In the description of the clock level simulation model <highlight><bold>108</bold></highlight>, one &ldquo;case&rdquo; sentence corresponds to one clock, and the relevant function is broken for each &ldquo;case&rdquo; to simulate a clock. Therefore, to terminate processing for the function, the function must be called repeatedly every cycle. This will be a major cause of reduction in simulation speed. Moreover, one state transition must be allocated to one function. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> An object of the present invention is providing a method of designing a logic circuit capable of designing hardware with good quality from an algorithm description written in a pure C language efficiently in a short period of time. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> The present invention provides a method of designing a logic circuit, including the steps of: converting an algorithm C description describing an algorithm of computation or control of the logic circuit in a C language into a functional C description describing control of hardware by rewriting the algorithm C description according to states in units of processing and describing the processing execution order as state transition (algorithm-functional C conversion step); converting the functional C description generated in the algorithm-functional C conversion step into a register transfer (RT) level C description by inserting a clock description as the conception of time in the functional C description (functional-RTLC conversion step); and converting the RT level C description generated in the functional-RTLC conversion step into a RT level description in HDL (RTLC-HDL conversion step). </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> According to the invention described above, hardware of a logic circuit can be easily designed based on an algorithm C description written in an existing pure C language such as ANSI-C and C&plus;&plus;. In addition, since the functional C description is generated by splitting the algorithm C description into a plurality of states in units of processing irrelevant of a clock cycle, it can be expressed to execute one state in a plurality of cycles. The functional C description is therefore suitable as a description style for examining the hardware architecture at a higher level of abstraction. This enables examination of the hardware architecture at a higher level of abstraction than that conventionally adopted. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> Preferably, the algorithm-functional C conversion step includes the step of splitting the algorithm C description into a plurality of states including at least one idle state or initializing state. By this splitting, even when a clock description is inserted in the functional-RTLC conversion step, the idle state is resumed whenever no operation is performed. This eliminates the necessity of cycle adjustment when the conception of time is added to a state machine. Only the insertion of a clock description is enough. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> Preferably, the algorithm-functional C conversion step includes the step of splitting the algorithm C description into at least a data input state corresponding to data input processing, a computation state corresponding to computation processing, and a result output state corresponding to data output processing. By this splitting, the conversion style to the functional C description can be unified. In addition, the data input state and the result output state can be expressed as states of performing data input/output from/to the outside of a state machine or a module. Therefore, the timing of a clock cycle during data transfer between functions can be easily adjusted when the clock description is inserted in the functional-RTLC conversion step. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> Preferably, the method further includes the step of: verifying functions of hardware including only the data path and the control and excluding the clock using the functional C description (function verification step), wherein the functional-RTLC conversion step is processed when the hardware functions are confirmed correct in the function verification step. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> By the above verification, the data path and the control as hardware components can be finalized at an early stage of design. In addition, since no conception of time exists in the functional C description, the function verification can be performed at high speed and easily. Correction during design change is also easy. This greatly shortens the time required for the design. Furthermore, the execution cycle of each state can be estimated in detail by inserting a clock counting function for each state. This enables estimation of processing performance with high precision. In other words, the functional C description can be used in place of a functional model (simulation model) written in a C language, which is normally prepared in parallel with hardware, and thus redundant development can be avoided. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> Preferably, the method further includes the step of: verifying operation of clock cycle timing of hardware using the RT level C description (operation verification step), wherein the RTLC-HDL conversion step is processed when the clock cycle timing operation is confirmed correct in the operation verification step. By this verification, at the stage of generation of the RT level C description, operation can be verified taking notice of a problem arising in relation with the clock cycle timing. This facilitates the verification, and thus improves the verification efficiency and the debugging efficiency. As a result, the time required for the design is shortened. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> Preferably, in the algorithm-functional C conversion step, the state transition is described in a &ldquo;switch&rdquo; sentence, each of the units of processing is described by multibranch expression, the execution order is expressed by clarifying a transition destination in a &ldquo;case&rdquo;, and one state machine is described so as to close itself by use of a loop expression. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> Therefore, the state machine can be described in an existing C language without changing the algorithm operation. In other words, it is possible to execute computation processing operation in the state machine correctly with insertion of state transition expression without use of a special exclusive language. In addition, since the state transition is not broken every cycle, it is unnecessary to allocate one state transition to one function. It is unnecessary, either, to call a function every cycle, and thus simulation can be executed at high speed. This indicates that the &ldquo;control&rdquo; as a hardware component can be clearly embedded in the computation processing in a C language, and thus the computation part and control part of hardware can be described in the functional C description. This enables not only examination of the hardware architecture at an early stage, but also execution of function verification at high speed. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> Preferably, in the algorithm-functional C conversion step, when a plurality of processing items are executed in parallel in one state, each of a plurality of state machines is described so as to close itself by use of a loop expression. Therefore, parallel operation can be easily described in the algorithm C description in a C language while maintaining the feature of high-speed simulation of the C language without the necessity of changing the operation. This means that description considering parallel operation is possible during examination of the hardware architecture. This enhances the degree of freedom in hardware examination at an early stage and also enables description of an advanced control method. Thus, during the conversion to the RT level C description, also, the description can be easily changed to parallel operation description. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> Preferably, the method further includes the step of rewriting the algorithm C description according to modules taking notice of hardware functions to generate an algorithm C description for each module, as preprocessing to the algorithm-functional C conversion step (module separation step). </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> With the above step, the hardware architecture can be examined at a stage of a higher level of abstraction, and thus a hardware-specific function can be intentionally separated. Therefore, the computation processing function, the storage function and the like can be easily separated. This facilitates the design in the next algorithm-functional C conversion step, and also facilitates the design of the RT level C description. In addition, it is easy to reflect any partial change to relevant function units. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> Preferably, in the module separation step, the algorithm C description is split into at least a memory part and a computation processing part. By this separation, replacement with a memory library is facilitated during generation of a RT level code in HDL. This enables design considering the hardware architecture at an early stage. Therefore, the circuit scale can be prevented from becoming large, enabling design considering a memory, as in the design in HDL. In addition, this facilitates change of a memory to be used and the like. Moreover, since design and simulation can be made by converting only the computation processing part into the functional C description or the RT level C description, the designability and the simulation speed improve. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> Preferably, in the module separation step, an operator corresponding to a soft macro or hard macro of hardware is separated from the algorithm C description as an individual module. By this separation, replacement with a macro library such as a multiplier macro during generation of a RT level code in HDL is facilitated. This enables design considering the hardware architecture at an early stage. Also, increase in circuit scale, which may otherwise be caused when automatic synthesis or the like is adopted, can be definitely prevented. In addition, since design and simulation can be made by converting only the computation processing part, excluding the multiplier macro and the memory part, into the functional C description or the RT level C description, the designability and the simulation speed improve. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> Preferably, in the module separation step, a parameter setting register part for computation processing is separated from the algorithm C description as an individual module. By this separation, partial change, such as change of the number of registers, is possible without changing the code in the computation processing part and the like. Also, since there is no need to search for a desired variable name in a large code, debugging is facilitated in malfunction analysis during function verification. In addition, when implemented as hardware, the register part can be easily replaced with a memory. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> Preferably, in the functional-RTLC conversion step, a state transition description representing the control and a computation processing description representing the data path are extracted from the functional C description, and a clock description as the conception of time is inserted in each of the extracted state transition description and computation processing description. Therefore, as in the description of the RT level in HDL, the code readability improves, and debugging in malfunction analysis during verification improves. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> Preferably, in the functional-RTLC conversion step, the RT level C description is generated by adopting grammar of SystemC or SpecC. Therefore, the design language can be determined after the verification of the hardware function independent of the design language. Thus, design can be started without the necessity of determining the design language, the simulation tool, the operation synthesis tool and the like at the start of development. This greatly improves the development efficiency, and shortens the time required for the development. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> The present invention also provides a computer-readable recording medium including a recorded program, the program enabling a computer to execute the steps of: converting an algorithm C description describing an algorithm of computation or control of a logic circuit in a C language into a functional C description describing control of hardware by rewriting the algorithm C description according to states in units of processing and describing the processing execution order as state transition (algorithm-functional C conversion step); and converting the functional C description generated in the algorithm-functional C conversion step into a register transfer (RT) level C description by inserting a clock description as the conception of time into the functional C description (functional-RTLC conversion step). </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> The present invention further provides a program prepared to enable a computer to execute the steps of: converting an algorithm C description describing an algorithm of computation or control of a logic circuit in a C language into a functional C description describing control of hardware by rewriting the algorithm C description according to states in units of processing and describing the processing execution order as state transition (algorithm-functional C conversion step); and converting the functional C description generated in the algorithm-functional C conversion step into a register transfer (RT) level C description by inserting a clock description as the conception of time into the functional C description (functional-RTLC conversion step).</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is an illustration of a configuration of a top-down design system from C language description of Embodiment 1 of the present invention. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a flowchart of processing of a method of designing a logic circuit of Embodiment 1 of the invention. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is an illustration of an example of splitting of algorithm C description with GUI in Embodiment 1 of the invention. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 4A and 4B</cross-reference> are illustrations of an example of state separation in Embodiment 1 of the invention. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is an illustration of an example of a RT level description with insertion of a clock description. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 6A</cross-reference> to <highlight><bold>6</bold></highlight>D are illustrations of examples of descriptions representing parallel operation and state separation of a description. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> is an illustration of a configuration of a top-down design system from C language description of Embodiment 2 of the present invention. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> is a flowchart of processing of a method of designing a logic circuit of Embodiment 2 of the invention. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference> is an illustration of an example of splitting of an algorithm C description with GUI in Embodiment 2 of the invention. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 10A and 10B</cross-reference> are illustrations of an example of state separation in Embodiment 2 of the invention. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 11A and 11B</cross-reference> are illustrations of an example of conversion of a state-separated description in Embodiment 2 of the invention. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 12A and 12B</cross-reference> are illustrations of an example of conversion to a RT level C description in Embodiment 2 of the invention. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 13</cross-reference> is an illustration of a configuration of a top-down design system from C language description of Embodiment 3 of the present invention. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 14</cross-reference> is a flowchart of processing of a method of designing a logic circuit of Embodiment 3 of the invention. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 15A and 15B</cross-reference> are illustrations of an example of a converted description in Embodiment 3 of the invention. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 16</cross-reference> is an illustration of a configuration of a conventional logic simulation system.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DESCRIPTION OF THE PREFERRED EMBODIMENTS </heading>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> Hereinafter, preferred embodiments of the present invention will be described with reference to the accompanying drawings. </paragraph>
<paragraph id="P-0048" lvl="7"><number>&lsqb;0048&rsqb;</number> Embodiment 1 </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> illustrates a configuration of a logic circuit design system of Embodiment 1 of the present invention, which is a hardware top-down design system from C language description. Referring to <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, the reference numeral <highlight><bold>1</bold></highlight> denotes an algorithm C description, which is a description of an algorithm of computation or control of a logic circuit as a design object system written in a C language, <highlight><bold>2</bold></highlight> denotes a functional C description describing control of hardware, <highlight><bold>3</bold></highlight> denotes a RT level C description, which is a C language description at a register transfer (RT) level. The algorithm C description <highlight><bold>1</bold></highlight> is written in an existing C language such as ANSI-C and C&plus;&plus;. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> An algorithm verification system <highlight><bold>10</bold></highlight> generates an algorithm C simulator <highlight><bold>12</bold></highlight> by compiling the algorithm C description <highlight><bold>1</bold></highlight> with a C compiler <highlight><bold>11</bold></highlight>. An algorithm-functional C conversion system <highlight><bold>20</bold></highlight>, which includes a state separation means <highlight><bold>21</bold></highlight>, converts the algorithm C description <highlight><bold>1</bold></highlight> into the functional C description <highlight><bold>2</bold></highlight>. A function verification system <highlight><bold>30</bold></highlight> generates a functional C simulator <highlight><bold>32</bold></highlight> by compiling the functional C description <highlight><bold>2</bold></highlight> with a C compiler <highlight><bold>31</bold></highlight>. A functional-RTLC conversion system <highlight><bold>40</bold></highlight>, which includes a clock insertion means <highlight><bold>41</bold></highlight>, converts the functional C description <highlight><bold>2</bold></highlight> into the RT level C description <highlight><bold>3</bold></highlight>. A timing verification system <highlight><bold>50</bold></highlight> generates a cycle base C simulator <highlight><bold>52</bold></highlight> by compiling the RT level C description <highlight><bold>3</bold></highlight>, together with a library <highlight><bold>4</bold></highlight> for permitting clock description, with a C compiler <highlight><bold>51</bold></highlight>. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> An existing conversion tool <highlight><bold>60</bold></highlight> for converting C language grammar into HDL description is used for conversion of the RT level C description <highlight><bold>3</bold></highlight> into Verilog-HDL <highlight><bold>5</bold></highlight> as a RT level description in HDL. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a flowchart of the logic circuit design method of this embodiment. In <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, step S<highlight><bold>1</bold></highlight> is an algorithm verification step in which an algorithm is verified using the algorithm C simulator <highlight><bold>12</bold></highlight>. Step S<highlight><bold>2</bold></highlight> is an algorithm-functional C conversion step in which after finalization of the algorithm in step S<highlight><bold>1</bold></highlight>, a description in a module of the algorithm C description <highlight><bold>1</bold></highlight> is split into states in functional units of processing by the algorithm-functional C conversion system <highlight><bold>20</bold></highlight>, to thereby convert the algorithm C description <highlight><bold>1</bold></highlight> into the functional C description <highlight><bold>2</bold></highlight>. Step S<highlight><bold>3</bold></highlight> is a function verification step in which hardware functions in the functional C description <highlight><bold>2</bold></highlight> obtained in the step S<highlight><bold>2</bold></highlight> are verified using the functional C simulator <highlight><bold>32</bold></highlight>. Step S<highlight><bold>4</bold></highlight> is a functional-RTLC conversion step in which after finalization of the functions in the step S<highlight><bold>3</bold></highlight>, a clock description is inserted in the functional C description <highlight><bold>2</bold></highlight>, to thereby convert the functional C description <highlight><bold>2</bold></highlight> into the RT level C description <highlight><bold>3</bold></highlight>. Step S<highlight><bold>5</bold></highlight> is an operation verification step in which the operation of the RT level C description <highlight><bold>3</bold></highlight> is verified using the cycle base C simulator <highlight><bold>52</bold></highlight> taking notice of the timing of the clock cycle. Step S<highlight><bold>6</bold></highlight> is a RTLC-HDL conversion step in which after confirmation of the operation at the clock timing in the step S<highlight><bold>5</bold></highlight>, the RT level C description <highlight><bold>3</bold></highlight> is converted into the Verilog-HDL <highlight><bold>5</bold></highlight> with the conversion tool <highlight><bold>60</bold></highlight>. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> Hereinafter, the logic circuit design method of this embodiment will be described with reference to FIGS. <highlight><bold>1</bold></highlight> to <highlight><bold>5</bold></highlight>. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> First, in the algorithm verification step S<highlight><bold>1</bold></highlight>, the algorithm C description <highlight><bold>1</bold></highlight> is compiled by the C compiler <highlight><bold>11</bold></highlight>, such as cc and gcc, in the algorithm verification system <highlight><bold>10</bold></highlight>, to generate the algorithm C simulator <highlight><bold>12</bold></highlight> for verification of the algorithm. Computation processing (data path) only is then verified using the algorithm C simulator <highlight><bold>12</bold></highlight>. Together with this verification, whether or not the algorithm has been finalized is determined. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> Correction of the algorithm C description <highlight><bold>1</bold></highlight> and verification of the corrected description are repeated until the algorithm has been finalized. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> In the algorithm-functional C conversion step S<highlight><bold>2</bold></highlight>, after finalization of the algorithm in the algorithm verification step S<highlight><bold>1</bold></highlight>, the algorithm C description <highlight><bold>1</bold></highlight> is converted into the functional C description <highlight><bold>2</bold></highlight> by rewriting the algorithm C description <highlight><bold>1</bold></highlight> according to the states in units of processing. For example, a description in each module of the algorithm C description <highlight><bold>1</bold></highlight> is split into states in units of processing, such as the initializing state corresponding to data input processing, the computation executing state corresponding to computation processing, and the result outputting state corresponding to data output processing. In addition, the transition destinations, transition conditions and transition order of the separated states are described. In this way, the description corresponding to &ldquo;control&rdquo; of hardware is embedded in the functional C description <highlight><bold>2</bold></highlight>. </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> The conversion processing described above can be implemented by embedding a keyword, in the form of a comment sentence or the like, in a line at which splitting is desired, and performing program conversion according to the keyword. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> Herein, a method of the state separation with GUI will be described with reference to <cross-reference target="DRAWINGS">FIG. 3</cross-reference>. Referring to <cross-reference target="DRAWINGS">FIG. 3</cross-reference>, an algorithm C description <highlight><bold>71</bold></highlight> before conversion is displayed on a GUI screen <highlight><bold>70</bold></highlight>. The user selects a portion <highlight><bold>72</bold></highlight> recognized as a group of processing on the screen, and specifies the state name in &ldquo;State name&rdquo; <highlight><bold>73</bold></highlight>, the execution order of the processing in &ldquo;Order&rdquo; <highlight><bold>74</bold></highlight>. The user also enters the condition under which the state is broken in &ldquo;End Condition&rdquo; <highlight><bold>75</bold></highlight>. By specifying as described above, a functional C description <highlight><bold>76</bold></highlight> after conversion is prepared by program conversion executed by the state separation means <highlight><bold>21</bold></highlight>. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 4A and 4B</cross-reference> illustrate an example of state separation, in which <cross-reference target="DRAWINGS">FIG. 4A</cross-reference> is an example of the algorithm C description before state separation and <cross-reference target="DRAWINGS">FIG. 4B</cross-reference> is an example of functional C description after the state separation. In the algorithm C description shown in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>A, texts A, B and C are considered as representing an initializing and idle state, a computation executing state and a result outputting state, respectively, and the execution order can be as follows. After initialization in the text A, the process proceeds to the text B to execute computation processing. Once the computation end condition is satisfied in the text B, the process proceeds to the text C to output the computation result. Once the computation result is output, the process returns to the text A as the idle state. </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> As a result of the conversion according to the state separation and the execution order described above, a functional C description as shown in <cross-reference target="DRAWINGS">FIG. 4B</cross-reference> is obtained. The separated units of processing A, B and C are respectively described in the form of a &ldquo;case&rdquo; in a &ldquo;switch&rdquo; sentence as multi-branched expression. The execution order of the units of processing is expressed by assigning the transition destination to the &ldquo;state&rdquo; in each &ldquo;case&rdquo;. Although the &ldquo;switch-case&rdquo; sentence is used as multi-branched expression in the illustrated example, any other means may be used as long as multi-branched expression is provided. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> Since the functional C description is written in a C language like the algorithm C description, the &ldquo;switch&rdquo; sentence is closed using a &ldquo;do&rdquo; &ldquo;while&rdquo; sentence. As the condition for breaking the &ldquo;while&rdquo; sentence, the idle state A is designated. With this description, during the execution of processing, the switch sentence is broken when the process returns to the unit of processing A after all the units of processing A, B and C are completed. This means that when this processing is executed next time, the process starts in the state of the unit of processing A. Although the &ldquo;do&rdquo; &ldquo;while&rdquo; sentence is used as loop expression to close a state machine in the illustrated example, other loop expression such as a &ldquo;while&rdquo; sentence and a &ldquo;for&rdquo; sentence may be used. In the case of using &ldquo;while(1)&rdquo;, a &ldquo;break&rdquo; sentence may be inserted in the state C before returning to the idle state. </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> In other words, it is possible to complete the functional C description capable of expressing an operation equivalent to the algorithm of breaking the state transition at the time of termination of the processing and also having a description clarifying &ldquo;control&rdquo; of hardware embedded therein. </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> Hereinafter, the function and effect of providing the idle state will be described. </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> When a clock is inserted, a circuit always operates. However, by setting a state machine to always return to the idle state, the circuit maintains the idle state as long as the condition for state transition fails to be satisfied. If no idle state is provided, and when a clock is inserted, it is necessary to provide processing such as newly adding control to be taken when each function fails to operate. This complicates the timing design in the functional-RTLC conversion step S<highlight><bold>4</bold></highlight>. </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> Therefore, by clarifying the idle state during the preparation of the clock-free functional C description, it is possible to prevent an event that the function may fail to operate correctly when a clock is inserted. The existence of the idle state will not influence the operation at the stage of the functional C description. Thus, by providing the idle state or the initiating state, the functional C description can be easily converted into the RT level C description only with insertion of a clock. </paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> Once the functional C description <highlight><bold>2</bold></highlight> is generated in the algorithm-functional C conversion step S<highlight><bold>2</bold></highlight>, the process proceeds to the function verification step S<highlight><bold>3</bold></highlight>. The hardware functions are verified using the functional C simulator <highlight><bold>32</bold></highlight> obtained by compiling by the C compiler <highlight><bold>31</bold></highlight>. Herein, whether or not the computation function has been realized according to the control optimal for the hardware is verified. If there is a malfunction or change of specifications, the state separation in the algorithm-functional C conversion step S<highlight><bold>2</bold></highlight> is corrected. </paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> Since the functional C description <highlight><bold>2</bold></highlight> does not reflect a clock as the conception of time, the function verification is performed considering only the data path and the control, excluding the clock, among the three main components of hardware. The &ldquo;data path&rdquo; of hardware as used herein corresponds to computation processing, and the &ldquo;control&rdquo; corresponds to the state machine written in the form of a &ldquo;switch&rdquo; sentence. Due to the exclusion of the clock as the conception of time, the verification is prevented from becoming complicate. </paragraph>
<paragraph id="P-0068" lvl="0"><number>&lsqb;0068&rsqb;</number> Once it is determined that the hardware functions have been finalized in the function verification step S<highlight><bold>3</bold></highlight>, the process proceeds to the functional-RTLC conversion step <highlight><bold>4</bold></highlight>. In this step, a clock description as the conception of time is inserted into the functional C description <highlight><bold>2</bold></highlight> by the clock insertion means <highlight><bold>41</bold></highlight> of the functional-RTLC conversion system <highlight><bold>40</bold></highlight>, to generate the RT level C description <highlight><bold>3</bold></highlight>. This insertion of a clock description is executed according to a conversion program. </paragraph>
<paragraph id="P-0069" lvl="0"><number>&lsqb;0069&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is an example of the RT level C description <highlight><bold>3</bold></highlight> obtained in an application to CoWareC for hardware/software co-design tool N2C. In <cross-reference target="DRAWINGS">FIG. 5, a</cross-reference> &ldquo;thread rise(clk)&rdquo; sentence is inserted so that the entire state machine operates with a clock. Other processing is also performed, including that the states are further split in detail with reference to the execution time estimated in the functional C description <highlight><bold>2</bold></highlight>. For example, in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>B, comment &ldquo;//2Cycle&rdquo; meaning that &ldquo;2 cycles are required&rdquo; is inserted in the EXEC state. In response to this comment, the EXEC state is split into EXEC and EXEC1, for example. In this processing, an &ldquo;if&rdquo; sentence may be used in place of the &ldquo;switch&rdquo; sentence. Also, the port is converted into a plurality of signals such as data and enable according to a port protocol. These conversions can be automated with a program. </paragraph>
<paragraph id="P-0070" lvl="0"><number>&lsqb;0070&rsqb;</number> Once the RT level C description <highlight><bold>3</bold></highlight> is prepared in the functional-RTLC conversion step S<highlight><bold>4</bold></highlight>, the hardware operation timing is verified with clock cycle precision in the operation verification step S<highlight><bold>5</bold></highlight>. Because the data path and the control have already been verified in the function verification step S<highlight><bold>3</bold></highlight> described above, only the timing operation is verified in this step. </paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> Once the timing operation is confirmed in the operation verification step S<highlight><bold>5</bold></highlight>, the RT level C description <highlight><bold>3</bold></highlight> is converted into the Verilog-HDL <highlight><bold>5</bold></highlight> with the conversion tool <highlight><bold>60</bold></highlight> in the RTLC-HDL conversion step S<highlight><bold>6</bold></highlight>. </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> Thus, in this embodiment, the functional C description <highlight><bold>2</bold></highlight> can be prepared by the description conversion at the same level as the algorithm C description <highlight><bold>1</bold></highlight>. Therefore, hardware of a logic circuit can be easily designed based on the description written in an existing pure C language such as ANSI-C and C&plus;&plus;. </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> In addition, the functional C description <highlight><bold>2</bold></highlight> has states separated according to the units of processing independent of a clock cycle. Therefore, one state can be expressed as being executed in a plurality of cycles. This means that the hardware architecture and the hardware control method can be examined at a higher level of abstraction than that conventionally adopted. </paragraph>
<paragraph id="P-0074" lvl="0"><number>&lsqb;0074&rsqb;</number> The functional C description <highlight><bold>2</bold></highlight> is obtained by splitting into the initializing state, the computation state and the result output state as basic states. Therefore, the conversion style can be unified. In addition, the initializing state and the result output state can be expressed as the states performing data input/output from/to the outside of a state machine or a module. Therefore, the timing of a clock cycle during data transfer between functions can be easily adjusted when the clock description is inserted in the functional-RTLC conversion step S<highlight><bold>4</bold></highlight>. </paragraph>
<paragraph id="P-0075" lvl="0"><number>&lsqb;0075&rsqb;</number> Only the data path and control of hardware are verified in the function verification step S<highlight><bold>3</bold></highlight> for early finalization of the functions, excluding the clock timing. Therefore, the data path and the control as hardware components are finalized at an early stage of design. In addition, being free from the conception of time, high-speed function verification is possible, and correction is easy during verification and design change. This greatly shortens the time required for the design. </paragraph>
<paragraph id="P-0076" lvl="0"><number>&lsqb;0076&rsqb;</number> The execution cycle of the states can be estimated in detail by inserting a clock counting function for each state. It is therefore possible to estimate processing performance with high precision. In other words, the functional C description <highlight><bold>2</bold></highlight> can be used in place of a functional model (simulation model) written in a C language, which is normally prepared in parallel with the hardware, and thus redundant development is avoided. </paragraph>
<paragraph id="P-0077" lvl="0"><number>&lsqb;0077&rsqb;</number> The clock cycle timing verification is performed at the final stage. Therefore, the verification can be performed taking notice of a problem related to the cycle timing. This facilitates the verification, and thus improves the verification efficiency and also the debugging efficiency. As a result, the time required for the design can be shortened. </paragraph>
<paragraph id="P-0078" lvl="0"><number>&lsqb;0078&rsqb;</number> One state transition is completed by one &ldquo;do&rdquo; &ldquo;while&rdquo; sentence. Therefore, the state machine can be described in the same language such as ANSI-C or C&plus;&plus; without changing the algorithm operation. Thus, the computation processing in the state machine can be correctly executed even when state transition expression is inserted, without the necessity of using a special exclusive language. </paragraph>
<paragraph id="P-0079" lvl="0"><number>&lsqb;0079&rsqb;</number> There is no &ldquo;break&rdquo; of state transition every cycle. Therefore, it is unnecessary to allocate one state transition to one function. It is unnecessary, either, to call a function every cycle, and this enables high-speed simulation. This indicates that the &ldquo;control&rdquo; as a hardware component can be clearly embedded in the computation processing in a C language, and that the computation part and control part of hardware can be described in the function C description <highlight><bold>2</bold></highlight> without use of a special language. Thus, the hardware architecture can be examined at an early stage, and also function verification can be executed at high speed. </paragraph>
<paragraph id="P-0080" lvl="0"><number>&lsqb;0080&rsqb;</number> Hereinafter, expression of parallel operation in the algorithm-functional C conversion step S<highlight><bold>2</bold></highlight> will be described. </paragraph>
<paragraph id="P-0081" lvl="0"><number>&lsqb;0081&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 6A</cross-reference> to <highlight><bold>6</bold></highlight>D are examples of expression of parallel operation. Assume that execution of a plurality of processing items in parallel in one state is desired, for example. As one method, as an example of the functional C description <highlight><bold>2</bold></highlight> shown in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>A, parallel processing may be explicitly stated in the form of a comment (for example, &ldquo;//parallel&rdquo;) corresponding to each processing item (part enclosed by the dotted line). <cross-reference target="DRAWINGS">FIG. 6B</cross-reference> shows an example of a description obtained by converting the functional C description <highlight><bold>2</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 6A</cross-reference> into the RT level C. As shown in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>B, the functional C description <highlight><bold>2</bold></highlight> may be converted so that two processing items operate in the same state &ldquo;SO&equals;&equals;2&rdquo; as described in the functional C description <highlight><bold>2</bold></highlight>. </paragraph>
<paragraph id="P-0082" lvl="0"><number>&lsqb;0082&rsqb;</number> There may be a case that each unit of processing must have state transition. In such a case, as shown in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>C, each state machine is described to close itself using a &ldquo;do&rdquo; &ldquo;while&rdquo; sentence (part enclosed by the dotted line). <cross-reference target="DRAWINGS">FIG. 6D</cross-reference> shows an example of a description obtained by converting the functional C description <highlight><bold>2</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 6C</cross-reference> into the RT level C. As shown in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>D, the two state machines may be converted by inserting a conditional sentence so as to operate in the same state &ldquo;SO&equals;&equals;2&rdquo; as described in the functional C description <highlight><bold>2</bold></highlight>. </paragraph>
<paragraph id="P-0083" lvl="0"><number>&lsqb;0083&rsqb;</number> Thus, since the parallelability can be explicitly stated in the algorithm-functional C conversion step S<highlight><bold>2</bold></highlight>, parallel processing can be described in the functional C description <highlight><bold>2</bold></highlight> without the necessity of a special simulator, and also simulation can be done at high speed. In addition, since both the hardware control and the parallelability can be stated, conversion to parallel description is also facilitated during the conversion into the RT level C description. </paragraph>
<paragraph id="P-0084" lvl="0"><number>&lsqb;0084&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> illustrates an example of description by CoWare C. However, description is possible as well by System C, Spec C and other languages only if they can describe clock. </paragraph>
<paragraph id="P-0085" lvl="7"><number>&lsqb;0085&rsqb;</number> Embodiment 2 </paragraph>
<paragraph id="P-0086" lvl="0"><number>&lsqb;0086&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> illustrates a configuration of a logic circuit design system of Embodiment 2 of the present invention, which is a hardware top-down design system from C language description. In <cross-reference target="DRAWINGS">FIG. 7</cross-reference>, the same components as those in <cross-reference target="DRAWINGS">FIG. 1</cross-reference> are denoted by the same reference numerals. In <cross-reference target="DRAWINGS">FIG. 7</cross-reference>, an algorithm-functional C conversion system <highlight><bold>20</bold></highlight>A includes a module separation means <highlight><bold>22</bold></highlight>, which rewrites the algorithm C description <highlight><bold>1</bold></highlight> for each module taking notice of hardware functions, to perform module separation. A functional-RTLC conversion system <highlight><bold>40</bold></highlight>A includes a control/data path separation means <highlight><bold>42</bold></highlight>, which separates a state transition description representing &ldquo;control&rdquo; and a computation description representing &ldquo;data path&rdquo; from the function C description <highlight><bold>2</bold></highlight>. </paragraph>
<paragraph id="P-0087" lvl="0"><number>&lsqb;0087&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> is a flowchart of the logic circuit design method of this embodiment. In <cross-reference target="DRAWINGS">FIG. 8</cross-reference>, the same process steps as those in <cross-reference target="DRAWINGS">FIG. 2</cross-reference> are denoted by the same reference numerals. In <cross-reference target="DRAWINGS">FIG. 8</cross-reference>, step S<highlight><bold>7</bold></highlight> is a module separation determination step in which whether or not the algorithm C description <highlight><bold>1</bold></highlight> can be split into modules taking notice of hardware functions is determined. Step S<highlight><bold>8</bold></highlight> is a module separation step in which functions specific to hardware such as a memory and a hard macro of the algorithm C description <highlight><bold>1</bold></highlight> are separated as different modules. Step S<highlight><bold>9</bold></highlight> is a control/data path separation step in which a &ldquo;switch&rdquo; sentence description in a state machine representing the control and a computation processing description in a &ldquo;case&rdquo; sentence in the &ldquo;switch&rdquo; sentence are separated from the functional C description <highlight><bold>2</bold></highlight>. </paragraph>
<paragraph id="P-0088" lvl="0"><number>&lsqb;0088&rsqb;</number> Hereinafter, the logic circuit design method of this embodiment will be described with reference to FIGS. <highlight><bold>7</bold></highlight> to <highlight><bold>11</bold></highlight>. </paragraph>
<paragraph id="P-0089" lvl="0"><number>&lsqb;0089&rsqb;</number> First, in the algorithm verification step S<highlight><bold>1</bold></highlight>, as in Embodiment 1, the algorithm C description <highlight><bold>1</bold></highlight> is compiled by the C compiler <highlight><bold>11</bold></highlight> in the algorithm verification system <highlight><bold>10</bold></highlight>, to generate the algorithm C simulator <highlight><bold>12</bold></highlight> for verification of the algorithm. Computation processing (data path) only is then verified using the algorithm C simulator <highlight><bold>12</bold></highlight>. Together with this verification, whether or not the algorithm has been finalized is determined. Correction of the algorithm C description <highlight><bold>1</bold></highlight> and verification of the description are repeated until the algorithm has been finalized. </paragraph>
<paragraph id="P-0090" lvl="0"><number>&lsqb;0090&rsqb;</number> After the finalization of the algorithm in the algorithm verification step S<highlight><bold>1</bold></highlight>, whether or not the algorithm C description <highlight><bold>1</bold></highlight> can be split into modules by the module separation means <highlight><bold>22</bold></highlight> taking notice of its hardware functions is determined in the module separation determination step S<highlight><bold>7</bold></highlight>. When the algorithm C description <highlight><bold>1</bold></highlight> has a description part like an array corresponding to a memory, or a description part of multiplication in the case that use of a multiplier hard macro is assumed, such a description part is separated as an individual module. This processing can be realized by identifying the array or the hard macro using a conversion program or the like. Alternatively, the description splitting is possible by displaying codes with GUI or the like and performing cut and paste of the codes in computation units of processing. </paragraph>
<paragraph id="P-0091" lvl="0"><number>&lsqb;0091&rsqb;</number> In this embodiment, a method of module separation with GUI will be described with reference to <cross-reference target="DRAWINGS">FIG. 9</cross-reference>. Referring to <cross-reference target="DRAWINGS">FIG. 9</cross-reference>, an algorithm C description <highlight><bold>81</bold></highlight> before conversion is displayed on a GUI screen <highlight><bold>80</bold></highlight> by opening a related file. The user selects a sentence assigned to an array corresponding to a memory, a multiplication part, or a plurality of parameter setting register parts, as a separating module part <highlight><bold>82</bold></highlight> on the screen, and specifies the module name in &ldquo;Module name&rdquo; <highlight><bold>83</bold></highlight>. By specifying like this, a split C description after conversion is prepared by program conversion by the module separation means <highlight><bold>22</bold></highlight>, and individual separated modules are displayed on a split C description display field <highlight><bold>84</bold></highlight>. </paragraph>
<paragraph id="P-0092" lvl="0"><number>&lsqb;0092&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 10A and 10B</cross-reference> illustrate an example of module separation, in which <cross-reference target="DRAWINGS">FIG. 10A</cross-reference> illustrates the original algorithm C description and <cross-reference target="DRAWINGS">FIG. 10B</cross-reference> illustrates the module-split algorithm C description. In <cross-reference target="DRAWINGS">FIG. 10</cross-reference>A, part A for entry of data in an array corresponds to a memory part of hardware, and parts B<highlight><bold>1</bold></highlight> and B<highlight><bold>2</bold></highlight> for assignment of data to parameters correspond to register parts. Part C for calling a function corresponds to a computation execution part. The parts A, B<highlight><bold>1</bold></highlight>, B<highlight><bold>2</bold></highlight> and C are separated as modules as shown in <cross-reference target="DRAWINGS">FIG. 10B</cross-reference>. Once no description part specific to a hardware function exists in the separated modules, the process proceeds to the algorithm-functional C conversion step S<highlight><bold>2</bold></highlight>. </paragraph>
<paragraph id="P-0093" lvl="0"><number>&lsqb;0093&rsqb;</number> In the algorithm-functional C conversion step S<highlight><bold>2</bold></highlight>, in principle, a module having a hardware-specific function is not converted into the functional C description. When control of a signal line is included, for example, only part related to a logic circuit is concretized during conversion into the RT level C description. For the other part, state separation and clarification of state transition are performed for each module for conversion to the functional C description <highlight><bold>2</bold></highlight>, as described in Embodiment 1. Herein, the module corresponding to the computation execution part is split into states for conversion to the functional C description <highlight><bold>2</bold></highlight>. </paragraph>
<paragraph id="P-0094" lvl="0"><number>&lsqb;0094&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 11A and 11B</cross-reference> illustrate an example of conversion into the functional C description <highlight><bold>2</bold></highlight>, in which <cross-reference target="DRAWINGS">FIG. 11A</cross-reference> illustrates the algorithm C description and <cross-reference target="DRAWINGS">FIG. 11B</cross-reference> illustrates the functional C description. Part A represents the initializing state, part B represents the computation execution state, and part C represents the result output state. The computation execution state B may further be split into two states, and <cross-reference target="DRAWINGS">FIG. 11B</cross-reference> shows an example of further split description. To state specifically, in <cross-reference target="DRAWINGS">FIG. 11</cross-reference>B, the state B is further split into a state of data input from a memory or the like and a computation state. In this case, the state transition is in the order of initializing (idle) state A&rarr;data input state B<highlight><bold>1</bold></highlight>&rarr;computation execution state B<highlight><bold>2</bold></highlight>&rarr;result output state C&rarr;initializing (idle) state. </paragraph>
<paragraph id="P-0095" lvl="0"><number>&lsqb;0095&rsqb;</number> In the next function verification step S<highlight><bold>3</bold></highlight>, the control and data path of hardware are verified as in Embodiment 1, to finalize the hardware functions. </paragraph>
<paragraph id="P-0096" lvl="0"><number>&lsqb;0096&rsqb;</number> In the control/data path separation step S<highlight><bold>9</bold></highlight>, a &ldquo;switch&rdquo; sentence of a state transition description corresponding to &ldquo;control&rdquo; and a computation processing description corresponding to &ldquo;data path&rdquo; in a &ldquo;case&rdquo; sentence in a &ldquo;switch&rdquo; sentence are separated from the functional C description <highlight><bold>2</bold></highlight> by the control/data path separation means <highlight><bold>42</bold></highlight> of the functional-RTLC conversion system <highlight><bold>40</bold></highlight>A. During this separation, a &ldquo;for&rdquo; sentence and the like are expanded to a counter description. Thereafter, in the functional-RTLC conversion step S<highlight><bold>4</bold></highlight>, a clock description is inserted, to generate the RT level C description <highlight><bold>3</bold></highlight>. </paragraph>
<paragraph id="P-0097" lvl="0"><number>&lsqb;0097&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 12A and 12B</cross-reference> illustrate an example of conversion to the RT level C description according to CoWareC for hardware/software co-design tool N2C, in which <cross-reference target="DRAWINGS">FIG. 12A</cross-reference> illustrates the original algorithm C description and <cross-reference target="DRAWINGS">FIG. 12B</cross-reference> illustrates the RT level C description. The control part is extracted from the algorithm C description shown in <cross-reference target="DRAWINGS">FIG. 12</cross-reference>A, to form a state machine, and a clock description is inserted in the state machine. Also, computation processing in each state in <cross-reference target="DRAWINGS">FIG. 12A</cross-reference> is extracted individually taking notice of a same parameter. A control signal is added to the extracted computation processing so that only the state to which the computation processing has belonged is activated, and a clock description is inserted in each processing. The &ldquo;for&rdquo; sentence is separately expanded as a counter description. In this way, the RT level C description as shown in <cross-reference target="DRAWINGS">FIG. 12B</cross-reference> is prepared. The description in <cross-reference target="DRAWINGS">FIG. 12B</cross-reference> has roughly the same configuration as a RT level description in HDL. This means that this description is highly readable for hardware designers. </paragraph>
<paragraph id="P-0098" lvl="0"><number>&lsqb;0098&rsqb;</number> Subsequently, in the operation verification step S<highlight><bold>5</bold></highlight>, the timing verification system <highlight><bold>50</bold></highlight> executes timing verification using the RT level C description <highlight><bold>3</bold></highlight> generated in the functional-RTLC conversion step S<highlight><bold>4</bold></highlight>. When no problem is found in the timing operation, the RT level C description <highlight><bold>3</bold></highlight> is converted into the Verilog-HDL <highlight><bold>5</bold></highlight> in the RTLC-HDL conversion step S<highlight><bold>6</bold></highlight>. </paragraph>
<paragraph id="P-0099" lvl="0"><number>&lsqb;0099&rsqb;</number> Thus, in this embodiment, the algorithm C description <highlight><bold>1</bold></highlight> is split into a plurality of modules taking notice of hardware functions. This enables examination of the hardware architecture at a stage of a high level of abstraction, and thus enables intentional separation of hardware-specific functions. Therefore, computation processing function, the storage function and the like can be easily separated. This facilitates the splitting design in the next algorithm-functional C conversion step S<highlight><bold>2</bold></highlight>. In addition, since a description part of the algorithm C description <highlight><bold>1</bold></highlight> that may be verified as it is can be separated from the other, the RT level design is also facilitated. </paragraph>
<paragraph id="P-0100" lvl="0"><number>&lsqb;0100&rsqb;</number> The algorithm C description is split into the data input state, the computation state and the result output state as basic states. Therefore, the conversion style into the functional C description <highlight><bold>2</bold></highlight> can be unified. In addition, the data input state and the result output state can be expressed as the states performing data input/output from/to the outside of a state machine or a module. Therefore, the timing of a clock cycle during data transfer between functions can be easily adjusted when a clock description is inserted in the functional-RTLC conversion step S<highlight><bold>4</bold></highlight>. </paragraph>
<paragraph id="P-0101" lvl="0"><number>&lsqb;0101&rsqb;</number> In the latter half of the design, a state transition description representing the &ldquo;control&rdquo; is extracted from the functional C description <highlight><bold>2</bold></highlight>, and also, a computation processing description representing the &ldquo;data path&rdquo; described in each state is extracted and separated individually for each variable, to prepare the RT level C description. Therefore, as in a RT level description in HDL, the code readability improves, and debugging in malfunction analysis during verification improves. </paragraph>
<paragraph id="P-0102" lvl="0"><number>&lsqb;0102&rsqb;</number> With the splitting into the memory part and the computation processing part, replacement thereof with a memory library is facilitated during generation of RTL codes in HDL. This enables design considering the hardware architecture at an early stage. Therefore, the circuit scale can be prevented from becoming large. This not only enables design considering a memory as in the design in HDL, but also facilitates change of a memory to be used and the like. Moreover, since only the computation processing part can be converted into the functional C description or the RT level C description for design and simulation, the designability and the simulation speed improve. </paragraph>
<paragraph id="P-0103" lvl="0"><number>&lsqb;0103&rsqb;</number> The parameter setting register part for computation processing is separated as an individual module. Therefore, partial change, such as change of the number of registers, is possible without changing a code in the computation processing part and the like. Also, since there is no need to search for a desired variable name in a large code, debugging is facilitated in malfunction analysis during function verification. In addition, when implemented as hardware, the register part can be easily replaced with a memory. </paragraph>
<paragraph id="P-0104" lvl="0"><number>&lsqb;0104&rsqb;</number> In the above description, separation of a memory part was exemplified. In the case that an operator such as a multiplier is defined as a soft macro or a hard macro of the hardware, the computation processing part thereof may be separated as an individual module. </paragraph>
<paragraph id="P-0105" lvl="7"><number>&lsqb;0105&rsqb;</number> Embodiment 3 </paragraph>
<paragraph id="P-0106" lvl="0"><number>&lsqb;0106&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 13</cross-reference> illustrates a configuration of a logic circuit design system of Embodiment 3 of the present invention, which is a hardware top-down design system from C language description. In <cross-reference target="DRAWINGS">FIG. 13</cross-reference>, the same components as those in <cross-reference target="DRAWINGS">FIG. 7</cross-reference> are denoted by the same reference numerals. In <cross-reference target="DRAWINGS">FIG. 13, a</cross-reference> functional-SystemC conversion system <highlight><bold>40</bold></highlight>B, a SystemC verification system <highlight><bold>50</bold></highlight>A and a SystemC synthesis tool <highlight><bold>70</bold></highlight> are provided in place of the functional-RTLC conversion system <highlight><bold>40</bold></highlight>A, the timing verification system <highlight><bold>50</bold></highlight> and the conversion tool <highlight><bold>60</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 7</cross-reference>. The functional-SystemC conversion system <highlight><bold>40</bold></highlight>B includes the control/data path separation means <highlight><bold>42</bold></highlight> and a sensitive description insertion means <highlight><bold>43</bold></highlight> for sensitive designation, and converts the functional C description <highlight><bold>2</bold></highlight> into a SystemC description <highlight><bold>6</bold></highlight>. The SystemC verification system <highlight><bold>50</bold></highlight>A compiles the SystemC description <highlight><bold>6</bold></highlight> with a C compiler <highlight><bold>53</bold></highlight> using a SystemC library <highlight><bold>7</bold></highlight>, to generate a SystemC simulator <highlight><bold>54</bold></highlight>. The SystemC synthesis tool <highlight><bold>70</bold></highlight>, which is made of a SystemC compiler from Synopsy, for example, converts the SystemC description <highlight><bold>6</bold></highlight> into the verilog-HDL <highlight><bold>5</bold></highlight>. </paragraph>
<paragraph id="P-0107" lvl="0"><number>&lsqb;0107&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 14</cross-reference> is a flowchart of the logic circuit design method of this embodiment. In <cross-reference target="DRAWINGS">FIG. 14</cross-reference>, the same steps as those in <cross-reference target="DRAWINGS">FIG. 8</cross-reference> are denoted by the same reference numerals. In <cross-reference target="DRAWINGS">FIG. 14</cross-reference>, step S<highlight><bold>10</bold></highlight> is a functional-SystemC conversion step in which a sensitive description is inserted in the functional C description <highlight><bold>2</bold></highlight> in the functional-SystemC conversion system <highlight><bold>40</bold></highlight>B, to convert the functional C description <highlight><bold>2</bold></highlight> into the SystemC description <highlight><bold>6</bold></highlight>. Step S<highlight><bold>11</bold></highlight> is a SystemC verification step in which clock cycle simulation is performed using the SystemC simulator <highlight><bold>54</bold></highlight>. Step S<highlight><bold>12</bold></highlight> is a SystemC-HDL conversion step in which the SystemC description <highlight><bold>6</bold></highlight> is synthesized into the Verilog-HDL <highlight><bold>5</bold></highlight> with an existing synthesis tool. The conversion in the functional-SystemC conversion step S<highlight><bold>10</bold></highlight> corresponds to the functional-RTLC conversion step according to the present invention. </paragraph>
<paragraph id="P-0108" lvl="0"><number>&lsqb;0108&rsqb;</number> Hereinafter, the logic circuit design method of this embodiment will be described with reference to FIGS. <highlight><bold>13</bold></highlight> to <highlight><bold>15</bold></highlight>. </paragraph>
<paragraph id="P-0109" lvl="0"><number>&lsqb;0109&rsqb;</number> As in Embodiment 2, the functional C description <highlight><bold>2</bold></highlight> is generated in the algorithm-functional C conversion step S<highlight><bold>2</bold></highlight>, and the hardware functions are finalized in the function verification step S<highlight><bold>3</bold></highlight>. In the control/data path separation step S<highlight><bold>9</bold></highlight>, a control description describing state transition corresponding to the &ldquo;control&rdquo; of hardware and a data path description describing computation processing in each state corresponding to the &ldquo;data path&rdquo; are separated from the functional C description <highlight><bold>2</bold></highlight> by the control/data path separation means <highlight><bold>42</bold></highlight> of the functional-SystemC conversion system <highlight><bold>40</bold></highlight>B. The data path description is provided individually for each parameter. </paragraph>
<paragraph id="P-0110" lvl="0"><number>&lsqb;0110&rsqb;</number> Subsequently, in the function-SystemC conversion step S<highlight><bold>10</bold></highlight>, a sensitive description is added to the control description and the data path description separated in the step S<highlight><bold>9</bold></highlight>. Along with this addition, conversion into SystemC grammar is performed using a conversion program, for example. </paragraph>
<paragraph id="P-0111" lvl="0"><number>&lsqb;0111&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 15A and 15B</cross-reference> illustrate an example of conversion into the SystemC description <highlight><bold>6</bold></highlight>, in which <cross-reference target="DRAWINGS">FIG. 15A</cross-reference> illustrates the original functional C description and <cross-reference target="DRAWINGS">FIG. 15B</cross-reference> illustrates a description converted into SystemC. The sensitive description denoted by <highlight><bold>91</bold></highlight> added to the end specifies whether the description is a part operating in clock synchronization or a part to be a combined circuit with a sensitive list. </paragraph>
<paragraph id="P-0112" lvl="0"><number>&lsqb;0112&rsqb;</number> After the conversion into the SystemC description <highlight><bold>6</bold></highlight> in the step S<highlight><bold>10</bold></highlight>, clock cycle base verification is performed using the SystemC simulator <highlight><bold>54</bold></highlight> of the SystemC verification system <highlight><bold>50</bold></highlight>A in the SystemC verification step S<highlight><bold>11</bold></highlight>. When correct operation is confirmed in the clock cycle base verification, the SystemC description <highlight><bold>6</bold></highlight> is converted into the RTL HDL description <highlight><bold>5</bold></highlight> with the existing SystemC synthesis tool <highlight><bold>70</bold></highlight> such as a SystemC compiler in the SystemC-HIDL conversion step S<highlight><bold>12</bold></highlight>. </paragraph>
<paragraph id="P-0113" lvl="0"><number>&lsqb;0113&rsqb;</number> As described above, in this embodiment, by the conversion from the functional C description into SystemC, for example, smooth conversion into a desired design language is possible. In this way, the design language can be determined after the verification of the hardware functions independent of the design language. Thus, since design can be started without the necessity of determining the design language, the simulation tool, the operation synthesis tool and the like at the start of development, the development efficiency greatly improves, and the time required for the development can be shortened. Also, optimal tools can be selected at the stage of completion of the functional C description. </paragraph>
<paragraph id="P-0114" lvl="0"><number>&lsqb;0114&rsqb;</number> In the above description, SystemC was exemplified. It is naturally possible to convert the functional C description into SpecC in a similar procedure by adopting SpecC grammar. In this case, also, a similar effect is provided. </paragraph>
<paragraph id="P-0115" lvl="0"><number>&lsqb;0115&rsqb;</number> In the above embodiments, the conversion into CoWareC, SystemC, SpecC or the like was performed at the RTLC stage. The step-by-step design method according to the present invention is also applicable to the following case. That is, a description in a module or block is written in a pure C language, but the module is connected to a module designed using any of the above system level description languages from the algorithm stage, and the connection is described according to the grammar of this system level description language. In such a case, also, the effect of improving the design efficiency is sufficiently obtained as in the above embodiments because the three main hardware components, that is, the data path, the control and the clock, are irrespective of the language. </paragraph>
<paragraph id="P-0116" lvl="0"><number>&lsqb;0116&rsqb;</number> The logic circuit design method of each embodiment of the present invention can be implemented by means of a computer executing a program for implementing the method. The method can also be implemented by recording a program for implementing the method on a computer-readable recording medium and allowing a computer to execute the program recorded on the recording medium. In particular, naturally, the functions of the algorithm-functional C conversion system <highlight><bold>20</bold></highlight> or <highlight><bold>20</bold></highlight>A, the functional-RTLC conversion system <highlight><bold>40</bold></highlight> or <highlight><bold>40</bold></highlight>A, and the functional-SystemC conversion system <highlight><bold>40</bold></highlight>B can be implemented by means of a program. </paragraph>
<paragraph id="P-0117" lvl="0"><number>&lsqb;0117&rsqb;</number> As described above, according to the present invention, hardware of a logic circuit can be easily designed based on an algorithm C description written in an existing pure C language. The functional C description can be expressed to enable execution of one state in a plurality of cycles, and thus is suitable as a description style for examining the hardware architecture at a higher level of abstraction. Therefore, according to the present invention, the hardware architecture can be examined at a higher level of abstraction than that conventionally adopted. </paragraph>
<paragraph id="P-0118" lvl="0"><number>&lsqb;0118&rsqb;</number> The present invention can be easily implemented as a design automation (DA) tool. This can further reduce the time required for design. </paragraph>
<paragraph id="P-0119" lvl="0"><number>&lsqb;0119&rsqb;</number> While the present invention has been described in a preferred embodiment, it will be apparent to those skilled in the art that the disclosed invention may be modified in numerous ways and may assume many embodiments other than that specifically set out and described above. Accordingly, it is intended by the appended claims to cover all modifications of the invention which fall within the true spirit and scope of the invention. </paragraph>
<paragraph id="P-0120" lvl="0"><number>&lsqb;0120&rsqb;</number> The above embodiment exemplifies CoWare C and System C. Wherein, it is needless to say that languages capable of describing conception of time (clock) can be applied to the present invention, as well. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method of designing a logic circuit, comprising the steps of 
<claim-text>converting an algorithm C description describing an algorithm of computation or control of the logic circuit in a C language into a functional C description describing control of hardware by rewriting the algorithm C description according to states in units of processing and describing the processing execution order as state transition (algorithm-functional C conversion step); </claim-text>
<claim-text>converting the functional C description generated in the algorithm-functional C conversion step into a register transfer (RT) level C description by inserting a clock description as the conception of time into the functional C description (functional-RTLC conversion step); and </claim-text>
<claim-text>converting the RT level C description generated in the functional-RTLC conversion step into a RT level description in HDL (RTLC-HDL conversion step). </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the algorithm-functional C conversion step comprises the step of splitting the algorithm C description into a plurality of states including at least one idle state or initializing state. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the algorithm-functional C conversion step comprises the step of splitting the algorithm C description into at least a data input state corresponding to data input processing, a computation state corresponding to computation processing, and a result output state corresponding to data output processing. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising the step of 
<claim-text>verifying functions of hardware including only the data path and the control and excluding the clock using the functional C description (function verification step), </claim-text>
<claim-text>wherein the functional-RTLC conversion step is processed when the hardware functions are confirmed correct in the function verification step. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising the step of 
<claim-text>verifying clock cycle timing operation of hardware using the RT level C description (operation verification step), </claim-text>
<claim-text>wherein the RTLC-HDL conversion step is processed when the clock cycle timing operation is confirmed correct in the operation verification step. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein in the algorithm-functional C conversion step, the state transition is described in a &ldquo;switch&rdquo; sentence, each of the units of processing is described by multi-branch expression, the execution order is expressed by clarifying a transition destination in a &ldquo;case&rdquo;, and one state machine is described so as to close itself by use of a loop expression. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference>, wherein in the algorithm-functional C conversion step, when a plurality of processing items are executed in parallel in one state, each of a plurality of state machines is described so as to close itself by use of a loop expression. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising the step of: 
<claim-text>rewriting the algorithm C description according to modules taking notice of hardware functions to generate an algorithm C description for each module, as preprocessing to the algorithm-functional C conversion step (module separation step). </claim-text>
</claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference>, wherein in the module separation step, the algorithm C description is split into at least a memory part and a computation processing part. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference>, wherein in the module separation step, an operator corresponding to a soft macro or hard macro of hardware is separated from the algorithm C description as an individual module. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference>, wherein in the module separation step, a parameter setting register part for computation processing is separated from the algorithm C description as an individual module. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein in the functional-RTLC conversion step, a state transition description representing the control and a computation processing description representing the data path are extracted from the functional C description, and 
<claim-text>a clock description as the conception of time is inserted in each of the extracted state transition description and computation processing description. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein in the functional-RTLC conversion step, the RT level C description is generated by adopting grammar of SystemC or SpecC. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. A computer-readable recording medium including a recorded program, the program enabling a computer to execute the steps of: 
<claim-text>converting an algorithm C description describing an algorithm of computation or control of a logic circuit in a C language into a functional C description describing control of hardware by rewriting the algorithm C description according to states in units of processing and describing the processing execution order as state transition (algorithm-functional C conversion step); and </claim-text>
<claim-text>converting the functional C description generated in the algorithm-functional C conversion step into a register transfer (RT) level C description by inserting a clock description as the conception of time into the functional C description (functional-RTLC conversion step). </claim-text>
</claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. A program prepared to enable a computer to execute the steps of: 
<claim-text>converting an algorithm C description describing an algorithm of computation or control of a logic circuit in a C language into a functional C description describing control of hardware by rewriting the algorithm C description according to states in units of processing and describing the processing execution order as state transition (algorithm-functional C conversion step); and </claim-text>
<claim-text>converting the functional C description generated in the algorithm-functional C conversion step into a register transfer (RT) level C description by inserting a clock description as the conception of time into the functional C description (functional-RTLC conversion step).</claim-text>
</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>2</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005392A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005392A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005392A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005392A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005392A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005392A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030005392A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030005392A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030005392A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00009">
<image id="EMI-D00009" file="US20030005392A1-20030102-D00009.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00010">
<image id="EMI-D00010" file="US20030005392A1-20030102-D00010.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00011">
<image id="EMI-D00011" file="US20030005392A1-20030102-D00011.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00012">
<image id="EMI-D00012" file="US20030005392A1-20030102-D00012.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00013">
<image id="EMI-D00013" file="US20030005392A1-20030102-D00013.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00014">
<image id="EMI-D00014" file="US20030005392A1-20030102-D00014.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00015">
<image id="EMI-D00015" file="US20030005392A1-20030102-D00015.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00016">
<image id="EMI-D00016" file="US20030005392A1-20030102-D00016.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
