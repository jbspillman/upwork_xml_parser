<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005267A1-20030102-M00001.NB SYSTEM "US20030005267A1-20030102-M00001.NB" NDATA NB>
<!ENTITY US20030005267A1-20030102-M00001.TIF SYSTEM "US20030005267A1-20030102-M00001.TIF" NDATA TIF>
<!ENTITY US20030005267A1-20030102-D00000.TIF SYSTEM "US20030005267A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005267A1-20030102-D00001.TIF SYSTEM "US20030005267A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005267A1-20030102-D00002.TIF SYSTEM "US20030005267A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005267A1-20030102-D00003.TIF SYSTEM "US20030005267A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005267A1-20030102-D00004.TIF SYSTEM "US20030005267A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005267A1-20030102-D00005.TIF SYSTEM "US20030005267A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030005267A1-20030102-D00006.TIF SYSTEM "US20030005267A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030005267A1-20030102-D00007.TIF SYSTEM "US20030005267A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030005267A1-20030102-D00008.TIF SYSTEM "US20030005267A1-20030102-D00008.TIF" NDATA TIF>
<!ENTITY US20030005267A1-20030102-D00009.TIF SYSTEM "US20030005267A1-20030102-D00009.TIF" NDATA TIF>
<!ENTITY US20030005267A1-20030102-D00010.TIF SYSTEM "US20030005267A1-20030102-D00010.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005267</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10175218</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20020619</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F009/00</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>712</class>
<subclass>221000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>System and method for parallel computing multiple packed-sum absolute differences (PSAD) in response to a single instruction</title-of-invention>
</technical-information>
<continuity-data>
<non-provisional-of-provisional>
<document-id>
<doc-number>60299881</doc-number>
<document-date>20010621</document-date>
<country-code>US</country-code>
</document-id>
</non-provisional-of-provisional>
</continuity-data>
<inventors>
<first-named-inventor>
<name>
<given-name>Igor</given-name>
<middle-name>M.</middle-name>
<family-name>Koba</family-name>
</name>
<residence>
<residence-us>
<city>Savannah</city>
<state>GA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Mikhail</given-name>
<family-name>Chernomordik</family-name>
</name>
<residence>
<residence-us>
<city>Savannah</city>
<state>GA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>THOMAS, KAYDEN, HORSTEMEYER &amp; RISLEY, LLP</name-1>
<name-2></name-2>
<address>
<address-1>100 GALLERIA PARKWAY, NW</address-1>
<address-2>STE 1750</address-2>
<city>ATLANTA</city>
<state>GA</state>
<postalcode>30339-5948</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A system and method are presented in which multiple packed-sum absolute differences (PSAD) are computed in response to a single instruction. One embodiment of the system comprises a first register configured to store a first operand having data elements, and a second register configured to store a second operand having data elements. Additionally, the system comprises a processor configured to perform multiple PSAD calculations between the data elements of the second operand and a first subset of data elements of the first operand. The multiple PSAD calculations are performed in response to a single instruction set. One embodiment of the method comprises the steps of receiving a single instruction, and performing multiple PSAD calculations in response to the single instruction. </paragraph>
</subdoc-abstract>
<subdoc-description>
<cross-reference-to-related-applications>
<heading lvl="1">CROSS REFERENCE TO RELATED APPLICATIONS </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> This application claims the benefit of U.S. provisional patent application serial No. 60/299,881, filed Jun. 21, 2001, which is incorporated herein by reference in its entirety.</paragraph>
</cross-reference-to-related-applications>
<summary-of-invention>
<section>
<heading lvl="1">FIELD OF INVENTION </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> The present invention relates generally to the field of microprocessors and instructions, and, more particularly, to a system and method for parallel computing multiple packed-sum absolute differences (PSAD) in response to a single instruction. </paragraph>
</section>
<section>
<heading lvl="1">BACKGROUND </heading>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> Computing a sum of absolute differences of pixels is used in many applications including motion video encoding algorithms and methods such as MPEG video encoding. This computation often comprises the more difficult computational part of video encoding algorithms. Sum of absolute differences of pixels is used to compare a measure of similarity of pixel blocks on a pair of pictures that is a part of motion estimation which, in turn, is a part of many video encoding algorithms. Computing the sum of absolute differences of pixels for video encoding, therefore, involves enormous amounts of calculations. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> One existing method to increase the microprocessor throughput for computing the sum of absolute differences of pixels involves providing a special microprocessor instruction for computing packed-sum absolute differences (PSAD). Many modem microprocessors, such as the Intel Pentium&trade; III and Pentium&trade; 4, Sun Microsystems UltraSparc&trade;, Compaq Alpha&trade;, and others, while possibly using different instruction mnemonic names, provide such microprocessor instructions to compute the PSAD value. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> The PSAD value is the sum of differences of absolute values for a plurality of neighborhood pixels (typically for 8 neighborhood pixels). Thus, the PSAD value is used to compute mean absolute difference of pixels (MAD), which is used as a criterion for picture similarity in motion-estimation algorithms. For example, computing one MAD value for a 16 pixel by 16 pixel block size requires a microprocessor to execute 32 PSAD instructions and add the results of all the executed PSAD instructions. Given the enormous amounts of calculations typically involved in, for example, motion estimation, the task of high quality real-time video encoding occupies much of the computational capabilities of modern microprocessors. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> There are many algorithms proposed to reduce computational complexity of motion estimation. But these fast motion-estimation algorithms often result in reduced picture quality for given bit-rates and given conditions, since motion estimation is both execution intensive and memory-loading intensive. The picture data (i.e., pixel data) for computing PSAD criteria are loaded from a large array containing a reference image and a compared (or object) image with the pixels of a new pixel block. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> Specialized semiconductor chips for motion estimation and video encoding utilize highly optimized architectures with pipelined systolic arrays of execution elements to perform motion estimation. But that solution appears to be too costly for general-purpose microprocessors. The developers of modem microprocessors, therefore, seek performance improvement for multimedia applications utilizing parallel multimedia data types and instructions. These instructions operate on multiple small-data elements, at any given time, in one instruction. Such instructions, in the case of Intel&trade; microprocessors, are called MMX or SIMD instructions. While the MMX and SIMD instructions give sufficient improvement in performance for certain multimedia applications, they still typically do not provide enough performance improvement for complex motion estimation tasks. The Intel&trade; microprocessors for example compute PSAD values in response to a PSADBW instruction, which operates on 64-bit operands or 128-bit operands. While PSADBW improves performance of certain motion estimation computation, further improvements are needed for high-quality real-time video encoding. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> PSADBW instructions compute the absolute value of the difference of eight unsigned byte integers from a source operand (first operand) and from a destination operand (second operand). These eight differences are then summed to produce an unsigned word-integer result that is stored in the destination operand. Thus, while the PSADBW instruction helps to reduce computation time, it is still limited since: (1) the instruction has long latency that delays execution of the next instruction; (2) there are small amounts of execution units in the processors to perform the instruction, which limits the amount of instructions that can be issued simultaneously, and, hence, issuing more than two independent PSADBW instructions does not give any speed improvement; (3) the instructions require multiple loads of data from memory to compute MAD values for pixel blocks, which makes it difficult to interleave loads, and leaves very little spare time for prefetch; and (4) motion estimation often requires MAD calculations for many pixel blocks at different addresses, thereby resulting in multiple instruction loads by pointers that are not aligned, thereby slowing the memory loading operations. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> The PSADBW instruction, and similar instructions of other microprocessors that compute PSAD values, improves the performance of motion estimation computations. However, as stated above, high-quality real-time video encoding may require greater efficiency than that provided by PSADBW and similar instructions. Increasing the number of execution units performing PSADBW instructions in a microprocessor may gain some improvements. However, the issuing of multiple PSADBW instructions would still be limited by the loading of operands from memory, usually from pointers that are not aligned, and, also, by data dependency of the results of the instruction that are added in one or two registers that accumulate the total result. Loading operands from memory becomes a limiting factor in performance of computing PASD values since the clock speed and amount of execution units in the microprocessor increases. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> Given these limitations, a heretofore-unaddressed need exists in the industry. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY </heading>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> The present invention provides a system and method for computing multiple packed-sum absolute differences (PSAD) in response to a single instruction. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> Briefly described, in architecture, one embodiment of the system comprises a first register configured to store a first operand having data elements, and a second register configured to store a second operand having data elements. Additionally, the system comprises a processor configured to perform multiple PSAD calculations between the data elements of the second operand and a first subset of data elements of the first operand. The multiple PSAD calculations are performed in response to a single instruction set. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> The present invention can also be viewed as providing methods for computing multiple PSAD in response to a single instruction. In this regard, one embodiment of such a method comprises the steps of receiving a single instruction, and performing multiple PSAD calculations in response to a single instruction. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> Other systems, methods, features, and advantages of the present invention will be or become apparent to one with skill in the art upon examination of the following drawings and detailed description. It is intended that all such additional systems, methods, features, and advantages be included within this description, be within the scope of the present invention, and be protected by the accompanying claims.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> Many aspects of the invention can be better understood with reference to the following drawings. The components in the drawings are not necessarily to scale, emphasis instead being placed upon clearly illustrating the principles of the present invention. Moreover, in the drawings, like reference numerals designate corresponding parts throughout the several views. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1A</cross-reference> is a block diagram showing one embodiment of a system configured to perform multiple packed-sum absolute differences (PSAD) calculations in response to a single microprocessor instruction. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1B</cross-reference> is a block diagram showing another embodiment of a system having dedicated hardware configured to perform multiple PSAD calculations in response to an instruction from a microprocessor. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2A</cross-reference> is a block diagram showing another embodiment of a system configured to perform multiple PSAD calculations in response to a single microprocessor instruction. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2B</cross-reference> is a block diagram showing another embodiment of a system having dedicated hardware configured to perform multiple PSAD calculations in response to an instruction from a microprocessor. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 3A and 3B</cross-reference> are block diagrams showing one embodiment of a system configured to perform a binary search of a plurality of MAD values to determine a &ldquo;best&rdquo; MAD value. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a flowchart showing method steps in one embodiment of a method for performing multiple PSAD calculations in response to a single microprocessor instruction. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5A</cross-reference> is a flowchart showing, in greater detail, method steps in one embodiment of the step of performing the multiple PSAD calculation of <cross-reference target="DRAWINGS">FIG. 4</cross-reference>. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5B</cross-reference> is a flowchart showing, in greater detail, method steps in another embodiment of the step of performing the multiple PSAD calculation of <cross-reference target="DRAWINGS">FIG. 4</cross-reference>. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is a flowchart showing, in greater detail, method steps associated with the step of determining the minimum MAD value of <cross-reference target="DRAWINGS">FIG. 4</cross-reference>. </paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS </heading>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> Having summarized various aspects of the present invention, reference is now made in detail to the description of the embodiments as illustrated in the drawings. While the several embodiments are described in connection with these drawings, there is no intent to limit the invention to the embodiment or embodiments disclosed herein. On the contrary, the intent is to cover all alternatives, modifications, and equivalents included within the spirit and scope of the invention as defined by the appended claims. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1A</cross-reference> is a block diagram showing one embodiment of a system configured to perform multiple packed-sum absolute differences (PSAD) calculations in response to a single microprocessor instruction. As shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>A, one embodiment of the system comprises a first register <highlight><bold>120</bold></highlight> (hereinafter also referred to as SRC<highlight><bold>1</bold></highlight>) having a first operand <highlight><bold>110</bold></highlight> (hereinafter also referred to as OP<highlight><bold>1</bold></highlight>), and a second register <highlight><bold>140</bold></highlight> (hereinafter also referred to as SRC<highlight><bold>2</bold></highlight>) having a second operand <highlight><bold>130</bold></highlight> (hereinafter also referred to as OP<highlight><bold>2</bold></highlight>). In a preferred embodiment, the system is configured to take advantage of the fact that many motion estimation algorithms calculate mean absolute differences (MAD) for neighboring pixels. Thus, data elements in OP<highlight><bold>1</bold></highlight> <highlight><bold>110</bold></highlight> may represent contiguous pixels in an object image, while data elements in OP<highlight><bold>2</bold></highlight> <highlight><bold>130</bold></highlight> may represent contiguous pixels in a reference image. Alternatively, data elements in OP<highlight><bold>1</bold></highlight> <highlight><bold>1110</bold></highlight> and OP<highlight><bold>2</bold></highlight> <highlight><bold>130</bold></highlight> may represent contiguous pixels in video frames. In any event, OP<highlight><bold>1</bold></highlight> <highlight><bold>110</bold></highlight> and OP<highlight><bold>2</bold></highlight> <highlight><bold>130</bold></highlight> comprise multiple data elements representing contiguous pixels, and, hence, reduce the number of data loading operations as a function of the size of the operands <highlight><bold>110</bold></highlight>, <highlight><bold>130</bold></highlight>. Thus, for example, if OP<highlight><bold>1</bold></highlight> <highlight><bold>110</bold></highlight> is a 120-bit operand OP<highlight><bold>2</bold></highlight> <highlight><bold>130</bold></highlight> is a 64-bit operand, then, as shown below, up to eight PSAD calculations may be performed without further loading of data. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> Since the calculation of MAD values includes the calculation of multiple PSAD values, a processor <highlight><bold>100</bold></highlight>, as shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>A, also includes a plurality of PSAD execution units <highlight><bold>150</bold></highlight><highlight><italic>a </italic></highlight>. . . <highlight><bold>150</bold></highlight><highlight><italic>h </italic></highlight>(hereinafter also referred to as PSAD unit n <highlight><bold>150</bold></highlight>). In this sense, the PSAD unit<highlight><bold>0</bold></highlight> <highlight><bold>150</bold></highlight><highlight><italic>a </italic></highlight>receives the first 64 bits of OP<highlight><bold>1</bold></highlight> <highlight><bold>110</bold></highlight> (i.e., OP<highlight><bold>1</bold></highlight>&lsqb;0:63&rsqb;) from SRC<highlight><bold>1</bold></highlight> <highlight><bold>120</bold></highlight> and the 64-bit OP<highlight><bold>2</bold></highlight> <highlight><bold>130</bold></highlight> (i.e., OP<highlight><bold>2</bold></highlight>&lsqb;0:63&rsqb;) from SRC<highlight><bold>2</bold></highlight> <highlight><bold>140</bold></highlight>, and performs a PSAD calculation between OP<highlight><bold>1</bold></highlight>&lsqb;0:63&rsqb; and OP<highlight><bold>2</bold></highlight>&lsqb;0:63&rsqb;. The PSAD unit<highlight><bold>1</bold></highlight> <highlight><bold>150</bold></highlight><highlight><italic>b </italic></highlight>receives OP<highlight><bold>1</bold></highlight>&lsqb;8:71&rsqb;, which represent the next contiguous eight bytes of OP<highlight><bold>1</bold></highlight> <highlight><bold>110</bold></highlight>, and OP<highlight><bold>2</bold></highlight>&lsqb;0:63&rsqb;, and performs a PSAD calculation between OP<highlight><bold>1</bold></highlight> &lsqb;8:71&rsqb; and OP<highlight><bold>2</bold></highlight>&lsqb;0:63&rsqb;. Similarly, each subsequent PSAD execution unit <highlight><bold>150</bold></highlight> receives subsequent contiguous eight bytes of OP<highlight><bold>1</bold></highlight> <highlight><bold>110</bold></highlight> and the eight bytes of OP<highlight><bold>2</bold></highlight> <highlight><bold>130</bold></highlight>, and performs a PSAD calculation between the received bytes of OP<highlight><bold>1</bold></highlight> <highlight><bold>110</bold></highlight> and OP<highlight><bold>2</bold></highlight> <highlight><bold>130</bold></highlight>. Thus, when each of the eight PSAD execution units <highlight><bold>150</bold></highlight> is finished with its calculation, each of the PSAD execution units <highlight><bold>150</bold></highlight> has produced a 16-bit result indicative of the PSAD calculation, and, further, of a mean absolute difference (MAD) value. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> Each of the results from the PSAD executions units <highlight><bold>150</bold></highlight> is directed to a pack unit <highlight><bold>160</bold></highlight>, which concatenates the eight 16-bit results into a single 128-bit destination operand <highlight><bold>180</bold></highlight> (i.e., DOP&lsqb;0:127&rsqb;), which is stored in a result register <highlight><bold>190</bold></highlight>. The 128-bit DOP <highlight><bold>180</bold></highlight>, as a whole, represents the eight calculated mean absolute difference (MAD) values <highlight><bold>180</bold></highlight><highlight><italic>a </italic></highlight>. . . <highlight><bold>180</bold></highlight><highlight><italic>h </italic></highlight>from the eight PSAD execution units <highlight><bold>150</bold></highlight>. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> Thus, for a 120-bit OP<highlight><bold>1</bold></highlight> <highlight><bold>110</bold></highlight> and a 64-bit OP<highlight><bold>2</bold></highlight> <highlight><bold>130</bold></highlight>, there would be eight parallel processes, summarized as follows: </paragraph>
<paragraph id="P-0030" lvl="2"><number>&lsqb;0030&rsqb;</number> PSAD<highlight><bold>0</bold></highlight> performs BYTE_SUM(ABS(SRC<highlight><bold>1</bold></highlight>&lsqb;0:63&rsqb;-SRC<highlight><bold>2</bold></highlight>&lsqb;0:63&rsqb;)) and stores the result in DOP&lsqb;0:15&rsqb;; </paragraph>
<paragraph id="P-0031" lvl="2"><number>&lsqb;0031&rsqb;</number> PSAD<highlight><bold>1</bold></highlight> performs BYTE_SUM(ABS(SRC<highlight><bold>1</bold></highlight>&lsqb;8:71&rsqb;-SRC<highlight><bold>2</bold></highlight>&lsqb;0:63&rsqb;)) and stores the result in DOP&lsqb;16:31&rsqb;; </paragraph>
<paragraph id="P-0032" lvl="2"><number>&lsqb;0032&rsqb;</number> PSAD<highlight><bold>2</bold></highlight> performs BYTE_SUM(ABS(SRC<highlight><bold>1</bold></highlight>&lsqb;16:79&rsqb;-SRC<highlight><bold>2</bold></highlight>&lsqb;0:63&rsqb;)) and stores the result in DOP&lsqb;32:47&rsqb;; </paragraph>
<paragraph id="P-0033" lvl="2"><number>&lsqb;0033&rsqb;</number> PSAD<highlight><bold>3</bold></highlight> performs BYTE_SUM(ABS(SRC<highlight><bold>1</bold></highlight>&lsqb;24:87&rsqb;-SRC<highlight><bold>2</bold></highlight>&lsqb;0:63&rsqb;)) and stores the result in DOP&lsqb;48:63&rsqb;; </paragraph>
<paragraph id="P-0034" lvl="2"><number>&lsqb;0034&rsqb;</number> PSAD<highlight><bold>4</bold></highlight> performs BYTE_SUM(ABS(SRC<highlight><bold>1</bold></highlight>&lsqb;32:95&rsqb;-SRC<highlight><bold>2</bold></highlight>&lsqb;0:63&rsqb;)) and stores the result in DOP&lsqb;64:79&rsqb;; </paragraph>
<paragraph id="P-0035" lvl="2"><number>&lsqb;0035&rsqb;</number> PSAD<highlight><bold>5</bold></highlight> performs BYTE_SUM(ABS(SRC<highlight><bold>1</bold></highlight>&lsqb;40:103&rsqb;-SRC<highlight><bold>2</bold></highlight>&lsqb;0:63&rsqb;)) and stores the result in DOP&lsqb;80:95&rsqb;; </paragraph>
<paragraph id="P-0036" lvl="2"><number>&lsqb;0036&rsqb;</number> PSAD<highlight><bold>6</bold></highlight> performs BYTE_SUM(ABS(SRC<highlight><bold>1</bold></highlight>&lsqb;48:111&rsqb;-SRC<highlight><bold>2</bold></highlight>&lsqb;0:63&rsqb;)) and stores the result in DOP&lsqb;96:111&rsqb;; </paragraph>
<paragraph id="P-0037" lvl="2"><number>&lsqb;0037&rsqb;</number> PSAD<highlight><bold>7</bold></highlight> performs BYTE_SUM(ABS(SRC<highlight><bold>1</bold></highlight>&lsqb;56:119&rsqb;-SRC<highlight><bold>2</bold></highlight>&lsqb;0:63&rsqb;)) and stores the result in DOP&lsqb;112:127&rsqb;; </paragraph>
<paragraph id="P-0038" lvl="2"><number>&lsqb;0038&rsqb;</number> wherein the BYTE_SUM operation is a sum of each contiguous 8-bit segment of: ABS(SRC<highlight><bold>1</bold></highlight> &lsqb;&rsqb;-SRC<highlight><bold>2</bold></highlight>&lsqb;&rsqb;), </paragraph>
<paragraph id="P-0039" lvl="2"><number>&lsqb;0039&rsqb;</number> for example:  
<math-cwu id="MATH-US-00001">
<number>1</number>
<math>
<mtable>
  <mtr>
    <mtd>
      <mrow>
        <mrow>
          <mi>DOP</mi>
          <mo>&af;</mo>
          <mrow>
            <mo>[</mo>
            <mrow>
              <mn>0</mn>
              <mo>:</mo>
              <mn>15</mn>
            </mrow>
            <mo>]</mo>
          </mrow>
        </mrow>
        <mo>=</mo>
        <mstyle>
          <mtext>&emsp;</mtext>
        </mstyle>
        <mo>&it;</mo>
        <mrow>
          <mo>(</mo>
          <mrow>
            <mrow>
              <mi>ABS</mi>
              <mo>&af;</mo>
              <mrow>
                <mo>(</mo>
                <mrow>
                  <mrow>
                    <mi>SRC1</mi>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>[</mo>
                      <mrow>
                        <mn>0</mn>
                        <mo>:</mo>
                        <mn>7</mn>
                      </mrow>
                      <mo>]</mo>
                    </mrow>
                  </mrow>
                  <mo>-</mo>
                  <mrow>
                    <mi>SRC2</mi>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>[</mo>
                      <mrow>
                        <mn>0</mn>
                        <mo>:</mo>
                        <mn>7</mn>
                      </mrow>
                      <mo>]</mo>
                    </mrow>
                  </mrow>
                </mrow>
                <mo>)</mo>
              </mrow>
            </mrow>
            <mo>+</mo>
          </mrow>
        </mrow>
      </mrow>
    </mtd>
  </mtr>
  <mtr>
    <mtd>
      <mrow>
        <mstyle>
          <mtext>&emsp;</mtext>
        </mstyle>
        <mo>&it;</mo>
        <mrow>
          <mo>(</mo>
          <mrow>
            <mrow>
              <mi>ABS</mi>
              <mo>&af;</mo>
              <mrow>
                <mo>(</mo>
                <mrow>
                  <mrow>
                    <mi>SRC1</mi>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>[</mo>
                      <mrow>
                        <mn>8</mn>
                        <mo>:</mo>
                        <mn>7</mn>
                      </mrow>
                      <mo>]</mo>
                    </mrow>
                  </mrow>
                  <mo>-</mo>
                  <mrow>
                    <mi>SRC2</mi>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>[</mo>
                      <mrow>
                        <mn>8</mn>
                        <mo>:</mo>
                        <mn>15</mn>
                      </mrow>
                      <mo>]</mo>
                    </mrow>
                  </mrow>
                </mrow>
                <mo>)</mo>
              </mrow>
            </mrow>
            <mo>+</mo>
          </mrow>
        </mrow>
      </mrow>
    </mtd>
  </mtr>
  <mtr>
    <mtd>
      <mrow>
        <mstyle>
          <mtext>&emsp;</mtext>
        </mstyle>
        <mo>&it;</mo>
        <mrow>
          <mo>(</mo>
          <mrow>
            <mrow>
              <mi>ABS</mi>
              <mo>&af;</mo>
              <mrow>
                <mo>(</mo>
                <mrow>
                  <mrow>
                    <mi>SRC1</mi>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>[</mo>
                      <mrow>
                        <mn>16</mn>
                        <mo>:</mo>
                        <mn>23</mn>
                      </mrow>
                      <mo>]</mo>
                    </mrow>
                  </mrow>
                  <mo>-</mo>
                  <mrow>
                    <mi>SRC2</mi>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>[</mo>
                      <mrow>
                        <mn>16</mn>
                        <mo>:</mo>
                        <mn>23</mn>
                      </mrow>
                      <mo>]</mo>
                    </mrow>
                  </mrow>
                </mrow>
                <mo>)</mo>
              </mrow>
            </mrow>
            <mo>+</mo>
          </mrow>
        </mrow>
      </mrow>
    </mtd>
  </mtr>
  <mtr>
    <mtd>
      <mrow>
        <mstyle>
          <mtext>&emsp;</mtext>
        </mstyle>
        <mo>&it;</mo>
        <mrow>
          <mo>(</mo>
          <mrow>
            <mrow>
              <mi>ABS</mi>
              <mo>&af;</mo>
              <mrow>
                <mo>(</mo>
                <mrow>
                  <mrow>
                    <mi>SRC1</mi>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>[</mo>
                      <mrow>
                        <mn>24</mn>
                        <mo>:</mo>
                        <mn>31</mn>
                      </mrow>
                      <mo>]</mo>
                    </mrow>
                  </mrow>
                  <mo>-</mo>
                  <mrow>
                    <mi>SRC2</mi>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>[</mo>
                      <mrow>
                        <mn>24</mn>
                        <mo>:</mo>
                        <mn>31</mn>
                      </mrow>
                      <mo>]</mo>
                    </mrow>
                  </mrow>
                </mrow>
                <mo>)</mo>
              </mrow>
            </mrow>
            <mo>+</mo>
          </mrow>
        </mrow>
      </mrow>
    </mtd>
  </mtr>
  <mtr>
    <mtd>
      <mrow>
        <mstyle>
          <mtext>&emsp;</mtext>
        </mstyle>
        <mo>&it;</mo>
        <mrow>
          <mo>(</mo>
          <mrow>
            <mi>ABS</mi>
            <mo>(</mo>
            <mrow>
              <mrow>
                <mi>SRC1</mi>
                <mo>&af;</mo>
                <mrow>
                  <mo>[</mo>
                  <mrow>
                    <mn>32</mn>
                    <mo>:</mo>
                    <mn>39</mn>
                  </mrow>
                  <mo>]</mo>
                </mrow>
              </mrow>
              <mo>-</mo>
              <mrow>
                <mi>SRC2</mi>
                <mo>&af;</mo>
                <mrow>
                  <mo>[</mo>
                  <mrow>
                    <mn>32</mn>
                    <mo>:</mo>
                    <mn>39</mn>
                  </mrow>
                  <mo>]</mo>
                </mrow>
              </mrow>
              <mo>+</mo>
            </mrow>
          </mrow>
        </mrow>
      </mrow>
    </mtd>
  </mtr>
  <mtr>
    <mtd>
      <mrow>
        <mstyle>
          <mtext>&emsp;</mtext>
        </mstyle>
        <mo>&it;</mo>
        <mrow>
          <mo>(</mo>
          <mrow>
            <mi>ABS</mi>
            <mo>(</mo>
            <mrow>
              <mrow>
                <mi>SRC1</mi>
                <mo>&af;</mo>
                <mrow>
                  <mo>[</mo>
                  <mrow>
                    <mn>40</mn>
                    <mo>:</mo>
                    <mn>47</mn>
                  </mrow>
                  <mo>]</mo>
                </mrow>
              </mrow>
              <mo>-</mo>
              <mrow>
                <mi>SRC2</mi>
                <mo>&af;</mo>
                <mrow>
                  <mo>[</mo>
                  <mrow>
                    <mn>40</mn>
                    <mo>:</mo>
                    <mn>47</mn>
                  </mrow>
                  <mo>]</mo>
                </mrow>
              </mrow>
              <mo>+</mo>
            </mrow>
          </mrow>
        </mrow>
      </mrow>
    </mtd>
  </mtr>
  <mtr>
    <mtd>
      <mrow>
        <mstyle>
          <mtext>&emsp;</mtext>
        </mstyle>
        <mo>&it;</mo>
        <mrow>
          <mo>(</mo>
          <mrow>
            <mrow>
              <mi>ABS</mi>
              <mo>&af;</mo>
              <mrow>
                <mo>(</mo>
                <mrow>
                  <mrow>
                    <mi>SRC1</mi>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>[</mo>
                      <mrow>
                        <mn>48</mn>
                        <mo>:</mo>
                        <mn>55</mn>
                      </mrow>
                      <mo>]</mo>
                    </mrow>
                  </mrow>
                  <mo>-</mo>
                  <mrow>
                    <mi>SRC2</mi>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>[</mo>
                      <mrow>
                        <mn>48</mn>
                        <mo>:</mo>
                        <mn>55</mn>
                      </mrow>
                      <mo>]</mo>
                    </mrow>
                  </mrow>
                </mrow>
                <mo>)</mo>
              </mrow>
            </mrow>
            <mo>+</mo>
          </mrow>
        </mrow>
      </mrow>
    </mtd>
  </mtr>
  <mtr>
    <mtd>
      <mrow>
        <mstyle>
          <mtext>&emsp;</mtext>
        </mstyle>
        <mo>&it;</mo>
        <mrow>
          <mo>(</mo>
          <mrow>
            <mi>ABS</mi>
            <mo>&af;</mo>
            <mrow>
              <mo>(</mo>
              <mrow>
                <mrow>
                  <mi>SRC1</mi>
                  <mo>&af;</mo>
                  <mrow>
                    <mo>[</mo>
                    <mrow>
                      <mn>56</mn>
                      <mo>:</mo>
                      <mn>63</mn>
                    </mrow>
                    <mo>]</mo>
                  </mrow>
                </mrow>
                <mo>-</mo>
                <mrow>
                  <mi>SRC2</mi>
                  <mo>&af;</mo>
                  <mrow>
                    <mo>[</mo>
                    <mrow>
                      <mn>56</mn>
                      <mo>:</mo>
                      <mn>63</mn>
                    </mrow>
                    <mo>]</mo>
                  </mrow>
                </mrow>
              </mrow>
              <mo>)</mo>
            </mrow>
          </mrow>
          <mo>)</mo>
        </mrow>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
<mathematica-file id="MATHEMATICA-00001" file="US20030005267A1-20030102-M00001.NB"/>
<image id="EMI-M00001" wi="216.027" he="88.08345" file="US20030005267A1-20030102-M00001.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> Thus, as shown in the embodiment of <cross-reference target="DRAWINGS">FIG. 1A, a</cross-reference> 120-bit OP<highlight><bold>1</bold></highlight> <highlight><bold>110</bold></highlight>, a 64-bit OP<highlight><bold>2</bold></highlight> <highlight><bold>130</bold></highlight>, and eight PSAD execution units <highlight><bold>150</bold></highlight> allows the processor <highlight><bold>100</bold></highlight> to perform eight PSAD calculations without additional loading of data. Additionally, the configuration of <cross-reference target="DRAWINGS">FIG. 1A</cross-reference> permits the calculation of eight PSAD values in parallel in response to a single instruction, thereby eliminating additional latency. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> While the specific embodiment of <cross-reference target="DRAWINGS">FIG. 1A</cross-reference> shows eight parallel PSAD execution units <highlight><bold>150</bold></highlight>, it will be clear to one of ordinary skill in the art that different embodiments may include a greater or a fewer number of PSAD execution units <highlight><bold>150</bold></highlight>. It is, however, worthwhile to note that, preferably, the number of PSAD execution units be a power of 2 (e.g., 2, 4, 8, 16, . . . , 2<highlight><superscript>n</superscript></highlight>) for simplicity of implementation. In this sense, the SRC<highlight><bold>1</bold></highlight> <highlight><bold>120</bold></highlight> would concomitantly be a 2<highlight><superscript>n&minus;1</superscript></highlight>-bit register, and OP<highlight><bold>1</bold></highlight> <highlight><bold>110</bold></highlight> would preferably be a 2<highlight><superscript>n&minus;1</superscript></highlight>-bit operand. Additionally, while <cross-reference target="DRAWINGS">FIG. 1A</cross-reference> shows the processing of contiguous bits, the processor <highlight><bold>100</bold></highlight> in more complex environments may be configured to process subsets of OP<highlight><bold>1</bold></highlight> <highlight><bold>110</bold></highlight> that are non-contiguous. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1B</cross-reference> is a block diagram showing another embodiment <highlight><bold>195</bold></highlight> of a system having dedicated hardware <highlight><bold>199</bold></highlight> configured to perform multiple PSAD calculations in response to an instruction from a microprocessor <highlight><bold>195</bold></highlight>. The dedicated hardware <highlight><bold>199</bold></highlight> may be configured similar to the system of <cross-reference target="DRAWINGS">FIG. 1A</cross-reference>. Thus, while <cross-reference target="DRAWINGS">FIG. 1A</cross-reference> shows one embodiment of the invention as being a part of the processor <highlight><bold>100</bold></highlight>, it will be clear to one of ordinary skill in the art that the system of <cross-reference target="DRAWINGS">FIG. 1A</cross-reference> may be implemented in dedicated hardware <highlight><bold>199</bold></highlight> that is physically separate from the microprocessor <highlight><bold>195</bold></highlight>. Thus, the system of <cross-reference target="DRAWINGS">FIG. 1A</cross-reference> may be configured in such a way that the microprocessor <highlight><bold>195</bold></highlight> accesses the dedicated hardware <highlight><bold>199</bold></highlight> in response to the execution of the single instruction. This permits the microprocessor <highlight><bold>195</bold></highlight> to perform other calculations while the dedicated hardware <highlight><bold>199</bold></highlight> performs the multiple PSAD calculations. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2A</cross-reference> is a block diagram showing another embodiment of a processor <highlight><bold>200</bold></highlight> configured to perform multiple PSAD calculations in response to a single microprocessor instruction. Unlike the embodiment of <cross-reference target="DRAWINGS">FIG. 1</cross-reference>A, only a single PSAD execution unit <highlight><bold>150</bold></highlight> is employed in the embodiment of <cross-reference target="DRAWINGS">FIG. 2A</cross-reference>. However, an additional 8-bit shift register <highlight><bold>210</bold></highlight> is employed to direct the appropriate bits of OP<highlight><bold>1</bold></highlight> <highlight><bold>110</bold></highlight> to the PSAD execution unit. Thus, as shown in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>A, given OP<highlight><bold>1</bold></highlight> &lsqb;0:119&rsqb; and OP<highlight><bold>2</bold></highlight>&lsqb;0:63&rsqb;, the PSAD execution unit <highlight><bold>150</bold></highlight> would effectively perform the function of PSAD unit<highlight><bold>0</bold></highlight> <highlight><bold>150</bold></highlight><highlight><italic>a </italic></highlight>(<cross-reference target="DRAWINGS">FIG. 1A</cross-reference>) at a first clock cycle. Subsequently, at a second clock cycle, the PSAD execution unit <highlight><bold>150</bold></highlight> would perform the function of PSAD unit<highlight><bold>1</bold></highlight> <highlight><bold>150</bold></highlight><highlight><italic>b </italic></highlight>(<cross-reference target="DRAWINGS">FIG. 1A</cross-reference>), etc. In other words, the shift register <highlight><bold>210</bold></highlight> would, effectively, direct appropriate bits of OP<highlight><bold>1</bold></highlight> <highlight><bold>110</bold></highlight> to the PSAD execution unit <highlight><bold>150</bold></highlight>, such that: </paragraph>
<paragraph id="P-0044" lvl="2"><number>&lsqb;0044&rsqb;</number> PSAD execution unit performs BYTE_SUM(ABS(SRC<highlight><bold>1</bold></highlight>&lsqb;0:63&rsqb;-SRC<highlight><bold>2</bold></highlight>&lsqb;0:63&rsqb;)) at clock cycle <highlight><bold>1</bold></highlight>; </paragraph>
<paragraph id="P-0045" lvl="2"><number>&lsqb;0045&rsqb;</number> PSAD execution unit performs BYTE_SUM(ABS(SRC<highlight><bold>1</bold></highlight>&lsqb;8:71&rsqb;-SRC<highlight><bold>2</bold></highlight>&lsqb;0:63&rsqb;)) at clock cycle <highlight><bold>2</bold></highlight>; </paragraph>
<paragraph id="P-0046" lvl="2"><number>&lsqb;0046&rsqb;</number> PSAD execution unit performs BYTE_SUM(ABS(SRC<highlight><bold>1</bold></highlight>&lsqb;16:79&rsqb;-SRC<highlight><bold>2</bold></highlight>&lsqb;0:63&rsqb;)) at clock cycle <highlight><bold>3</bold></highlight>; </paragraph>
<paragraph id="P-0047" lvl="2"><number>&lsqb;0047&rsqb;</number> PSAD execution unit performs BYTE_SUM(ABS(SRC<highlight><bold>1</bold></highlight>&lsqb;24:87&rsqb;-SRC<highlight><bold>2</bold></highlight>&lsqb;0:63&rsqb;)) at clock cycle <highlight><bold>4</bold></highlight>; </paragraph>
<paragraph id="P-0048" lvl="2"><number>&lsqb;0048&rsqb;</number> PSAD execution unit performs BYTE_SUM(ABS(SRC<highlight><bold>1</bold></highlight>&lsqb;32:95&rsqb;-SRC<highlight><bold>2</bold></highlight>&lsqb;0:63&rsqb;)) at clock cycle <highlight><bold>5</bold></highlight>; </paragraph>
<paragraph id="P-0049" lvl="2"><number>&lsqb;0049&rsqb;</number> PSAD execution unit performs BYTE_SUM(ABS(SRC<highlight><bold>1</bold></highlight> &lsqb;40:103&rsqb;-SRC<highlight><bold>2</bold></highlight>&lsqb;0:63&rsqb;)) at clock cycle <highlight><bold>6</bold></highlight>; </paragraph>
<paragraph id="P-0050" lvl="2"><number>&lsqb;0050&rsqb;</number> PSAD execution unit performs BYTE_SUM(ABS(SRC<highlight><bold>1</bold></highlight>&lsqb;48:111&rsqb;-SRC<highlight><bold>2</bold></highlight>&lsqb;0:63&rsqb;)) at clock cycle <highlight><bold>7</bold></highlight>; and </paragraph>
<paragraph id="P-0051" lvl="2"><number>&lsqb;0051&rsqb;</number> PSAD execution unit performs BYTE_SUM(ABS(SRC<highlight><bold>1</bold></highlight>&lsqb;56:119&rsqb;-SRC<highlight><bold>2</bold></highlight>&lsqb;0:63&rsqb;)) at clock cycle <highlight><bold>8</bold></highlight>. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> The processor <highlight><bold>200</bold></highlight> further comprises an additional shift register <highlight><bold>220</bold></highlight>, which is configured to shift the 16-bit PSAD result from each clock cycle, thereby effectively generating contiguous 16-bit segments of PSAD results, which are stored in a result register <highlight><bold>190</bold></highlight> as DOP&lsqb;0:127&rsqb;. Thus, each contiguous 16-bit segment of DOP&lsqb;0:127&rsqb; would represent a MAD value calculated by the PSAD execution unit <highlight><bold>150</bold></highlight> at each clock cycle. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> Unlike the embodiment of <cross-reference target="DRAWINGS">FIG. 1</cross-reference>A, in which the eight PSAD calculations are performed in parallel, the processor <highlight><bold>200</bold></highlight> here performs the eight PSAD calculations sequentially. However, the processing is still vastly simplified since the data-loading operation is only performed once (i.e., SRC<highlight><bold>1</bold></highlight> <highlight><bold>120</bold></highlight> and SRC<highlight><bold>2</bold></highlight> <highlight><bold>140</bold></highlight> are only loaded once with their respective data elements). Additionally, latency is reduced since data shifting operations by the shift register <highlight><bold>210</bold></highlight> (or shift register <highlight><bold>220</bold></highlight>) may concurrently be performed for subsequent (or preceding) subsets of data elements while the PSAD execution unit <highlight><bold>150</bold></highlight> is performing a given PSAD calculation. Furthermore, the processor <highlight><bold>200</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 2A</cross-reference> provides for a more simplified hardware architecture. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> While the specific embodiment of <cross-reference target="DRAWINGS">FIG. 2A</cross-reference> shows eight sequential PSAD calculations, it will be clear to one of ordinary skill in the art that different embodiments may include a greater or a fewer number of PSAD calculations. It is, however, worthwhile to note that, preferably, the number of PSAD execution units be a power of 2 (e.g., 2, 4, 8, 5 16, . . . , 2<highlight><superscript>n</superscript></highlight>) for simplicity of implementation. In this sense, the SRC<highlight><bold>1</bold></highlight> <highlight><bold>120</bold></highlight> would concomitantly be a 2<highlight><superscript>n&minus;1</superscript></highlight>-bit register, and OP<highlight><bold>1</bold></highlight> <highlight><bold>110</bold></highlight> would preferably be a 2<highlight><superscript>n&minus;1</superscript></highlight>-bit operand. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> Additionally, while <cross-reference target="DRAWINGS">FIG. 1A</cross-reference> shows the processing of contiguous bits, the processor <highlight><bold>100</bold></highlight>, in more complex environments, may be configured to process subsets of OP<highlight><bold>1</bold></highlight> <highlight><bold>110</bold></highlight> that are non-contiguous. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> Regardless of whether the embodiment of <cross-reference target="DRAWINGS">FIG. 1A</cross-reference> or the embodiment of <cross-reference target="DRAWINGS">FIG. 2A</cross-reference> is employed to derive the DOP <highlight><bold>180</bold></highlight>, the same calculation is usually repeated for all pixel lines in the macroblock, typically comprising <highlight><bold>8</bold></highlight> or <highlight><bold>16</bold></highlight> consecutive lines. The results of the multiple PSAD calculations for every line are added together. A single 128-bit accumulator register may be utilized. The results of each multiple PSAD calculation can be added to the accumulator register using a &ldquo;packed add&rdquo; instruction, which is typically supported by modem microprocessors. In some embodiments the &ldquo;packed add&rdquo; operation may be included into the flow of the multiple PSAD operations to avoid a calling of separate instructions (i.e., the multiple PSAD results would be automatically added to the values previously accumulated in the accumulator register). </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> Note that the next multiple PSAD operation can begin execution before the previous multiple PSAD operation is completed because there is no explicit data dependency. This is beneficial for performance since many modem microprocessors are capable of executing multiple instructions in sequence if one instruction is not explicitly data dependent on the previous one. Given the increased efficiency, another embodiment of the invention may be perceived as a microprocessor instruction that is capable of recursively performing the multiple PSAD instructions in response to a single instruction. For simplicity, this single microprocessor instruction may be designated as a multiple-multiple-PSAD (MMPSAD) instruction. Since the MMPSAD instruction permits recursive calculations of multiple PSAD values, parameters of the MMPSAD instruction may include an initial address, which provides the memory location of the first pixel line, and an iteration number, which designates the number of consecutive pixel lines for which multiple PSAD values are calculated (i.e., the number of iterations). In a preferred embodiment, the number of iterations would be any power of 2 (e.g., 2, 4, 8, 16, etc.). Thus, for example, if the MMPSAD instruction includes a starting address of 0&times;00 and indicates eight iterations, then the system would calculate eight consecutive multiple PSAD values from 0&times;00. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> In any event, regardless of whether the embodiment of <cross-reference target="DRAWINGS">FIG. 1A</cross-reference> or the embodiment of <cross-reference target="DRAWINGS">FIG. 2A</cross-reference> or other alternative embodiments are employed to derive the DOP <highlight><bold>180</bold></highlight>, once all of the MAD values for a number of consecutive lines in the macroblock are calculated and added to the corresponding values in an accumulation register, motion estimation algorithms often derive a single &ldquo;best&rdquo; MAD value by determining a minimum MAD value from the plurality of calculated MAD values. One embodiment of a system for determining a &ldquo;best&rdquo; MAD value is shown in <cross-reference target="DRAWINGS">FIGS. 3A and 3B</cross-reference>. Since the embodiments of <cross-reference target="DRAWINGS">FIGS. 1A and 2A</cross-reference> produce a 128-bit DOP (i.e., eight MAD values), the specific embodiment of <cross-reference target="DRAWINGS">FIGS. 3A and 3B</cross-reference> show the derivation of the &ldquo;best&rdquo; MAD value from the 128-bit DOP. However, it will be clear to one of ordinary skill in the art that, if the processors <highlight><bold>100</bold></highlight>, <highlight><bold>200</bold></highlight> of <cross-reference target="DRAWINGS">FIGS. 1A and 2A</cross-reference> are configured to produce a different 2<highlight><superscript>n </superscript></highlight>number of MAD values, the embodiment of <cross-reference target="DRAWINGS">FIGS. 3A and 3B</cross-reference> may be appropriately altered to accommodate the 2<highlight><superscript>n </superscript></highlight>MAD values. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> While <cross-reference target="DRAWINGS">FIG. 2A</cross-reference> shows one embodiment of the invention as being a part of the processor, it will be clear to one of ordinary skill in the art that the system of <cross-reference target="DRAWINGS">FIGS. 2A</cross-reference> may be implemented in dedicated hardware that is physically separate from a microprocessor. This is shown in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>B, which shows the system of <cross-reference target="DRAWINGS">FIG. 2A</cross-reference> such that a microprocessor <highlight><bold>297</bold></highlight> accesses the dedicated hardware <highlight><bold>299</bold></highlight> in response to the execution of the single instruction. This permits the microprocessor to perform other calculations while the dedicated hardware performs the MMPSAD calculation. As shown in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>B, the dedicated hardware <highlight><bold>299</bold></highlight> may be configured similar to the processor of <cross-reference target="DRAWINGS">FIG. 2A</cross-reference>. </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 3A and 3B</cross-reference> are block diagrams showing one embodiment of a system configured to perform a binary search of a plurality of calculated MAD values to determine the lowest MAD value. In a broad sense, the system of <cross-reference target="DRAWINGS">FIGS. 3A and 3B</cross-reference> performs a binary search on non-overlapping 16-bit segments of the 128-bit DOP in order to determine which of the 16-bit segments has the minimum value as compared to the other 16-bit segments. In other words, since each non-overlapping 16-bit segment represents a MAD value, the system performs a binary search on the 2<highlight><superscript>n </superscript></highlight>MAD values to determine which of the 2<highlight><superscript>n </superscript></highlight>MAD values is the &ldquo;best&rdquo; MAD value. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> The embodiment shown in <cross-reference target="DRAWINGS">FIGS. 3A and 3B</cross-reference> takes advantage of the fact that the MAD comparing procedure is mathematically equivalent to first selecting the lowest of eight separate MAD values and finding a position (e.g., an integer number from 0 to 7) of the lowest MAD value, then comparing only one of the lowest MAD values with the &ldquo;best&rdquo; previously-achieved MAD value. Also, if the one MAD value is smaller than the previously-achieved MAD value, then storing the new lowest MAD value and pixel block position. For this, only one conditional instruction is required, which compares one new MAD value with the &ldquo;best&rdquo; previously-achieved MAD value. It is, however, possible to select the lowest of eight separate MAD values (packed in a words format in one register) and find the position (e.g., integer number from 0 to 7) of the lowest MAD value, without conditional instructions, using parallel SIMD instructions that are supported by many microprocessors. The disadvantage of such an approach is that multiple instructions are executed. In any event, it is worthwhile to note that greater performance can be achieved by executing special microprocessor instructions that are specifically designed for selecting the lowest MAD value and finding its position. </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> In the embodiment of <cross-reference target="DRAWINGS">FIGS. 3A and 3B</cross-reference>, which show the calculation of the &ldquo;best&rdquo; MAD value using a single conditional instruction, DOP&lsqb;0:127&rsqb; is divided into two 64-bit segments <highlight><bold>310</bold></highlight>, <highlight><bold>312</bold></highlight>. The first 64-bit segment <highlight><bold>310</bold></highlight> being DOP&lsqb;0:63&rsqb;, which represents MAD<highlight><bold>0</bold></highlight>, MAD<highlight><bold>1</bold></highlight>, MAD<highlight><bold>2</bold></highlight>, and MAD<highlight><bold>3</bold></highlight>, and the second 64-bit segment <highlight><bold>312</bold></highlight> being DOP&lsqb;64:127&rsqb;, which represents MAD<highlight><bold>4</bold></highlight>, MAD<highlight><bold>5</bold></highlight>, MAD<highlight><bold>6</bold></highlight>, and MAD<highlight><bold>7</bold></highlight>. The two 64-bit segments, DOP&lsqb;0:63&rsqb; <highlight><bold>310</bold></highlight> and DOP&lsqb;64:127&rsqb; <highlight><bold>312</bold></highlight>, are directed to a four-word packed-subtract unit <highlight><bold>314</bold></highlight>, while DOP&lsqb;0:127&rsqb; <highlight><bold>180</bold></highlight> is directed to a four-pair packed-select unit <highlight><bold>320</bold></highlight>. The four-word packed-subtract unit <highlight><bold>314</bold></highlight> compares DOP&lsqb;0:63&rsqb; with DOP&lsqb;64:127&rsqb;, which essentially results in four comparisons of 16-bit word-pairs as follows: </paragraph>
<paragraph id="P-0063" lvl="2"><number>&lsqb;0063&rsqb;</number> comparison of MAD<highlight><bold>0</bold></highlight> with MAD<highlight><bold>4</bold></highlight> to determine the position of the lower MAD value, MAD(<highlight><bold>0</bold></highlight>,<highlight><bold>4</bold></highlight>); </paragraph>
<paragraph id="P-0064" lvl="2"><number>&lsqb;0064&rsqb;</number> comparison of MAD<highlight><bold>1</bold></highlight> with MAD<highlight><bold>5</bold></highlight> to determine the position of the lower MAD value, MAD(<highlight><bold>1</bold></highlight>,<highlight><bold>5</bold></highlight>); </paragraph>
<paragraph id="P-0065" lvl="2"><number>&lsqb;0065&rsqb;</number> comparison of MAD<highlight><bold>2</bold></highlight> with MAD<highlight><bold>6</bold></highlight> to determine the position of the lower MAD value, MAD(<highlight><bold>2</bold></highlight>,<highlight><bold>6</bold></highlight>); and </paragraph>
<paragraph id="P-0066" lvl="2"><number>&lsqb;0066&rsqb;</number> comparison of MAD<highlight><bold>3</bold></highlight> with MAD<highlight><bold>7</bold></highlight> to determine the position of the lower MAD value, MAD(<highlight><bold>3</bold></highlight>,<highlight><bold>7</bold></highlight>). </paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> The four-word packed-subtract unit <highlight><bold>314</bold></highlight> produces four carry bits (i.e., a four-bit result indicative of the position of the lower four MAD values). The four carry bits are propagated to the four-pair packed-select unit <highlight><bold>320</bold></highlight>, which has the 128-bit DOP <highlight><bold>180</bold></highlight>, and, also, to a 7&times;3 code converter <highlight><bold>340</bold></highlight>. The four-pair packed-select unit <highlight><bold>320</bold></highlight> selects the four 16-bit results that correspond to the lower four MAD values as indicated by the four carry bits. These four 16-bit results are directed to a two-pair packed-select unit <highlight><bold>332</bold></highlight>. Additionally, these four 16-bit results are divided into two 32-bit segments <highlight><bold>322</bold></highlight>, <highlight><bold>324</bold></highlight>, which are directed to a two-word packed-subtract unit <highlight><bold>323</bold></highlight>, which compares the two 32-bit segments <highlight><bold>322</bold></highlight>, <highlight><bold>324</bold></highlight>, and which essentially results in two comparisons of 16-bit word-pairs as follows: </paragraph>
<paragraph id="P-0068" lvl="2"><number>&lsqb;0068&rsqb;</number> comparison of MAD(<highlight><bold>0</bold></highlight>,<highlight><bold>4</bold></highlight>) with MAD(<highlight><bold>2</bold></highlight>,<highlight><bold>6</bold></highlight>) to determine the position of the lower MAD value, MAD((<highlight><bold>0</bold></highlight>,<highlight><bold>4</bold></highlight>),(<highlight><bold>2</bold></highlight>,<highlight><bold>6</bold></highlight>)); and </paragraph>
<paragraph id="P-0069" lvl="2"><number>&lsqb;0069&rsqb;</number> comparison of MAD(<highlight><bold>1</bold></highlight>,<highlight><bold>5</bold></highlight>) with MAD(<highlight><bold>3</bold></highlight>,<highlight><bold>7</bold></highlight>) to determine the position of the lower MAD value, MAD((<highlight><bold>1</bold></highlight>,<highlight><bold>5</bold></highlight>),(<highlight><bold>3</bold></highlight>,<highlight><bold>7</bold></highlight>)). </paragraph>
<paragraph id="P-0070" lvl="0"><number>&lsqb;0070&rsqb;</number> The two-word packed subtract unit <highlight><bold>323</bold></highlight> produces two carry bits (i.e., a two-bit result indicative of the position of the two lower MAD values). The two carry bits are propagated to the two-pair packed-select unit <highlight><bold>332</bold></highlight>, which has the 64-bit result from the four-pair packed-select unit <highlight><bold>320</bold></highlight>, and, also, to the 7&times;3 code converter <highlight><bold>340</bold></highlight>. The two-pair packed-select unit <highlight><bold>332</bold></highlight> selects the two 16-bit results that correspond to the lower two MAD values as indicated by the two carry bits. These two 16-bit results are directed to a one-pair packed-select unit <highlight><bold>336</bold></highlight> as well as a one-pair packed-subtract unit <highlight><bold>334</bold></highlight>. The one-pair packed-subtract unit <highlight><bold>334</bold></highlight> compares the two 16-bit results to determine which of the two 16-bit results represents the lower MAD value. In other words, the one-pair packed-subtract unit <highlight><bold>334</bold></highlight> compares MAD((<highlight><bold>1</bold></highlight>,<highlight><bold>5</bold></highlight>),(<highlight><bold>3</bold></highlight>,<highlight><bold>7</bold></highlight>)) and MAD((<highlight><bold>0</bold></highlight>,<highlight><bold>4</bold></highlight>),(<highlight><bold>2</bold></highlight>,<highlight><bold>6</bold></highlight>)) to determine the lowest MAD value, MAD((<highlight><bold>1</bold></highlight>,<highlight><bold>5</bold></highlight>),(<highlight><bold>3</bold></highlight>,<highlight><bold>7</bold></highlight>),(<highlight><bold>0</bold></highlight>,<highlight><bold>4</bold></highlight>),(<highlight><bold>2</bold></highlight>,<highlight><bold>6</bold></highlight>)). </paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> In doing so, the one-pair packed-subtract unit <highlight><bold>334</bold></highlight> produces a single carry bit, which is indicative of the position of the lowest MAD value. This single carry bit is propagated to the one-pair packed-select unit <highlight><bold>336</bold></highlight>, which has the 32-bit result from the two-pair packed-select unit <highlight><bold>332</bold></highlight>, and, also, to the 7&times;3 code converter <highlight><bold>340</bold></highlight>. The one-pair packed-select unit <highlight><bold>336</bold></highlight> selects the lowest 16-bit result, and forwards the lowest 16-bit result to the result register <highlight><bold>350</bold></highlight> as BEST_MAD&lsqb;0:15&rsqb;. </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> At this point, the 7&times;3 code converter has received a total of seven carry bits (i.e., four carry bits from the four-pair packed-subtract unit <highlight><bold>314</bold></highlight>, two carry bits from the two-pair packed-subtract unit <highlight><bold>323</bold></highlight>, and a single carry bit from the one-pair packed-subtract unit <highlight><bold>336</bold></highlight>). The code converter <highlight><bold>340</bold></highlight> produces a three-bit number from the received seven carry bits. This three-bit number is indicative of the position of the lowest MAD value. The three-bit number is also stored in the result register <highlight><bold>350</bold></highlight>. </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> As shown from the system of <cross-reference target="DRAWINGS">FIGS. 3A and 3B</cross-reference>, the sequential narrowing of four 16-bit results, to two 16-bit results, to one 16-bit result may be seen as a binary search. Thus, if 2<highlight><superscript>n </superscript></highlight>MAD values are calculated from the processor <highlight><bold>100</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 1</cross-reference>), <highlight><bold>200</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 2</cross-reference>), then n packed-subtract units and n packed-select units would be employed in deriving the lowest MAD value. Also, a 2<highlight><superscript>n</superscript></highlight>&minus;1&times;n code converter would be employed as compared to the specific 7&times;3 code converter of <cross-reference target="DRAWINGS">FIG. 3B</cross-reference>. </paragraph>
<paragraph id="P-0074" lvl="0"><number>&lsqb;0074&rsqb;</number> Having described several embodiments of systems for computing multiple PSAD and lowest MAD values, attention is turned to <cross-reference target="DRAWINGS">FIGS. 4 through 6</cross-reference>, which show embodiments of methods for computing multiple PSAD and lowest MAD values. </paragraph>
<paragraph id="P-0075" lvl="0"><number>&lsqb;0075&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a flowchart <highlight><bold>400</bold></highlight> showing method steps in one embodiment of a method for performing multiple PSAD calculations in response to a single microprocessor instruction. As shown in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, one embodiment of the method begins with receiving, in step <highlight><bold>410</bold></highlight>, a single microprocessor instruction. Once the microprocessor instruction has been received <highlight><bold>410</bold></highlight>, multiple PSAD calculations are performed, in step <highlight><bold>420</bold></highlight>, in response to the single microprocessor instruction. In a preferred embodiment, the processor <highlight><bold>100</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 1</cross-reference> or the processor <highlight><bold>200</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 2</cross-reference> may be employed to perform the multiple PSAD calculations. Once the multiple PSAD calculations have been performed <highlight><bold>420</bold></highlight>, multiple MAD values are determined, in step <highlight><bold>425</bold></highlight>, and added, in step <highlight><bold>430</bold></highlight>, to an accumulation register. For multiple pixel lines, the adding step <highlight><bold>430</bold></highlight> may be seen as inserting MAD values for a first pixel line into the accumulation register, and then adding subsequent MAD values to the stored values in the accumulation register. Alternatively, the adding step <highlight><bold>430</bold></highlight> may be seen as loading an accumulation register with 0 prior to MAD calculations, and then simply adding calculated MAD values to the accumulation register. The adding step <highlight><bold>430</bold></highlight> is followed by a determining, in step <highlight><bold>435</bold></highlight>, of whether or not there are additional lines (e.g., pixel lines, data lines, etc.) of a macroblock for which MAD values should be calculated. If it is determined <highlight><bold>435</bold></highlight> that additional lines exist for MAD calculations, then the further multiple PSAD calculations are performed <highlight><bold>420</bold></highlight> for those additional lines. If, on the other hand, it is determined <highlight><bold>435</bold></highlight> that there are no additional lines for which a MAD value should be calculated, then a minimum MAD value is determined, in step <highlight><bold>440</bold></highlight>, using a binary search of the accumulation register. In a preferred embodiment, the system of <cross-reference target="DRAWINGS">FIGS. 3A and 3B</cross-reference> may be employed to determine <highlight><bold>440</bold></highlight> the &ldquo;best&rdquo; MAD value. </paragraph>
<paragraph id="P-0076" lvl="0"><number>&lsqb;0076&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5A</cross-reference> is a flowchart showing, in greater detail, method steps in one embodiment of the step of performing <highlight><bold>420</bold></highlight> the multiple PSAD calculation of <cross-reference target="DRAWINGS">FIG. 4</cross-reference>. As shown in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>A, once the microprocessor instruction has been received <highlight><bold>410</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 4</cross-reference>), a first operand having data elements is retrieved, in step <highlight><bold>510</bold></highlight>, and a second operand having data elements is further retrieved, in step <highlight><bold>520</bold></highlight>. In a preferred embodiment, these operands would be OP<highlight><bold>1</bold></highlight> <highlight><bold>110</bold></highlight> and OP<highlight><bold>2</bold></highlight> <highlight><bold>130</bold></highlight> as described with reference to <cross-reference target="DRAWINGS">FIGS. 1 and 2</cross-reference>. Once the operands have been retrieved <highlight><bold>510</bold></highlight>, <highlight><bold>520</bold></highlight>, a PSAD calculation is performed, in step <highlight><bold>530</bold></highlight>, using the data elements of the second operand and a first subset of data elements of the first operand. Additionally, the a PSAD calculation is performed, in step <highlight><bold>540</bold></highlight>, using the data elements of the second operand and a second subset of data elements of the first operand. In a preferred embodiment, the performing of the two PSAD calculations would occur substantially simultaneously as shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. However, in another embodiment, the performing of the two PSAD calculations may occur sequentially as shown in the <cross-reference target="DRAWINGS">FIG. 2</cross-reference>. Regardless of how the PSAD calculations are performed, the result of each of the calculations is output, in step <highlight><bold>550</bold></highlight>, to a destination register. In a preferred embodiment, the destination register is DOP&lsqb;0:128&rsqb; as shown in <cross-reference target="DRAWINGS">FIGS. 1 and 2</cross-reference>. </paragraph>
<paragraph id="P-0077" lvl="0"><number>&lsqb;0077&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5B</cross-reference> is a flowchart showing, in greater detail, method steps in another embodiment of the step of performing <highlight><bold>420</bold></highlight> the multiple PSAD calculation of <cross-reference target="DRAWINGS">FIG. 4</cross-reference>. Unlike <cross-reference target="DRAWINGS">FIG. 5</cross-reference>A, which shows only two parallel PSAD calculations, the embodiment of <cross-reference target="DRAWINGS">FIG. 5B</cross-reference> permits n parallel PSAD calculations. As described with reference to <cross-reference target="DRAWINGS">FIGS. 1 and 2</cross-reference>, it is convenient to choose n as a power of 2. As shown in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>B, once the microprocessor instruction has been received <highlight><bold>410</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 4</cross-reference>), a first operand having data elements is retrieved, in step <highlight><bold>510</bold></highlight>, and a second operand having data elements is retrieved, in step <highlight><bold>520</bold></highlight>. In a preferred embodiment, these operands would be OP<highlight><bold>1</bold></highlight> <highlight><bold>110</bold></highlight> and OP<highlight><bold>2</bold></highlight> <highlight><bold>130</bold></highlight> as described with reference to <cross-reference target="DRAWINGS">FIGS. 1 and 2</cross-reference>. Once the operands have been retrieved <highlight><bold>510</bold></highlight>, <highlight><bold>520</bold></highlight>, a PSAD calculation is performed, in step <highlight><bold>530</bold></highlight>, using the data elements of the second operand and a first subset of data elements of the first operand. Additionally, a PSAD calculation is performed, in step <highlight><bold>540</bold></highlight>, using the data elements of the second operand and a second subset of data elements of the first operand. Furthermore, a PSAD calculation is performed using a third subset of data elements of the first operand and so on, until all n PSAD calculations have been performed. In a preferred embodiment, n&equals;8, thereby permitting eight independent PSAD calculations on eight different subsets of data elements of the first operand. In a preferred embodiment, the n PSAD calculations would occur substantially simultaneously as shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. However, in another embodiment, the n PSAD calculations may occur sequentially as shown in the <cross-reference target="DRAWINGS">FIG. 2</cross-reference>. Regardless of how the PSAD calculations are performed, the result of each of the calculations is output, in step <highlight><bold>550</bold></highlight>, to a destination register. In a preferred embodiment, the destination register is DOP&lsqb;0:128&rsqb; as shown in <cross-reference target="DRAWINGS">FIGS. 1 and 2</cross-reference>. </paragraph>
<paragraph id="P-0078" lvl="0"><number>&lsqb;0078&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is a flowchart showing, in greater detail, method steps associated with the step of determining <highlight><bold>440</bold></highlight> the minimum MAD of <cross-reference target="DRAWINGS">FIG. 4</cross-reference>. As shown in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>, once the multiple MAD values have been determined <highlight><bold>425</bold></highlight>, one of the MAD values is compared, in step <highlight><bold>610</bold></highlight>, with another of the MAD values, and a smaller of the compared <highlight><bold>610</bold></highlight> MAD values is determined, in step <highlight><bold>620</bold></highlight>, and stored, in step <highlight><bold>630</bold></highlight>. Once the smaller MAD value has been stored <highlight><bold>630</bold></highlight>, it is determined, in step <highlight><bold>640</bold></highlight>, whether or not all MAD values have been compared (i.e., whether or not the smallest MAD value has been determined). If all MAD values have not been compared, then the steps repeat from step <highlight><bold>610</bold></highlight>, in which MAD values are further compared. If, however, all MAD values have been compared, then the stored smallest MAD value is output, in step <highlight><bold>650</bold></highlight>. In a preferred embodiment, the method steps of <cross-reference target="DRAWINGS">FIG. 6</cross-reference> may be executed using a system, such as the one described with reference to <cross-reference target="DRAWINGS">FIGS. 3A and 3B</cross-reference>. </paragraph>
<paragraph id="P-0079" lvl="0"><number>&lsqb;0079&rsqb;</number> The processor <highlight><bold>100</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 1</cross-reference>), <highlight><bold>200</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 2</cross-reference>), the PSAD execution units <highlight><bold>150</bold></highlight> (<cross-reference target="DRAWINGS">FIGS. 1 and 2</cross-reference>), and the pack unit <highlight><bold>160</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 1</cross-reference>) of the present invention can be implemented in hardware, software, firmware, or a combination thereof. In the preferred embodiment(s), the processor <highlight><bold>100</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 1</cross-reference>), <highlight><bold>200</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 2</cross-reference>), the PSAD execution units <highlight><bold>150</bold></highlight> (<cross-reference target="DRAWINGS">FIGS. 1 and 2</cross-reference>), and the pack unit <highlight><bold>160</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 1</cross-reference>) are implemented in hardware, and, hence, may be implemented with any or a combination of the following technologies: a discrete logic circuit(s) having logic gates for implementing logic functions upon data signals, an application specific integrated circuit (ASIC) having appropriate combinational logic gates, a programmable gate array(s) (PGA), a field programmable gate array (FPGA), etc. However, the processor <highlight><bold>100</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 1</cross-reference>), <highlight><bold>200</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 2</cross-reference>), the PSAD execution units <highlight><bold>150</bold></highlight> (<cross-reference target="DRAWINGS">FIGS. 1 and 2</cross-reference>), and the pack unit <highlight><bold>160</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 1</cross-reference>) may also be implemented in software or firmware, as in an alternative embodiment, which is stored in a memory and is executed by a suitable instruction execution system. </paragraph>
<paragraph id="P-0080" lvl="0"><number>&lsqb;0080&rsqb;</number> Any process descriptions or blocks in flow charts should be understood as representing modules, segments, or portions of code which include one or more executable instructions for implementing specific logical functions or steps in the process, and alternate implementations are included within the scope of the preferred embodiment of the present invention in which functions may be executed out of order from that shown or discussed, including substantially concurrently or in reverse order, depending on the functionality involved, as would be understood by those reasonably skilled in the art of the present invention. </paragraph>
<paragraph id="P-0081" lvl="0"><number>&lsqb;0081&rsqb;</number> Although an exemplary embodiment of the present invention has been shown and described, it will be apparent to those of ordinary skill in the art that a number of changes, modifications, or alterations to the invention as described may be made, none of which depart from the spirit of the present invention. All such changes, modifications, and alterations should therefore be seen as within the scope of the present invention. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">I claim: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A system comprising: 
<claim-text>a first register configured to store a first operand, wherein the first operand has data elements; </claim-text>
<claim-text>a second register configured to store a second operand, wherein the second operand has data elements; and </claim-text>
<claim-text>a processor configured to perform multiple packed-sum-absolute-difference (PSAD) calculations in response to a single instruction, wherein each of the multiple PSAD calculations is performed between the data elements of the second operand and different subsets of data elements of the first operand. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the first register is further configured to store a first operand having a number of data elements greater than the number of data elements of the second operand. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, wherein the number of data elements in each of the different subsets is equal to the number of data elements in the second operand. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference>, wherein each of the different subsets has overlapping elements with at least one other of the different subsets. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference>, wherein the elements of each of the different subsets occupy a contiguous portion of the first register. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the processor is configured to perform multiple PSAD calculations in parallel. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the first register is further configured to store a 128-bit first operand, wherein the second register is further configured to store a 64-bit second operand. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising a destination register configured to store a result of each of the multiple PSAD calculations. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. A system comprising: 
<claim-text>a first register configured to store a first operand, wherein the first operand has data elements; </claim-text>
<claim-text>a second register configured to store a second operand, wherein the second operand has data elements; and </claim-text>
<claim-text>a processor configured to perform multiple packed-sum-absolute-difference (PSAD) calculations in response to a single instruction, wherein at least one of the multiple PSAD calculations is performed on the data elements of the second operand and a first subset of data elements of the first operand. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, wherein the processor is further configured to perform multiple PSAD calculations on pixels of a video frame represented by the first operand. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein the processor is further configured to perform multiple PSAD calculations on pixels of a video frame represented by the second operand. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, wherein the processor is further configured to perform multiple PSAD calculations on pixels of a reference image represented by the first operand. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, wherein the processor is further configured to perform multiple PSAD calculations on pixels of an object image represented by the second operand. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, wherein the first register is further configured to store a first operand having a greater number of data elements than the number of data elements of the second operand. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference>, wherein the number of data elements in the first subset of data elements is equal to the number of data elements in the second operand. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference>, wherein the processor is configured to perform another of the multiple PSAD calculations on the data elements of the second operand and a second subset of data elements of the first operand. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, wherein elements of the first subset overlap with elements of the second subset. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, wherein the first register is further configured to store elements of the first subset in a first contiguous portion. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, wherein the first register is further configured to store a first contiguous portion having a sequential group of bytes. </claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00011">claim 18</dependent-claim-reference>, wherein the first register is further configured to store elements of the second subset in a second contiguous portion of the first register. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, wherein the processor is configured to perform the multiple PSAD calculations substantially in parallel. </claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, wherein the processor is configured to perform the multiple PSAD calculations substantially sequentially. </claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, wherein the first register is a 2<highlight><superscript>n</superscript></highlight>-bit register, wherein n is an integer value. </claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00022">claim 23</dependent-claim-reference>, wherein the second register is a 2<highlight><superscript>m</superscript></highlight>-bit register, wherein m is an integer value. </claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, wherein the first register is a 128-bit register and the second register is a 64-bit register. </claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, further comprising a destination register configured to store a result of each of the multiple PSAD calculations. </claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00022">claim 26</dependent-claim-reference>, wherein the processor is configured to store each of the results of each of the multiple PSAD calculations in non-overlapping contiguous portions of the destination register. </claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00022">claim 27</dependent-claim-reference>, wherein the processor is further configured to generate 16-bit results as a result of each of the multiple PSAD calculations. </claim-text>
</claim>
<claim id="CLM-00029">
<claim-text><highlight><bold>29</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00022">claim 28</dependent-claim-reference>, wherein the processor is further configured to determine multiple mean absolute difference (MAD) values from the multiple PSAD calculations. </claim-text>
</claim>
<claim id="CLM-00030">
<claim-text><highlight><bold>30</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00022">claim 29</dependent-claim-reference>, wherein the processor is further configured to determine a minimum MAD value from the multiple MAD values. </claim-text>
</claim>
<claim id="CLM-00031">
<claim-text><highlight><bold>31</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00033">claim 30</dependent-claim-reference>, wherein the processor is further configured to perform a binary search on the results of the multiple MAD calculations. </claim-text>
</claim>
<claim id="CLM-00032">
<claim-text><highlight><bold>32</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference>, wherein the processor is configured to recursively perform the multiple PSAD calculations in response to a single instruction. </claim-text>
</claim>
<claim id="CLM-00033">
<claim-text><highlight><bold>33</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00033">claim 32</dependent-claim-reference>, wherein the processor is further configured to receive a single instruction comprising: 
<claim-text>a starting address; and </claim-text>
<claim-text>a number of iterations. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00034">
<claim-text><highlight><bold>34</bold></highlight>. A system comprising: 
<claim-text>a first register configured to store a first operand, wherein the first operand has data elements; </claim-text>
<claim-text>a second register configured to store a second operand, wherein the second operand has data elements; </claim-text>
<claim-text>a processor configured to receive a single instruction and issue a command; and </claim-text>
<claim-text>dedicated hardware configured to receive the issued command from the processor, wherein the hardware is configured to perform multiple packed-sum-absolute-difference (PSAD) calculations in response to the issued command, wherein at least one of the multiple PSAD calculations is performed between the data elements of the second operand I<highlight><bold>1</bold></highlight> and a first subset of data elements of the first operand. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00035">
<claim-text><highlight><bold>35</bold></highlight>. A method comprising the steps of: 
<claim-text>receiving a single instruction; and </claim-text>
<claim-text>performing multiple packed-sum-absolute-difference (PSAD) calculations in response to the single instruction. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00036">
<claim-text><highlight><bold>36</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00033">claim 35</dependent-claim-reference>, wherein the step of performing multiple PSAD calculations comprises the steps of: 
<claim-text>retrieving a first operand having data elements in response to the receiving of the single instruction; and </claim-text>
<claim-text>retrieving a second operand having data elements in response to the receiving of the single instruction. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00037">
<claim-text><highlight><bold>37</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00033">claim 36</dependent-claim-reference>, wherein the step of performing multiple PSAD calculations further comprises the step of performing a PSAD calculation using the data elements of the second operand and a first subset of data elements of the first operand. </claim-text>
</claim>
<claim id="CLM-00038">
<claim-text><highlight><bold>38</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00033">claim 37</dependent-claim-reference>, wherein the step of performing multiple PSAD calculations further comprises the step of performing a PSAD calculation using the data elements of the second operand and a different subset of data elements of the first operand. </claim-text>
</claim>
<claim id="CLM-00039">
<claim-text><highlight><bold>39</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00033">claim 36</dependent-claim-reference>, wherein the step of performing multiple PSAD calculations further comprises the step of outputting a result in response to the performing of the multiple PSAD calculations. </claim-text>
</claim>
<claim id="CLM-00040">
<claim-text><highlight><bold>40</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00033">claim 35</dependent-claim-reference>, further comprising the step of determining multiple mean absolute difference (MAD) values from the multiple PSAD calculations. </claim-text>
</claim>
<claim id="CLM-00041">
<claim-text><highlight><bold>41</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00044">claim 40</dependent-claim-reference>, further comprising the step of determining a minimum calculated MAD value from the multiple MAD values. </claim-text>
</claim>
<claim id="CLM-00042">
<claim-text><highlight><bold>42</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00044">claim 41</dependent-claim-reference>, where in the step of determining a minimum calculated MAD value comprises the steps of performing a binary search on the multiple MAD values. </claim-text>
</claim>
<claim id="CLM-00043">
<claim-text><highlight><bold>43</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00044">claim 42</dependent-claim-reference>, wherein the step of performing a binary search comprises the steps of: 
<claim-text>comparing one of the multiple MAD values with another of the multiple MAD values; </claim-text>
<claim-text>evaluating which of the two MAD values is smaller; and </claim-text>
<claim-text>outputting the smaller of the two MAD values. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00044">
<claim-text><highlight><bold>44</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00033">claim 35</dependent-claim-reference>, further comprising the step of recursively performing multiple PSAD calculations in response to the single instruction. </claim-text>
</claim>
<claim id="CLM-00045">
<claim-text><highlight><bold>45</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00044">claim 44</dependent-claim-reference>, wherein the step of performing multiple PSAD calculations further comprises the step of receiving a single instruction having: 
<claim-text>a starting address; and </claim-text>
<claim-text>a number of iterations. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00046">
<claim-text><highlight><bold>46</bold></highlight>. A system comprising: 
<claim-text>means for receiving a single instruction; and </claim-text>
<claim-text>means for performing multiple packed-sum-absolute-difference (PSAD) calculations in response to the single instruction. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00047">
<claim-text><highlight><bold>47</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00044">claim 46</dependent-claim-reference>, wherein the means for performing multiple PSAD calculations comprises: 
<claim-text>means for retrieving a first operand having data elements in response to the receiving of the single instruction; and </claim-text>
<claim-text>means for retrieving a second operand having data elements in response to the receiving of the single instruction. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00048">
<claim-text><highlight><bold>48</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00044">claim 47</dependent-claim-reference>, wherein the means for performing multiple PSAD calculations further comprises means for performing a PSAD calculation using the data elements of the second operand and a first subset of data elements of the first operand. </claim-text>
</claim>
<claim id="CLM-00049">
<claim-text><highlight><bold>49</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00044">claim 48</dependent-claim-reference>, wherein the means for performing multiple PSAD calculations further comprises means for performing a PSAD calculation using the data elements of the second operand and a different subset of data elements of the first operand. </claim-text>
</claim>
<claim id="CLM-00050">
<claim-text><highlight><bold>50</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00044">claim 47</dependent-claim-reference>, wherein the means for performing multiple PSAD calculations further comprises means for outputting a result in response to the performing of the multiple PSAD calculations. </claim-text>
</claim>
<claim id="CLM-00051">
<claim-text><highlight><bold>51</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00044">claim 46</dependent-claim-reference>, further comprising means for determining multiple mean absolute difference (MAD) values from the multiple PSAD calculations. </claim-text>
</claim>
<claim id="CLM-00052">
<claim-text><highlight><bold>52</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00055">claim 51</dependent-claim-reference>, further comprising means for determining a minimum calculated MAD value from the multiple MAD values. </claim-text>
</claim>
<claim id="CLM-00053">
<claim-text><highlight><bold>53</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00055">claim 52</dependent-claim-reference>, wherein the means for determining a minimum calculated MAD value comprises means for performing a binary search on the multiple MAD values. </claim-text>
</claim>
<claim id="CLM-00054">
<claim-text><highlight><bold>54</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00055">claim 53</dependent-claim-reference>, wherein the means for performing a binary search comprises: 
<claim-text>means for comparing one of the multiple MAD values with another of the multiple MAD values; </claim-text>
<claim-text>means for evaluating which of the two MAD values is smaller; and </claim-text>
<claim-text>means for outputting the smaller of the two MAD values. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00055">
<claim-text><highlight><bold>55</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00044">claim 46</dependent-claim-reference>, further comprising means for recursively performing multiple PSAD calculations in response to the single instruction. </claim-text>
</claim>
<claim id="CLM-00056">
<claim-text><highlight><bold>56</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00055">claim 55</dependent-claim-reference>, wherein the means for performing the multiple PSAD calculations comprises means for receiving a single instruction having: 
<claim-text>a starting address; and </claim-text>
<claim-text>a number of iterations.</claim-text>
</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>1A</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005267A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005267A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005267A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005267A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005267A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005267A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030005267A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030005267A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030005267A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00009">
<image id="EMI-D00009" file="US20030005267A1-20030102-D00009.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00010">
<image id="EMI-D00010" file="US20030005267A1-20030102-D00010.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
