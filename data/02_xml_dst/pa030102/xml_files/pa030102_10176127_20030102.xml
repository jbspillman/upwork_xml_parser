<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030002603A1-20030102-M00001.NB SYSTEM "US20030002603A1-20030102-M00001.NB" NDATA NB>
<!ENTITY US20030002603A1-20030102-M00001.TIF SYSTEM "US20030002603A1-20030102-M00001.TIF" NDATA TIF>
<!ENTITY US20030002603A1-20030102-M00002.NB SYSTEM "US20030002603A1-20030102-M00002.NB" NDATA NB>
<!ENTITY US20030002603A1-20030102-M00002.TIF SYSTEM "US20030002603A1-20030102-M00002.TIF" NDATA TIF>
<!ENTITY US20030002603A1-20030102-M00003.NB SYSTEM "US20030002603A1-20030102-M00003.NB" NDATA NB>
<!ENTITY US20030002603A1-20030102-M00003.TIF SYSTEM "US20030002603A1-20030102-M00003.TIF" NDATA TIF>
<!ENTITY US20030002603A1-20030102-D00000.TIF SYSTEM "US20030002603A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030002603A1-20030102-D00001.TIF SYSTEM "US20030002603A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030002603A1-20030102-D00002.TIF SYSTEM "US20030002603A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030002603A1-20030102-D00003.TIF SYSTEM "US20030002603A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030002603A1-20030102-D00004.TIF SYSTEM "US20030002603A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030002603A1-20030102-D00005.TIF SYSTEM "US20030002603A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030002603A1-20030102-D00006.TIF SYSTEM "US20030002603A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030002603A1-20030102-D00007.TIF SYSTEM "US20030002603A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030002603A1-20030102-D00008.TIF SYSTEM "US20030002603A1-20030102-D00008.TIF" NDATA TIF>
<!ENTITY US20030002603A1-20030102-D00009.TIF SYSTEM "US20030002603A1-20030102-D00009.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030002603</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10176127</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20020621</filing-date>
</domestic-filing-data>
<foreign-priority-data>
<priority-application-number>
<doc-number>01404649.7</doc-number>
</priority-application-number>
<filing-date>20010621</filing-date>
<country-code>EP</country-code>
</foreign-priority-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>H03D001/00</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>375</class>
<subclass>341000</subclass>
</uspc>
</classification-us-primary>
<classification-us-secondary>
<uspc>
<class>714</class>
<subclass>795000</subclass>
</uspc>
</classification-us-secondary>
</classification-us>
<title-of-invention>Method and apparatus for decoding a bit sequence</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Alexander</given-name>
<family-name>Worm</family-name>
</name>
<residence>
<residence-non-us>
<city>Brussels</city>
<country-code>BE</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Heiko</given-name>
<family-name>Michel</family-name>
</name>
<residence>
<residence-non-us>
<city>Kaiserslautern</city>
<country-code>DE</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Norbert</given-name>
<family-name>Wehn</family-name>
</name>
<residence>
<residence-non-us>
<city>Queidersbach</city>
<country-code>DE</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<assignee>
<organization-name>ALCATEL</organization-name>
<assignee-type>03</assignee-type>
</assignee>
<correspondence-address>
<name-1>SUGHRUE MION, PLLC</name-1>
<name-2></name-2>
<address>
<address-1>2100 Pennsylvania Avenue, N.W.</address-1>
<city>Washington</city>
<state>DC</state>
<postalcode>20037-3213</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A method and apparatus are disclosed for decoding according to a Log-MAP algorithm, a bit sequence encoded by a convolutional encoder and received through a noisy channel. A digital signal processor (DSP) for performing the decoding is provided with an extended core possessing a transition metric calculation unit (<highlight><bold>153</bold></highlight>) for calculating transition metric values of the encoder trellis for output to a memory store (<highlight><bold>101,102</bold></highlight>) of the DSP, and for output to a unit (<highlight><bold>154</bold></highlight>) for performing a Log-MAP add-compare-select operation. The Log-MAP add-compare-select unit (<highlight><bold>154</bold></highlight>) calculates updated path metric values of the encoder trellis for storage in a memory store (<highlight><bold>101,102</bold></highlight>) of the DSP, and for input to a Log-Likelihood Ratio calculating unit (<highlight><bold>155</bold></highlight>). The Log-Likelihood Ratio calculating unit (<highlight><bold>155</bold></highlight>) calculates the Log-Likelihood Ratio of a given data bit to be decoded. Transition metric unit (<highlight><bold>153</bold></highlight>), Log-MAP add-compare-select unit (<highlight><bold>154</bold></highlight>), and Log-Likelihood Ratio calculating unit (<highlight><bold>155</bold></highlight>) are each controlled by the program control unit (<highlight><bold>104</bold></highlight>) of the DSP, and communicate with the data memories (<highlight><bold>101, 102</bold></highlight>) of the DSP, via data lines (<highlight><bold>150, 151, 152</bold></highlight>). </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> The present invention relates to a method and apparatus for decoding, according to a Log-MAP algorithm, a bit sequence encoded by a convolutional encoder and received through a noisy channel. </paragraph>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> A key demand on any communications system is to ensure that the information received by the system corresponds closely (exactly if possible) with the information originally transmitted to the system. Transmission errors, such as bit errors, are often unavoidably introduced into a communications system by noisy transmission channels etc. and, as a result of this, much effort has been expended on developing forward-error-correction (FEC) schemes. These schemes aim to correct errors in received signals by using information contained within the signal itself. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> FEC schemes generally aim to be sufficiently sophisticated to provide acceptably low bit error rates in error-corrected data, yet not be too complex or costly (in terms of reduced data-transmission rates) to implement in practice. A widely used FEC coding scheme is that of &ldquo;Turbo-Coding&rdquo; which is regarded by some commentators in the field of data coding as being the most powerful FEC coding scheme presently available. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> Turbo-Codes developed from the concepts of &ldquo;concatenated coding&rdquo; and &ldquo;iterative decoding&rdquo;, and the term &ldquo;Turbo-Codes&rdquo; better describes the iterative decoding step rather than the concatenated encoding step. Typically, the encoding step of Turbo-Codes involves the parallel concatenation of two convolutional codes, although serial (or hybrid) concatenation is also possible. In this arrangement, two convolutional encoders are arranged in parallel, both having the same data sequence as input, but with one of the two encoders operating upon that data only after it has been interleaved. The output of these encoders may then be combined with the original (un-coded) data sequence for transmission, thereby providing a &ldquo;systematic&rdquo; code sequence in which the data symbols from the input data sequence appear unchanged in the resulting output code sequence. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> Thus, the output code sequence comprises the original un-coded data and associated check-bits which can be used by a decoder to correct errors in the received code sequence. By concatenating the encoders in this way, a relatively complex code can be produced using relatively simple constituent encoders. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> Convolutional encoding is a well established encoding technique in which input data sequences are split into &ldquo;blocks&rdquo; of a predetermined length, each of which are independently encoded to produce a &ldquo;code block&rdquo; of check bits for the input data. In particular, convolutional encoding is performed by calculating the modulo-2 sum of a current input data-bit and one or more preceding input data-bits. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> Implementation of this encoding method may be by way of shift-registers and exclusive-OR gates as illustrated by the example Recursive Systematic Convolutional (RSC) encoder of <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. When the encoder receives an input bit at input <highlight><bold>1</bold></highlight>, the bit passes directly to the &ldquo;systematic&rdquo; output <highlight><bold>2</bold></highlight> and to the first of the three shift-registers <highlight><bold>3</bold></highlight> via one of the four exclusive-OR gates <highlight><bold>4</bold></highlight>, thereby causing a corresponding code bit (i.e. a check-bit) to be output at output <highlight><bold>5</bold></highlight> simultaneously with the systematic bit at output <highlight><bold>2</bold></highlight>. It will be noted that the output of the second and third shift-registers is also input (via exclusive-OR gates) to the first register via a &ldquo;recursive&rdquo; feed-back loop <highlight><bold>6</bold></highlight>. In this example, the provision of three shift-registers <highlight><bold>3</bold></highlight> provides a convolutional encoder with &ldquo;constraint length&rdquo; K&equals;4, meaning that the encoder output (check-bit) at a given time depends upon four encoder inputs, namely the present input and the three preceding ones (i.e. those stored in the three shift-registers <highlight><bold>3</bold></highlight>). </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> The behaviour of an encoder is conveniently represented by a &ldquo;code-trellis&rdquo; as illustrated in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, which corresponds to the RSC encoder of <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. Each column in the code-trellis corresponds to the input into the encoder of a new data block (in this case one bit) at the k<highlight><superscript>th </superscript></highlight>time-step, and the 2<highlight><superscript>K&minus;1</superscript></highlight>&equals;8 (K&equals;4) nodes of the trellis correspond to the possible states of the encoder at each such-time step (i.e. the contents of the K shift-registers <highlight><bold>3</bold></highlight>). The branches <highlight><bold>20</bold></highlight> joining adjacent nodes <highlight><bold>21</bold></highlight> represent possible ways in which the state of the encoder can change between time-steps k&minus;1 and k, as a result of the input thereto of a data &ldquo;one&rdquo; bit (solid lines) or a data &ldquo;zero&rdquo; bit (dashed lines). Accordingly, each node <highlight><bold>21</bold></highlight>, at a given time-step k&minus;1, is the source of two branches each branch joining that node to a respective one of two possible succeeding adjacent nodes at time-step k. Similarly, each node after the fourth time-step is also the terminus of two branches, each branch joining that node to a respective one of two possible preceding adjacent nodes. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> In this way a trellis of all possible transitions of the encoder is provided. The possible transitions depend upon the nature of the code (RSC code in this case), and any one path through the trellis represents one possible input data sequence and its corresponding output code sequence. It is this property which is used in decoding a given code sequence output by an encoder, when received at a decoder. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> The Viterbi algorithm is often employed to decode convolutional codes. Its objective is to find the path through the code-trellis that most closely resembles the received code sequence, processing one code block (i.e. time-step) at a time. The principle of the algorithm is to progressively build the most likely complete path by determining at each node (at a given time-step) the path to that node which corresponds with the code sequence which is closest to the received code sequence. Each such &ldquo;survivor&rdquo; path determined in this way is then extended by repeating the step for successive adjacent nodes in the trellis until the path can be extended no further. The best of the remaining &ldquo;survivor&rdquo; paths is then chosen as being the one most likely to represent the actual state transitions that the encoder made when encoding the data. Accordingly, an estimate of the data sequence input to the encoder can be obtained with knowledge of the encoder properties. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> Each branch of the trellis carries with it a &ldquo;branch metric&rdquo; representing the probability of the encoder having made the transition represented by that branch, given the received code sequence and channel side information and the encoder properties. Each survivor path also carries with it a &ldquo;path metric&rdquo; derived from the metrics of the constituent branches of that path. Thus, when each survivor path is extended from a given node by one branch, there is an associated branch metric calculation for each possible branch from that node, followed by an addition of each branch metric to the path metric of that node, followed by a comparison of the two resulting path metrics and then a final selection of which of the two is to be the survivor path. This add-compare-select (&ldquo;ACS&rdquo;) process must be repeated many times throughout the trellis when decoding a code sequence, and results in a very large number of operations having to be performed and extensive data storage requirements. Consequently, a number of &ldquo;acceleration&rdquo; schemes have been proposed in the art which aim to perform more efficiently the ACS process in a Viterbi decoding algorithm. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> An alternative decoding algorithm is the Logarithmic Maximum A Posteriori (Log-MAP) decoding algorithm. This decoding algorithm performs ACS operations, similar to those of the Viterbi algorithm, for each time-step in the trellis. In doing so the Log-MAP algorithm determines the most likely information bit to have been transmitted given a received code sequence which may be noisy or distorted. This is unlike the Viterbi decoding algorithm which determines the most likely transmitted code sequence (i.e. via the survivor path). </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> In general, a MAP decoder must ultimately select the most likely transmitted code sequence {right arrow over (x)}, given a received sequence {right arrow over (y)}, in a manner equivalent to maximizing the conditional probability:  
<math-cwu id="MATH-US-00001">
<number>1</number>
<math>
<mrow>
  <mrow>
    <mi>p</mi>
    <mo>&af;</mo>
    <mrow>
      <mo>(</mo>
      <mrow>
        <mover>
          <mi>x</mi>
          <mo>&RightArrow;</mo>
        </mover>
        <mo>&VerticalSeparator;</mo>
        <mover>
          <mi>y</mi>
          <mo>&RightArrow;</mo>
        </mover>
      </mrow>
      <mo>)</mo>
    </mrow>
  </mrow>
  <mo>=</mo>
  <mrow>
    <mfrac>
      <mrow>
        <mrow>
          <mi>p</mi>
          <mo>&af;</mo>
          <mrow>
            <mo>(</mo>
            <mrow>
              <mover>
                <mi>y</mi>
                <mo>&RightArrow;</mo>
              </mover>
              <mo>&VerticalSeparator;</mo>
              <mover>
                <mi>x</mi>
                <mo>&RightArrow;</mo>
              </mover>
            </mrow>
            <mo>)</mo>
          </mrow>
        </mrow>
        <mo>&it;</mo>
        <mrow>
          <mi>p</mi>
          <mo>&af;</mo>
          <mrow>
            <mo>(</mo>
            <mover>
              <mi>x</mi>
              <mo>&RightArrow;</mo>
            </mover>
            <mo>)</mo>
          </mrow>
        </mrow>
      </mrow>
      <mrow>
        <mi>p</mi>
        <mo>&af;</mo>
        <mrow>
          <mo>(</mo>
          <mover>
            <mi>y</mi>
            <mo>&RightArrow;</mo>
          </mover>
          <mo>)</mo>
        </mrow>
      </mrow>
    </mfrac>
    <mo>.</mo>
  </mrow>
</mrow>
</math>
<mathematica-file id="MATHEMATICA-00001" file="US20030002603A1-20030102-M00001.NB"/>
<image id="EMI-M00001" wi="216.027" he="22.08465" file="US20030002603A1-20030102-M00001.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> This is the &ldquo;maximum a posteriori&rdquo; (MAP) criterion. The quantities p({right arrow over (y)}) and p({right arrow over (x)}) are assumed constant, hence the MAP criterion amounts to maximizing p({right arrow over (y)}&verbar;{right arrow over (x)}). </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> In &ldquo;hard decision&rdquo; coding, the MAP criterion is satisfied using only the received sequence {right arrow over (y)}, unchanged. In &ldquo;soft decision&rdquo; coding, information regarding the reliability or &ldquo;likelihood&rdquo; of the bit values in {right arrow over (y)} is generated also. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> The Log-MAP algorithm quantifies this soft information in terms of &ldquo;Log-Likelihood Ratios&rdquo; (LLR) to represent, in the log domain, the degree of certainty of specific decoded bits at the output of a decoder and is used in iterative decoding of Turbo-codes. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> The Log-MAP algorithm operates in the logarithmic domain in order to compress the large range of numerical values encountered and also to turn multiplication into simple additions etc. Thus, the Log-MAP algorithm utilises more of the information available during decoding so as to increase decoding efficiency since unreliable bit decisions can be corrected if required. More importantly, the Log-MAP decoding algorithm inherently provides &ldquo;soft&rdquo; decision information which can be effectively used in decoding concatenated codes. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> Although the Viterbi decoding algorithm may be adapted to provide soft information for this purpose, such information is widely regarded as being inferior to that provided by the Log-MAP decoding algorithm. This limitation is especially important when employing Turbo-Codes which rely on an iterative decoding scheme which employs soft information. Hence, the higher quality of soft information provided by the Log-MAP decoding algorithm renders it well suited to applications involving Turbo-Codes. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> Consequently, it is generally desirable to increase the efficiency of the Log-MAP algorithm in its application to Turbo-Coding. However, in contrast to the Viterbi algorithm, current digital signal processors do not provide any specific acceleration schemes for the Log-MAP algorithm. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> Thus, it is an aim of the present invention to overcome this general deficiency in the prior art at least by exploiting the structure of the trellis associated with a Log-MAP encoder. In particular, in the trellis of a binary convolutional encoder, the transitions between neighbouring states can be segregated into disjoint groups of four each originating in a concurrent pair of states and terminating in another concurrent pair. The structure produced by these four states is known as a trellis &ldquo;butterfly&rdquo;. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> At its most general, the present invention proposes to accelerate the operation of a Log-MAP decoding algorithm by at least performing each step of an Add-Compare-Select (ACS) operation in respect of one state of one concurrent pair of states of a trellis butterfly in parallel with each corresponding step of an Add-Compare-Select operation in respect of the other state of the one concurrent pair of states. The ACS operation may form part of a path metric update or part of a Log-Likelihood Ratio calculation. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> In parallel processing in this way, each one of the two ACS operations performed on the two concurrent states of a pair of butterfly states utilize the same data quantities, namely the same set of path metric values and the same two possible transition metric values between the two concurrent pairs of states of the butterfly. Thus, according to the present invention, the operation of the Log-MAP decoding algorithm may be accelerated at least through approximately halving the data retrieval requirements of the operation. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> Accordingly, in a first aspect of the present invention there may be provided a method for calculating path metric values of a convolutional encoder for use in decoding according to a Log-MAP algorithm a bit sequence encoded thereby and received through a noisy channel, the method comprising the steps of: </paragraph>
<paragraph id="P-0024" lvl="2"><number>&lsqb;0024&rsqb;</number> (i) adding to the path metric value associated with a first encoder state a first transition metric value associated with the transition of said encoder from said first encoder state to a first adjacent encoder state thereby providing a first path metric value for said first adjacent encoder state; </paragraph>
<paragraph id="P-0025" lvl="2"><number>&lsqb;0025&rsqb;</number> (ii) substantially simultaneously with step (i) adding to the path metric value associated with a second encoder state concurrent with said first state a second transition metric value associated with the transition of said encoder from said second encoder state to said first adjacent encoder state thereby providing a second path metric value for said first adjacent encoder state; </paragraph>
<paragraph id="P-0026" lvl="2"><number>&lsqb;0026&rsqb;</number> (iii) comparing said first path metric value for said first adjacent encoder state to said second path metric value therefor and selecting the maximum of the two to be the path metric value associated with that adjacent encoder state; </paragraph>
<paragraph id="P-0027" lvl="2"><number>&lsqb;0027&rsqb;</number> (iv) adding to the path metric value associated with said first encoder state said second transition metric value associated with the transition of said encoder from said first encoder state to a second adjacent encoder state concurrent with said first adjacent encoder state thereby providing a first path metric value for said second adjacent encoder state; </paragraph>
<paragraph id="P-0028" lvl="2"><number>&lsqb;0028&rsqb;</number> (v) substantially simultaneously with step (iv) adding to the path metric value associated with said second encoder state said second transition metric value associated with the transition of said encoder from said second encoder state to said second adjacent encoder state thereby providing a second path metric value for said second adjacent encoder state; </paragraph>
<paragraph id="P-0029" lvl="2"><number>&lsqb;0029&rsqb;</number> (vi) comparing said first path metric values for said second adjacent encoder state to said second path metric value therefore and selecting the maximum of the two to be the path metric value associated with that adjacent encoder state; </paragraph>
<paragraph id="P-0030" lvl="7"><number>&lsqb;0030&rsqb;</number> wherein said encoder states and said adjacent encoder states define a trellis butterfly and the sequence of steps (i), (ii) and (iii) are performed substantially simultaneously with the sequence of steps (iv), (v) and (vi) respectively. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> Preferably, the method includes the step of adding the correction term</paragraph>
<paragraph lvl="0"><in-line-formula>ln(1&plus;exp(&minus;&Dgr;))</in-line-formula></paragraph>
<paragraph id="P-0032" lvl="7"><number>&lsqb;0032&rsqb;</number> to the selected path metric value associated with a given adjacent encoder state, where &Dgr; is the absolute value of the difference between said first path metric value of said given adjacent encoder state and said second path metric value thereof. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> Thus, an accelerated Log-MAP Add-Compare-Select operation (LM_ACS) is provided. The LM_ACS operation requires two path metric values and two branch metric values to process a trellis butterfly. The result of the operation is the simultaneous production of two updated path matrices. The use of the correction term may improve the accuracy of the path metric values obtained according to the LM_ACS operation. This correction factor, when added to the selected maximum value of the two quantities defining &Dgr;, results in the Jacobian logarithm of these two quantities, of which the selected maximum value is only an approximation (i.e. ln(e<highlight><superscript>a</superscript></highlight>&plus;e<highlight><superscript>b</superscript></highlight>)&equals;max(a,b)&plus;ln(1&plus;e<highlight><superscript>&minus;&Dgr;</superscript></highlight>),&Dgr;&equals;&verbar;a&minus;b&verbar;). </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> The above steps (i) to (vi) may be repeated for all other concurrent trellis butterflies. Thus, each complete path metric update at a given trellis time-step may be mapped onto an m-fold execution of the LM_ACS operation for a trellis having m butterflies per time-step. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> The path metric values for all of said encoder states and said adjacent encoder states may be forward path metrics calculated by forward recursion wherein all of said adjacent encoder states succeed all of said encoder states. Alternatively, the path metric values for all of said encoder states and said adjacent encoder states may be backward path metrics calculated by backward recursion wherein all of said adjacent encoder states precede all of said encoder states. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> Therefore, both forward and backward path metric updating may be performed using the LM_ACS operation. This is particularly advantageous in calculating Log-Likelihood Ratios (LLR) which require both. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> According to a second aspect of the present invention, there may be provided a method for calculating Log-Likelihood Ratio values for state transitions of a convolutional encoder for use in decoding according to a Log-MAP algorithm a bit sequence encoded thereby and received through a noisy channel, the method comprising the steps (i) to (iii) which are performed in respect of only those transitions corresponding with a parity bit of a first value, and steps (iv) to (vi) which are performed in respect of only those transitions corresponding with a parity bit of a second value: </paragraph>
<paragraph id="P-0038" lvl="2"><number>&lsqb;0038&rsqb;</number> (i) adding to the forward path metric value associated with a first encoder state of a given trellis butterfly; a first transition metric value associated with the forward transition of said encoder from said first encoder state to a first adjacent encoder state of said butterfly; and, the backward path metric value associated with said first adjacent encoder state to provide a first sum; </paragraph>
<paragraph id="P-0039" lvl="2"><number>&lsqb;0039&rsqb;</number> (ii) substantially simultaneously with step (i) adding to the forward path metric value associated with a second encoder state of said trellis butterfly concurrent with said first state; said first transition metric value associated with the forward transition of said encoder from said second encoder state to a second adjacent encoder state of said butterfly concurrent with said first adjacent encoder state; and, the backward path metric value associated with said second adjacent encoder state to provide a second sum; </paragraph>
<paragraph id="P-0040" lvl="2"><number>&lsqb;0040&rsqb;</number> (iii) comparing said first sum and said second sum and selecting the maximum value of the two to be a first maximum value; </paragraph>
<paragraph id="P-0041" lvl="2"><number>&lsqb;0041&rsqb;</number> (iv) adding to the forward path metric value associated with said second encoder state; a second transition metric value associated with the forward transition of said encoder from said second encoder state to said first adjacent encoder state; and, the backward path metric value associated with said first adjacent encoder state to provide a third sum; </paragraph>
<paragraph id="P-0042" lvl="2"><number>&lsqb;0042&rsqb;</number> (v) substantially simultaneously with step (iv) adding to the forward path metric value associated with said first encoder state; said second transition metric value associated with the forward transition of said encoder from said first encoder state to said second adjacent encoder state; and, the backward path metric value associated with said second adjacent encoder state to provide a fourth sum; </paragraph>
<paragraph id="P-0043" lvl="2"><number>&lsqb;0043&rsqb;</number> (vi) comparing said third sum and said fourth sum and selecting the maximum value of the two to be a second maximum value; </paragraph>
<paragraph id="P-0044" lvl="7"><number>&lsqb;0044&rsqb;</number> whereby the sequence of steps (i), (ii) and (iii) is performed substantially simultaneously with the sequence of steps (iv), (v) and (vi) respectively and steps (i) to (vi) are repeated for the encoder states of all other concurrent trellis butterflies to provide a set of first maximum values and a set of second maximum values, and the maximum element of said set of second maximum values is subtracted from the maximum element of said set of first maximum values to provide a Log-Likelihood Ratio. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> Thus, it will be appreciated that steps (i) to (vi) of this second aspect of the present invention employ an extension of the LM_ACS operation according to the first aspect of the invention. In particular, the &ldquo;Add&rdquo; component of the LM_ACS operation is here extended from being the addition of two quantities (e.g. path metric&plus;transition metric to the same one state) to the addition of three quantities (i.e. forward path metric&plus;transition metric to different states&plus;backward path metric). Accordingly, this extended LM_ACS operation requires two forward path metric values, two transition metric values and two backward path metric values to process a trellis butterfly. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> In accordance with the second of its aspects, the invention preferably may provide a method for calculating LLR values wherein the maximum element of said set of second maximum values is subtracted from the maximum element of said set of first maximum values according to the steps of: </paragraph>
<paragraph id="P-0047" lvl="2"><number>&lsqb;0047&rsqb;</number> (i) choosing two elements from said set of first maximum values, comparing said two elements and selecting the maximum value of the two to be an element in a successive set of first maximum values; </paragraph>
<paragraph id="P-0048" lvl="2"><number>&lsqb;0048&rsqb;</number> (ii) substantially simultaneously with step (i) choosing two elements from said set of second maximum values, comparing said two elements and selecting the maximum value of the two to be an element in a successive set of second maximum values; </paragraph>
<paragraph id="P-0049" lvl="2"><number>&lsqb;0049&rsqb;</number> (iii) repeating steps (i) and (ii) in respect of all previously unchosen elements of said sets of first and second maximum values until all elements of each have been so selected; </paragraph>
<paragraph id="P-0050" lvl="2"><number>&lsqb;0050&rsqb;</number> (iv) repeating steps (i) to (iii) in respect of each successive set of first and second maximum values until each said successive set ultimately comprises only one element; </paragraph>
<paragraph id="P-0051" lvl="2"><number>&lsqb;0051&rsqb;</number> (v) subtracting the value of the one element of said ultimate successive set of first maximum values from that of the one element of said ultimate successive set of second maximum values so as to provide a Log-Likelihood Ratio. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> Thus, the calculation of the Log-Likelihood Ratio (LLR) for a given encoder transition (time step within the encoder trellis) may be further accelerated by performing in parallel the processing of date produced by the extended LM_ACS operation, thus providing an accelerated LLR (LLR_ACC) operation. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> Preferably, in the invention according to its second aspect, the correction term:</paragraph>
<paragraph lvl="0"><in-line-formula>ln(1&plus;exp(&minus;&Dgr;))</in-line-formula></paragraph>
<paragraph id="P-0054" lvl="7"><number>&lsqb;0054&rsqb;</number> is added to any quantity selected as being the maximum of two quantities compared for that purpose, where &Dgr; is the absolute value of the difference between said quantities compared. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> This correction factor, when added to the selected maximum value of the two quantities defining &Dgr;, results in the Jacobian logarithm of these two quantities, of which the selected maximum value is only an approximate. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> In method for calculating LLRs according to the second aspect of the invention, the forward path metric values may be calculated according to a method comprising the steps of: </paragraph>
<paragraph id="P-0057" lvl="2"><number>&lsqb;0057&rsqb;</number> (i) adding to the path metric value associated with a first encoder state a first transition metric value associated with the transition of said encoder from said first encoder state to a first adjacent encoder state thereby providing a first path metric value for said first adjacent encoder state; </paragraph>
<paragraph id="P-0058" lvl="2"><number>&lsqb;0058&rsqb;</number> (ii) substantially simultaneously with step (i) adding to the path metric value associated with a second encoder state concurrent with said first state a second transition metric value associated with the transition of said encoder from said second encoder state to said first adjacent encoder state thereby providing a second path metric value for said first adjacent encoder state; </paragraph>
<paragraph id="P-0059" lvl="2"><number>&lsqb;0059&rsqb;</number> (iii) comparing said first path metric value for said first adjacent encoder state to said second path metric value therefore and selecting the maximum of the two to be the path metric value associated with that adjacent encoder state; </paragraph>
<paragraph id="P-0060" lvl="2"><number>&lsqb;0060&rsqb;</number> (iv) adding to the path metric value associated with said first encoder state said second transition metric value associated with the transition of said encoder from said first encoder state to a second adjacent encoder state concurrent with said first adjacent encoder state thereby providing a first path metric value for said second adjacent encoder state; </paragraph>
<paragraph id="P-0061" lvl="2"><number>&lsqb;0061&rsqb;</number> (v) substantially simultaneously with step (iv) adding to the path metric value associated with said second encoder state said second transition metric value associated with the transition of said encoder from said second encoder state to said second adjacent encoder state thereby providing a second path metric value for said second adjacent encoder state; </paragraph>
<paragraph id="P-0062" lvl="2"><number>&lsqb;0062&rsqb;</number> (vi) comparing said first path metric values for said second adjacent encoder state to said second path metric value therefore and selecting the maximum of the two to be the path metric value associated with that adjacent encoder state; </paragraph>
<paragraph id="P-0063" lvl="7"><number>&lsqb;0063&rsqb;</number> wherein the path metric values for all of said encoder states and said adjacent encoder states are forward path metrics calculated by forward recursion such that all of said adjacent encoder states succeed all of said encoder states, and the sequence of steps (i), (ii) and (iii) are performed substantially simultaneously with the sequence of steps (iv), (v) and (vi) respectively. </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> Thus, it will be appreciated that the forward path metrics used in the calculation of the LLR values may be determined in the LM_ACS operation. </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> Similarly, in the method for calculating LLRs according to the second aspect of the invention, the backward path metric values may be calculated according to a method comprising the steps of: </paragraph>
<paragraph id="P-0066" lvl="2"><number>&lsqb;0066&rsqb;</number> (i) adding to the path metric value associated with a first encoder state a first transition metric value associated with the transition of said encoder from said first encoder state to a first adjacent encoder state thereby providing a first path metric value for said first adjacent encoder state; </paragraph>
<paragraph id="P-0067" lvl="2"><number>&lsqb;0067&rsqb;</number> (ii) substantially simultaneously with step (i) adding to the path metric value associated with a second encoder state concurrent with said first state a second transition metric value associated with the transition of said encoder from said second encoder state to said first adjacent encoder state thereby providing a second path metric value for said first adjacent encoder state; </paragraph>
<paragraph id="P-0068" lvl="2"><number>&lsqb;0068&rsqb;</number> (iii) comparing said first path metric value for said first adjacent encoder state to said second path metric value therefore and selecting the maximum of the two to be the path metric value associated with that adjacent encoder state; </paragraph>
<paragraph id="P-0069" lvl="2"><number>&lsqb;0069&rsqb;</number> (iv) adding to the path metric value associated with said first encoder state said second transition metric value associated with the transition of said encoder from said first encoder state to a second adjacent encoder state concurrent with said first adjacent encoder state thereby providing a first path metric value for said second adjacent encoder state; </paragraph>
<paragraph id="P-0070" lvl="2"><number>&lsqb;0070&rsqb;</number> (v) substantially simultaneously with step (iv) adding to the path metric value associated with said second encoder state said second transition metric value associated with the transition of said encoder from said second encoder state to said second adjacent encoder state thereby providing a second path metric value for said second adjacent encoder state; </paragraph>
<paragraph id="P-0071" lvl="2"><number>&lsqb;0071&rsqb;</number> (vi) comparing said first path metric values for said second adjacent encoder state to said second path metric value therefore and selecting the maximum of the two to be the path metric value associated with that adjacent encoder state; </paragraph>
<paragraph id="P-0072" lvl="7"><number>&lsqb;0072&rsqb;</number> wherein the path metric values for all of said encoder states and said adjacent encoder states are backward path metrics calculated by backward recursion wherein all of said adjacent encoder states precede all of said encoder states, and the sequence of steps (i), (ii) and (iii) are performed substantially simultaneously with the sequence of steps (iv), (v) and (vi) respectively. </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> Thus, it will be appreciated that the backward path metrics used in the calculation of the LLR values may be determined in the LM_ACS operation. </paragraph>
<paragraph id="P-0074" lvl="0"><number>&lsqb;0074&rsqb;</number> Preferably, in the method according to the second aspect of the present invention the first value of parity bits output from said encoder is &plus;1 and said second value thereof is &minus;1. However, the first and second values may be other than &plus;1 and &minus;1 respectively, they need only differ. </paragraph>
<paragraph id="P-0075" lvl="0"><number>&lsqb;0075&rsqb;</number> In accordance with any-aspect of the present invention, there may be provided a method for calculating transition metric values (&ggr;) for use in decoding wherein: </paragraph>
<paragraph id="P-0076" lvl="2"><number>&lsqb;0076&rsqb;</number> (i) the encoder transition associated with the output therefrom of a systematic and a parity bit of values &minus;1 and &minus;1 respectively is assigned a first transition metric value of</paragraph>
<paragraph lvl="0"><in-line-formula>&ggr;(&minus;1,&minus;1)&equals;0;</in-line-formula></paragraph>
<paragraph id="P-0077" lvl="2"><number>&lsqb;0077&rsqb;</number> (ii) the encoder transition associated with the output therefrom of a systematic and a parity bit of values &minus;1 and &plus;1 respectively is assigned a second transition metric value of</paragraph>
<paragraph lvl="0"><in-line-formula>&ggr;(&minus;1,&plus;1)&equals;s<highlight><bold>1</bold></highlight>;</in-line-formula></paragraph>
<paragraph id="P-0078" lvl="2"><number>&lsqb;0078&rsqb;</number> (iii) the encoder transition associated with the output therefrom of a systematic and a parity bit of values &plus;1 and &minus;1 respectively is assigned a third transition metric value</paragraph>
<paragraph lvl="0"><in-line-formula>&ggr;(&plus;1,&minus;1)&equals;s<highlight><bold>2</bold></highlight>;</in-line-formula></paragraph>
<paragraph id="P-0079" lvl="2"><number>&lsqb;0079&rsqb;</number> (iv) the encoder transition associated with the output therefrom of a systematic and a parity bit of values &plus;1 and &plus;1 respectively is assigned a transition metric value &ggr;(&plus;1,&plus;1) equal to the sum of said first and second transition metric values; </paragraph>
<paragraph id="P-0080" lvl="7"><number>&lsqb;0080&rsqb;</number> where the terms s<highlight><bold>1</bold></highlight> and s<highlight><bold>2</bold></highlight> are dependent on the signal-to-noise ratio associated with the received bit sequence, the received parity and systematic bits corresponding with the bits output from the encoder, and at least an estimate of the a priori probability of the encoder transition. </paragraph>
<paragraph id="P-0081" lvl="0"><number>&lsqb;0081&rsqb;</number> Thus, it will be appreciated that calculation of the four possible transition metric values is substantially simplified in only requiring two terms to be calculated (i.e. s<highlight><bold>1</bold></highlight> and s<highlight><bold>2</bold></highlight>). Preferably, s<highlight><bold>1</bold></highlight>&equals;4&middot;SNR&middot;y<highlight><subscript>k</subscript></highlight><highlight><superscript>p </superscript></highlight>and s<highlight><bold>2</bold></highlight>&equals;4&middot;SNR&middot;y<highlight><subscript>k</subscript></highlight><highlight><superscript>s</superscript></highlight>&plus;z<highlight><subscript>k</subscript></highlight>., where SNR is the signal-to-noise ratio associated with the received bit sequence, Y<highlight><subscript>k</subscript></highlight><highlight><superscript>p </superscript></highlight>and Y<highlight><subscript>k</subscript></highlight><highlight><superscript>s </superscript></highlight>are received parity and systematic bits, and Z<highlight><subscript>k </subscript></highlight>is at least an estimate of the a priori probability of the encoder transition at time step k respectively. </paragraph>
<paragraph id="P-0082" lvl="0"><number>&lsqb;0082&rsqb;</number> The present invention also proposes a digital signal processor (DSP) for accelerating the operation of a Log-MAP decoding algorithm by at least performing each step of an Add-Compare-Select (ACS) operation in respect of one state of one concurrent pair of states of a trellis butterfly in parallel with each corresponding step of an Add-Compare-Select operation in respect of the other state of the one concurrent pair of states, in accordance with any of the methods described above. The ACS operation may form part of a path metric update or part of a Log-Likelihood Ratio calculation. </paragraph>
<paragraph id="P-0083" lvl="0"><number>&lsqb;0083&rsqb;</number> Thus, the invention may provide a digital signal processor for calculating path metric values of a convolutional encoder for use in decoding, according to a Log-MAP algorithm, a bit sequence encoded thereby and received through a noisy channel, the processor comprising: </paragraph>
<paragraph id="P-0084" lvl="2"><number>&lsqb;0084&rsqb;</number> a transition metric calculating unit for receiving from a memory store of the digital signal processor data concerning said bit sequence, for calculating transition metric values representing transitions between states of a convolutional encoder, and for outputting those calculated metric values; </paragraph>
<paragraph id="P-0085" lvl="2"><number>&lsqb;0085&rsqb;</number> an Add-Compare-Select unit for receiving said calculated transition metric values, for receiving path metric values derived from said calculated transition metric values, for deriving updated path metric values from said path metric values and said transition metric values, and for outputting these updated path metric values wherein the updated path metric values are derived in accordance with the method of the first aspect of the invention. </paragraph>
<paragraph id="P-0086" lvl="0"><number>&lsqb;0086&rsqb;</number> Thus, the DSP provides updated path metric values, either forward or backward, for use in decoding a bit sequence. It will be appreciated that the ACS unit of the DPS may be employed not only to update forward or backward path metric values by adding these to successive transition metric values in accordance with the first aspect of the present invention, but the ACS unit may also be employed in calculating updated path metric and LLR values in accordance with the second aspect of the invention. </paragraph>
<paragraph id="P-0087" lvl="0"><number>&lsqb;0087&rsqb;</number> Preferably, the transition metric calculating unit employs the method of calculating transition metric values (&ggr;) described above. The transition metric calculating unit may output calculated transition metric values to a memory store of the DSP to which the ACS unit is also connected for the purposes of receiving transition metric values therefrom. The ACS unit preferably receives path metric values and transition metric values from the memory store of the DSP, and outputs updated path metric values thereto for storage in that memory store. </paragraph>
<paragraph id="P-0088" lvl="0"><number>&lsqb;0088&rsqb;</number> A transition metric cache may be provided in the DSP into which the metric calculating unit outputs and stores the calculated transition metrics associated with a given time step of the encoder trellis being decoded, and the ACS unit may receive those transition metric values from the transition metric cache for use in deriving updated path metric values. </paragraph>
<paragraph id="P-0089" lvl="0"><number>&lsqb;0089&rsqb;</number> Thus, since for each trellis time step, only four transition metric values are required in order to process each of the concurrent butterflies of the time step, by storing the four values in a temporary cache store the need to repeatedly retrieve the values from the main memory store of the DSP is obviated. This helps to increase the efficiency of the signal processor. </paragraph>
<paragraph id="P-0090" lvl="0"><number>&lsqb;0090&rsqb;</number> Preferably the ACS unit of the DSP comprises: </paragraph>
<paragraph id="P-0091" lvl="2"><number>&lsqb;0091&rsqb;</number> a calculation unit having a number of data input ports, two data output ports; </paragraph>
<paragraph id="P-0092" lvl="2"><number>&lsqb;0092&rsqb;</number> wherein the calculation unit is operable to add path metric values to transition metric data values concurrently received at the data input ports thereof to provide two concurrent pairs of updated path metric values, to compare within each concurrent pair said updated path metric values and to output at said two data output ports thereof the maximum path metric value of each concurrent pair. </paragraph>
<paragraph id="P-0093" lvl="0"><number>&lsqb;0093&rsqb;</number> Thus, the ACS unit may update either forward or backward path metrics in accordance with the first aspect of the invention or with the second aspect when employed in calculating LLRs. The calculation unit may have a first data input port for receiving path metric data values, a second data input port for receiving transition metric data values, a third data input port for receiving path metric data values, and a fourth data input port for receiving transition metric data values. </paragraph>
<paragraph id="P-0094" lvl="0"><number>&lsqb;0094&rsqb;</number> The ACS unit may have function-selection apparatus which permits the function of the ACS to be that of producing updated forward or backward path metrics in accordance with the first aspect of the invention, or to be that of producing the elements of the first and second sets of maximum values for use in calculating LLRs in accordance with the second aspect of the invention. </paragraph>
<paragraph id="P-0095" lvl="0"><number>&lsqb;0095&rsqb;</number> The function-selection apparatus preferably comprises: </paragraph>
<paragraph id="P-0096" lvl="2"><number>&lsqb;0096&rsqb;</number> a first data input gate connected in-between the two data output ports of the calculation unit and two feedback data input ports of the calculation unit of the ACS unit; </paragraph>
<paragraph id="P-0097" lvl="2"><number>&lsqb;0097&rsqb;</number> a second data input gate connected to the second and fourth data input ports of the calculation unit and to a fifth data input port thereof; </paragraph>
<paragraph id="P-0098" lvl="2"><number>&lsqb;0098&rsqb;</number> a third data input gate connected to the second and fourth data input ports of the calculation unit and to a sixth data input port thereof; </paragraph>
<paragraph id="P-0099" lvl="2"><number>&lsqb;0099&rsqb;</number> wherein the function-selection apparatus is operable to select the data values to be input to the feedback data input ports, and the fifth and sixth data input ports of the calculation unit. </paragraph>
<paragraph id="P-0100" lvl="0"><number>&lsqb;0100&rsqb;</number> The input-selection apparatus preferably has two selection states, each of which determine the function of the ACS unit. </paragraph>
<paragraph id="P-0101" lvl="0"><number>&lsqb;0101&rsqb;</number> Preferably in a first selection state of the function selection apparatus, the first data input gate blocks data output from the calculation unit and causes data input at the two feedback data input ports thereof to have a value of zero, while concurrently the second data input gate causes transition metric data input at the fourth input port of the calculation unit to be simultaneously input at the fifth data input thereof, and concurrently the third data input gate causes transition metric data input at the second input port of the calculation unit to be simultaneously input at the sixth data input port thereof. </paragraph>
<paragraph id="P-0102" lvl="0"><number>&lsqb;0102&rsqb;</number> Thus, in this first selection state, the input selection apparatus may cause the ACS unit to function so as to update path metric values in accordance with the first aspect of the present invention since for each adder means the two transition metric values simultaneously input thereto represent different transition metrics. </paragraph>
<paragraph id="P-0103" lvl="0"><number>&lsqb;0103&rsqb;</number> In a second selection state of the function selection apparatus, the first data input gate preferably permits data to pass from the outputs of the calculation unit to the two feedback data input ports thereof, while concurrently the second data input gate causes transition metric data input at the second input port of the calculation unit to be simultaneously input at the fifth data input thereof, and concurrently the third data input gate causes transition metric data input at the fourth input port of the calculation unit to be simultaneously input at the sixth data input port thereof. </paragraph>
<paragraph id="P-0104" lvl="0"><number>&lsqb;0104&rsqb;</number> Hence, in its second selection state, the input selection apparatus permits the ACS unit to function so as to calculate the elements of the sets of first and second maximum values for use in LLR calculations according to the second aspect of the present invention. That is to say, the two path metric values simultaneously input to any one adder means are made to be the same path metric and are input concurrently with backward path metric values. </paragraph>
<paragraph id="P-0105" lvl="0"><number>&lsqb;0105&rsqb;</number> The DSP is preferably provided with a Log-Likelihood Ratio unit for calculating LLR values from the set of first maximum values and the set of second maximum values in accordance with the LLR acceleration (LLR_ACC) methods derived above relating to the second aspect of the present invention, and for outputting calculated LLRs to the memory store of the DSP. The Log-Likelihood Ratio unit is preferably connected to the cache apparatus such as to be able to retrieve any data elements of the sets of first maximum values and second maximum values when stored therein, and to be able to store therein elements of successive sets of first and second maximum values produced by the Log-Likelihood Ratio unit. </paragraph>
<paragraph id="P-0106" lvl="0"><number>&lsqb;0106&rsqb;</number> Preferably, the Log-Likelihood Ratio unit comprises: </paragraph>
<paragraph id="P-0107" lvl="2"><number>&lsqb;0107&rsqb;</number> cache apparatus operable to store said set of first maximum values, said set of second maximum values and said successive sets thereof; </paragraph>
<paragraph id="P-0108" lvl="2"><number>&lsqb;0108&rsqb;</number> two compare-and-select units, each one possessing a first data input port connected to a data output port of said cache apparatus, a second data input port connected to a data output port of said cache apparatus, and a data output port connected to a data input port of said cache apparatus; </paragraph>
<paragraph id="P-0109" lvl="2"><number>&lsqb;0109&rsqb;</number> wherein one of said compare-and-select units is operable to receive at its first and second data input ports elements of said set of first maximum values output form said cache apparatus, and the other of said compare-and-select units is operable to receive at its first and second data input ports elements of said set of second maximum values output from said cache apparatus, each said compare-and-select unit being operable to compare concurrent first and second inputs and to output via said output port the element which is the maximum of the two. </paragraph>
<paragraph id="P-0110" lvl="0"><number>&lsqb;0110&rsqb;</number> Preferably, in the aforementioned Log-Likelihood Ratio unit, the element output from both compare-and-select units is input into said cache apparatus for storage as an element in the respective successive set of maximum values. The data output port of each of the two compare-and-select units is preferably connected to a respective one of a first input port and a second input port of a subtraction unit which is operable to subtract the data at one input port thereof from the data at the other input port thereof, and to output the result. </paragraph>
<paragraph id="P-0111" lvl="0"><number>&lsqb;0111&rsqb;</number> Preferably, each compare-and-select unit of the Log-Likelihood Ratio unit includes a subtraction unit connected to said first and second input ports of the two compare-and-select means, wherein the subtraction unit is operable to subtract data input at said first input port from data concurrently input at said second input port and to output the sign and the absolute magnitude of the result. </paragraph>
<paragraph id="P-0112" lvl="0"><number>&lsqb;0112&rsqb;</number> Preferably, each compare-and-select unit includes a selecting unit having a first and second input port respectively connected to said first and second input ports of the compare-and-select unit, wherein the selecting unit is operable to receive as a further input the sign output from said subtracting unit and to output the data input via one of its first and second input ports in dependence upon the value of said sign. </paragraph>
<paragraph id="P-0113" lvl="0"><number>&lsqb;0113&rsqb;</number> Each compare-and-select unit may include correcting apparatus for adding to the output of said selecting unit a correction factor substantially equal to</paragraph>
<paragraph lvl="0"><in-line-formula>ln(1&plus;exp(&minus;&Dgr;))</in-line-formula></paragraph>
<paragraph id="P-0114" lvl="7"><number>&lsqb;0114&rsqb;</number> where &Dgr; is the absolute value of the result output from said subtracting unit. </paragraph>
<paragraph id="P-0115" lvl="0"><number>&lsqb;0115&rsqb;</number> This correction factor, when added to the selected maximum value of the two quantities defining &Dgr;, results in the Jacobian logarithm of these two quantities, of which the selected maximum value is only one approximation. </paragraph>
<paragraph id="P-0116" lvl="0"><number>&lsqb;0116&rsqb;</number> Preferably, said correcting apparatus comprises: </paragraph>
<paragraph id="P-0117" lvl="2"><number>&lsqb;0117&rsqb;</number> a look-up table possessing a plurality of correction values and having an input port connected to the output port of said subtracting unit and an output port; and, </paragraph>
<paragraph id="P-0118" lvl="2"><number>&lsqb;0118&rsqb;</number> an adder means having a first input port connected to said output port of the look-up table and having a second input port connected to the output port of said selecting unit; </paragraph>
<paragraph id="P-0119" lvl="2"><number>&lsqb;0119&rsqb;</number> wherein said adder means is operable to add to the output of said selecting unit a correction term output from said look-up table. </paragraph>
<paragraph id="P-0120" lvl="0"><number>&lsqb;0120&rsqb;</number> The invention may also provide a turbo decoder comprising a plurality of Log-MAP decoders wherein: </paragraph>
<paragraph id="P-0121" lvl="2"><number>&lsqb;0121&rsqb;</number> each Log-MAP decoder comprises branch metric calculating apparatus for calculating transition metric values (&ggr;) according to the above methods. </paragraph>
<paragraph id="P-0122" lvl="0"><number>&lsqb;0122&rsqb;</number> The invention may provide a turbo decoder comprising a plurality of Log-MAP decoders wherein: </paragraph>
<paragraph id="P-0123" lvl="2"><number>&lsqb;0123&rsqb;</number> each Log-MAP decoder comprising path metric calculating apparatus for calculating path metric values of said encoder according to the first aspect of the present invention. </paragraph>
<paragraph id="P-0124" lvl="0"><number>&lsqb;0124&rsqb;</number> The present invention may also provide a turbo decoder comprising a plurality of Log-MAP decoders wherein: </paragraph>
<paragraph id="P-0125" lvl="2"><number>&lsqb;0125&rsqb;</number> each Log-MAP decoder comprising Log-Likelihood Ratio unit for calculating Log-Likelihood Ratio values of said encoder according to the second aspect of the present invention.</paragraph>
</summary-of-invention>
<brief-description-of-drawings>
<paragraph id="P-0126" lvl="0"><number>&lsqb;0126&rsqb;</number> There now follows a non-limiting example of the present invention with reference to the following figures: </paragraph>
<paragraph id="P-0127" lvl="0"><number>&lsqb;0127&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> illustrates a recursive systematic convolutional (RSC) encoder; </paragraph>
<paragraph id="P-0128" lvl="0"><number>&lsqb;0128&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> illustrates an encoder trellis associated with the RSC encoder of <cross-reference target="DRAWINGS">FIG. 1</cross-reference>; </paragraph>
<paragraph id="P-0129" lvl="0"><number>&lsqb;0129&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> illustrates a Turbo-Code encoder comprising two RSC encoders in parallel concatenation providing constituent codes of the Turbo-Code; </paragraph>
<paragraph id="P-0130" lvl="0"><number>&lsqb;0130&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> illustrates a Turbo-Decoder employing two maximum a posteriori probability (MAP) decoders; </paragraph>
<paragraph id="P-0131" lvl="0"><number>&lsqb;0131&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> illustrates a Log-Map trellis butterfly; </paragraph>
<paragraph id="P-0132" lvl="0"><number>&lsqb;0132&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> illustrates a flow diagram outlining the operation of the accelerated Log-MAP decoding algorithm (LM_ACS); </paragraph>
<paragraph id="P-0133" lvl="0"><number>&lsqb;0133&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> illustrates a schematic representation of an update of a Log-MAP trellis time step mapped onto Log-MAP butterflies of the trellis; </paragraph>
<paragraph id="P-0134" lvl="0"><number>&lsqb;0134&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> illustrates a flow diagram of outlining the extended operation of the accelerated Log-MAP decoding algorithm (LM_ACS); </paragraph>
<paragraph id="P-0135" lvl="0"><number>&lsqb;0135&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference> illustrates a flow diagram outlining the operation of the accelerated Log-Likelihood Ratio (LLR_ACC) calculation; </paragraph>
<paragraph id="P-0136" lvl="0"><number>&lsqb;0136&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10</cross-reference> illustrates a block diagram of an extended digital signal processor core; </paragraph>
<paragraph id="P-0137" lvl="0"><number>&lsqb;0137&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 11</cross-reference> illustrates a sample architecture for the LM_ACS unit of the extended digital signal processor; </paragraph>
<paragraph id="P-0138" lvl="0"><number>&lsqb;0138&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 12</cross-reference> illustrates a sample architecture for the LLR_ACC unit of the extended digital signal processor.</paragraph>
</brief-description-of-drawings>
<detailed-description>
<paragraph id="P-0139" lvl="0"><number>&lsqb;0139&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 3</cross-reference> there is illustrated the structure of a Turbo-Code encoder. The Turbo-Code encoder comprises data input <highlight><bold>31</bold></highlight> connected to the data inputs of two identical constituent recursive systematic convolutional (RSC) encoders <highlight><bold>34</bold></highlight> and <highlight><bold>35</bold></highlight> connected in parallel concatenation. The block data sequence to be encoded, {right arrow over (d)}&equals;(d<highlight><subscript>1</subscript></highlight>, . . . ,d<highlight><subscript>N</subscript></highlight>) where N is the block size, is input at the data input <highlight><bold>31</bold></highlight> of the Turbo-Code encoder and subsequently input to each one of the two identical constituent code encoders <highlight><bold>34</bold></highlight> and <highlight><bold>35</bold></highlight>. The second of the two constituent RSC encoders <highlight><bold>34</bold></highlight> receives the block data via an interleaver <highlight><bold>32</bold></highlight>. Interleaving places the block sequence {right arrow over (d)}&equals;(d<highlight><subscript>1</subscript></highlight>, . . . ,d<highlight><subscript>N</subscript></highlight>) into a different order before inputing that re-ordered data block sequence <highlight><bold>33</bold></highlight> ({right arrow over (x)}<highlight><superscript>s</superscript></highlight><highlight><subscript>int</subscript></highlight>) into the second RSC encoder <highlight><bold>34</bold></highlight>. In this way the effects of burst errors in any one data block may be reduced. </paragraph>
<paragraph id="P-0140" lvl="0"><number>&lsqb;0140&rsqb;</number> Each constituent RSC encoder produces parity bits for use in forward error correction of the data block input thereto. The first encoder <highlight><bold>35</bold></highlight> outputs a parity bit sequence {right arrow over (x)}<highlight><superscript>1p</superscript></highlight>, while the second encoder <highlight><bold>34</bold></highlight> outputs a parity bit sequence {right arrow over (x)}<highlight><superscript>2p</superscript></highlight><highlight><subscript>int </subscript></highlight>associated with the interleaved data block input thereto. Due to the parallel concatenation of the systematic information ({right arrow over (x)}<highlight><superscript>s</superscript></highlight>) and the parity information ({right arrow over (x)}<highlight><superscript>1p</superscript></highlight>,{right arrow over (x)}<highlight><superscript>2p</superscript></highlight><highlight><subscript>int</subscript></highlight>), three output bits are generated for each bit d<highlight><subscript>k </subscript></highlight>of the input data sequence {right arrow over (d)}&equals;(d<highlight><subscript>l</subscript></highlight>, . . . ,d<highlight><subscript>N</subscript></highlight>). These three outputs are subsequently input to separate respective inputs <highlight><bold>36</bold></highlight>, <highlight><bold>37</bold></highlight> and <highlight><bold>38</bold></highlight> of the multiplexer <highlight><bold>39</bold></highlight>. </paragraph>
<paragraph id="P-0141" lvl="0"><number>&lsqb;0141&rsqb;</number> Puncturing unit <highlight><bold>41</bold></highlight> ensures that certain bits are removed from the parity bit-stream input to the multiplexer <highlight><bold>39</bold></highlight> and are not transmitted. For example, every second bit of the parity information may be punctured, leading to the transmitted data sequence {right arrow over (x)}&equals;(x<highlight><subscript>1</subscript></highlight><highlight><superscript>s</superscript></highlight>,x<highlight><subscript>1</subscript></highlight><highlight><superscript>1p</superscript></highlight>,x<highlight><subscript>2</subscript></highlight><highlight><superscript>s</superscript></highlight>,x<highlight><subscript>int,2</subscript></highlight><highlight><superscript>2p</superscript></highlight>, . . . ,x<highlight><subscript>N&minus;1</subscript></highlight><highlight><superscript>s</superscript></highlight>, x<highlight><subscript>N&minus;1</subscript></highlight><highlight><superscript>1p</superscript></highlight>,x<highlight><subscript>N</subscript></highlight><highlight><superscript>s</superscript></highlight>,x<highlight><subscript>int,N</subscript></highlight><highlight><superscript>2p</superscript></highlight>) in which sucessive parity bits (denoted x<highlight><superscript>1p</superscript></highlight>) are taken from the first encoder <highlight><bold>35</bold></highlight> alternately with parity bits (denoted x<highlight><superscript>2p</superscript></highlight>) are taken from the second encoder <highlight><bold>34</bold></highlight>. </paragraph>
<paragraph id="P-0142" lvl="0"><number>&lsqb;0142&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> illustrates a Turbo-Decoder employing a first maximum a posteriori probability (MAP) decoder <highlight><bold>41</bold></highlight> connected in series with a second MAP decoder <highlight><bold>42</bold></highlight> via an interleaver <highlight><bold>43</bold></highlight>. The first MAP decoder <highlight><bold>41</bold></highlight> has three inputs: the systematic data input <highlight><bold>47</bold></highlight> (denoted {right arrow over (y)}<highlight><superscript>s</superscript></highlight>), the parity data input <highlight><bold>46</bold></highlight> (denoted {right arrow over (y)}<highlight><superscript>1p</superscript></highlight>) associated with the output of the first RSC encoder <highlight><bold>35</bold></highlight>, and the extrinsic information <highlight><bold>48</bold></highlight> (denoted {right arrow over (z)}<highlight><superscript>2</superscript></highlight>) output from the second MAP decoder <highlight><bold>42</bold></highlight> and received via the an intermediate interleaver <highlight><bold>44</bold></highlight>. The extrinsic information serves as a priori information. </paragraph>
<paragraph id="P-0143" lvl="0"><number>&lsqb;0143&rsqb;</number> With this information and channel state information <highlight><bold>56</bold></highlight>, the first MAP decoder <highlight><bold>41</bold></highlight> calculates for each bit d<highlight><subscript>k </subscript></highlight>of the input data sequence {right arrow over (d)}&equals;(d<highlight><subscript>1</subscript></highlight>, . . . ,d<highlight><subscript>N</subscript></highlight>) the MAP Log-Likelihood Ratio value:  
<math-cwu id="MATH-US-00002">
<number>2</number>
<math>
<mrow>
  <mrow>
    <mrow>
      <msub>
        <mi>&Lambda;</mi>
        <mn>1</mn>
      </msub>
      <mo>&af;</mo>
      <mrow>
        <mo>(</mo>
        <msub>
          <mi>d</mi>
          <mi>k</mi>
        </msub>
        <mo>)</mo>
      </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
      <mi>log</mi>
      <mo>&it;</mo>
      <mstyle>
        <mtext>&emsp;</mtext>
      </mstyle>
      <mo>&it;</mo>
      <mfrac>
        <mrow>
          <mi>Pr</mi>
          <mo>&it;</mo>
          <mrow>
            <mo>{</mo>
            <mrow>
              <msub>
                <mi>d</mi>
                <mi>k</mi>
              </msub>
              <mo>=</mo>
              <mrow>
                <mn>1</mn>
                <mo>&VerticalSeparator;</mo>
                <mover>
                  <mi>R</mi>
                  <mo>&RightArrow;</mo>
                </mover>
              </mrow>
            </mrow>
            <mo>}</mo>
          </mrow>
        </mrow>
        <mrow>
          <mi>Pr</mi>
          <mo>&it;</mo>
          <mrow>
            <mo>{</mo>
            <mrow>
              <msub>
                <mi>d</mi>
                <mi>k</mi>
              </msub>
              <mo>=</mo>
              <mrow>
                <mn>0</mn>
                <mo>&VerticalSeparator;</mo>
                <mover>
                  <mi>R</mi>
                  <mo>&RightArrow;</mo>
                </mover>
              </mrow>
            </mrow>
            <mo>}</mo>
          </mrow>
        </mrow>
      </mfrac>
    </mrow>
  </mrow>
  <mo>,</mo>
</mrow>
</math>
<mathematica-file id="MATHEMATICA-00002" file="US20030002603A1-20030102-M00002.NB"/>
<image id="EMI-M00002" wi="216.027" he="27.13095" file="US20030002603A1-20030102-M00002.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0144" lvl="7"><number>&lsqb;0144&rsqb;</number> where {right arrow over (R)}&equals;(R<highlight><subscript>1</subscript></highlight>, . . . ,R<highlight><subscript>k</subscript></highlight>, . . . ,R<highlight><subscript>N</subscript></highlight>) and R<highlight><subscript>k</subscript></highlight>&equals;(y<highlight><subscript>k</subscript></highlight><highlight><superscript>s</superscript></highlight>,y<highlight><subscript>k</subscript></highlight><highlight><superscript>1p</superscript></highlight>,z<highlight><subscript>k</subscript></highlight><highlight><superscript>2</superscript></highlight>), which can be written as:</paragraph>
<paragraph lvl="0"><in-line-formula>&Lgr;hu <highlight><bold>1</bold></highlight>(<highlight><italic>d</italic></highlight><highlight><subscript>k</subscript></highlight>)&equals;<highlight><italic>z</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>1</superscript></highlight><highlight><italic>&plus;c&middot;y</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>s</superscript></highlight><highlight><italic>&plus;z</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>2</superscript></highlight></in-line-formula></paragraph>
<paragraph id="P-0145" lvl="7"><number>&lsqb;0145&rsqb;</number> with c&equals;4&times;SNR, the quantity SNR being the signal-to-noise ratio associated with the received data signal. The systematic term c&middot;y<highlight><subscript>k</subscript></highlight><highlight><superscript>s </superscript></highlight>and the a priori term z<highlight><subscript>k</subscript></highlight><highlight><superscript>2 </superscript></highlight>are regarded as independent of the parity information for the bit d<highlight><subscript>k</subscript></highlight>. </paragraph>
<paragraph id="P-0146" lvl="0"><number>&lsqb;0146&rsqb;</number> The newly generated extrinsic information can therefore be computed as:</paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>z</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>1</superscript></highlight>&equals;&Lgr;<highlight><superscript>1</superscript></highlight>(<highlight><italic>d</italic></highlight><highlight><subscript>k</subscript></highlight>)&minus;<highlight><italic>c&middot;y</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>s</superscript></highlight><highlight><italic>&minus;z</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>2</superscript></highlight></in-line-formula></paragraph>
<paragraph id="P-0147" lvl="7"><number>&lsqb;0147&rsqb;</number> which is output at the data output <highlight><bold>49</bold></highlight> of the first MAP decoder <highlight><bold>41</bold></highlight> and serves, after interleaving by intermediate interleaver <highlight><bold>43</bold></highlight>, as a priori information z<highlight><subscript>k,int</subscript></highlight><highlight><superscript>1 </superscript></highlight>for input at one of the data inputs <highlight><bold>50</bold></highlight> of the second MAP decoder <highlight><bold>42</bold></highlight>. This information is input to the second MAP decoder <highlight><bold>42</bold></highlight> together with interleaved systematic data {right arrow over (y)}<highlight><subscript>k,int</subscript></highlight><highlight><superscript>s </superscript></highlight>at another data input <highlight><bold>51</bold></highlight> thereof, interleaved parity data {right arrow over (y)}<highlight><subscript>int</subscript></highlight><highlight><superscript>2p </superscript></highlight>(from the second RSC encoder <highlight><bold>34</bold></highlight>) at a further data input <highlight><bold>52</bold></highlight> thereof, and channel state information <highlight><bold>57</bold></highlight>. The second MAP decoder <highlight><bold>42</bold></highlight> computes extrinsic information as:</paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>z</italic></highlight><highlight><subscript>k,int</subscript></highlight><highlight><superscript>2</superscript></highlight>&equals;&Lgr;<highlight><superscript>2</superscript></highlight>(<highlight><italic>d</italic></highlight><highlight><subscript>k,int</subscript></highlight>)&minus;<highlight><italic>c&middot;y</italic></highlight><highlight><subscript>k,int</subscript></highlight><highlight><superscript>s</superscript></highlight><highlight><italic>&minus;z</italic></highlight><highlight><subscript>k,int</subscript></highlight><highlight><superscript>1</superscript></highlight></in-line-formula></paragraph>
<paragraph id="P-0148" lvl="7"><number>&lsqb;0148&rsqb;</number> which is subsequently de-interleaved by the de-interleaver <highlight><bold>44</bold></highlight> connected between the extrinsic information output of the second MAP decoder <highlight><bold>42</bold></highlight> and the a priori information input <highlight><bold>48</bold></highlight> of the first MAP decoder <highlight><bold>41</bold></highlight>. This procedure iterates several times until the MAP estimates {right arrow over (&Lgr;)}<highlight><superscript>1,2 </superscript></highlight>stabilise, whereupon the stabilised MAP estimate {right arrow over (&Lgr;)}<highlight><subscript>int</subscript></highlight><highlight><superscript>2 </superscript></highlight>is output from the output port <highlight><bold>53</bold></highlight> of the second MAP decoder <highlight><bold>42</bold></highlight> to the input of a second de-interleaver <highlight><bold>45</bold></highlight> for de-interleaving thereby. The de-interleaver MAP estimate of the Log-Likelihood Ratio {right arrow over (&Lgr;)}<highlight><superscript>2 </superscript></highlight>is subsequently output from the second de-interleaver <highlight><bold>45</bold></highlight> to a decision circuit <highlight><bold>55</bold></highlight> for use in decoding the received bit sequence {right arrow over (y)}. </paragraph>
<paragraph id="P-0149" lvl="0"><number>&lsqb;0149&rsqb;</number> It is preferable to implement this MAP decoding in the (natural) logarithmic domain in order to avoid numerical problems without degrading decoding performance. In the logarithmic domain, each of the first and second MAP decoders <highlight><bold>41</bold></highlight> and <highlight><bold>42</bold></highlight> operate as Log-MAP decoders which compute log-likelihood ratios as follows:</paragraph>
<paragraph lvl="0"><in-line-formula>&Lgr;(<highlight><italic>d</italic></highlight><highlight><subscript>k</subscript></highlight>)&equals;max*<highlight><subscript>(S</subscript></highlight><highlight><subscript><highlight><subscript>k</subscript></highlight></subscript></highlight><highlight><subscript>,S</subscript></highlight><highlight><subscript><highlight><subscript>k&minus;1</subscript></highlight></subscript></highlight><highlight><subscript>)</subscript></highlight>&lcub;{overscore (&ggr;)}<highlight><subscript>1</subscript></highlight>&lsqb;(<highlight><italic>y</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>s</superscript></highlight><highlight><italic>,y</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>p</superscript></highlight>), <highlight><italic>S</italic></highlight><highlight><subscript>k&minus;1</subscript></highlight><highlight><italic>,S</italic></highlight><highlight><subscript>k</subscript></highlight>&rsqb;{overscore (&agr;)}<highlight><subscript>k&minus;1</subscript></highlight>(<highlight><italic>S</italic></highlight><highlight><subscript>k&minus;1</subscript></highlight>)&plus;{overscore (&bgr;)}<highlight><subscript>k</subscript></highlight>(<highlight><italic>S</italic></highlight><highlight><subscript>k</subscript></highlight>)&rcub;</in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula>&minus;max*<highlight><subscript>(S</subscript></highlight><highlight><subscript><highlight><subscript>k</subscript></highlight></subscript></highlight><highlight><subscript>,S</subscript></highlight><highlight><subscript><highlight><subscript>k&minus;1</subscript></highlight></subscript></highlight><highlight><subscript>)</subscript></highlight>&lcub;{overscore (&ggr;)}<highlight><subscript>0</subscript></highlight>&lsqb;(<highlight><italic>y</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>s</superscript></highlight><highlight><italic>,y</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>p</superscript></highlight>),<highlight><italic>S</italic></highlight><highlight><subscript>k&minus;1</subscript></highlight><highlight><italic>,S</italic></highlight><highlight><subscript>k</subscript></highlight>&rsqb;&plus;{overscore (&agr;)}<highlight><subscript>k&minus;1</subscript></highlight>(<highlight><italic>S</italic></highlight><highlight><subscript>k&minus;1</subscript></highlight>)&plus;{overscore (&bgr;)}<highlight><subscript>k</subscript></highlight>(<highlight><italic>S</italic></highlight><highlight><subscript>k</subscript></highlight>)&rcub;,</in-line-formula></paragraph>
<paragraph id="P-0150" lvl="7"><number>&lsqb;0150&rsqb;</number> where the max* operation is in respect of all states S<highlight><subscript>(k,k&minus;1) </subscript></highlight>involved in transitions between trellis states at time step k&minus;1 and time step k, and</paragraph>
<paragraph lvl="0"><in-line-formula>{overscore (&ggr;)}<highlight><subscript>i</subscript></highlight>&lsqb;(<highlight><italic>y</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>s</superscript></highlight><highlight><italic>,y</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>p</superscript></highlight>),<highlight><italic>S</italic></highlight><highlight><subscript>k&minus;1</subscript></highlight><highlight><italic>,S</italic></highlight><highlight><subscript>k</subscript></highlight>&rsqb;&equals;2&middot;<highlight><italic>SNR&middot;y</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>s</superscript></highlight><highlight><italic>x</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>s</superscript></highlight>(<highlight><italic>i</italic></highlight>)&plus;2<highlight><italic>&middot;SNR&middot;y</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>p</superscript></highlight><highlight><italic>x</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>p</superscript></highlight>(<highlight><italic>i,S</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><italic>,S</italic></highlight><highlight><subscript>k&minus;1</subscript></highlight>)&plus;ln(<highlight><italic>Pr&lcub;S</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><italic>&verbar;S</italic></highlight><highlight><subscript>k&minus;1</subscript></highlight>&rcub;)</in-line-formula></paragraph>
<paragraph id="P-0151" lvl="7"><number>&lsqb;0151&rsqb;</number> are the branch metrics &ggr; (with i&equals;0,1) represented in the logarithmic domain, ln(Pr&lcub;S<highlight><subscript>k</subscript></highlight>&verbar;S<highlight><subscript>k&minus;1</subscript></highlight>&rcub;) being the a priori information. Branch metrics with i&equals;0 correspond to branches of the encoder trellis associated with the output by the Turbo-Code encoder of a &ldquo;zero&rdquo; bit, while those with i&equals;1 correspond to the output of a &ldquo;one&rdquo; bit. </paragraph>
<paragraph id="P-0152" lvl="0"><number>&lsqb;0152&rsqb;</number> It is to be noted that prior to transmission, every data bit output from the Turbo-Code encoder is subject to transformation. Data bits x<highlight><subscript>k</subscript></highlight><highlight><superscript>s </superscript></highlight>and x<highlight><subscript>k</subscript></highlight><highlight><superscript>p </superscript></highlight>are transformed according to the relation x&rarr;2&middot;x&minus;1;y&rarr;2&middot;y&minus;1 such that &ldquo;zero&rdquo; bits are transmitted as &ldquo;&minus;1&rdquo; bits. </paragraph>
<paragraph id="P-0153" lvl="0"><number>&lsqb;0153&rsqb;</number> Using these branch metrics, the forward path metrics {overscore (&agr;)}<highlight><subscript>k </subscript></highlight>in the log domain, and backward path metrics {overscore (&bgr;)}<highlight><subscript>k </subscript></highlight>in the log domain, are calculated recursively using the following relations:</paragraph>
<paragraph lvl="0"><in-line-formula>{overscore (&agr;)}<highlight><subscript>k</subscript></highlight>(<highlight><italic>S</italic></highlight><highlight><subscript>k</subscript></highlight>)&equals;max*<highlight><subscript>(S</subscript></highlight><highlight><subscript><highlight><subscript>k&minus;1</subscript></highlight></subscript></highlight><highlight><subscript>,i)</subscript></highlight>&lcub;{overscore (&ggr;)}<highlight><subscript>i</subscript></highlight>&lsqb;(<highlight><italic>y</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>s</superscript></highlight><highlight><italic>,y</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>p</superscript></highlight>),<highlight><italic>S</italic></highlight><highlight><subscript>k&minus;1</subscript></highlight><highlight><italic>,S</italic></highlight><highlight><subscript>k</subscript></highlight>&rsqb;&plus;{overscore (&agr;)}<highlight><subscript>k&minus;1</subscript></highlight>(<highlight><italic>S</italic></highlight><highlight><subscript>k&minus;1</subscript></highlight>)&rcub;,</in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula>and</in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula>{overscore (&bgr;)}<highlight><subscript>k</subscript></highlight>(<highlight><italic>S</italic></highlight><highlight><subscript>k</subscript></highlight>)&equals;max*<highlight><subscript>(S</subscript></highlight><highlight><subscript><highlight><subscript>k&plus;1</subscript></highlight></subscript></highlight><highlight><subscript>,i)</subscript></highlight>&lcub;{overscore (&ggr;)}<highlight><subscript>i</subscript></highlight>&lsqb;(<highlight><italic>y</italic></highlight><highlight><subscript>k&plus;1</subscript></highlight><highlight><superscript>s</superscript></highlight><highlight><italic>,y</italic></highlight><highlight><subscript>k&plus;1</subscript></highlight><highlight><superscript>p</superscript></highlight>),<highlight><italic>S</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><italic>,S</italic></highlight><highlight><subscript>k&plus;1</subscript></highlight>&rsqb;&plus;{overscore (&bgr;)}<highlight><subscript>k&plus;1</subscript></highlight>(<highlight><italic>S</italic></highlight><highlight><subscript>k&plus;1</subscript></highlight>)&rcub;.</in-line-formula></paragraph>
<paragraph id="P-0154" lvl="0"><number>&lsqb;0154&rsqb;</number> The operator term max* is the Jacobian logarithm of the quantities operated on thereby, of which the selected maximum (max) value is only an approximation (i.e. max*(a,b)&equals;ln(e<highlight><superscript>a</superscript></highlight>&plus;e<highlight><superscript>b</superscript></highlight>)&equals;max(a,b)&plus;ln(1&plus;e<highlight><superscript>&minus;&Dgr;</superscript></highlight>),&Dgr;&equals;&verbar;a&minus;b&verbar;). The present invention may operate according to the sub-optimal approximation max*(a,b)&ap;max(a,b) which omits the logarithmic correction term, but the present embodiment does not omit this term. </paragraph>
<paragraph id="P-0155" lvl="0"><number>&lsqb;0155&rsqb;</number> It will be appreciated that the four main tasks of each one of the two the Log-MAP decoders <highlight><bold>41</bold></highlight> and <highlight><bold>42</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 4</cross-reference> are the calculation of branch metrics for use in the calculation of forward and backward path metrics (i.e. path metric updating) and for use together with those updated path metrics in the calculation of Log-Likelihood Ratios (i.e. &ldquo;soft&rdquo; output data). According to the present embodiment, each of the Log-MAP decoders <highlight><bold>41</bold></highlight> and <highlight><bold>42</bold></highlight> comprises a digital signal processor for decoding received information according to the present invention. Usually, the two Log-MAP decoders are mapped to one single DSP. </paragraph>
<paragraph id="P-0156" lvl="0"><number>&lsqb;0156&rsqb;</number> According to this embodiment, the branch metrics are calculated from the received systematic and parity information bits along with channel state information and a priori information. Assuming the sent symbols x<highlight><subscript>k</subscript></highlight>&egr;&lcub;&minus;1,1&rcub;, the probabilities for the systematic and parity bits y<highlight><subscript>k </subscript></highlight>received through a channel subject to additive white Gaussian noise are defined by:</paragraph>
<paragraph lvl="0"><in-line-formula>{overscore (&ggr;)}<highlight><subscript>i</subscript></highlight>&lsqb;(<highlight><italic>y</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>s</superscript></highlight><highlight><italic>,y</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>p</superscript></highlight>),<highlight><italic>S</italic></highlight><highlight><subscript>k&minus;1</subscript></highlight><highlight><italic>,S</italic></highlight><highlight><subscript>k</subscript></highlight>&rsqb;&equals;2&middot;<highlight><italic>SNR&middot;y</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>s</superscript></highlight><highlight><italic>x</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>s</superscript></highlight>(<highlight><italic>i</italic></highlight>)&plus;2&middot;<highlight><italic>SNR&middot;y</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>p</superscript></highlight><highlight><italic>x</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>p</superscript></highlight>(<highlight><italic>i,S</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><italic>,S</italic></highlight><highlight><subscript>k&minus;1</subscript></highlight>)&plus;ln(<highlight><italic>Pr&lcub;S</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><italic>&verbar;S</italic></highlight><highlight><subscript>k&minus;1</subscript></highlight>&rcub;)</in-line-formula></paragraph>
<paragraph id="P-0157" lvl="7"><number>&lsqb;0157&rsqb;</number> in the logarithmic domain. The a priori information ln(Pr&lcub;S<highlight><subscript>k</subscript></highlight>&verbar;S<highlight><subscript>k&minus;1</subscript></highlight>&rcub;) required by any one of the two Log-MAP decoders <highlight><bold>41</bold></highlight> and <highlight><bold>42</bold></highlight> of the Turbo-Code decoder is directly deduced from the extrinsic information (z<highlight><superscript>1,2</superscript></highlight>) calculated by the other of the two decoders. If a transition S<highlight><subscript>k&minus;1</subscript></highlight><highlight><superscript>m</superscript></highlight>&rarr;S<highlight><subscript>k</subscript></highlight><highlight><superscript>m&prime;</superscript></highlight> is possible according to the trellis and d<highlight><subscript>k</subscript></highlight>, from trellis node m at time k&minus;1 to trellis node m&prime; at time step k, then:</paragraph>
<paragraph lvl="0"><in-line-formula>ln(<highlight><italic>Pr&lcub;S</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><italic>&verbar;S</italic></highlight><highlight><subscript>k&minus;1</subscript></highlight>&rcub;)&equals;<highlight><italic>z</italic></highlight><highlight><subscript>k</subscript></highlight>; for <highlight><italic>d</italic></highlight><highlight><subscript>k</subscript></highlight>&equals;1</in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula>ln(<highlight><italic>Pr&lcub;S</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><italic>&verbar;S</italic></highlight><highlight><subscript>k&minus;1</subscript></highlight>&rcub;)&equals;0; for d<highlight><subscript>k</subscript></highlight>&equals;0.</in-line-formula></paragraph>
<paragraph id="P-0158" lvl="0"><number>&lsqb;0158&rsqb;</number> Thus, the a priori information ln(Pr&lcub;S<highlight><subscript>k</subscript></highlight>&verbar;S<highlight><subscript>k&minus;1</subscript></highlight>&rcub;) required by any one of the two Log-MAP decoders <highlight><bold>41</bold></highlight> and <highlight><bold>42</bold></highlight> of the Turbo-Code decoder is directly deduced from the extrinsic information (z<highlight><superscript>1,2</superscript></highlight>) calculated by the other of the two decoders. </paragraph>
<paragraph id="P-0159" lvl="0"><number>&lsqb;0159&rsqb;</number> A total of four different branch metric values are possible at each trellis time step k, one for each of the four combinations of the two possible received systematic data bits y<highlight><subscript>k</subscript></highlight><highlight><superscript>s</superscript></highlight>&egr;&lcub;&minus;1,1&rcub;, and parity bits y<highlight><subscript>k</subscript></highlight><highlight><superscript>p</superscript></highlight>&egr;&lcub;&minus;1,1&rcub;:</paragraph>
<paragraph lvl="0"><in-line-formula>{overscore (&ggr;)}(<highlight><italic>x</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>s</superscript></highlight>&equals;&minus;1,<highlight><italic>x</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>p</superscript></highlight>&equals;&minus;1)&equals;&minus;2&middot;<highlight><italic>SNR&middot;</italic></highlight>(<highlight><italic>y</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>s</superscript></highlight><highlight><italic>&plus;y</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>p</superscript></highlight>)</in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula>{overscore (&ggr;)}(<highlight><italic>x</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>s</superscript></highlight>&equals;&minus;1,<highlight><italic>x</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>p</superscript></highlight>&equals;&plus;1)&equals;&minus;2&middot;<highlight><italic>SNR&middot;</italic></highlight>(<highlight><italic>&minus;y</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>s</superscript></highlight><highlight><italic>&plus;y</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>p</superscript></highlight>)</in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula>{overscore (&ggr;)}(<highlight><italic>x</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>s</superscript></highlight>&equals;&plus;1,<highlight><italic>x</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>p</superscript></highlight>&equals;&minus;1)&equals;&minus;2&middot;<highlight><italic>SNR&middot;</italic></highlight>(<highlight><italic>y</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>s</superscript></highlight><highlight><italic>&minus;y</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>p</superscript></highlight>)&plus;z<highlight><subscript>k</subscript></highlight></in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula>{overscore (&ggr;)}(<highlight><italic>x</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>s</superscript></highlight>&equals;&plus;1,<highlight><italic>x</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>p</superscript></highlight>&equals;&plus;1)&equals;&minus;2&middot;<highlight><italic>SNR&middot;</italic></highlight>(<highlight><italic>y</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>s</superscript></highlight><highlight><italic>&plus;y</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>p</superscript></highlight>)&plus;z<highlight><subscript>k</subscript></highlight>.</in-line-formula></paragraph>
<paragraph id="P-0160" lvl="0"><number>&lsqb;0160&rsqb;</number> The structure of the Turbo-Code encoder determines which transition metric is assigned to a given transition. Simplification of the calculation of these branch metrics is achieved by adding the term (2&middot;SNR&middot;(y<highlight><subscript>k</subscript></highlight><highlight><superscript>s</superscript></highlight>&plus;y<highlight><subscript>k</subscript></highlight><highlight><superscript>p</superscript></highlight>)) to each of the above four equations, yielding:</paragraph>
<paragraph lvl="0"><in-line-formula>{overscore (&ggr;)}<highlight><subscript>k</subscript></highlight><highlight><superscript>0,0</superscript></highlight>&equals;{overscore (&ggr;)}(<highlight><italic>x</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>s</superscript></highlight>&equals;&minus;1,<highlight><italic>x</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>p</superscript></highlight>&equals;&minus;1)&equals;0</in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula>{overscore (&ggr;)}<highlight><subscript>k</subscript></highlight><highlight><superscript>0,1</superscript></highlight>&equals;{overscore (&ggr;)}(<highlight><italic>x</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>s</superscript></highlight>&equals;&minus;1,<highlight><italic>x</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>p</superscript></highlight>&equals;&plus;1)&equals;s<highlight><bold>1</bold></highlight></in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula>{overscore (&ggr;)}<highlight><subscript>k</subscript></highlight><highlight><superscript>1,0</superscript></highlight>&equals;{overscore (&ggr;)}(<highlight><italic>x</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>s</superscript></highlight>&equals;&plus;1,<highlight><italic>x</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>p</superscript></highlight>&equals;&minus;1)&equals;s<highlight><bold>2</bold></highlight></in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula>{overscore (&ggr;)}<highlight><subscript>k</subscript></highlight><highlight><superscript>1,1</superscript></highlight>&equals;{overscore (&ggr;)}(<highlight><italic>x</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>s</superscript></highlight>&equals;&plus;1,<highlight><italic>x</italic></highlight><highlight><subscript>k</subscript></highlight><highlight><superscript>p</superscript></highlight>&equals;&plus;1)&equals;s<highlight><bold>1</bold></highlight>&plus;s<highlight><bold>2</bold></highlight></in-line-formula></paragraph>
<paragraph id="P-0161" lvl="7"><number>&lsqb;0161&rsqb;</number> where s<highlight><bold>1</bold></highlight>&equals;4&middot;SNR&middot;y<highlight><subscript>k</subscript></highlight><highlight><superscript>p </superscript></highlight>and s<highlight><bold>2</bold></highlight>&equals;4&middot;SNR&middot;y<highlight><subscript>k</subscript></highlight><highlight><superscript>s</superscript></highlight>&plus;z<highlight><subscript>k</subscript></highlight>. Thus, only two terms have to be calculated by either Log-MAP decoder <highlight><bold>41</bold></highlight> and <highlight><bold>42</bold></highlight>, from the received data bits. </paragraph>
<paragraph id="P-0162" lvl="0"><number>&lsqb;0162&rsqb;</number> In the portion of the trellis of the binary convolutional Turbo-Code encoder of <cross-reference target="DRAWINGS">FIG. 3</cross-reference> from a time step k&minus;1 to k, the transitions between neighbouring states of the trellis can be segregated into disjoint groups of four each originating in a concurrent pair of states and terminating in another concurrent pair. The structure produced by these four states is known as a trellis &ldquo;butterfly&rdquo;. <cross-reference target="DRAWINGS">FIG. 5</cross-reference> illustrates the Log-MAP butterfly of the Turbo-Code encoder of <cross-reference target="DRAWINGS">FIG. 3</cross-reference> which comprises a first concurrent pair of states m and m&plus;M/2, and a second concurrent pair of states <highlight><bold>2</bold></highlight>m and <highlight><bold>2</bold></highlight>m&plus;1. Here, M is the total number of possible states of the trellis (M&equals;8 in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>), and m is a given state number. </paragraph>
<paragraph id="P-0163" lvl="0"><number>&lsqb;0163&rsqb;</number> Each one of the states of the first pair (m,m&plus;M/2) is joined to each one of the second pair of states (<highlight><bold>2</bold></highlight>m,<highlight><bold>2</bold></highlight>m&plus;1) by a respective one of a pair of distinct branch metrics &ggr;<highlight><subscript>k</subscript></highlight>(I) and &ggr;<highlight><subscript>k</subscript></highlight>(II). Each of these two branch metrics takes a value given by one of the four possible values given above. The first branch metric of the pair is associated with the output by the encoder of a parity bit of a first binary value and the second one of the pair is associated with the output by the encoder of a parity bit of a second binary value (e.g. parity bit <highlight><bold>0</bold></highlight>, and parity bit <highlight><bold>1</bold></highlight> respectively). </paragraph>
<paragraph id="P-0164" lvl="0"><number>&lsqb;0164&rsqb;</number> The forward branch metrics &agr;<highlight><subscript>k </subscript></highlight>associated with the first pair of states (m,m&plus;M/2) of the butterfly are updated by adding the relevant transition metric thereto so as to extend that path metric to one of the second pair of states (<highlight><bold>2</bold></highlight>m,<highlight><bold>2</bold></highlight>m&plus;1) according to the following equations:</paragraph>
<paragraph lvl="0"><in-line-formula>&agr;<highlight><subscript>k</subscript></highlight>((<highlight><bold>2</bold></highlight><highlight><italic>m</italic></highlight>)&equals;max*(&agr;<highlight><subscript>k&minus;1</subscript></highlight>(<highlight><italic>m</italic></highlight>)&plus;&ggr;<highlight><subscript>k</subscript></highlight>(I),&agr;<highlight><subscript>k&minus;1</subscript></highlight>(<highlight><italic>m&plus;M/</italic></highlight>2)&plus;&ggr;<highlight><subscript>k</subscript></highlight>(II))</in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula>&agr;<highlight><subscript>k</subscript></highlight>((<highlight><bold>2</bold></highlight><highlight><italic>m</italic></highlight>&plus;1)&equals;max*(&agr;<highlight><subscript>k&minus;1</subscript></highlight>(<highlight><italic>m</italic></highlight>)&plus;&ggr;<highlight><subscript>k</subscript></highlight>(II),&agr;<highlight><subscript>k&minus;1</subscript></highlight>(<highlight><italic>m&plus;M/</italic></highlight>2)&plus;&ggr;<highlight><subscript>k</subscript></highlight>(I))</in-line-formula></paragraph>
<paragraph id="P-0165" lvl="0"><number>&lsqb;0165&rsqb;</number> Similarly, the backward branch metrics &bgr;<highlight><subscript>k </subscript></highlight>associated with the second pair of states (<highlight><bold>2</bold></highlight>m,<highlight><bold>2</bold></highlight>m&plus;1) of the butterfly are updated by adding the relevant transition metric thereto so as to extend that path metric to one of the first pair of states (m,m&plus;M/2) according to the following equations:</paragraph>
<paragraph lvl="0"><in-line-formula>&bgr;<highlight><subscript>k&minus;1</subscript></highlight>(<highlight><italic>m</italic></highlight>)&equals;max*(&bgr;<highlight><subscript>k</subscript></highlight>(<highlight><bold>2</bold></highlight><highlight><italic>m</italic></highlight>)&plus;&ggr;<highlight><subscript>k</subscript></highlight>(I),&bgr;<highlight><subscript>k</subscript></highlight>(<highlight><bold>2</bold></highlight><highlight><italic>m&plus;</italic></highlight>1)&plus;&ggr;<highlight><subscript>k</subscript></highlight>(II))</in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula>&bgr;<highlight><subscript>k&minus;1</subscript></highlight>(<highlight><italic>m&plus;M/</italic></highlight>2)&equals;max*(&bgr;<highlight><subscript>k</subscript></highlight>(<highlight><bold>2</bold></highlight><highlight><italic>m</italic></highlight>)&plus;&ggr;<highlight><subscript>k</subscript></highlight>(II),&bgr;<highlight><subscript>k</subscript></highlight>(<highlight><bold>2</bold></highlight><highlight><italic>m&plus;</italic></highlight>1)&plus;&ggr;<highlight><subscript>k</subscript></highlight>(I))</in-line-formula></paragraph>
<paragraph id="P-0166" lvl="0"><number>&lsqb;0166&rsqb;</number> It will be readily appreciated that in updating any concurrent pair of states of a Log-MAP butterfly according to these equations, the same four data items are used for each state of the pair. That is to say, the same two path metrics to the state being updated, and the same two transition metric values for achieving that update are used for updating each state of a concurrent butterfly pair. </paragraph>
<paragraph id="P-0167" lvl="0"><number>&lsqb;0167&rsqb;</number> Each state update requires three successive steps: the addition of transition metric values to each of the two branch metrics of a concurrent pair; a comparison of the two resulting updated branch metrics; and a selection of the maximum value of the two. Thus, implementation of each of the above updating equations requires an Add-Compare-Select &ldquo;ACS&rdquo; operation. </paragraph>
<paragraph id="P-0168" lvl="0"><number>&lsqb;0168&rsqb;</number> At its most general, the present invention proposes to accelerate the operation of a Log-MAP decoding algorithm by at least performing each step of an Add-Compare-Select (ACS) operation in respect of one state of one concurrent pair of states of a trellis butterfly in parallel with each corresponding step of an Add-Compare-Select operation in respect of the other state of the one concurrent pair of states. The ACS operation may form part of a path metric update or part of a Log-Likelihood Ratio calculation. </paragraph>
<paragraph id="P-0169" lvl="0"><number>&lsqb;0169&rsqb;</number> Accordingly, the Log-MAP ACS operation &ldquo;LM_ACS&rdquo; is introduced. This operation is performed on a trellis butterfly and comprises the steps of: </paragraph>
<paragraph id="P-0170" lvl="2"><number>&lsqb;0170&rsqb;</number> (i) adding to the path metric value associated with a first encoder state a first transition metric value associated with the transition of the encoder from the first encoder state to a first adjacent encoder state thereby providing a first updated path metric value for the first adjacent encoder state; </paragraph>
<paragraph id="P-0171" lvl="2"><number>&lsqb;0171&rsqb;</number> (ii) substantially simultaneously with step (i) adding to the path metric value associated with a second encoder state concurrent with the first state a second transition metric value associated with the transition of the encoder from the second encoder state to the first adjacent encoder state thereby providing a second updated path metric value for the first adjacent encoder state; </paragraph>
<paragraph id="P-0172" lvl="2"><number>&lsqb;0172&rsqb;</number> (iii) comparing the first updated path metric value for the first adjacent encoder state to the second updated path metric value therefor and selecting the maximum of the two to be the updated path metric value associated with that adjacent encoder state; </paragraph>
<paragraph id="P-0173" lvl="2"><number>&lsqb;0173&rsqb;</number> (iv) adding to the path metric value associated with the first encoder state the second transition metric value associated with the transition of the encoder from the first encoder state to a second adjacent encoder state concurrent with the first adjacent encoder state thereby providing a first updated path metric value for the second adjacent encoder state; </paragraph>
<paragraph id="P-0174" lvl="2"><number>&lsqb;0174&rsqb;</number> (v) substantially simultaneously with step (iv) adding to the path metric value associated with the second encoder state the second transition metric value associated with the transition of the encoder from the second encoder state to said second adjacent encoder state thereby providing a second updated path metric value for the second adjacent encoder state; </paragraph>
<paragraph id="P-0175" lvl="2"><number>&lsqb;0175&rsqb;</number> (vi) comparing said first updated path metric values for the second adjacent encoder state to the second updated path metric value therefore and selecting the maximum of the two to be the updated path metric value associated with that adjacent encoder state. </paragraph>
<paragraph id="P-0176" lvl="0"><number>&lsqb;0176&rsqb;</number> In this operation, the sequence of steps (i), (ii) and (iii) are performed substantially simultaneously with the sequence of steps (iv), (v) and (vi) respectively. </paragraph>
<paragraph id="P-0177" lvl="0"><number>&lsqb;0177&rsqb;</number> The max* operation is defined by:</paragraph>
<paragraph lvl="0"><in-line-formula>max*(<highlight><italic>a,b</italic></highlight>)&equals;max(<highlight><italic>a,b</italic></highlight>)&plus;ln(1&plus;exp(&minus;&verbar;<highlight><italic>a&minus;b</italic></highlight>&verbar;)).</in-line-formula></paragraph>
<paragraph id="P-0178" lvl="0"><number>&lsqb;0178&rsqb;</number> The correction term ln(1&plus;exp(&minus;&verbar;a&minus;b&verbar;)) being added to the result of the result of the ACS operation associated with the &ldquo;max&rdquo; operation to provide the full Jacobian logarithm of which the &ldquo;max&rdquo; operator is only an approximation. This is implemented in the digital signal processor of the present embodiment by use of a small look-up table (LUT) as will be explained in more detail below. </paragraph>
<paragraph id="P-0179" lvl="0"><number>&lsqb;0179&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> schematically illustrates the steps of the LM_ACS operation. The functionality of this operation is based upon the structure of the four path metric update equations defined above. The first step <highlight><bold>61</bold></highlight> of the LM_ACS operation requires the simultaneous provision by the digital signal processor of two path metric values (PM<highlight><bold>1</bold></highlight>,PM<highlight><bold>2</bold></highlight>) of a concurrent Log-MAP butterfly pair, and of two distinct transition metric values (TM<highlight><bold>1</bold></highlight>, TM<highlight><bold>2</bold></highlight>) for use in the second step <highlight><bold>62</bold></highlight> of the operation of updating that pair in two simultaneous &ldquo;max*&rdquo; operations. Updated path metrics (RM<highlight><bold>1</bold></highlight>,RM<highlight><bold>2</bold></highlight>) are simultaneously produced as a result <highlight><bold>63</bold></highlight>. </paragraph>
<paragraph id="P-0180" lvl="0"><number>&lsqb;0180&rsqb;</number> Each complete path metric update of this type at a time step k can be mapped onto an m-fold execution of the LM_ACS operation:</paragraph>
<paragraph lvl="0"><in-line-formula>(RM<highlight><bold>1</bold></highlight>,RM<highlight><bold>2</bold></highlight>)&equals;LM_ACS(PM<highlight><bold>1</bold></highlight>,PM<highlight><bold>2</bold></highlight>,TM<highlight><bold>1</bold></highlight>,TM<highlight><bold>2</bold></highlight>)</in-line-formula></paragraph>
<paragraph id="P-0181" lvl="7"><number>&lsqb;0181&rsqb;</number> by the digital signal processor as depicted in <cross-reference target="DRAWINGS">FIG. 7</cross-reference> for an 8-state encoder trellis. The parameters &ggr;<highlight><subscript>k</subscript></highlight>(I) and &ggr;<highlight><subscript>k</subscript></highlight>(II) of the Log-MAP butterfly of <cross-reference target="DRAWINGS">FIG. 5</cross-reference> correspond with the transition metric values TM<highlight><bold>1</bold></highlight> and TM<highlight><bold>2</bold></highlight>. It will be appreciated that, with this assignment, the first two Log-MAP butterflies of <cross-reference target="DRAWINGS">FIG. 7</cross-reference> correspond with the butterfly of <cross-reference target="DRAWINGS">FIG. 5</cross-reference> with regard to the allocation of dashed and solid lines (transition metric values). As a common operation is defined for all butterflies, the order of the branch metrics must be exchanged when the digital signal processor (DSP) computes the last two butterflies of <cross-reference target="DRAWINGS">FIG. 7</cross-reference> (right-hand column). </paragraph>
<paragraph id="P-0182" lvl="0"><number>&lsqb;0182&rsqb;</number> In order to update the forward path metrics of the eight states (m&equals;0, . . . ,m&equals;7) of the encoder trellis segment of <cross-reference target="DRAWINGS">FIG. 7</cross-reference> from time k&minus;1 to time k, the LM_ACS operation must be performed by the DSP four times as follows:</paragraph>
<paragraph lvl="0"><in-line-formula>(&agr;<highlight><subscript>k</subscript></highlight>(0),&agr;<highlight><subscript>k</subscript></highlight>(1))&equals;<highlight><italic>LM</italic></highlight><highlight><subscript>&mdash;</subscript></highlight><highlight><italic>ACS</italic></highlight>(&agr;<highlight><subscript>k&minus;1</subscript></highlight>(0),&agr;<highlight><subscript>k&minus;1</subscript></highlight>(4),&ggr;<highlight><subscript>k</subscript></highlight><highlight><superscript>0,0</superscript></highlight>,&ggr;<highlight><subscript>k</subscript></highlight><highlight><superscript>1,1</superscript></highlight>)</in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula>(&agr;<highlight><subscript>k</subscript></highlight>(2),&agr;<highlight><subscript>k</subscript></highlight>(3))&equals;<highlight><italic>LM</italic></highlight><highlight><subscript>&mdash;</subscript></highlight><highlight><italic>ACS</italic></highlight>(&agr;<highlight><subscript>k&minus;1</subscript></highlight>(1),&agr;<highlight><subscript>k&minus;1</subscript></highlight>(5),&ggr;<highlight><subscript>k</subscript></highlight><highlight><superscript>0,1</superscript></highlight>,&ggr;<highlight><subscript>k</subscript></highlight><highlight><superscript>1,0</superscript></highlight>)</in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula>(&agr;<highlight><subscript>k</subscript></highlight>(4),&agr;<highlight><subscript>k</subscript></highlight>(5))&equals;<highlight><italic>LM</italic></highlight><highlight><subscript>&mdash;</subscript></highlight><highlight><italic>ACS</italic></highlight>(&agr;<highlight><subscript>k&minus;1</subscript></highlight>(2),&agr;<highlight><subscript>k&minus;1</subscript></highlight>(6),&ggr;<highlight><subscript>k</subscript></highlight><highlight><superscript>1,0</superscript></highlight>,&ggr;<highlight><subscript>k</subscript></highlight><highlight><superscript>0,1</superscript></highlight>)</in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula>(&agr;<highlight><subscript>k</subscript></highlight>(6),&agr;<highlight><subscript>k</subscript></highlight>(7))&equals;<highlight><italic>LM</italic></highlight><highlight><subscript>&mdash;</subscript></highlight><highlight><italic>ACS</italic></highlight>(&agr;<highlight><subscript>k&minus;1</subscript></highlight>(3),&agr;<highlight><subscript>k&minus;1</subscript></highlight>(7),&ggr;<highlight><subscript>k</subscript></highlight><highlight><superscript>1,1</superscript></highlight>,&ggr;<highlight><subscript>k</subscript></highlight><highlight><superscript>0,0</superscript></highlight>)</in-line-formula></paragraph>
<paragraph id="P-0183" lvl="0"><number>&lsqb;0183&rsqb;</number> During the updating of these forward path metrics, all updated path metrics (&agr;<highlight><subscript>k</subscript></highlight>(0), . . . ,&agr;<highlight><subscript>k</subscript></highlight>(7)) are stored for every time step k in a memory store of the DSP for later use in Log-Likelihood Ratio calculations. As every two LM_ACS operations use the same pair of branch metrics, either (&ggr;<highlight><subscript>k</subscript></highlight><highlight><superscript>0,0</superscript></highlight>,&ggr;<highlight><subscript>k</subscript></highlight><highlight><superscript>1,1</superscript></highlight>) or (&ggr;<highlight><subscript>k</subscript></highlight><highlight><superscript>0,1</superscript></highlight>,&ggr;<highlight><subscript>k</subscript></highlight><highlight><superscript>1,0</superscript></highlight>) the buffering of these branch metric values in a transition metric cache can reduce the required bandwidth of the main memory store of the DSP and enhance its efficiency. </paragraph>
<paragraph id="P-0184" lvl="0"><number>&lsqb;0184&rsqb;</number> The updating of backward path metrics is achieved by the DSP according to the following:</paragraph>
<paragraph lvl="0"><in-line-formula>(&bgr;<highlight><subscript>k&minus;1</subscript></highlight>(0),&bgr;<highlight><subscript>&minus;1k</subscript></highlight>(4))&equals;<highlight><italic>LM</italic></highlight><highlight><subscript>&mdash;</subscript></highlight><highlight><italic>ACS</italic></highlight>(&bgr;<highlight><subscript>k</subscript></highlight>(0),&bgr;<highlight><subscript>k</subscript></highlight>(1),&ggr;<highlight><subscript>k</subscript></highlight><highlight><superscript>0,0</superscript></highlight>,&ggr;<highlight><subscript>k</subscript></highlight><highlight><superscript>1,1</superscript></highlight>)</in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula>(&bgr;<highlight><subscript>k&minus;1</subscript></highlight>(1),&bgr;<highlight><subscript>k&minus;1</subscript></highlight>(5))&equals;<highlight><italic>LM</italic></highlight><highlight><subscript>&mdash;</subscript></highlight><highlight><italic>ACS</italic></highlight>(&bgr;<highlight><subscript>k</subscript></highlight>(2),&bgr;<highlight><subscript>k</subscript></highlight>(3),&ggr;<highlight><subscript>k</subscript></highlight><highlight><superscript>0,1</superscript></highlight>,&ggr;<highlight><subscript>k</subscript></highlight><highlight><superscript>1,0</superscript></highlight>)</in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula>(&bgr;<highlight><subscript>k&minus;1</subscript></highlight>(2),&bgr;<highlight><subscript>k&minus;1</subscript></highlight>(6))&equals;<highlight><italic>LM</italic></highlight><highlight><subscript>&mdash;</subscript></highlight><highlight><italic>ACS</italic></highlight>(&bgr;<highlight><subscript>k</subscript></highlight>(4),&bgr;<highlight><subscript>k</subscript></highlight>(5),&ggr;<highlight><subscript>k</subscript></highlight><highlight><superscript>1,0</superscript></highlight>,&ggr;<highlight><subscript>k</subscript></highlight><highlight><superscript>0,1</superscript></highlight>)</in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula>(&bgr;<highlight><subscript>k&minus;1</subscript></highlight>(3),&bgr;<highlight><subscript>k&minus;1</subscript></highlight>(7))&equals;<highlight><italic>LM</italic></highlight><highlight><subscript>&mdash;</subscript></highlight><highlight><italic>ACS</italic></highlight>(&bgr;<highlight><subscript>k</subscript></highlight>(6),&bgr;<highlight><subscript>k</subscript></highlight>(7),&ggr;<highlight><subscript>k</subscript></highlight><highlight><superscript>1,1</superscript></highlight>,&ggr;<highlight><subscript>k</subscript></highlight><highlight><superscript>0,0</superscript></highlight>)</in-line-formula></paragraph>
<paragraph id="P-0185" lvl="0"><number>&lsqb;0185&rsqb;</number> By combining the backward path metric update with Log-Likelihood Ratio (LLR) calculations, the DSP is able to directly use backward path metric values calculated (and stored) in this way at time step k for use in LLR calculations later. Only 2M backward path metric values need to be stored by the DSP, the values being for time-steps k and k&minus;1. </paragraph>
<paragraph id="P-0186" lvl="0"><number>&lsqb;0186&rsqb;</number> The calculation of LLR values for the eight-state encoder trellis section of <cross-reference target="DRAWINGS">FIG. 7</cross-reference>, from time k&minus;1 to time k may be written as follows:  
<math-cwu id="MATH-US-00003">
<number>3</number>
<math>
<mrow>
  <msub>
    <mi>&Lambda;</mi>
    <mi>k</mi>
  </msub>
  <mo>=</mo>
  <mrow>
    <mrow>
      <mi>max</mi>
      <mo>&CenterDot;</mo>
      <mrow>
        <mo>{</mo>
        <mtable>
          <mtr>
            <mtd>
              <mrow>
                <mrow>
                  <mrow>
                    <msub>
                      <mi>&alpha;</mi>
                      <mi>k</mi>
                    </msub>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>(</mo>
                      <mn>4</mn>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                  <mo>+</mo>
                  <msubsup>
                    <mi>&gamma;</mi>
                    <mi>k</mi>
                    <mrow>
                      <mn>0</mn>
                      <mo>,</mo>
                      <mn>1</mn>
                    </mrow>
                  </msubsup>
                  <mo>+</mo>
                  <mrow>
                    <msub>
                      <mi>&beta;</mi>
                      <mi>k</mi>
                    </msub>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>(</mo>
                      <mn>0</mn>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                </mrow>
                <mo>,</mo>
              </mrow>
            </mtd>
          </mtr>
          <mtr>
            <mtd>
              <mrow>
                <mrow>
                  <mrow>
                    <msub>
                      <mi>&alpha;</mi>
                      <mi>k</mi>
                    </msub>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>(</mo>
                      <mn>0</mn>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                  <mo>+</mo>
                  <msubsup>
                    <mi>&gamma;</mi>
                    <mi>k</mi>
                    <mrow>
                      <mn>0</mn>
                      <mo>,</mo>
                      <mn>1</mn>
                    </mrow>
                  </msubsup>
                  <mo>+</mo>
                  <mrow>
                    <msub>
                      <mi>&beta;</mi>
                      <mi>k</mi>
                    </msub>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>(</mo>
                      <mn>1</mn>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                </mrow>
                <mo>,</mo>
              </mrow>
            </mtd>
          </mtr>
          <mtr>
            <mtd>
              <mrow>
                <mrow>
                  <mrow>
                    <msub>
                      <mi>&alpha;</mi>
                      <mi>k</mi>
                    </msub>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>(</mo>
                      <mn>5</mn>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                  <mo>+</mo>
                  <mrow>
                    <msub>
                      <mi>&beta;</mi>
                      <mi>k</mi>
                    </msub>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>(</mo>
                      <mn>2</mn>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                </mrow>
                <mo>,</mo>
              </mrow>
            </mtd>
          </mtr>
          <mtr>
            <mtd>
              <mrow>
                <mrow>
                  <mrow>
                    <msub>
                      <mi>&alpha;</mi>
                      <mi>k</mi>
                    </msub>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>(</mo>
                      <mn>1</mn>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                  <mo>+</mo>
                  <mrow>
                    <msub>
                      <mi>&beta;</mi>
                      <mi>k</mi>
                    </msub>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>(</mo>
                      <mn>3</mn>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                </mrow>
                <mo>,</mo>
              </mrow>
            </mtd>
          </mtr>
          <mtr>
            <mtd>
              <mrow>
                <mrow>
                  <mrow>
                    <msub>
                      <mi>&alpha;</mi>
                      <mi>k</mi>
                    </msub>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>(</mo>
                      <mn>2</mn>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                  <mo>+</mo>
                  <mrow>
                    <msub>
                      <mi>&beta;</mi>
                      <mi>k</mi>
                    </msub>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>(</mo>
                      <mn>4</mn>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                </mrow>
                <mo>,</mo>
              </mrow>
            </mtd>
          </mtr>
          <mtr>
            <mtd>
              <mrow>
                <mrow>
                  <mrow>
                    <msub>
                      <mi>&alpha;</mi>
                      <mi>k</mi>
                    </msub>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>(</mo>
                      <mn>6</mn>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                  <mo>+</mo>
                  <mrow>
                    <msub>
                      <mi>&beta;</mi>
                      <mi>k</mi>
                    </msub>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>(</mo>
                      <mn>5</mn>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                </mrow>
                <mo>,</mo>
              </mrow>
            </mtd>
          </mtr>
          <mtr>
            <mtd>
              <mrow>
                <mrow>
                  <mrow>
                    <msub>
                      <mi>&alpha;</mi>
                      <mi>k</mi>
                    </msub>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>(</mo>
                      <mn>3</mn>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                  <mo>+</mo>
                  <msubsup>
                    <mi>&gamma;</mi>
                    <mi>k</mi>
                    <mrow>
                      <mn>0</mn>
                      <mo>,</mo>
                      <mn>1</mn>
                    </mrow>
                  </msubsup>
                  <mo>+</mo>
                  <mrow>
                    <msub>
                      <mi>&beta;</mi>
                      <mi>k</mi>
                    </msub>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>(</mo>
                      <mn>6</mn>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                </mrow>
                <mo>,</mo>
              </mrow>
            </mtd>
          </mtr>
          <mtr>
            <mtd>
              <mrow>
                <mrow>
                  <mrow>
                    <msub>
                      <mi>&alpha;</mi>
                      <mi>k</mi>
                    </msub>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>(</mo>
                      <mn>7</mn>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                  <mo>+</mo>
                  <msubsup>
                    <mi>&gamma;</mi>
                    <mi>k</mi>
                    <mrow>
                      <mn>0</mn>
                      <mo>,</mo>
                      <mn>1</mn>
                    </mrow>
                  </msubsup>
                  <mo>+</mo>
                  <mrow>
                    <msub>
                      <mi>&beta;</mi>
                      <mi>k</mi>
                    </msub>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>(</mo>
                      <mn>7</mn>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                </mrow>
                <mo>,</mo>
              </mrow>
            </mtd>
          </mtr>
        </mtable>
        <mo>}</mo>
      </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
      <mi>max</mi>
      <mo>&CenterDot;</mo>
      <mrow>
        <mo>{</mo>
        <mtable>
          <mtr>
            <mtd>
              <mrow>
                <mrow>
                  <mrow>
                    <msub>
                      <mi>&alpha;</mi>
                      <mi>k</mi>
                    </msub>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>(</mo>
                      <mn>0</mn>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                  <mo>+</mo>
                  <mrow>
                    <msub>
                      <mi>&beta;</mi>
                      <mi>k</mi>
                    </msub>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>(</mo>
                      <mn>0</mn>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                </mrow>
                <mo>,</mo>
              </mrow>
            </mtd>
          </mtr>
          <mtr>
            <mtd>
              <mrow>
                <mrow>
                  <mrow>
                    <msub>
                      <mi>&alpha;</mi>
                      <mi>k</mi>
                    </msub>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>(</mo>
                      <mn>4</mn>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                  <mo>+</mo>
                  <mrow>
                    <msub>
                      <mi>&beta;</mi>
                      <mi>k</mi>
                    </msub>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>(</mo>
                      <mn>1</mn>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                </mrow>
                <mo>,</mo>
              </mrow>
            </mtd>
          </mtr>
          <mtr>
            <mtd>
              <mrow>
                <mrow>
                  <mrow>
                    <msub>
                      <mi>&alpha;</mi>
                      <mi>k</mi>
                    </msub>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>(</mo>
                      <mn>1</mn>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                  <mo>+</mo>
                  <msubsup>
                    <mi>&gamma;</mi>
                    <mi>k</mi>
                    <mrow>
                      <mn>0</mn>
                      <mo>,</mo>
                      <mn>1</mn>
                    </mrow>
                  </msubsup>
                  <mo>+</mo>
                  <mrow>
                    <msub>
                      <mi>&beta;</mi>
                      <mi>k</mi>
                    </msub>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>(</mo>
                      <mn>2</mn>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                </mrow>
                <mo>,</mo>
              </mrow>
            </mtd>
          </mtr>
          <mtr>
            <mtd>
              <mrow>
                <mrow>
                  <mrow>
                    <msub>
                      <mi>&alpha;</mi>
                      <mi>k</mi>
                    </msub>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>(</mo>
                      <mn>5</mn>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                  <mo>+</mo>
                  <msubsup>
                    <mi>&gamma;</mi>
                    <mi>k</mi>
                    <mrow>
                      <mn>0</mn>
                      <mo>,</mo>
                      <mn>1</mn>
                    </mrow>
                  </msubsup>
                  <mo>+</mo>
                  <mrow>
                    <msub>
                      <mi>&beta;</mi>
                      <mi>k</mi>
                    </msub>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>(</mo>
                      <mn>3</mn>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                </mrow>
                <mo>,</mo>
              </mrow>
            </mtd>
          </mtr>
          <mtr>
            <mtd>
              <mrow>
                <mrow>
                  <mrow>
                    <msub>
                      <mi>&alpha;</mi>
                      <mi>k</mi>
                    </msub>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>(</mo>
                      <mn>6</mn>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                  <mo>+</mo>
                  <msubsup>
                    <mi>&gamma;</mi>
                    <mi>k</mi>
                    <mrow>
                      <mn>0</mn>
                      <mo>,</mo>
                      <mn>1</mn>
                    </mrow>
                  </msubsup>
                  <mo>+</mo>
                  <mrow>
                    <msub>
                      <mi>&beta;</mi>
                      <mi>k</mi>
                    </msub>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>(</mo>
                      <mn>4</mn>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                </mrow>
                <mo>,</mo>
              </mrow>
            </mtd>
          </mtr>
          <mtr>
            <mtd>
              <mrow>
                <mrow>
                  <mrow>
                    <msub>
                      <mi>&alpha;</mi>
                      <mi>k</mi>
                    </msub>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>(</mo>
                      <mn>2</mn>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                  <mo>+</mo>
                  <msubsup>
                    <mi>&gamma;</mi>
                    <mi>k</mi>
                    <mrow>
                      <mn>0</mn>
                      <mo>,</mo>
                      <mn>1</mn>
                    </mrow>
                  </msubsup>
                  <mo>+</mo>
                  <mrow>
                    <msub>
                      <mi>&beta;</mi>
                      <mi>k</mi>
                    </msub>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>(</mo>
                      <mn>5</mn>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                </mrow>
                <mo>,</mo>
              </mrow>
            </mtd>
          </mtr>
          <mtr>
            <mtd>
              <mrow>
                <mrow>
                  <mrow>
                    <msub>
                      <mi>&alpha;</mi>
                      <mi>k</mi>
                    </msub>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>(</mo>
                      <mn>7</mn>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                  <mo>+</mo>
                  <mrow>
                    <msub>
                      <mi>&beta;</mi>
                      <mi>k</mi>
                    </msub>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>(</mo>
                      <mn>6</mn>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                </mrow>
                <mo>,</mo>
              </mrow>
            </mtd>
          </mtr>
          <mtr>
            <mtd>
              <mrow>
                <mrow>
                  <mrow>
                    <msub>
                      <mi>&alpha;</mi>
                      <mi>k</mi>
                    </msub>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>(</mo>
                      <mn>3</mn>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                  <mo>+</mo>
                  <mrow>
                    <msub>
                      <mi>&beta;</mi>
                      <mi>k</mi>
                    </msub>
                    <mo>&af;</mo>
                    <mrow>
                      <mo>(</mo>
                      <mn>7</mn>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                </mrow>
                <mo>,</mo>
              </mrow>
            </mtd>
          </mtr>
        </mtable>
        <mo>}</mo>
      </mrow>
    </mrow>
  </mrow>
</mrow>
</math>
<mathematica-file id="MATHEMATICA-00003" file="US20030002603A1-20030102-M00003.NB"/>
<image id="EMI-M00003" wi="216.027" he="95.05755" file="US20030002603A1-20030102-M00003.TIF" imf="TIFF" ti="MF"/>
</math-cwu>
</paragraph>
<paragraph id="P-0187" lvl="0"><number>&lsqb;0187&rsqb;</number> This equation consists of two extended ACS operations and may be performed in three stages beginning with the partitioning of the equation into four butterflies as follows: </paragraph>
<paragraph id="P-0188" lvl="7"><number>&lsqb;0188&rsqb;</number> Stage 1:</paragraph>
<paragraph lvl="0"><in-line-formula>llr<highlight><bold>1</bold></highlight>_s<highlight><bold>1</bold></highlight>_<highlight><bold>1</bold></highlight>&equals;max*(&agr;<highlight><subscript>k</subscript></highlight>(4)&plus;&ggr;<highlight><subscript>k</subscript></highlight><highlight><superscript>0,1</superscript></highlight>&plus;&bgr;<highlight><subscript>k</subscript></highlight>(0), &agr;<highlight><subscript>k</subscript></highlight>(0)&plus;&ggr;<highlight><subscript>k</subscript></highlight><highlight><superscript>0,1</superscript></highlight>&plus;&bgr;<highlight><subscript>k</subscript></highlight>(1))</in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula>llr<highlight><bold>0</bold></highlight>_s<highlight><bold>1</bold></highlight>_<highlight><bold>1</bold></highlight>&equals;max*(&agr;<highlight><subscript>k</subscript></highlight>(0)&plus;&bgr;<highlight><subscript>k</subscript></highlight>(0), &agr;<highlight><subscript>k</subscript></highlight>(4)&plus;&bgr;<highlight><subscript>k</subscript></highlight>(1))</in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula>llr<highlight><bold>1</bold></highlight>_s<highlight><bold>1</bold></highlight>_<highlight><bold>2</bold></highlight>&equals;max*(&agr;<highlight><subscript>k</subscript></highlight>(5)&plus;&bgr;<highlight><subscript>k</subscript></highlight>(2), &agr;<highlight><subscript>k</subscript></highlight>(1)&plus;&bgr;<highlight><subscript>k</subscript></highlight>(3))</in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula>llr<highlight><bold>0</bold></highlight>_s<highlight><bold>1</bold></highlight>_<highlight><bold>2</bold></highlight>&equals;max*(&agr;<highlight><subscript>k</subscript></highlight>(1)&plus;&ggr;<highlight><subscript>k</subscript></highlight><highlight><superscript>0,1</superscript></highlight>&plus;&bgr;<highlight><subscript>k</subscript></highlight>(2), &agr;<highlight><subscript>k</subscript></highlight>(5)&plus;&ggr;<highlight><subscript>k</subscript></highlight><highlight><superscript>0,1</superscript></highlight>&plus;&bgr;<highlight><subscript>k</subscript></highlight>(3))</in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula>llr<highlight><bold>1</bold></highlight>_s<highlight><bold>1</bold></highlight>_<highlight><bold>3</bold></highlight>&equals;max*(&agr;<highlight><subscript>k</subscript></highlight>(2)&plus;&bgr;<highlight><subscript>k</subscript></highlight>(4), &agr;<highlight><subscript>k</subscript></highlight>(6)&plus;&bgr;<highlight><subscript>k</subscript></highlight>(5))</in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula>llr<highlight><bold>0</bold></highlight>_s<highlight><bold>1</bold></highlight>_<highlight><bold>3</bold></highlight>&equals;max*(&agr;<highlight><subscript>k</subscript></highlight>(6)&plus;&ggr;<highlight><subscript>k</subscript></highlight><highlight><superscript>0,1</superscript></highlight>&plus;&bgr;<highlight><subscript>k</subscript></highlight>(4), &agr;<highlight><subscript>k</subscript></highlight>(2)&plus;&ggr;<highlight><subscript>k</subscript></highlight><highlight><superscript>0,1</superscript></highlight>&plus;&bgr;<highlight><subscript>k</subscript></highlight>(5))</in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula>llr<highlight><bold>1</bold></highlight>_s<highlight><bold>1</bold></highlight>_<highlight><bold>4</bold></highlight>&equals;max*(&agr;<highlight><subscript>k</subscript></highlight>(3)&plus;&ggr;<highlight><subscript>k</subscript></highlight><highlight><superscript>0,1</superscript></highlight>&plus;&bgr;<highlight><subscript>k</subscript></highlight>(6), &agr;<highlight><subscript>k</subscript></highlight>(7)&plus;&ggr;<highlight><subscript>k</subscript></highlight><highlight><superscript>0,1</superscript></highlight>&plus;&bgr;<highlight><subscript>k</subscript></highlight>(7))</in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula>llr<highlight><bold>0</bold></highlight>_s<highlight><bold>1</bold></highlight>_<highlight><bold>4</bold></highlight>&equals;max*(&agr;<highlight><subscript>k</subscript></highlight>(7)&plus;&bgr;<highlight><subscript>k</subscript></highlight>(6), &agr;<highlight><subscript>k</subscript></highlight>(3)&plus;&bgr;<highlight><subscript>k</subscript></highlight>(7))</in-line-formula></paragraph>
<paragraph id="P-0189" lvl="7"><number>&lsqb;0189&rsqb;</number> followed by stage 2:</paragraph>
<paragraph lvl="0"><in-line-formula>llr<highlight><bold>1</bold></highlight>_s<highlight><bold>2</bold></highlight>_<highlight><bold>1</bold></highlight>&equals;max*(llr<highlight><bold>1</bold></highlight>_s<highlight><bold>1</bold></highlight>_<highlight><bold>1</bold></highlight>, llr<highlight><bold>1</bold></highlight>_s<highlight><bold>1</bold></highlight>_<highlight><bold>2</bold></highlight>)</in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula>llr<highlight><bold>0</bold></highlight>_s<highlight><bold>2</bold></highlight>_<highlight><bold>1</bold></highlight>&equals;max*(llr<highlight><bold>0</bold></highlight>_s<highlight><bold>1</bold></highlight>_<highlight><bold>1</bold></highlight>, llr<highlight><bold>0</bold></highlight>_s<highlight><bold>1</bold></highlight>_<highlight><bold>2</bold></highlight>)</in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula>llr<highlight><bold>1</bold></highlight>_s<highlight><bold>2</bold></highlight>_<highlight><bold>2</bold></highlight>&equals;max*(llr<highlight><bold>1</bold></highlight>_s<highlight><bold>1</bold></highlight>_<highlight><bold>3</bold></highlight>, llr<highlight><bold>1</bold></highlight>_s<highlight><bold>1</bold></highlight>_<highlight><bold>4</bold></highlight>)</in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula>llr<highlight><bold>0</bold></highlight>_s<highlight><bold>2</bold></highlight>_<highlight><bold>2</bold></highlight>&equals;max*(llr<highlight><bold>0</bold></highlight>_s<highlight><bold>1</bold></highlight>_<highlight><bold>3</bold></highlight>, llr<highlight><bold>0</bold></highlight>_s<highlight><bold>1</bold></highlight>_<highlight><bold>4</bold></highlight>)</in-line-formula></paragraph>
<paragraph id="P-0190" lvl="7"><number>&lsqb;0190&rsqb;</number> then ending in stage 3:</paragraph>
<paragraph lvl="0"><in-line-formula>llr<highlight><bold>1</bold></highlight>_s<highlight><bold>3</bold></highlight>&equals;max*(llr<highlight><bold>1</bold></highlight>_s<highlight><bold>2</bold></highlight>_<highlight><bold>1</bold></highlight>, llr<highlight><bold>1</bold></highlight>_s<highlight><bold>2</bold></highlight>_<highlight><bold>2</bold></highlight>)</in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula>llr<highlight><bold>0</bold></highlight>_s<highlight><bold>3</bold></highlight>&equals;max*(llr<highlight><bold>0</bold></highlight>_s<highlight><bold>2</bold></highlight>_<highlight><bold>1</bold></highlight>, llr<highlight><bold>0</bold></highlight>_s<highlight><bold>2</bold></highlight>_<highlight><bold>2</bold></highlight>)</in-line-formula></paragraph>
<paragraph lvl="0"><in-line-formula>&Lgr;<highlight><subscript>k</subscript></highlight>&equals;llr<highlight><bold>1</bold></highlight>_s<highlight><bold>3</bold></highlight>&minus;llr<highlight><bold>0</bold></highlight>_s<highlight><bold>3</bold></highlight></in-line-formula></paragraph>
<paragraph id="P-0191" lvl="0"><number>&lsqb;0191&rsqb;</number> Thus, it will be appreciated that stage 1 of this process amounts to performing an extended LM_ACS operation four times, one for each of the four butterflies defined by (llr<highlight><bold>1</bold></highlight>_s<highlight><bold>1</bold></highlight>_<highlight><bold>1</bold></highlight>, llr<highlight><bold>0</bold></highlight>_s<highlight><bold>1</bold></highlight>_<highlight><bold>1</bold></highlight>), (llr<highlight><bold>1</bold></highlight>_s<highlight><bold>1</bold></highlight>_<highlight><bold>2</bold></highlight>, llr<highlight><bold>0</bold></highlight>_s<highlight><bold>1</bold></highlight>_<highlight><bold>2</bold></highlight>), (llr<highlight><bold>1</bold></highlight>_s<highlight><bold>1</bold></highlight>_<highlight><bold>3</bold></highlight>, llr<highlight><bold>0</bold></highlight>_s<highlight><bold>1</bold></highlight>_<highlight><bold>3</bold></highlight>), and (llr<highlight><bold>1</bold></highlight>_s<highlight><bold>1</bold></highlight>_<highlight><bold>4</bold></highlight>, llr<highlight><bold>0</bold></highlight>_s<highlight><bold>1</bold></highlight>_<highlight><bold>4</bold></highlight>). </paragraph>
<paragraph id="P-0192" lvl="0"><number>&lsqb;0192&rsqb;</number> The extended LM_ACS operation performed on each one of these four butterflies comprises the steps (i) to (iii) which are performed in respect of only those trellis transitions corresponding with a parity bit of a first value (e.g. bit <highlight><bold>0</bold></highlight>), and steps (iv) to (vi) which are performed in respect of only those trellis transitions corresponding with a parity bit of a second value (e.g. bit <highlight><bold>1</bold></highlight>): </paragraph>
<paragraph id="P-0193" lvl="2"><number>&lsqb;0193&rsqb;</number> (i) adding to the forward path metric value associated with a first encoder state of a given trellis butterfly; a first transition metric value associated with the forward transition of the encoder from the first encoder state to a first adjacent encoder state of the butterfly; and, the backward path metric value associated with the first adjacent encoder state to provide a first sum; </paragraph>
<paragraph id="P-0194" lvl="2"><number>&lsqb;0194&rsqb;</number> (ii) substantially simultaneously with step (i) adding to the forward path metric value associated with a second encoder state of the trellis butterfly concurrent with the first state; said first transition metric value associated with the forward transition of the encoder from the second encoder state to a second adjacent encoder state of the butterfly concurrent with the first adjacent encoder state; and, the backward path metric value associated with the second adjacent encoder state to provide a second sum; </paragraph>
<paragraph id="P-0195" lvl="2"><number>&lsqb;0195&rsqb;</number> (iii) comparing the first sum and the second sum and selecting the maximum value of the two to be a first maximum value; </paragraph>
<paragraph id="P-0196" lvl="2"><number>&lsqb;0196&rsqb;</number> (iv) adding to the forward path metric value associated with the second encoder state; a second transition metric value associated with the forward transition of the encoder from the second encoder state to the first adjacent encoder state; and, the backward path metric value associated with the first adjacent encoder state to provide a third sum; </paragraph>
<paragraph id="P-0197" lvl="2"><number>&lsqb;0197&rsqb;</number> (v) substantially simultaneously with step (iv) adding to the forward path metric value associated with the first encoder state; the second transition metric value associated with the forward transition of the encoder from the first encoder state to the second adjacent encoder state; and, the backward path metric value associated with the second adjacent encoder state to provide a fourth sum; </paragraph>
<paragraph id="P-0198" lvl="2"><number>&lsqb;0198&rsqb;</number> (vi) comparing said third sum and said fourth sum and selecting the maximum value of the two to be a second maximum value. </paragraph>
<paragraph id="P-0199" lvl="0"><number>&lsqb;0199&rsqb;</number> The sequence of steps (i), (ii) and (iii) is performed substantially simultaneously with the sequence of steps (iv), (v) and (vi) respectively and steps (i) to (vi) are repeated for the encoder states of all of the other three concurrent trellis butterflies to provide a set of first maximum values and a set of second maximum values. In the present example, the set of first maximum values comprises the four elements &lcub;llr<highlight><bold>1</bold></highlight>_s<highlight><bold>1</bold></highlight>_<highlight><bold>1</bold></highlight>, llr<highlight><bold>1</bold></highlight>_s<highlight><bold>1</bold></highlight>_<highlight><bold>2</bold></highlight>, llr<highlight><bold>1</bold></highlight>_s<highlight><bold>1</bold></highlight>_<highlight><bold>3</bold></highlight>, llr<highlight><bold>1</bold></highlight>_s<highlight><bold>1</bold></highlight>_<highlight><bold>4</bold></highlight>&rcub;, and the set of second maximum values comprises the four elements &lcub;llr<highlight><bold>0</bold></highlight>_s<highlight><bold>1</bold></highlight>_<highlight><bold>1</bold></highlight>, llr<highlight><bold>0</bold></highlight>_s<highlight><bold>1</bold></highlight>_<highlight><bold>2</bold></highlight>, llr<highlight><bold>0</bold></highlight>_s<highlight><bold>1</bold></highlight>_<highlight><bold>3</bold></highlight>, llr<highlight><bold>0</bold></highlight>_s<highlight><bold>1</bold></highlight>_<highlight><bold>4</bold></highlight>&rcub;. </paragraph>
<paragraph id="P-0200" lvl="0"><number>&lsqb;0200&rsqb;</number> To determine the LLR value for the trellis segment, the maximum element of the set of second maximum values is subtracted from the maximum element of the set of first maximum values to provide a Log-Likelihood Ratio according to stages 2 and 3 defined above. These two stages define an accelerated LLR operation (LLR_ACC) as explained below. </paragraph>
<paragraph id="P-0201" lvl="0"><number>&lsqb;0201&rsqb;</number> It will be appreciated that the &ldquo;Add&rdquo; component of the LM_ACS operation is here extended from being the addition of two quantities (e.g. path metric&plus;transition metric to the same one state) to the addition of three quantities (i.e. forward path metric&plus;transition metric to different states&plus;backward path metric). Accordingly, this extended LM_ACS operation requires two forward path metric values, two transition metric values and two backward path metric values to process a trellis butterfly. </paragraph>
<paragraph id="P-0202" lvl="0"><number>&lsqb;0202&rsqb;</number> The extended LM_ACS operation is schematically illustrated in <cross-reference target="DRAWINGS">FIG. 8</cross-reference>. This extended LM_ACS operation requires the same four metric values <highlight><bold>81</bold></highlight> (i.e. PM<highlight><bold>1</bold></highlight>,PM<highlight><bold>2</bold></highlight>,TM<highlight><bold>1</bold></highlight>,TM<highlight><bold>2</bold></highlight>) required of the LM_ACS operation when used in path metric updating, plus an additional two parameters <highlight><bold>82</bold></highlight> (i.e. BT<highlight><bold>1</bold></highlight> and BT<highlight><bold>2</bold></highlight>), which represent the backward path metric values associated with two concurrent butterfly states. In addition, the parameters PAR<highlight><bold>1</bold></highlight> and PAR<highlight><bold>2</bold></highlight> generalise the two transition metric values TM<highlight><bold>1</bold></highlight> and TM<highlight><bold>2</bold></highlight> in that each one of the two parameters may take any one of the values TM<highlight><bold>1</bold></highlight> and TM<highlight><bold>2</bold></highlight>, depending upon the function of the LM_ACS operation. </paragraph>
<paragraph id="P-0203" lvl="0"><number>&lsqb;0203&rsqb;</number> When used to perform simple metric updating, the LM_ACS operation requires the DSP to call metrics <highlight><bold>81</bold></highlight> from the DSP memory store, metrics <highlight><bold>82</bold></highlight> are not called from the aforementioned cache and their value is set to BT<highlight><bold>1</bold></highlight>&equals;0 and BT<highlight><bold>2</bold></highlight>&equals;0 by the DSP. Similarly, the DSP sets PAR<highlight><bold>1</bold></highlight>&equals;TM<highlight><bold>2</bold></highlight> and PAR<highlight><bold>2</bold></highlight>&equals;TM<highlight><bold>1</bold></highlight> and performs the LM_ACS operations <highlight><bold>83</bold></highlight> resulting two updated path metrics RM<highlight><bold>1</bold></highlight> And RM<highlight><bold>2</bold></highlight>. These two path metrics <highlight><bold>84</bold></highlight> are returned to the DSP memory store for later use in LLR calculation using the extended LM_ACS operation. </paragraph>
<paragraph id="P-0204" lvl="0"><number>&lsqb;0204&rsqb;</number> When used to perform stage 1 above, the extended LM_ACS operation requires the DSP to call metrics <highlight><bold>81</bold></highlight> and <highlight><bold>82</bold></highlight> from the DSP memory store. The DSP sets PAR<highlight><bold>1</bold></highlight>&equals;TM<highlight><bold>1</bold></highlight> and PAR<highlight><bold>2</bold></highlight>&equals;TM<highlight><bold>2</bold></highlight> and performs the LM_ACS operations <highlight><bold>83</bold></highlight> resulting two elements, RM<highlight><bold>1</bold></highlight> And RM<highlight><bold>2</bold></highlight>, of the sets of first and second maximum values respectively. These two elements <highlight><bold>84</bold></highlight> are returned to the DSP memory store. This process is repeated until all required butterflies are processed and the sets of first and second maximum values are complete. Stages 2 and 3 above may then be performed in respect of these two sets. </paragraph>
<paragraph id="P-0205" lvl="0"><number>&lsqb;0205&rsqb;</number> To accelerate the calculation of stages 2 and 3 of the LLR calculation, the operation LLR_ACC is introduced. In performing this operation, the DSP obtains all of its data from the cache within which are stored the elements of the first and second sets of maximum values. </paragraph>
<paragraph id="P-0206" lvl="0"><number>&lsqb;0206&rsqb;</number> The DSP calculates the LLR value by subtracting the maximum element of the set of second maximum values from the maximum element of said set of first maximum values according to the LLR_ACC operation having the steps of: </paragraph>
<paragraph id="P-0207" lvl="2"><number>&lsqb;0207&rsqb;</number> (i) choosing two elements from the set of first maximum values, comparing the two elements and selecting the maximum value of the two to be an element in a successive set of first maximum values; </paragraph>
<paragraph id="P-0208" lvl="2"><number>&lsqb;0208&rsqb;</number> (ii) substantially simultaneously with step (i) choosing two elements from the set of second maximum values, comparing the two elements and selecting the maximum value of the two to be an element in a successive set of second maximum values; </paragraph>
<paragraph id="P-0209" lvl="2"><number>&lsqb;0209&rsqb;</number> (iii) repeating steps (i) and (ii) in respect of all previously un-chosen elements of the sets of first and second maximum values until all elements of each have been so selected; </paragraph>
<paragraph id="P-0210" lvl="2"><number>&lsqb;0210&rsqb;</number> (iv) repeating steps (i) to (iii) in respect of each successive set of first and second maximum values until each the successive set ultimately comprises only one element; </paragraph>
<paragraph id="P-0211" lvl="2"><number>&lsqb;0211&rsqb;</number> (v) subtracting the value of the one element of the ultimate successive set of first maximum values from that of the one element of the ultimate successive set of second maximum values so as to provide a Log-Likelihood Ratio. </paragraph>
<paragraph id="P-0212" lvl="0"><number>&lsqb;0212&rsqb;</number> In this way the calculation of the Log-Likelihood Ratio (LLR) for a given encoder transition (time step within the encoder trellis) is accelerated, by performing in parallel the processing of date produced by the extended LM_ACS operation, thus providing an accelerated LLR (LLR_ACC) operation. </paragraph>
<paragraph id="P-0213" lvl="0"><number>&lsqb;0213&rsqb;</number> The LLR_ACC operation is schematically illustrated in <cross-reference target="DRAWINGS">FIG. 9</cross-reference>. This operation requires the DSP to retrieve four elements <highlight><bold>91</bold></highlight> (i.e. BT<highlight><bold>1</bold></highlight>,BT<highlight><bold>2</bold></highlight>,BT<highlight><bold>3</bold></highlight>,BT<highlight><bold>4</bold></highlight>) from the cache store into which they were copied during the extended LM_ACS operation of the DSP (denoted RM<highlight><bold>1</bold></highlight>, RM<highlight><bold>2</bold></highlight> etc at <highlight><bold>85</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 8</cross-reference>). The DSP then performs the LLR_ACC operation <highlight><bold>92</bold></highlight> simultaneously upon two pairs of the four input elements and outputs the two results <highlight><bold>94</bold></highlight>, RM<highlight><bold>1</bold></highlight> and RM<highlight><bold>2</bold></highlight>, to the same cache from whence they came overwriting two of the previously retrieved elements in that cache. These two cached values represent elements of a successive set of first maximum and second maximum elements respectively. Also, the DSP calculates the difference value RM<highlight><bold>1</bold></highlight>-RM<highlight><bold>2</bold></highlight> and stores the value in the main DSP memory store. This process is repeated until all elements of the sets of first and second maximum values have been processed, and the successive sets of first maximum values and second maximum values are complete (i.e. stage 2 is complete in this example). </paragraph>
<paragraph id="P-0214" lvl="0"><number>&lsqb;0214&rsqb;</number> Except for the last stage of the LLR_ACC operation (here stage 3) the difference value RM<highlight><bold>1</bold></highlight>-RM<highlight><bold>2</bold></highlight> is meaningless. At the last stage, the difference value is the LLR. </paragraph>
<paragraph id="P-0215" lvl="0"><number>&lsqb;0215&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10</cross-reference> illustrates an example of a DSP core extended to provide the metric calculation, LM_ACS, extended LM_ACS and LLR_ACC operations described above. The DSP includes conventional components such as an address generation unit (AGU) <highlight><bold>103</bold></highlight> having an address bus <highlight><bold>106</bold></highlight> connected to a program memory <highlight><bold>100</bold></highlight>, an address bus <highlight><bold>107</bold></highlight> connected to a first data memory <highlight><bold>100</bold></highlight>, and an address bus <highlight><bold>108</bold></highlight> connected to a second data memory <highlight><bold>102</bold></highlight>. Data busses <highlight><bold>109</bold></highlight> and <highlight><bold>110</bold></highlight> connected the two data memories <highlight><bold>101</bold></highlight> and <highlight><bold>102</bold></highlight> to the data ALU <highlight><bold>105</bold></highlight> of the DSP. A control bus <highlight><bold>111</bold></highlight> connects the program control unit (PCU) <highlight><bold>104</bold></highlight> of the DSP to the AGU <highlight><bold>103</bold></highlight> and to the data arithmetic logic unit (ALU) <highlight><bold>105</bold></highlight>. A program memory data bus <highlight><bold>112</bold></highlight> connects the program memory <highlight><bold>100</bold></highlight> to both the data ALU <highlight><bold>105</bold></highlight> and the PCU <highlight><bold>104</bold></highlight> of the DSP. </paragraph>
<paragraph id="P-0216" lvl="0"><number>&lsqb;0216&rsqb;</number> These components and connections of the DSP are generic and their function and interaction shall not be further discussed herein. </paragraph>
<paragraph id="P-0217" lvl="0"><number>&lsqb;0217&rsqb;</number> An extension to the generic portion of the DSP of <cross-reference target="DRAWINGS">FIG. 10</cross-reference> is provided by the metric calculation unit <highlight><bold>153</bold></highlight>, the LM_ACS unit <highlight><bold>154</bold></highlight>, the LLR_ACC unit <highlight><bold>155</bold></highlight>, the transition metric cache <highlight><bold>156</bold></highlight>, and the dual port cache <highlight><bold>157</bold></highlight> of the DSP. The metric calculating unit <highlight><bold>153</bold></highlight>, the LM_ACS unit <highlight><bold>154</bold></highlight> and the LLR_ACC unit <highlight><bold>155</bold></highlight> are connected to the generic portion of the DSP via a control bus <highlight><bold>150</bold></highlight> which is connected to the control bus <highlight><bold>111</bold></highlight> of the generic DSP, and consequently to those other DSP components connected to that control bus. Each of the metric calculating unit <highlight><bold>153</bold></highlight>, the LM_ACS unit <highlight><bold>154</bold></highlight> and the LLR_ACC unit <highlight><bold>155</bold></highlight> has two data interfaces each connected to a respective one of the two data memories <highlight><bold>101</bold></highlight> and <highlight><bold>102</bold></highlight> of the DSP via data busses <highlight><bold>151</bold></highlight> and <highlight><bold>152</bold></highlight>. </paragraph>
<paragraph id="P-0218" lvl="0"><number>&lsqb;0218&rsqb;</number> The metric calculating unit <highlight><bold>153</bold></highlight> is able to calculate transition metric values in accordance with the above described methods, and to supply transition metric values for storage in the data memories <highlight><bold>101</bold></highlight>, <highlight><bold>102</bold></highlight> of the DSP and in the metric cache <highlight><bold>156</bold></highlight> thereof. The LM_ACS unit <highlight><bold>154</bold></highlight> is able to the LM_ACS operation in updating path metric values. Transition metric values, path metric values (forward and backward), and other data values are retrievable by the LM_ACS unit <highlight><bold>154</bold></highlight> from data memories <highlight><bold>101</bold></highlight> and <highlight><bold>102</bold></highlight> and cache <highlight><bold>156</bold></highlight>, for this purpose. </paragraph>
<paragraph id="P-0219" lvl="0"><number>&lsqb;0219&rsqb;</number> Input lines <highlight><bold>201</bold></highlight> and <highlight><bold>203</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 11</cross-reference> can each be independently mapped to data busses <highlight><bold>151</bold></highlight> and <highlight><bold>152</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 10</cross-reference>. Input lines <highlight><bold>202</bold></highlight> and <highlight><bold>204</bold></highlight> can each be independently mapped to data busses <highlight><bold>151</bold></highlight>, <highlight><bold>152</bold></highlight> or <highlight><bold>159</bold></highlight>. The return value line <highlight><bold>217</bold></highlight> is mapped to both data busses <highlight><bold>151</bold></highlight> and <highlight><bold>160</bold></highlight> while line <highlight><bold>217</bold></highlight>&prime; is mapped to both data busses <highlight><bold>152</bold></highlight> and <highlight><bold>161</bold></highlight>. Updated path metric values are returned to the DSP data memories <highlight><bold>101</bold></highlight> and <highlight><bold>102</bold></highlight> from the LM_ACS unit <highlight><bold>154</bold></highlight>. </paragraph>
<paragraph id="P-0220" lvl="0"><number>&lsqb;0220&rsqb;</number> The accelerated LLR operation is performed by the LLR_ACC unit <highlight><bold>155</bold></highlight>. This unit retrieved data values from the dual port cache <highlight><bold>157</bold></highlight> via dual data busses <highlight><bold>160</bold></highlight> and <highlight><bold>161</bold></highlight>, and also returns data values thereto. Data values calculated by the LLR_ACC unit are also output to the data memories <highlight><bold>101</bold></highlight> and <highlight><bold>102</bold></highlight> of the DSP. These data values include the sets of first and second maximum values, and LLR values. </paragraph>
<paragraph id="P-0221" lvl="0"><number>&lsqb;0221&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 11</cross-reference> illustrates an example of the architecture of the LM_ACS unit <highlight><bold>154</bold></highlight> suitable for performing the extended LM_ACS operation. </paragraph>
<paragraph id="P-0222" lvl="0"><number>&lsqb;0222&rsqb;</number> The LM_ACS unit of the DSP comprises a calculation unit <highlight><bold>209</bold></highlight>. The calculation unit is operable to add path metric values to transition metric data values concurrently received at its data input ports to give updated path metric values, compare pairs of concurrent updated path metrics, and concurrently output at separate ones of each data output port <highlight><bold>217</bold></highlight> and <highlight><bold>217</bold></highlight>&prime; the maximum of the two compared updated path metric pairs in accordance with the &ldquo;max*&rdquo; component of the LM_ACS operation described above. </paragraph>
<paragraph id="P-0223" lvl="0"><number>&lsqb;0223&rsqb;</number> The calculation unit has a first data input port <highlight><bold>201</bold></highlight> for receiving path metric data values PM<highlight><bold>1</bold></highlight>, a second data input port <highlight><bold>202</bold></highlight> for receiving transition metric data values (TM<highlight><bold>1</bold></highlight>), a third data input port <highlight><bold>203</bold></highlight> for receiving path metric data values (PM<highlight><bold>2</bold></highlight>), a fourth data input port <highlight><bold>204</bold></highlight> for receiving transition metric data values (TM<highlight><bold>2</bold></highlight>), a fifth input port <highlight><bold>205</bold></highlight> for receiving transition metric values (PAR<highlight><bold>1</bold></highlight>), a sixth input port <highlight><bold>206</bold></highlight> for receiving transition metric values (PAR<highlight><bold>2</bold></highlight>), a first feedback data input port <highlight><bold>207</bold></highlight> for receiving backward path metric values (BT<highlight><bold>1</bold></highlight>), and a second feedback data input port <highlight><bold>208</bold></highlight> for receiving backward path metric values (BT<highlight><bold>2</bold></highlight>). </paragraph>
<paragraph id="P-0224" lvl="0"><number>&lsqb;0224&rsqb;</number> The calculation unit is operable to perform the LM_ACS operation illustrated in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>, and the extended LM_ACS operation illustrated in <cross-reference target="DRAWINGS">FIG. 8</cross-reference> depending upon its selected function. The LM_ACS unit has a function selection apparatus comprising transition metric selector gates <highlight><bold>232</bold></highlight> and <highlight><bold>232</bold></highlight>&prime;, and path metric selector gate <highlight><bold>227</bold></highlight>. </paragraph>
<paragraph id="P-0225" lvl="0"><number>&lsqb;0225&rsqb;</number> The transition metric selector gate <highlight><bold>232</bold></highlight> (<highlight><bold>232</bold></highlight>&prime;) has a first input <highlight><bold>233</bold></highlight> (<highlight><bold>233</bold></highlight>&prime;) and a second data input <highlight><bold>234</bold></highlight> (<highlight><bold>234</bold></highlight>&prime;) for concurrently receiving transition metric values TM<highlight><bold>2</bold></highlight> and TM<highlight><bold>1</bold></highlight>, and a data output <highlight><bold>235</bold></highlight> (<highlight><bold>235</bold></highlight>&prime;) for outputting one of those two values as the parameter PAR<highlight><bold>1</bold></highlight> (PAR<highlight><bold>2</bold></highlight>) to the fifth data input <highlight><bold>205</bold></highlight> of the calculation unit. The path metric selector gate <highlight><bold>227</bold></highlight> has two data input ports <highlight><bold>228</bold></highlight> and <highlight><bold>229</bold></highlight>, connected to respective output ports <highlight><bold>217</bold></highlight> (<highlight><bold>217</bold></highlight>&prime;) of the calculation unit <highlight><bold>209</bold></highlight> for receiving backward path metric values output therefrom. The first data output port <highlight><bold>230</bold></highlight> of the path metric selector gate <highlight><bold>227</bold></highlight> is connected to the second feedback data input port <highlight><bold>208</bold></highlight> of the calculation unit <highlight><bold>209</bold></highlight>. Similarly, the second data output port <highlight><bold>231</bold></highlight> of the path metric selector gate <highlight><bold>227</bold></highlight> is connected to the first feedback data input port <highlight><bold>207</bold></highlight> of the calculation unit. </paragraph>
<paragraph id="P-0226" lvl="0"><number>&lsqb;0226&rsqb;</number> Thus, data values BT<highlight><bold>1</bold></highlight> and BT<highlight><bold>2</bold></highlight> may be input to the calculation unit via the second and first feedback data output ports <highlight><bold>231</bold></highlight> and <highlight><bold>230</bold></highlight>, respectively, of the path metric selector gate <highlight><bold>227</bold></highlight>. The path metric selector gate may also set the values BT<highlight><bold>1</bold></highlight> and BT<highlight><bold>2</bold></highlight> to zero. </paragraph>
<paragraph id="P-0227" lvl="0"><number>&lsqb;0227&rsqb;</number> In its first selection state, the function section apparatus causes the LM_ACS unit to perform path metric updates by having the path metric selector gate <highlight><bold>227</bold></highlight> set BT<highlight><bold>1</bold></highlight>&equals;0 and BT<highlight><bold>2</bold></highlight>&equals;0, while simultaneously having transition metric selector gates <highlight><bold>232</bold></highlight> and <highlight><bold>232</bold></highlight>&prime; set PAR<highlight><bold>1</bold></highlight>&equals;TM<highlight><bold>2</bold></highlight> and PAR<highlight><bold>2</bold></highlight>&equals;TM<highlight><bold>1</bold></highlight> respectively. Updated transition metric values RM<highlight><bold>1</bold></highlight> and RM<highlight><bold>2</bold></highlight> output from the calculation unit <highlight><bold>209</bold></highlight> are stored in the main memory store <highlight><bold>219</bold></highlight> of the DSP and, for backward path metric values, are also copied back into a dual port cache store (not shown). </paragraph>
<paragraph id="P-0228" lvl="0"><number>&lsqb;0228&rsqb;</number> In its second selection state, the function selection apparatus causes the LM_ACS unit to perform the extended LM_ACS operation as part of an LLR calculation (see stage 1 above). This is achieved by having the path metric selector gate <highlight><bold>227</bold></highlight> input the values BT<highlight><bold>1</bold></highlight> and BT<highlight><bold>2</bold></highlight>, from the output ports <highlight><bold>217</bold></highlight> (<highlight><bold>217</bold></highlight>&prime;) of the calculation unit, into the first and second feedback input ports of the calculation unit without setting them to zero. Simultaneously transition metric selector units <highlight><bold>232</bold></highlight> and <highlight><bold>232</bold></highlight>&prime; set PAR<highlight><bold>1</bold></highlight>&equals;TM<highlight><bold>1</bold></highlight> and PAR<highlight><bold>2</bold></highlight>&equals;TM<highlight><bold>2</bold></highlight> respectively. Data elements RM<highlight><bold>1</bold></highlight> and RM<highlight><bold>2</bold></highlight> output from the calculating unit <highlight><bold>209</bold></highlight> are stored in the main memory store <highlight><bold>219</bold></highlight> of the DSP and, for later use in LLR_ACC operations, are also copied back into the dual port cache store (not shown). </paragraph>
<paragraph id="P-0229" lvl="0"><number>&lsqb;0229&rsqb;</number> A sample architecture for the LLR_ACC unit (<highlight><bold>115</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 10</cross-reference>) is illustrated in <cross-reference target="DRAWINGS">FIG. 12</cross-reference>. This unit is suitable to perform &ldquo;stage 2&rdquo; and &ldquo;stage 3&rdquo; discussed above. The LLR_ACC unit comprises a first compare-and-select unit <highlight><bold>300</bold></highlight> and a second identical compare-and-select unit <highlight><bold>300</bold></highlight>&prime;. Like reference numerals indicate like parts in the two units <highlight><bold>300</bold></highlight> and <highlight><bold>300</bold></highlight>&prime; (with primes being added to the reference numerals of the latter). </paragraph>
<paragraph id="P-0230" lvl="0"><number>&lsqb;0230&rsqb;</number> The compare-and-select unit <highlight><bold>300</bold></highlight> of the LLR_ACC unit comprises a first data input port <highlight><bold>301</bold></highlight> for receiving via data interface <highlight><bold>319</bold></highlight>, data elements from one of the sets of first and second maximum values stored within the dual port cache <highlight><bold>321</bold></highlight> (cache data addresses &lsqb;0 . . . 15&rsqb;), and a second data input port <highlight><bold>302</bold></highlight> for concurrently receiving via data interface <highlight><bold>320</bold></highlight>, data elements from the other of the sets of first and second maximum values stored within the dual port cache <highlight><bold>321</bold></highlight> (cache data addresses &lsqb;16 . . . 31&rsqb;). </paragraph>
<paragraph id="P-0231" lvl="0"><number>&lsqb;0231&rsqb;</number> It is to be noted that the cache <highlight><bold>321</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 12</cross-reference> is the same cache as the cache <highlight><bold>157</bold></highlight> illustrated in <cross-reference target="DRAWINGS">FIG. 10</cross-reference>. Consequently, lines <highlight><bold>319</bold></highlight> and <highlight><bold>320</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 12</cross-reference> also correspond with lines <highlight><bold>160</bold></highlight> and <highlight><bold>161</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 10</cross-reference>. </paragraph>
<paragraph id="P-0232" lvl="0"><number>&lsqb;0232&rsqb;</number> Furthermore, output line <highlight><bold>318</bold></highlight> maps to either one of data busses <highlight><bold>151</bold></highlight> or <highlight><bold>152</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 10</cross-reference>. </paragraph>
<paragraph id="P-0233" lvl="0"><number>&lsqb;0233&rsqb;</number> Data values concurrently received at these two input ports are simultaneously input to a compare unit <highlight><bold>307</bold></highlight> via the two data input ports <highlight><bold>303</bold></highlight> and <highlight><bold>305</bold></highlight> thereof, and input to the difference unit <highlight><bold>308</bold></highlight> via its two data input ports <highlight><bold>304</bold></highlight> and <highlight><bold>306</bold></highlight>. The difference unit <highlight><bold>308</bold></highlight> determines the absolute value of the arithmetic difference (i.e. &verbar;b&minus;a&verbar;) between the data values concurrently input at its two data input ports (i.e. value &ldquo;b&rdquo; at port <highlight><bold>304</bold></highlight> and value &ldquo;a&rdquo; at port <highlight><bold>306</bold></highlight>), and also determines the sign of this difference. The absolute value of this difference is output to a look-up table (LUT) <highlight><bold>310</bold></highlight> while the sign of this difference is output to a third data input <highlight><bold>309</bold></highlight> of the compare unit <highlight><bold>307</bold></highlight>. </paragraph>
<paragraph id="P-0234" lvl="0"><number>&lsqb;0234&rsqb;</number> On the basis of the sign value input to at port <highlight><bold>309</bold></highlight>, the compare unit <highlight><bold>307</bold></highlight> selects the maximum of the two data values concurrently input to it at data input ports <highlight><bold>303</bold></highlight> and <highlight><bold>305</bold></highlight>, and outputs the selected maximum data value on output port <highlight><bold>312</bold></highlight> to an adder unit <highlight><bold>315</bold></highlight>. Simultaneously with this operation, a correction term is retrieved from the look-up table <highlight><bold>310</bold></highlight>, on the basis of the data input to it from difference unit <highlight><bold>308</bold></highlight>, and is output via output port <highlight><bold>311</bold></highlight> to adder unit <highlight><bold>315</bold></highlight>. The adder unit then adds the correction value to the selected maximum value and outputs the result at the output port <highlight><bold>314</bold></highlight> of the compare-and-select unit <highlight><bold>300</bold></highlight>. </paragraph>
<paragraph id="P-0235" lvl="0"><number>&lsqb;0235&rsqb;</number> The above explanation applies to the parallel compare-and-select unit <highlight><bold>300</bold></highlight>&prime; with like items given like (primed) reference numerals. </paragraph>
<paragraph id="P-0236" lvl="0"><number>&lsqb;0236&rsqb;</number> Thus, the compare-and-select units <highlight><bold>300</bold></highlight> (<highlight><bold>300</bold></highlight>&prime;) perform the max* operation as defined by:</paragraph>
<paragraph lvl="0"><in-line-formula>max*(<highlight><italic>a,b</italic></highlight>)&equals;max(<highlight><italic>a,b</italic></highlight>)&plus;ln(1&plus;exp(<highlight><italic>&minus;&verbar;a&minus;b &verbar;</italic></highlight>)).</in-line-formula></paragraph>
<paragraph id="P-0237" lvl="0"><number>&lsqb;0237&rsqb;</number> The correction term ln(1&plus;exp(&minus;&verbar;a&minus;b&verbar;)) being added to the result of the result of the ACS operation associated with the &ldquo;max&rdquo; operation to provide the full Jacobian logarithm of which the &ldquo;max&rdquo; operator is only an approximation. This is implemented in the digital signal processor of the present embodiment by use of the look-up table (LUT) <highlight><bold>310</bold></highlight> (<highlight><bold>310</bold></highlight>&prime;) as explained above. </paragraph>
<paragraph id="P-0238" lvl="0"><number>&lsqb;0238&rsqb;</number> Thus, the compare-and-select unit <highlight><bold>300</bold></highlight> (<highlight><bold>300</bold></highlight>&prime;) performs the &ldquo;max*&rdquo; operation upon the concurrently input data elements and outputs the result at output port <highlight><bold>314</bold></highlight> (<highlight><bold>314</bold></highlight>&prime;) to an input port <highlight><bold>316</bold></highlight> (<highlight><bold>316</bold></highlight>&prime;) of a subtracting unit <highlight><bold>315</bold></highlight> and to the dual port cache <highlight><bold>321</bold></highlight> (via data bus <highlight><bold>317</bold></highlight> (<highlight><bold>317</bold></highlight>&prime;)) for use in later stages of the LLR_ACC operation (e.g. &ldquo;stage 3&rdquo; above). </paragraph>
<paragraph id="P-0239" lvl="0"><number>&lsqb;0239&rsqb;</number> The subtracting unit <highlight><bold>315</bold></highlight> subtracts data values input at port <highlight><bold>316</bold></highlight>&prime; from data values concurrently input at port <highlight><bold>316</bold></highlight> and outputs the result <highlight><bold>318</bold></highlight>. After the final stage of the LLR_ACC operation has been performed, the output result <highlight><bold>318</bold></highlight> of the subtracting unit <highlight><bold>315</bold></highlight> is the LLR value. </paragraph>
<paragraph id="P-0240" lvl="0"><number>&lsqb;0240&rsqb;</number> It is to be understood that variations and modifications to the above described embodiments of the present invention, as would be readily apparent to the skilled person, may be made without departing from the scope of the present invention. </paragraph>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method for calculating path metric values of a convolutional encoder for use in decoding according to a Log-MAP algorithm a bit sequence encoded thereby and received through a noisy channel, the method comprising the steps of: 
<claim-text>(i) adding to the path metric value associated with a first encoder state a first transition metric value associated with the transition of said encoder from said first encoder state to a first adjacent encoder state thereby providing a first path metric value for said first adjacent encoder state; </claim-text>
<claim-text>(ii) substantially simultaneously with step (i) adding to the path metric value associated with a second encoder state concurrent with said first state a second transition metric value associated with the transition of said encoder from said second encoder state to said first adjacent encoder state thereby providing a second path metric value for said first adjacent encoder state; </claim-text>
<claim-text>(iii) comparing said first path metric value for said first adjacent encoder state to said second path metric value therefor and selecting the maximum of the two to be the path metric value associated with that adjacent encoder state; </claim-text>
<claim-text>(iv) adding to the path metric value associated with said first encoder state said second transition metric value associated with the transition of said encoder from said first encoder state to a second adjacent encoder state concurrent with said first adjacent encoder state thereby providing a first path metric value for said second adjacent encoder state; </claim-text>
<claim-text>(v) substantially simultaneously with step (iv) adding to the path metric value associated with said second encoder state said second transition metric value associated with the transition of said encoder from said second encoder state to said second adjacent encoder state thereby providing a second path metric value for said second adjacent encoder state; </claim-text>
<claim-text>(vi) comparing said first path metric values for said second adjacent encoder state to said second path metric value therefore and selecting the maximum of the two to be the path metric value associated with that adjacent encoder state; </claim-text>
<claim-text>wherein said encoder states and said adjacent encoder states define a trellis butterfly and the sequence of steps (i), (ii) and (iii) are performed substantially simultaneously with the sequence of steps (iv), (v) and (vi) respectively. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. A method according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein the correction term:</claim-text>
<claim-text><in-line-formula>ln(1&plus;exp(&minus;&Dgr;))</in-line-formula></claim-text>
<claim-text>is added to the path metric value associated with a given adjacent encoder state, where &Dgr; is the absolute value of the difference between said first path metric value of said given adjacent encoder state and said second path metric value thereof. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. A method according to any preceding claim wherein steps (i) to (vi) are repeated for all other concurrent trellis butterflies. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. A method according to <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference> wherein the path metric values for all of said encoder states and said adjacent encoder states are forward path metrics calculated by forward recursion wherein all of said adjacent encoder states succeed all of said encoder states. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. A method according to <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference> wherein the path metric values for all of said encoder states and said adjacent encoder states are backward path metrics calculated by backward recursion wherein all of said adjacent encoder states precede all of said encoder states. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. A method for calculating Log-Likelihood Ratio values for state transitions of a convolutional encoder for use in decoding according to a Log-MAP algorithm a bit sequence encoded thereby and received through a noisy channel, the method comprising the steps (i) to (iii) which are performed in respect of only those transitions corresponding with a parity bit of a first value, and steps (iv) to (vi) which are performed in respect of only those transitions corresponding with a parity bit of a second value: 
<claim-text>(i) adding to the forward path metric value associated with a first encoder state of a given trellis butterfly a first transition metric value associated with the forward transition of said encoder from said first encoder state to a first adjacent encoder state of said butterfly; and, the backward path metric value associated with said first adjacent encoder state to provide a first sum; </claim-text>
<claim-text>(ii) substantially simultaneously with step (i) adding to the forward path metric value associated with a second encoder state of said trellis butterfly concurrent with said first state; said first transition metric value associated with the forward transition of said encoder from said second encoder state to a second adjacent encoder state of said butterfly concurrent with said first adjacent encoder state; and, the backward path metric value associated with said second adjacent encoder state to provide a second sum; </claim-text>
<claim-text>(iii) comparing said first sum and said second sum and selecting the maximum value of the two to be a first maximum value; </claim-text>
<claim-text>(iv) adding to the forward path metric value associated with said second encoder state; a second transition metric value associated with the forward transition of said encoder from said second encoder state to said first adjacent encoder state; and, the backward path metric value associated with said first adjacent encoder state to provide a third sum; </claim-text>
<claim-text>(v) substantially simultaneously with step (iv) adding to the forward path metric value associated with said first encoder state; said second transition metric value associated with the forward transition of said encoder from said first encoder state to said second adjacent encoder state; and, the backward path metric value associated with said second adjacent encoder state to provide a fourth sum; </claim-text>
<claim-text>(vi) comparing said third sum and said fourth sum and selecting the maximum value of the two to be a second maximum value; </claim-text>
<claim-text>the sequence of steps (i), (ii) and (iii) being performed substantially simultaneously with the sequence of steps (iv), (v) and (vi) respectively and steps (i) to (vi) being repeated for the encoder states of all other concurrent trellis butterflies to provide a set of first maximum values and a set of second maximum values, wherein the maximum element of said set of second maximum values is subtracted from the maximum element of said set of first maximum values to provide a Log-Likelihood Ratio. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. A method for calculating Log-Likelihood-Ratio values according to <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference> wherein the maximum element of said set of second maximum values is subtracted from the maximum element of said set of first maximum values according to the steps of: 
<claim-text>(i) choosing two elements from said set of first maximum values, comparing said two elements and selecting the maximum value of the two to be an element in a successive set of first maximum values; </claim-text>
<claim-text>(ii) substantially simultaneously with step (i) choosing two elements from said set of second maximum values, comparing said two elements and selecting the maximum value of the two to be an element in a successive set of second maximum values; </claim-text>
<claim-text>(iii) repeating steps (i) and (ii) in respect of all previously unchosen elements of said sets of first and second maximum values until all elements of each have been so selected; </claim-text>
<claim-text>(iv) repeating steps (i) to (iii) in respect of each successive set of first and second maximum values until each said successive set ultimately comprises only one element; </claim-text>
<claim-text>(v) subtracting the value of the one element of said ultimate successive set of first maximum values from that of the one element of said ultimate successive set of second maximum values so as to provide a Log-Likelihood Ratio. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. A method according to <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference> wherein the correction term:</claim-text>
<claim-text><in-line-formula>ln(1&plus;exp(&minus;&Dgr;))</in-line-formula></claim-text>
<claim-text>is added to any quantity selected as being the maximum of two quantities compared for that purpose, where &Dgr; is the absolute value of the difference between said quantities compared. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. A method for calculating Log-Likelihood Ratios according to any one of claims <highlight><bold>6</bold></highlight>, <highlight><bold>7</bold></highlight> or <highlight><bold>8</bold></highlight> wherein said forward path metric values are calculated according to a method comprising the steps of: 
<claim-text>(i) adding to the path metric value associated with a first encoder state a first transition metric value associated with the transition of said encoder from said first encoder state to a first adjacent encoder state thereby providing a first path metric value for said first adjacent encoder state; </claim-text>
<claim-text>(ii) substantially simultaneously with step (i) adding to the path metric value associated with a second encoder state concurrent with said first state a second transition metric value associated with the transition of said encoder from said second encoder state to said first adjacent encoder state thereby providing a second path metric value for said first adjacent encoder state; </claim-text>
<claim-text>(iii) comparing said first path metric value for said first adjacent encoder state to said second path metric value therefor and selecting the maximum of the two to be the path metric value associated with that adjacent encoder state; </claim-text>
<claim-text>(iv) adding to the path metric value associated with said first encoder state said second transition metric value associated with the transition of said encoder from said first encoder state to a second adjacent encoder state concurrent with said first adjacent encoder state thereby providing a first path metric value for said second adjacent encoder state; </claim-text>
<claim-text>(v) substantially simultaneously with step (iv) adding to the path metric value associated with said second encoder state said second transition metric value associated with the transition of said encoder from said second encoder state to said second adjacent encoder state thereby providing a second path metric value for said second adjacent encoder state; </claim-text>
<claim-text>(vi) comparing said first path metric values for said second adjacent encoder state to said second path metric value therefore and selecting the maximum of the two to be the path metric value associated with that adjacent encoder state; </claim-text>
<claim-text>wherein the path metric values for all of said encoder states and said adjacent encoder states are forward path metrics calculated by forward recursion such that all of said adjacent encoder states succeed all of said encoder states, and the sequence of steps (i), (ii) and (iii) are performed substantially simultaneously with the sequence of steps (iv), (v) and (vi) respectively. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. A method for calculating Log-Likelihood Ratios according to any one of claims <highlight><bold>6</bold></highlight>, <highlight><bold>7</bold></highlight> or <highlight><bold>8</bold></highlight> wherein said backward path metric values are calculated according to a method comprising the steps of: 
<claim-text>(i) adding to the path metric value associated with a first encoder state a first transition metric value associated with the transition of said encoder from said first encoder state to a first adjacent encoder state thereby providing a first path metric value for said first adjacent encoder state; </claim-text>
<claim-text>(ii) substantially simultaneously with step (i) adding to the path metric value associated with a second encoder state concurrent with said first state a second transition metric value associated with the transition of said encoder from said second encoder state to said first adjacent encoder state thereby providing a second path metric value for said first adjacent encoder state; </claim-text>
<claim-text>(iii) comparing said first path metric value for said first adjacent encoder state to said second path metric value therefore and selecting the maximum of the two to be the path metric value associated with that adjacent encoder state; </claim-text>
<claim-text>(iv) adding to the path metric value associated with said first encoder state said second transition metric value associated with the transition of said encoder from said first encoder state to a second adjacent encoder state concurrent with said first adjacent encoder state thereby providing a first path metric value for said second adjacent encoder state; </claim-text>
<claim-text>(v) substantially simultaneously with step (iv) adding to the path metric value associated with said second encoder state said second transition metric value associated with the transition of said encoder from said second encoder state to said second adjacent encoder state thereby providing a second path metric value for said second adjacent encoder state; </claim-text>
<claim-text>(vi) comparing said first path metric values for said second adjacent encoder state to said second path metric value therefor and selecting the maximum of the two to be the path metric value associated with that adjacent encoder state; </claim-text>
<claim-text>wherein the path metric values for all of said encoder states and said adjacent encoder states are backward path metrics calculated by backward recursion wherein all of said adjacent encoder states precede all of said encoder states, and the sequence of steps (i), (ii) and (iii) are performed substantially simultaneously with the sequence of steps (iv), (v) and (vi) respectively. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. A method according any preceding claim wherein said first value of parity bits output from said encoder is &plus;1 and said second value thereof is &minus;1. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. A method for calculating transition metric values (&ggr;) for use in decoding according to <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference> wherein: wherein:</claim-text>
<claim-text><in-line-formula>&ggr;(&minus;1,&minus;1)&equals;0;</in-line-formula>
<claim-text>the encoder transition associated with the output therefrom of a systematic and a parity bit of values &minus;1 and &minus;1 respectively is assigned a first transition metric value of</claim-text>
<claim-text><in-line-formula>&ggr;(&minus;1,&minus;1)&equals;0;</in-line-formula></claim-text>
<claim-text>the encoder transition associated with the output therefrom of a systematic and a parity bit of values &minus;1 and &plus;1 respectively is assigned a second transition metric value of</claim-text>
<claim-text><in-line-formula>&ggr;(&minus;1,&plus;1)&equals;s<highlight><bold>1</bold></highlight>;</in-line-formula></claim-text>
<claim-text>the encoder transition associated with the output therefrom of a systematic and a parity bit of values &plus;1 and &minus;1 respectively is assigned a third transition metric value</claim-text>
<claim-text><in-line-formula>&ggr;(&plus;1,&minus;1)&equals;s<highlight><bold>2</bold></highlight>;</in-line-formula></claim-text>
<claim-text>the encoder transition associated with the output therefrom of a systematic and a parity bit of values &plus;1 and &plus;1 respectively is assigned a transition metric value &ggr;(&plus;1,&plus;1) equal to the sum of said first and second transition metric values; </claim-text>
<claim-text>where the terms s<highlight><bold>1</bold></highlight> and s<highlight><bold>2</bold></highlight> are dependent on the signal-to-noise ratio associated with the received bit sequence, the received parity and systematic bits corresponding with the bits output from the encoder, and at least an estimate of the a priori probability of the encoder transition. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. A method for calculating transition metric values (&ggr;) for use in decoding according to <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference> where</claim-text>
<claim-text><in-line-formula>&ggr;(&minus;1,&plus;1)&equals;4&times;<highlight><italic>SNR&times;y</italic></highlight><highlight><subscript>p</subscript></highlight></in-line-formula><in-line-formula>and</in-line-formula><in-line-formula>&ggr;(&plus;1,&minus;1)&equals;4&times;<highlight><italic>SNR&times;y</italic></highlight><highlight><subscript>s</subscript></highlight><highlight><italic>&plus;z,</italic></highlight></in-line-formula></claim-text>
<claim-text>wherein the term SNR is the signal-to-noise ratio associated with said received bit sequence, y<highlight><subscript>p </subscript></highlight>and y<highlight><subscript>s </subscript></highlight>are the received parity and systematic bits respectively corresponding with said bits output from the encoder, and the term z represents at least an estimate of the a priori probability of the encoder transition. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. Apparatus for calculating Log-Likelihood Ratios according to the method of any one of <dependent-claim-reference depends_on="CLM-00007">claims 7</dependent-claim-reference> to <dependent-claim-reference depends_on="CLM-00010">10</dependent-claim-reference>, the apparatus comprising: 
<claim-text>cache means operable to store said set of first maximum values, said set of second maximum values and said successive sets thereof; </claim-text>
<claim-text>two compare-and-select means each one possessing a first data input port connected to a data output port of said cache means, a second data input port connected to a data output port of said cache means, and a data output port connected to a data input port of said cache means; </claim-text>
<claim-text>wherein one of said compare-and-select means is operable to receive at its first and second data input ports elements of said set of first maximum values output form said cache means, and the other of said compare-and-select means is operable to receive at its first and second data input ports elements of said set of second maximum values output from said cache means, each said compare-and-select means being operable to compare concurrent first and second inputs and to output via said output port the element which is the maximum of the two. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. Apparatus for calculating Log-Likelihood Ratios according to <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference> wherein the element output from either compare-and-select means is input into said cache means for storage as an element in the respective successive set of maximum values. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. Apparatus for calculating Log-Likelihood Ratios according to <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference> wherein the output port of each compare-and-select means is connected to one of a first input port and a second input port of a subtracting means wherein the subtracting means is operable to subtract one input from the other input and to output the result. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. Apparatus for calculating Log-Likelihood Ratios according to any one of <dependent-claim-reference depends_on="CLM-00014">claims 14</dependent-claim-reference> to <dependent-claim-reference depends_on="CLM-00016">16</dependent-claim-reference> wherein each compare-and-select means includes subtracting means connected to said first and second input ports of the compare-and-select means, wherein the subtracting means is operable to subtract data input at said first input port from data concurrently input at said second input port and to output the sign and the absolute magnitude of the result. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. Apparatus for calculating Log-Likelihood Ratios according to <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference> wherein each compare-and-select means includes selecting means having a first and second input ports respectively connected to said first and second input ports of the compare-and-select means, wherein the selecting means is operable receive as a further input the sign output from said subtracting means and to output the data input via one of its first and second input ports in dependence upon the value of said sign. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. Apparatus for calculating Log-Likelihood Ratios according to <dependent-claim-reference depends_on="CLM-00011">claim 18</dependent-claim-reference> wherein each compare-and-select means includes correcting means for adding to the output of said selecting means a correction factor substantially equal to</claim-text>
<claim-text><in-line-formula>ln(1&plus;exp(&minus;&Dgr;))</in-line-formula></claim-text>
<claim-text>where &Dgr; is the absolute value of the result output from said subtracting means. </claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. Apparatus for calculating Log-Likelihood Ratios according to <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference> wherein said correcting means comprises: 
<claim-text>a look-up table possessing a plurality of correction values and having an input port connected to the output port of said subtracting means and an output port; </claim-text>
<claim-text>adding means having a first input port connected to said output port of the look-up table and having a second input port connected to the output port of said selecting means; </claim-text>
<claim-text>wherein said adding means is operable to add to the output of said selecting means a correction term output from said look-up table. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. Apparatus for calculating Log-Likelihood Ratios according to any one of <dependent-claim-reference depends_on="CLM-00014">claims 14</dependent-claim-reference> to <dependent-claim-reference depends_on="CLM-00020">20</dependent-claim-reference> wherein the element output from either compare-and-select means is input into said cache means for storage as an element in the respective successive set of maximum values overwriting a previously chosen element therein. </claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. A digital signal processor for calculating path metric values of a convolutional encoder for use in decoding, according to any preceding claim, an encoded bit sequence received thereby through a noisy channel, the processor comprising: 
<claim-text>a transition metric calculating unit for receiving from a memory store of the digital signal processor data concerning said bit sequence, for calculating transition metric values representing transitions between states of a convolutional encoder, and for outputting those calculated metric values; </claim-text>
<claim-text>an Add-Compare-Select (ACS) unit for receiving said calculated transition metric values, for receiving path metric values derived from said calculated transition metric values, for deriving updated path metric values from said path metric values and said transition metric values, and for outputting these updated path metric values wherein the updated path metric values are derived in accordance with the method of the first aspect of the invention. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. A digital signal processor according to <dependent-claim-reference depends_on="CLM-00022">claim 22</dependent-claim-reference> wherein, the transition metric calculating unit employs the method of calculating transition metric values (&ggr;) according to any one of claims <highlight><bold>12</bold></highlight> and <highlight><bold>13</bold></highlight>. </claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. A digital signal processor according to <dependent-claim-reference depends_on="CLM-00022">claim 23</dependent-claim-reference> wherein, the transition metric calculating unit is operable to output calculated transition metric values to a memory store of the digital signal processor to which the ACS unit is also connected for the purposes of receiving transition metric values therefrom. </claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. A digital signal processor according to <dependent-claim-reference depends_on="CLM-00022">claim 24</dependent-claim-reference> wherein, the ACS unit is operable to receive path metric values and transition metric values from the memory store of the digital signal processor, and to output updated path metric values thereto for storage in that memory store. </claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. A digital signal processor according to any one of <dependent-claim-reference depends_on="CLM-00022">claims 22</dependent-claim-reference> to <dependent-claim-reference depends_on="CLM-00025">25</dependent-claim-reference> having a transition metric cache into which the metric calculating unit is operable to output and store calculated transition metric values, and the ACS unit is operable to receive those transition metric values from the transition metric cache. </claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. A digital signal processor according to any one of <dependent-claim-reference depends_on="CLM-00022">claims 22</dependent-claim-reference> to <dependent-claim-reference depends_on="CLM-00026">26</dependent-claim-reference> having an additional cache apparatus within which the ACS unit is operable to retrievably store data values calculated thereby. </claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. A digital signal processor according to any one of <dependent-claim-reference depends_on="CLM-00022">claims 22</dependent-claim-reference> to <dependent-claim-reference depends_on="CLM-00027">27</dependent-claim-reference> wherein the ACS unit comprises: 
<claim-text>a calculation unit having a number of data input ports, two data output ports; </claim-text>
<claim-text>wherein the calculation unit is operable to add path metric values to transition metric data values concurrently received at the data input ports thereof to provide two concurrent pairs of updated path metric values, to compare within each concurrent pair said updated path metric values and to output at said two data output ports thereof the maximum path metric value of each concurrent pair. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00029">
<claim-text><highlight><bold>29</bold></highlight>. A digital signal processor according to <dependent-claim-reference depends_on="CLM-00022">claim 28</dependent-claim-reference> wherein, the calculation unit has a first data input port for receiving path metric data values, a second data input port for receiving transition metric data values, a third data input port for receiving path metric data values, and a fourth data input port for receiving transition metric data values. </claim-text>
</claim>
<claim id="CLM-00030">
<claim-text><highlight><bold>30</bold></highlight>. A digital signal processor according to any one of <dependent-claim-reference depends_on="CLM-00022">claims 22</dependent-claim-reference> to <dependent-claim-reference depends_on="CLM-00029">29</dependent-claim-reference> wherein, the ACS unit has function-selection apparatus which is operable to select the function of the ACS to be that of producing updated path metrics, or to be that of producing the elements of the first and second sets of maximum values for use in calculating Log-Likelihood Ratio (LLR) values. </claim-text>
</claim>
<claim id="CLM-00031">
<claim-text><highlight><bold>31</bold></highlight>. A digital signal processor according to <dependent-claim-reference depends_on="CLM-00033">claim 30</dependent-claim-reference> wherein, the function-selection apparatus comprises: 
<claim-text>a first data input gate connected in-between the two data output ports of the calculation unit and two feedback data input ports of the calculation unit of the ACS unit; </claim-text>
<claim-text>a second data input gate connected to the second and fourth data input ports of the calculation unit and to a fifth data input port thereof; </claim-text>
<claim-text>a third data input gate connected to the second and fourth data input ports of the calculation unit and to a sixth data input port thereof; </claim-text>
<claim-text>wherein the function-selection apparatus is operable to select the data values to be input to the feedback data input ports, and the fifth and sixth data input ports of the calculation unit. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00032">
<claim-text><highlight><bold>32</bold></highlight>. A digital signal processor according to <dependent-claim-reference depends_on="CLM-00033">claim 31</dependent-claim-reference> wherein, in a first selection state of the function selection apparatus, the first data input gate blocks data output from the calculation unit and causes data input at the two feedback data input ports thereof to have a value of zero, while concurrently the second data input gate causes transition metric data input at the fourth input port of the calculating unit to be simultaneously input at the fifth data input thereof, and concurrently the third data input gate causes transition metric data input at the second input port of the calculation unit to be simultaneously input at the sixth data input port thereof. </claim-text>
</claim>
<claim id="CLM-00033">
<claim-text><highlight><bold>33</bold></highlight>. A digital signal processor according to <dependent-claim-reference depends_on="CLM-00033">claim 31</dependent-claim-reference> wherein, in a second selection state of the function selection apparatus, the first data input gate permits data to pass from the outputs of the calculation unit to the two feedback data input ports thereof, while concurrently the second data input gate causes transition metric data input at the second input port of the calculation unit to be simultaneously input at the fifth data input thereof, and concurrently the third data input gate causes transition metric data input at the fourth input port of the calculation unit to be simultaneously input at the sixth data input port thereof. </claim-text>
</claim>
<claim id="CLM-00034">
<claim-text><highlight><bold>34</bold></highlight>. A digital signal processor according to any of <dependent-claim-reference depends_on="CLM-00022">claims 22</dependent-claim-reference> to <dependent-claim-reference depends_on="CLM-00033">33</dependent-claim-reference> further comprising a Log-Likelihood Ratio unit for calculating LLR values, and for outputting calculated LLR values to the memory store of the DSP. </claim-text>
</claim>
<claim id="CLM-00035">
<claim-text><highlight><bold>35</bold></highlight>. A digital signal processor according to <dependent-claim-reference depends_on="CLM-00033">claim 34</dependent-claim-reference> wherein, the Log-Likelihood Ratio unit is connected to cache apparatus and is operable to retrieve data elements of the sets of first maximum values and second maximum values when stored therein, and is operable to store therein elements of successive sets of first and second maximum values produced by the Log-Likelihood Ratio unit. </claim-text>
</claim>
<claim id="CLM-00036">
<claim-text><highlight><bold>36</bold></highlight>. A digital signal processor according to <dependent-claim-reference depends_on="CLM-00033">claim 35</dependent-claim-reference> wherein, the Log-Likelihood Ratio unit comprises: 
<claim-text>cache apparatus operable to store said set of first maximum values, said set of second maximum values and said successive sets thereof; </claim-text>
<claim-text>two compare-and-select units, each one possessing a first data input port connected to a data output port of said cache apparatus, a second data input port connected to a data output port of said cache apparatus, and a data output port connected to a data input port of said cache apparatus; </claim-text>
<claim-text>wherein one of said compare-and-select units is operable to receive at its first and second data input ports elements of said set of first maximum values output form said cache apparatus, and the other of said compare-and-select units is operable to receive at its first and second data input ports elements of said set of second maximum values output from said cache apparatus, each said compare-and-select unit being operable to compare concurrent first and second inputs and to output via said output port the element which is the maximum of the two. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00037">
<claim-text><highlight><bold>37</bold></highlight>. A digital signal processor according to <dependent-claim-reference depends_on="CLM-00033">claim 36</dependent-claim-reference> wherein, in the Log-Likelihood Ratio unit, data elements output from said compare-and-select units are input into said cache apparatus for storage as an element in the respective successive set of maximum values. </claim-text>
</claim>
<claim id="CLM-00038">
<claim-text><highlight><bold>38</bold></highlight>. A digital signal processor according to <dependent-claim-reference depends_on="CLM-00033">claim 37</dependent-claim-reference> wherein, data elements output port of each of the two compare-and-select units are connected to a respective one of a first input port and a second input port of a subtraction unit which is operable to subtract the data at one input port thereof from the data at the other input port thereof, and to output the result. </claim-text>
</claim>
<claim id="CLM-00039">
<claim-text><highlight><bold>39</bold></highlight>. A digital signal processor according to any of <dependent-claim-reference depends_on="CLM-00036">claims 36</dependent-claim-reference> to <dependent-claim-reference depends_on="CLM-00038">38</dependent-claim-reference> wherein, each compare-and-select unit of the Log-Likelihood Ratio unit includes a subtraction unit connected to said first and second input ports of the two compare-and-select means, wherein the subtraction unit is operable to subtract data input at said first input port from data concurrently input at said second input port and to output the sign and the absolute magnitude of the result. </claim-text>
</claim>
<claim id="CLM-00040">
<claim-text><highlight><bold>40</bold></highlight>. A digital signal processor according to any of <dependent-claim-reference depends_on="CLM-00036">claims 36</dependent-claim-reference> to <dependent-claim-reference depends_on="CLM-00039">39</dependent-claim-reference> wherein, each compare-and-select unit includes a selecting unit having a first and second input port respectively connected to said first and second input ports of the compare-and-select unit, wherein the selecting unit is operable to receive as a further input the sign output from said subtracting unit and to output the data input via one of its first and second input ports in dependence upon the value of said sign. </claim-text>
</claim>
<claim id="CLM-00041">
<claim-text><highlight><bold>41</bold></highlight>. A digital signal processor according to any of <dependent-claim-reference depends_on="CLM-00036">claims 36</dependent-claim-reference> to <dependent-claim-reference depends_on="CLM-00040">40</dependent-claim-reference> wherein each compare-and-select unit includes correcting apparatus for adding to the output of said selecting unit a correction factor substantially equal to</claim-text>
<claim-text><in-line-formula>ln(1&plus;exp(&minus;&Dgr;))</in-line-formula></claim-text>
<claim-text>where &Dgr; is the absolute value of the result output from said subtracting unit. </claim-text>
</claim>
<claim id="CLM-00042">
<claim-text><highlight><bold>42</bold></highlight>. A digital signal processor according to any of <dependent-claim-reference depends_on="CLM-00036">claims 36</dependent-claim-reference> to <dependent-claim-reference depends_on="CLM-00041">41</dependent-claim-reference> wherein, said correcting apparatus comprises: 
<claim-text>a look-up table possessing a plurality of correction values and having an input port connected to the output port of said subtracting unit and an output port; and, </claim-text>
<claim-text>an adder means having a first input port connected to said output port of the look-up table and having a second input port connected to the output port of said selecting unit; </claim-text>
<claim-text>wherein said adder means is operable to add to the output of said selecting unit a correction term output from said look-up table. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00043">
<claim-text><highlight><bold>43</bold></highlight>. A Turbo-Code decoder comprising a plurality of Log-MAP decoders wherein, each Log-MAP decoder comprises branch metric calculating apparatus for calculating transition metric values (&ggr;) according to any of preceding <dependent-claim-reference depends_on="CLM-00012">claims 12</dependent-claim-reference> to <highlight><bold>47</bold></highlight>. </claim-text>
</claim>
<claim id="CLM-00044">
<claim-text><highlight><bold>44</bold></highlight>. A Turbo-Code decoder comprising a plurality of Log-MAP decoders wherein each Log-MAP decoder comprises path metric calculating apparatus for calculating path metric values of said encoder according to any preceding claim. </claim-text>
</claim>
<claim id="CLM-00045">
<claim-text><highlight><bold>45</bold></highlight>. A Turbo-Code decoder comprising a plurality of Log-MAP decoders wherein each Log-MAP decoder comprises a Log-Likelihood Ratio unit for calculating Log-Likelihood Ratio values of said encoder according to any of <dependent-claim-reference depends_on="CLM-00006">claims 6</dependent-claim-reference> to <highlight><bold>49</bold></highlight>.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>3</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030002603A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030002603A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030002603A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030002603A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030002603A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030002603A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030002603A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030002603A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030002603A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00009">
<image id="EMI-D00009" file="US20030002603A1-20030102-D00009.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
