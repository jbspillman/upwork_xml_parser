<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005027A1-20030102-D00000.TIF SYSTEM "US20030005027A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005027A1-20030102-D00001.TIF SYSTEM "US20030005027A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005027A1-20030102-D00002.TIF SYSTEM "US20030005027A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005027A1-20030102-D00003.TIF SYSTEM "US20030005027A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005027A1-20030102-D00004.TIF SYSTEM "US20030005027A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005027A1-20030102-D00005.TIF SYSTEM "US20030005027A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030005027A1-20030102-D00006.TIF SYSTEM "US20030005027A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030005027A1-20030102-D00007.TIF SYSTEM "US20030005027A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030005027A1-20030102-D00008.TIF SYSTEM "US20030005027A1-20030102-D00008.TIF" NDATA TIF>
<!ENTITY US20030005027A1-20030102-D00009.TIF SYSTEM "US20030005027A1-20030102-D00009.TIF" NDATA TIF>
<!ENTITY US20030005027A1-20030102-D00010.TIF SYSTEM "US20030005027A1-20030102-D00010.TIF" NDATA TIF>
<!ENTITY US20030005027A1-20030102-D00011.TIF SYSTEM "US20030005027A1-20030102-D00011.TIF" NDATA TIF>
<!ENTITY US20030005027A1-20030102-D00012.TIF SYSTEM "US20030005027A1-20030102-D00012.TIF" NDATA TIF>
<!ENTITY US20030005027A1-20030102-D00013.TIF SYSTEM "US20030005027A1-20030102-D00013.TIF" NDATA TIF>
<!ENTITY US20030005027A1-20030102-D00014.TIF SYSTEM "US20030005027A1-20030102-D00014.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005027</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10176794</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20020621</filing-date>
</domestic-filing-data>
<foreign-priority-data>
<priority-application-number>
<doc-number>0115965.6</doc-number>
</priority-application-number>
<filing-date>20010629</filing-date>
<country-code>GB</country-code>
</foreign-priority-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F009/46</ipc>
</classification-ipc-primary>
<classification-ipc-secondary>
<ipc>G06F009/00</ipc>
</classification-ipc-secondary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>709</class>
<subclass>104000</subclass>
</uspc>
</classification-us-primary>
<classification-us-secondary>
<uspc>
<class>709</class>
<subclass>316000</subclass>
</uspc>
</classification-us-secondary>
</classification-us>
<title-of-invention>Computer system for detecting object updates</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Samuel</given-name>
<middle-name>David</middle-name>
<family-name>Borman</family-name>
</name>
<residence>
<residence-non-us>
<city>Southsea</city>
<country-code>GB</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Edward</given-name>
<middle-name>John</middle-name>
<family-name>Slattery</family-name>
</name>
<residence>
<residence-non-us>
<city>Winchester</city>
<country-code>GB</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<assignee>
<organization-name>International Business Machines Corporation</organization-name>
<assignee-type>03</assignee-type>
</assignee>
<correspondence-address>
<name-1>Gregory M. Doudnikoff</name-1>
<name-2>IBM Corp. IP Law Dept T81/503</name-2>
<address>
<address-1>3039 Cornwallis Road</address-1>
<address-2>PO Box 12195</address-2>
<city>Research Triangle Park</city>
<state>NC</state>
<postalcode>27709-2195</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A computer system is used to run one or more programs. It includes a memory having at least a first heap and a second heap in which objects are stored, with a first object being stored on the first heap. A write barrier is provided for detecting that said the first object has been updated by a program to include a first reference to a memory location in the second heap. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">FIELD OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> The present invention relates to a computer system for running one or more programs and including a memory for storing objects, and in particular to the processing when one object updates a reference to another. </paragraph>
</section>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> Programs written in the Java programming language (Java is a trademark of Sun Microsystems Inc) are generally run in a virtual machine environment, rather than directly on hardware. Thus a Java program is typically compiled into byte-code form, and then interpreted by a Java virtual machine (VM) into hardware commands for the platform on which the Java VM is executing. The Java VM itself is an application running on the underlying operating system. An important advantage of this approach is that Java applications can then run on a very wide range of platforms. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> Java is an object-oriented language. Thus a Java program is formed from a set of class files having methods that represent sequences of instructions. A hierarchy of classes can be defined, with each class inheriting properties (including methods) from those classes which are above it in the hierarchy. For any given class in the hierarchy, its descendants (i.e. below it) are called subclasses, whilst its ancestors (i.e. above it) are called superclasses. At run-time objects are created as instantiations of these class files, and indeed the class files themselves are effectively loaded as objects One Java object can call a method in another Java object. In recent years the Java environment has become very popular, and is described in many books, for example &ldquo;Exploring Java&rdquo; by Niemeyer and Peck, O&apos;Reilly &amp; Associates, 1996, USA, and &ldquo;The Java Virtual Machine Specification&rdquo; by Lindholm and Yellin, Addison-Wedley, 1997, USA. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> The standard Java VM architecture is generally designed to run only a single application, although this can be multi-threaded. In a server environment used for database transactions and such-like, each transaction is typically performed as a separate application, rather than as different threads within an application. This is to ensure that every transaction starts with the Java VM in a clean state. In other words, a new Java VM is started for each transaction (i.e. for each new Java application). Unfortunately however this results in an initial delay in running the application (the reasons for this will be described in more detail later). The overhead due to this frequent starting and then stopping a Java VM as successive transactions are processed is significant, and seriously degrades the scalability of Java server solutions. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> Various attempts have been made to mitigate this problem. EP-962860-A describes a process whereby one Java VM can fork into a parent and a child process, this being quicker than setting up a fresh Java VM. The ability to run multiple processes in a Java-like system, thereby reducing overhead per application, is described in &ldquo;Processes in KaffeOS: Isolation, Resource Management, and Sharing in Java&rdquo; by G back, W Hsieh, and J Lepreau (see the file /flux/papers/kaffeos-osdi<highlight><bold>00</bold></highlight>/main.html) at http://www.cs.utah.edu). </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> Another approach is described in &ldquo;Oracle JServer Scalability and Performance&rdquo; by Jeremy Litzt, July 1999 (see the file /database/documents/jserver_scalability_and_performance_t wp.pdf at http://www.oracle.com). The JServer product available from Oracle Corporation, USA, supports the concept of multiple sessions (a session effectively representing a transaction or application), each session including a JServer session. Each individual session appears to its JServer client to be a dedicated conventional Java VM. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> U.S. patent application Ser. No. 09/304160, filed Apr. 30, 1999 (&ldquo;A long Running Reusable Extendible Virtual Machine&rdquo;), assigned to IBM Corporation (IBM docket YOR9-1999-0170), discloses a virtual machine having two types of heap, a private heap and a shared heap. The former is intended primarily for storing application classes, whilst the latter is intended primarily for storing system classes and, as its name implies, is accessible to multiple VMs. A related idea is described in &ldquo;Building a Java virtual machine for server applications: the JVM on OS/390&rdquo; by Dillenberger et al, IBM Systems Journal, Vol 39/1, January 2000. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> The above documents are focused primarily on the ability to easily run multiple Java VMs in parallel. A different (and potentially complementary) approach is based on a serial rather than parallel configuration. Thus it is desirable to run repeated transactions (i.e. applications) on the same Java VM, since this could avoid having to reload all the system classes at the start of each application. However, one difficulty with this is that each application expects to run on a fresh, clean, Java VM. There is a danger with serial re-use of a Java VM that the state left from a previous transaction somehow influences the outcome of a new transaction. This unpredictability is unacceptable in most circumstances. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> U.S. provisional application No. 60/208268 filed May 31, 2000 in the name of IBM Corporation (IBM docket number YOR9-2000-0359) discloses the idea of having two heaps in a JVM. One of these is a transient heap, which is used to store transaction objects that will not persist into the next transaction, whilst a second, persistent, heap is used for storing objects, such as system objects, that will persist. This approach provides the basis for an efficient reset mechanism by deleting the transient heap. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> This concept is developed in GB application 0027045.4, filed Nov. 6, 2000 in the name of IBM Corporation (IBM docket number GB9-2000-0101), which focuses particularly on the deletion of the transient heap. One difficulty that arises at reset is how to handle pointers from objects in the persistent heap to objects in the transient heap, since following reset and deletion of the transient heap, these pointers will no longer be valid. The general policy in the above application is that if such cross-heap pointers exist, the Java VM is no longer resettable, and so will normally have to be terminated. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> However, it is possible that the objects in the persistent heap from which the cross-heap pointers originate are no longer live, but rather are waiting to be garbage collected (the process of garbage collection in Java is described in more detail below). It is clearly undesirable to terminate the Java VM as unresettable simply on the basis of a cross-heap pointer that could possibly be deleted. Therefore, as described in the above application, if any cross-heap pointers are found at reset, a garbage collection operation is performed, which will remove any objects that are no longer live. In many cases this will eliminate all the objects that have the cross-heap pointers, thereby allowing reset to proceed. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> Although the approach in the GB 0027045.4 application is effective, it suffers from the problem that garbage collection is a relatively time-consuming operation. Thus if any cross-heap pointers are found, there is a significant wait while the garbage collection is performed in order to determine whether or not the Java VM is safe to reset. This wait is unfortunate, given that one of the main motivations for being able to reset the Java VM in the first place was to overcome the start-up delay when having to launching a new Java VM for each transaction. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> Accordingly, the invention provides a computer system for running one or more programs and including a memory in which objects are stored, said system further including: </paragraph>
<paragraph id="P-0014" lvl="2"><number>&lsqb;0014&rsqb;</number> a card table containing multiple cards, each card corresponding to a portion of said memory; and </paragraph>
<paragraph id="P-0015" lvl="2"><number>&lsqb;0015&rsqb;</number> a write barrier for detecting that a first object has been updated by a program to include a reference to a second object, and for marking the card that corresponds to the memory location of said second object. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> In broad terms each card is simply a small region of memory, which corresponds to a much larger region of memory. The card is then marked if an object in its corresponding larger region of memory is referenced. This provides an effective record of memory usage, a form of memory map, to track objects which may potentially be live, because they are referenced by other objects. Scanning the card table can therefore provide a short cut to identifying live objects, compared to a full garbage collection. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> It will be appreciated that there are many possibilities as regards the detailed structure of the card table, and this will typically depend on performance aspects. For example, if cards in the card table are contiguous with an order that matches the corresponding memory locations, access speed to the card table will be much greater since a card can be located in the card table directly from a given memory location. However, other configurations of the card table may also be adopted. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> In the preferred embodiment, the computer memory is divided into at least first and second heaps, and a reset can be performed on the system, involving the deletion of all objects in the second heap. At such reset, any pointers from the first heap into the second heap (cross-heap pointers) become invalid, or put another way, the presence of any such cross-heap pointer prevents a valid reset operation. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> Note that the first and second heaps do not need to be physically separate, but may for example be one heap logically partitioned into two or more heaps. In addition, there may be large number of logically separate heaps, and also a variety of different heap models, such as providing local heaps for threads. In this context a cross-heap pointer should simply be interpreted as a pointer from a first region of memory that is not being reset into a second region of memory that is being reset. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> The main objective of the present invention is to allow a quick determination at reset of whether a cross-heap pointer is still live, without having to perform a full garbage collection. To this end, each card in the card table comprises first and second components. The first component is marked if an object in a corresponding memory location is updated to include a reference to another object. In the preferred embodiment, this first component is only marked if the object being updated is in the first heap, and the object being referenced is in the second heap. This approach therefore flags all cross-heap pointers. An alternative approach is simply to mark the cards for all updated objects (or optionally just those in the middleware heap) irrespective of the location of the objects they reference. This effectively defers checking whether the reference is a cross-heap pointer until the reset itself, which may be desirable for performance reasons. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> Further in the preferred embodiment, the second component of the card table is marked if an object in a corresponding memory location is referenced from another object, providing the object being updated (i.e. the referencing object) is in the first heap (this is because references from the second heap should be deletable at reset, and so cannot make an object live). Preferably the second component of the card is only marked if the object being referenced is in the first heap. Alternatively it may be simpler to drop this requirement (so no testing of which heap contains the referenced object); in this case the marked cards corresponding to the second heap would simply be ignored at reset. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> Note that in the preferred embodiment, the second component of a card is not marked if the object being updated and the object being referenced are in memory locations corresponding to a single card. This is because there must be some other reference to the card from outside for any object within it to be potentially live. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> At reset itself, the second component of each card corresponding to a memory location referenced by the system stack or registers is marked. These locations are termed the roots, and represent live objects. Any other objects which are live must be referenced directly or directly from one of the roots. Thus by marking the roots, and also by using the write barrier to mark referenced objects, the second component of cards corresponding to all potentially live objects should have been marked. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> This means that at reset the first component of each card corresponding to objects in the first heap is checked to see if it is marked, in other words, to see if an object in the corresponding portion of memory contains a cross-heap pointer. If so, it is determined if the second component of any such card is marked. If not, it is known that any objects in the portion of memory corresponding to the card cannot be live, and therefore any cross-heap pointer therein can be ignored. On the other hand, if the second component is marked, then the object containing the cross-heap pointer may still potentially be live, and so reset cannot proceed. In the preferred embodiment at this stage, a full garbage collection is performed, to allow a more accurate determination of which objects are live (the use of the card table conservatively indicates cards as live, in that any live object will imply its corresponding card is live, but the converse is not necessarily true, i.e. a live card does not mean that all, or indeed any, of its corresponding objects are actually live). If the garbage collection shows that the objects containing the cross-heap pointers are in fact not live, then the reset can proceed after all. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> At reset, the first component of each card is restored to its initial (zero) value as part of such reset, in other words to its unmarked state. On the other hand, the second component of each card persists through reset, to mirror the fact that object references within the first heap can likewise persist through reset. The second component is only reset itself if a garbage collection is performed on the system, whereupon it is known exactly which objects are live, and the second component in the corresponding cards can therefore be marked accordingly. (Note that in this context reset of the second component is not back to its initial, completely unmarked state, but rather back to a state in which it is known to be fully current). </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> The invention further provides a method for running one or more programs on a computer system including a memory in which objects are stored, said method including the steps of: </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> providing a card table containing multiple cards, each card corresponding to a portion of said memory; and </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> detecting with a write barrier that a first object has been updated by a program to include a reference to a second object, and marking the card that corresponds to the memory location of said second object. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> The invention further provides a computer program product comprising instructions encoded on a computer readable medium for causing a computer to perform this method. A suitable computer readable medium may be a DVD or computer disk, or the instructions may be encoded in a signal transmitted over a network from a server. It will be appreciated that the method and computer program product of the invention will benefit from the same preferred features as the system of the invention. </paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> A preferred embodiment of the invention will now be described in detail by way of example only with reference to the following drawings: </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> shows a schematic diagram of a computer system supporting a Java Virtual Machine (VM); </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a schematic diagram of the internal structure of the Java VM; </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a flowchart depicting the steps required to load a class and prepare it for use; </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a flowchart depicting at a high level the serial reuse of a Java VM; </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a schematic diagram showing the heap and its associated components in more detail; </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 6A and 6B</cross-reference> form a flowchart illustrating garbage collection; </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> is a diagram of a lookup table used to determine if a reference is in a heap; </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> is a diagram of a modified lookup structure for the same purpose as <cross-reference target="DRAWINGS">FIG. 7</cross-reference>, but for use in a system with much larger memory; </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 9A and 9B</cross-reference> form a flowchart illustrating the operations taken to delete the transient heap during Java VM reset; </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10</cross-reference> is a diagram illustrating some objects in memory and the corresponding portion of a card table; </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 11</cross-reference> is a flow chart depicting a write barrier for writing to the card table; and </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 12</cross-reference> is a diagram illustrating the structure of the card table. </paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION </heading>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> illustrates a computer system <highlight><bold>10</bold></highlight> including a (micro)processor <highlight><bold>20</bold></highlight> which is used to run software loaded into memory <highlight><bold>60</bold></highlight>. The software can be loaded into the memory by various means (not shown), for example from a removable storage device such as a floppy disk, CD ROM, or DVD, or over a network such as a local area network (LAN), telephone/modem connection, or wireless link, typically via a hard disk drive (also not shown). Computer system runs an operating system (OS) <highlight><bold>30</bold></highlight>, on top of which is provided a Java virtual machine (VM) <highlight><bold>40</bold></highlight>. The Java VM looks like an application to the (native) OS <highlight><bold>30</bold></highlight>, but in fact functions itself as a virtual operating system, supporting Java application <highlight><bold>50</bold></highlight>. A Java application may include multiple threads, illustrated by threads T<highlight><bold>1</bold></highlight> and T<highlight><bold>2</bold></highlight> <highlight><bold>71</bold></highlight>, <highlight><bold>72</bold></highlight>. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> System <highlight><bold>10</bold></highlight> also supports middleware subsystem <highlight><bold>45</bold></highlight>, for example a transaction processing environment such as CICS, available from IBM Corporation (CICS is a trademark of IBM Corporation). The middleware subsystem runs as an application or environment on operating system <highlight><bold>30</bold></highlight>, and initiates the Java VM <highlight><bold>40</bold></highlight>. The middleware also includes Java programming which acts to cause transactions as Java applications <highlight><bold>50</bold></highlight> to run on top of the Java VM <highlight><bold>40</bold></highlight>. In accordance with the present invention, and as will be described in more detail below, the middleware can cause successive transactions to run on the same Java VM. In a typical server environment, multiple Java VMs may be running on computer system <highlight><bold>10</bold></highlight>, in one or more middleware environments. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> It will be appreciated that computer system <highlight><bold>10</bold></highlight> can be a standard personal computer or workstation, network computer, minicomputer, mainframe, or any other suitable computing device, and will typically include many other components (not shown) such as display screen, keyboard, sound card, network adapter card, etc which are not directly relevant to an understanding of the present invention. Note that computer system <highlight><bold>10</bold></highlight> may also be an embedded system, such as a set top box, handheld device, or any other hardware device including a processor <highlight><bold>20</bold></highlight> and control software <highlight><bold>30</bold></highlight>, <highlight><bold>40</bold></highlight>. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> shows the structure of Java VM <highlight><bold>40</bold></highlight> in more detail (omitting some components which are not directly pertinent to an understanding of the present invention). The fundamental unit of a Java program is the class, and thus in order to run any application the Java VM must first load the classes forming and required by that application. For this purpose the Java VM includes a hierarchy of class loaders <highlight><bold>110</bold></highlight>, which conventionally includes three particular class loaders, named Application <highlight><bold>120</bold></highlight>, Extension <highlight><bold>125</bold></highlight>, and Primordial <highlight><bold>130</bold></highlight>. An application can add additional class loaders to the Java VM (a class loader is itself effectively a Java program). In the preferred embodiment of the present invention, a fourth class loader is also supported, Middleware <highlight><bold>124</bold></highlight>. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> For each class included within or referenced by a program, the Java VM effectively walks up the class loader hierarchy, going first to the Application class loader, then the Middleware loader, then the Extension class loader, and finally to the Primordial class loader, to see if any class loader has previously loaded the class. If the response from all of the class loaders is negative, then the JVM walks back down the hierarchy, with the Primordial class loader first attempting to locate the class, by searching in the locations specified in its class path definition. If this is unsuccessful, the Extension class loader then makes a similar attempt, if this fails the Middleware class loader tries. Finally, if this fails the Application class loader tries to load the class from one of the locations specified in its class path (if this fails, or if there is some other problem such as a security violation, the system returns an error). It will be appreciated that a different class path can be defined for each class loader. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> The Java VM further includes a component CL <highlight><bold>204</bold></highlight>, which also represents a class loader unit, but at a lower level. In other words, this is the component that actually interacts with the operating system to perform the class loading on behalf of the different (Java) class loaders <highlight><bold>110</bold></highlight>. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> Also present in the Java VM is a heap <highlight><bold>140</bold></highlight>, which is used for storage of objects <highlight><bold>145</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 2</cross-reference> shows the heap <highlight><bold>140</bold></highlight> only at a high level; see <cross-reference target="DRAWINGS">FIG. 5</cross-reference> below for more details). Each loaded class represents an object, and therefore can be found on the heap. In Java a class effectively defines a type of object, and this is then instantiated one or more times in order to utilise the object. Each such instance is itself an object which can be found in heap <highlight><bold>140</bold></highlight>. Thus the objects <highlight><bold>145</bold></highlight> shown in the heap in <cross-reference target="DRAWINGS">FIG. 2</cross-reference> may represent class objects or other object instances. (Note that strictly the class loaders as objects are also stored on heap <highlight><bold>140</bold></highlight>, although for the sake of clarity they are shown separately in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>). Although heap <highlight><bold>140</bold></highlight> is shared between all threads, typically for reasons of operational efficiency, certain portions of heap <highlight><bold>140</bold></highlight> can be assigned to individual threads, effectively as a small region of local storage, which can be used in a similar fashion to a cache for that thread. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> The Java VM also includes a class storage area <highlight><bold>160</bold></highlight>, which is used for storing information relating to the class files stored as objects in the heap <highlight><bold>140</bold></highlight>. This area includes the method code region <highlight><bold>164</bold></highlight> for storing byte code for implementing application logic such as class method calls, and a constant pool <highlight><bold>162</bold></highlight> for storing strings and other constants associated with a class. The class storage area also includes a field data region <highlight><bold>170</bold></highlight> for sharing static variables (static in this case implies belonging to the class rather than individual instances of the class, or, to put this another way, shared between all instances of a class), and an area <highlight><bold>168</bold></highlight> for storing static initialisation methods and other specialised methods (separate from the main method code <highlight><bold>164</bold></highlight>). The class storage area further includes a method block area <highlight><bold>172</bold></highlight>, which is used to store information relating to the code, such as invokers, and a pointer to the code, which may for example be in method code area <highlight><bold>164</bold></highlight>, in JIT code area <highlight><bold>185</bold></highlight> (as described in more detail below), or loaded as native code such as C, for example as a dynamic link library (DLL). </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> Classes stored as objects <highlight><bold>145</bold></highlight> in the heap <highlight><bold>140</bold></highlight> contain a reference to their associated data such as method byte code etc in class storage area <highlight><bold>160</bold></highlight>. They also contain a reference to the class loader which loaded them into the heap, plus other fields such as a flag (not shown) to indicate whether or not they have been initialised. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> further shows a monitor pool <highlight><bold>142</bold></highlight>. This contains a set of locks (monitors) that are used to control access to an object by different threads. Thus when a thread requires exclusive access to an object, it first obtains ownership of its corresponding monitor. Each monitor can maintain a queue of threads waiting for access to any particular object. Hash table <highlight><bold>141</bold></highlight> is used to map from an object in the heap to its associated monitor. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> Another component of the Java VM is the interpreter <highlight><bold>156</bold></highlight>, which is responsible for reading in Java byte code from loaded classes, and converting this into machine instructions for the relevant platform. From the perspective of a Java application, the interpreter effectively simulates the operation of a processor for the virtual machine. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> Also included within the Java VM are class loader cache <highlight><bold>180</bold></highlight> and garbage collection (GC) unit <highlight><bold>175</bold></highlight>. The former is effectively a table used to allow a class loader to trace those classes which it initially loaded into the Java VM. The class loader cache therefore allows each class loader to check whether it has loaded a particular class&mdash;part of the operation of walking the class loader hierarchy described above. Note also that it is part of the overall security policy of the Java VM that classes will typically have different levels of permission within the system based on the identity of the class loader by which they were originally loaded. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> Garbage collection (GC) facility <highlight><bold>175</bold></highlight> is used to delete objects from heap <highlight><bold>140</bold></highlight> when those objects are no longer required. Thus in the Java programming language, applications do not need to specifically request or release memory, rather this is controlled by the Java VM. Therefore, when Java application <highlight><bold>50</bold></highlight> creates an object <highlight><bold>145</bold></highlight>, the Java VM secures the requisite memory resource. Then, when Java application <highlight><bold>50</bold></highlight> finishes using object <highlight><bold>145</bold></highlight>, the Java VM can delete the object to free up this memory resource. This latter process is known as garbage collection, and is generally performed by briefly interrupting all threads <highlight><bold>71</bold></highlight>, <highlight><bold>72</bold></highlight>, and scanning the heap <highlight><bold>140</bold></highlight> for objects which are no longer referenced, and hence can be deleted. The garbage collection of the preferred embodiment is described in more detail below. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> The Java VM further includes a just-in-time (JIT) compiler <highlight><bold>190</bold></highlight>. This forms machine code to run directly on the native platform by a compilation process from the class files. The machine code is created typically when the application program is started up or when some other usage criterion is met, and is then stored for future use. This improves run-time performance by avoiding the need for this code to be interpreted later by the interpreter <highlight><bold>156</bold></highlight>. </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> Another component of the Java VM is the stack area <highlight><bold>195</bold></highlight>, which is used for storing the stacks <highlight><bold>196</bold></highlight>, <highlight><bold>198</bold></highlight> associated with the execution of different threads on the Java VM. Note that because the system libraries and indeed parts of the Java VM itself are written in Java, and these frequently use multi-threading, the Java VM may be supporting multiple threads even if the user application <highlight><bold>50</bold></highlight> running on top of the Java VM contains only a single thread itself. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> It will be appreciated of course that <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is simplified, and essentially shows only those components pertinent to an understanding of the present invention. Thus for example the heap may contain thousands of Java objects in order to run Java application <highlight><bold>50</bold></highlight>, and the Java VM contains many other components (not shown) such as diagnostic facilities, etc. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a flowchart illustrating the operations conventionally performed to load a class in order to run a Java application. The first operation is loading (step <highlight><bold>310</bold></highlight>) in which the various class loaders try to retrieve and load a particular class. The next operation is linking, which comprises three separate steps. The first of these is verification (step <highlight><bold>320</bold></highlight>), which essentially checks that the code represents valid Java programming, for example that each instruction has a valid operational code, and that each branch instruction goes to the beginning of another instruction (rather than the middle of an instruction). This is followed by preparation (step <highlight><bold>330</bold></highlight>) which amongst other things creates the static fields for a class. The linking process is completed by the step of resolution, in which a symbolic reference to another class is typically replaced by a direct reference (step <highlight><bold>340</bold></highlight>). </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> At resolution the Java VM may also try to load additional classes associated with the current class. For example, if the current class calls a method in a second class then the second class may be loaded now. Likewise, if the current class inherits from a superclass, then the superclass may also be loaded now. This can then be pursued recursively; in other words, if the second class calls methods in further classes, or has one or more superclasses, these too may now be loaded. Note that it is up to the Java VM implementation how many classes are loaded at this stage, as opposed to waiting until such classes are actually needed before loading them. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> The final step in <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is the initialisation of a loaded class (step <highlight><bold>350</bold></highlight>), which represents calling the static initialisation method (or methods) of the class. According to the formal Java VM specification, this initialisation must be performed once and only once before the first active use of a class, and includes things such as setting static (class) variables to their initial values (see the above-mentioned book by Lindholm and Yellin for a definition of &ldquo;first active use&rdquo;). Note that initialisation of an object also requires initialisation of its superclasses, and so this may involve recursion up a superclass tree in a similar manner to that described for resolution. The initialisation flag in a class object <highlight><bold>145</bold></highlight> is set as part of the initialisation process, thereby ensuring that the class initialisation is not subsequently re-run. </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> The end result of the processing of <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is that a class has been loaded into a consistent and predictable state, and is now available to interact with other classes. In fact, typically at start up of a Java program and its concomitant Java VM, some 1000 objects are loaded prior to actual running of the Java program itself, these being created from many different classes. This gives some idea of the initial delay and overhead involved in beginning a Java application. </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> As mentioned above, the problems caused by this initial delay can be greatly reduced by serial reuse of a Java VM, thereby avoiding the need to reload system classes and so on. <cross-reference target="DRAWINGS">FIG. 4</cross-reference> provides a high-level flowchart of a preferred method for achieving such serial reuse. The method commences with the start of the middleware subsystem <highlight><bold>45</bold></highlight>, which in turn uses the Java Native Interface (JNI) to perform a Create JVM operation (step <highlight><bold>410</bold></highlight>). Next an application or transaction to run on the Java VM is loaded by the Application class loader <highlight><bold>120</bold></highlight>. The middleware includes Java routines to provide various services to the application, and these are also loaded at this point, by the Middleware class loader <highlight><bold>124</bold></highlight>. </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> The application can now be run (step <highlight><bold>420</bold></highlight>), and in due course will finally terminate. At this point, instead of terminating the Java VM as well as the application, the middleware subsystem makes a Reset JVM call to the Java VM (step <highlight><bold>430</bold></highlight>). The middleware classes may optionally include a tidy-up method and/or a reinitialize method. Both of these are static methods. The Java VM responds to the Reset JVM by calling the tidy-up method of the middleware classes (step <highlight><bold>440</bold></highlight>). The purpose of this is to allow the middleware to leave the Java VM in a tidy state, for example removing resources and closing files that are no longer required, and deleting references to the application objects. In particular, all those middleware classes which have been used since the previous Java VM reset (or since the Java VM was created if no resets have occurred) have their tidy-up method called, assuming of course that they have a tidy-up method (there is no requirement for them to have such a tidy-up method). </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> The tidy-up method may be similar to the finalise method of a class, which is a standard Java facility to allow an object to perform some close-down operation. However, there is an important difference in that tidy-up is a static method. This means that contrary to the finalise method it applies to the class rather than any particular object instance, and so will be called even if there are no current object instances for that class. In addition the timing of the tidy-up method is different from finalise, in that the former is called in response to a predetermined command to reset the Java VM. In contrast, in accordance with the Java VM specification, the finalise method is only triggered by a garbage collection. More particularly, if an object with a finalizer method is found to be unreachable during a garbage collection (i.e. it is no longer effectively active) then it is queued to the finalizer thread, which then runs the finalizer method after the garbage collection is completed. Note that the finalizer method of an object may never be called, if an application finishes and the Java VM shuts down without the system needing to perform a garbage collection. </paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> Once the tidy-up has been completed, a refresh heap operation is performed (step <highlight><bold>445</bold></highlight>). As will be described in more detail below, this deletes those portions of the heap that relate to the application or transaction that has just been completed, generally analogous to a garbage collection cycle. Note that many of the objects deleted here might not have been removable prior to the tidy-up method, since they could still have been referenced by the middleware classes. </paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> At this point, the middleware subsystem makes a determination of whether or not there is another application to run on the Java VM (step <highlight><bold>450</bold></highlight>). If not, the middleware subsystem uses the JNI to make a Destroy JVM call (step <highlight><bold>460</bold></highlight>) which terminates the Java VM, thereby ending the method of <cross-reference target="DRAWINGS">FIG. 4</cross-reference>. If on the other hand there is another application to run, then this new application is started by the middleware. The system responds to this new application by calling in due course the reinitialisation method in each of the middleware classes to be reused (step <highlight><bold>455</bold></highlight>). The purpose of this is to allow the middleware classes to perform certain operations which they might do at initialisation, thereby sidestepping the restriction that the Java VM specification prevents the initialisation method itself being called more than once. As a simple example, the reinitialisation may be used to reset a clock or a counter. As shown in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, the system is now in a position to loop round and run another application (step <highlight><bold>420</bold></highlight>). </paragraph>
<paragraph id="P-0068" lvl="0"><number>&lsqb;0068&rsqb;</number> It is generally expected that the reinitialisation method will be similar in function to the initialisation method, but there may well be some differences. For example, it may be desired to reset static variables which were initialised implicitly. Another possibility is to allow some state or resources to persist between applications; for example, if a class always outputs to one particular log file which is set up by the initialisation method, it may be more efficient to keep this open in between successive Java VMs, transparent to the application. </paragraph>
<paragraph id="P-0069" lvl="0"><number>&lsqb;0069&rsqb;</number> It should be noted that whilst <cross-reference target="DRAWINGS">FIG. 4</cross-reference> indicates the distinct logical steps performed by the method of the invention, in practice these steps are not all independent. For example, calling the tidy-up methods (step <highlight><bold>440</bold></highlight>) is part of the overall Reset JVM operation (step <highlight><bold>430</bold></highlight>). Likewise, calling the reinitialisation methods (step <highlight><bold>455</bold></highlight>) is effectively part of the start-up processing of running the new application (step <highlight><bold>420</bold></highlight>). Thus reinitialisation is performed prior to first active use of a class, and this may occur at any stage of a program. Therefore class reinitialisation (like conventional initialisation) is not necessarily completed at start-up of the program, but rather can be regarded as potentially an ongoing process throughout the running of a program. </paragraph>
<paragraph id="P-0070" lvl="0"><number>&lsqb;0070&rsqb;</number> It will also be appreciated that there is some flexibility with regard to the ordering of the steps shown in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>. In particular, the decision of whether or not there is to be another application (step <highlight><bold>450</bold></highlight>) could be performed earlier, such as prior to the refresh heap step, the tidyup step, and/or the Reset JVM step. In the latter case, which corresponds to immediately after the first application has concluded (i.e. straight after step <highlight><bold>420</bold></highlight>), the alternative outcomes would be to destroy the Java VM (step <highlight><bold>460</bold></highlight>) if there were no further applications, or else to reset the JVM, tidy up, refresh the heap, and reinitialise (steps <highlight><bold>430</bold></highlight>, <highlight><bold>440</bold></highlight>, <highlight><bold>445</bold></highlight>, and <highlight><bold>455</bold></highlight>) if there were further applications. If instead the decision step <highlight><bold>450</bold></highlight> is intermediate these above two extreme positions, the logic flow can be determined accordingly. </paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> It should be noted that in the preferred embodiment, the ability to reset the Java VM, and to have tidyup and reinitialise methods, is only available for middleware classes (i.e. those loaded by the middleware class loader). This is to allow the middleware classes to be re-used by successive applications or transactions, for which they can perform various services. The basis for this approach is that typically the middleware is a relatively sophisticated and trusted application, and so can be allowed to take responsibility for proper implementation of the tidy-up and reinitialise methods. On the other hand, individual transactions are not treated as reliable. </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> Note also that the system classes themselves do not have tidyup or reinitialisation methods, despite persisting across a Java VM reset. Rather, if the middleware makes any change to a system class, then the middleware itself is expected to take the necessary action (if any) for a reset with respect to the system class as part of the middleware&apos;s own tidyup operation. </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> An important part of the Reset JVM/tidyup operation (steps <highlight><bold>430</bold></highlight> and <highlight><bold>440</bold></highlight>) in the preferred embodiment is to make sure that the Java VM is in a state which is amenable to being tidied up. If this is the case, the Java VM is regarded as being clean, if not, it is regarded as being dirty or unresettable. </paragraph>
<paragraph id="P-0074" lvl="0"><number>&lsqb;0074&rsqb;</number> Considering this in more detail, if the application has performed certain operations, then it will not be possible for the middleware classes to be certain that their tidy-up and reinitialise methods will fully reset the system to a fresh state. With such a contaminated Java VM, the system still calls the tidy-up methods of the class objects as per normal (step <highlight><bold>440</bold></highlight>), but the return code back to the middleware associated with the reset JVM operation (step <highlight><bold>430</bold></highlight>) effectively indicates failure. The expectation here is that the Java VM would actually be terminated by the middleware subsystem at this point, as it is no longer in a predictable condition. </paragraph>
<paragraph id="P-0075" lvl="0"><number>&lsqb;0075&rsqb;</number> One important situation which would prevent the Java VM from being able to properly reset is where the application has performed certain operations directly such as making security or environment changes, loading native code, or performing Abstract Windowing Toolkit (AWT) operations. These affect the state of the Java VM or the underlying computer system and cannot be reliably tidied up by the middleware, for the simple reason that the middleware does not necessarily know about them. Such changes could then persist through a Reset JVM call, and contaminate the Java VM for any future applications. In contrast, if an application performs such operations through a middleware call, then this does not cause any problems, because the middleware now does know about the situation and so can perform whatever tidyup measures are required. </paragraph>
<paragraph id="P-0076" lvl="0"><number>&lsqb;0076&rsqb;</number> The Java VM thus monitors for operations that may prevent proper reset, including whether they have been performed by an application or middleware. This is determined by the Java VM keeping track of its context, which is set to application context for an application class, and to middleware context for a middleware class, whilst a primordial or extension class has no impact on the existing context of application or middleware. In particular, context can be determined based on the type of class which contains the method that is currently being performed, whilst the type of class is determined from its original class loader. </paragraph>
<paragraph id="P-0077" lvl="0"><number>&lsqb;0077&rsqb;</number> As previously mentioned, the list of problematic operations given above only causes difficulty when performed in an application context, since in a middleware context it is possible for them to be reset by the appropriate tidy-up routines of the relevant middleware classes. </paragraph>
<paragraph id="P-0078" lvl="0"><number>&lsqb;0078&rsqb;</number> Referring now to <cross-reference target="DRAWINGS">FIG. 5</cross-reference>, in the preferred embodiment the heap <highlight><bold>140</bold></highlight> is split into three components. Objects in one component can reference objects in another component. At the bottom (logically) of heap <highlight><bold>140</bold></highlight> is middleware section <highlight><bold>510</bold></highlight>, and at the top of the heap is transient section <highlight><bold>520</bold></highlight>. The data in these two heaps grows towards each other, thus transient heap grows in the direction of arrow <highlight><bold>521</bold></highlight>, and middleware heap in the direction of arrow <highlight><bold>511</bold></highlight>. The middleware heap is defined by boundary <highlight><bold>512</bold></highlight>, and the transient heap by boundary <highlight><bold>522</bold></highlight>, with unassigned space <highlight><bold>515</bold></highlight> between them. It should be appreciated that boundaries <highlight><bold>512</bold></highlight> and <highlight><bold>522</bold></highlight> represent the maximum size currently assigned to the two heaps, rather than their current fill levels&mdash;these are instead shown by dashed lines <highlight><bold>513</bold></highlight> and <highlight><bold>523</bold></highlight>. In other words, as the middleware heap fills up, the fill level <highlight><bold>513</bold></highlight> will approach towards middleware heap boundary <highlight><bold>512</bold></highlight>; likewise as the transient heap fills up, the fill level <highlight><bold>523</bold></highlight> will approach towards transient heap boundary <highlight><bold>522</bold></highlight>. </paragraph>
<paragraph id="P-0079" lvl="0"><number>&lsqb;0079&rsqb;</number> Finally, and separate from the transient heap and middleware heap, is system heap <highlight><bold>550</bold></highlight>. Note that the combined transient and middleware heaps, together with intervening unassigned space, are allocated from a single physically contiguous block of memory <highlight><bold>560</bold></highlight>. In contrast, the system heap <highlight><bold>550</bold></highlight> may be formed from multiple non-contiguous regions of memory. </paragraph>
<paragraph id="P-0080" lvl="0"><number>&lsqb;0080&rsqb;</number> In one preferred embodiment, memory <highlight><bold>560</bold></highlight> comprises <highlight><bold>64</bold></highlight> MBytes, and the initial size of the middleware and transient heaps is 0.5 Mbyte each. Thus it can be seen that initially the unassigned region <highlight><bold>515</bold></highlight> dominates, although the transient and middleware heaps are allowed to expand into this space (details of the expansion policy are provided in the above mentioned GB 0027045.4 application, although these have no direct relevance to the present invention). However, the values quoted are exemplary only, and suitable values will vary widely according to machine architecture and size, and also the type of application. </paragraph>
<paragraph id="P-0081" lvl="0"><number>&lsqb;0081&rsqb;</number> Heap control block <highlight><bold>530</bold></highlight> is used for storing various information about the heap, such as the location of the heap within memory, and the limits of the transient and middleware sections as defined by limits <highlight><bold>512</bold></highlight> and <highlight><bold>522</bold></highlight>. Free chain block <highlight><bold>532</bold></highlight> is used for listing available storage locations within the middleware and transient sections (there is actually one free chain block for each section). Thus although the middleware and transient heaps start to fill sequentially, the likely result of a garbage collection cycle is that space may become available within a previously occupied region. Typically therefore there is no single fill line such as <highlight><bold>513</bold></highlight>, <highlight><bold>523</bold></highlight> between vacant and occupied space, rather a fragmented pattern. The free chain block is a linked list which specifies the location and size of empty regions within that section of the heap. It is quick to determine whether and where a requested amount of storage is available in the heap by simply scanning through the linked list. Note that in the preferred embodiment, empty regions in the heap which are below a predetermined size (typically a few hundred bytes) are excluded from the free chain list. This prevents the list from becoming too long through containing a large number of very small vacant regions, although it does mean that these regions effectively become inaccessible for storage (although they can be retrieved later, as described in more detail below). </paragraph>
<paragraph id="P-0082" lvl="0"><number>&lsqb;0082&rsqb;</number> The transient heap <highlight><bold>520</bold></highlight> is used for storing objects having no expected currency beyond the end of the application or transaction, including application object instances, and primordial object instances and arrays created by application methods (arrays can be regarded as a specialised form of object). Since the lifetime of such objects is commensurate with the application itself, it should be possible to delete all the objects in the transient heap at the end of the application. The application class objects are also on the transient heap. In contrast, the middleware heap <highlight><bold>510</bold></highlight> is used for storing objects which have a life expectancy longer than a single transaction, including middleware object instances, and primordial object instances and arrays created by middleware methods. In addition, string objects and arrays for strings interned in the Interned String Table are also stored in the middleware heap (the Interned String Table is a tool whereby if multiple identical strings are to be stored on the heap, it is possible to store only one copy of the string itself, which can then be referenced elsewhere). Lastly, the system heap <highlight><bold>550</bold></highlight> is used for storing primordial class objects and reusable class objects, where the term reusable class object is used to denote a class which can be used again after JVM reset. </paragraph>
<paragraph id="P-0083" lvl="0"><number>&lsqb;0083&rsqb;</number> The type of class is dependent on the class loader which originally loaded it, in other words a middleware class and an application class are loaded by the middleware class loader <highlight><bold>124</bold></highlight> and the application class loader <highlight><bold>120</bold></highlight> respectively. For the purposes of the present discussion, primordial classes can be considered as classes loaded by the Primordial or Extensions class loader (<highlight><bold>130</bold></highlight> and <highlight><bold>125</bold></highlight> respectively in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>). In the preferred embodiment, classes loaded by the middleware class loader are automatically regarded as reusable. </paragraph>
<paragraph id="P-0084" lvl="0"><number>&lsqb;0084&rsqb;</number> Instances of primordial classes, such as the basic string class java/lang/String, can be located either in the middleware heap or the transient heap, depending on the method which created them. In a preferred embodiment of the present invention, the determination of where to place such primordial class instances is based on the current context described above (also referred to as method-type). Thus if a method belonging to an application class is invoked, the context or method-type becomes Application, whilst if a method belonging to a middleware class is invoked, the method-type becomes Middleware. Finally, if a method belonging to a primordial class is invoked, the method-type is unchanged from its previous value. The context or method-type is stored in the Java frame for the method (which is stored on stack <highlight><bold>195</bold></highlight>&mdash;see <cross-reference target="DRAWINGS">FIG. 2</cross-reference>); at the completion of the method, the method-type reverts to its value at the time the method was invoked, which was stored in the previous frame. </paragraph>
<paragraph id="P-0085" lvl="0"><number>&lsqb;0085&rsqb;</number> It should be noted that for the above purpose a method belongs to the class that actually defines it. For example, if class A subclasses class B, but does not override method C, then method C belongs to class B. Therefore the method-type is that of class B, even if method C is being run for an instance of class A. In addition, the reason for tracking method-type on a per-thread basis is that it is possible for various threads within an application to be executing different methods having different context. </paragraph>
<paragraph id="P-0086" lvl="0"><number>&lsqb;0086&rsqb;</number> The transient region of the heap, containing objects created by the application or transaction, is subject to normal garbage collection. However, the intention is that it will be sufficiently large that this is unlikely to occur within the lifetime of a typical application, since as previously mentioned garbage collection is a relatively slow operation. At the end of each application, the transient region of the heap is reset. (The repetition of this pattern will thereby avoid having to perform garbage collection during most applications). In contrast the middleware region generally contains objects created by the trusted middleware. It is again subject to conventional garbage collection, although in a transaction environment it is expected that the majority of objects will be created in the transient heap, so that garbage collection is not expected to occur frequently. The middleware heap is not cleared between applications, but rather remains to give the middleware access to its persistent state (it is assumed that the middleware can take responsibility for resetting itself to the correct state to run the next application). </paragraph>
<paragraph id="P-0087" lvl="0"><number>&lsqb;0087&rsqb;</number> The preferred embodiment is actually somewhat more complicated than described above, in that it supports two types of application class loader, one of which is for standard application classes, the other for reusable application classes. The motivation here is that when the next transaction is to run, it will in fact require many of the same application classes as the previous transaction. Therefore it is desirable to retain some application classes rather than having to reload them, although certain additional processing is required to make them look newly loaded to the next transaction. Conversely it would be possible to have a second middleware class loader which is for non-reusable middleware classes. In the former situation the reusable application classes are treated essentially in the same manner as the reusable middleware classes, (eg loaded into the system heap); in the latter situation the non-reusable middleware classes would be treated similarly to the non-reusable application classes, but loaded into the middleware heap (since they may exist after the conclusion of a transaction, even if they do not endure for the next transaction). However, for present purposes in order to explain the invention more clearly, it will be assumed that all the middleware classes are reusable, and that none of the application classes are reusable. </paragraph>
<paragraph id="P-0088" lvl="0"><number>&lsqb;0088&rsqb;</number> Referring now to <cross-reference target="DRAWINGS">FIGS. 6A and 6B</cross-reference>, these illustrate the garbage collection strategy of the preferred embodiment. In particular, the method involves firstly a mark phase, which marks all objects in the heap that are currently in use (known as live or active objects), and secondly a sweep phase, which represents the actual deletion of objects from the heap. Note that general background on garbage collection algorithms can be found in &ldquo;Garbage Collection: Algorithms for Automatic Dynamic Memory Management&rdquo; by R Jones and R Lins, Wiley, 1996 (ISBN 0 471 94148 4), whilst one implementation for garbage collection in a system having multiple heaps is described in: &ldquo;A customisable memory management framework for C&plus;&plus;&rdquo; by G Attardi, T Flagella, and P Iglio, in Software Practice and Experience, vol 28/11, 1998. </paragraph>
<paragraph id="P-0089" lvl="0"><number>&lsqb;0089&rsqb;</number> As shown in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>A, the method starts with a review of the registers and stack, both the Java stack, as shown in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>, and also the C stack, (assuming that the Java VM <highlight><bold>40</bold></highlight> is running as a C application on OS <highlight><bold>30</bold></highlight>, see <cross-reference target="DRAWINGS">FIG. 1</cross-reference>) (step <highlight><bold>610</bold></highlight>). Each thirty-two bit data word (for a 32-bit system) contained therein could represent anything, for example a real number, or part of a string, but it is assumed at least initially that it may denote a 32 bit reference to an object location in the heap. To firm up on this assumption, three tests are made. Firstly, it is tested whether or not the number references a location within the heap (step <highlight><bold>612</bold></highlight>); if not then the number cannot represent an object reference. Secondly, in the preferred embodiment, all objects commence on an 8-byte boundary. Thus if the location corresponding to the data word from the stack/register does not fall on an object boundary (tested at step <highlight><bold>615</bold></highlight>), then the original assumption that the data/number represents a reference to the heap must again be rejected. Thirdly, in the preferred embodiment, a table <highlight><bold>538</bold></highlight> is maintained (see <cross-reference target="DRAWINGS">FIG. 5</cross-reference>) which has a bit for each object location in the heap; this bit is set to unity if there is an object stored at that location, and zero if no object is stored at that location (the relevant bit is updated appropriately whenever an object is created, deleted, or moved). If the data word from the stack/register corresponds to an object location for which the bit is zero, in other words, no object at that location, then once more the original assumption that the data/number represents a reference to the heap must be rejected (step <highlight><bold>620</bold></highlight>). If the data word passes all three of the tests of steps <highlight><bold>612</bold></highlight>, <highlight><bold>615</bold></highlight> and <highlight><bold>620</bold></highlight>, then there are three remaining possibilities: (a) the word references an object on the heap; (b) the word is an integer that happens to have the same value as the object reference; or (c) the word is a previous value from uninitialized storage. As a conservative measure, it is assumed that option (a) is correct, and so the object is marked as live (step <highlight><bold>625</bold></highlight>). A special array of bits is provided (block <highlight><bold>534</bold></highlight>, see <cross-reference target="DRAWINGS">FIG. 5</cross-reference>), one bit per object, in order to store these mark bits. If there remain other values on the stacks/registers to test (step <highlight><bold>630</bold></highlight>), the method then loops back to examine these in the same manner as just described; if not the first stage of the mark process is complete. The objects so far identified are known as &ldquo;roots&rdquo;, in the sense that any other objects which are still live must be referenced directly or indirectly from one of these objects. </paragraph>
<paragraph id="P-0090" lvl="0"><number>&lsqb;0090&rsqb;</number> In the second stage of the mark process, shown in <cross-reference target="DRAWINGS">FIG. 6</cross-reference>B, the objects marked as live (i.e. the roots) are copied onto a list of active objects (step <highlight><bold>635</bold></highlight>) (in the preferred embodiment objects are actually copied to the active list when originally marked, i.e. at the same time as step <highlight><bold>625</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 6A</cross-reference>). An object from this list is then selected (step <highlight><bold>640</bold></highlight>), and examined to see if it contains any references (step <highlight><bold>645</bold></highlight>). Note that this is a reasonably straightforward procedure, because the structure of the object is known from its corresponding class file, which defines the relevant variables to be used by the object. Any objects referenced by the selected object are themselves marked (step <highlight><bold>650</bold></highlight>) and added to the active list (step <highlight><bold>655</bold></highlight>). Next, the selected object is removed from the active list (step <highlight><bold>660</bold></highlight>), and then a test is performed (step <highlight><bold>665</bold></highlight>) to determine if the active list is empty; if not, processing loops back to step <highlight><bold>640</bold></highlight> to select another object from the active list. Finally, when step <highlight><bold>665</bold></highlight> produces a positive outcome, all objects that are active, because they are referenced directly or indirectly from the stacks or registers, have been appropriately marked. </paragraph>
<paragraph id="P-0091" lvl="0"><number>&lsqb;0091&rsqb;</number> The mark stage is then followed by a sweep stage (step <highlight><bold>670</bold></highlight>) and a compact stage (step <highlight><bold>675</bold></highlight>). The former garbage collects (i.e. deletes) all those objects which have not been marked, on the basis that they are no longer reachable from any live or active object. In particular, each object which is not marked as active has its corresponding bit set to zero in table <highlight><bold>538</bold></highlight> (see <cross-reference target="DRAWINGS">FIG. 5</cross-reference>). Runs of zeros in the bit allocation table <highlight><bold>538</bold></highlight> are now identified; these correspond to some combination of the object immediately preceding the run, which may extend into the run (since only the head of an object is marked in the bit allocation table), and free space (released or never filled). The amount of free space in the run of zeros can be determined by examining the size of the object immediately preceding the run. If the amount of free space exceeds the predetermined minimum amount mentioned earlier, then the run is added to the free chain list <highlight><bold>532</bold></highlight> (see <cross-reference target="DRAWINGS">FIG. 5</cross-reference>). </paragraph>
<paragraph id="P-0092" lvl="0"><number>&lsqb;0092&rsqb;</number> Over time, such sweeping will tend to produce many discontinuous vacant regions within the heap, corresponding to the pattern of deleted objects. This does not represent a particularly efficient configuration, and in addition there will be effective loss of those pieces of memory too small to be on the free list. Hence a compact stage (step <highlight><bold>675</bold></highlight>) can be performed, which acts to squeeze together those objects which remain in the heap after the sweep in order to amass them into a single continuous block of storage (one for the transient heap, one for the middleware heap). Essentially, this means relocating objects from their initial positions in the heap, to a new position so that, as much as possible, they are all adjacent to one another. As part of this compaction, the very small regions of memory too small to be on the free chain <highlight><bold>532</bold></highlight> (see <cross-reference target="DRAWINGS">FIG. 5</cross-reference>) should be aggregated into larger blocks that can be recorded in the free chain. </paragraph>
<paragraph id="P-0093" lvl="0"><number>&lsqb;0093&rsqb;</number> An important requirement of the object relocation of the compaction step is of course that references to a moved object are altered to point to its new location. This is a relatively straightforward operation for object references on the heap itself, since as previously mentioned, they can be identified from the known structure of each object, and updated to the appropriate new value. However, there is a problem with objects which are directly referenced from a register or stack. As discussed above, each number in the register/stack is treated for garbage collection purposes as if it were an object reference, but there is no certainty that this is actually the case; rather the number may represent an integer, a real number, or any other piece of data. It is therefore not possible to update any object references on the stack or register, because they may not in fact be an object reference, but rather some other piece of program data, which cannot of course be changed arbitrarily. The consequence of this is that it is impossible to move an object which appears to be directly referenced from the heap or stack; instead these objects must remain in their existing position. Such objects are informally known as &ldquo;dozed&rdquo; objects since they cannot be moved from their current position. </paragraph>
<paragraph id="P-0094" lvl="0"><number>&lsqb;0094&rsqb;</number> Two other classes of objects which cannot be moved from the heap are class objects, and thread objects (thread objects are control blocks used to store information about a thread). The reason for this is that such objects are referenced from so many other places in the system that it is not feasible to change all these other references. These objects are therefore known as &ldquo;pinned&rdquo;, since like dozed objects they cannot be moved from their current position. </paragraph>
<paragraph id="P-0095" lvl="0"><number>&lsqb;0095&rsqb;</number> A consequence of pinned and dozed objects is that a compact process may not be able to accumulate all objects in a heap into a single contiguous region of storage, in that pinned and dozed objects must remain in their original positions. </paragraph>
<paragraph id="P-0096" lvl="0"><number>&lsqb;0096&rsqb;</number> Note that in the preferred embodiment, a compact stage (step <highlight><bold>675</bold></highlight>) is not necessarily employed on every garbage collection cycle, unless this is explicitly requested as a user initial set-up option. Rather a compact operation is only performed when certain predetermined criteria are met. For example, as previously indicated a garbage collection can be triggered by a request for storage in the heap that cannot be satisfied. If the request still cannot be satisfied after the sweep step <highlight><bold>670</bold></highlight>, because there is no single block of memory available of sufficient size, then a compact stage is automatically performed, to try and accumulate an adequately-sized storage region. </paragraph>
<paragraph id="P-0097" lvl="0"><number>&lsqb;0097&rsqb;</number> An important aspect of the garbage collection process is that it operates by detecting all live objects; the remaining objects which are not live are then marked as dead. Consequently, for a given object, it is not possible to tell whether or not it is dead without effectively performing a full garbage collection. </paragraph>
<paragraph id="P-0098" lvl="0"><number>&lsqb;0098&rsqb;</number> One complication that arises from effectively having multiple heaps of potentially variable sizes is that it becomes more complex to determine whether or not a given object reference is within a heap (as required, for example, for step <highlight><bold>612</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 6A</cross-reference>), and if so which one (in case, for example, they have different garbage collection policies). One possibility is to compare the reference with the information in the heap control block <highlight><bold>530</bold></highlight> (see <cross-reference target="DRAWINGS">FIG. 5</cross-reference>). However, with multiple heaps, and also a system heap which is not necessarily contiguous, this becomes a time-consuming operation. </paragraph>
<paragraph id="P-0099" lvl="0"><number>&lsqb;0099&rsqb;</number> In order to overcome this problem, the preferred embodiment adopts the approach illustrated schematically in <cross-reference target="DRAWINGS">FIG. 7</cross-reference>. As shown, system address space or virtual memory <highlight><bold>800</bold></highlight> is split into chunks of a standard size, referred to herein as slices <highlight><bold>802</bold></highlight>. As previously mentioned, in the preferred embodiment on a 32 bit system, these slices are each 64 KBytes in size. The slices can be numbered linearly as shown with increasing address space. The heaps can then be allocated out of these slices, in such a way that heap space is always allocated or deallocated in terms of an integral number of slices. <cross-reference target="DRAWINGS">FIG. 7</cross-reference> shows three different heaps (for simplicity termed A , B and C), whereby heap A is non-contiguous and comprises slices <highlight><bold>3</bold></highlight>-<highlight><bold>4</bold></highlight> and <highlight><bold>6</bold></highlight>-<highlight><bold>7</bold></highlight>, heap B comprises slice <highlight><bold>9</bold></highlight>, and heap C is contiguous and comprises slices <highlight><bold>12</bold></highlight>-<highlight><bold>14</bold></highlight> inclusive. Note that two or more of these heaps may possibly be being managed as single block of storage (i.e. in the same manner as the transient and middleware heaps of <cross-reference target="DRAWINGS">FIG. 5</cross-reference>). </paragraph>
<paragraph id="P-0100" lvl="0"><number>&lsqb;0100&rsqb;</number> Also illustrated in <cross-reference target="DRAWINGS">FIG. 7</cross-reference> is lookup table <highlight><bold>825</bold></highlight>, which has two columns, the first <highlight><bold>830</bold></highlight> representing slice number, and the second <highlight><bold>831</bold></highlight> representing heap number. Thus each row of the table can be used to determine, for the relevant slice, which heap it is in&mdash;a value of zero (indicated by a dash) is assumed to indicate that the slice is not currently in a heap. The system updates table <highlight><bold>825</bold></highlight> whenever slices are allocated to or deallocated from the heap. </paragraph>
<paragraph id="P-0101" lvl="0"><number>&lsqb;0101&rsqb;</number> Using table <highlight><bold>825</bold></highlight> it now becomes very quick to determine whether a given memory address is in a heap. Thus an initial determination is made of the relevant slice, by dividing the given memory location (minus the system base memory location if non-zero) by the slice size, and rounding down to the next integer (i.e. truncating) to obtain the slice number. This can then be used to directly access the corresponding heap identifier in column <highlight><bold>831</bold></highlight>. In fact, it will be appreciated that column <highlight><bold>830</bold></highlight> of Table <highlight><bold>825</bold></highlight> does not need to be stored explicitly, since the memory location of each entry in column <highlight><bold>831</bold></highlight> is simply a linear function of slice number. More specifically, each entry in column <highlight><bold>831</bold></highlight> can typically be represented by 1 byte, and so the information for slice N can be found at the base location for table <highlight><bold>825</bold></highlight>, plus N bytes. Overall therefore, this approach provides a rapid mapping from object location to heap identity (if any), irrespective of the number of heaps, or the complexity of their configuration. </paragraph>
<paragraph id="P-0102" lvl="0"><number>&lsqb;0102&rsqb;</number> One problem however with the technique illustrated in <cross-reference target="DRAWINGS">FIG. 7</cross-reference> is that on 64 bit machines, the virtual memory or address space is so great that table <highlight><bold>825</bold></highlight> would become prohibitively large. Thus in a preferred embodiment for such systems, a modified mapping is used, as shown in <cross-reference target="DRAWINGS">FIG. 8</cross-reference>, which has an extra layer in the memory mapping arrangement. In the diagram, memory <highlight><bold>900</bold></highlight> represents the system address space or virtual memory, which as in <cross-reference target="DRAWINGS">FIG. 7</cross-reference> is divided into slices <highlight><bold>902</bold></highlight> (the difference from <cross-reference target="DRAWINGS">FIG. 7</cross-reference> being that on a 64 bit system, address space is much larger, so there are many more slices). <cross-reference target="DRAWINGS">FIG. 8</cross-reference> illustrates the location of two heaps, arbitrarily denoted A and B, with A comprising slices <highlight><bold>2</bold></highlight>-<highlight><bold>4</bold></highlight> inclusive, and B comprising slices <highlight><bold>1026</bold></highlight>-<highlight><bold>1028</bold></highlight> inclusive and also slices <highlight><bold>9723</bold></highlight>-<highlight><bold>9726</bold></highlight> inclusive. </paragraph>
<paragraph id="P-0103" lvl="0"><number>&lsqb;0103&rsqb;</number> Also shown in <cross-reference target="DRAWINGS">FIG. 8</cross-reference> are two lookup tables, <highlight><bold>925</bold></highlight>, <highlight><bold>926</bold></highlight>, each of which, for the sake of illustration, contains <highlight><bold>2048</bold></highlight> entries, and maps to a corresponding range of slices in address space <highlight><bold>900</bold></highlight>. Lookup table <highlight><bold>925</bold></highlight> maps slices <highlight><bold>0</bold></highlight>-<highlight><bold>2047</bold></highlight>, whilst lookup table <highlight><bold>926</bold></highlight> maps slices <highlight><bold>8192</bold></highlight>-<highlight><bold>10239</bold></highlight>. These lookup tables are directly analogous to that of <cross-reference target="DRAWINGS">FIG. 7</cross-reference>, in that they logically contain two columns, the first <highlight><bold>930</bold></highlight> identifying a slice number, and the second <highlight><bold>931</bold></highlight> the identity of any heap within that slice (or else zero). Tables <highlight><bold>925</bold></highlight> and <highlight><bold>926</bold></highlight> can be regarded as forming the lower level of the lookup hierarchy. </paragraph>
<paragraph id="P-0104" lvl="0"><number>&lsqb;0104&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> also depicts a higher layer in the lookup hierarchy, namely table <highlight><bold>940</bold></highlight>, which again logically contains two columns. The first column <highlight><bold>941</bold></highlight> logically represents the number of lookup table <highlight><bold>925</bold></highlight>, <highlight><bold>926</bold></highlight> in the next lower layer of the lookup hierarchy, whilst the second column <highlight><bold>942</bold></highlight> contains a pointer to the relevant lookup table. Thus the first row of column <highlight><bold>942</bold></highlight> contains a pointer <highlight><bold>951</bold></highlight> to table <highlight><bold>925</bold></highlight>, and the fifth row of column <highlight><bold>942</bold></highlight> contains a pointer <highlight><bold>952</bold></highlight> to table <highlight><bold>926</bold></highlight>. </paragraph>
<paragraph id="P-0105" lvl="0"><number>&lsqb;0105&rsqb;</number> It will be noted that to conserve space, lookup tables in the lower level of the hierarchy only exist where at least some of the corresponding slices are assigned to a heap. Thus for the particular arrangement of <cross-reference target="DRAWINGS">FIG. 8</cross-reference>, the lookup tables for slices <highlight><bold>2048</bold></highlight>-<highlight><bold>4095</bold></highlight>, <highlight><bold>4096</bold></highlight>-<highlight><bold>6143</bold></highlight>, and <highlight><bold>6144</bold></highlight>-<highlight><bold>8191</bold></highlight> have not been created, since none of these slices has been assigned to any heap. In other words, lookup tables <highlight><bold>925</bold></highlight>, <highlight><bold>926</bold></highlight>, etc for various slice ranges will be created and deleted according to whether any slices within that slice range are being utilised for the heap. If this is not the case, and the lookup table is deleted (or not created in the first place), the pointer in column <highlight><bold>942</bold></highlight> of top level lookup table <highlight><bold>940</bold></highlight> is set to zero. </paragraph>
<paragraph id="P-0106" lvl="0"><number>&lsqb;0106&rsqb;</number> The operation of the embodiment shown in <cross-reference target="DRAWINGS">FIG. 8</cross-reference> is analogous to that of <cross-reference target="DRAWINGS">FIG. 7</cross-reference>, except that there is an extra level of indirection involved in the hierarchy. Thus to determine whether a particular reference or address is within a heap, the correct row is determined based on a knowledge of the size of a slice <highlight><bold>902</bold></highlight>, and also the number of rows in each lower level lookup table <highlight><bold>925</bold></highlight>, <highlight><bold>926</bold></highlight>. It is expected that for most rows, the corresponding entry in column <highlight><bold>942</bold></highlight> will be null or zero, immediately indicating that that address is not in a heap slice. However, if the lookup selects a row which has a non-zero entry, this is then followed (using pointer <highlight><bold>951</bold></highlight>, <highlight><bold>952</bold></highlight> or equivalent) to the corresponding lookup table. The desired entry is then found by locating the row using the reference under investigation (allowing for which particular lookup table is involved), and examining the entry for that row in column <highlight><bold>931</bold></highlight>. This will indicate directly whether or not the slice containing the referenced location is in a heap, and if so, which one. </paragraph>
<paragraph id="P-0107" lvl="0"><number>&lsqb;0107&rsqb;</number> As an example of this, to investigate memory address 637405384 we first integer divide by 65536 (the size of a slice in the preferred embodiment), to give 9727 (truncated), implying we are in slice 9727. Next we perform an integer division of 9727 by 2048 (the number of entries in each lower level look-up table), to give 4 (truncated), implying we are in the 5th row of column <highlight><bold>941</bold></highlight>. It will be appreciated that we could have got here directly by dividing 637405384 by 134217728 (which equals 2048&times;65536, or in other words, the total number of addresses per lower level lookup table). In any event, from the 5th row of table <highlight><bold>940</bold></highlight>, it is determined that the corresponding entry in column <highlight><bold>941</bold></highlight> is non-zero, so that the specified address may possibly lie in a heap. Accordingly, pointer <highlight><bold>952</bold></highlight> is followed to table <highlight><bold>926</bold></highlight>. Here we can determine that the row of interest is number 1535 (equal to 9727 modulo 2048), from which we can see that this particular slice is not, after all, part of heap. It follows of course that this is also true for any address within this slice. </paragraph>
<paragraph id="P-0108" lvl="0"><number>&lsqb;0108&rsqb;</number> Returning now to <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, as previously described, at the end of a transaction the transient heap is deleted (equivalent to the refresh heap step <highlight><bold>445</bold></highlight>, performed as part of the Reset JVM). This activity is generally similar to garbage collection, although certain optimizations are possible, and certain additional constraints need to be considered. This process is shown in more detail in the flow chart of <cross-reference target="DRAWINGS">FIG. 9</cross-reference> (which is split for convenience into two components, <highlight><bold>9</bold></highlight>A and <highlight><bold>9</bold></highlight>B). The first step in <cross-reference target="DRAWINGS">FIG. 9A</cross-reference> (<highlight><bold>1005</bold></highlight>) is to wait for all finalization activity to complete. Thus if there has been a GC during a transaction then there may be finalizers to be run and they must be run before the transient heap can be reset, as the finalizers could create (or require) other objects. This checking is performed by confirming that there are no objects waiting for the finalizer thread, and that there are no other in-progress objects (i.e. the processing of all pending finalization objects has been completed). Next all the locks required for garbage collection are obtained, and all other threads are suspended (step <highlight><bold>1010</bold></highlight>). The system is now in a position to commence deletion of the transient heap. </paragraph>
<paragraph id="P-0109" lvl="0"><number>&lsqb;0109&rsqb;</number> In order to accomplish this, the stacks and registers of all threads are scanned (as for a normal garbage collection). Any potential references to the transient heap can be found, for example using the approach described in relation to <cross-reference target="DRAWINGS">FIG. 7</cross-reference> or <highlight><bold>8</bold></highlight> (step <highlight><bold>1015</bold></highlight>). Should such a reference to the transient heap be located, then the Java VM is potentially dirty and so cannot be reset. The reason for this as discussed in relation to standard garbage collection (<cross-reference target="DRAWINGS">FIG. 6</cross-reference>) is that the references on the stacks and registers must be treated as live, even though it is not certain that they are in fact object references. To firm up on this the references are tested to see if it is possible to exclude them from being object references (step <highlight><bold>1020</bold></highlight>), essentially by using the same three tests <highlight><bold>612</bold></highlight>, <highlight><bold>615</bold></highlight> and <highlight><bold>620</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 6</cross-reference>. In other words, if the possible reference is not on the heap, or does not fall on an 8-byte boundary, or does not correspond to an allocated memory location, then it cannot in fact be a reference. Otherwise, the register or stack value may still be a reference, and so processing has to exit with an error that the Java VM is dirty and cannot be reset (step <highlight><bold>1099</bold></highlight>). Note that references from the stacks or registers to the middleware or system heap are of course acceptable, because objects on these heaps are not being deleted. </paragraph>
<paragraph id="P-0110" lvl="0"><number>&lsqb;0110&rsqb;</number> It will be appreciated that based on the above, a spurious data value in a stack or register will sometimes prevent Java VM reset. However this happens relatively infrequently in practice, because all but the main application thread and certain system threads should have terminated at this point, so the stacks are relatively empty (n.b. the policy adopted in the preferred embodiment is that a Java VM cannot be reset if more than a single transaction thread was used; multiple middleware threads are tolerated providing they have terminated by the completion of the middleware tidyups). Related to this, finalizer objects on the transient heap are retained in that heap until a Java VM reset. This means that references to such objects are not entered onto the stack for the finalizer thread, which would otherwise typically cause the reset to fail at steps <highlight><bold>1015</bold></highlight> and <highlight><bold>1020</bold></highlight> (this would be the case even where the finalise method for the object had been finished, since this would not necessarily lead to complete deletion of the corresponding stack entry; rather the finalizer thread may enter a function to wait for more work, resulting in uninitialized areas on the stack which may point to previously processed finalizer objects). </paragraph>
<paragraph id="P-0111" lvl="0"><number>&lsqb;0111&rsqb;</number> It is important to note that error <highlight><bold>1099</bold></highlight> indicating that the Java VM is dirty does not imply that previous processing was incorrect, merely that the Java VM cannot be reset (although of course this may in turn indicate some unexpected action by the application). In other words, a new Java VM will need to be created for the next application. Because of this, if it is detected that the Java VM is dirty, such as a negative outcome at step <highlight><bold>1020</bold></highlight>, the method normally proceeds immediately to step <highlight><bold>1099</bold></highlight>. This returns an error code to the Reset JVM request from the middleware, with no attempt to continue to perform any further garbage collection. The reason for this is that the middleware may want to do a little more tidying up, but generally it is expected that it will terminate the current Java VM fairly quickly. Hence there is unlikely to be a need for any further garbage collection, which rather would represent an unnecessary waste of time. A similar policy is adopted whenever the processing of <cross-reference target="DRAWINGS">FIG. 9</cross-reference> indicates that the Java VM is dirty. </paragraph>
<paragraph id="P-0112" lvl="0"><number>&lsqb;0112&rsqb;</number> Assuming now a negative result from step <highlight><bold>1015</bold></highlight> or <highlight><bold>1020</bold></highlight>, the stacks and registers are now examined for any potential references to the middleware heap (step <highlight><bold>1021</bold></highlight>). If any such references are found, these are again checked to see if they could be objects (step <highlight><bold>1022</bold></highlight>), using essentially the same checks as described in relation to step <highlight><bold>1020</bold></highlight>. If any such potential reference is indeed to an object, than as described in more detail below, a card table is marked accordingly. As previously mentioned however, the presence of such references from a stack or register into the middleware heap is not a problem as far as reset is concerned. Note also that in the preferred embodiment, the scans of steps <highlight><bold>1015</bold></highlight> and <highlight><bold>1021</bold></highlight> are in practice combined into a single logical scan. </paragraph>
<paragraph id="P-0113" lvl="0"><number>&lsqb;0113&rsqb;</number> The Java VM refresh now continues with an examination of the primordial statics fields (step <highlight><bold>1025</bold></highlight>) to see what objects they reference. Since these fields will be retained through the Java VM reset, it is important that the objects that they reference, either directly or indirectly, are likewise retained. If however the referenced objects are application objects (tested at step <highlight><bold>1030</bold></highlight>) then clearly these cannot be retained, because the application has essentially terminated, and the purpose of resetting the Java VM is to allow a new application to commence. Therefore, if the primordial statics do reference an application object, then the Java VM is marked as dirty, and the method proceeds to error <highlight><bold>1099</bold></highlight>. </paragraph>
<paragraph id="P-0114" lvl="0"><number>&lsqb;0114&rsqb;</number> Assuming that the objects in the transient heap referenced by the primordial static fields are not an application objects (typically they will be primordial object instances or arrays), then these are moved (&ldquo;promoted&rdquo;) from the transient heap to the middleware heap (step <highlight><bold>1035</bold></highlight>). The reason why such objects are placed on the transient heap initially is that at allocation time, it may not be known that the object to be allocated is a primordial static variable, or reachable from one. Since a promoted object is now newly on the middleware heap, it is necessary to examine any references that the promoted object itself contains. This is described in more detail below. To allow other objects which reference the promoted object to locate its new position, a sort of forwarding address is temporarily stored in the original location of the promoted object. This forwarding address can be deleted (along with the rest of the transient heap) once all the other objects have had their reference to the promoted object properly updated. </paragraph>
<paragraph id="P-0115" lvl="0"><number>&lsqb;0115&rsqb;</number> (Note that this promotion of objects bears some similarities to generational garbage collection, in which new objects are initially allocated to a short-term heap, and then promoted to a longer-term heap if they survive beyond a certain time, but the criterion for promotion is different: essentially it is based on object type or usage, rather than age. Generational garbage collection is discussed further in the book by Jones and Lin referenced above). </paragraph>
<paragraph id="P-0116" lvl="0"><number>&lsqb;0116&rsqb;</number> After the primordial static objects have been promoted, the next step is to review the card table. The card table is shown as block <highlight><bold>536</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 5</cross-reference>, and in more detail in <cross-reference target="DRAWINGS">FIG. 12</cross-reference>. The card table comprises pairs of bytes, each pair corresponding to a fixed unit of the heap (for example 512 bytes), and comprising one byte from a first column, <highlight><bold>1301</bold></highlight>, and one byte from a second column, <highlight><bold>1302</bold></highlight>. The first column is used to indicate a card that is potentially dirty (containing a pointer from the middleware heap into the transient heap, hereinafter termed a crossheap pointer), and the second column is used to indicate a card that is live (and so cannot be garbage collected). </paragraph>
<paragraph id="P-0117" lvl="0"><number>&lsqb;0117&rsqb;</number> The operation of the card table is shown in <cross-reference target="DRAWINGS">FIG. 11</cross-reference>. This depicts a write barrier that is triggered by an update to an object during normal processing of the transaction (i.e. prior to reset). The first step of this processing (step <highlight><bold>1210</bold></highlight>) is a test to see whether or not the update involves writing an object reference into the heap. If not, some other piece of data (such as an integer field) that cannot represent a pointer into the transient heap is being stored, and consequently the method exits. </paragraph>
<paragraph id="P-0118" lvl="0"><number>&lsqb;0118&rsqb;</number> On the other hand, if the data being stored is indeed an object reference, then a test is made (step <highlight><bold>1220</bold></highlight>) to determine whether the object reference is being written into the middleware heap; if not, the method again exits. Next a test is made to determine whether the object reference points to the transient heap (step <highlight><bold>1230</bold></highlight>). The tests of step <highlight><bold>1220</bold></highlight> and <highlight><bold>1230</bold></highlight> can both be implemented using the lookup table structure described in relation to <cross-reference target="DRAWINGS">FIGS. 7 and 8</cross-reference>. </paragraph>
<paragraph id="P-0119" lvl="0"><number>&lsqb;0119&rsqb;</number> It will be appreciated that a positive outcome from step <highlight><bold>1230</bold></highlight> indicates that we are writing a crossheap pointer, i.e. one from the middleware heap into the transient heap. Therefore the card in the first column <highlight><bold>1301</bold></highlight> of the card table that corresponds to the object having the reference written into it is updated to a predetermined value (step <highlight><bold>1240</bold></highlight>). More precisely, the card updated corresponds not to the unit of the heap which contains the updated object reference itself, but rather to the unit of heap which contains the top of the object that includes the new or modified reference (for a small object these may of course be the same). </paragraph>
<paragraph id="P-0120" lvl="0"><number>&lsqb;0120&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 12</cross-reference> illustrates certain cards that have had their first byte updated to the predetermined value as signified schematically by an &ldquo;X&rdquo; (eg card <highlight><bold>1304</bold></highlight>). Marking the first column <highlight><bold>1301</bold></highlight> of the card table in this manner indicates that the relevant card is dirty, in the sense that it (or more accurately, its corresponding unit of the heap) presently contains a crossheap pointer. However, it should be appreciated that this does not necessarily imply, at reset, that the Java VM itself is dirty, since the reference may have subsequently been modified or deleted. </paragraph>
<paragraph id="P-0121" lvl="0"><number>&lsqb;0121&rsqb;</number> Returning now to step <highlight><bold>1230</bold></highlight>, if this produces a negative result, then this implies that the reference is to an object on the middleware heap itself. A test is then made (step <highlight><bold>1250</bold></highlight>) to determine whether the referenced object is in the same heap unit (i.e. corresponding to the same card) as the object from which the reference is made (again this is based on the unit of heap which contains the start of the relevant objects). If the referenced object is in the same card as the referencing object, the method exits. However, if this is not the case, the card corresponding to the unit of the heap containing the referenced object has its entry in the second column <highlight><bold>1302</bold></highlight> of the card table updated to a predetermined value. This effectively means that the unit of memory corresponding to the card is potentially &ldquo;live&rdquo;. <cross-reference target="DRAWINGS">FIG. 12</cross-reference> also illustrates certain cards which have had their second byte updated to the predetermined value (which need not be the same as used for the first byte), as signified schematically again by an &ldquo;X&rdquo; (e.g. card <highlight><bold>1305</bold></highlight>). </paragraph>
<paragraph id="P-0122" lvl="0"><number>&lsqb;0122&rsqb;</number> Given that the processing of <cross-reference target="DRAWINGS">FIG. 11</cross-reference> represents a write barrier which is performed each time an object reference is updated, it is important that it proceeds as quickly as possible. This explains why each card comprises a pair of bytes, despite each byte containing only a single bit of information. The Java language does not directly support bit operations, but rather operations on whole bytes can be performed more quickly (in other languages such as C which do support bit operations for example, it may be appropriate to have the card table as some kind of bit map). </paragraph>
<paragraph id="P-0123" lvl="0"><number>&lsqb;0123&rsqb;</number> Given that bit operations are not supported, the reason for having two separate bytes, one to mark as dirty, one to mark as live, is again to allow the update to be performed as quickly as possible. This can be seen by considering the situation where only a single byte is used to store both pieces of information (eg <highlight><bold>0</bold></highlight> for not dirty, not live; <highlight><bold>1</bold></highlight> for dirty, not live; <highlight><bold>2</bold></highlight> for not dirty, live; <highlight><bold>3</bold></highlight> for dirty, live). With this arrangement, the update at step <highlight><bold>1240</bold></highlight> would need to write <highlight><bold>1</bold></highlight> if the original value of the byte were 0, and 3 if the original value of the byte were 2. Thus a test would be needed on the original value of the byte, which increases path length. </paragraph>
<paragraph id="P-0124" lvl="0"><number>&lsqb;0124&rsqb;</number> Even more significantly, if both aspects were encoded into the same byte, it would be necessary to lock the card in order to perform an update. Otherwise, consider two processes that simultaneously try to access a card, and that both read its initial value as 0. If one process is trying to update the card to 1, and the other to 2, the result will be unpredictable (1 or 2, depending on which process completes last), and in any event incorrect, since the true new value should be 3. This inconsistency could only be overcome by locking the object during the read/write operation on the card, which is a very time-consuming requirement. </paragraph>
<paragraph id="P-0125" lvl="0"><number>&lsqb;0125&rsqb;</number> Instead, by having separate bytes to indicate dirty/non-dirty and live/non-live, the need for locking and any comparison with the current card value is eliminated. Thus the initial setting of a card is always non-live and non-dirty. Any updates made to it by step <highlight><bold>1240</bold></highlight> then set the first component to dirty, and any updates made to it by step <highlight><bold>1260</bold></highlight> set the second component to live. Therefore even if multiple processes try to update the card simultaneously at step <highlight><bold>1240</bold></highlight>, the result will always be the correct one (that the relevant card component is marked as live and/or dirty) irrespective of the order in which the updates are actually applied. </paragraph>
<paragraph id="P-0126" lvl="0"><number>&lsqb;0126&rsqb;</number> The processing shown in <cross-reference target="DRAWINGS">FIG. 11</cross-reference> is also relevant when promoting an object, as described at step <highlight><bold>1035</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 9</cross-reference>A, albeit with certain changes. Thus the promoted object is examined to see if it contains any references (corresponding to step <highlight><bold>1210</bold></highlight>). If so, we pass directly through to the positive outcome of step <highlight><bold>1220</bold></highlight> (since we know that the newly promoted object must be in the middleware heap), to determine where each reference points. If a reference points into a different card in the middleware heap, then this produces a negative outcome at steps <highlight><bold>1230</bold></highlight> and <highlight><bold>1250</bold></highlight>, and leads to updating the second column of the card table (step <highlight><bold>1260</bold></highlight>); as before, the card updated corresponds to the portion of the heap containing the referenced object. On the other hand, if a reference points to the transient heap, then updating the first column of the card table of step <highlight><bold>1240</bold></highlight> as shown in <cross-reference target="DRAWINGS">FIG. 11</cross-reference> is replaced by one of two different actions, depending on the nature of the object referenced. In particular, if the object referenced is an application object, then analogous to step <highlight><bold>1030</bold></highlight>, this leads to an error preventing reset (step <highlight><bold>1099</bold></highlight>). Alternatively, if the object referenced can be promoted, then this is done, which effectively takes us back to step <highlight><bold>1035</bold></highlight>. The newly promoted object must then be scanned itself for references, and we again go through the processing of <cross-reference target="DRAWINGS">FIG. 11</cross-reference> (modified as described above). This processing is repeated for each object reference in a promoted object, which in practice can sometimes lead to whole chains of primordial objects being promoted at this stage. </paragraph>
<paragraph id="P-0127" lvl="0"><number>&lsqb;0127&rsqb;</number> It will be appreciated that the structure of the card table shown in <cross-reference target="DRAWINGS">FIG. 12</cross-reference> is illustrative only, and may be adapted to any suitable configuration for performance reasons, especially speed of access. For example, it may be decided to have the second column <highlight><bold>1302</bold></highlight> following the first column <highlight><bold>1301</bold></highlight> in memory, rather than having byte pairs for a single card adjacent to one another. It will also be appreciated with respect to the flowchart of <cross-reference target="DRAWINGS">FIG. 11</cross-reference> that various modifications could be made. Thus one possibility is to move step <highlight><bold>1240</bold></highlight> up before step <highlight><bold>1220</bold></highlight>, so that marking the first card simply indicates any pointer update (rather than specifically a crossheap pointer). This change would make it slightly easier to support the option of a simplified write barrier, as discussed below, where reset performance is not a major concern. </paragraph>
<paragraph id="P-0128" lvl="0"><number>&lsqb;0128&rsqb;</number> Returning now to <cross-reference target="DRAWINGS">FIG. 9</cross-reference>, the first column of the card table is scanned (step <highlight><bold>1040</bold></highlight>), one card at a time, during reset of the Java VM. More particularly those cards which correspond to the region currently assigned to the middleware heap are scanned. Thus cards for the transient heap <highlight><bold>520</bold></highlight> and for the unassigned region <highlight><bold>510</bold></highlight> are not scanned. As part of this review, it is first determined for each card if it is marked as dirty (step <highlight><bold>1045</bold></highlight>); i.e. whether the first byte in <cross-reference target="DRAWINGS">FIG. 12</cross-reference> is set for that card. If so, this indicates that a crossheap pointer has been stored in the corresponding portion of the middleware heap since the last Java VM reset, and so it must be checked to confirm that it does not still validly point to the transient heap. </paragraph>
<paragraph id="P-0129" lvl="0"><number>&lsqb;0129&rsqb;</number> Consequently, in step <highlight><bold>1048</bold></highlight> it is determined whether the relevant object is potentially live, by examining the second byte in the card table pair (i.e. from column <highlight><bold>1301</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 12</cross-reference>). If this second byte is not set, and assuming the card is not otherwise referenced (see below) the card cannot be live (an example of such a card is <highlight><bold>1304</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 12</cross-reference>). Thus the object that contains the crossheap pointer that originally triggered marking the card as dirty is no longer valid because it is not now being used. Consequently this card can be ignored, and the scan of the card table can continue to the next card. If it turns out that there are no cards in the card table that are marked as both dirty and live, then the negative path from step <highlight><bold>1048</bold></highlight> can be followed to the next stage of processing (see <cross-reference target="DRAWINGS">FIG. 9B</cross-reference>). </paragraph>
<paragraph id="P-0130" lvl="0"><number>&lsqb;0130&rsqb;</number> To understand why the card table <highlight><bold>536</bold></highlight> successfully identifies those cards which potentially contain live objects, an object is only live if it is referenced directly or indirectly from a root. Now in step <highlight><bold>1023</bold></highlight> described above, all cards containing a root (i.e. a reference from a stack or register) are marked at reset in the second column. This caters therefore for all the direct references from a root. As regards any indirect reference from a root, this must be via an object, and the write barrier of <cross-reference target="DRAWINGS">FIG. 11</cross-reference> marks all those cards containing objects that are referenced from elsewhere (including allowance for promoted objects as described above). </paragraph>
<paragraph id="P-0131" lvl="0"><number>&lsqb;0131&rsqb;</number> In particular, the process of <cross-reference target="DRAWINGS">FIG. 11</cross-reference> marks the cards for objects on the middleware heap as they are referenced, with two exceptions. Firstly, with respect to the test of step <highlight><bold>1220</bold></highlight>, if the referencing object is located in the transient heap, then the second column of the card table is not marked. This is because it is assumed that the referencing object will be deleted along with the rest of the transient heap at reset; should this not be the case (because the object on the transient heap is referenced for example from the stack), then this will already have been detected (e.g. at step <highlight><bold>1015</bold></highlight>), and reset prevented. In other words, a reference at reset to a middleware object from an object on the transient heap cannot make the middleware object live in this context; either the transient object itself is dead, in which case the reference can be ignored, or the transient object is still live, in which case reset is prevented and effectively the whole system must be terminated. </paragraph>
<paragraph id="P-0132" lvl="0"><number>&lsqb;0132&rsqb;</number> The second exception for marking the second column of the card table is that, as per step <highlight><bold>1250</bold></highlight>, a reference to another object in the same card does not need to be marked. This is because this card will be marked as long as the referencing object is still live; if the referencing object is not live, then the referenced object can likewise be ignored. </paragraph>
<paragraph id="P-0133" lvl="0"><number>&lsqb;0133&rsqb;</number> To see this more clearly, consider an object A. If object A in a card is a root, then the card will be marked in accordance with step <highlight><bold>1023</bold></highlight>. On the other hand, if the card is not marked as being a root, then object A is only live if pointed to from a root. Thus there must be a chain of one or more references from a root to the card for object A (otherwise we can be certain that all the objects in the card of object A are no longer live). This chain from a root into the object A must at some stage in its length pass from outside the card containing object A (since the chain starts with a root which is outside this card), into the card containing object A, in order for it to terminate on object A. Thus as long as we pick up the chain on entering into the card of object A (which should produce a negative test at step <highlight><bold>1230</bold></highlight>), and then mark this card as live, we have no interest in any further length of the chain lying purely within the card corresponding to object A. </paragraph>
<paragraph id="P-0134" lvl="0"><number>&lsqb;0134&rsqb;</number> To illustrate the above, <cross-reference target="DRAWINGS">FIG. 10</cross-reference> depicts a section of middleware heap <highlight><bold>510</bold></highlight> and card table <highlight><bold>536</bold></highlight>, showing three cards <highlight><bold>1411</bold></highlight>, <highlight><bold>1412</bold></highlight>, and <highlight><bold>1413</bold></highlight>, together with their corresponding heap sections <highlight><bold>1401</bold></highlight>, <highlight><bold>1402</bold></highlight>, and <highlight><bold>1403</bold></highlight> respectively. Heap section <highlight><bold>1402</bold></highlight> contains object O<highlight><bold>1</bold></highlight>, which in turn references object O<highlight><bold>2</bold></highlight> via pointer <highlight><bold>1421</bold></highlight>, and object O<highlight><bold>2</bold></highlight> in turn references object O<highlight><bold>3</bold></highlight> via pointer <highlight><bold>1422</bold></highlight>. When writing both pointer <highlight><bold>1421</bold></highlight> and pointer <highlight><bold>1422</bold></highlight>, the test of step <highlight><bold>1250</bold></highlight> is positive, and so no entry is made into either column of the relevant card <highlight><bold>1412</bold></highlight>. Next, assume that a pointer <highlight><bold>1425</bold></highlight> is created from O<highlight><bold>3</bold></highlight> into the transient heap. Now an entry is made into the first column of card <highlight><bold>1412</bold></highlight> (marked as <highlight><bold>1431</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 10</cross-reference>), to show that an object within this card has been updated to contain a reference to the transient heap (i.e. it is potentially dirty). Finally, when the pointer <highlight><bold>1423</bold></highlight> from O<highlight><bold>4</bold></highlight> to O<highlight><bold>1</bold></highlight> is created, this does represent a middleware reference from one card to another. Consequently, the second column of the card table for the card corresponding to O<highlight><bold>1</bold></highlight> is also updated (mark <highlight><bold>1433</bold></highlight>) to show that this card is potentially live. </paragraph>
<paragraph id="P-0135" lvl="0"><number>&lsqb;0135&rsqb;</number> Returning to step <highlight><bold>1048</bold></highlight>, as soon as a card is located that is marked as both dirty and also as live (an example of such a card is <highlight><bold>1303</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 12</cross-reference>, or card <highlight><bold>1412</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 10</cross-reference>), then there is potentially a live crossheap pointer that could prevent reset. However, this is not certain, because we only know that the relevant card contained at one time firstly an object with a crossheap pointer and secondly an object that is live&mdash;we do not know that these are actually the same object, in other words that the crossheap pointer still exists, or that the object containing it is live (the card could be marked as live because of a reference to some completely different object in the card). </paragraph>
<paragraph id="P-0136" lvl="0"><number>&lsqb;0136&rsqb;</number> To see this more clearly, if we remove pointer <highlight><bold>1421</bold></highlight> from O<highlight><bold>1</bold></highlight> to O<highlight><bold>2</bold></highlight>, then the card table would not be changed, but only O<highlight><bold>1</bold></highlight> would be potentially live via the reference from O<highlight><bold>4</bold></highlight>&mdash;not O<highlight><bold>2</bold></highlight> or O<highlight><bold>3</bold></highlight>. Therefore the cross-heap pointer <highlight><bold>1425</bold></highlight> from O<highlight><bold>3</bold></highlight> can in fact be ignored. However, the card table lacks the granularity to make this determination. It should also be noted that we have effectively assumed that O<highlight><bold>4</bold></highlight> is live, although this may not necessarily be the case. Thus the design of the card table is conservative, in that it marks everything that may possibly be dirty and live, even although neither of these may actually be true of any object within the card at reset. </paragraph>
<paragraph id="P-0137" lvl="0"><number>&lsqb;0137&rsqb;</number> Accordingly, as soon as a card is found which does produce a positive outcome to step <highlight><bold>1048</bold></highlight>, further testing must be done to see if there is a genuine problem. The first part of this testing looks at all the object references in objects which start in the heap unit corresponding to the marked card. For all objects associated with a marked card, all references contained in those objects (even if the references themselves are outside the unit of the heap corresponding to the card) are checked to see if they point to the transient heap (step <highlight><bold>1050</bold></highlight>). If they do not, for example they contain only null pointers, and/or references to the middleware heap, then this is not a problem for Java VM reset, and we can continue with the scan of the card table (step <highlight><bold>1040</bold></highlight>). On the other hand, if there are any such pointers to the transient heap from the middleware heap, this will be a problem on reset since those references will no longer be valid once the transient heap is cleared. The exceptions to this are where the objects containing these problematic references are no longer live (i.e. could be garbage collected), or are primordial and can be successfully promoted. </paragraph>
<paragraph id="P-0138" lvl="0"><number>&lsqb;0138&rsqb;</number> Note that in step <highlight><bold>1050</bold></highlight> there is no need to perform tests analogous to step <highlight><bold>1020</bold></highlight> to see if the address does correspond to an object (such as being on an 8-byte boundary, etc). This is because the scan card process uses the known class structure of an object to specifically pick out any object references therein, rather than simply looking for some data value that may potentially represent an object reference to an address in the transient heap. </paragraph>
<paragraph id="P-0139" lvl="0"><number>&lsqb;0139&rsqb;</number> On a positive outcome to step <highlight><bold>1050</bold></highlight>, and indeed immediately a single such reference is found (because this is enough to potentially prevent reset) the system performs the mark phase of a garbage collection (step <highlight><bold>1055</bold></highlight>), which is a relatively long operation. The purpose of this garbage collection is that if the problematic (cross-heap) references are in objects which are marked (i.e. live), as tested at step <highlight><bold>1060</bold></highlight>, then the JVM must be regarded as dirty; hence the method proceeds to error <highlight><bold>1099</bold></highlight>. On the other hand, if the problematic references are in objects which are not marked, then these references can effectively be ignored, since these objects are no longer live. </paragraph>
<paragraph id="P-0140" lvl="0"><number>&lsqb;0140&rsqb;</number> A further possibility as mentioned above is that the reference is actually to a primordial object which can be promoted into the middleware heap. This processing is shown as step <highlight><bold>1058</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 9</cross-reference>, is largely analogous to step <highlight><bold>1035</bold></highlight> (which only promoted a limited subset of primordial objects, namely those referenced by primordial statics). Any such promoted objects also now need to be checked for any pointers back to the transient heap. In some situations this can lead to a chain of primordial objects being promoted from the transient heap back up to the middleware heap. (Note that although step <highlight><bold>1058</bold></highlight> is shown separately from the GC mark phase in step <highlight><bold>1055</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 9</cross-reference>A, they are actually performed together in the preferred implementation). </paragraph>
<paragraph id="P-0141" lvl="0"><number>&lsqb;0141&rsqb;</number> One complication is that the heaps may have been compacted during a transaction, as previously described in relation to garbage collection. This then invalidates the card table. In such cases a full scan of the middleware heap is then performed automatically to locate any object references to the transient heap, equivalent to the garbage collection mark phase of step <highlight><bold>1055</bold></highlight>. Note however that compaction is such a long operation that in this case the extra time taken at reset is, in relative terms, not so important. As previously indicated, the intention is that most transactions will not require garbage collection (or compaction). </paragraph>
<paragraph id="P-0142" lvl="0"><number>&lsqb;0142&rsqb;</number> Assuming that the test of step <highlight><bold>1060</bold></highlight> produces a negative output (i.e. no live middleware references to the transient heap), the method proceeds to scan for Java Native Interface (JNI) global references. These are references which are used by native code routines (i.e. running directly on OS <highlight><bold>30</bold></highlight> rather than on Java VM <highlight><bold>40</bold></highlight>, see <cross-reference target="DRAWINGS">FIG. 1</cross-reference>) to refer to Java objects. Using the JNI such references can be made global, that is available to all threads, in which case they will exist independently of the thread that created them. All such JNI global reference slots are scanned (step <highlight><bold>1065</bold></highlight>) (see <cross-reference target="DRAWINGS">FIG. 9B</cross-reference>) and if a reference to the transient heap is found (step <highlight><bold>1070</bold></highlight>) the Java VM is marked as dirty (i.e. error <highlight><bold>1099</bold></highlight>), since these references will clearly fail once the transient heap is reset. </paragraph>
<paragraph id="P-0143" lvl="0"><number>&lsqb;0143&rsqb;</number> Providing this is not the case, the JNI weak references are scanned next (step <highlight><bold>1072</bold></highlight>). These are references which the application specifies using JNI as expendable, in that they can be deleted if no longer used. According, any such weak JNI references to the transient heap that are found can be nulled (step <highlight><bold>1074</bold></highlight>), thereby permitting the Java VM reset to proceed. </paragraph>
<paragraph id="P-0144" lvl="0"><number>&lsqb;0144&rsqb;</number> Next, the static variables of all middleware classes are scanned (step <highlight><bold>1076</bold></highlight>) to see if any directly reference the transient heap (step <highlight><bold>1078</bold></highlight>). Note that these won&apos;t previously have been examined, since they are on the system heap rather than the middleware heap. If a direct reference to the transient heap is found, the Java VM is dirty, corresponding to error <highlight><bold>1099</bold></highlight>. (Note that unlike for the primordial statics (step <highlight><bold>1025</bold></highlight>) there is no need to iteratively follow references from the middleware statics, since any indirect references will already have been picked up by the preceding analysis). If no transient heap references are found, the processing continues to step <highlight><bold>1080</bold></highlight> in which objects on the transient heap are reviewed to see if any have finalizer methods, and any that are found are now run (step <highlight><bold>1082</bold></highlight>). One important aspect of the preferred embodiment is that these finalizer methods are run on the main thread, rather than being passed to the system finalizer thread. An implication of this is that the finalizer methods will be run in the known and controllable context of the main thread. In addition, it is ensured that the finalizer methods complete before progressing to the next stage of the Java VM reset. Unfortunately, finalizer methods can create fresh objects, which may newly reference the transient heap. Therefore, after the finalizer methods have completed, processing must return to step <highlight><bold>1025</bold></highlight> to repeat much of the checking, to ensure that the system is still in a position for Java VM reset. In theory, if the finalizer methods have created new objects on the transient heap which themselves have finalizer methods, then this loop may have to be followed more than once. </paragraph>
<paragraph id="P-0145" lvl="0"><number>&lsqb;0145&rsqb;</number> Note that strictly speaking there is no formal requirement to run the finalizers at this stage, since this is the point at which the Java VM would normally terminate at the conclusion of an application, rather than having a garbage collection performed. Nevertheless, the policy in the preferred embodiment is that object finalizers will be run before deletion at JVM reset, although other implementations may have different policies. </paragraph>
<paragraph id="P-0146" lvl="0"><number>&lsqb;0146&rsqb;</number> It is assumed that eventually all finalizers will be run, resulting in a negative outcome to the test of step <highlight><bold>1080</bold></highlight>. In these circumstances, the method proceeds to step <highlight><bold>1085</bold></highlight>, which represents reset of the Java VM by deleting the transient heap. In practice, this involves several operations. Firstly, if the mark phase of the garbage collection was run (step <highlight><bold>1055</bold></highlight>) then the sweep phase, which is relatively quick, is now run on the middleware heap. Next, various operations are performed to formally reset the transient heap, including: the removal of all transient heap monitors and the freeing of storage for transient heap class blocks (i.e. releasing the storage utilised by the class block, which is not on the heap). The transient heap pointers can now be reset so that the heap is effectively emptied, and restored to its initial size (by setting boundary 522 appropriately). </paragraph>
<paragraph id="P-0147" lvl="0"><number>&lsqb;0147&rsqb;</number> Once the transient heap has been recreated (although it could be done before), in the preferred embodiment a garbage collection is performed on the middleware heap if either of the following two cases is true: firstly, if the number of slices left in the unallocated portion of the heap, between the middleware heap and the transient heap, is less than two, or secondly if the amount of free space in the middleware heap plus half the unassigned portion <highlight><bold>515</bold></highlight> of the heap (see <cross-reference target="DRAWINGS">FIG. 5</cross-reference>) is less than the amount of storage used by the previous transaction times three. Both of these can be regarded as a preemptive garbage collection, performing this operation now if the next transaction would otherwise probably be constrained for space, in the hope that this will avoid a garbage collection during the transaction itself. Note that in the current implementation this preemptive garbage collection would be performed irrespective of whether a garbage collection mark phase was performed in step <highlight><bold>1055</bold></highlight>. Finally, all the threads can be restarted and the garbage collection locks released, whereupon the reset is completed, and the Java VM is available to support the next application. </paragraph>
<paragraph id="P-0148" lvl="0"><number>&lsqb;0148&rsqb;</number> One aspect that has not been discussed yet is reset of the card table. For the first column of the card table, this is relatively straightfoward; the first column can be reinitialised (i.e. everything set as clean) as part of the heap reset (step <highlight><bold>1085</bold></highlight>). The situation with regard to the second column of the card table however is slightly more complicated. Since middleware objects persist across the reset, the &ldquo;live&rdquo; markings from one middleware object to another must also persist across reset. The natural consequence of this, if no further action is taken, would be that more and more cards have their second column marked as live, and so the benefit from the test of step <highlight><bold>1048</bold></highlight> would reduce&mdash;i.e. it would rarely test negative. </paragraph>
<paragraph id="P-0149" lvl="0"><number>&lsqb;0149&rsqb;</number> However, it is possible to reset the second column of the card table whenever a garbage collection is performed. More particularly, after a garbage collection, the middleware heap will only contain live objects. Thus any card which is marked as live, but which no longer contains any objects (these having been deleted in the garbage collection), can now be reset back to not live. An alternative (equivalent) approach is to reset the entire second column of the card table to zero (unmarked) at the start of garbage collection, and then specifically mark those cards still containing objects at the end of garbage collection. It will be appreciated that such a reset of the second column of the card table at a garbage collection works even if a compaction is performed, since the reset of the second column of the card table can be delayed until after the compaction is complete, and the values of the cards then simply adjusted to indicate the (new) locations of the live objects. </paragraph>
<paragraph id="P-0150" lvl="0"><number>&lsqb;0150&rsqb;</number> The reset of the second column of the card table is actually-self-correcting to some extent, in that it can also be performed after the GC mark phase of step <highlight><bold>1055</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 9A</cross-reference>. Thus if the card table contains too many cards marked (potentially spuriously) as live, then this increases the likelihood of a positive outcome from step <highlight><bold>1048</bold></highlight>, which in turn will lead to the GC mark phase of step <highlight><bold>1055</bold></highlight> (assuming a positive outcome from step <highlight><bold>1050</bold></highlight>). This in turn can reset the second column of the card table, making it more effective for the next transaction. </paragraph>
<paragraph id="P-0151" lvl="0"><number>&lsqb;0151&rsqb;</number> Note that in practice it has been found that although the initial transaction on a Java VM may utilise objects from many cards, for subsequent transactions the number of cards used may be very small (typically only a handful). This means that the technique disclosed herein will tend to perform particularly well after a first garbage collection resets of the second column of the card table. </paragraph>
<paragraph id="P-0152" lvl="0"><number>&lsqb;0152&rsqb;</number> Although one preferred embodiment of the invention has been described in detail above, the skilled person will be aware of many possible variations this embodiment. For example, it will be appreciated that the purpose of the second column in the card table is to allow a rapid determination of whether a dirty card is dead, thereby permitting any crossheap pointers that it contains to be discounted. However, this is at the expense of a moderately complicated write barrier, as discussed in relation to <cross-reference target="DRAWINGS">FIG. 11</cross-reference>. Thus the benefit to be obtained by this approach will depend on whether the increase reset speed (by hopefully avoiding a garbage collection mark phase) will compensate for the reduced execution speed during the body of the application. </paragraph>
<paragraph id="P-0153" lvl="0"><number>&lsqb;0153&rsqb;</number> Since this trade-off is likely to be application dependent, in the preferred embodiment, the Java VM has a setting which allows the write barrier of <cross-reference target="DRAWINGS">FIG. 11</cross-reference> to be modified for applications in which execution speed during the transaction is especially critical (or where reset speed is not a problem). In this setting, only the first column of the card table is utilised (<highlight><bold>1301</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 12</cross-reference>), and the write barrier of <cross-reference target="DRAWINGS">FIG. 11</cross-reference> simply reduces to steps <highlight><bold>1210</bold></highlight> and <highlight><bold>1240</bold></highlight> (which do not involve any testing as regards heap location). In addition, the test of step <highlight><bold>1048</bold></highlight> in <cross-reference target="DRAWINGS">FIG. 9A</cross-reference> is removed, with a positive outcome to step <highlight><bold>1045</bold></highlight> leading directly to step <highlight><bold>1050</bold></highlight>, and then on into the garbage collection mark phase if any crossheap pointers are found. </paragraph>
<paragraph id="P-0154" lvl="0"><number>&lsqb;0154&rsqb;</number> It will be appreciated that many of the other details of the systems and processes discussed above are exemplary only, and can be varied according to particular circumstances. Thus further modifications to the embodiments described herein will be apparent to the skilled person yet remain within the scope of the invention as set out in the attached claims. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A computer system for running one or more programs and including a memory in which objects are stored, said system further including: 
<claim-text>a card table containing multiple cards, each card corresponding to a portion of said memory; and </claim-text>
<claim-text>a write barrier for detecting that a first object has been updated by a program to include a reference to a second object, and for marking the card that corresponds to the memory location of said second object. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The computer system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein said memory is divided into at least first and second heaps. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The computer system of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, wherein the card is only marked if the first object is located in the first heap. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The computer system of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, wherein each card comprises first and second components, the first component being marked if an object in a corresponding memory location is updated to include a reference to another object, and the second component being marked if an object in a corresponding memory location is referenced from another object. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The computer system of <dependent-claim-reference depends_on="CLM-00004">claim 4</dependent-claim-reference>, wherein the first component is only marked if the object being updated is in the first heap, and the object being referenced is in the second heap. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The computer system of <dependent-claim-reference depends_on="CLM-00004">claim 4</dependent-claim-reference>, wherein the second component is only marked if the object being updated is in the first heap, and the object being referenced is also in the first heap. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The computer system of <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference>, wherein the second component is not marked if the object being updated and the object being referenced are in memory locations corresponding to a single card. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The computer system of <dependent-claim-reference depends_on="CLM-00004">claim 4</dependent-claim-reference>, wherein if an object is moved from the second heap to the first heap, then any object references within the moved object are regarded as having been updated and the card table is marked accordingly. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The computer system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the card table is reset if a garbage collection is performed on the system. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The computer system of <dependent-claim-reference depends_on="CLM-00004">claim 4</dependent-claim-reference>, wherein a reset can be performed on the system, involving the deletion of all objects in the second heap, and the first component of each card is restored to an unmarked value as part of such reset. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The computer system of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein the second component of each card is maintained through said reset, and only restored to an unmarked value if a garbage collection is performed on the system. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The computer system of <dependent-claim-reference depends_on="CLM-00004">claim 4</dependent-claim-reference>, wherein the system further includes means for performing a reset including: 
<claim-text>means for marking the second component of each card corresponding to a memory location referenced by the system stack or registers; </claim-text>
<claim-text>means for detecting if the first component of any card corresponding to objects in the first heap is marked; </claim-text>
<claim-text>means responsive to so detecting, for determining if the second component of any such card is marked; and </claim-text>
<claim-text>means responsive to determining that no cards have both the first and second components marked for proceeding with the reset. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. A method of running one or more programs on a computer system including a memory in which objects are stored, said method comprising the steps of: 
<claim-text>providing a card table containing multiple cards, each card corresponding to a portion of said memory; and </claim-text>
<claim-text>detecting with a write barrier that a first object has been updated by a program to include a reference to a second object, and marking the card that corresponds to the memory location of said second object. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference>, wherein said memory is divided into at least first and second heaps. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference>, wherein the card is only marked if the first object is located in the first heap. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference>, wherein each card comprises first and second components, the first component being marked if an object in a corresponding memory location is updated to include a reference to another object, and the second component being marked if an object in a corresponding memory location is referenced from another object. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, wherein the first component is only marked if the object being updated is in the first heap, and the object being referenced is in the second heap. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, wherein the second component is only marked if the object being updated is in the first heap, and the object being referenced is also in the first heap. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 18</dependent-claim-reference>, wherein the second component is not marked if the object being updated and the object being referenced are in memory locations corresponding to a single card. </claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, wherein if an object is moved from the second heap to the first heap, then any object references within the moved object are regarded as having been updated and the card table is marked accordingly. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference>, wherein the card table is reset if a garbage collection is performed on the system. </claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, wherein a reset can be performed on the system, involving the deletion of all objects in the second heap, and the first component of each card is restored to an unmarked value as part of such reset. </claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 22</dependent-claim-reference>, wherein the second component of each card is maintained through said reset, and only restored to an unmarked value if a garbage collection is performed on the system. </claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference>, wherein the method further includes performing a reset by the following steps: 
<claim-text>marking the second component of each card corresponding to a memory location referenced by the system stack or registers; </claim-text>
<claim-text>detecting if the first component of any card corresponding to objects in the first heap is marked; </claim-text>
<claim-text>responsive to so detecting, determining if the second component of any such card is marked; and </claim-text>
<claim-text>responsive to determining that no cards have both the first and second components marked, proceeding with the reset. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. A computer computer program product comprising instructions on a medium in machine readable form which when loaded into a computer system for running one or more programs and including a memory in which objects are stored, will cause said system to perform the steps of: 
<claim-text>providing a card table containing multiple cards, each card corresponding to a portion of said memory; and </claim-text>
<claim-text>detecting with a write barrier that a first object has been updated by a program to include a reference to a second object, and marking the card that corresponds to the memory location of said second object. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. The computer program product of <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>, wherein said memory is divided into at least first and second heaps. </claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. The computer program product of <dependent-claim-reference depends_on="CLM-00022">claim 26</dependent-claim-reference>, wherein the card is only marked if the first object is located in the first heap. </claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. The computer program product of <dependent-claim-reference depends_on="CLM-00022">claim 26</dependent-claim-reference>, wherein each card comprises first and second components, the first component being marked if an object in a corresponding memory location is updated to include a reference to another object, and the second component being marked if an object in a corresponding memory location is referenced from another object. </claim-text>
</claim>
<claim id="CLM-00029">
<claim-text><highlight><bold>29</bold></highlight>. The computer program product of <dependent-claim-reference depends_on="CLM-00022">claim 28</dependent-claim-reference>, wherein the first component is only marked if the object being updated is in the first heap, and the object being referenced is in the second heap. </claim-text>
</claim>
<claim id="CLM-00030">
<claim-text><highlight><bold>30</bold></highlight>. The computer program product of <dependent-claim-reference depends_on="CLM-00022">claim 28</dependent-claim-reference>, wherein the second component is only marked if the object being updated is in the first heap, and the object being referenced is also in the first heap. </claim-text>
</claim>
<claim id="CLM-00031">
<claim-text><highlight><bold>31</bold></highlight>. The computer program product of <dependent-claim-reference depends_on="CLM-00033">claim 30</dependent-claim-reference>, wherein the second component is not marked if the object being updated and the object being referenced are in memory locations corresponding to a single card. </claim-text>
</claim>
<claim id="CLM-00032">
<claim-text><highlight><bold>32</bold></highlight>. The computer program product of <dependent-claim-reference depends_on="CLM-00022">claim 28</dependent-claim-reference>, wherein if an object is moved from the second heap to the first heap, then any object references within the moved object are regarded as having been updated and the card table is marked accordingly. </claim-text>
</claim>
<claim id="CLM-00033">
<claim-text><highlight><bold>33</bold></highlight>. The computer program product of <dependent-claim-reference depends_on="CLM-00022">claim 25</dependent-claim-reference>, wherein the card table is reset if a garbage collection is performed on the system. </claim-text>
</claim>
<claim id="CLM-00034">
<claim-text><highlight><bold>34</bold></highlight>. The computer program product of <dependent-claim-reference depends_on="CLM-00022">claim 28</dependent-claim-reference>, wherein a reset can be performed on the system, involving the deletion of all objects in the second heap, and the first component of each card is restored to an unmarked value as part of such reset. </claim-text>
</claim>
<claim id="CLM-00035">
<claim-text><highlight><bold>35</bold></highlight>. The computer program product of <dependent-claim-reference depends_on="CLM-00033">claim 34</dependent-claim-reference>, wherein the second component of each card is maintained through said reset, and only restored to an unmarked value if a garbage collection is performed on the system. </claim-text>
</claim>
<claim id="CLM-00036">
<claim-text><highlight><bold>36</bold></highlight>. The computer program product of <dependent-claim-reference depends_on="CLM-00033">claim 35</dependent-claim-reference>, wherein the instructions further cause the system to perform a reset by the steps of: 
<claim-text>marking the second component of each card corresponding to a memory location referenced by the system stack or registers; </claim-text>
<claim-text>detecting if the first component of any card corresponding to objects in the first heap is marked; </claim-text>
<claim-text>responsive to so detecting, determining if the second component of any such card is marked; and </claim-text>
<claim-text>responsive to determining that no cards have both the first and second components marked, proceeding with the reset.</claim-text>
</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>6A</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005027A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005027A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005027A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005027A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005027A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005027A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030005027A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030005027A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030005027A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00009">
<image id="EMI-D00009" file="US20030005027A1-20030102-D00009.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00010">
<image id="EMI-D00010" file="US20030005027A1-20030102-D00010.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00011">
<image id="EMI-D00011" file="US20030005027A1-20030102-D00011.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00012">
<image id="EMI-D00012" file="US20030005027A1-20030102-D00012.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00013">
<image id="EMI-D00013" file="US20030005027A1-20030102-D00013.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00014">
<image id="EMI-D00014" file="US20030005027A1-20030102-D00014.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
