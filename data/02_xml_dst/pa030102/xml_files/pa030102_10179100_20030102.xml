<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030002440A1-20030102-D00000.TIF SYSTEM "US20030002440A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030002440A1-20030102-D00001.TIF SYSTEM "US20030002440A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030002440A1-20030102-D00002.TIF SYSTEM "US20030002440A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030002440A1-20030102-D00003.TIF SYSTEM "US20030002440A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030002440A1-20030102-D00004.TIF SYSTEM "US20030002440A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030002440A1-20030102-D00005.TIF SYSTEM "US20030002440A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030002440A1-20030102-D00006.TIF SYSTEM "US20030002440A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030002440A1-20030102-D00007.TIF SYSTEM "US20030002440A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030002440A1-20030102-D00008.TIF SYSTEM "US20030002440A1-20030102-D00008.TIF" NDATA TIF>
<!ENTITY US20030002440A1-20030102-D00009.TIF SYSTEM "US20030002440A1-20030102-D00009.TIF" NDATA TIF>
<!ENTITY US20030002440A1-20030102-D00010.TIF SYSTEM "US20030002440A1-20030102-D00010.TIF" NDATA TIF>
<!ENTITY US20030002440A1-20030102-D00011.TIF SYSTEM "US20030002440A1-20030102-D00011.TIF" NDATA TIF>
<!ENTITY US20030002440A1-20030102-D00012.TIF SYSTEM "US20030002440A1-20030102-D00012.TIF" NDATA TIF>
<!ENTITY US20030002440A1-20030102-D00013.TIF SYSTEM "US20030002440A1-20030102-D00013.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030002440</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10179100</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20020625</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>H04J001/16</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>370</class>
<subclass>229000</subclass>
</uspc>
</classification-us-primary>
<classification-us-secondary>
<uspc>
<class>370</class>
<subclass>230000</subclass>
</uspc>
</classification-us-secondary>
</classification-us>
<title-of-invention>Ordered semaphore management subsystem</title-of-invention>
</technical-information>
<continuity-data>
<non-provisional-of-provisional>
<document-id>
<doc-number>60301598</doc-number>
<document-date>20010627</document-date>
<country-code>US</country-code>
</document-id>
</non-provisional-of-provisional>
</continuity-data>
<inventors>
<first-named-inventor>
<name>
<given-name>Jean</given-name>
<middle-name>Louis</middle-name>
<family-name>Calvignac</family-name>
</name>
<residence>
<residence-us>
<city>Cary</city>
<state>NC</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Gordon</given-name>
<middle-name>Taylor</middle-name>
<family-name>Davis</family-name>
</name>
<residence>
<residence-us>
<city>Chapel Hill</city>
<state>NC</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Marco</given-name>
<family-name>Heddes</family-name>
</name>
<residence>
<residence-us>
<city>Lawrence</city>
<state>MA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Steven</given-name>
<middle-name>Kenneth</middle-name>
<family-name>Jenkins</family-name>
</name>
<residence>
<residence-us>
<city>Raleigh</city>
<state>NC</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Ross</given-name>
<middle-name>Boyd</middle-name>
<family-name>Leavens</family-name>
</name>
<residence>
<residence-us>
<city>Cary</city>
<state>NC</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Robert</given-name>
<middle-name>Brian</middle-name>
<family-name>Likovich</family-name>
<name-suffix>JR.</name-suffix>
</name>
<residence>
<residence-us>
<city>Raleigh</city>
<state>NC</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<assignee>
<organization-name>International Business Machines Corporation</organization-name>
<address>
<city>Armonk</city>
<state>NY</state>
</address>
<assignee-type>02</assignee-type>
</assignee>
<correspondence-address>
<name-1>IBM Corporation</name-1>
<name-2>Intellectual Property Law Dept. 9CCA/B002</name-2>
<address>
<address-1>P.O. Box 12195</address-1>
<city>Res. Tri. Park</city>
<state>NC</state>
<postalcode>27709</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">An ordered semaphore management subsystem and method for use in an application system which includes a plurality of processors competing for shared resources each of which is controlled by a unique semaphore. The subsystem generates an ordered semaphore field (OSF) corresponding to each processor in a linked list of processors and assigns one of four statuses to the OSF depending on the position the processor occupies in the linked list of processors competing for the shared resources. The four states are (1) semaphore head (SH); (2) behind semaphore head (BSH); (3) semaphore head behind (SHB); and (4) skip (Skip). Only the SH processor is allocated the semaphore when requested. A processor not in the SH state will be denied the semaphore even if is available to assure sequential access. </paragraph>
</subdoc-abstract>
<subdoc-description>
<cross-reference-to-related-applications>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> This application claims the benefit of the filing date of provisional application Serial No. 60/301,598, filed Jun. 27, 2001.</paragraph>
</cross-reference-to-related-applications>
<summary-of-invention>
<section>
<heading lvl="1">FIELD OF THE INVENTION </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> The invention relates to semaphore management subsystems and more particularly to generic ordered semaphore management subsystems and a method for managing ordered semaphores suitable for use with any multi-threaded (multiprocessor) system requiring in part or in hole in line or sequential processing of a task divided and distributed among a plurality of threads or processors for later recombination. </paragraph>
</section>
<section>
<heading lvl="1">BACKGROUND </heading>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> While the invention is generic in nature and capable of use with a large variety of multi-threaded processor systems, it will be described in conjunction with a multi-threaded processor system such as the IBM Part No. IBM32NPR161EPXCAE133 Network Processor which employs a plurality of processors or threads each of which concurrently process data frames which may be from the same or different data flows. The individual threads/processors share common resources in the network processor. Semaphores defined to be associated with specific resources are used to allocate the specific resources to the individual threads as requested. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> Within such a network processor several data frames are processed at the same time. Each data frame is processed by one processor/thread. Each processor/thread operates independently from all the other processors/threads. Thus, as the software (picocode) processes a data frame, the software has no knowledge of other frames which have been, are being, or will be processed. As data frames are processed, a thread may need access to a shared resource. This shared resource is shared among all threads. To allow a thread access to the resource without interference from other threads, semaphores are used. A semaphore is a mechanism which allows a processor/thread to use a resource without interference from another processor/thread. Semaphores exist in almost every multi-processor environment where multiple processors can access common resources. A semaphore is used to ensure that one and only one processor/thread has &ldquo;ownership&rdquo; or use of a given resource at any given time. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> A network processor is a multi-processor environment with resources which can be accessed by all processors/threads. Thus, semaphores are an intricate part of network processors. A discussed above, network processors process data frames which belong to one or more data flows. Traditionally, semaphores are implemented in software using &ldquo;read modify write&rdquo; or &ldquo;test and set&rdquo; instructions. When these instructions are used as a basis to create and allocate semaphores, valuable system resources must be used. To implement a semaphore, system memory must be used. To access a semaphore, several lines of code must be executed. If these system resources were not used for semaphore implementation, they could be used for other functions or provide a performance increase by not executing extra line(s) of code. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> When semaphores are implemented in software, several lines of code must be executed to access and lock the semaphore, impacting performance. If the semaphore is unavailable (locked by another thread/processor), the software would need to poll on the semaphore. This would waste valuable bandwidth on the arbitrated memory holding semaphore locks to be accessed by all threads/processors. To implement a fair semaphore access in software requires more system memory and lines of code. For example, if a semaphore is locked, the thread/processor would need to put itself in a queue waiting for access. This queue would be implemented in system memory and require software management impacting performance. This allows threads/processors to have fair access to resources. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> In a software semaphore environment, multiple threads/processors cannot unlock their respective semaphores at the same time. Typically, all the semaphores are in the same system memory. Each thread/processor must arbitrate to access the memory to unlock their semaphore. This may add to the processing time of other threads/processors waiting to access the same memory to access the semaphore locks. The same is true for locking semaphores. When semaphores are implemented in software, only one semaphore can be unlocked/locked at a time since all the semaphores reside in a common area of system memory. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> In the IBM Network Processor System identified above a device termed Completion Unit monitors the order in which frames or packets in a flow are processed by the threads or Dyadic Protocol Processor Units (DPPUs) and generates information used by a semaphore sub-system to control the order in which semaphores are assigned. Such systems require ordered semaphores which must perform two functions. First, the well known semaphore function, ensure that one and only one processor/thread has access to a single resource at any time. And second, ordered semaphores must ensure that the processors/threads which are processing data frames of the same data flow access the common resource in frame order, for example, an e-mail message which must be encrypted using an encryption co-processor shared among all of the processors/threads. The encryption of the data frames must occur in order to properly encrypt the message. The software would use an ordered semaphore mechanism to access the encryption co-processor. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> This would ensure two things. First, only one processor/thread accesses the co-processor at a time. And second, the encryption of the data frames of the data flow (e-mail message) occurs in order. Ordered Semaphores are needed since processing time for each data frame can be different. Data frames from the same data flow will take different amounts of time to process. For example, tree searches for each data frame can take different amounts of time. Threads which share a common ALU will stall occasionally to allow the other thread to process data. Thus, frames in the same data flow being processed by different threads will attempt to access a shared resource at different times and not in data flow order. Because of this, ordered semaphores are required to ensure the shared resource is accessed in data flow order. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> The Completion Unit logic block contains all the information required to put processed data frames (received from processors/threads) back in the correct order for each data flow. U.S. applications Ser. No. 09/479,028 filed Jan. 7, 2000 and Ser. No. 09/548,906 filed Apr. 13, 2000 incorporated herein by reference describe how the Completion Unit performs this function. Within the completion unit, linked lists of the data frames assigned to processors/threads represent the data frame order of the data flows. One linked list exists for each data flow which currently has a data frame being processed by a processor/thread. The head of the linked list is associated with a processor/thread. It is from this processor/thread that the next processed data frame is to be taken from and sent out onto the network. When the processed data frame is sent, the head of the linked list is removed and the next element of the linked list is examined; see the referenced applications for details. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> The invention contemplates an ordered semaphore management subsystem and method for use in an application system which includes a plurality of shared resources each of which is controlled by a unique semaphore; a plurality of processors adapted to perform similar tasks using one or more shared resources controlled in a sequential manner by the semaphores on assigned segments of a continuous data stream; a linked list of processor labels each identifying a processor and defining the order in which the processed data is to be assembled. Each label includes, a data flow ID, a data flow head field, a data flow tail field, and a pointer field pointing to the next label in the linked list. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> The subsystem includes a logic circuit responsive to the creation of a label included in the linked list for generating and encoding a predetermined state in an ordered semaphore field (OSF) corresponding to the created label. The states include: </paragraph>
<paragraph id="P-0013" lvl="2"><number>&lsqb;0013&rsqb;</number> a semaphore head (SH) state, </paragraph>
<paragraph id="P-0014" lvl="2"><number>&lsqb;0014&rsqb;</number> a behind semaphore head (BSH) state, </paragraph>
<paragraph id="P-0015" lvl="2"><number>&lsqb;0015&rsqb;</number> a semaphore head behind (SHB) state and, </paragraph>
<paragraph id="P-0016" lvl="2"><number>&lsqb;0016&rsqb;</number> a skip (Skip) state. </paragraph>
<paragraph id="P-0017" lvl="7"><number>&lsqb;0017&rsqb;</number> A second logic circuit responsive to a request for a semaphore from a processor examines the encoded ordered semaphore field corresponding to the processor&apos;s label and grants the semaphore request when the field is in the SH state. A third logic circuit responsive to a change in the status of a processor updates the ordered semaphore field corresponding to the label associated with the processor. It updates the OSF corresponding to the label identified by the pointer in the label of the processor whose status changed.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a block diagram of an application system which incorporates a semaphore manager subsystem according to the invention; </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a block diagram of a semaphore manager subsystem according to the invention; </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a diagram of the semaphore value storage <highlight><bold>21</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 2</cross-reference>; </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 4A and 4B</cross-reference> are flow diagrams defining the lock command logic <highlight><bold>22</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 2</cross-reference>; </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a flow diagram defining the semaphore unlock command logic <highlight><bold>23</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 2</cross-reference>; </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is a flow diagram defining the error and exit logic <highlight><bold>24</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 2</cross-reference>; </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> is a flow diagram the reservation release command logic <highlight><bold>25</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 2</cross-reference>; </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> is a diagram of a linked list thread element including an ordered semaphore field OSF according to the invention; and, FIGS. <highlight><bold>9</bold></highlight>-<highlight><bold>12</bold></highlight> are flow diagrams of the completion unit interface logic.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF THE INVENTION </heading>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> As pointed out above the completion unit of the IBM network processor system contains all the information required to put processed data frames (received from processors/threads) back in the correct order for each data flow. By adding a two bit Ordered Semaphore Field (OSF) to each element in the linked lists of the completion unit, ordered semaphore management can be achieved. The OSF allows the Semaphore Manager/Co-processor logic block to walk the linked list(s) within the completion unit before the processed data frames are sent out onto the network. The lists can reside in the completion unit or alternatively updated copies of the lists can be provided by the completion unit to the semaphore manager subsystem. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> The OSF added to the linked list elements represent one of four states: (1) this element is currently the Semaphore Head (SH), (2) this element is currently behind the Semaphore Head (BSH), (3) the SH is currently behind this element (SHB), and (4) this element has been removed from the linked list (Skip), with respect only to ordered semaphores. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> When a new element (label/thread number) is loaded into the completion unit (due to a dispatch), the Ordered Semaphore Field (OSF) will be set to one of three states. The OSF can be set to indicate the element has been removed from the linked list (with respect to ordered semaphores). This is used in the case where ordered semaphores are disabled or it is known that the software will not use ordered semaphores to process the dispatched frame. If the label/thread being loaded into the completion unit is linked into an existing linked list behind an existing Semaphore Head (SH) field, the OSF is marked as BSH. If the label/thread being loaded into the completion unit is the start of a new linked list, or is being linked into an existing linked list which does not have a OSF &equals;SH, the OSF is marked SH. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> When an element is SH, this allows the Semaphore Manager/Co-processor to grant an ordered semaphore for the thread to access the protected resource. When an element is in the BSH state, the Semaphore Manager/Co-processor must wait to grant the thread access to the ordered semaphore protected resource even if the resource is available. At any time, a thread can indicate to the Semaphore Manager/Co-processor (using the reservation release command) that it no longer needs the ordered semaphore access. If this occurs when the thread is the SH, the two bit field is changed to indicate this element is currently SHB, and the next element which has not been removed from the linked list (with respect to ordered semaphores) is marked as the SH. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> If the Semaphore Manager/Co-processor, in response to the reservation release command, indicates that a particular thread no longer needs the ordered semaphore access and the thread is currently BSH, the element will be marked Skip and removed from the linked list with respect to ordered semaphores. When the semaphore head reaches this thread, the semaphore head will simply skip to the next element (thread) in the list. By adding additional Ordered Semaphore Fields, more than one ordered semaphore can be supported per data flow. For example, consider adding two Ordered Semaphore Fields to each element within the completion unit. The software can be designed to access two different resources, or the same resource twice, using Ordered Semaphores. Again, the additional logic to the completion unit interface logic block is minimal if the function is included in the completion unit logic block. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> The Semaphore ManageilCo-processor does not add or remove labels/thread numbers from the linked lists within the completion unit. The Semaphore Manager/Co-processor can mark labels/thread numbers as Skip. This allows the thread to continue processing without having to access the ordered semaphore. The &ldquo;Reservation Release&rdquo; command of the Semaphore Coprocessor/Manager can mark a label/thread as &ldquo;Skip&rdquo;. When the thread in front releases the ordered semaphore, the ordered semaphore head will pass to the thread behind the thread marked &ldquo;Skip&rdquo;. The Semaphore Manager/Co-processor is simply walking the pre-existing linked lists within the completion unit (if they are included in the completion unit logic block) to achieve ordered semaphore operation. The OSF can be used to mark the associated label/thread number as &ldquo;removed&rdquo; from the linked list with respect to ordered semaphores by setting the OSF to Skip. The label/thread numbers remain in linked lists to support the enqueue of processed data frames. The &ldquo;Reservation Release&rdquo; or &ldquo;skip&rdquo; marking is non-blocking on every thread. Thus, threads performing &ldquo;Reservation Release&rdquo; commands do not wait to become the head of the ordered semaphore queue before completing the instruction. This increases system performance by reducing processing time. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 1</cross-reference><highlight><italic>a </italic></highlight>network processor such as the IBM processor identified above includes an input/output data storage unit <highlight><bold>11</bold></highlight> which stores a plurality or stream of data frames which require processing. A dispatching unit <highlight><bold>12</bold></highlight> transfers individual data frames to a plurality of processors <highlight><bold>13</bold></highlight>-<highlight><bold>1</bold></highlight>-<highlight><bold>13</bold></highlight>-<highlight><italic>n </italic></highlight>which process the individual frames received from the dispatching unit <highlight><bold>12</bold></highlight>. The processors <highlight><bold>13</bold></highlight>-<highlight><bold>1</bold></highlight>-<highlight><bold>13</bold></highlight>-<highlight><italic>n </italic></highlight>pass the processed data frames on to a completion unit <highlight><bold>14</bold></highlight> which reassembles the data frames before passing the reassembled stream of data frames on to a second input/output unit <highlight><bold>15</bold></highlight>. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> Each of the processors <highlight><bold>13</bold></highlight>-<highlight><bold>1</bold></highlight>-<highlight><bold>13</bold></highlight>-<highlight><italic>n </italic></highlight>includes a semaphore coprocessor <highlight><bold>13</bold></highlight><highlight><italic>p </italic></highlight>which interfaces a hardware semaphore manager subsystem <highlight><bold>16</bold></highlight> constructed according to the invention. The semaphore subsystem <highlight><bold>16</bold></highlight> is implemented in hardware and interfaces with, for example, the Dyatic Protocol Processor Unit (DPPU) of the using processing system. Each DPPU contains four threads which can each process one data frame. Each DPPU has one Semaphore Co-Processor associated with it. The threads in a given DPPU interface to the one Semaphore Co-Processor within the DPPU. The multiple Semaphore Co-Processors all communicate with the central Semaphore Manager subsystem. The Semaphore Manager subsystem <highlight><bold>16</bold></highlight> contains all of the tables and control logic to lock, unlock, and arbitrate for semaphores. The semaphore manager <highlight><bold>16</bold></highlight> communicates with the completion unit <highlight><bold>14</bold></highlight> over a bus <highlight><bold>17</bold></highlight>. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> Only one processor instruction is executed to lock a semaphore, and only one processor instruction is executed to unlock a semaphore. This saves instruction memory and processing time when compared to software implementations of semaphores. An unlock instruction from a thread executes immediately. Nothing can block unlock instructions within the Semaphore Manager subsystem, including other unlock instructions from other threads. When semaphores are implemented in software, only one semaphore can be unlocked at a time since all the semaphores reside in a common area of system memory. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> Fairness algorithms can be implemented in the Hardware Semaphore Manager subsystem. This provides fairness of access to a semaphore when multiple threads/processors request access to the same semaphore. This eliminates the need for software and system memory to be utilized to implement fairness algorithms. This increases performance by reducing frame processing time and instruction memory utilization, and does not use any system memory. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> The Hardware Semaphore Manager subsystem contains the semaphores. Each semaphore is an N bit value. For example, each semaphore could be 32 bits. This allow 2&circ; 32 resources to be managed by the Semaphore Manager. Since the Semaphore Manager subsystem is generic and designed to be used by a wide variety of systems, it is the responsibility of the using system programmer to attach a meaning to a semaphore. That is, the Semaphore Manager does not know what a Semaphore represents. It is just a string of 32 bits. Semaphores can be seen as having 32-bit address space and the programmer can map this to anything, like the Tree Search Memory, the Data Store, the Embedded PowerPC, etc. There are two advantages here. First, no system memory is used for semaphore management. Second, the Hardware Semaphore Manager implementation is generic with respect to the number of and types of system resources which must be managed by semaphores. As the Network Processor evolves and shared resources are added or removed, the Semaphore Manager does not need to change. The Hardware Semaphore Co-processor and Manager does not use any system memory. This eliminates the need for memory accesses, and allows the memory bandwidth to be used for other functions. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 2</cross-reference> the semaphore coprocessors <highlight><bold>13</bold></highlight><highlight><italic>p</italic></highlight>-<highlight><bold>1</bold></highlight>-<highlight><bold>13</bold></highlight><highlight><italic>p</italic></highlight>-<highlight><italic>n </italic></highlight>communicate with the Semaphore Manager subsystem <highlight><bold>16</bold></highlight> via a bus <highlight><bold>20</bold></highlight>. The subsystem <highlight><bold>16</bold></highlight> includes a semaphore value storage <highlight><bold>21</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 3</cross-reference>), semaphore lock command logic <highlight><bold>22</bold></highlight> (<cross-reference target="DRAWINGS">FIGS. 4A and 4B</cross-reference>), semaphore unlock command logic <highlight><bold>23</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 5</cross-reference>) and semaphore exit and error detection logic <highlight><bold>24</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 6</cross-reference>). It also includes reservation release command logic <highlight><bold>25</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 7</cross-reference>) and completion unit interface logic <highlight><bold>26</bold></highlight> (FIGS. <highlight><bold>9</bold></highlight>-<highlight><bold>12</bold></highlight>). </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a block diagram of the semaphore value storage. The storage can be based upon a RAM, CAM, or discrete latches. For each thread there exists exactly two registers. The first register (Semaphore_Value) is for example a 32 bit register which holds the 32 bit Semaphore Value (Sem_Val) that can be locked by the associated thread. The second register (Semaphore_Lock) is a 1 bit register which indicates if the Sem_Val stored in the associated Semaphore_Value register is locked or unlocked. When the Semaphore_Lock register is set to 1&rsquo;b, the Sem_Val in the Semaphore_Value register is locked. When the Semaphore_Lock register is reset to &lsquo;0&rsquo;b, no Sem_Val is locked by the associated software thread. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> A semaphore can be locked when a software thread issues a single command &ldquo;Semaphore Lock&rdquo; (Sem_Lock) with two parameters. The first parameter is the &ldquo;Semaphore Value&rdquo; (Sem_Val). This is, for example, a 32 bit value which the thread wishes to lock. The second parameter is the &ldquo;Timeout Enable&rdquo; (Timeout_Enable) bit. When the Timeout Enable bit is set and the requested semaphore is already locked by a different thread, the Semaphore Lock command will terminate without locking the semaphore. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> In the preferred embodiment, each thread has an assigned register in the semaphore value storage and is thus identified as the source of the semaphore value requested. Alternatively, the requested semaphore value could be placed in any available register along with a thread or flow ID. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 4A and 4B</cross-reference> illustrate the function of the lock command logic. Directional blocks A, B, C and D indicate the connections between the two figures. The process starts when a thread N issues a semaphore lock command which includes a 32 bit semaphore value and a 1 bit time out enable value <highlight><bold>400</bold></highlight>. If the request is an ordered semaphore request and thread N is not enabled for ordered semaphores <highlight><bold>400</bold></highlight>-A, a queue not enabled error is generated <highlight><bold>401</bold></highlight> and the request is changed to an unordered request <highlight><bold>402</bold></highlight>. If it is not the former, it is examined to determine if it is an unordered request or an ordered request at the head of a queue <highlight><bold>403</bold></highlight>. If the request is either of the above it enters a round robin <highlight><bold>404</bold></highlight> for selection and exits <cross-reference target="DRAWINGS">FIG. 4A</cross-reference> at A. If the answer in block <highlight><bold>403</bold></highlight> is &ldquo;no&rdquo; (in which case it is an ordered request which is not the head of a queue) it is examined to determine if the timeout enable bit is set. If the timeout enable bit is not set <highlight><bold>405</bold></highlight> the request loops back to <highlight><bold>403</bold></highlight>. If the bit is set it exits <cross-reference target="DRAWINGS">FIG. 4A</cross-reference> at D. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> The non-winning threads at block <highlight><bold>406</bold></highlight> loop back to block <highlight><bold>404</bold></highlight> while the semaphore request from the winning thread is examined <highlight><bold>407</bold></highlight> in the semaphore value storage to determine if that semaphore value is currently locked. If the semaphore value is not locked it is examined in block <highlight><bold>408</bold></highlight> to determine if the request is ordered. If the request is ordered, the thread is removed from the ordered queue by sending a Pop signal <highlight><bold>409</bold></highlight> and the semaphore value requested is locked <highlight><bold>410</bold></highlight> for thread N. If the request was not ordered the requested semaphore value is locked for thread N <highlight><bold>410</bold></highlight> and in either case the operation for thread N is complete <highlight><bold>411</bold></highlight>. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> If the locked semaphore value requested by thread N is already locked by thread N <highlight><bold>412</bold></highlight>, a lock same semaphore value error for thread N is generated <highlight><bold>413</bold></highlight> and the operation completes at <highlight><bold>411</bold></highlight>. If the requested semaphore value <highlight><bold>412</bold></highlight> was not locked by thread N the timeout bit is examined <highlight><bold>414</bold></highlight> and if it is not set it loops back to <highlight><bold>404</bold></highlight> via C. If it is set a signal is generated for thread N indicating that the requested semaphore was not available <highlight><bold>415</bold></highlight> and the operation completes <highlight><bold>411</bold></highlight>. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> When a thread completes an operation with a resource controlled by a semaphore it sends a semaphore unlock command to the semaphore manager, <cross-reference target="DRAWINGS">FIG. 5</cross-reference> at <highlight><bold>501</bold></highlight>. The semaphore manager unlocks the semaphore by resetting the semaphore lock bit in the memory location associated with thread N in the semaphore memory <highlight><bold>21</bold></highlight>, <highlight><bold>502</bold></highlight> and completes the operation for thread N <highlight><bold>503</bold></highlight>. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> When thread N exits (processing is complete for the data frame) <highlight><bold>601</bold></highlight> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> the semaphore manager examines the address in memory <highlight><bold>21</bold></highlight> associated with thread N to determine if the thread has a locked semaphore. If a semaphore is locked <highlight><bold>602</bold></highlight> the semaphore manager unlocks the semaphore <highlight><bold>603</bold></highlight> and generates a semaphore locked at exit error for thread N <highlight><bold>604</bold></highlight>. If a semaphore is not locked by thread N the operation is complete. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> When the software on thread N issues a reservation release command <highlight><bold>701</bold></highlight> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> the semaphore manager determines if the thread is enabled for ordered semaphores <highlight><bold>702</bold></highlight>. If it is, the semaphore manager sends a Pop signal (this signal indicates an end of ordered semaphore operation for thread N) to the completion unit interface logic <highlight><bold>703</bold></highlight> and completes the current operation for thread N <highlight><bold>704</bold></highlight>. If thread N is not enabled for ordered semaphores <highlight><bold>702</bold></highlight> the semaphore manager completes the current operation for thread N <highlight><bold>704</bold></highlight>. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> The completion unit in the referenced IBM network processor employs a linked list(s) of labels for managing the reordering of data frames processed by the different threads. The label illustrated in <cross-reference target="DRAWINGS">FIG. 8</cross-reference> is similar (with one exception discussed below) to the label used in the IBM system. The label element <highlight><bold>800</bold></highlight> illustrated in <cross-reference target="DRAWINGS">FIG. 8</cross-reference> contains the label associated with the data flow being processed and a plurality of fields. A one bit field <highlight><bold>802</bold></highlight> when set indicates that the thread is the head of the enqueued data flow. A one bit field <highlight><bold>803</bold></highlight> when set indicates that the label is valid. A one bit field <highlight><bold>804</bold></highlight> when set indicates that the thread is the tail of the data flow and a multi-bit field <highlight><bold>805</bold></highlight> is a pointer to the next label in the linked list of labels. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> Applicants have modified the label of the referenced IBM network management system by adding a two bit ordered semaphore field (OSF) <highlight><bold>806</bold></highlight> to the label. This field defines one of four states (00, 01, 10 &amp; 11) that a thread enabled for ordered semaphores can assume. A first state SH (which can be occupied by only one thread in a linked list of <highlight><bold>800</bold></highlight>&apos;s), indicates that the thread is currently the semaphore head. A second state BSH indicates that the thread is currently behind the semaphore head. A third state, SHB indicates that the SH is currently behind the thread. And the fourth state Skip indicates that the thread has been removed (but only with respect to ordered semaphores) from the linked list. How these states are applied and managed will become apparent from the description of FIGS. <highlight><bold>9</bold></highlight>-<highlight><bold>12</bold></highlight> below. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> The semaphore manager needs access to the linked list(s) of labels. In those instances where the application system allows access, the logic necessary to manage the OSF (which is the case with the IBM network system) can be achieved through the completion unit interface logic <highlight><bold>26</bold></highlight>. If access is not available then the application system needs to make updated copies of the linked list(s) available to the interface logic <highlight><bold>26</bold></highlight>. The location of the linked list(s) is not critical to the invention and in the descriptions which follow it will be assumed that the application system allows the semaphore manager access to the linked list(s) via the interface <highlight><bold>26</bold></highlight>. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> The flow diagram of <cross-reference target="DRAWINGS">FIG. 9</cross-reference> defines the logic for initializing an ordered semaphore field OSF. When a label is written into the label field (<highlight><bold>801</bold></highlight>), update of the OSF starts (<highlight><bold>901</bold></highlight>). The logic determines if ordered semaphores are enabled for the frame associated with the label <highlight><bold>902</bold></highlight>. The label is checked <highlight><bold>903</bold></highlight> to determine if the enqueue data flow head was set to one when the label was written. If it was the associated OSF is set to the head state SH <highlight><bold>904</bold></highlight> and the operation is complete. If it was not set to one and the OSF of the old tail is SHB <highlight><bold>905</bold></highlight>, the OSF of the label is set to SH <highlight><bold>904</bold></highlight>. If <highlight><bold>905</bold></highlight> is negative, the OSF of the label is set to BSH <highlight><bold>906</bold></highlight>. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> If block <highlight><bold>902</bold></highlight> is negative, block <highlight><bold>907</bold></highlight> determines if the enqueue data flow head was set to one when the label was written. If it was, the OSF is set to SHB <highlight><bold>908</bold></highlight>. If block <highlight><bold>907</bold></highlight> is negative, block <highlight><bold>909</bold></highlight> determines if the OSF of the old tail was SHB and sets the OSF of the label to SHB <highlight><bold>908</bold></highlight>. If block <highlight><bold>909</bold></highlight> is negative the label OSF is set to Skip <highlight><bold>910</bold></highlight>. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> When a Pop command (<cross-reference target="DRAWINGS">FIG. 7, 703</cross-reference> or <cross-reference target="DRAWINGS">FIG. 4B, 409</cross-reference>) is received at the interface <highlight><bold>26</bold></highlight> <cross-reference target="DRAWINGS">FIG. 10</cross-reference> at block <highlight><bold>1001</bold></highlight>, the OSF for the thread is checked <highlight><bold>1002</bold></highlight> to determine if the OSF was set to SH. If it is set to SH, the field is changed to SHB state <highlight><bold>1003</bold></highlight>. The tail bit is checked <highlight><bold>1004</bold></highlight>. If the tail bit is one the process ends. If the tail bit is not one, an update semaphore head command is sent to the next element or thread in the linked list <highlight><bold>1005</bold></highlight> and the process ends. If block <highlight><bold>1002</bold></highlight> is negative, block <highlight><bold>1006</bold></highlight> checks the OSF to determine if it is set to the BSH. If it is, the OSF of the element or thread is set to the Skip state <highlight><bold>1007</bold></highlight> and the process ends. When block <highlight><bold>1006</bold></highlight> is negative the process ends and no change to the OSF is made. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 11</cross-reference>, in response to the receipt of an update semaphore head command (<cross-reference target="DRAWINGS">FIG. 10, 1005</cross-reference> or <cross-reference target="DRAWINGS">FIG. 11, 1106</cross-reference>) from a previous label or thread <highlight><bold>1101</bold></highlight>, the logic <highlight><bold>1102</bold></highlight> examines the OSF of the current label. If the field is BSH the field is changed to SH <highlight><bold>1103</bold></highlight>. If it is not BSH, it is set to SHB state <highlight><bold>1104</bold></highlight>. The tail bit is checked <highlight><bold>1105</bold></highlight>. If the tail bit is set the process ends. If the tail bit is not set an update semaphore head command is sent to the label or thread identified in the pointer <highlight><bold>1106</bold></highlight> and the process ends. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> When the completion unit receives a data flow enqueue command from a thread <cross-reference target="DRAWINGS">FIG. 12, 1201</cross-reference> the OSF is examined <highlight><bold>1202</bold></highlight>. If it is neither SH or BSH the process ends. If the field is SH or BSH, the semaphore manager generates an enqueue without Pop of ordered semaphore error message <highlight><bold>1203</bold></highlight>. This indicates to the software that a thread was enabled to use ordered semaphores but did not. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> The foregoing is illustrative of the present invention and is not to be construed as limiting the invention. While several embodiments of this invention have been described in detail, those skilled in this art will readily appreciate that many modifications are possible without materially departing from the novel teachings and advantages of this invention. Accordingly, all such modifications are intended to be included within the scope of this invention as defined by the claims. In the claims, means-plus-function clauses are intended to cover the structures described herein as performing the recited function and structural functional equivalents thereof. Therefore, it is to be understood that the foregoing is illustrative of the present invention and is not to be construed as limited to the specific embodiments disclosed, and that modifications to the disclosed embodiments, as well as other embodiments, are intended to be included within the scope of the claims appended hereto. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">We claim: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. In an application system including, one or more shared resources each controlled by a unique semaphore, a plurality of processors adapted to perform similar tasks on assigned segments of a continuous data flow in the data flow sequence, using one or more shared resources controlled by semaphores, a linked list of processor labels each identifying a processor and defining the order in which the processed data is to be assembled, each said label including, a data flow ID, a data flow head field, a data flow tail field and a pointer field pointing to the next label in the linked list, an ordered semaphore management subsystem comprising: 
<claim-text>first logic circuit responsive to the creation of a label included in the linked list for generating and encoding one of a plurality of predetermined states in an ordered semaphore field (OSF) corresponding to the created label; </claim-text>
<claim-text>second logic circuit responsive to an ordered semaphore request from a processor for examining the encoded OSF corresponding to the processor&apos;s label and granting the semaphore request when the field is in a first predetermined state; and, </claim-text>
<claim-text>third logic circuit responsive to a change in the status of a processor for updating the ordered semaphore field corresponding to the label associated with the processor and for updating the ordered semaphore field corresponding to the label identified by the pointer in the label of the processor whose status changed. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The ordered semaphore management subsystem set forth in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> in which the plurality of states in the OSF include; 
<claim-text>semaphore head (SH) state, </claim-text>
<claim-text>behind semaphore head (BSH) state, </claim-text>
<claim-text>semaphore head behind (SHB) state and, </claim-text>
<claim-text>skip (Skip) state. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The ordered semaphore management subsystem set forth in <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference> in which the first logic circuit encodes the head of ordered semaphores SH state when; 
<claim-text>ordered semaphores are enabled for this label and data flow, and the head field of the data flow of the label is set to head of data flow, or the OSF of the old tail field of the data flow is in the SHB state. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The ordered semaphore management subsystem set forth in <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference> in which the first logic circuit encodes the behind semaphore head (BSH) state when; 
<claim-text>ordered semaphores are enabled for this label and data flow, and the head field of the data flow of the label is not set to head of data flow, and when the ordered semaphore field of the old tail field of the data flow is not in the SHB state. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The ordered semaphore management subsystem set forth in <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference> in which the first logic circuit encodes semaphore head behind (SHB) state when; 
<claim-text>ordered semaphores are not enabled for this label and data flow, and the head field of the data flow of the label is set to head of data flow, or the OSF of the old tail field of the data flow is in the SHB state. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The ordered semaphore management subsystem set forth in <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference> in which the first logic circuit encodes the Skip state when; 
<claim-text>ordered semaphores are not enabled for this label and data flow, and the head field of the data flow of the label is not set to head of data flow, and the ordered semaphore field of the old tail field of the data flow is not in the SHB state. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The ordered semaphore management subsystem set forth in <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference> in which the second logic circuit grants the semaphore request when the OSF is SH. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The ordered semaphore management subsystem set forth in <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference> in which the third logic circuit in response to a change in status indicating that a processor no longer requires a semaphore: 
<claim-text>changes the status of the OSF associated with the processor to SHB and terminates the operation if the processor is identified as the tail in the associated link list; and, </claim-text>
<claim-text>if the processor is not identified as the tail in said linked list, the OSF associated with the processor identified by the pointer field is changed to SH if it is BSH and terminates the operation and if it is not BSH the above process is continued until the pointed to processor is identified as the tail of the linked list. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. In an application system including, one or more shared resources each controlled by a unique semaphore, a plurality of processors adapted to perform similar tasks on assigned segments of a continuous data flow in the data flow sequence, using one or more shared resources controlled by semaphores, a linked list of processor labels each identifying a processor and defining the order in which the processed data is to be assembled, each said label including, a data flow ID, a data flow head field, a data flow tail field and a pointer field pointing to the next label in the linked list, an ordered semaphore management subsystem comprising: 
<claim-text>first logic circuit responsive to the creation of a label included in the linked list for generating and encoding one of a plurality of predetermined states in an ordered semaphore field corresponding to the created label, said states including; 
<claim-text>a semaphore head (SH) state, </claim-text>
<claim-text>a behind semaphore head (BSH) state, </claim-text>
<claim-text>a semaphore head behind (SHB) state and, </claim-text>
<claim-text>a skip (Skip) state, </claim-text>
</claim-text>
<claim-text>second logic circuit responsive to a semaphore request from a processors for examining the encoded ordered semaphore field corresponding to the processor&apos;s label and granting the semaphore request when the field is in the SH state; and, </claim-text>
<claim-text>third logic circuit responsive to a change in the status of a processor for updating the ordered semaphore field corresponding to the label associated with the processor and updates the ordered semaphore field corresponding to the label identified by the pointer in the label of the processor whose status changed. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The ordered semaphore management subsystem set forth in <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference> in which: 
<claim-text>the first logic circuit selects the SH state when ordered semaphores are enabled for this label and data flow, and the head field of the data flow of the label is set to head of data flow, or the ordered semaphore field of the old tail field of the data flow is in the SHB state; </claim-text>
<claim-text>the (BSH) state is selected by the first logic circuit when ordered semaphores are enabled for this label and data flow, and the head field of the data flow of the label is not set to head of data flow, and when the ordered semaphore field of the old tail field of the data flow is not in the SHB state; </claim-text>
<claim-text>the semaphore head behind (SHB) field is selected by the first logic circuit when ordered semaphores are not enabled for this label and data flow and the head field of the data flow of the label is set to head of data flow, or the OSF of the old tail is SHB; and, </claim-text>
<claim-text>the Skip state is selected by the first logic circuit when ordered semaphores are not enabled for this label and data flow, and the head field of the data flow of the label is not set to head of data flow, and the ordered semaphore field of the old tail field of the data flow is not in the SHB state. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The ordered semaphore management subsystem set forth in <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference> in which the third logic circuit in response to a change in status indicating that a processor no longer requires a semaphore changes; 
<claim-text>the status of the OSF associated with the processor to SHB and terminates the operation if the processor is identified as the tail in the associated link list; and, </claim-text>
<claim-text>if the processor is not identified as the tail in said link list, the OSF associated with the processor identified by the pointer field is changed to SH if it is BSH and terminates the operation and if it is not BSH the above process is continued until the pointed to processor is identified as the tail of the link list. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. In an application system including, one or more shared resources each controlled by a unique semaphore, a plurality of processors adapted to perform similar tasks on assigned segments of a continuous data flow in the data flow sequence, using one or more shared resources controlled by semaphores, a linked list of processor labels each identifying a processor and defining the order in which the processed data is to be assembled, each said label including, a data flow ID, a data flow head field, a data flow tail field and a pointer field pointing to the next label in the linked list, a method for managing ordered semaphores comprising the steps: 
<claim-text>responsive to the creation of a label included in the linked list generating and encoding one of a plurality of predetermined states in an ordered semaphore field (OSF) corresponding to the created label; </claim-text>
<claim-text>responsive to a semaphore request from a processors examining the encoded OSF corresponding to the processor&apos;s label and granting the semaphore request when the field is in a first predetermined state; and, </claim-text>
<claim-text>responsive to a change in the status of a processor updating the ordered semaphore field corresponding to the label associated with the processor and updating the ordered semaphore field corresponding to the label identified by the pointer in the label of the processor whose status changed. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The ordered semaphore management method set forth in <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference> in which the plurality of states in the OSF include; 
<claim-text>semaphore head (SH) state, </claim-text>
<claim-text>behind semaphore head (BSH) state, </claim-text>
<claim-text>semaphore head behind (SHB) state and, </claim-text>
<claim-text>skip (Skip) state. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The ordered semaphore management method set forth in <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference> in which the OSF is encoded as the head of ordered semaphores SH when; 
<claim-text>ordered semaphores are enabled for this label and data flow, and the head field of the data flow of the label is set to head of data flow, or the ordered semaphore field of the old tail field of the data flow is in the SHB state. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The ordered semaphore management method set forth in <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference> in which the OSF is encoded as the behind semaphore head (BSH) state when; 
<claim-text>ordered semaphores are enabled for this label and data flow, and the head field of the data flow of the label is not set to head of data flow, and when the ordered semaphore field of the old tail field of the data flow is not in the SHB state. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The ordered semaphore management method set forth in <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference> in which the OSF is encoded as the semaphore head behind (SHB) state when; 
<claim-text>ordered semaphores are not enabled for this label and data flow, and the head field of the data flow of the label is set to head of data flow, or the OSF of the old tail field of the data flow is in the SHB state. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The ordered semaphore management method set forth in <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference> in which the OSF is encoded as the Skip state when; 
<claim-text>ordered semaphores are not enabled for this label and data flow, and the head field of the data flow of the label is not set to head of data flow, and the ordered semaphore field of the old tail field of the data flow is not in the SHB state. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The ordered semaphore management subsystem set forth in <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference> in which the semaphore request is granted when the OSF is SH. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The ordered semaphore management method set forth in <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference> in which in response to a change in status indicating that a processor no longer requires a semaphore; 
<claim-text>the status of the OSF associated with the processor is changed to SHB and the operation terminates if the processor is identified as the tail in the associated linked list; and, </claim-text>
<claim-text>if the processor is not identified as the tail in said linked list, the OSF associated with the processor identified by the pointer field is changed to SH if it is BSH and terminates the operation and if it is not BSH the above process is continued until the pointed to processor is identified as the tail of the link list. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. In an application system including, one or more shared resources each controlled by a unique semaphore, a plurality of processors adapted to perform similar tasks on assigned segments of a continuous data flow in the data flow sequence, using one or more shared resources controlled by semaphores, a linked list of processor labels each identifying a processor and defining the order in which the processed data is to be assembled, each said label including, a data flow ID, a data flow head field, a data flow tail field and a pointer field pointing to the next label in the linked list, a method for managing ordered semaphores comprising the steps: 
<claim-text>responsive to the creation of a label included in the linked list generating and encoding one of a plurality of predetermined states in an ordered semaphore field corresponding to the created label, said states including; 
<claim-text>a semaphore head (SH) state, </claim-text>
<claim-text>a behind semaphore head (BSH) state, </claim-text>
<claim-text>a semaphore head behind (SHB) state and, </claim-text>
<claim-text>a skip (Skip) state, </claim-text>
</claim-text>
<claim-text>responsive to a semaphore request from a processors examining the encoded ordered semaphore field corresponding to the processor&apos;s label and granting the semaphore request when the field is in the SH state; and, </claim-text>
<claim-text>responsive to a change in the status of a processor updating the ordered semaphore field corresponding to the label associated with the processor and updating the ordered semaphore field corresponding to the label identified by the pointer in the label of the processor whose status changed. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The ordered semaphore management method set forth in <dependent-claim-reference depends_on="CLM-00022">claim 20</dependent-claim-reference> in which: 
<claim-text>the SH state is selected when ordered semaphores are enabled for this label and data flow, and the head field of the data flow of the label is set to head of data flow, or the ordered semaphore field of the old tail field of the data flow is in the SHB state; </claim-text>
<claim-text>the (BSH) state is selected when ordered semaphores are enabled for this label and data flow, and the head field of the data flow of the label is not set to head of data flow, and when the ordered semaphore field of the old tail field of the data flow is not in the SHB state; </claim-text>
<claim-text>the semaphore head behind (SHB) field is selected when ordered semaphores are not enabled for this label and data flow, and the head field of the data flow of the label is set to head of data flow; and, </claim-text>
<claim-text>the Skip state is selected when ordered semaphores are not enabled for this label and data flow, and the head field of the data flow of the label is not set to head of data flow, and the ordered semaphore field of the old tail field of the data flow is not in the SHB state. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The ordered semaphore management method set forth in <dependent-claim-reference depends_on="CLM-00022">claim 20</dependent-claim-reference> in which in response to a change in status indicating that a processor no longer requires a semaphore; 
<claim-text>the status of the OSF associated with the processor is changed to SHB and the operation terminates if the processor is identified as the tail in the associated link list; and, </claim-text>
<claim-text>if the processor is not identified as the tail in said link list, the OSF associated with the processor identified by the pointer field is changed to SH if it is BSH and if it is not BSH the above process is continued until the pointed to processor is identified as the tail of the link list.</claim-text>
</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>1</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030002440A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030002440A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030002440A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030002440A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030002440A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030002440A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030002440A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030002440A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030002440A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00009">
<image id="EMI-D00009" file="US20030002440A1-20030102-D00009.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00010">
<image id="EMI-D00010" file="US20030002440A1-20030102-D00010.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00011">
<image id="EMI-D00011" file="US20030002440A1-20030102-D00011.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00012">
<image id="EMI-D00012" file="US20030002440A1-20030102-D00012.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00013">
<image id="EMI-D00013" file="US20030002440A1-20030102-D00013.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
