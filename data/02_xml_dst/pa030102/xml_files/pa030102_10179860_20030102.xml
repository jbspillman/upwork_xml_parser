<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005195A1-20030102-D00000.TIF SYSTEM "US20030005195A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005195A1-20030102-D00001.TIF SYSTEM "US20030005195A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005195A1-20030102-D00002.TIF SYSTEM "US20030005195A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005195A1-20030102-D00003.TIF SYSTEM "US20030005195A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005195A1-20030102-D00004.TIF SYSTEM "US20030005195A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005195A1-20030102-D00005.TIF SYSTEM "US20030005195A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030005195A1-20030102-D00006.TIF SYSTEM "US20030005195A1-20030102-D00006.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005195</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10179860</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20020625</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F012/00</ipc>
</classification-ipc-primary>
<classification-ipc-secondary>
<ipc>G06F012/14</ipc>
</classification-ipc-secondary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>710</class>
<subclass>200000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Semaphore management subsystem for use with multi-thread processor systems</title-of-invention>
</technical-information>
<continuity-data>
<non-provisional-of-provisional>
<document-id>
<doc-number>60301602</doc-number>
<document-date>20010627</document-date>
<country-code>US</country-code>
</document-id>
</non-provisional-of-provisional>
</continuity-data>
<inventors>
<first-named-inventor>
<name>
<given-name>Gordon</given-name>
<middle-name>Taylor</middle-name>
<family-name>Davis</family-name>
</name>
<residence>
<residence-us>
<city>Chapel Hill</city>
<state>NC</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Marco</given-name>
<family-name>Heddes</family-name>
</name>
<residence>
<residence-us>
<city>Lawrence</city>
<state>MA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Steven</given-name>
<middle-name>Kenneth</middle-name>
<family-name>Jenkins</family-name>
</name>
<residence>
<residence-us>
<city>Raleigh</city>
<state>NC</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Ross</given-name>
<middle-name>Boyd</middle-name>
<family-name>Leavens</family-name>
</name>
<residence>
<residence-us>
<city>Carry</city>
<state>NC</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Robert</given-name>
<middle-name>Brian</middle-name>
<family-name>Likovich</family-name>
<name-suffix>JR.</name-suffix>
</name>
<residence>
<residence-us>
<city>Raleigh</city>
<state>NC</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<assignee>
<organization-name>International Business Machines Corporation</organization-name>
<address>
<city>Armonk</city>
<state>NY</state>
<country>
<country-code>US</country-code>
</country>
</address>
<assignee-type>02</assignee-type>
</assignee>
<correspondence-address>
<name-1>IBM Corporation</name-1>
<name-2>Intellectual Property Law Dept. 9CCA/B002</name-2>
<address>
<address-1>P.O. Box12195</address-1>
<city>Res. Tri. Park</city>
<state>NC</state>
<postalcode>27709</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A generic method and apparatus for managing semaphores in a multi-threaded processing system has a storage area for each of the threads in the processing system. Each storage area includes a first part for storing at least one indicia for identifying at least one unique semaphore from a plurality of semaphores utilized by the multi-threaded processing system and a second part for storing an indicia for indicating a locked status for the stored semaphore. A thread requiring a semaphore sends a semaphore lock request to the semaphore manager which examines the contents of all of the storage areas to determine the status of the requested semaphore. If the requested semaphore is not locked, it is locked for the requesting thread by inserting the requested semaphore and locked status in the memory location assigned to the requesting thread. </paragraph>
</subdoc-abstract>
<subdoc-description>
<cross-reference-to-related-applications>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> This application claims the benefit of the filing date of provisional application Serial No. 60/301602, filed Jun. 27, 2001.</paragraph>
</cross-reference-to-related-applications>
<summary-of-invention>
<section>
<heading lvl="1">FIELD OF THE INVENTION </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> The invention is directed to a generic semaphore management method and subsystem which is adapted for use with a plurality of different multi-threaded processor systems. </paragraph>
</section>
<section>
<heading lvl="1">BACKGROUND </heading>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> While the invention is generic in nature and capable of use with a large variety of multi-threaded processor systems, it will be described in conjunction with a multi-threaded processor system such as the IBM Part No. IBM32NPR161EPXCAE133 Network Processor which employs a plurality of processors each of which concurrently process data frames. The individual threads/processors share common resources in the network processor. Semaphores defined to be associated with specific resources are used to allocate the specific resources to the individual threads as requested. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> Within such a network processor several data frames are processed at the same time. Each frame is processed by one processor/thread. Each processor/thread operates independently from all the other processors/threads. Thus, as the software (picocode) processes a data frame, the software has no knowledge of other frames which have been, are being, or will be processed. As frames are processed, a thread may need access to a shared resource. This shared resource is shared among all threads. To allow a thread access to the resource without interference from other threads, semaphores are used. A semaphore is a mechanism which allows a processor/thread to use a resource without interference from another processor/thread. Semaphores exist in almost every multi-processor environment where multiple processors can access common resources. A semaphore is used to ensure that one and only one processor/thread has &ldquo;ownership&rdquo; or use of a given resource at any given time. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> A network processor is a multi-processor environment with resources which can be accessed by all processors/threads. Thus, semaphores are an intricate part of network processors. As discussed above, network processors process frames which belong to one or more flows. Traditionally, semaphores are implemented in software using &ldquo;read modify write&rdquo; or &ldquo;test and set&rdquo; instructions. When these instructions are used as a basis to create and allocate semaphores, valuable system resources must be used. To implement a semaphore, system memory must be used. To access a semaphore, several lines of code must be executed. If these system resources were not used for semaphore implementation, they could be used for other functions or provide a performance increase by not executing extra line(s) of code. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> When semaphores are implemented in software, several lines of code must be executed to access and lock the semaphore, thus impacting performance. If the semaphore is unavailable (locked by another thread/processor), the software would need to poll on the semaphore. This would waste valuable bandwidth on the arbitrated memory holding semaphore locks to be accessed by all threads/processors. To implement a fair semaphore access in software requires more system memory and lines of code. For example, if a semaphore is locked, the thread/processor would need to put itself in a queue waiting for access. This queue would be implemented in system memory and require software management, impacting performance. This allows threads/processors to have fair access to resources. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> In a software semaphore environment, multiple threads/processors cannot unlock their respective semaphores at the same time. Typically, all the semaphores are in the same system memory. Each thread/processor must arbitrate to access the memory to unlock their semaphore. This may add to the processing time of other threads/processors waiting to access the same memory to access the semaphore locks. The same is true for locking semaphores. When semaphores are implemented in software, only one semaphore can be unlocked/locked at a time since all the semaphores reside in a common area of system memory. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> The invention contemplates a generic method and apparatus for managing semaphores in a multi-threaded processing system. The invention uses a non-system memory which has a storage area for each of the threads in the processing system. Each storage area includes a first part for storing at least one indicia for identifying at least one unique semaphore from a plurality of semaphores utilized by the multi-threaded processing system and a second part for storing an indicia for indicating a locked status for the stored semaphore. A thread requiring a semaphore sends a semaphore lock request to the semaphore manager which examines the contents of all of the storage areas to determine if a locked semaphore corresponding to the requested semaphore is stored in any of the storage areas. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> If a locked semaphore corresponding to the requested semaphore is not found the semaphore manager stores the requested semaphore in the storage area associated with the requesting thread along with a locked status indicia and notifies the requesting thread that the request is granted. The request is rejected if the same locked semaphore is found in the memory and is locked by the requesting thread. The request is held in abeyance if the same locked semaphore is found in the memory but is not locked by the requesting thread and the request does not include a time out enable bit which is set to one. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> When a thread issues an unlock signal the semaphore manager unlocks the semaphore associated with the thread sending the unlock signal. In response to an exit signal from a thread the semaphore manager examines the storage location associated with the thread providing the exit signal to determine if the semaphore is unlocked and unlocks the semaphore if it is locked and generates a semaphore locked exit error message for return to the associated thread.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a block diagram of a network processor including a novel generic semaphore management subsystem according to the invention; </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a block diagram of the generic semaphore subsystem of <cross-reference target="DRAWINGS">FIG. 1</cross-reference>: </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a detailed diagram of the semaphore value storage illustrated in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>; </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a flow diagram of the semaphore lock command logic illustrated in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>; </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is flow diagram of the semaphore unlock command logic of <cross-reference target="DRAWINGS">FIG. 2</cross-reference>: and, </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is a flow diagram of the error detection and exit logic illustrated in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF THE INVENTION </heading>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 1 a</cross-reference> network processor such as the IBM processor identified above includes an input/output data storage unit <highlight><bold>11</bold></highlight> which stores a plurality or stream of data frames which require processing. A dispatching unit <highlight><bold>12</bold></highlight> transfers individual data frames to a plurality of processors <highlight><bold>13</bold></highlight>-<highlight><bold>1</bold></highlight>-<highlight><bold>13</bold></highlight>-<highlight><italic>n </italic></highlight>which process the individual frames received from the dispatching unit <highlight><bold>12</bold></highlight>. The processors <highlight><bold>13</bold></highlight>-<highlight><bold>1</bold></highlight>-<highlight><bold>13</bold></highlight>-<highlight><italic>n </italic></highlight>pass the processed data frames on to a completion unit <highlight><bold>14</bold></highlight> which reassembles the data frames before passing the reassembled stream of data frames on to a second input/output unit <highlight><bold>15</bold></highlight>. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> Each of the processors <highlight><bold>13</bold></highlight>-<highlight><bold>1</bold></highlight>-<highlight><bold>13</bold></highlight>-<highlight><italic>n </italic></highlight>includes a semaphore coprocessor <highlight><bold>13</bold></highlight><highlight><italic>p </italic></highlight>which interfaces a hardware semaphore manager subsystem <highlight><bold>16</bold></highlight> constructed according to the invention. The semaphore subsystem <highlight><bold>16</bold></highlight> is implemented in hardware and interfaces with, for example, the Dyadic Protocol Processor Unit (DPPU) of the using processing system. Each DPPU contains four threads which can each process one data frame. Each DPPU has one Semaphore Co-Processor associated with it. The threads in a given DPPU interface to the one Semaphore Co-Processor within the DPPU. The multiple Semaphore Co-Processors all communicate with the central Semaphore Manager subsystem. The Semaphore Manager subsystem <highlight><bold>16</bold></highlight> contains all of the tables, and control logic to lock, unlock, and arbitrate for semaphores. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> Only one processor instruction is executed to lock a semaphore, and only one processor instruction is executed to unlock a semaphore. This saves instruction memory and processing time when compared to software implementations of semaphores. An unlock instruction from a thread executes immediately. Nothing can block unlock instructions within the Semaphore Manager subsystem, including other unlock instructions from other threads. When semaphores are implemented in software, only one semaphore can be unlocked at a time since all the semaphores reside in a common area of system memory. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> Fairness algorithms can be implemented in the Hardware Semaphore Manager subsystem. This provides fairness of access to a semaphore when multiple threads/processors are making simultaneous requests. This eliminates the need for software and system memory to be utilized to implement fairness algorithms. This increases performance by reducing frame processing time and instruction memory utilization, and does not use any system memory. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> The Hardware Semaphore Manager subsystem contains the semaphores. Each semaphore is an N bit value. For example, each semaphore could be 32 bits. This allow 2&circ; 32 resources to be managed by the Semaphore Manager. Since the Semaphore Manager subsystem is generic and designed to be used by a wide variety of systems, it is the responsibility of the using system programmer to attach a meaning to a semaphore. That is, the Semaphore Manager does not know what a Semaphore represents. It is just a string of 32 bits. Semaphores can be seen as having 32-bit address space and the programmer can map this to anything, like the Tree Search Memory, the Data Store, the Embedded PowerPC, etc. There are two advantages here. First, no system memory is used for semaphore management. Second, the Hardware Semaphore Manager implementation is generic with respect to the number of and types of system resources which must be managed by semaphores. As the Network Processor evolves and shared resources are added or removed, the Semaphore Manager does not need to change. The Hardware Semaphore Co-processor and Manager does not use any system memory. This eliminates the need for memory accesses, and allows the memory bandwidth to be used for other functions. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 2</cross-reference> the semaphore coprocessors <highlight><bold>13</bold></highlight><highlight><italic>p</italic></highlight>-<highlight><bold>1</bold></highlight>-<highlight><bold>13</bold></highlight><highlight><italic>p</italic></highlight>-<highlight><italic>n </italic></highlight>communicate with the Semaphore Manager subsystem <highlight><bold>16</bold></highlight> via a bus <highlight><bold>20</bold></highlight>. The subsystem <highlight><bold>16</bold></highlight> includes a semaphore value storage <highlight><bold>21</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 3</cross-reference>), semaphore lock command logic <highlight><bold>22</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 4</cross-reference>), semaphore unlock command logic <highlight><bold>23</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 5</cross-reference>) and semaphore exit and error detection logic <highlight><bold>24</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 6</cross-reference>). </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a block diagram of the semaphore value storage. The storage can be based upon a RAM, CAM, or discrete latches. For each thread there exists exactly two registers. The first register (Semaphore_Value) is for example a 32 bit register which holds the 32 bit Semaphore Value (Sem_Val) that can be locked by the associated thread. The second register (Semaphore_Lock) is a 1 bit register which indicates if the Sem_Val stored in the associated Semaphore_Value register is locked or unlocked. When the Semaphore_Lock register is set to &lsquo;1&rsquo;b, the Sem_Val in the Semaphore_Value register is locked. When the Semaphore_Lock register is reset to &lsquo;0&rsquo;b, no Sem_Val is locked by the associated software thread. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> A semaphore can be locked when a software thread issues a single command &ldquo;Semaphore Lock&rdquo; (Sem_Lock) with two parameters. The first parameter is the &ldquo;Semaphore Value&rdquo; (Sem_Val). This is, for example, a 32 bit value which the thread wishes to lock. The second parameter is the &ldquo;Timeout Enable&rdquo; (Timeout_Enable) bit. When the Timeout Enable bit is set and the requested semaphore is already locked by a different thread, the Semaphore Lock command will terminate without locking the semaphore. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> In the preferred embodiment, each thread has an assigned register in the semaphore value storage and is thus identified as the source of the semaphore value requested. Alternatively, the requested semaphore value could be placed in any available register along with the thread ID. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> illustrates the logic flow of the Semaphore Lock command. At block <highlight><bold>100</bold></highlight>, the software executing on thread N issues a Semaphore Lock (Sem_Lock) command with two parameters, Semaphore Value (Sem_Val), a 32 bit value, and Timeout Enable (Timeout_Enable), a 1 bit value. Block <highlight><bold>110</bold></highlight> is a fair round-robin function which selects one Semaphore Lock command to service. This function selects one thread of all threads which could all issue a Semaphore Lock command at the same time. Block <highlight><bold>120</bold></highlight> is a test to see if a Semaphore Lock command from a given thread won the round-robin selection. If the Semaphore Lock command did not win the round-robin selection, it is returned to block <highlight><bold>110</bold></highlight> (the round-robin function) until it does win. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> If the Semaphore Lock command does win the round-robin selection, the logic flow continues to block <highlight><bold>130</bold></highlight>. At block <highlight><bold>130</bold></highlight>, the Semaphore Value (Sem_Val) parameter received with the Semaphore lock command is checked to determine if this 32 bit value (Sem_Val) is already locked. This is accomplished by comparing the Sem_Val to the contents of the Semaphore_Value registers in <cross-reference target="DRAWINGS">FIG. 3</cross-reference> which have their associated Semaphore Lock register set to &lsquo;1&rsquo;b. If the Sem_Val is not already locked, then Sem_Val is locked for thread N at block <highlight><bold>140</bold></highlight>, and signals the requesting thread that the Semaphore Lock command is complete (without any errors) at block <highlight><bold>190</bold></highlight>. To lock Sem_Val, Sem_Val is written into the Semaphore_Value register associated with thread N and the Semaphore_Lock register associated with thread N is set to &lsquo;1&rsquo;b. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> If the Sem_Val is locked, block <highlight><bold>150</bold></highlight> checks if the Sem_Val is already locked by thread N, the same thread which is requesting to lock it again. If thread N is attempting to lock the Sem_Val for which it has already locked, block <highlight><bold>160</bold></highlight> will generate an error signal to the software program on thread N at block <highlight><bold>160</bold></highlight> and signals the Semaphore Lock command is complete at block <highlight><bold>190</bold></highlight>. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> If the Sem_Val is locked (go to block <highlight><bold>150</bold></highlight>) and it is not locked by thread N, the thread requesting the Sem_Val to be locked, control is passed to block <highlight><bold>170</bold></highlight>. At block <highlight><bold>170</bold></highlight>, the Timeout_Enable parameter is checked. If the Timeout_Enable parameter is not set (logic &lsquo;0&rsquo;b), this Sem_Lock command is returned to the round-robin selection algorithm, block <highlight><bold>110</bold></highlight>. This allows the Sem_Val command to eventually lock the Sem_Val once it becomes unlocked. If the Timeout_Enable parameter is set (logic &lsquo;1&rsquo;b) at block <highlight><bold>170</bold></highlight>, block <highlight><bold>180</bold></highlight> will signal the software program that the Sem_Val was not able to be locked for thread N. The Semaphore Lock command is complete at block <highlight><bold>190</bold></highlight>. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> illustrates the logic flow of the Semaphore Unlock command. At block <highlight><bold>200</bold></highlight>, the software on thread N issues a Semaphore Unlock (Sem_Unlock) command with no parameters. At block <highlight><bold>210</bold></highlight>, the Semaphore Value (Sem_Val) associated with thread N is unlocked. This is accomplished by resetting the Semaphore_Lock register to &lsquo;0&rsquo;b associated with thread N. The Semaphore Unlock command is complete at block <highlight><bold>220</bold></highlight>. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> illustrates the logic flow, for the Semaphore Co-processor/Manager, when processing completes for a frame and the thread exits. In normal operation, a thread will unlock it&apos;s semaphore using the Sem_Unlock command before processing of the frame is complete. If a semaphore is locked when a thread exits (software has completed processing a frame), an error has occurred. The Semaphore Co-processor/Manager will detect and report this error. When software is done processing a frame, the last command executed is the Exit (Exit) command. At block <highlight><bold>400</bold></highlight>, the Semaphore Co-processor/Manager detects the Exit command has been executed. At block <highlight><bold>410</bold></highlight>, the Semaphore_Lock register is tested for the thread which just executed the Exit command. If the Semaphore_Lock register is &lsquo;0&rsquo;b, the thread does not have a locked semaphore and no error is reported. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> If the Semaphore_Lock register is &lsquo;1&rsquo;b, the thread has a locked semaphore. At block <highlight><bold>420</bold></highlight>, the Semaphore_Lock register is cleared to &lsquo;0&rsquo;b. At block <highlight><bold>430</bold></highlight>, a &ldquo;Semaphore Locked at Exit&rdquo; error is generated. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> The foregoing is illustrative of the present invention and is not to be construed as limiting the invention. While several embodiments of this invention have been described in detail, those skilled in this art will readily appreciate that many modifications are possible without materially departing from the novel teachings and advantages of this invention. Accordingly, all such modifications are intended to be included within the scope of this invention as defined by the claims. In the claims, means-plus-function clauses are intended to cover the structures described herein as performing the recited function and structural functional equivalents thereof. Therefore, it is to be understood that the foregoing is illustrative of the present invention and is not to be construed as limited to the specific embodiments disclosed, and that modifications to the disclosed embodiments, as well as other embodiments, are intended to be included within the scope of the claims appended hereto. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">We claim: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A subsystem for managing semaphores for a multi-threaded processing system comprising: 
<claim-text>a memory having a plurality of storage areas, </claim-text>
<claim-text>each of the storage areas including a first part for storing at least one indicia for identifying at least one unique semaphore from a plurality of semaphores utilized by the multi-threaded processing system and a second part for storing an indicia for indicating a locked status for the stored semaphore; </claim-text>
<claim-text>first logic circuit responsive to a semaphore lock request from a thread for examining the contents of all of the storage areas to determine if a locked semaphore corresponding to the requested semaphore is stored in any of the storage areas; </claim-text>
<claim-text>second logic circuit responsive to the first logic circuit for storing the requested semaphore in a storage area along with a locked status if the requested semaphore is not found in the search and notifying the requesting thread that the request is granted; </claim-text>
<claim-text>third logic circuit responsive to the first logic circuit for rejecting the request if the same locked semaphore is found in the memory and is locked by the requesting thread; and, </claim-text>
<claim-text>fourth logic circuit responsive to the first and third logic circuits for holding the semaphore request in abeyance if the same locked semaphore is found in the memory but is not locked by the requesting thread. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The subsystem set forth in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> in which the fourth logic circuit completes the semaphore lock request with an indication that the semaphore was locked if the request includes a set time out enable bit. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The subsystem set forth in claims <highlight><bold>1</bold></highlight> or <highlight><bold>2</bold></highlight> including: 
<claim-text>fifth logic circuit responsive to an unlock request from a thread for accessing a memory location associated with the thread for changing the stored semaphore status from locked to unlocked. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The subsystem set forth in <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference> including: 
<claim-text>sixth logic circuit responsive to an exit signal from a thread for examining the storage location associated with the thread providing the exit signal to determine if the semaphore is unlocked and for unlocking the semaphore if it is locked and generating a semaphore locked at exit error message. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. A subsystem for managing semaphores for a multi-threaded processing system comprising: 
<claim-text>a memory having a plurality of storage areas one for each of the threads in the multi-threaded processing system, each of the storage areas including a first part for storing at least one indicia for identifying at least one unique semaphore from a plurality of semaphores utilized by the multi-threaded processing system and a second part for storing an indicia for indicating a semaphore locked status for the stored semaphore; </claim-text>
<claim-text>first logic circuit responsive to a request for a semaphore from a thread for examining the contents of all of the storage areas to determine if a locked semaphore corresponding to the requested semaphore is stored in any of the storage areas; </claim-text>
<claim-text>second logic circuit for storing the requested semaphore in the storage area associated with the requesting thread along with a status indicating a locked semaphore if the requested semaphore is not found in the search and notifying the requesting thread that the request is granted; </claim-text>
<claim-text>third logic circuit for rejecting the request if the same locked semaphore is found in the memory associated with the requesting thread; and fourth logic circuit for holding the semaphore request in abeyance if the same locked semaphore is found in a memory not associated with the requesting thread. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The subsystem set forth in <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference> in which the fourth logic circuit completes the semaphore lock request with an indication that no semaphore was locked if the request includes a set time out enable bit. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The subsystem set forth in claims <highlight><bold>5</bold></highlight> or <highlight><bold>6</bold></highlight> including: 
<claim-text>fifth logic circuit responsive to an unlock signal from a thread for accessing a memory location associated with the thread for changing the stored semaphore status from locked to unlocked. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The subsystem set forth in <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference> including: 
<claim-text>sixth logic circuit responsive to an exit signal from a thread for examining the storage location associated with the thread providing the exit signal to determine if the semaphore is unlocked and for unlocking the semaphore if it is locked and generating a semaphore locked at exit error message. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. In a multi-threaded processing system a method for managing semaphores comprising the following steps: 
<claim-text>establishing a memory having a plurality of storage areas each of which includes a first part for storing at least one indicia for identifying at least one unique semaphore from a plurality of semaphores utilized by the multi-threaded processing system and a second part for storing an indicia for indicating a locked status for the stored semaphore; </claim-text>
<claim-text>receiving a semaphore lock request from a thread, examining the contents of all of the storage areas to determine if a locked semaphore corresponding to the requested semaphore is stored in any of the storage areas; </claim-text>
<claim-text>if a locked semaphore corresponding to the requested semaphore is not found storing the requested semaphore in a storage area along with a locked status indicia and notifying the requesting thread that the request is granted; </claim-text>
<claim-text>rejecting the request if the same locked semaphore is found in the memory and is locked by the requesting thread; and, </claim-text>
<claim-text>holding the semaphore request in abeyance if the same locked semaphore is found in the memory but is not locked by the requesting thread. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The method set forth in <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference> in which the semaphore lock request is completed with an indication that no semaphore was locked if the request includes a set time out enable bit. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The method set forth in claims <highlight><bold>9</bold></highlight> or <highlight><bold>10</bold></highlight> in which: 
<claim-text>in response to an unlock signal from a thread changing the stored semaphore status from locked to unlocked in the storage location associated with the thread. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The method set forth in <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference> including: 
<claim-text>examining in response to an exit signal from a thread the storage location associated with the thread providing the exit signal to determine if the semaphore is unlocked and unlocking the semaphore if is locked and generating a semaphore locked at exit error message. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. In a multi-threaded processing system a method for managing semaphores comprising the following steps: 
<claim-text>establishing a memory having a storage areas for each of the threads each of which includes a first part for storing at least one indicia for identifying at least one unique semaphore from a plurality of semaphores utilized by the multi-threaded processing system and a second part for storing an indicia for indicating a locked status for the stored semaphore; </claim-text>
<claim-text>receiving a semaphore lock request from a thread, examining the contents of all of the storage areas to determine if a locked semaphore corresponding to the requested semaphore is stored in any of the storage areas; </claim-text>
<claim-text>if a locked semaphore corresponding to the requested semaphore is not found storing the requested semaphore in a predetermined storage area along with a locked status indicia and notifying the requesting thread that the request is granted; </claim-text>
<claim-text>rejecting the request if the same locked semaphore is found in the memory and is locked by the requesting thread; and, </claim-text>
<claim-text>holding the semaphore request in abeyance if the same locked semaphore is found in the memory but is not locked by the requesting thread. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The method set forth in <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference> in which the semaphore lock request is completed with an indication that no semaphore was locked if the request includes a set time out enable bit. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The method set forth in claims <highlight><bold>13</bold></highlight> or <highlight><bold>14</bold></highlight> in which: 
<claim-text>in response to an unlock signal from a thread changing the stored semaphore status from locked to unlocked in the storage location associated with the thread. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The method set forth in <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference> including: 
<claim-text>examining in response to an exit signal from a thread the storage location associated with the thread providing the exit signal to determine if the semaphore is unlocked and unlocking the semaphore if is locked and generating a semaphore locked at exit error message. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The subsystem set forth in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> in which the memory is a content addressable memory and the contents are searched for the thread ID. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The subsystem set forth in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> in which the memory has a different location associated with each thread and thread ID is used to address that location.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>1</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005195A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005195A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005195A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005195A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005195A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005195A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030005195A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
