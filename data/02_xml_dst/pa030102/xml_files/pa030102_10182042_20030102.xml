<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030004697A1-20030102-D00000.TIF SYSTEM "US20030004697A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030004697A1-20030102-D00001.TIF SYSTEM "US20030004697A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030004697A1-20030102-D00002.TIF SYSTEM "US20030004697A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030004697A1-20030102-D00003.TIF SYSTEM "US20030004697A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030004697A1-20030102-D00004.TIF SYSTEM "US20030004697A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030004697A1-20030102-D00005.TIF SYSTEM "US20030004697A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030004697A1-20030102-D00006.TIF SYSTEM "US20030004697A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030004697A1-20030102-D00007.TIF SYSTEM "US20030004697A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030004697A1-20030102-D00008.TIF SYSTEM "US20030004697A1-20030102-D00008.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030004697</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10182042</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20020724</filing-date>
</domestic-filing-data>
<foreign-priority-data>
<priority-application-number>
<doc-number>0001585.9</doc-number>
</priority-application-number>
<filing-date>20000124</filing-date>
<country-code>GB</country-code>
</foreign-priority-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F009/45</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>703</class>
<subclass>013000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Method of designing, modelling or fabricating a communications baseband stack</title-of-invention>
</technical-information>
<inventors>
<first-named-inventor>
<name>
<given-name>Gavin</given-name>
<middle-name>Robert</middle-name>
<family-name>Ferris</family-name>
</name>
<residence>
<residence-non-us>
<city>London</city>
<country-code>GB</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
</inventors>
<correspondence-address>
<name-1>Richard C Woodbridge</name-1>
<name-2>Woodbridge &amp; Associates</name-2>
<address>
<address-1>P O Box 592</address-1>
<city>Princeton</city>
<state>NJ</state>
<postalcode>08542-0592</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
<international-conventions>
<pct-application>
<document-id>
<doc-number>PCT/GB01/00278</doc-number>
<document-date>20010124</document-date>
<country-code>WO</country-code>
</document-id>
</pct-application>
</international-conventions>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A method of designing, modelling or fabricating a communications baseband stack, comprising the steps of: (a) creating a description of one or more of the following parameters of the baseband stack: (i) resource requirements; (ii) capabilities; (iii) behavior; and (b) using that description as an input to software comprising a virtual machine layer optimised for a communications DSP in order to generate an emulation of the baseband stack to be designed, modelled or fabricated. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">FIELD OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> This invention relates to software for designing, modelling or fabricating a communications baseband stack. Communications baseband stacks are used for digital signal processing in communications equipment. </paragraph>
</section>
<section>
<heading lvl="1">DESCRIPTION OF THE PRIOR ART </heading>
<paragraph id="P-0002" lvl="7"><number>&lsqb;0002&rsqb;</number> Technology Background: Digital Signal Processing, DSPs and Baseband Stacks. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> Digital signal processing is a process of manipulating digital representations of analogue and/or digital quantities in order to transmit or recover intelligent information which has been propagated over a channel. Digital signal processors perform digital signal processing by applying high speed, high numerical accuracy computations and are generally formed as integrated circuits optimised for high speed, real-time data manipulation. Digital signal processors are used in many data acquisition, processing and control environments, such as audio, communications, and video. Digital signal processors can be implemented in other ways, in addition to integrated circuits; for example, they can be implemented by micro-processors and programmed computers. The term &lsquo;DSP&rsquo; used in this specification covers any device or system, whether in software or hardware, or a combination of the two, capable of performing digital signal processing. The term &lsquo;DSP&rsquo; therefore covers one or more digital signal processor chips; it also covers the following: one or more digital signal processor chips working together with one or more external co-processors, such as a FPGA (field programmable gate array) or an ASIC programmed to perform digital signal processing; as well as any Turing equivalent to any of the above. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> In the communications sector, a DSP will be a critical element for a baseband stack as the baseband stack runs on the DSP; the stack plus DSP together perform digital signal processing. The term &lsquo;baseband stack&rsquo; used in this specification means a set of processing steps (or the structures which perform the steps) including one or more of the following: source coding, channel coding, modulation, or their inverses, namely source decoding, channel decoding and demodulation. In addition, the term &lsquo;baseband stack&rsquo; should be construed as including structures capable of processing digital signals without any form of down conversion; a software radio would include such a baseband stack. As will be appreciated by the skilled implementer, source coding is used to compress a signal (i.e. the source signal) to reduce the bitrate. Channel coding adds structured redundancy to improve the ability of a decoder to extract information from the received signal, which may be corrupted. Modulation alters an analogue waveform in dependence on the information to be propagated. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> Baseband stacks are found in mobile telephones (e.g. a GSM stack or a UMTS stack) and digital radio receivers (e.g. a DAB stack), as well as other one and two-way digital communications devices. The term &lsquo;communications&rsquo; used in this specification covers all forms of one or two way, one to one and one to many communications and broadcasting. The terms &lsquo;designing&rsquo; and &lsquo;modelling&rsquo; typically includes the processes of one or more of emulation, resource calculation, diagnostic analysis, hardware sizing, debugging and performance estimating. </paragraph>
<paragraph id="P-0006" lvl="7"><number>&lsqb;0006&rsqb;</number> The Increasing Complexity of Communications Systems Places Intense Pressure on Baseband Stack Development </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> The complexity of communications systems is increasing on an almost daily basis. There are a number of drivers for this: traffic on the Internet is increasing at 1000% pa. Much of this (largely bursty) data is moving to wireless carriers, but there is less and less spectrum available on which to host such services. These facts have led to the use of ever more complex signal processing algorithms, in order to squeeze as much data as possible into the smallest possible bandwidth. In fact, the complexity of these algorithms has been increasing faster than Moore&apos;s law (i.e that computing power doubles every 18 months), with the result that conventional DSPs are becoming insufficient. For complex terminals, therefore, an ASIC must be produced to manage the vast parallel processing load involved. However, this is where the problems really begin. For not only are the algorithms used more complex on the signal processing front; the use of bursty, variable-QoS, often ephemeral transport channels, mandated by the move from primarily voice traffic to primarily Internet-related traffic, needs ever more sophisticated control plane software, even at Layer <highlight><bold>1</bold></highlight> (which requires hard real-time code). Conventional DSP toolsets do not provide an appropriate mechanism to address this problem, and as a result many current designs are not scalable to deal with &lsquo;real world&rsquo; data applications. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> However, the high MIPs requirements of modern communication systems represent only part of the story. The other problem arises when a multiplicity of standards (e.g., GSM, IS-136, UMTS, IS-95 etc.) need to be deployed within a single SoC (System on a Chip). SoC devices supporting multiple standards will be increasingly attractive to device vendors seeking to tap efficiently different markets in different countries; also, it is expected that the next generation UMTS phones will have not only GSM (or current generation) capabilities but also added features, such as DAB (Digital Radio Broadcasting) receivers, hence requiring baseband stacks for UMTS, GSM and DAB. The complexity of communications protocols is now such that no single company can hope to provide solutions for all of them. But there is an acute problem building an SoC which integrates IP from multiple vendors (e.g. the IP in the three different baseband stacks listed above) together into a single coherent package in increasingly short timescales: no commercial system currently exists in the market to enable multiple vendors&apos; IP to be interworked. Layer <highlight><bold>2</bold></highlight> and layer <highlight><bold>3</bold></highlight> software (generally, soft real-time code) is more straightforward, since it may simply be run as one process of many as software on a DSP or other generalised processor. But layer <highlight><bold>1</bold></highlight> IP (hard real time, often parallel) algorithms, present a much more difficult problem, since the necessary hardware acceleration often dominates the architecture of the whole layer, providing non-portable, fragile, solution-specific IP. </paragraph>
<paragraph id="P-0009" lvl="7"><number>&lsqb;0009&rsqb;</number> Overview of Deficiencies in Current Models of Baseband Stack Development </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> In the past, baseband stacks have been relatively simple, the amount of required high-MIPs functionality has been relatively small and only modest amounts of multi-standard, multi-vendor integration have been performed. But as noted above, none of these now apply: (a) the bandwidth pressure means that ever more complex algorithms (e.g., turbo decoding, MUD, RAKE, etc.) are employed, necessitating the use of hardware; (b) the increase in packet data traffic is also driving up the complexity of layer <highlight><bold>1</bold></highlight> control planes as more birth-death events and reconfigurations must be dealt with in hard real time; and (c) time to market, standard diversification and differentiation pressures are leading vendors to integrate more and more increasingly complex functionality (3G, Bluetooth, 802.11, etc.) into a single device in record time&mdash;necessitating the licensing of layer <highlight><bold>1</bold></highlight> IP to produce an SoC (system on chip) for a particular target application. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> Currently, there is no adequate solution for this problem; the VHDL toolset providers (such as Cadence and Synopsis) are approaching it from the &lsquo;bottom up&rsquo;&mdash;their tools are effective for producing individual high-MIPs units of functionality (e.g., a Viterbi accelerator) but do not provide tools or integration for the layer <highlight><bold>1</bold></highlight> framework or control code. DSP vendors (e.g., TI, Analog Devices) do provide software development tools, but their real time models are static (and so do not cope well with packet data burstiness) and their DSPs are limited by Moore&apos;s law, which acts as a brake to their usefulness. Furthermore, communication stack software is best modelled as a state machine, for which C or C&plus;&plus; (the languages usually supported by the DSP vendors) is a poor substrate. </paragraph>
<paragraph id="P-0012" lvl="7"><number>&lsqb;0012&rsqb;</number> Detailed Analysis of Deficiencies in Current Models of Baseband Stack Development </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> Conventionally, baseband stack development for digital communications is fragmented and highly specialised. For example, the initial development of the signal processing algorithms that are the heart of a baseband stack is generally performed on a mathematical modelling environment (such as Matlab), with fitting to a particular memory and MIPs (Million Instructions per Second) budget for the final target DSP being done by skilled estimation using a conventional spreadsheet. Once this modelling process has been performed satisfactorily, code modules and infrastructure software for the stack will be written, adapting existing libraries where possible (and possibly an RTOS (Real-Time Operating System)). Then, a &lsquo;real time&rsquo; prototype hardware system will be built (sometimes called a &lsquo;rack&rsquo;) in which any required hardware acceleration will be prototyped on PLDs (Programmable Logic Device) where possible. This will be tested off air, and necessary changes made to the code. Once satisfactory, the stack will be &lsquo;locked off&rsquo; and the final ASIC (Application Specific Integrated Circuit) (incorporating the hardware acceleration modules as on-chip peripherals) will be produced. The resultant baseband DSP or DSP components is then tested and then shipped. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> There are a number of problems with this &lsquo;traditional&rsquo; approach. The more important of these are that: </paragraph>
<paragraph id="P-0015" lvl="2"><number>&lsqb;0015&rsqb;</number> The resulting stacks tend to have a lot of architecture specificity in their construction, making the process of &lsquo;porting&rsquo; to another hardware platform (e.g. a DSP from another manufacturer) time consuming. </paragraph>
<paragraph id="P-0016" lvl="2"><number>&lsqb;0016&rsqb;</number> The stacks also tend to be hard to modify and &lsquo;fragile&rsquo;, making it difficult both to implement in-house changes (e.g., to rectify bugs or accommodate new features introduced into the standard) and to licence the stacks effectively to others who may wish to change them slightly. </paragraph>
<paragraph id="P-0017" lvl="2"><number>&lsqb;0017&rsqb;</number> Integration with the MMI (Man Machine Interface) tends to be poor, generally meaning that a separate microcontroller is used for this function within the target device. This increases chip count and cost. </paragraph>
<paragraph id="P-0018" lvl="2"><number>&lsqb;0018&rsqb;</number> The process is quite slow, with about 1 year minimum elapsed time to produce a baseband processor for a significantly complex system, such as DAB (Digital Audio Broadcasting). </paragraph>
<paragraph id="P-0019" lvl="2"><number>&lsqb;0019&rsqb;</number> The process puts a lot of stress on technical authorities&mdash;so called &lsquo;gurus&rsquo;&mdash;to govern the overall best way to allocate buffers, manage downconversion, insert digital filters, generate good channel models and so on. This is generally a disadvantage since it adds a critical path and key personnel dependency to the project of stack production and lengthens timelines. The resulting product is quite likely not to include all the appropriate current technology because no individual is completely expert across all of the prevailing best practice, nor will the gurus or their team necessarily have time to incorporate all of the possible innovations in a given stack project even if they did know them. </paragraph>
<paragraph id="P-0020" lvl="2"><number>&lsqb;0020&rsqb;</number> The reliance on manual computation of MIPs and memory requirements, and the bespoke nature of the DSP modules and infrastructure code for the stack, means that there is an increased probability of error in the product. </paragraph>
<paragraph id="P-0021" lvl="2"><number>&lsqb;0021&rsqb;</number> An associated point is that generally real-time prototyping of the stack is not possible until the &lsquo;rack&rsquo; is built; a lack of high-visibility debuggers available even at that point means that final stack and resource &lsquo;lock off&rsquo; is delayed unnecessarily, pushing out the hardware production time scale. High visibility debuggers would, if available, be very useful since they provide, when developing in a high level language like C&plus;&plus;, the ability in the development tool to place break points in the code, halt the processing at that point and then examine the contents of memory, single step instructions to see their effects, etc. Triggers can then also be placed in the code that will stop execution and start up the debugger when particular conditions arise. These are very powerful tools when developing application software. &lsquo;Lock-off&rsquo; refers to the fact that when one phase of the project is complete, development can move onto the next. In a hardware development you cannot iterate as easily as in software as each iteration requires expensive or time consuming fabrication. </paragraph>
<paragraph id="P-0022" lvl="2"><number>&lsqb;0022&rsqb;</number> Because it is likely that low-level modules or hardware acceleration &lsquo;controllers&rsquo; will have to be developed for the stack being produced, developers will have to become familiar with the assembly language of the target processor, and will become dependent upon the development tools provided for that processor. </paragraph>
<paragraph id="P-0023" lvl="2"><number>&lsqb;0023&rsqb;</number> Lack of modularity coupled with the fact that the infrastructure code is not reused means that much the same work will have to be redone for the next digital broadcast stack to be produced. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> Coupled with these difficulties are an associated set of &lsquo;strategic&rsquo; problems that arise from this type of approach to stack development, in which stacks are inevitably strongly attached to a particular hardware environment, namely: </paragraph>
<paragraph id="P-0025" lvl="2"><number>&lsqb;0025&rsqb;</number> From the stack producer&apos;s point of view, there is an uncomfortably close relationship with the chosen DSP hardware platform. Not only must this be selected carefully since mistakes will require a costly (and time-consuming) port, but the development tools, low-level assembly language, test &lsquo;rack&rsquo; hardware development and final platform ASIC production will all be architecture-specific. If an opportunity to use the stack on another hardware platform comes up, it will first have to be ported, which will take quite a long time and introduce multiple codebases (and thereby the strong risk of platform-specific bugs). The code base is the source code that underpins a project. Ideally when developing software you would have a one to one mapping between source code and functionality, so if a number of projects require a particular function they would all share the same implementation. Thus, if that implementation is improved all projects will benefit. What tends to happen, however, is that separate projects have separate copies of the code and over time the implementations diverge (rather like genes in the natural world). When projects use different hardware, under the conventional development paradigm, it is sometimes impossible to use the same code. And even if the same hardware platform becomes available with an upgraded specification, the code will still have to undergo a &lsquo;mini-port&rsquo; to be able to use those additional features (more on-board memory, for example, or a second MAC (Multiply Accumulate) unit). </paragraph>
<paragraph id="P-0026" lvl="2"><number>&lsqb;0026&rsqb;</number> From the hardware producer&apos;s point of view, there is an equally uncomfortably close relationship with the software stacks. Hardware producers do not want (on the whole) to become experts in the business of stack production, and yet without such stacks (to turn their devices into useful products) they find themselves unable to shift units. For the marketplace, the available &lsquo;software base&rsquo; can obscure the other features upon which the hardware producer&apos;s products ought more properly to compete (such as available MIPs, power consumption, available hardware IP, etc.). </paragraph>
<paragraph id="P-0027" lvl="2"><number>&lsqb;0027&rsqb;</number> Operating system providers (such as Symbian Limited) find it essential to interface their OS with baseband communications stacks; in practice this can be very difficult to achieve because of the monolithic, power hungry and real-time requirements of conventional stacks. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> Reference may be made to eXpressDSP Real-Time Software Technology from Texas Instruments Incorporated. This suite of products enables the reduction of development and integration time for DSP software. But it exemplifies many of the disadvantages of conventional design approaches since it is tied exclusively to the Texas Instruments DSP platform. Further detailed differences of one implementation of the present invention over the eXpressDSP Real-Time Software Technology suite are summarised in the Detailed Description. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE PRESENT INVENTION </heading>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> In accordance with a first aspect of the present invention, there is provided a method of designing, modelling or fabricating a communications baseband stack, comprising the steps of: </paragraph>
<paragraph id="P-0030" lvl="2"><number>&lsqb;0030&rsqb;</number> (a) creating a description of one or more of the following parameters of the baseband stack: </paragraph>
<paragraph id="P-0031" lvl="3"><number>&lsqb;0031&rsqb;</number> (i) resource requirements; </paragraph>
<paragraph id="P-0032" lvl="3"><number>&lsqb;0032&rsqb;</number> (ii) capabilities; </paragraph>
<paragraph id="P-0033" lvl="3"><number>&lsqb;0033&rsqb;</number> (iii) behaviour; and </paragraph>
<paragraph id="P-0034" lvl="2"><number>&lsqb;0034&rsqb;</number> (b) using that description as an input to software comprising a virtual machine layer optimised for a communications DSP in order to generate an emulation of the baseband stack to be designed, modelled or fabricated. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> Hence, the present invention contemplates (i) applying a form of &lsquo;emulation&rsquo; to the domain of communications baseband stack design and (ii) introduces the idea of using a virtual machine layer optimised for a communications DSP in this context. This approach makes accurate simulation of resource utilisation (e.g. processor requirements, peak resource situations, state considerations etc.) possible. The term &lsquo;emulation&rsquo; used in this specification should be broadly construed in this context to include any process which enables a system (whether hardware or software) to behave in the same or a similar way to another system (whether hardware or software). Modifications and refinements can be made at an early design stage with the present invention, improving design quality, reducing the chance of costly design errors and reducing overall time to market. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> Preferably, the method includes the following stages: </paragraph>
<paragraph id="P-0037" lvl="2"><number>&lsqb;0037&rsqb;</number> (a) using, for one or more components to be incorporated in the baseband stack, a component description which defines some or all of the externally visible attributes of a component, as well as its behaviour, as an input to a mathematical modelling tool programmed to output component related performance data for each component; </paragraph>
<paragraph id="P-0038" lvl="2"><number>&lsqb;0038&rsqb;</number> (b) processing the component related performance data for each component to yield a baseband stack description; </paragraph>
<paragraph id="P-0039" lvl="2"><number>&lsqb;0039&rsqb;</number> (c) creating a resources description defining the resources of the baseband stack; </paragraph>
<paragraph id="P-0040" lvl="2"><number>&lsqb;0040&rsqb;</number> (d) creating an interface description defining how each component is to used in the baseband stack; and </paragraph>
<paragraph id="P-0041" lvl="2"><number>&lsqb;0041&rsqb;</number> (e) using each of the baseband stack description, the resources description, and the interface description as the inputs to the software. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> The software can therefore emulate accurately the baseband stack; it can also be both instrumented and interpreted/compiled to output diagnostic information in respect of a component in the same format as (e.g. in order to merge with) the component description for that component in order to refine the quality of the component description. This feedback loop can be very effective in rapidly extracting accurate data and feeding it back into the design loop. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> Another advantage of this structured approach is that hardware components can be progressively introduced into a test system: a first test may be carried out using software to emulate a given hardware component as part of a design or modelling process; the emulated component is then replaced with the hardware component, and a further test is carried out. Problems and unexpected consequences of using hardware components can therefore be more readily identified. In the same way, ports of individual stack modules can be made to a particular architecture and tested: for example, imagine a baseband stack comprising modules A, B and C: once fully tested in a software emulation, module A can be ported onto the target DSP and the system re-tested, with module A running on the target DSP and modules B and C continuing to run on the emulator. Problems can therefore be more readily identified and resolved. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> In addition to emulating the baseband stack, the method can be used to fabricate an actual baseband stack implementation (i.e. generate executable code running on the target platform) by compiling automatically generated source code. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> The method of the present invention may utilise a standardised description of the characteristics (including non-interface behaviour) of communications components to enable the emulation to accurately estimate the resource requirements of a system using those components. This is referred to as the Component Definition Language&mdash;(&lsquo;CDL&rsquo;) in the embodiment described in the Detailed Description. Communications components are conventionally described with a variety of ad hoc labels. This renders any systematic approach to simulation impossible. Using the standardised description system, component developers will be able to publish their component specifications for potential developers to make use of. Product developers will be able to benchmark their solution using a number of potential suppliers simply by plugging in different data files. It will also be possible for a system builder to calculate, through repeated simulation or mathematically, the ideal specifications of the components they want. Once they have completed this process they will be able to approach potential suppliers armed with precise details of what they require. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> Further, the method of the present invention may also utilise a language designed to define completely the functionality of a baseband stack (e.g. receiver/transceiver) to estimate, simulate or fabricate a real device using the above design process. This is referred to as the Device Definition Language&mdash;(&lsquo;DDL&rsquo;) in the embodiment described in the Detailed Description. This leads to many advantages: Currently, defining the functionality of a receiver/transceiver is often done in a non-systematic ad hoc manner. DDL however allows the exchange of information between any number of diverse applications, design tools and visualisers. It will also be architecture independent and provide a reliable medium of exchanges between individuals, companies etc. The language will be extensible to allow it to incorporate innovations in the future and so that third parties can incorporate their own components. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> At this point, some further elaboration on the meaning of a &lsquo;virtual machine layer&rsquo; is appropriate. A &lsquo;virtual machine&rsquo; typically defines the functionality and interfaces of the ideal machine for implementing the type of applications relevant to the present invention. It typically presents to the using application an ideal machine, optimised for the task in hand, and hides the irregularities and deficiencies of the actual hardware. The &lsquo;vial machine&rsquo; may also manage and/or maintain one or more state machines modelling or representing communications processes. The &lsquo;virtual machine layer&rsquo; is then software that makes a real machine look like this ideal one. This layer will typically be different for every real machine type. A &lsquo;virtual machine layer&rsquo; typically refers to a layer of software which provides a set of one or more APIs (Application Program Interfaces) to perform some task or set of tasks (e.g. digital signal processing) and which also owns the critical resources that must be allocated and shared between using programs (e.g. resources such as memory and CPU). </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> The virtual machine layer in an implementation of the present invention is preferably optimised to allocate, share and switch resources in such a way as is best for digital signal processing; a typical operating system, in contrast, will be optimised for general user-interface programs, such as word processors. Thus, for example, the resource switching algorithms in this case will typically operate on much smaller time increments than that of an end-user operating system and may control parallel processes. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> The virtual machine layer, optimised for a communications DSP, insulates software baseband stacks from the hardware upon which they must execute. Hence, baseband stacks can be made very portable since they can be isolated by the virtual machine layer from changes in the underlying hardware. The virtual machine layer may also manage flow control between different connected modules (each performing different functions); this may be done on a concurrent basis. It may also define common data structures for signal processing, as will be described in more detail subsequently. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> The software of the present invention may be used in a development environment to enable a communications device, (e.g. a baseband stack, or indeed an entire SoC including several baseband stacks from different vendors, or an end product such as a mobile telephone) to be modelled and developed or to actually perform baseband processing. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> The potency of applying the &lsquo;virtual machine layer&rsquo; concept to the domain of communications DSPs can best be understood through an example from a non-analogous field. In the field of PC software, Microsoft&apos;s Windows&trade; operating system (sitting on top of the system BIOS) insulates software developers from the actual machine in use, and from the specifics of the devices connected to it. It provides, in other words, a &lsquo;virtual machine layer&rsquo; upon which code can operate. This is schematically illustrated in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. Because of this virtual machine layer, it is not necessary for someone writing a word processor, for example, to know whether it is a Dell or a Compaq machine that will execute their code, or what sort of printer the user has connected (if any). Furthermore, the operating system provides a set of common components, functions and services (such as file dialog panels, memory allocation mechanisms, and thread management APIs). Because only written once, the rigour, extent and reliability of such &lsquo;common code&rsquo; is greatly increased over what would be the case if each application had to re-implement it, over and over again. Further, the manufacturers of PC hardware are protected from the complexities of software development, having only to provide a BIOS and drivers from the appropriate Windows APIs in order to take advantage of the vast array of existing software for that platform. This situation can be contrasted with the pre-Windows situation in which each application would frequently contain its own custom GUI code and drivers, as illustrated in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> A key enabler for the PC Windows &lsquo;virtual machine layer&rsquo; approach is that a large number of applications require largely the same underlying &lsquo;virtual machine&rsquo; functionality. If only one application ever needed to use a printer, or only one needed multithreading, then it would not be effective for these services to be part of the Windows &lsquo;virtual machine layer&rsquo;. But, this is not the case as there are a large number of applications with similar I/O requirements (windows, icons, mice, pointers, printers, disk store, etc.) and similar &lsquo;common code&rsquo; requirements, making the PC &lsquo;virtual machine layer&rsquo; a compelling proposition. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> However, prior to the present invention, no-one had considered applying the &lsquo;virtual machine&rsquo; concept to the field of communications DSPs; by doing so, the present invention enables software to be written for the virtual machine rather than a specific DSP, decoupling engineers from the architecture constraints of DSPs from any one source of manufacture. This form of DSP independence is as potentially useful as the hardware independence in the PC world delivered by the Microsoft Windows operating system. It is illustrated schematically in <cross-reference target="DRAWINGS">FIGS. 3 and 4</cross-reference>. <cross-reference target="DRAWINGS">FIG. 3</cross-reference> shows a conventional situation in which parts of the baseband stack which should, when properly implemented, be architecturally neutral are in fact not properly isolated from the substrate hardware; <cross-reference target="DRAWINGS">FIG. 4</cross-reference> depicts how the virtual machine layer (called the Communications Virtual Machine or CVM of the present invention does successfully isolate these parts of the baseband stack. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> There are therefore several key advantages to the CVM: </paragraph>
<paragraph id="P-0055" lvl="2"><number>&lsqb;0055&rsqb;</number> Porting baseband stacks across DSP architectures and to different media access hardware (such as, for example, porting a stack for a GSM phone operating at 900 MHz to one operating at 1800 MHz) will be much faster since the invention enables stacks to be designed which are not architecture or spectrum specific: a critical advantage as time to market becomes ever more important. Hence, a stack will work on any DSP architecture to which the virtual machine layer has been ported. Likewise, a DSP to which the virtual machine layer has been ported will run all the stacks written for the virtual machine layer. </paragraph>
<paragraph id="P-0056" lvl="2"><number>&lsqb;0056&rsqb;</number> Much of the high MIPS, complex code (e.g. a Viterbi decoder) will be written once only for the virtual machine layer, as opposed to many different times for each DSP architecture. Hence, quality and reliability of this complex code can be economically improved. That in turn means that the baseband stacks will themselves need less code and what stack code there is need be less complex, thus increasing its reliability. </paragraph>
<paragraph id="P-0057" lvl="2"><number>&lsqb;0057&rsqb;</number> The virtual machine layer provides the ability to prototype either entirely in software or with a mixture of software and proven DSP components, allowing the identification of algorithmic deficiencies and resource requirements earlier in the development cycle. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> Preferably, the virtual machine layer is programmed with or enables access to various core processes and/or core structures and/or core functions and/or flow control and/or state management. The core processes with which the virtual machine layer is programmed (or enables access to) include one or more &lsquo;common engines&rsquo;. These &lsquo;common engines&rsquo; perform one or more of the baseband stack functions, namely: source coding, channel coding, modulation and their inverses (source decoding, channel decoding and These two libraries, no matter what the underlying hardware and operating system substrate, are manifest as a common API to the &lsquo;core&rsquo; code, which therefore does not have to be modified during a port. The only code which does get modified, namely the contents of the library implementations, benefits from significant encapsulation and a wide variety of test vectors generated from the mathematical models. It is because the points of articulation in the architecture are appropriately positioned that porting of stacks can be rapidly achieved using this approach. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> Furthermore, as a development platform, this approach has the great advantage that one can develop on one architecture (e.g. the Intel platform) running not a mathematical model but rather a full, real-time transceiver, and then simply swap the libraries and recompile on the target architecture. This is very useful when trying to e.g., tune an equaliser module. </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> The CVM approach builds on this way of working. However, in addition, as much as possible of the common functionality is abstracted into the &lsquo;virtual machine&rsquo; hardware abstraction layer, together with key services and functions that are useful for all digital communications baseband processing work. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> below shows how this would work at an architectural level. Instead of the given stack being shipped with different library implementations for platform A and platform B, in the CVM there is a common &lsquo;baseband operating system&rsquo; layer for each of platform A and platform B, providing a common API on top of which (apart from a recompile) the higher level code can run unchanged. </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> Furthermore, we can incorporate into this layer much of the functionality that otherwise would lie within the C&plus;&plus; core, such as the symbol subscriber architecture for symbol-directed processing, and the pipeline architecture for data directed processing. </paragraph>
<paragraph id="P-0063" lvl="7"><number>&lsqb;0063&rsqb;</number> Specific CVM Development Methodologies: Two Phase Scheduling </paragraph>
<paragraph id="P-0064" lvl="7"><number>&lsqb;0064&rsqb;</number> Phase I </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> An important aspect when building a Baseband communications system is quantifying the requirements of the hardware and software platform the application will run on. A baseline calculation of the number of MIPs (millions of instructions per second) an application will require is relatively straight forward, simply calculate the requirements of each component to perform one operation, multiply by the number of operations and add them all together. This, however does not take into account aspects like parallelism. Although, theoretically, 2&times;500 MIPs processors will deliver 1000 MIPs of processing power the algorithms may not be able to take advantage of this if the are waiting for operations on another chip to complete. There are also the extra processing requirements of the scheduler and the data transfer overheads to consider. The data transfer penalty is probably small if both processors are on the same board but more significant if they are on separate boards plugged into an external bus. Bus contention (two or more processors wanting to transfer data at the same time) can also reduce overall efficiency. </paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> The CVM provides a number of methods to facilitate implementing systems in this sort of distributed environment. </paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> Initially we can quantify the requirements of the individual computing components such as the signal processing functions described in Appendix 1 and the more application specific engines built upon them. In environments like 3G mobile communications the amount of data passing though a block will vary over time so it is not sufficient just to calculate the requirements of a block at one data rate. Instead a profile will be built up over the range of potential input vector sizes. </paragraph>
<paragraph id="P-0068" lvl="0"><number>&lsqb;0068&rsqb;</number> The CVM allows a system to be defined as a collection of data flows (pipelines) where data is injected at one end, and consumed at the other. The engines on these pipelines are characterised in terms of how much processing they require as a function of input vector size. The first pass at calculating the MIPs usage is to simulate passing engines of varying size along this pipeline and calculating the total usage as a function of input block size. This calculates the total MIPs requirements of the engines assuming they are run sequentially to completion on a single processor. </paragraph>
<paragraph id="P-0069" lvl="0"><number>&lsqb;0069&rsqb;</number> A more sophisticated model then assigns engines to separate processors and allows true pipelining. A solution based on this architecture will require more MIPs than the single threaded solution but has the potential, once the pipeline is loaded, to process data engines in shorter elapsed time. If N is the number of processors, E(N) the efficiency of processor utilisation (1&equals;100%, 0&equals;zero), Mp the MIPs rating of a single processor and M the total MIPs requirement of the problem then the time to process 1 seconds worth of data T will be;</paragraph>
<paragraph lvl="0"><in-line-formula><highlight><italic>T&equals;M/</italic></highlight>(<highlight><italic>E</italic></highlight>(<highlight><italic>N</italic></highlight>)&times;<highlight><italic>N&times;Mp</italic></highlight>)</in-line-formula></paragraph>
<paragraph id="P-0070" lvl="0"><number>&lsqb;0070&rsqb;</number> The objective is to find the smallest value of N where T is less than <highlight><bold>1</bold></highlight> by a &ldquo;comfortable&rdquo; margin. E(N) will be close to 1 for a single board and will drop as the number of boards is increased (because of the overheads introduced by scheduling and data transfer). E(N) will also vary depending on how the processing engines are distributed between the boards (because of the varying data transfer requirements and the possibility of uneven load balancing leaving an processor idle some of the time). </paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> A CVM simulator that has knowledge of the scheduling process, the characteristics of the bus and the characteristics of the engines will be able to calculate E(N) and hence T for different numbers of boards and engine arrangements. It will also be possible to investigate the effects of &ldquo;doubling up&rdquo; some of the engines; that is having the same functionality on more than one board. </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> Once we know the sequence of engines that are required for a task we can set the CVM to search through arrangements of engines and boards looking for the optimal solution. It will also be possible to have individual Mp values for the boards (replace N&times;Mp by the sum of the individual Mps) and to tie specific engines to specific boards, for instance a Viterbi decoder will always run on an FPGA, which will have a higher MIPs rating than a DSP. For large numbers of engines exhaustive searches will become impractical and some assistance from an engineer will be required. </paragraph>
<paragraph id="P-0073" lvl="7"><number>&lsqb;0073&rsqb;</number> Phase II </paragraph>
<paragraph id="P-0074" lvl="0"><number>&lsqb;0074&rsqb;</number> Once we have and acceptable arrangements of engines and boards we can move onto phase two of the scheduling process, &ldquo;doing it for real&rdquo;. Phase I will have generated a system configuration which can no be used to load the engines onto the correct boards. This information will also be made available to the scheduler on the main board. Once the system is running data engines will flow from the scheduler to the engines that will operate on them. Most of the time this scheduler will simply send data onward in the order they need to be processed but there will be occasions when more intelligence can be applied. When there are multiple engines of equivalent priority the scheduler will look to try and balance the queue sizes on all the boards by scheduling work to the least loaded. When the same functionality exists on more than one board the scheduler will again look for the most appropriate board to schedule. All the boards will have a local scheduler to obviate the need to involve the main scheduler in routing engines between two engines on the same board. When there is a choice of board to send work to schedulers will always choose their own board when possible. The scheduler will also have to monitor the absolute urgency of the most urgent engines looking for potential lulls in the processing when it can schedule less urgent activities, such as routing log messages and monitoring information back to a monitoring console. </paragraph>
<paragraph id="P-0075" lvl="7"><number>&lsqb;0075&rsqb;</number> More CVM Development Methodologies: the MIPS Counter as Used in a UMTS Implementation </paragraph>
<paragraph id="P-0076" lvl="0"><number>&lsqb;0076&rsqb;</number> As noted above, the CVM consists of a number of distributed engines that are connected and controlled by the CVM Scheduler. These engines may sit on the same hardware, but could sit on different hardware (CPU, DSP or FPGA.) For a UMTS implementation of the CVM, a system to identify bottlenecks and aid in serialisng the engines/blocks has been developed. We first assume that the processing route for a block of data is given; for instance the UMTS standards 25.212 and 25.222 suggest how the block is muxed in the TrCH stage. Some of the processing may then be switched between routes depending on some objective criteria such as BER. However, the required engines are known. Then, the order of the engine must be determined in terms of the data size and number of users. For example, if a vector is of length n, and if the engine consists of for (int i&equals;0,i&lt;n, i&plus;&plus;) </paragraph>
<paragraph id="P-0077" lvl="2"><number>&lsqb;0077&rsqb;</number> &lcub;</paragraph>
<paragraph id="P-0078" lvl="2"><number>&lsqb;0078&rsqb;</number> for (int j&equals;0,j&lt;n, j&plus;&plus;) </paragraph>
<paragraph id="P-0079" lvl="2"><number>&lsqb;0079&rsqb;</number> &lcub;</paragraph>
<paragraph id="P-0080" lvl="2"><number>&lsqb;0080&rsqb;</number> //Do something . . . </paragraph>
<paragraph id="P-0081" lvl="2"><number>&lsqb;0081&rsqb;</number> &rcub;</paragraph>
<paragraph id="P-0082" lvl="2"><number>&lsqb;0082&rsqb;</number> &rcub;</paragraph>
<paragraph id="P-0083" lvl="7"><number>&lsqb;0083&rsqb;</number> then we can say that the process is an order n&circ; <highlight><bold>2</bold></highlight>, or o(n&circ; <highlight><bold>2</bold></highlight>). Next we can count the number of operations (&lsquo;&plus;&rsquo;, &lsquo;&minus;&rsquo;, . . . in (//Do something&rsquo;). FFTs are for example n Log (n) processes. We can then multiply this by the device&apos;s instructions per operation and then divide this by the number of MIPS to get the time that the device will take to perform a task. Alternatively we can simply set a relative time. </paragraph>
<paragraph id="P-0084" lvl="0"><number>&lsqb;0084&rsqb;</number> The same process can be repeated for the number of users (K): for example MU can go as <highlight><bold>2</bold></highlight>&circ; K. Finally, each block may or may not change the bit rate. Turbo Encoding increases it multiplicatively by a factor of 3.m CRC adds 12 bits. Note, that bus latency, the scheduler, parallelisation/serialisation can all be considered to be engines). </paragraph>
<paragraph id="P-0085" lvl="0"><number>&lsqb;0085&rsqb;</number> The point is that we know that data rate. The question answered by this process is how we can distribute the engines (e.g. their MIPS budget) to accommodate this. </paragraph>
<paragraph id="P-0086" lvl="7"><number>&lsqb;0086&rsqb;</number> TopDownDesign </paragraph>
<paragraph id="P-0087" lvl="0"><number>&lsqb;0087&rsqb;</number> Traversing the processing chain is quite complex when state and data control are needed. This procedure is used to tie in RS C&plus;&plus; blocks through a standard adaptor to integrate with Simulink. Fundamentally, the intention is to move through hierarchies. As you move up layers, so the abstraction becomes higher and higher. The intention is to round trip data a &lsquo;user&rsquo; creates 3 services: The UE Tx this to the BS through a physical channel with certain properties. The BS receives and decodes the data. In this case the BS has a trivial backhaul, and retransmits the data back to the UE, through a physical channel, whereupon the data is compared to the input data. This system allows us to interchange engines to improve performance in terms of BER and time in a variety of channels. </paragraph>
<paragraph id="P-0088" lvl="7"><number>&lsqb;0088&rsqb;</number> CVM Features </paragraph>
<paragraph id="P-0089" lvl="0"><number>&lsqb;0089&rsqb;</number> The CVM can be thought of as a minimal OS to provide the sorts of functionality required by baseband processing stacks (and, as mentioned, these can be two-way stacks also, such as GSM or Bluetooth). It is therefore complementary to a full-blown embedded operating system like Microsoft Windows CE or Symbian&apos;s EPOC. </paragraph>
<paragraph id="P-0090" lvl="0"><number>&lsqb;0090&rsqb;</number> The CVM provides (inter alia) the following functionality: </paragraph>
<paragraph id="P-0091" lvl="2"><number>&lsqb;0091&rsqb;</number> Extensive set of vector-processing primitives (more completely listed at Appendix 1), covering operations such as FFTs, FIR and IIR and wave digital filters, decimation, correlation, complex multiplication, etc. These should use hardware acceleration where this is available on the underlying hardware, and would be accessed via a set of library calls paralleling an extended version of a library. In a sense, this aspect of the CVM represents a software or API abstraction of an idealised digital signal processing engine for digital communications. </paragraph>
<paragraph id="P-0092" lvl="2"><number>&lsqb;0092&rsqb;</number> Support for allocation of aligned buffers and memory &lsquo;handshaking&rsquo; (ping-pong buffers). </paragraph>
<paragraph id="P-0093" lvl="2"><number>&lsqb;0093&rsqb;</number> Advanced scheduling management, with the option for pre-emptive multithreading of a simple kind. Hard real-time performance (i.e., the ability to guarantee that a piece of code will execute at a particular point in time) will be supported as a key component of the architecture. Inter-process communication structures (at least shared memory) and thread synchronisation facilities will be provided. A key feature is a stochastic parallel scheduler, cognisant of design time pardoning decisions for CVM engines across a heterogenous computational substrate. </paragraph>
<paragraph id="P-0094" lvl="2"><number>&lsqb;0094&rsqb;</number> Explicit support for the notion of symbol and data directed processing. This will directly support the ability to add symbol subscribers and pipeline stages into the structure to allow modular development. </paragraph>
<paragraph id="P-0095" lvl="2"><number>&lsqb;0095&rsqb;</number> Support for key I/O peripherals, including serial ports, parallel ports and display controllers. </paragraph>
<paragraph id="P-0096" lvl="2"><number>&lsqb;0096&rsqb;</number> Extensibility to enable the scope of the O/S to be increased, particularly for modular I/O support. </paragraph>
<paragraph id="P-0097" lvl="2"><number>&lsqb;0097&rsqb;</number> Characterisation libraries for a particular implementation, allowing mathematical models and real-time prototypes to mimic the performance of the target substrate and interconnects to a high degree of accuracy. </paragraph>
<paragraph id="P-0098" lvl="2"><number>&lsqb;0098&rsqb;</number> PC versions to enable the production of real-time prototypes. </paragraph>
<paragraph id="P-0099" lvl="2"><number>&lsqb;0099&rsqb;</number> Support for communication with a host (application) OS&mdash;this will be bidirectional to enable callbacks and so on. A component intercommunication technology (e.g. COM) may be used to provide the binary &lsquo;glue&rsquo;. A suitable application OS might be, for example, EPOC32 or Windows CE, as these are OSs designed to perform the more usual user-level I/O and structured storage management demodulation). The &lsquo;common engines&rsquo; include the fast Fourier transform (FFI), Viterbi decoder (with various constraint lengths, Galois polynomials and puncturing vectors), Reed-Solomon engines, discrete cosine transform (DCT) for the MPEG decoders, time and frequency bitwise re-ordering for error decoherence, complex vector multiplication and Euler synthesis. A more extensive list is contained at Appendix 1. One or more of these parameterised transforms are commonly required by communications baseband stacks. This subsidiary feature is predicated on the inventive insight that a set of common processes is found within almost all of the key digital broadcast systems; an example is the similarity of GSM to DAB: both, for example, use interleaving and Viterbi decoding. Commonality is hence predicated on a common mathematical foundation. </paragraph>
<paragraph id="P-0100" lvl="0"><number>&lsqb;0100&rsqb;</number> In addition, a &lsquo;core structure&rsquo; may also be present in each case. The &lsquo;core structure&rsquo; involves splitting the decoding chain up into a symbol processing section (concerned with processing full symbols, regardless of whether all the information held within that symbol is to be used) and data directed processing, in which only those bits which hold relevant information are processed. In each case, it is highly desirable that the processing modules are able to allocate, share and dispose of intermediate, aligned memory buffers, pass events between themselves, and exist within a framework that enables modular development. </paragraph>
<paragraph id="P-0101" lvl="0"><number>&lsqb;0101&rsqb;</number> The core function may relate to resource allocation and scheduling, include one or more of the following: memory allocation, real time resource allocation and concurrency management. </paragraph>
<paragraph id="P-0102" lvl="0"><number>&lsqb;0102&rsqb;</number> The software can preferably access PC debug tools, which are far superior in performance and capability than DSP design tools. It may be subject to conformance scripting, as will be defined subsequently. In addition, it may operate with a component, in which only that information necessary to enable it to operate with and/or otherwise model the performance of the component is supplied by the owner of the intellectual property in the component. This enables the owner of the intellectual property (which can be valuable trade secret information such as internal details, design and operation) to hide that information, releasing only far less critical information, such as the functions supported, the parameters required the APIs, timing and resource interactions, and the expected performance for characterisation estimation. </paragraph>
<paragraph id="P-0103" lvl="0"><number>&lsqb;0103&rsqb;</number> Since the CVM draws together the ideas introduced above, and is a critical aspect of an implementation of the present invention, it is summarised in the following section. </paragraph>
<paragraph id="P-0104" lvl="7"><number>&lsqb;0104&rsqb;</number> Summary of the CVM Implementation </paragraph>
<paragraph id="P-0105" lvl="0"><number>&lsqb;0105&rsqb;</number> The CVM is both a platform for developing digital signal processing products and also a runtime for actually running those products. The CVM in essence brings the complexity management techniques associated with a virtual machine layer to real-time digital signal processing by (i) placing high MIPS digital signal processing computations (which may be implemented in an architecture specific manner) into &lsquo;engines&rsquo; on one side of the virtual machine layer and (ii) placing architecture neutral, low MIPS code (e.g. the Layer <highlight><bold>1</bold></highlight> code defining various low MIPS processes) on the other side. More specifically, the CVM separates all high complexity, but low-MIPs control plane and data &lsquo;operations and parameters&rsquo; flow functionality from the high-MIPs &lsquo;engines&rsquo; performing resource-intensive (e.g., Viterbi decoding, FFT, correlations, etc.). This separation enables complex communications baseband stacks to be built in an &lsquo;architecture neutral&rsquo;, highly portable manner since baseband stacks can be designed to run on the CVM, rather than the underlying hardware. The CVM presents a uniform set of APIs to the high complexity, low MIPS control codes of these stacks, allowing high MIPS engines to be re-used for many different kinds of stacks (e.g. a Viterbi decoding engine can be used for both a GSM and a UMTS stack). </paragraph>
<paragraph id="P-0106" lvl="0"><number>&lsqb;0106&rsqb;</number> The CVM can form part of a design tool which can support stochastic simulation of load on multiple parallel datapaths (distribution to underlying &lsquo;engines&rsquo; of the virtual machine) where the effect of the distribution of these datapaths to different positions within a potentially heterogenous communications DSP topology or a non-symmetric memory topology (e.g., some components being local, others accessible across a contested bus, etc) may be explored with respect to expected loading patterns for given precomputed scenarios of use. The output of such a design tool is an initial partitioning of the design &lsquo;engines&rsquo; (high-MIPs components) into variously distributed &lsquo;hard&rsquo; and &lsquo;soft&rsquo; datapaths (where a hard datapath is a flow implemented in an ASIC or FPGA, and soft datapath is a flow implemented over a conventional programmable DSP). This partitioning is visible to the dynamic scheduling engine (by means of which the high level, architecture neutral software dispatches its processing requests to the underlying engines) and is utilised by it, to assist in the process of making optimal or close to optimal runtime scheduling decisions. </paragraph>
<paragraph id="P-0107" lvl="0"><number>&lsqb;0107&rsqb;</number> During the development stage of a digital signal processing product, the MIPS requirements of various designs of the digital signal processing product can be simulated or modelled by the CVM in order to identify the arrangement which gives the optimal access cost (e.g. will perform with the minimum number of processors); a resource allocation process is used which uses at least one stochastic, statistical distribution function, as opposed to a deterministic function. Simulations of various DSP chip and FPGA implementations are possible; placing high MIPS operations into FPGAs is highly desirable because of their speed and parallel processing capabilities. </paragraph>
<paragraph id="P-0108" lvl="0"><number>&lsqb;0108&rsqb;</number> During actual operation, a scheduler in the CVM can intelligently allocate tasks in real-time to computational resources in order to maintain optimal operation. This approach is referred to as &lsquo;2 Phase Scheduling&rsquo; in this specification. Because the resource requirements of different engines can be (i) explicitly modelled at design time and (ii) intelligently utilised during runtime, it is possible to mix engines from several different vendors in a single product. As noted above, these engines connect up to the Layer <highlight><bold>1</bold></highlight> control codes not directly, but instead through the intermediary of the CVM virtual machine layer. Further, efficient migration from the non-real time prototype to a run time using a DSP and FPGA combination and then onto a custom ASIC is possible using the CVM. </paragraph>
<paragraph id="P-0109" lvl="0"><number>&lsqb;0109&rsqb;</number> The CVM is implemented with three key features: </paragraph>
<paragraph id="P-0110" lvl="2"><number>&lsqb;0110&rsqb;</number> Dynamic, multi-memory-space multiprocessor distributed scheduler with support for co-scheduling. </paragraph>
<paragraph id="P-0111" lvl="2"><number>&lsqb;0111&rsqb;</number> APIs to commonly used, high-MIPs operations for digital broadcast and communications, with architecture-native implementations. </paragraph>
<paragraph id="P-0112" lvl="2"><number>&lsqb;0112&rsqb;</number> Resource management and normalisation layer (provided over the native RTOS). </paragraph>
<paragraph id="P-0113" lvl="0"><number>&lsqb;0113&rsqb;</number> The CVM can exist in several &lsquo;pipeline&rsquo; forms. A &lsquo;pipeline&rsquo; is a structure or set of interoperating hardware or software devices and routines which pass information from one device or process to another. In the DSP environment, such pieces of information are often referred to as &lsquo;symbols&rsquo;. Pipelines can be implemented also as data flow architectures as well as conventional procedural code and all such variants are within the scope of the present invention. The CVM can also be conceptualised and implemented as a state machine or as procedural code and again all such variants are within the scope of the present invention. </paragraph>
<paragraph id="P-0114" lvl="0"><number>&lsqb;0114&rsqb;</number> One instance of the CVM contains an Interpreted Pipeline Manager, which incorporates run-time versions of the CVM core. By &lsquo;interpreted&rsquo; we mean that its specification has not been translated into the underlying machine code, but is repeatedly re-translated as the program runs, in exactly the same was as an interpreted language, such as BASIC. </paragraph>
<paragraph id="P-0115" lvl="0"><number>&lsqb;0115&rsqb;</number> Another instance is an Instrumented Interpreted Pipeline Manager which incorporates run-time versions of the CVM core. This operates in the same was as an Interpreted Pipeline Manager, but also produces metrics and measurements helpful to the developer. An interpreted non-instrumented version is also useful for development and debugging, as is a compiled and instrumented version. The latter may be the optimal tool for developing and debugging. </paragraph>
<paragraph id="P-0116" lvl="0"><number>&lsqb;0116&rsqb;</number> Another version of the CVM is a Pipeline Builder. Instead of running, it outputs computer source code, such as C, which can be compiled to produce a Pipeline implementation. For this reason it must have available to it CVM libraries. It can be thought of as the compiled and non-instrumented variant. </paragraph>
<paragraph id="P-0117" lvl="0"><number>&lsqb;0117&rsqb;</number> The CVM apparatus may include or relate to a standardised description of the characteristics (including non-interface behaviour) of communications components to enable a simulator to accurately estimate the resource requirements of a system using those components. Time and concurrency restraints may be modelled in the CVM apparatus, enabling mapping onto a real time OS, with the possibility of parallel processing. </paragraph>
<paragraph id="P-0118" lvl="0"><number>&lsqb;0118&rsqb;</number> Other features and aspects of the present invention are defined in the Claims of this specification.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0119" lvl="0"><number>&lsqb;0119&rsqb;</number> The invention will now be described with reference to the accompanying drawings in which: </paragraph>
<paragraph id="P-0120" lvl="0"><number>&lsqb;0120&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a schematic showing the relationship between hardware and application software when using Microsoft Windows; </paragraph>
<paragraph id="P-0121" lvl="0"><number>&lsqb;0121&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a schematic showing the pre-Microsoft Windows relationship between hardware and application software; </paragraph>
<paragraph id="P-0122" lvl="0"><number>&lsqb;0122&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a schematic showing the conventional failure to isolate supposedly architecturally neutral parts of a baseband stack; </paragraph>
<paragraph id="P-0123" lvl="0"><number>&lsqb;0123&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 4A and 4B</cross-reference> are schematics showing the successful isolation of architecturally neutral parts of a baseband stack in the present invention; </paragraph>
<paragraph id="P-0124" lvl="0"><number>&lsqb;0124&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a schematic showing the structure in a baseband communications stack; </paragraph>
<paragraph id="P-0125" lvl="0"><number>&lsqb;0125&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is a schematic showing the common engines and structure in an embodiment of the present invention; </paragraph>
<paragraph id="P-0126" lvl="0"><number>&lsqb;0126&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> is a schematic showing the relationship between the CVM of the present invention, the hardware and the stack; </paragraph>
<paragraph id="P-0127" lvl="0"><number>&lsqb;0127&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 8 and 9</cross-reference> are schematics showing steps in the development cycle using the present invention.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION </heading>
<paragraph id="P-0128" lvl="0"><number>&lsqb;0128&rsqb;</number> The present invention will be described with reference to the CVM implementation from RadioScape Limited of London, United Kingdom. </paragraph>
<paragraph id="P-0129" lvl="7"><number>&lsqb;0129&rsqb;</number> CVM Overview </paragraph>
<paragraph id="P-0130" lvl="0"><number>&lsqb;0130&rsqb;</number> The CVM is both a platform for developing digital signal processing products and also a runtime for actually running those products. The CVM in essence brings the complexity management techniques associated with a virtual machine layer to real-time digital signal processing by (i) placing high MIPS digital signal processing computations (which may be implemented in an architecture specific manner) into &lsquo;engines&rsquo; on one side of the virtual machine layer and (ii) placing architecture neutral, low MIPS code (e.g. the Layer <highlight><bold>1</bold></highlight> code defining various low MIPS processes) on the other side. More specifically, the CVM separates all high complexity, but low-MIPs control plane and data &lsquo;operations and parameters&rsquo; flow functionality from the high-MIPs &lsquo;engines&rsquo; performing resource-intensive (e.g., Viterbi decoding, FFT, correlations, etc.). This separation enables complex communications baseband stacks to be built in an &lsquo;architecture neutral&rsquo;, highly portable manner since baseband stacks can be designed to run on the CVM, rather than the underlying hardware. The CVM presents a uniform set of APIs to the high complexity, low MIPS control codes of these stacks, allowing high MIPS engines to be re-used for many different kinds of stacks (e.g. a Viterbi decoding engine can be used for both a GSM and a UMTS stack). </paragraph>
<paragraph id="P-0131" lvl="0"><number>&lsqb;0131&rsqb;</number> The virtual machine layer supports underlying high MIPs algorithms common to a number of different baseband processing algorithms, and makes these accessible to high level, architecture neutral, potentially high complexity but low-MIPs control flows through a scheduler interface, which allows the control flow to specify the algorithm to be executed, together with a set of resource constraint envelopes, relating to one or more of: time of execution, memory, interconnect bandwidth, inside of which the caller desires the execution to take place. </paragraph>
<paragraph id="P-0132" lvl="0"><number>&lsqb;0132&rsqb;</number> During the development stage of a digital signal processing product, the MIPS requirements of various designs of the digital signal processing product can be simulated or modelled by the CVM in order to identify the arrangement which gives the optimal access cost (e.g. will perform with the minimum number of processors); a resource allocation process is used for modelling which uses at least one stochastic, statistical distribution function (and/or a statistical measurement function), as opposed to a deterministic function. Simulations of various DSP chip and FPGA implementations are possible; placing high MIPS operations into FPGAs is highly desirable because of their speed and parallel processing capabilities. </paragraph>
<paragraph id="P-0133" lvl="0"><number>&lsqb;0133&rsqb;</number> During actual operation, a scheduler in the CVM can intelligently allocate tasks in real-time to computational resources in order to maintain optimal operation. This approach is referred to as &lsquo;2 Phase Scheduling&rsquo; in this specification. Because the resource requirements of different engines can be (i) explicitly modelled at design time and (ii) intelligently utilised during runtime, it is possible to mix engines from several different vendors in a single product. As noted above, these engines connect up to the Layer <highlight><bold>1</bold></highlight> control codes not directly, but instead through the intermediary of the CVM virtual machine layer. Further, efficient migration from the PCT non-real time prototype to a run time using a DSP and FPGA combination and then onto a custom ASIC is possible. </paragraph>
<paragraph id="P-0134" lvl="0"><number>&lsqb;0134&rsqb;</number> The CVM is implemented with three key features: </paragraph>
<paragraph id="P-0135" lvl="2"><number>&lsqb;0135&rsqb;</number> Dynamic, multi-memory-space multiprocessor distributed scheduler with support for co-scheduling. </paragraph>
<paragraph id="P-0136" lvl="2"><number>&lsqb;0136&rsqb;</number> APIs to commonly used, high-MIPs operations for digital broadcast and communications, with architecture-native implementations. </paragraph>
<paragraph id="P-0137" lvl="2"><number>&lsqb;0137&rsqb;</number> Resource management and normalisation layer (provided over the native RTOS). </paragraph>
<paragraph id="P-0138" lvl="7"><number>&lsqb;0138&rsqb;</number> The CVM is a Design Flow Solution as Well as a Runtime </paragraph>
<paragraph id="P-0139" lvl="0"><number>&lsqb;0139&rsqb;</number> The CVM provides a complete design flow to complement the runtime. This provides the engineer with fully integrated mathematical models, statistical simulation tools (essential for operation with bursty data), a priori partitioning simulation tools (to determine e.g., whether a datapath should go into hardware or run in software on a DSP core). Through the use of custom libraries for mathematical modelling tools (e.g. Matlab/Simulink), the CVM is able to model in detail and with bit-exact accuracy the high-MIPs engine operations, allowing engineers to determine up front how many bits wide the various datapaths must be, etc. However, the system is also able to accept XML commands from a statistically simulated control plane, allowing birth/death events and burstiness to be handled within the context of the model. Furthermore, since even the simulation engines are accessed through the scheduler&apos;s indirection interface, it is possible to plug in calls to e.g. real hardware implementations to speed simulation execution. </paragraph>
<paragraph id="P-0140" lvl="0"><number>&lsqb;0140&rsqb;</number> It is also, importantly, possible to perform simulation of resource loading under various system partitioning decisions. How many instances of a particular algorithmic &lsquo;engine&rsquo; (e.g., a Viterbi decoder, a RAKE receiver element, a block FFT operation, etc.) are required to provide sufficient cover under various statistical loadings&quest; What happens if a datapath is moved across a latent and/or contended resource such as a bus&quest; What if the datapath is implemented in hardware rather than software&quest; All of these decisions are critical but existing toolsets have not addressed them, and this is doubly true when the partitioning decisions are being made with respect to multiple, third-party IP engines or engines (see below). The CVM design flow explicitly enables these sorts of design decisions to be answered. Furthermore, initial partitioning information is then &lsquo;fed forward&rsquo; from the design toolset into the runtime scheduler, enabling it to vector requests off to the appropriate engine instances for implementation when the system is under actual dynamic load. </paragraph>
<paragraph id="P-0141" lvl="0"><number>&lsqb;0141&rsqb;</number> Working from the &lsquo;bottom up&rsquo;, treating the software largely as an afterthought, is not longer a viable route to market; this path simply takes too long, yields a result that is too architecture-specific, and has a bad &lsquo;fit&rsquo; to the parallel, state-machine nature of the underlying domain. Working from the &lsquo;top down&rsquo;, the paradigm utilised by the CVM, provides a much more powerful and extensible solution. </paragraph>
<paragraph id="P-0142" lvl="0"><number>&lsqb;0142&rsqb;</number> A final point about the CVM is that by separating out the control flow code from the underlying engines, it becomes possible to perform a lot of development work on conventional platforms (e.g., PCs) without having to work with the actual embedded target. This allows for much faster turnaround of designs than is generally possible when using a particular vendor&apos;s end target development platform. </paragraph>
</section>
<section>
<heading lvl="1">EXAMPLE </heading>
<paragraph id="P-0143" lvl="7"><number>&lsqb;0143&rsqb;</number> The CVM is a Design Solution for Hard Real Time, Multi-vendor, Multi-protocol Environments Such as SoC for 3G Systems </paragraph>
<paragraph id="P-0144" lvl="0"><number>&lsqb;0144&rsqb;</number> One of the core elements of the CVM is its ability to deal with (potentially conflicting) resource requirements of third party software/hardware in a hard real time, multi-vendor, multi-protocol environment. This ability is a key benefit of the CVM and is of particular importance when designing a system on chip (SoC). To understand this, consider the problems faced by a would-be provider of a baseband chip for the 3G cellular phone market. First, because of the complexity of the layer <highlight><bold>1</bold></highlight> processing required, simply writing code for an off-the-shelf DSP is not an option; an ASIC will be required to handle the complexities of dispreading, turbo decoding, etc. Secondly, since UMTS will only be rolled out in a small number of metro locations initially, the chip will also need to be able to support GSM. It is unlikely that the company producing the baseband chip will have extensive skills in both these areas, therefore IP will need to be licensed in. This point becomes particularly relevant in light of the ever increasing time-to-market pressures for technology companies. But licensing in part-hardware, part-software IP engines from multiple vendors for layer <highlight><bold>1</bold></highlight> provides a real problem. First, there is no current common simple standard for &lsquo;mix and match&rsquo; IP in this manner. What is needed, and what the CVM design flow provides, is a way to characterise both the static and dynamic resource requirements of a 3<highlight><superscript>rd </superscript></highlight>party IP block, so that it may be co-scheduled in real time with other IP engines, potentially from an entirely different supplier, and then connected transparently through to the higher level layer <highlight><bold>1</bold></highlight> control code. Furthermore, the nature of the CVM is that these high-level overall call structures and control planes can be produced in an architecture-neutral language (e.g., SDL compiled to ANSI C), with only the low-level, high-MIPs parts being implemented directly in an architecture-specific form. </paragraph>
<paragraph id="P-0145" lvl="0"><number>&lsqb;0145&rsqb;</number> As noted above, the high MIPs functionality contained within the engines represent complete operational routines. These engines may be implemented in hardware or software or some combination of the two, but this is unimportant from the point of view of the high level &lsquo;calling&rsquo; code, which is entirely abstracted from the engines. The high-level IP communicates with the underlying engines via CVM scheduler calls, which allow the hard real-time dynamic resource constraints to be specified. The scheduler then dispatches the request to the appropriate datapath for execution, which may involve calling a function on a DSP, or passing data to an FPGA or ASIC. Importantly, the scheduler can deal with multiple hard datapaths that may have different access and execution profiles&mdash;for example, an on-bus Viterbi decoder, an on-chip software based decoder, and an off-chip dedicated ASIC accessed via external DMA&mdash;and pass particular requests off to the appropriate unit, which is completely independent from the calling high-level code. </paragraph>
<paragraph id="P-0146" lvl="0"><number>&lsqb;0146&rsqb;</number> This also means that, where two different communications stacks require some common high-MIPs engines, a vendor of an appropriate (platform-specific) engine implementation (whether designed in hardware, software, or some combination of both) can sell into both markets, and, if the two standards are implemented on a single SoC, both stacks can potentially share the same accelerator. In addition, the CVM specifies a set of over 100 core operations which taken together provide around 80% of the high-MIPs functionality found in the vast majority of digital broadcast and communications protocols. The CVM runtime also provides a wrapper around the underlying RTOS, presenting the high-level code with a normalised interface for resource management (including threads, memory, and external access). </paragraph>
<paragraph id="P-0147" lvl="0"><number>&lsqb;0147&rsqb;</number> Using the CVM, it is possible to construct an integrated development platform for communications SoC products, in which a number of third party vendors are able to publish their IP, as either high-level architecture neutral SDL or C&plus;&plus; components, or architecture specific, resource profiled engines (which can be hardware, software, or a combination of both). An integrated design flow would enable the SoC designer to produce an overall system that contains the appropriate engines (chosen from particular vendors), add her own IP on both or either side of the CVM, and then generate both the deployable hardware specification (as a number of VHDL-defined cores, together with accelerators) and software components. It is possible to construct a toolset which would provide a complete flow through mathematical modeling, statistical a priori stochastic simulation for partitioning, protocol verification and final system generation and provide appropriate mechanisms to characterise, publish, enumerate and use libraries of &lsquo;packaged&rsquo; IP within designs. </paragraph>
<paragraph id="P-0148" lvl="0"><number>&lsqb;0148&rsqb;</number> This system would have the potential to become the main workbench for SoC designers, who would only have to go into VHDL tools to develop the high-MIPs engines, not any of the layer <highlight><bold>1</bold></highlight> control fabric. </paragraph>
<paragraph id="P-0149" lvl="7"><number>&lsqb;0149&rsqb;</number> The CVM Allows SDL to be Used in Designing Layer <highlight><bold>1</bold></highlight> </paragraph>
<paragraph id="P-0150" lvl="0"><number>&lsqb;0150&rsqb;</number> As noted above, the CVM allows the low-MIPs code to be written in an architectural neutral manner, using either ANSI C&plus;&plus; or, preferably, SDL which may then be compiled to ANSI C. SDL is a language widely used within the telecommunication industry for the representation of layer <highlight><bold>2</bold></highlight> and layer <highlight><bold>3</bold></highlight> stacks, and is particularly well suited to systems that are most economically expressed in a state machine format. SDL traditionally would not be appropriate for use below layer <highlight><bold>2</bold></highlight> (the end of the &lsquo;soft real time&rsquo; domain). The SDL code is entirely portable between various architectures, and may be tested in the normal manner using tools such as TTCN. System constraints (such as dynamic resource ceilings) can be attached to various portions of the code and substrate interconnects in development and then simulated with realistic loading models to allow up-front partitioning of the datapaths into hardware and software. Importantly, the CVM schedule is cognisant of the datapath portioning decisions taken during the design time portion of the development process. The toolflow is fully integrated with Matlab and Simulink, allowing bit-accurate testing of high-MIPs functionality. The use of SDL as the preferred language for the high-level logic flows within layer <highlight><bold>1</bold></highlight> is not accidental&mdash;SDL has been widely used within layers <highlight><bold>2</bold></highlight> and <highlight><bold>3</bold></highlight> of telecommunications stacks such as GSM, but has not crossed the chasm into the hard real time domain. With the CVM, by contrast, it becomes possible to invoke parallel, hard real time execution from SDL control flows, thereby allowing the extremely powerful and natural state machine expressiveness of SDL to be used to author the high level layer <highlight><bold>1</bold></highlight> algorithms. Increasingly, although low MIPs these algorithms are themselves extremely complex, as they must deal with issues such as bursty rate matching, user transport channel birth/death events, handovers between multiple standards, and QoS-bound graceful degradation under load, to name but a few. Other languages not designed for real-time operations (e.g. C&plus;&plus; and Java) can also be used in designing Layer <highlight><bold>1</bold></highlight>, as alternative s to SDL. </paragraph>
<paragraph id="P-0151" lvl="7"><number>&lsqb;0151&rsqb;</number> Theoretical Background to the CVM </paragraph>
<paragraph id="P-0152" lvl="0"><number>&lsqb;0152&rsqb;</number> Current digital communications systems are built around a largely common consensus, which has emerged in the last 15 years or so, about the best way to reliably transmit information wirelessly in the face of quite severe channel effects. Two-way systems have somewhat different channel and modulation requirements from broadcast-oriented systems (for example, using CDMA to provide graceful degradation in the face of a congested spectral band, and having some &lsquo;hard&rsquo; real time requirements), but overall much commonality exists. </paragraph>
<paragraph id="P-0153" lvl="0"><number>&lsqb;0153&rsqb;</number> For example, in the specific case of broadcast (one-way) systems, decoders and encoders may be seen as simply parallel &lsquo;protocol stacks&rsquo;. Most broadcast transmission systems start with source coding (such as MPEG; this compresses the input to reduce bitrate) followed by channel coding (such as convolutional and Reed-Solomon coding; this adds structured redundancy to improve the ability of the receiver to extract information despite signal corruption) followed by modulation (at which point a number of subcarriers are modified in some combination of angle (frequency or phase) or amplitude to hold the information. The reverse process is then carried out in the receiver, yielding (on one level) the diagram of <cross-reference target="DRAWINGS">FIG. 5</cross-reference>. Hence, a set of common processing engines are found within almost all of the key digital broadcast systems, and a common processing structure may also be applied in each case. </paragraph>
<paragraph id="P-0154" lvl="0"><number>&lsqb;0154&rsqb;</number> The CVM embodiment exploits this as follows: the common engines, (or functions or libraries) include algorithms to perform one or more of the following: source coding, channel coding, modulation, or their inverses, namely source decoding, channel decoding and demodulation. They include for example, the fast Fourier transform (FFT), Viterbi decoder (with various constraint lengths, Galois polynomials and puncturing vectors), Reed-Solomon engines, discrete cosine transform (DCT) for the MPEG decoders, time and frequency bitwise reordering for error decoherence, complex vector multiplication and Euler synthesis, etc. A more extensive list is at Appendix 1. These are high MIPS routines and therefore ideally implemented in a CVM in an architecture specific manner (either through assembly code or hardware accelerators). They can, regardless of this, be accessed in the CVM through common, high level APIs. Each of these parameterised transforms has a parallel mathematical modelling block provided for it. </paragraph>
<paragraph id="P-0155" lvl="0"><number>&lsqb;0155&rsqb;</number> The common structure involves splitting the decoding chain up into a symbol processing section (concerned with processing full symbols, regardless of whether all the information held within that symbol is to be used) and data directed processing, in which only those bits which hold relevant information are processed. In each case, it is critical that the processing modules are able to allocate, share and dispose of intermediate, aligned memory buffers, pass events between themselves, and exist within a framework that enables modular development The common structure is paralleled where appropriate in a mathematical modelling environment and described via graph description language (GDL). <cross-reference target="DRAWINGS">FIG. 6</cross-reference> schematically depicts this common block and structure approach used in the CVM. </paragraph>
<paragraph id="P-0156" lvl="0"><number>&lsqb;0156&rsqb;</number> A similar analysis may be provided for 2-way systems, except that there is an additional CCS (calculus of concurrent systems) requirement and resource allocation issue, and the required &lsquo;critical mass&rsquo; of processing engines is slightly different. </paragraph>
<paragraph id="P-0157" lvl="0"><number>&lsqb;0157&rsqb;</number> It is interesting that current generation third party application development tools and hardware deployment platforms (DSPs and DSP cores) do not reflect the structural realities discussed above, and do not (on the whole) provide hardware acceleration tailored towards communications baseband applications nor the 2 phase scheduling approach (see below). Nor do current embedded operating systems support these operations in any systematic or coherent manner. </paragraph>
<paragraph id="P-0158" lvl="0"><number>&lsqb;0158&rsqb;</number> However, the number of digital communications systems is increasing rapidly, creating a demand for rapid time-to-market deployment of baseband stacks. As explained above, a core innovative approach of the present invention is to exploit the underlying commonality and requirements of such systems by providing a software-hosted common &lsquo;virtual machine layer&rsquo; (exemplified by the CVM embodiment) reifying these capabilities and software structure. One key commercial application is as a design solution for hard real time, multi-vendor, multi-protocol environments such as SoC (as noted above). </paragraph>
<paragraph id="P-0159" lvl="7"><number>&lsqb;0159&rsqb;</number> CVM Development Methodologies </paragraph>
<paragraph id="P-0160" lvl="0"><number>&lsqb;0160&rsqb;</number> The development methodology used in the CVM builds upon (and departs from) a methodology using layered development and layered deployment. These concepts will be discussed initially: Layered development refers to a process of progressing from mathematical models, through C&plus;&plus; or SDL code to a target assembler implementation (if necessary). Throughout this process, each of the modules in question is maintained at each of the necessary levels (for example, a convolutional decoder would exist as a parallel mathematical model, C&plus;&plus; implementation, SIMD model and assembler implementations in various target languages). </paragraph>
<paragraph id="P-0161" lvl="0"><number>&lsqb;0161&rsqb;</number> Layered deployment refers to the use of libraries to isolate the code as far as possible from the underlying hardware and host operating system when a receiver stack is actually implemented. Hence as much as possible of the code (high complexity but low MIPs requirement) is kept as generic SDL or ANSI-compliant C&plus;&plus; which is then simply recompiled for the target platform. For example, a library is used to provide platform-dependent functions such as simple I/O, allocation of memory buffers etc. Another library is used to provide high-cycle routines (such as the FFT, Viterbi decoder, etc.) in an architecture specific manner, which may involve the use of highly crafted assembler routines or even callthroughs to specialised hardware acceleration engines. </paragraph>
<paragraph id="P-0162" lvl="2"><number>&lsqb;0162&rsqb;</number> Ability to &lsquo;pare down&rsquo; the ROM image of the CVM at build time to ensure that the minimum ROM (hence, ultimately, chip area) is used. This uses a minimal implementation of the CVM. </paragraph>
<paragraph id="P-0163" lvl="2"><number>&lsqb;0163&rsqb;</number> State machine functionality management (including potential integration with SDL) </paragraph>
<paragraph id="P-0164" lvl="2"><number>&lsqb;0164&rsqb;</number> Support for data structures </paragraph>
<paragraph id="P-0165" lvl="2"><number>&lsqb;0165&rsqb;</number> Transforms between different representations (such as fixed and floating point). </paragraph>
<paragraph id="P-0166" lvl="0"><number>&lsqb;0166&rsqb;</number> The goal of the CVM is to enable the rapid deployment of particular applications onto particular targets, with the multiplicity of applications coming at the development stage. Conventional OSs are designed for run-time support of a variety of apps that are essentially unknown when the OS is loaded, but this is typically not the case with the CVM. Moreover, the CVM does not need to handle interaction with a user, except by supporting presentation streams through portals provided by the &lsquo;host&rsquo; OS. </paragraph>
<paragraph id="P-0167" lvl="0"><number>&lsqb;0167&rsqb;</number> The CVM incorporates a number of the features that are currently in the high-level C&plus;&plus; code of a DAB stack into the infrastructure level (such as the appropriate modular structure for the development of symbol-directed and data-directed processing), and is not simply a &lsquo;library wrapper&rsquo;. </paragraph>
<paragraph id="P-0168" lvl="0"><number>&lsqb;0168&rsqb;</number> The CVM concept rests upon the idea (critically dependent upon domain knowledge that can only be achieved through review of the various standards and the process of actually building the stacks) that abstracting the common functions and (importantly) processing structures required by modern digital broadcast and communications standards is possible and can be achieved elegantly through an appropriate software abstraction layer coupled with a systematic layered development environment. </paragraph>
<paragraph id="P-0169" lvl="7"><number>&lsqb;0169&rsqb;</number> CVM Advantages </paragraph>
<paragraph id="P-0170" lvl="0"><number>&lsqb;0170&rsqb;</number> With the CVM, stack developers are isolated from the particular hardware in use. The CVM provides support for the structures (e.g., symbol and data-directed pipelines, and state machines), functions (e.g., memory allocation and real time resource and concurrency management) and libraries (e.g., for FFT, Viterbi, convolution, etc.) required by digital communication baseband stacks to enable code to be written once, in a high-level language (SDL, ANSI C/C&plus;&plus; or Java) and merely recompiled (if necessary, with Java it would not be, and COM or some other form of component intercommunication technology can provide the &lsquo;binary level&rsquo; glue to link the modules together) to run on a particular platform, making calls through to the hardware abstraction layer provided by the CVM layer. </paragraph>
<paragraph id="P-0171" lvl="0"><number>&lsqb;0171&rsqb;</number> Prototyping using the CVM will be very rapid, with each of the DSP modules paralleled by a mathematical model. Memory allocation and partitioning will be supported by an automated toolset (parameterised by the desired target hardware) rather than relying on guesswork. Once the processing chain is established on the model (which will optionally be performed by graphical arrangement and parameterisation rather than coding) and is working successfully, it will be possible to run a real-time PC-based version (using the Intel MMX/SIMD version of the CVM, together with RadioScape&apos;s generic baseband processor module). Any changes to the standard code (e.g. a custom equaliser) may then be integrated in a modular, incremental fashion and the code-test-edit cycle (being PC based) could use all the latest PC development tools, and be very rapid. Use of hardware acceleration on the target platform will be covered by the CVM (since all of the required cycle-intensive features for digital communications baseband processing will be provided as library calls at the CVM API). Clearly, the use of an appropriately adapted underlying hardware unit, would provide targeted acceleration for most of the desired functions. For many applications, the support of lightweight pre-emptive multithreading and other low-level functions on the CVM itself will obviate the need to use any other RTOS, but interaction with a user-OS (such as Windows CE or Symbian&apos;s EPOC) will be supported and straightforward through the APIs discussed above. </paragraph>
<paragraph id="P-0172" lvl="0"><number>&lsqb;0172&rsqb;</number> With this approach, a CVM-compatible stack, once written, would be portable instantly to any of the hardware platforms onto which the CVM itself had been ported, (always providing, of course, that there were sufficient resources (MIPs, memory, bandwidth) on the target machine to execute the desired stack in real time) without involving extra work. This would represent a substantial market opportunity (assuming reasonable cross-platform penetration of the CVM) for stack vendors, as it will essentially insulate their developments from hardware specificity. There is also a particularly significant commercial opportunity for designing multi-vendor SoC products (see above). </paragraph>
<paragraph id="P-0173" lvl="0"><number>&lsqb;0173&rsqb;</number> From the hardware vendor&apos;s point of view, the advantage of the CVM is that once it is ported for a given processor, that processor would automatically support (resources permitting) all stacks that had been written to the CVM API. This, of course, obviates the need for the hardware provider to get into the applications business; they need only port the CVM. It also means that the need to produce and support a full-specification development environment and toolset is reduced, since stack vendors (for the digital communications market at least) would then be able to develop code purely in ANSI C/C&plus;&plus; or Java. It should be noted that the CVM concept does not apply to all digital signal processing tasks, for example, making a PID controller for use in a car braking system. The reason that the CVM concept works for digital communication baseband processing is that, as explained above, there is a large pool of commonality in such systems that can be exploited; however, the CVM does not provide all the tools, structures or functions that would be required for other digital signal processing tasks, necessarily. Of course, it would potentially be possible to identify other such &lsquo;islands&rsquo; of common function and extend the CVM idiom to cover their needs, but we are focussed here on the baseband aspects because they are highly in demand, and strongly exhibit the necessary commonality. The CVM approach leaves the hardware vendor free to compete not on the existing application set, but rather on the virtues of their hardware (e.g., MIPs, targeted acceleration, memory, power consumption). </paragraph>
<paragraph id="P-0174" lvl="7"><number>&lsqb;0174&rsqb;</number> The CVM Development Cycle </paragraph>
<paragraph id="P-0175" lvl="0"><number>&lsqb;0175&rsqb;</number> The process of actually using the CVM to develop a baseband stack will now be described. For the purposes of this specification, a device is the target being developed, such as a digital radio. A component is an identifiable specific part of it: either software, hardware, or both. &lsquo;Interpreted&rsquo; means code (possibly compiled) which reads in configurations at run time. </paragraph>
<paragraph id="P-0176" lvl="0"><number>&lsqb;0176&rsqb;</number> The CVM Development Cycle begins with the &lsquo;Component Definition Language&rsquo;. This language enables the full externally visible attributes of a component to be specified, as well as its behaviour. The intention is that this can be written by a manufacturer or (as will be seen later) could be generated by test runs of an instrumented CVM. </paragraph>
<paragraph id="P-0177" lvl="0"><number>&lsqb;0177&rsqb;</number> Via a set of plug-ins the Component Definition Language can be read in to a mathematical modelling tool, such as the industry popular MatLab or Mathematica. Using the modelling tool, the theoretical behaviour of all components to be used in the device would be explored and understood. </paragraph>
<paragraph id="P-0178" lvl="0"><number>&lsqb;0178&rsqb;</number> The results of this investigation would then be either transcribed, or output via another plug in to be developed, into &lsquo;Device Definition Language&rsquo;. Just as Component Definition Language defines a component, this defines the target device being built, and will contain such elements as which components are used. </paragraph>
<paragraph id="P-0179" lvl="0"><number>&lsqb;0179&rsqb;</number> In effect, the Device Definition Language defines the communications &lsquo;Pipeline&rsquo; that is being developed. The Pipeline concept is important since most communications devices can be thought of as the process of moving information through a pipeline, performing transforms on the way. It is in effect an electronic assembly line, but rather than operate on parts of a car, it operates on items of data commonly called &lsquo;symbols&rsquo;. Thus a radio signal would eventually be transformed to an audio signal. Of course, &lsquo;real&rsquo; devices are often more complicated than a simple pipeline, and may have more than one pipeline, branches, or loops. The CVM development process allows a pipeline design to be tested before a full hardware version is ever built. This leads to shorter development times. </paragraph>
<paragraph id="P-0180" lvl="0"><number>&lsqb;0180&rsqb;</number> To fully define a target device, or pipeline, more information is needed. We also need a description of the resources (such as CPU rate) available on our target, and this is defined in a &lsquo;Conformance Scripting Language&rsquo; and interconnects. We also need to know how each component is used (both physical and software APIs); this is achieved using &lsquo;Component API Specifications&rsquo;. </paragraph>
<paragraph id="P-0181" lvl="0"><number>&lsqb;0181&rsqb;</number> These three resources: the Device Definition Language, the Conformance Scripting Language, and the Component API Specifications, are now used within one of several possible CVMs: The first is the &lsquo;Instrumented Interpreted&rsquo; (or, preferably, Instrumented and Compiled, which will perform more rapidly than an Instrumented Interpreted version) Pipeline Manager. This has some similarity to a software ICE. It reads the three resources and then emulates the pipeline (emulation may be in real time): so if the target is a radio it then runs as a radio. Because of the Conformance Scripting Language it is able to simulate any bottlenecks or resource limitations that would exist on the target device and is useful for development and de-bugging. In addition to running, the Instrumented Interpreted/ or Instrumented Compiled Pipeline Manager also outputs diagnostic information for each device&mdash;in Component Definition Language. This is important, since it can now be fed back into the development cycle and merged with the original Component Definition Language descriptions to refine that description. Hence, information on actual performance is made available to the designer before any hardware is constructed, and this is where the (substantial) development savings are made. This closes the inner loop of the development cycle. The Instrumented Interpreted or Instrumented Compiled Pipeline Manager incorporates run-time versions of the CVM core. It is possible for software elements of the Instrumented Interpreted or Instrumented Compiled Pipeline Manager to be replaced by hardware versions. (Ideally one at a time, so that bugs can be detected as they are introduced.) This is another development process enhancement This corresponds to the 2 Phase Scheduling process (see above) involving the design time portioning of engines across the computational substrate. </paragraph>
<paragraph id="P-0182" lvl="0"><number>&lsqb;0182&rsqb;</number> The second CVM is an &lsquo;Interpreted Pipeline Manager&rsquo;. It is not instrumented, but in other regards is identical. It may be used in development and debugging and by a manufacturer to produce a complete product. This is the third benefit: much of the work in writing a communications device is already done. It also incorporates run-time versions of the CVM core. </paragraph>
<paragraph id="P-0183" lvl="0"><number>&lsqb;0183&rsqb;</number> The third CVM is a &lsquo;Pipeline Builder&rsquo;. It can be thought of as a Compiled Non-Instrumented variant. Like the other two it reads the three resources, but instead of running it outputs computer source code, such as C, which can be compiled to produce a Pipeline implementation. For this reason it must have available to it CVM libraries. Testing this closes the outer loop of the development cycle. The overall approach of the CVM development cycle is shown schematically at <cross-reference target="DRAWINGS">FIGS. 8 and 9</cross-reference>. </paragraph>
<paragraph id="P-0184" lvl="0"><number>&lsqb;0184&rsqb;</number> In the prior art section of this specification, we acknowledged the eXpressDSP Real-Time Software Technology from Texas Instruments Incorporated. The key advances possessed by the CVM will now be apparent to the skilled implementer. They include the following: </paragraph>
<paragraph id="P-0185" lvl="2"><number>&lsqb;0185&rsqb;</number> EXpressDSP is not a virtual machine layer as such. </paragraph>
<paragraph id="P-0186" lvl="2"><number>&lsqb;0186&rsqb;</number> CVM allows portability between various DSP platforms simply by porting the virtual machine; it is not tied to one platform (as the TI system is) </paragraph>
<paragraph id="P-0187" lvl="2"><number>&lsqb;0187&rsqb;</number> CVM includes integration with mathematical modelling </paragraph>
<paragraph id="P-0188" lvl="2"><number>&lsqb;0188&rsqb;</number> CVM allows the development of stacks using PC-based tools, not the less capable DSP-based tools </paragraph>
<paragraph id="P-0189" lvl="2"><number>&lsqb;0189&rsqb;</number> CVM includes the ability to &lsquo;real time&rsquo; prototype on the PC, moving module-by-module onto the target environment </paragraph>
<paragraph id="P-0190" lvl="2"><number>&lsqb;0190&rsqb;</number> CVM includes the ability to generate resource timings by running a standard code set, and then generate an &lsquo;architecture description&rsquo; profile from this </paragraph>
<paragraph id="P-0191" lvl="2"><number>&lsqb;0191&rsqb;</number> CVM allows development using high-level languages, since most of the &lsquo;high cycle&rsquo; routines are already &lsquo;in the environment&rsquo; of the CVM, which is oriented towards the signal processing requirements of baseband communication engines rather than a generic &lsquo;real time software foundation&rsquo;</paragraph>
<paragraph id="P-0192" lvl="2"><number>&lsqb;0192&rsqb;</number> CVM also includes the sort of data, dynamic resource, and buffer management commonly required for baseband DSP </paragraph>
<paragraph id="P-0193" lvl="2"><number>&lsqb;0193&rsqb;</number> CVM gives provision for a-priori resource prediction and concurrency analysis </paragraph>
<paragraph id="P-0194" lvl="2"><number>&lsqb;0194&rsqb;</number> CVM includes not merely functional elements (an API) but also the call structure (how the DSP code functions dynamically) as well as the full development paradigm support (from mathematical modelling, resource modelling, through PC-based prototyping and finally end-target deployment) </paragraph>
<paragraph id="P-0195" lvl="2"><number>&lsqb;0195&rsqb;</number> CVM allows the use of a third-party RTOS if desired, and can also operate without an RTOS if desired. </paragraph>
<paragraph id="P-0196" lvl="2"><number>&lsqb;0196&rsqb;</number> CVM offers 2 Phase scheduling </paragraph>
<paragraph id="P-0197" lvl="2"><number>&lsqb;0197&rsqb;</number> CVM enables advantages in migrating to ASICs and SoCs </paragraph>
<paragraph id="P-0198" lvl="2"><number>&lsqb;0198&rsqb;</number> CVM offers runtime and design tools which are fully integrated yet platform independent. </paragraph>
</section>
<section>
<heading lvl="1">Appendix 1 </heading>
<paragraph id="P-0199" lvl="7"><number>&lsqb;0199&rsqb;</number> Examples of Core Processes </paragraph>
<paragraph id="P-0200" lvl="7"><number>&lsqb;0200&rsqb;</number> Signal Transforms and Frequency Domain Analysis </paragraph>
<paragraph id="P-0201" lvl="2"><number>&lsqb;0201&rsqb;</number> Signal Flow Graphs (SFG) </paragraph>
<paragraph id="P-0202" lvl="2"><number>&lsqb;0202&rsqb;</number> Discrete Frequency DFT </paragraph>
<paragraph id="P-0203" lvl="2"><number>&lsqb;0203&rsqb;</number> Windowing (Hamming, Hanning etc.) </paragraph>
<paragraph id="P-0204" lvl="7"><number>&lsqb;0204&rsqb;</number> Digital Filtering </paragraph>
<paragraph id="P-0205" lvl="2"><number>&lsqb;0205&rsqb;</number> Digital FIR Filters </paragraph>
<paragraph id="P-0206" lvl="2"><number>&lsqb;0206&rsqb;</number> Impulse Response </paragraph>
<paragraph id="P-0207" lvl="2"><number>&lsqb;0207&rsqb;</number> Frequency Response </paragraph>
<paragraph id="P-0208" lvl="2"><number>&lsqb;0208&rsqb;</number> FIR Low Pass Digital Filter </paragraph>
<paragraph id="P-0209" lvl="2"><number>&lsqb;0209&rsqb;</number> Infinite Impulse Response Digital Filters </paragraph>
<paragraph id="P-0210" lvl="7"><number>&lsqb;0210&rsqb;</number> Adaptive Signal Processing </paragraph>
<paragraph id="P-0211" lvl="2"><number>&lsqb;0211&rsqb;</number> Components for Adaptive Signal Processing including Adaptive Digital Filters </paragraph>
<paragraph id="P-0212" lvl="3"><number>&lsqb;0212&rsqb;</number> Channel Identification </paragraph>
<paragraph id="P-0213" lvl="3"><number>&lsqb;0213&rsqb;</number> Echo Cancellation </paragraph>
<paragraph id="P-0214" lvl="3"><number>&lsqb;0214&rsqb;</number> Acoustic Echo Cancellation </paragraph>
<paragraph id="P-0215" lvl="3"><number>&lsqb;0215&rsqb;</number> Background Noise Suppression </paragraph>
<paragraph id="P-0216" lvl="3"><number>&lsqb;0216&rsqb;</number> Channel Equalisation </paragraph>
<paragraph id="P-0217" lvl="3"><number>&lsqb;0217&rsqb;</number> Adaptive Line Enhancement (ALE) </paragraph>
<paragraph id="P-0218" lvl="2"><number>&lsqb;0218&rsqb;</number> Adaptive Algorithms, including: </paragraph>
<paragraph id="P-0219" lvl="3"><number>&lsqb;0219&rsqb;</number> Minimising the Mean Squared Error </paragraph>
<paragraph id="P-0220" lvl="3"><number>&lsqb;0220&rsqb;</number> Adaptive Algorithm for FIR Filter </paragraph>
<paragraph id="P-0221" lvl="3"><number>&lsqb;0221&rsqb;</number> Mean Squared Error </paragraph>
<paragraph id="P-0222" lvl="3"><number>&lsqb;0222&rsqb;</number> Minimum Mean Squared Error Solution </paragraph>
<paragraph id="P-0223" lvl="3"><number>&lsqb;0223&rsqb;</number> Wiener-Hopf Solution </paragraph>
<paragraph id="P-0224" lvl="3"><number>&lsqb;0224&rsqb;</number> Gradient Techniques <highlight><bold>1</bold></highlight> </paragraph>
<paragraph id="P-0225" lvl="3"><number>&lsqb;0225&rsqb;</number> Gradient Techniques <highlight><bold>2</bold></highlight> </paragraph>
<paragraph id="P-0226" lvl="3"><number>&lsqb;0226&rsqb;</number> The LMS Algorithm </paragraph>
<paragraph id="P-0227" lvl="2"><number>&lsqb;0227&rsqb;</number> Recursive Least Squares </paragraph>
<paragraph id="P-0228" lvl="2"><number>&lsqb;0228&rsqb;</number> Adaptive IIR Filtering </paragraph>
<paragraph id="P-0229" lvl="2"><number>&lsqb;0229&rsqb;</number> Gradient IIR Filtering Techniques </paragraph>
<paragraph id="P-0230" lvl="2"><number>&lsqb;0230&rsqb;</number> Feintuch&apos;s IIR LMS </paragraph>
<paragraph id="P-0231" lvl="2"><number>&lsqb;0231&rsqb;</number> Equation Frror LMS Algonthm </paragraph>
<paragraph id="P-0232" lvl="2"><number>&lsqb;0232&rsqb;</number> Directed Mode (DDM) </paragraph>
<paragraph id="P-0233" lvl="2"><number>&lsqb;0233&rsqb;</number> Subband Adaptive Filter (SAF) Structure </paragraph>
<paragraph id="P-0234" lvl="7"><number>&lsqb;0234&rsqb;</number> Multirate Signal Processing </paragraph>
<paragraph id="P-0235" lvl="2"><number>&lsqb;0235&rsqb;</number> Upsampling &amp; Downsampling </paragraph>
<paragraph id="P-0236" lvl="2"><number>&lsqb;0236&rsqb;</number> Interpolating Low Pass Filter </paragraph>
<paragraph id="P-0237" lvl="2"><number>&lsqb;0237&rsqb;</number> Oversampling and Reconstrunction </paragraph>
<paragraph id="P-0238" lvl="2"><number>&lsqb;0238&rsqb;</number> Sigma-Delta Processing Architecture </paragraph>
<paragraph id="P-0239" lvl="2"><number>&lsqb;0239&rsqb;</number> Subband Processing </paragraph>
<paragraph id="P-0240" lvl="2"><number>&lsqb;0240&rsqb;</number> M-Channel Filter Banks by Iteration </paragraph>
<paragraph id="P-0241" lvl="2"><number>&lsqb;0241&rsqb;</number> Modulated Filter Banks </paragraph>
<paragraph id="P-0242" lvl="2"><number>&lsqb;0242&rsqb;</number> Polyphase Filter Banks </paragraph>
<paragraph id="P-0243" lvl="2"><number>&lsqb;0243&rsqb;</number> QMF Filter Banks </paragraph>
<paragraph id="P-0244" lvl="7"><number>&lsqb;0244&rsqb;</number> Audio Signal Source Coding </paragraph>
<paragraph id="P-0245" lvl="2"><number>&lsqb;0245&rsqb;</number> Lossless Huffman Coding/Decoding </paragraph>
<paragraph id="P-0246" lvl="2"><number>&lsqb;0246&rsqb;</number> Linear PCM </paragraph>
<paragraph id="P-0247" lvl="2"><number>&lsqb;0247&rsqb;</number> Companding </paragraph>
<paragraph id="P-0248" lvl="2"><number>&lsqb;0248&rsqb;</number> Adaptive Quantization Tools </paragraph>
<paragraph id="P-0249" lvl="2"><number>&lsqb;0249&rsqb;</number> Linear Predictive Coding </paragraph>
<paragraph id="P-0250" lvl="2"><number>&lsqb;0250&rsqb;</number> Long-Term Prediction </paragraph>
<paragraph id="P-0251" lvl="2"><number>&lsqb;0251&rsqb;</number> Delta Modulation (DM) </paragraph>
<paragraph id="P-0252" lvl="2"><number>&lsqb;0252&rsqb;</number> Differential PCM (DPCM) </paragraph>
<paragraph id="P-0253" lvl="2"><number>&lsqb;0253&rsqb;</number> Adaptive DPCM (ADPCM) </paragraph>
<paragraph id="P-0254" lvl="2"><number>&lsqb;0254&rsqb;</number> LPC Vocoder </paragraph>
<paragraph id="P-0255" lvl="2"><number>&lsqb;0255&rsqb;</number> Code-Excited Linear Prediction (CELP) </paragraph>
<paragraph id="P-0256" lvl="2"><number>&lsqb;0256&rsqb;</number> Algebraic CELP (ACELP) </paragraph>
<paragraph id="P-0257" lvl="2"><number>&lsqb;0257&rsqb;</number> Subband Coding </paragraph>
<paragraph id="P-0258" lvl="2"><number>&lsqb;0258&rsqb;</number> Tools for Psychoacoustics </paragraph>
<paragraph id="P-0259" lvl="2"><number>&lsqb;0259&rsqb;</number> Spectral Masking </paragraph>
<paragraph id="P-0260" lvl="2"><number>&lsqb;0260&rsqb;</number> Temporal Masking </paragraph>
<paragraph id="P-0261" lvl="2"><number>&lsqb;0261&rsqb;</number> Precision Adaptive Subband Coding and bit Allocation and bit Stream Formatting tools </paragraph>
<paragraph id="P-0262" lvl="7"><number>&lsqb;0262&rsqb;</number> Digital Modulation </paragraph>
<paragraph id="P-0263" lvl="2"><number>&lsqb;0263&rsqb;</number> XOR long an short code spreading/despreading </paragraph>
<paragraph id="P-0264" lvl="2"><number>&lsqb;0264&rsqb;</number> Amplitude Modulation </paragraph>
<paragraph id="P-0265" lvl="2"><number>&lsqb;0265&rsqb;</number> Quadrature Amplitude Modulation (QAM) </paragraph>
<paragraph id="P-0266" lvl="2"><number>&lsqb;0266&rsqb;</number> Quadrature Demodulation </paragraph>
<paragraph id="P-0267" lvl="2"><number>&lsqb;0267&rsqb;</number> Complex Quadrature Modulation </paragraph>
<paragraph id="P-0268" lvl="2"><number>&lsqb;0268&rsqb;</number> Complex Quadrature Demodulation </paragraph>
<paragraph id="P-0269" lvl="2"><number>&lsqb;0269&rsqb;</number> QPSK </paragraph>
<paragraph id="P-0270" lvl="2"><number>&lsqb;0270&rsqb;</number> n-PSK </paragraph>
<paragraph id="P-0271" lvl="2"><number>&lsqb;0271&rsqb;</number> M-ary Amplitude Shift Keying </paragraph>
<paragraph id="P-0272" lvl="2"><number>&lsqb;0272&rsqb;</number> &pgr;/n QPSK </paragraph>
<paragraph id="P-0273" lvl="2"><number>&lsqb;0273&rsqb;</number> Unipolar RZ and NRZ Signalling </paragraph>
<paragraph id="P-0274" lvl="2"><number>&lsqb;0274&rsqb;</number> Polar and Bipolar RZ and NRZ Signalling </paragraph>
<paragraph id="P-0275" lvl="2"><number>&lsqb;0275&rsqb;</number> Bandpass Shift Keying, including </paragraph>
<paragraph id="P-0276" lvl="3"><number>&lsqb;0276&rsqb;</number> Amplitude (On-Off) Shift Keying </paragraph>
<paragraph id="P-0277" lvl="3"><number>&lsqb;0277&rsqb;</number> Binary Phase Shift Keying (BPSK) </paragraph>
<paragraph id="P-0278" lvl="3"><number>&lsqb;0278&rsqb;</number> Frequency Shift Keying including </paragraph>
<paragraph id="P-0279" lvl="3"><number>&lsqb;0279&rsqb;</number> Bandpass Filtering for BPSK </paragraph>
<paragraph id="P-0280" lvl="3"><number>&lsqb;0280&rsqb;</number> Pulse Shaping including </paragraph>
<paragraph id="P-0281" lvl="3"><number>&lsqb;0281&rsqb;</number> Nyquist (Sinc) Pulse Shaping </paragraph>
<paragraph id="P-0282" lvl="3"><number>&lsqb;0282&rsqb;</number> Raised Cosine Pulse Shaping </paragraph>
<paragraph id="P-0283" lvl="3"><number>&lsqb;0283&rsqb;</number> Root Raised Cosine Pulse Shaping </paragraph>
<paragraph id="P-0284" lvl="7"><number>&lsqb;0284&rsqb;</number> Spread Spectrum Tools </paragraph>
<paragraph id="P-0285" lvl="2"><number>&lsqb;0285&rsqb;</number> Pseudo Random Code Generation </paragraph>
<paragraph id="P-0286" lvl="2"><number>&lsqb;0286&rsqb;</number> Gold Sequences </paragraph>
<paragraph id="P-0287" lvl="2"><number>&lsqb;0287&rsqb;</number> Kasami Sequences </paragraph>
<paragraph id="P-0288" lvl="2"><number>&lsqb;0288&rsqb;</number> Orthogonal Spreading Codes </paragraph>
<paragraph id="P-0289" lvl="2"><number>&lsqb;0289&rsqb;</number> Variable Length OC Generation </paragraph>
<paragraph id="P-0290" lvl="2"><number>&lsqb;0290&rsqb;</number> Orthogonal Walsh codes </paragraph>
<paragraph id="P-0291" lvl="2"><number>&lsqb;0291&rsqb;</number> Code Detection </paragraph>
<paragraph id="P-0292" lvl="2"><number>&lsqb;0292&rsqb;</number> Rake Receiver implementing </paragraph>
<paragraph id="P-0293" lvl="2"><number>&lsqb;0293&rsqb;</number> NBI Rejection Techniques including </paragraph>
<paragraph id="P-0294" lvl="3"><number>&lsqb;0294&rsqb;</number> Prediction filters </paragraph>
<paragraph id="P-0295" lvl="3"><number>&lsqb;0295&rsqb;</number> NBI rejection in Transform Domain </paragraph>
<paragraph id="P-0296" lvl="3"><number>&lsqb;0296&rsqb;</number> Decision feedback NBI rejection </paragraph>
<paragraph id="P-0297" lvl="7"><number>&lsqb;0297&rsqb;</number> Tools for Management of Multiple Access &amp; Detection </paragraph>
<paragraph id="P-0298" lvl="2"><number>&lsqb;0298&rsqb;</number> TDMA including </paragraph>
<paragraph id="P-0299" lvl="3"><number>&lsqb;0299&rsqb;</number> TDMA Frames </paragraph>
<paragraph id="P-0300" lvl="3"><number>&lsqb;0300&rsqb;</number> TDMA combined with FDMA </paragraph>
<paragraph id="P-0301" lvl="2"><number>&lsqb;0301&rsqb;</number> CDMA including </paragraph>
<paragraph id="P-0302" lvl="3"><number>&lsqb;0302&rsqb;</number> Direct Sequence (DS) CDMA </paragraph>
<paragraph id="P-0303" lvl="2"><number>&lsqb;0303&rsqb;</number> Power Control </paragraph>
<paragraph id="P-0304" lvl="2"><number>&lsqb;0304&rsqb;</number> Beamforming Tools </paragraph>
<paragraph id="P-0305" lvl="2"><number>&lsqb;0305&rsqb;</number> Frequency Hopping CDMA </paragraph>
<paragraph id="P-0306" lvl="2"><number>&lsqb;0306&rsqb;</number> Multiuser Detection (MUD) </paragraph>
<paragraph id="P-0307" lvl="2"><number>&lsqb;0307&rsqb;</number> Multiple Access Interference Suppression </paragraph>
<paragraph id="P-0308" lvl="2"><number>&lsqb;0308&rsqb;</number> Decorrelator </paragraph>
<paragraph id="P-0309" lvl="2"><number>&lsqb;0309&rsqb;</number> Interference canceller </paragraph>
<paragraph id="P-0310" lvl="2"><number>&lsqb;0310&rsqb;</number> Adaptive MMSE </paragraph>
<paragraph id="P-0311" lvl="2"><number>&lsqb;0311&rsqb;</number> MMSE receiver training </paragraph>
<paragraph id="P-0312" lvl="2"><number>&lsqb;0312&rsqb;</number> Adaptive MMSE receiver DDM </paragraph>
<paragraph id="P-0313" lvl="7"><number>&lsqb;0313&rsqb;</number> Mobile Channels </paragraph>
<paragraph id="P-0314" lvl="2"><number>&lsqb;0314&rsqb;</number> Rayleigh Fading Suppression mechanisms (Gaussian, Riceian) </paragraph>
<paragraph id="P-0315" lvl="2"><number>&lsqb;0315&rsqb;</number> Modelling and suppression tools, including: </paragraph>
<paragraph id="P-0316" lvl="3"><number>&lsqb;0316&rsqb;</number> Time spreading </paragraph>
<paragraph id="P-0317" lvl="3"><number>&lsqb;0317&rsqb;</number> Time spreading: coherence bandwidth </paragraph>
<paragraph id="P-0318" lvl="3"><number>&lsqb;0318&rsqb;</number> Time spreading: flat fading </paragraph>
<paragraph id="P-0319" lvl="3"><number>&lsqb;0319&rsqb;</number> Time spreading: Freq selective fading </paragraph>
<paragraph id="P-0320" lvl="3"><number>&lsqb;0320&rsqb;</number> Time variant behaviour of the channel </paragraph>
<paragraph id="P-0321" lvl="3"><number>&lsqb;0321&rsqb;</number> Doppler effect </paragraph>
<paragraph id="P-0322" lvl="7"><number>&lsqb;0322&rsqb;</number> Channel Coding </paragraph>
<paragraph id="P-0323" lvl="2"><number>&lsqb;0323&rsqb;</number> Cyclic Coder </paragraph>
<paragraph id="P-0324" lvl="2"><number>&lsqb;0324&rsqb;</number> Reed Solomon Encoder </paragraph>
<paragraph id="P-0325" lvl="2"><number>&lsqb;0325&rsqb;</number> Convolutional Encoder </paragraph>
<paragraph id="P-0326" lvl="2"><number>&lsqb;0326&rsqb;</number> CE Puncturing </paragraph>
<paragraph id="P-0327" lvl="2"><number>&lsqb;0327&rsqb;</number> Interleaving </paragraph>
<paragraph id="P-0328" lvl="2"><number>&lsqb;0328&rsqb;</number> Convolutional Decoder </paragraph>
<paragraph id="P-0329" lvl="2"><number>&lsqb;0329&rsqb;</number> Viterbi Decoder (Hard and soft decision) </paragraph>
<paragraph id="P-0330" lvl="2"><number>&lsqb;0330&rsqb;</number> Turbo Codes </paragraph>
<paragraph id="P-0331" lvl="2"><number>&lsqb;0331&rsqb;</number> Turbo EnCoding </paragraph>
<paragraph id="P-0332" lvl="2"><number>&lsqb;0332&rsqb;</number> Turbo DeCoding </paragraph>
<paragraph id="P-0333" lvl="7"><number>&lsqb;0333&rsqb;</number> Equalisation </paragraph>
<paragraph id="P-0334" lvl="2"><number>&lsqb;0334&rsqb;</number> Adaptive Channel Equalisation </paragraph>
<paragraph id="P-0335" lvl="2"><number>&lsqb;0335&rsqb;</number> FIR Equaliser </paragraph>
<paragraph id="P-0336" lvl="2"><number>&lsqb;0336&rsqb;</number> Decision Feedback Equaliser </paragraph>
<paragraph id="P-0337" lvl="2"><number>&lsqb;0337&rsqb;</number> Direct conversion toolkit </paragraph>
<paragraph id="P-0338" lvl="2"><number>&lsqb;0338&rsqb;</number> QAM Analog RF/IF Architecture </paragraph>
<paragraph id="P-0339" lvl="2"><number>&lsqb;0339&rsqb;</number> QAM IF Downconversion support </paragraph>
<paragraph id="P-0340" lvl="2"><number>&lsqb;0340&rsqb;</number> Bandpass Sigma Delta support </paragraph>
<paragraph id="P-0341" lvl="2"><number>&lsqb;0341&rsqb;</number> Bandpass Sigma Delta to Baseband support </paragraph>
<paragraph id="P-0342" lvl="2"><number>&lsqb;0342&rsqb;</number> Bandpass and fs/4 Systems </paragraph>
<paragraph id="P-0343" lvl="7"><number>&lsqb;0343&rsqb;</number> Signal Processing Library Functions </paragraph>
<paragraph id="P-0344" lvl="0"><number>&lsqb;0344&rsqb;</number> This section describes some of the signal processing functions available with the CVM </paragraph>
<paragraph id="P-0345" lvl="7"><number>&lsqb;0345&rsqb;</number> Vector Manipulation Functions </paragraph>
<paragraph id="P-0346" lvl="2"><number>&lsqb;0346&rsqb;</number> AutoCorrelate Estimates a normal, biased or unbiased auto-correlation of an input vector and stores the result in a second vector </paragraph>
<paragraph id="P-0347" lvl="2"><number>&lsqb;0347&rsqb;</number> Conjugate (vector) Computes the complex conjugate of a vector, the result can be returned in place or in a second vector. </paragraph>
<paragraph id="P-0348" lvl="2"><number>&lsqb;0348&rsqb;</number> Conjugate (value) Returns the conjugate of a complex value. </paragraph>
<paragraph id="P-0349" lvl="2"><number>&lsqb;0349&rsqb;</number> ExtendedConjugate Computes the conjugate-sytnmetric extension of a vector in-place or in a new vector. </paragraph>
<paragraph id="P-0350" lvl="2"><number>&lsqb;0350&rsqb;</number> Exp Computes a vector where each element is e to the power of the corresponding element in the input vector. The result can be returned in place or in a second vector. </paragraph>
<paragraph id="P-0351" lvl="2"><number>&lsqb;0351&rsqb;</number> InverseThreshold Computes the inverse of the elements of a vector, with a threshold value. The result can be returned in place or in a second vector. </paragraph>
<paragraph id="P-0352" lvl="2"><number>&lsqb;0352&rsqb;</number> Threshold Performs the threshold operation on a vector. The result can be returned in place or in a second vector. </paragraph>
<paragraph id="P-0353" lvl="2"><number>&lsqb;0353&rsqb;</number> CrossCorrelate Estimates the cross-correlation of two vectors and stores the result in a third vector. </paragraph>
<paragraph id="P-0354" lvl="2"><number>&lsqb;0354&rsqb;</number> DotProduct Computes a dot product of two vectors after applying the ExtendedConjucate operation to them. </paragraph>
<paragraph id="P-0355" lvl="2"><number>&lsqb;0355&rsqb;</number> ExtendedDotProd Computes a dot product of two conjugate-symmetric extended vectors. </paragraph>
<paragraph id="P-0356" lvl="2"><number>&lsqb;0356&rsqb;</number> DownSample Down-samples a signal, conceptually decreasing its sampling rate by an integer factor. Returns the result in a second vector. </paragraph>
<paragraph id="P-0357" lvl="2"><number>&lsqb;0357&rsqb;</number> Max, Returns the maximum value in a vector. </paragraph>
<paragraph id="P-0358" lvl="2"><number>&lsqb;0358&rsqb;</number> Mean Computes the mean (average) of the elements in a vector. </paragraph>
<paragraph id="P-0359" lvl="2"><number>&lsqb;0359&rsqb;</number> Min Returns the minimum value in a vector. </paragraph>
<paragraph id="P-0360" lvl="2"><number>&lsqb;0360&rsqb;</number> UpSample Up-samples a signal, conceptually increasing its sampling rate by an integer factor. Returns the result in a second vector. </paragraph>
<paragraph id="P-0361" lvl="2"><number>&lsqb;0361&rsqb;</number> PowerSpectrum (<highlight><bold>1</bold></highlight>) Returns the power spectrum of a complex vector in a second vector. </paragraph>
<paragraph id="P-0362" lvl="2"><number>&lsqb;0362&rsqb;</number> PowerSpectrum (<highlight><bold>2</bold></highlight>) Computes the power spectrum of a complex vector whose real and imaginary components are two vectors. Stores the results in a third vector. </paragraph>
<paragraph id="P-0363" lvl="2"><number>&lsqb;0363&rsqb;</number> Add Adds two vectors and stores the result in a third. </paragraph>
<paragraph id="P-0364" lvl="2"><number>&lsqb;0364&rsqb;</number> Subtract Subtracts one vector from another and stores the result in a third. </paragraph>
<paragraph id="P-0365" lvl="2"><number>&lsqb;0365&rsqb;</number> Multiply Multiplies two vectors and stores the result in a third. </paragraph>
<paragraph id="P-0366" lvl="2"><number>&lsqb;0366&rsqb;</number> Divide Divides one vector by another and stores the result in a third. </paragraph>
<paragraph id="P-0367" lvl="7"><number>&lsqb;0367&rsqb;</number> Complex Vector Operations </paragraph>
<paragraph id="P-0368" lvl="2"><number>&lsqb;0368&rsqb;</number> ImaginaryPart Returns the imaginary part of a complex vector in a second vector. </paragraph>
<paragraph id="P-0369" lvl="2"><number>&lsqb;0369&rsqb;</number> RealPart Returns the real part of a complex vector in a second vector. </paragraph>
<paragraph id="P-0370" lvl="2"><number>&lsqb;0370&rsqb;</number> Magnitude (<highlight><bold>1</bold></highlight>) Computes the magnitudes of elements of a complex vector and stores the result in a second vector. </paragraph>
<paragraph id="P-0371" lvl="2"><number>&lsqb;0371&rsqb;</number> Magnitude (<highlight><bold>2</bold></highlight>) This second version calculates the magnitudes of elements of the complex vector whose real and imaginary components are specified in individual real vectors and stores the result in a third vector. </paragraph>
<paragraph id="P-0372" lvl="2"><number>&lsqb;0372&rsqb;</number> Phase (<highlight><bold>1</bold></highlight>) Returns the phase angles of elements of a complex vector in a second vector. </paragraph>
<paragraph id="P-0373" lvl="2"><number>&lsqb;0373&rsqb;</number> Phase (<highlight><bold>2</bold></highlight>) Computes the phase angles of elements of the complex input vector whose real and imaginary components are specified in real and imaginary vectors, respectively. The function stores the resulting phase angles in a third vector. </paragraph>
<paragraph id="P-0374" lvl="2"><number>&lsqb;0374&rsqb;</number> ComplexToPolar Converts the complex real/imaginary (Cartesian coordinate X/Y) pairs of individual input vectors to polar coordinate form. One version stores the magnitude (radius) component of each element in one vector and the phase (angle) component of each element in another vector. </paragraph>
<paragraph id="P-0375" lvl="2"><number>&lsqb;0375&rsqb;</number> ComplexToPolar A second version returns the polar co-ordinates as (magnitude, phase) pairs in a single vector </paragraph>
<paragraph id="P-0376" lvl="2"><number>&lsqb;0376&rsqb;</number> PolarToComplex Converts the polar form (magnitude, phase) pairs stored in a vector into a complex vector. Returned in a second vector. </paragraph>
<paragraph id="P-0377" lvl="2"><number>&lsqb;0377&rsqb;</number> PolarToComplex Converts the polar form magnitude/phase pairs stored in the individual vectors into a complex vector. The function stores the real component of the result in a third vector and the imaginary component in a fourth vector. </paragraph>
<paragraph id="P-0378" lvl="2"><number>&lsqb;0378&rsqb;</number> PolarToComplex Converts the polar form magnitude/phase pairs stored in two individual vectors into a complex vector. The function stores the real component of the result in a third vector and the imaginary component in a fourth vector. </paragraph>
<paragraph id="P-0379" lvl="7"><number>&lsqb;0379&rsqb;</number> Sample Quantisation </paragraph>
<paragraph id="P-0380" lvl="0"><number>&lsqb;0380&rsqb;</number> These methods convert between linear and nonlinear quantisation schemes. The number of bits used and the non linear parameters used can be varied. </paragraph>
<paragraph id="P-0381" lvl="2"><number>&lsqb;0381&rsqb;</number> ALawToLinear Converts a vector of A-law encoded samples to linear samples. The result can be returned in place or in a second vector. </paragraph>
<paragraph id="P-0382" lvl="2"><number>&lsqb;0382&rsqb;</number> LinearToALaw Encodes a vector of linear samples using the A-law format The result can be returned in place or in a second vector. </paragraph>
<paragraph id="P-0383" lvl="2"><number>&lsqb;0383&rsqb;</number> LinearToMuLaw Encodes the linear samples in a vector using the &mgr;-law. The result can be returned in place or in a second vector. </paragraph>
<paragraph id="P-0384" lvl="2"><number>&lsqb;0384&rsqb;</number> MuLawToLinear Converts a vector of 8-bit &mgr;-law encoded samples to the linear format. The result can be returned in place or in a second vector. </paragraph>
<paragraph id="P-0385" lvl="7"><number>&lsqb;0385&rsqb;</number> Sample-Generating Functions </paragraph>
<paragraph id="P-0386" lvl="2"><number>&lsqb;0386&rsqb;</number> RandomGaussian Computes a vector of pseudo-random samples with a Gaussian distribution. </paragraph>
<paragraph id="P-0387" lvl="2"><number>&lsqb;0387&rsqb;</number> InitialiseTone Initialises a sinusoid generator with a given frequency, phase and magnitude. </paragraph>
<paragraph id="P-0388" lvl="2"><number>&lsqb;0388&rsqb;</number> NextTone Produces the next sample of a sinusoid of frequency, phase and magnitude specified using InitialiseTone. </paragraph>
<paragraph id="P-0389" lvl="2"><number>&lsqb;0389&rsqb;</number> InitialiseTriangle Initialises a triangle wave generator with a given frequency, phase and magnitude. </paragraph>
<paragraph id="P-0390" lvl="2"><number>&lsqb;0390&rsqb;</number> NextTriangle Produces the next sample of a triangle wave generated using the parameters in InitialiseTriangle. </paragraph>
<paragraph id="P-0391" lvl="7"><number>&lsqb;0391&rsqb;</number> Windowing Functions </paragraph>
<paragraph id="P-0392" lvl="2"><number>&lsqb;0392&rsqb;</number> BartlettWindow Multiplies a vector by a Bartlett windowing function. The result is returned in a second vector. </paragraph>
<paragraph id="P-0393" lvl="2"><number>&lsqb;0393&rsqb;</number> BlackmanWindow Multiplies a vector by a Blackman windowing function with a user-specified parameter. The result is returned in a second vector. </paragraph>
<paragraph id="P-0394" lvl="2"><number>&lsqb;0394&rsqb;</number> HammingWindow Multiplies a vector by a Hamming windowing function. The result is returned in a second vector. </paragraph>
<paragraph id="P-0395" lvl="2"><number>&lsqb;0395&rsqb;</number> HannWindow Multiplies a vector by a Hann windowing function. The result is returned in a second vector. </paragraph>
<paragraph id="P-0396" lvl="2"><number>&lsqb;0396&rsqb;</number> KaiserWndow Multiplies a vector by a Kaiser windowing function. The result is returned in a second vector. </paragraph>
<paragraph id="P-0397" lvl="7"><number>&lsqb;0397&rsqb;</number> Convolution Functions </paragraph>
<paragraph id="P-0398" lvl="2"><number>&lsqb;0398&rsqb;</number> Convolve Performs finite, linear convolution of two sequences. </paragraph>
<paragraph id="P-0399" lvl="2"><number>&lsqb;0399&rsqb;</number> Convolve<highlight><bold>2</bold></highlight>D Performs finite, linear convolution of two two-dimensional signals. </paragraph>
<paragraph id="P-0400" lvl="2"><number>&lsqb;0400&rsqb;</number> Filter<highlight><bold>2</bold></highlight>D Filters a two-dimensional signal similar to Convolve<highlight><bold>2</bold></highlight>D, but with the input and output arrays of the same size. </paragraph>
<paragraph id="P-0401" lvl="7"><number>&lsqb;0401&rsqb;</number> Fourier Transform Functions </paragraph>
<paragraph id="P-0402" lvl="0"><number>&lsqb;0402&rsqb;</number> Versions of these methods exist for a number of different data storage (fixed, floating and integer) formats. </paragraph>
<paragraph id="P-0403" lvl="2"><number>&lsqb;0403&rsqb;</number> DiscreteFT Computes a discrete Fourier transform in-place or in a second vector. </paragraph>
<paragraph id="P-0404" lvl="2"><number>&lsqb;0404&rsqb;</number> InitialiseGoertz Initialises the data used by Goertzel functions. </paragraph>
<paragraph id="P-0405" lvl="2"><number>&lsqb;0405&rsqb;</number> ResetGoertz Resets the internal delay line used by the Goertzel functions. </paragraph>
<paragraph id="P-0406" lvl="2"><number>&lsqb;0406&rsqb;</number> GoertzFT (<highlight><bold>1</bold></highlight>) Computes the DFT for a given frequency for a single signal count. </paragraph>
<paragraph id="P-0407" lvl="2"><number>&lsqb;0407&rsqb;</number> GoertzFT (<highlight><bold>2</bold></highlight>) Computes the DFT for a given frequency for a block of successive signal counts. </paragraph>
<paragraph id="P-0408" lvl="2"><number>&lsqb;0408&rsqb;</number> FFT (<highlight><bold>1</bold></highlight>) Computes a complex Fast Fourier Transform of a vector, either inplace or in a new vector. </paragraph>
<paragraph id="P-0409" lvl="2"><number>&lsqb;0409&rsqb;</number> FFT (<highlight><bold>2</bold></highlight>) Computes a forward Fast Fourier Transform of two conjugate-symmetric signals, either in-place or in a new vector. </paragraph>
<paragraph id="P-0410" lvl="2"><number>&lsqb;0410&rsqb;</number> FFT (<highlight><bold>3</bold></highlight>) Computes a forward Fast Fourier Transform of a conjugate-symmetric signal, either in-place or in a new vector. </paragraph>
<paragraph id="P-0411" lvl="2"><number>&lsqb;0411&rsqb;</number> FFT (<highlight><bold>4</bold></highlight>) Computes a Fast Fourier Transform of a complex vector and returns the result in two separate (real and imaginary) vectors. </paragraph>
<paragraph id="P-0412" lvl="2"><number>&lsqb;0412&rsqb;</number> FFT (<highlight><bold>5</bold></highlight>) Computes a Fast Fourier Transform of a complex vector provided as two separate (real and imaginary) vectors returns the result in two separate (real and imaginary) vectors. </paragraph>
<paragraph id="P-0413" lvl="2"><number>&lsqb;0413&rsqb;</number> IFFT (<highlight><bold>1</bold></highlight>) Computes an inverse Fast Fourier Transform of a vector, either in-place or in a new vector. </paragraph>
<paragraph id="P-0414" lvl="2"><number>&lsqb;0414&rsqb;</number> IFFT (<highlight><bold>2</bold></highlight>) Computes an inverse Fast Fourier Transform of two conjugate-symmetric signals, either in-place or in a new vector. </paragraph>
<paragraph id="P-0415" lvl="2"><number>&lsqb;0415&rsqb;</number> IFFT (<highlight><bold>3</bold></highlight>) Computes an inverse Fast Fourier Transform of a conjugate-symmetric signal, either in-place or in a new vector. </paragraph>
<paragraph id="P-0416" lvl="7"><number>&lsqb;0416&rsqb;</number> Finite Impulse Response Filter Functions </paragraph>
<paragraph id="P-0417" lvl="2"><number>&lsqb;0417&rsqb;</number> InitialiseFIR Initialises a low-level, single-rate finite impulse response filter with a set of delay line values and taps. </paragraph>
<paragraph id="P-0418" lvl="2"><number>&lsqb;0418&rsqb;</number> FIR Filters a single sample through a low-level, finite impulse response filter, previously configured using InitialiseFIR. </paragraph>
<paragraph id="P-0419" lvl="2"><number>&lsqb;0419&rsqb;</number> BlockFIR Filters a block of samples through a low-level, finite impulse response filter. </paragraph>
<paragraph id="P-0420" lvl="2"><number>&lsqb;0420&rsqb;</number> GetFIRDelays Gets the delay line values for a low-level, finite impulse response filter. </paragraph>
<paragraph id="P-0421" lvl="2"><number>&lsqb;0421&rsqb;</number> GetFIRTaps Gets the tap coefficients for a low-level, finite impulse response filter. </paragraph>
<paragraph id="P-0422" lvl="2"><number>&lsqb;0422&rsqb;</number> SetFIRDelays Changes the delay line values for a low-level, finite impulse response filter. </paragraph>
<paragraph id="P-0423" lvl="2"><number>&lsqb;0423&rsqb;</number> SetFIRTaps Changes the tap coefficients for a low-level, finite impulse response filter. </paragraph>
<paragraph id="P-0424" lvl="2"><number>&lsqb;0424&rsqb;</number> InitisliseMultiFIR Initialises a low-level, multi-rate finite impulse response filter. </paragraph>
<paragraph id="P-0425" lvl="2"><number>&lsqb;0425&rsqb;</number> MultiFIR Filters a single sample through a low-level, multi-rate finite impulse response filter, previously configured using InitisliseMultiFIR </paragraph>
<paragraph id="P-0426" lvl="2"><number>&lsqb;0426&rsqb;</number> BlockMultiFIR Filters a block of samples through a low-level, multi-rate finite impulse response filter, previously configured using InitisliseMultiFIR. </paragraph>
<paragraph id="P-0427" lvl="7"><number>&lsqb;0427&rsqb;</number> Least Mean Squares Adaptation Filter Functions </paragraph>
<paragraph id="P-0428" lvl="2"><number>&lsqb;0428&rsqb;</number> InitialiseSALF Initialise a low-level, single-rate, adaptive FIR filter that uses the least mean squares (LMS) algorithm. </paragraph>
<paragraph id="P-0429" lvl="2"><number>&lsqb;0429&rsqb;</number> InitialiseMALF Initialise a low-level, multi-rate, adaptive FIR filter that uses the least mean squares (LMS) algorithm. </paragraph>
<paragraph id="P-0430" lvl="2"><number>&lsqb;0430&rsqb;</number> InitALFDelay Initialises a delay line for a low-level, adaptive FIR filter that uses the least mean squares(LMS) algorithm. </paragraph>
<paragraph id="P-0431" lvl="2"><number>&lsqb;0431&rsqb;</number> SALF Filter a sample through a low-level, single-rate, adaptive FIR filter that uses the least mean squares (LMS) algorithm. </paragraph>
<paragraph id="P-0432" lvl="2"><number>&lsqb;0432&rsqb;</number> MALF Filter a sample through a low-level, multi-rate, adaptive FIR filter that uses the least mean squares (LMS) algorithm. </paragraph>
<paragraph id="P-0433" lvl="2"><number>&lsqb;0433&rsqb;</number> SLF Filter a sample through a low-level, single-rate, adaptive FIR filter that uses the least mean squares (LMS) algorithm, but without adapting the filter for a secondary signal. </paragraph>
<paragraph id="P-0434" lvl="2"><number>&lsqb;0434&rsqb;</number> MLF Filter a sample through a low-level, multi-rate, adaptive FIR filter that uses the least mean squares (LMS) algorithm, but without adapting the filter for a secondary signal. </paragraph>
<paragraph id="P-0435" lvl="2"><number>&lsqb;0435&rsqb;</number> EnginesALF Filter a block of samples through a low-level, single-rate, adaptive FIR filter that uses the least mean squares (LMS) algorithm. </paragraph>
<paragraph id="P-0436" lvl="2"><number>&lsqb;0436&rsqb;</number> BlockMALF Filter a block of samples through a low-level, multi-rate, adaptive FIR filter that uses the least mean squares (LMS) algorithm. </paragraph>
<paragraph id="P-0437" lvl="2"><number>&lsqb;0437&rsqb;</number> EnginesLF Filter a block of samples through a low-level, single-rate, adaptive FIR filter that uses the least mean squares (LMS) algorithm, but without adapting the filter for a secondary signal. </paragraph>
<paragraph id="P-0438" lvl="2"><number>&lsqb;0438&rsqb;</number> BlockMLF Filter a block of samples through a low-level, multi-rate, adaptive FIR filter that uses the least mean squares (LMS) algorithm, but without adapting the filter for a secondary signal. </paragraph>
<paragraph id="P-0439" lvl="2"><number>&lsqb;0439&rsqb;</number> SetALFDelays Sets the delay line values for a low-level, adaptive FIR filter that uses the least mean squares (LMS) algorithm. </paragraph>
<paragraph id="P-0440" lvl="2"><number>&lsqb;0440&rsqb;</number> SetALFLeaks Sets the leak values for a low-level, adaptive FIR filter that uses the least mean squares (LMS) algorithm. </paragraph>
<paragraph id="P-0441" lvl="2"><number>&lsqb;0441&rsqb;</number> SetALFSteps Sets the step values for a low-level, adaptive FIR filter that uses he least mean squares (LMS) algorithm. </paragraph>
<paragraph id="P-0442" lvl="2"><number>&lsqb;0442&rsqb;</number> SetALFTaps Sets the taps coefficients for a low-level, adaptive FIR filter that uses the least mean squares (LMS) algorithm. </paragraph>
<paragraph id="P-0443" lvl="2"><number>&lsqb;0443&rsqb;</number> GetALFDelays Gets the delay line values for a low-level, adaptive FIR filter that uses the least mean squares (LMS) algorithm. </paragraph>
<paragraph id="P-0444" lvl="2"><number>&lsqb;0444&rsqb;</number> GetALFLeaks Gets the leak values for a low-level, adaptive FIR filter that uses the least mean squares (LMS) algorithm. </paragraph>
<paragraph id="P-0445" lvl="2"><number>&lsqb;0445&rsqb;</number> GetALFSteps Gets the step values for a low-level, adaptive FIR filter that uses he least mean squares (LMS) algorithm. </paragraph>
<paragraph id="P-0446" lvl="2"><number>&lsqb;0446&rsqb;</number> GetALFTaps Gets the taps coefficients for a low-level, adaptive FIR filter that uses the least mean squares (LMS) algorithm. </paragraph>
<paragraph id="P-0447" lvl="7"><number>&lsqb;0447&rsqb;</number> Infinite Impulse Response Filter Functions </paragraph>
<paragraph id="P-0448" lvl="2"><number>&lsqb;0448&rsqb;</number> InitialiseIIR Initialises a low-level, infinite, impulse response filter of a specified order. </paragraph>
<paragraph id="P-0449" lvl="2"><number>&lsqb;0449&rsqb;</number> InitialiseBiquadIIR Initialises a low-level, infinite impulse response (IIR) filter to reference a cascade of biquads (second-order IIR sections). </paragraph>
<paragraph id="P-0450" lvl="2"><number>&lsqb;0450&rsqb;</number> InitialiseIIRDelay Initialises the delay line for a low-level, infinite impulse response (IIR) filter. </paragraph>
<paragraph id="P-0451" lvl="2"><number>&lsqb;0451&rsqb;</number> IIR Filters a single sample through a low-level, infinite impulse response filter. </paragraph>
<paragraph id="P-0452" lvl="2"><number>&lsqb;0452&rsqb;</number> BlockIIR Filters a block of samples through a low-level, infinite impulse response filter. </paragraph>
<paragraph id="P-0453" lvl="7"><number>&lsqb;0453&rsqb;</number> Wavelet Functions </paragraph>
<paragraph id="P-0454" lvl="2"><number>&lsqb;0454&rsqb;</number> DecomposeWavelet Decomposes signals into wavelet series. </paragraph>
<paragraph id="P-0455" lvl="2"><number>&lsqb;0455&rsqb;</number> ReconstructWavelet Reconstructs signals from wavelet decomposition. </paragraph>
<paragraph id="P-0456" lvl="7"><number>&lsqb;0456&rsqb;</number> Discrete Cosine Transform Function </paragraph>
<paragraph id="P-0457" lvl="2"><number>&lsqb;0457&rsqb;</number> DCT Performs the Discrete Cosine Transform (DCT). </paragraph>
<paragraph id="P-0458" lvl="7"><number>&lsqb;0458&rsqb;</number> Vector Data Conversion Functions </paragraph>
<paragraph id="P-0459" lvl="0"><number>&lsqb;0459&rsqb;</number> All the functions described in this section can operate on a number of different data formats (such as various integer lengths, different floating point formats and fixed point representations of floating point numbers). The Signal Processing Library will contain methods to translate single values and vectors between all pairs of formats supported. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method of designing, modelling or fabricating a communications baseband stack, comprising the steps of: 
<claim-text>(a) creating a description of one or more of the following parameters of the baseband stack: 
<claim-text>(i) resource requirements; </claim-text>
<claim-text>(ii) capabilities; </claim-text>
<claim-text>(iii) behaviour; and </claim-text>
</claim-text>
<claim-text>(b) using that description as an input to software comprising a virtual machine layer optimised for a communications DSP in order to generate an emulation of the baseband stack to be designed, modelled or fabricated. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> comprising the steps of: 
<claim-text>(a) using, for one or more components to be incorporated in the baseband stack, a component description which defines some or all of the externally visible attributes of a component, as well as its behaviour, as an input to a mathematical modelling tool programmed to output component related performance data for each component; </claim-text>
<claim-text>(b) processing the component related performance data for each component to yield a baseband stack description; </claim-text>
<claim-text>(c) creating a resources description defining the resources of the baseband stack; </claim-text>
<claim-text>(d) creating an interface description defining how each component is to be used in the baseband stack; and </claim-text>
<claim-text>(e) using each of the baseband stack description, the resources description, and the interface description as the inputs to the software. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference> in which the software emulates the baseband stack and is both instrumented and interpreted/compiled. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference>, in which the software outputs diagnostic information in respect of a component in the same format as the component description for that component in order to refine the quality of the component description. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00004">claim 4</dependent-claim-reference> in which the diagnostic information in the component description is fed back as an input to the software to improve the accuracy of the modelling. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference> and any claim dependent on <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference> where the software outputs computer source code which can be interpreted or compiled to fabricate an actual baseband stack implementation. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The method of any preceding claim in which components or modules of the baseband stack can be incrementally ported to a target DSP to enable testing and debugging of individual ported components or modules. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The method of any preceding claim in which: 
<claim-text>(a) a first test is carried out using software to emulate a given hardware component as part of a design or modelling process; </claim-text>
<claim-text>(b) the emulated component is replaced with the hardware component, and </claim-text>
<claim-text>(c) a further test is carried out. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> in which the virtual machine layer allows statistical modelling in which available resources and interconnect characteristics are represented as statistical distribution functions. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> in which the virtual machine layer allows low MIPS code to interface with high MIPS processes by using APIs presented by the virtual machine layer. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference> in which the high MIPS processes are implementations of abstract processes and are organised in a runtime environment in such a way that access cost is optimised. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> in which the virtual machine layer comprises a scheduler which is programmed to co-schedule processes between different engines in order to give optimal resource utilisation during either or both of (i) the design and modelling phase and (ii) a runtime, and in which the resource allocation involves one or both of the following steps: (a) measurement using a statistical function; (b) modelling using a statistical distribution function. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference> in which the virtual machine layer supports underlying high MIPs algorithms common to a number of different baseband processing algorithms, and makes these accessible to high level, architecture neutral, potentially high complexity but low-MIPs control flows through a scheduler interface, which allows the control flow to specify the algorithm to be executed, together with a set of resource constraint envelopes, relating to one or more of: time of execution, memory, interconnect bandwidth, inside of which the caller desires the execution to take place. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference> adapted to allow, during design or modelling, datapath partioning of high MIPS processes across different engines. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference> in which the scheduler is aware, during runtime, of the datapath partioning decisions made across different engines. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference> in which the low MIPS complex code is expressed at least in part in a language not designed for real time operations. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference> in which the language is SDL. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference> which enables the low MIPS complex code to be represented in an architecture neutral manner. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference> which enables a baseband stack to be constructed with architecture neutral, low MIPS control codes, in which the control codes use a set of architecture neutral APIs specified by the virtual machine layer in order to access architecture specific high MIPS processes. </claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference> in which at least one high MIPS engine provides a resource for several different kinds of baseband stack. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference> programmed to characterise the static and dynamic resource requirements of different processes so that they can be co-scheduled in real-time with other processes. </claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference> further comprising fully integrated mathematical models, statistical simulation tools and a priori partioning simulation tools. </claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The method of any preceding operating as a design or modelling platform for a system on a chip. </claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 23</dependent-claim-reference>, in which intellectual property blocks, each from several different vendors, can be combined in the system on a chip by virtue of the static and dynamic resource requirements of each block being modelled by the software so that multiple blocks can be co-scheduled together in real-time. </claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 24</dependent-claim-reference> in which the blocks perform high MIPS operations. </claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 24</dependent-claim-reference> in which the blocks perform low MIPS, control operations. </claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference> as used in a process of migrating the substrate on which digital signal processing is performed from (a) a PC prototype for non-real time design and modelling to (b) one or more DSP chips with one or more external FPGAs for runtime. </claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 27</dependent-claim-reference> in which the substrate is subsequently migrated to a custom ASIC. </claim-text>
</claim>
<claim id="CLM-00029">
<claim-text><highlight><bold>29</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference> in which the virtual machine layer is programmed with or enables access to one or more of the following: 
<claim-text>(a) core processes; </claim-text>
<claim-text>(b) core structures; </claim-text>
<claim-text>(c) core functions: </claim-text>
<claim-text>(d) flow control; </claim-text>
<claim-text>(e) state management. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00030">
<claim-text><highlight><bold>30</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 29</dependent-claim-reference> in which the core processes include algorithms to perform one or more of the following: source coding, channel coding, modulation, or their inverses, namely source decoding, channel decoding and demodulation. </claim-text>
</claim>
<claim id="CLM-00031">
<claim-text><highlight><bold>31</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 29</dependent-claim-reference> in which the core structures comprise a symbol processing section (concerned with processing full symbols, regardless of whether all the information held within that symbol is to be used) and a data directed processing section, in which only those bits which hold relevant information are processed. </claim-text>
</claim>
<claim id="CLM-00032">
<claim-text><highlight><bold>32</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00033">claim 31</dependent-claim-reference> in which the core structure is comprised of processing modules operable to allocate, share and dispose of intermediate, aligned memory buffers, and pass events between themselves. </claim-text>
</claim>
<claim id="CLM-00033">
<claim-text><highlight><bold>33</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 29</dependent-claim-reference> in which the core functions include one or more of the following: resource allocation and scheduling, including memory allocation, real time resource allocation and concurrency management. </claim-text>
</claim>
<claim id="CLM-00034">
<claim-text><highlight><bold>34</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 29</dependent-claim-reference> operable to access PC debug tools. </claim-text>
</claim>
<claim id="CLM-00035">
<claim-text><highlight><bold>35</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 29</dependent-claim-reference> which is operable with a component, in which only that information necessary to enable the software to operate with and/or otherwise model the performance of the component is supplied by the owner of the intellectual property in the component. </claim-text>
</claim>
<claim id="CLM-00036">
<claim-text><highlight><bold>36</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 29</dependent-claim-reference> which is operable with a standardised description of the characteristics (including interface and non-interface behaviour) of communications components to enable a simulator, emulator or modelling tool to accurately estimate the resource requirements of a system using those components. </claim-text>
</claim>
<claim id="CLM-00037">
<claim-text><highlight><bold>37</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 29</dependent-claim-reference> operable to model time, CPU, memory, interconnect scheduling and concurrency restraints, enabling mapping onto a real time OS, non real-time OS, virtual machine or hardware. </claim-text>
</claim>
<claim id="CLM-00038">
<claim-text><highlight><bold>38</bold></highlight>. A baseband stack developed using the method of any preceding claim. </claim-text>
</claim>
<claim id="CLM-00039">
<claim-text><highlight><bold>39</bold></highlight>. A communications device using the baseband stack of <dependent-claim-reference depends_on="CLM-00033">claim 38</dependent-claim-reference>. </claim-text>
</claim>
<claim id="CLM-00040">
<claim-text><highlight><bold>40</bold></highlight>. A system on a chip developed using the method of any preceding claim <highlight><bold>1</bold></highlight>-<highlight><bold>37</bold></highlight>. </claim-text>
</claim>
<claim id="CLM-00041">
<claim-text><highlight><bold>41</bold></highlight>. A method of defining a component using a standardised description of the characteristics (including interface and/or non-interface behaviour) of that component whereby that standardised description can be used in a method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> or constitute the component description of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference> and any preceding claim dependent on <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>. </claim-text>
</claim>
<claim id="CLM-00042">
<claim-text><highlight><bold>42</bold></highlight>. A method of defining a baseband stack using a language designed to define some or all of the functionality of the stack to estimate, simulate or fabricate a real stack using the method of any preceding claim <highlight><bold>1</bold></highlight>-<highlight><bold>37</bold></highlight>.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>1</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030004697A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030004697A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030004697A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030004697A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030004697A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030004697A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030004697A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030004697A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030004697A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
