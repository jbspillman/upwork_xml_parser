<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005142A1-20030102-D00000.TIF SYSTEM "US20030005142A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005142A1-20030102-D00001.TIF SYSTEM "US20030005142A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005142A1-20030102-D00002.TIF SYSTEM "US20030005142A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005142A1-20030102-D00003.TIF SYSTEM "US20030005142A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005142A1-20030102-D00004.TIF SYSTEM "US20030005142A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005142A1-20030102-D00005.TIF SYSTEM "US20030005142A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030005142A1-20030102-D00006.TIF SYSTEM "US20030005142A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030005142A1-20030102-D00007.TIF SYSTEM "US20030005142A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030005142A1-20030102-D00008.TIF SYSTEM "US20030005142A1-20030102-D00008.TIF" NDATA TIF>
<!ENTITY US20030005142A1-20030102-D00009.TIF SYSTEM "US20030005142A1-20030102-D00009.TIF" NDATA TIF>
<!ENTITY US20030005142A1-20030102-D00010.TIF SYSTEM "US20030005142A1-20030102-D00010.TIF" NDATA TIF>
<!ENTITY US20030005142A1-20030102-D00011.TIF SYSTEM "US20030005142A1-20030102-D00011.TIF" NDATA TIF>
<!ENTITY US20030005142A1-20030102-D00012.TIF SYSTEM "US20030005142A1-20030102-D00012.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005142</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10188377</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20020702</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F015/16</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>709</class>
<subclass>232000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Storing a frame header</title-of-invention>
</technical-information>
<continuity-data>
<division-of>
<parent-child>
<child>
<document-id>
<doc-number>10188377</doc-number>
<kind-code>A1</kind-code>
<document-date>20020702</document-date>
</document-id>
</child>
<parent>
<document-id>
<doc-number>09364374</doc-number>
<document-date>19990730</document-date>
<country-code>US</country-code>
</document-id>
</parent>
<parent-status>GRANTED</parent-status>
<parent-patent>
<document-id>
<doc-number>6449656</doc-number>
<country-code>US</country-code>
</document-id>
</parent-patent>
</parent-child>
</division-of>
</continuity-data>
<inventors>
<first-named-inventor>
<name>
<given-name>Uri</given-name>
<family-name>Elzur</family-name>
</name>
<residence>
<residence-non-us>
<city>Zichron Yaakov</city>
<country-code>IL</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Dan</given-name>
<middle-name>G.</middle-name>
<family-name>Wartski</family-name>
</name>
<residence>
<residence-non-us>
<city>Haifa</city>
<country-code>IL</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>TROP PRUNER &amp; HU, PC</name-1>
<name-2></name-2>
<address>
<address-1>8554 KATY FREEWAY</address-1>
<address-2>SUITE 100</address-2>
<city>HOUSTON</city>
<state>TX</state>
<postalcode>77024</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A method and apparatus for use with a computer system are disclosed. A packet is received that includes a header. The header indicates at least one characteristic that is associated with a layer of a protocol stack. The packet is parsed in hardware to extract the characteristic(s), and the packet is processed based on the parsing. Hardware may construct subsequent headers and update fields of the transport, network and data link layers. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">BACKGROUND </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> The invention relates to storing a frame header, for example in connection with a network controller. </paragraph>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 1, a</cross-reference> server <highlight><bold>12</bold></highlight> may communicate with a client <highlight><bold>10</bold></highlight> by transmitting packets <highlight><bold>8</bold></highlight> of information over a network <highlight><bold>18</bold></highlight> pursuant to a network protocol. As an example, the network protocol may be a Transmission Control Protocol/Internet Protocol (TCP/IP), and as a result, the client <highlight><bold>10</bold></highlight> and server <highlight><bold>12</bold></highlight> may implement protocol stacks, such as TCP/IP stacks <highlight><bold>17</bold></highlight> and <highlight><bold>19</bold></highlight>, respectively. For the client <highlight><bold>10</bold></highlight> (as an example), the TCP/IP stack <highlight><bold>17</bold></highlight> conceptually divides the client&apos;s software and hardware protocol functions into five hierarchical layers <highlight><bold>16</bold></highlight> (listed in hierarchical order): an application layer <highlight><bold>16</bold></highlight><highlight><italic>a </italic></highlight>(the highest layer), a transport layer <highlight><bold>16</bold></highlight><highlight><italic>b</italic></highlight>, a network layer <highlight><bold>16</bold></highlight><highlight><italic>c</italic></highlight>, a data link layer <highlight><bold>16</bold></highlight><highlight><italic>d </italic></highlight>and a physical layer <highlight><bold>16</bold></highlight><highlight><italic>e </italic></highlight>(the lowest layer). </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> More particularly, the physical layer <highlight><bold>16</bold></highlight><highlight><italic>e </italic></highlight>typically includes hardware (a network controller, for example) that establishes physical communication with the network <highlight><bold>18</bold></highlight> by generating and receiving signals (on a network wire <highlight><bold>9</bold></highlight>) that indicate bits of the packets <highlight><bold>8</bold></highlight>. The physical layer <highlight><bold>16</bold></highlight><highlight><italic>e </italic></highlight>recognizes bits and does not recognize packets, as the data link layer <highlight><bold>16</bold></highlight><highlight><italic>d </italic></highlight>performs this function. In this manner, the data link layer <highlight><bold>16</bold></highlight><highlight><italic>d </italic></highlight>typically is both a software and hardware layer that may, for transmission purposes, cause the client <highlight><bold>10</bold></highlight> to package the data to be transmitted into the packets <highlight><bold>8</bold></highlight>. For purposes of receiving packets <highlight><bold>8</bold></highlight>, the data link layer <highlight><bold>16</bold></highlight><highlight><italic>d </italic></highlight>may, as another example, cause the client <highlight><bold>10</bold></highlight> to determine the integrity of the incoming packets <highlight><bold>8</bold></highlight> by determining if the incoming packets <highlight><bold>8</bold></highlight> generally conform to predefined formats and if the data of the packets comply with checksums (or cyclic redundancy check (CRC))of the packets, for example. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> The network layer <highlight><bold>16</bold></highlight><highlight><italic>c </italic></highlight>typically is a software layer that is responsible for routing the packets <highlight><bold>8</bold></highlight> over the network <highlight><bold>18</bold></highlight>. In this manner, the network layer <highlight><bold>16</bold></highlight><highlight><italic>c </italic></highlight>typically causes the client <highlight><bold>10</bold></highlight> to assign and decode Internet Protocol (IP) addresses that identify entities that are coupled to the network <highlight><bold>18</bold></highlight>, such as the client <highlight><bold>10</bold></highlight> and the server <highlight><bold>12</bold></highlight>. The transport layer <highlight><bold>16</bold></highlight><highlight><italic>b </italic></highlight>typically is a software layer that is responsible for such things as reliable data transfer between two end points and may use sequencing, error control and general flow control of the packets <highlight><bold>8</bold></highlight> to achieve reliable data transfer. The transport layer <highlight><bold>16</bold></highlight><highlight><italic>b </italic></highlight>may cause the client <highlight><bold>10</bold></highlight> to implement the specific network protocol, such as the TCP/IP protocol or a User Datagram Protocol (UDP) or Realtime Transport Protocol(RTP) which exists on top of UDP, as examples. The application layer <highlight><bold>16</bold></highlight><highlight><italic>a </italic></highlight>typically includes network applications that, upon execution, cause the client <highlight><bold>10</bold></highlight> to generate and receive the data of the packets <highlight><bold>8</bold></highlight>. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 2, a</cross-reference> typical packet <highlight><bold>8</bold></highlight> may include an IP header <highlight><bold>20</bold></highlight> that indicates such information as the source and destination IP addresses for the packet <highlight><bold>8</bold></highlight>. The packet <highlight><bold>8</bold></highlight> may also include a security header <highlight><bold>23</bold></highlight> that indicates a security protocol (e.g. IPSec) and attributes of the packet <highlight><bold>8</bold></highlight> and a protocol header <highlight><bold>22</bold></highlight> (a TCP or an UDP protocol header, as examples) that is specific to the transport protocol being used. As an example, a TCP protocol header might indicate a TCP destination port and a TCP source port that uniquely identify the applications that cause the client <highlight><bold>10</bold></highlight> and server <highlight><bold>12</bold></highlight> to transmit and receive the packets <highlight><bold>8</bold></highlight>. The packet <highlight><bold>8</bold></highlight> may also include a data portion <highlight><bold>24</bold></highlight>, the contents of which are furnished by the source application. The packet <highlight><bold>8</bold></highlight> may include additional information, such as a trailer <highlight><bold>26</bold></highlight>, for example, that is used in connection with encryption and/or authentication of the data portion <highlight><bold>24</bold></highlight>. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 3</cross-reference>, as an example, a TCP protocol header <highlight><bold>22</bold></highlight><highlight><italic>a </italic></highlight>may include a field <highlight><bold>30</bold></highlight> that indicates the TCP source port address and a field <highlight><bold>32</bold></highlight> that indicates the TCP destination port address. Another field <highlight><bold>34</bold></highlight> of the TCP protocol header <highlight><bold>22</bold></highlight><highlight><italic>a </italic></highlight>may indicate a sequence number that is used to concatenate received packets of an associated flow. In this manner, packets <highlight><bold>8</bold></highlight> that have the same IP addresses, transport layer port addresses (and security attributes). are typically part of the same flow, and the sequence number indicates the order of a particular packet <highlight><bold>8</bold></highlight> in that flow. Thus, as an example, a packet <highlight><bold>8</bold></highlight> with a sequence number of &ldquo;244&rdquo; typically is transmitted before a packet <highlight><bold>8</bold></highlight> with a sequence number of &ldquo;245.&rdquo;</paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> The TCP protocol header <highlight><bold>22</bold></highlight><highlight><italic>a </italic></highlight>may include a field <highlight><bold>38</bold></highlight> that indicates a length of the header <highlight><bold>22</bold></highlight><highlight><italic>a</italic></highlight>, a field <highlight><bold>44</bold></highlight> that indicates a checksum for the bytes in the header <highlight><bold>22</bold></highlight><highlight><italic>a </italic></highlight>and a field <highlight><bold>40</bold></highlight> that indicates control and status flags. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> In order to transmit data from one application to another over the network wire, the data is segmented into frames. The maximum number of bytes that can be packed into one frame is called the maximal transmit unit (MTU). Thus, the operating system may pass data units down to hardware, such as network controller, in units that correspond to the MTU. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> There is overhead associated with segmenting the data into MTUs, creating the frame header at all layers, and transmitting multiple messages down the stack to a miniport driver or other drivers for other operating systems or hardware. A driver, containing device specific information, communicates with non-device specific port drivers that in turn communicate with the protocol stack on behalf of the system. When the operating system wishes to offload some of that overhead, it may pass data to the miniport driver or hardware in data units larger than the MTU. This type of transfer is generally called a large send. The miniport driver or hardware can now segment the data and create the framing information. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> Generally a large send requires that header information be recreated for successive frames. However, this will result in delay and overhead and also requires the header to be read across the system bus with every segment prior to its modification. This may increase the overall delay to complete the data exchange between the client and the server and consume bus resources that are important especially for server and multiple controller systems. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> Thus, there is a continuing need for implementing a large send in a way which reduces the consumption of bus resources. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY </heading>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> In one embodiment of the invention, a method for use with a computer system, includes receiving output data from the computer system, extracting the header of the packet; storing a header from said data in a header memory, retrieving the header from header memory and parsing the header to add additional information to the header.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWING </heading>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a schematic diagram of a network of computers according to the prior art. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a schematic diagram of a packet transmitted over the network shown in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is an illustration of an exemplary protocol header of the packet of <cross-reference target="DRAWINGS">FIG. 2</cross-reference>. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a schematic diagram of a computer system according to an embodiment of the invention. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a schematic diagram of a network controller of <cross-reference target="DRAWINGS">FIG. 4</cross-reference>. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference><highlight><italic>a </italic></highlight>is a flow diagram illustrating a large send. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference><highlight><italic>b </italic></highlight>shows a method of generating a partial checksum. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is an illustration of a flow tuple stored in memory of the network controller of <cross-reference target="DRAWINGS">FIG. 5</cross-reference>. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> is a schematic diagram illustrating the transfer of packet data according to an embodiment of the invention. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> is a schematic diagram illustrating the transfer of packet data between layers of the network stack of the prior art. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 9 and 10</cross-reference> are flow diagrams illustrating parsing of packet data by a receive parser of the network controller of <cross-reference target="DRAWINGS">FIG. 5</cross-reference>. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 11</cross-reference> is a flow diagram illustrating operation of a zero copy parser of the network controller of <cross-reference target="DRAWINGS">FIG. 5</cross-reference>. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 12</cross-reference> is another flow diagram illustrating the operation of a zero copy parser.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION </heading>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, an embodiment <highlight><bold>50</bold></highlight> of a computer system in accordance with the invention includes a network controller <highlight><bold>52</bold></highlight> (a local area network (LAN) controller, for example) that communicates packets of information with other networked computer systems via at least one network wire <highlight><bold>53</bold></highlight>. Unlike conventional network controllers, the network controller <highlight><bold>52</bold></highlight> may be adapted in one embodiment of the invention, to perform functions that are typically implemented by a processor (a central processing unit (CPU), for example) that executes one or more software layers (a network layer and a transport layer, as examples) of a protocol stack (a TCP/IP stack, for example). As an example, these functions may include parsing headers of incoming packets to obtain characteristics (of the packet) that typically are extracted by execution of the software layers. The characteristics, in turn, may be used to identify a flow that is associated with the packet, as further described below. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 5</cross-reference>, the network controller <highlight><bold>52</bold></highlight> may include hardware, such as a receive path <highlight><bold>92</bold></highlight>, to perform traditional software functions to process packets that are received from the network. For example, the receive path <highlight><bold>92</bold></highlight> may include a receive parser <highlight><bold>98</bold></highlight> to parse a header of each packet to extract characteristics of the packet, such as characteristics that associate a particular flow with the packet. Because the receive path <highlight><bold>92</bold></highlight> may be receiving incoming packets from many different flows, the receive path <highlight><bold>92</bold></highlight> may include a memory <highlight><bold>100</bold></highlight> that stores entries, or flow tuples <highlight><bold>140</bold></highlight>, that uniquely identify a particular flow. In this manner, the receive parser <highlight><bold>98</bold></highlight> may interact with the memory <highlight><bold>100</bold></highlight> to compare parsed information from the incoming packet with the stored flow tuples <highlight><bold>140</bold></highlight> to determine if the flow if detected, or &ldquo;flow tuple hit,&rdquo; occurs. If a flow tuple hit occurs, the receive parser <highlight><bold>98</bold></highlight> may indicate this event to other circuitry (of the controller <highlight><bold>52</bold></highlight>) that processes the packet based on the detected flow, as further described below. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> Referring also to <cross-reference target="DRAWINGS">FIG. 6</cross-reference>, each flow tuple <highlight><bold>140</bold></highlight> may include fields that identify characteristics of a particular flow. As an example, in some embodiments, at least one of the flow tuples <highlight><bold>140</bold></highlight> may be associated with a Transmission Control Protocol (TCP), a User Datagram Protocol (UDP) or a Realtime Transport Protocol (RTP), as just a few examples. The flow tuple <highlight><bold>140</bold></highlight> may include a field <highlight><bold>142</bold></highlight> that indicates an Internet protocol (IP) destination address (i.e., the address of the computer system to receive the packet); a field <highlight><bold>144</bold></highlight> that indicates an IP source address (i.e., the address of a computer system to transmit the packet); a field <highlight><bold>146</bold></highlight> that indicates a TCP destination port (i.e., the address of the application that caused generation of the packet); a field <highlight><bold>148</bold></highlight> that indicates a TCP source port (i.e., the address of the application that is to receive the packet); and a field <highlight><bold>150</bold></highlight> that indicates security/authentication attributes of the packet. Other flow tuples <highlight><bold>140</bold></highlight> may be associated with other network protocols, such as a User Datagram Protocol (UDP), for example. The above references to specific network protocols are intended to be examples only and are not intended to limit the scope of the invention. Additional flow tuples <highlight><bold>140</bold></highlight> may be stored in the memory <highlight><bold>100</bold></highlight> and existing flow tuples <highlight><bold>140</bold></highlight> may be removed from the memory <highlight><bold>100</bold></highlight> via a driver program <highlight><bold>57</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 4</cross-reference>). </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> If the receive parser <highlight><bold>98</bold></highlight> recognizes (via the flow tuples <highlight><bold>140</bold></highlight>) the flow that is associated with the incoming packet, then the receive path <highlight><bold>92</bold></highlight> may further process the packet. If the receive parser <highlight><bold>98</bold></highlight> does not recognize the flow, then the receive path <highlight><bold>92</bold></highlight> may pass the incoming packet via a Peripheral Component Interconnect (PCI) interface <highlight><bold>130</bold></highlight> to software layers of a TCP/IP stack of the computer system <highlight><bold>50</bold></highlight> for processing. The PCI Specification is available from The PCI Special Interest Group, Portland, Oreg. 97214. Other bus interfaces may be used in place of the PCI interface <highlight><bold>130</bold></highlight>. In this manner, in some embodiments, the computer system <highlight><bold>50</bold></highlight> may execute an operating system that provides at least a portion of some layers (network and transport layers, for example) of the protocol stack. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> In some embodiments, even if the receive parser <highlight><bold>98</bold></highlight> recognizes the flow, additional information may be needed before receive path <highlight><bold>92</bold></highlight> further processes the incoming packet <highlight><bold>52</bold></highlight>. For example, an authentication/encryption engine <highlight><bold>102</bold></highlight> may authenticate and/or decrypt the data portion of the incoming packet based on the security attributes that are indicated by the field <highlight><bold>150</bold></highlight> (see <cross-reference target="DRAWINGS">FIG. 6</cross-reference>). In this manner, if the field <highlight><bold>150</bold></highlight> indicates that the data portion of the incoming packet is encrypted, then the engine <highlight><bold>102</bold></highlight> may need a key to decrypt the data portion. If authenticated, a key may be used to check authenticity. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> For purposes of providing the key to the engine <highlight><bold>102</bold></highlight>, the network controller <highlight><bold>52</bold></highlight> may include a key memory <highlight><bold>104</bold></highlight> that stores different keys that may be indexed by the different associated flows, for example. Additional keys may be stored in the key memory <highlight><bold>104</bold></highlight> by execution of the driver program <highlight><bold>57</bold></highlight>, and existing keys may be removed from the key memory <highlight><bold>104</bold></highlight> by execution of the driver program <highlight><bold>57</bold></highlight>. In this manner, if the engine <highlight><bold>102</bold></highlight> determines that the particular decryption key is not stored in the key memory <highlight><bold>104</bold></highlight>, then the engine <highlight><bold>102</bold></highlight> may submit a request (via the PCI interface <highlight><bold>130</bold></highlight>) to the driver program <highlight><bold>57</bold></highlight> (see <cross-reference target="DRAWINGS">FIG. 4</cross-reference>) for the key. In this manner, the driver program <highlight><bold>57</bold></highlight>, when executed, may furnish the key in response to the request and interact with the PCI interface <highlight><bold>130</bold></highlight> to store the key in the key memory <highlight><bold>104</bold></highlight>. In some embodiments, if the key is unavailable (i.e., the key is not available from the driver program <highlight><bold>57</bold></highlight> or is not stored in the key memory <highlight><bold>104</bold></highlight>), then the engine <highlight><bold>102</bold></highlight> does not decrypt the data portion of the packet. Instead, the PCI interface <highlight><bold>130</bold></highlight> stores the encrypted data in a predetermined location of a system memory <highlight><bold>56</bold></highlight> (see <cross-reference target="DRAWINGS">FIG. 4</cross-reference>) so that software of one or more layers of the protocol stack may be executed to decrypt the data portion of the incoming packet. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> After the parsing, the processing of the packet by the network controller <highlight><bold>52</bold></highlight> may include bypassing the execution of one or more software layers of the protocol stack. For example, the receive path <highlight><bold>92</bold></highlight> may include a zero copy parser <highlight><bold>110</bold></highlight> that, via the PCI interface <highlight><bold>130</bold></highlight>, copies data associated with the packet into a memory buffer <highlight><bold>304</bold></highlight> (see <cross-reference target="DRAWINGS">FIG. 7</cross-reference>) that is associated with the application. In this manner, several applications may have associated buffers for receiving the packet data. The operating system creates and maintains the buffers <highlight><bold>304</bold></highlight> in a virtual address space, and the operating system reserves a multiple number of physical four kilobyte (KB) pages for each buffer <highlight><bold>304</bold></highlight>. The operating system also associates each buffer with a particular application. This arrangement is to be contrasted to conventional arrangements that may use intermediate buffers to transfer packet data from the network controller to applications, as described below. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 8</cross-reference>, for example, a typical network controller <highlight><bold>300</bold></highlight> does not directly transfer the packet data into the buffers <highlight><bold>304</bold></highlight> because the typical network controller <highlight><bold>300</bold></highlight> does not parse the incoming packets to obtain information that identifies the destination application. Instead, the typical network controller <highlight><bold>300</bold></highlight> (under the control of the data link layer, for example) typically transfers the data portion of the packet into packet buffers <highlight><bold>302</bold></highlight> that are associated with an intermediate layer e.g. the data link, the network layer or the transport layer. In contrast to the buffers <highlight><bold>304</bold></highlight>, each buffer <highlight><bold>302</bold></highlight> may have a size range of 64 to 1518 bytes. The execution of the network layer subsequently associates the data with the appropriate applications and causes the data to be transferred from the buffers <highlight><bold>302</bold></highlight> to the buffers <highlight><bold>304</bold></highlight>. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> Referring back to <cross-reference target="DRAWINGS">FIG. 7</cross-reference>, in contrast to the conventional arrangement described above, the network controller <highlight><bold>52</bold></highlight> may use the zero copy parser <highlight><bold>110</bold></highlight> to bypass the buffers <highlight><bold>302</bold></highlight> and copy the data portion of the packet directly into the appropriate buffer <highlight><bold>304</bold></highlight>. To accomplish this, the zero copy parser <highlight><bold>110</bold></highlight> (see <cross-reference target="DRAWINGS">FIG. 5</cross-reference>) may receive an indication of the TCP destination port (as an example) from the receive parser <highlight><bold>98</bold></highlight> that, as described above, extracts this information from the header. The TCP or other protocol destination port uniquely identifies the application that is to receive the data and thus, identifies the appropriate buffer <highlight><bold>304</bold></highlight> for the packet data. Besides transferring the data portions to the buffers <highlight><bold>304</bold></highlight>, the zero copy parser <highlight><bold>110</bold></highlight> may handle control issues between the network controller and the network stack and may handle cases where an incoming packet is missing, as described below. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 5</cross-reference>, besides the components described above, the receive path <highlight><bold>92</bold></highlight> may also include one or more first-in-first-out (FIFO) memories <highlight><bold>106</bold></highlight> to synchronize the flow of incoming packets through the receive path <highlight><bold>92</bold></highlight>. A checksum engine <highlight><bold>108</bold></highlight> (of the receive path <highlight><bold>92</bold></highlight>) may be coupled to one of the FIFO memories <highlight><bold>106</bold></highlight> for purposes of verifying checksums that are embedded in the packets. The receive path <highlight><bold>92</bold></highlight> may be interfaced to a PCI bus <highlight><bold>72</bold></highlight> via the PCI interface <highlight><bold>130</bold></highlight>. The PCI interface <highlight><bold>130</bold></highlight> may include an emulated direct memory access (DMA) engine <highlight><bold>131</bold></highlight>. In this manner, for purposes of transferring the data portions of the packets directly into the buffers <highlight><bold>304</bold></highlight>, the zero copy parser <highlight><bold>110</bold></highlight> may use one of a predetermined number (sixteen, for example) of emulated DMA channels to transfer the data into the appropriate buffer <highlight><bold>304</bold></highlight>. In some embodiments, it is possible for each of the channels to be associated with a particular buffer <highlight><bold>304</bold></highlight>. However, in some embodiments, when the protocol stack (instead of the zero copy parser <highlight><bold>110</bold></highlight>) is used to transfer the data portions of the packets the DMA engine <highlight><bold>131</bold></highlight> may use a lower number (one, for example) of channels for these transfers. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> In some embodiments, the receive path <highlight><bold>92</bold></highlight> may include additional circuitry, such as a serial-to-parallel conversion circuit <highlight><bold>96</bold></highlight> that may receive a serial stream of bits from a network interface <highlight><bold>90</bold></highlight> when a packet is received from the network wire <highlight><bold>53</bold></highlight>. In this manner, the conversion circuit <highlight><bold>96</bold></highlight> packages the bits into bytes and provides these bytes to the receive parser <highlight><bold>98</bold></highlight>. The network interface <highlight><bold>90</bold></highlight> may be coupled to generate and receive signals to/from the wire <highlight><bold>53</bold></highlight>. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> In addition to the receive path <highlight><bold>92</bold></highlight>, the network controller <highlight><bold>52</bold></highlight> may include other hardware circuitry, such as a transmit path <highlight><bold>94</bold></highlight>, to transmit outgoing packets to the network. In the transmit path <highlight><bold>94</bold></highlight>, the network controller <highlight><bold>52</bold></highlight> may include a transmit parser <highlight><bold>114</bold></highlight> that is coupled to the PCI interface <highlight><bold>130</bold></highlight> to receive outgoing packet data from the computer system <highlight><bold>50</bold></highlight> and form the header on the packets. To accomplish this, in some embodiments, the transmit parser <highlight><bold>114</bold></highlight> stores the headers of predetermined flows in a header memory <highlight><bold>116</bold></highlight>. Because the headers of a particular flow may indicate a significant amount of the same information (port and IP addresses, for example), the transmit parser <highlight><bold>114</bold></highlight> may slightly modify the stored header for each outgoing packet and assemble the modified header onto the outgoing packet. As an example, for a particular flow, the transmit parser <highlight><bold>114</bold></highlight> may retrieve the header from the header memory <highlight><bold>116</bold></highlight> and parse the header to add such information as sequence and acknowledgment numbers (as examples) to the header of the outgoing packet. A checksum engine <highlight><bold>120</bold></highlight> may compute checksums for the IP and network headers of the outgoing packet and incorporate the checksums into the packet. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> The transmit path <highlight><bold>94</bold></highlight> may also include an authentication and encryption engine <highlight><bold>126</bold></highlight> that may encrypt and/or authenticate the data of the outgoing packets. In this manner, all packets of a particular flow may be encrypted (and/or authenticated) via a key that is associated with the flow, and the keys for the different flows may be stored in a key memory <highlight><bold>124</bold></highlight>. The key memory <highlight><bold>124</bold></highlight> may be accessed (by execution of the driver program <highlight><bold>57</bold></highlight>, for example) via the PCI interface <highlight><bold>130</bold></highlight>. The transmit path <highlight><bold>94</bold></highlight> may also include a parallel-to-serial conversion circuit <highlight><bold>128</bold></highlight> to serialize the data of the outgoing packets. The circuit <highlight><bold>128</bold></highlight> may be coupled to the network interface <highlight><bold>90</bold></highlight>. The transmit path <highlight><bold>94</bold></highlight> may also include one or more FIFO memories <highlight><bold>122</bold></highlight> to synchronize the flow of the packets through the transmit path <highlight><bold>94</bold></highlight>. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 5</cross-reference><highlight><italic>a</italic></highlight>, in connection with a large send, where the data received by the controller <highlight><bold>52</bold></highlight> exceeds the maximal transmit unit (MTU) (diamond <highlight><bold>502</bold></highlight>), the beginning and end of the first frame header may be identified (block <highlight><bold>504</bold></highlight>). The first frame header may be stored in the header memory <highlight><bold>116</bold></highlight> (block <highlight><bold>506</bold></highlight>). In some embodiments this may save the overhead of re-reading the header over the PCI bus in special accesses for every frame. Each ensuing header or headers (diamond <highlight><bold>508</bold></highlight>) may then be modified for only the information that is different such as the IP identification field, TCP/UDP checksum and sequence number (block <highlight><bold>510</bold></highlight>). Keeping the header in the header memory <highlight><bold>116</bold></highlight> rather than system memory saves overhead. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> A large send is a flow that helps the system with building TCP/IP headers. The system sends the controller <highlight><bold>52</bold></highlight>, through the driver, a large packet with a prototype header. The controller breaks this large packet into small MTU sized packets and updates the packet header based on the prototype header sent with the large packet (IP identification, sequence number, checksum calculation, flags and so on). </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> The controller <highlight><bold>52</bold></highlight> loads the prototype header into a header file in memory <highlight><bold>116</bold></highlight> while the parser <highlight><bold>114</bold></highlight> helps in parsing the header and informs the state machine <highlight><bold>115</bold></highlight> about offsets in the first header. The first header, i.e. the prototype header, for the first or prototype frame is different than the subsequent headers. A method of aggregating the initial header checksum with the data checksum to get an overall checksum which is not a full checksum, as illustrated in <cross-reference target="DRAWINGS">FIG. 5</cross-reference><highlight><italic>b</italic></highlight>, may save effort. The driver may compute the sixteen bit sum of the prototype header including all fixed fields and a pseudoheader (block <highlight><bold>512</bold></highlight>). </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> The pseudoheader may include the IP addresses (source and destination) and the protocol fields of the IP frame, and the TCP total length of the header, options and the data length. The TCP total length may include the TCP trailer. In this way, the processing may be done in a layered fashion, using the pseudoheader, between the IP and TCP processing and allows information not available in the original package to be handled in software. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> The hardware computes the checksum of the data and when all fields have been added (block <highlight><bold>514</bold></highlight>), the hardware performs a one&apos;s complement (block <highlight><bold>516</bold></highlight>). This method may save complexity from hardware while avoiding unnecessary hardware and software operations. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> Again for the prototype frame, only the micro-machine (state machine) <highlight><bold>115</bold></highlight> asserts a busy status bit and sets the parser <highlight><bold>114</bold></highlight> in a parse only mode. In this mode the parser <highlight><bold>114</bold></highlight> analyzes the packet header and does not forward it to the FIFO memory <highlight><bold>122</bold></highlight>. The micro-machine examines the parser results and fills in missing data (e.g. including SNAP length, IP total length, TCP sequence number, clear FIN and PSH flags, and/or UDP length and/or RTP fields) to command the checksum engine and authentication/encryption engine for later operations. It then places the parser in a normal mode and enables normal transmit operation of the transmit path <highlight><bold>94</bold></highlight>. The parser loads data from FIFO <highlight><bold>122</bold></highlight> registers to the state machine to calculate and prepare the header file for the large send transmission. The FIFO registers that are loaded include IP offset in bytes, TCP offset in bytes, and TCP/UDP&num;. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> Next, the MTU sized first packet is produced by the micro-machine commanding the DMA on the number of additional bytes to fetch from the bus <highlight><bold>72</bold></highlight>. All subsequent frames of the large send block are treated differently. First, the prototype header is fetched from the header memory <highlight><bold>116</bold></highlight>, then the micro-machine adjusts the content of all header fields subject to change (which may include the IP identification increment, and the TCP sequence number update). </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> The last frame is different. Its size may be smaller than MTU and some flags may carry different values. For this frame the micro-machine may update the SNAP length, IP total length, IP identification increment, TCP sequence number update fields, while FIN and PSH may be set in case the original prototype header had set them. The transmit path <highlight><bold>94</bold></highlight> operates in normal mode thereafter. All of the large send packet segments are treated as regular packets, subject to full or partial parsing. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> Although normally a large send is not used when the flow includes security frames, a large send may be implemented even with Encapsulating Security Payload (ESP) datagrams. The ESP specification is set forth in &ldquo;R. Atkinson, IP Encapsulating Security Payload (ESP). Request for comments (proposed standard) RFC 1827, Internet Engineering Task Force, August 1995.&rdquo; A special memory <highlight><bold>550</bold></highlight> may be provided for the trailer used with ESP datagrams. By storing the ESP trailer in the memory <highlight><bold>550</bold></highlight>, the controller hardware can then deal with security frames in large sends as described previously. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> In some embodiments, the receive parser <highlight><bold>98</bold></highlight> may include one or more state machines, counter(s) and timer(s), as examples, to perform the following functions. In particular, referring to <cross-reference target="DRAWINGS">FIG. 9</cross-reference>, the receive parser <highlight><bold>98</bold></highlight> may continually check (block <highlight><bold>200</bold></highlight>) for another unparsed incoming packet. When another packet is to be processed, the receive parser <highlight><bold>98</bold></highlight> may check the integrity of the packet, as indicated in block <highlight><bold>201</bold></highlight>. For example, the receive parser <highlight><bold>98</bold></highlight> may determine if the incoming packet includes an IP header and determine if a checksum of the IP header matches a checksum that is indicated by the IP header. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> If the receive parser <highlight><bold>98</bold></highlight> determines (diamond <highlight><bold>202</bold></highlight>) that the incoming packet passes this test, then the receive parser <highlight><bold>98</bold></highlight> may parse (block <highlight><bold>206</bold></highlight>) the header to extract the IP components of a header of the packet to obtain the information needed to determine if a flow tuple hit occurs. For example, the receive parser <highlight><bold>98</bold></highlight> may extract the network protocol being used, IP destination and source addresses, and the port destination and source addresses. Next, the receive parser <highlight><bold>98</bold></highlight> may determine if the network protocol is recognized, as indicated in diamond <highlight><bold>208</bold></highlight>. (In the case of an IPSec frame, the receive parser <highlight><bold>98</bold></highlight> may also check whether the frame uses the Authentication Header (AH) or ESP transform and compare it to the expected format stored in the tuple). If not, then the receive parser <highlight><bold>98</bold></highlight> may pass (block <highlight><bold>204</bold></highlight>) further control of the processing to the network stack. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> The receive parser <highlight><bold>98</bold></highlight> may subsequently parse (block <highlight><bold>212</bold></highlight>) the protocol header. As an example, if the packet is associated with the TCP/IP protocol, then the receive parser <highlight><bold>98</bold></highlight> may parse the TCP header of the packet, an action that may include extracting the TCP ports and security attributes of the packet, as examples. The receive parser <highlight><bold>98</bold></highlight> uses the parsed information from the protocol header to determine (diamond <highlight><bold>216</bold></highlight>) if a flow tuple hit has occurred. If not, the receiver parser <highlight><bold>98</bold></highlight> passes control of further processing of the packet to the stack, as depicted in block <highlight><bold>204</bold></highlight>. Otherwise, the receive parser <highlight><bold>98</bold></highlight> determines (diamond <highlight><bold>218</bold></highlight>) if the data portion of the packet needs to be decrypted. If so, the receive parser <highlight><bold>98</bold></highlight> determines if the associated key is available in the key memory <highlight><bold>104</bold></highlight>, as depicted in diamond <highlight><bold>220</bold></highlight>. If the key is not available, then the receive parser <highlight><bold>98</bold></highlight> may return to block <highlight><bold>204</bold></highlight> and thus, pass control of further processing of the packet to the stack. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 10</cross-reference>, if the key is available, the receive parser <highlight><bold>98</bold></highlight> may update a count of the number of received packets for the associated flow, as depicted in block <highlight><bold>224</bold></highlight>. Next, the receive parser <highlight><bold>98</bold></highlight> may determine (diamond <highlight><bold>226</bold></highlight>) whether it is time to transmit an acknowledgment packet back to the sender of the packet based on the number of received packets in the flow In this manner, if the count exceeds a predetermined number that exceeds the window (i.e., if the amount of unacknowledged transmitted data exceeds the window), then the receive parser <highlight><bold>98</bold></highlight> may either (depending on the particular embodiment) notify (block <highlight><bold>228</bold></highlight>) the driver program <highlight><bold>57</bold></highlight> (see <cross-reference target="DRAWINGS">FIG. 4</cross-reference>) or notify (block <highlight><bold>230</bold></highlight>) the transmit parser <highlight><bold>114</bold></highlight> of the need to transmit an acknowledgment packet. Thus, in the latter case, the transmit parser <highlight><bold>114</bold></highlight> may be adapted to generate an acknowledgment packet, as no data for the data portion may be needed from the application layer. The receive parser <highlight><bold>98</bold></highlight> transitions from either block <highlight><bold>228</bold></highlight> or <highlight><bold>230</bold></highlight> to diamond <highlight><bold>200</bold></highlight> to check for another received packet. After an acknowledgment packet is transmitted, the receive parser <highlight><bold>98</bold></highlight> may clear the count of received packets for that particular flow. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> Referring to <cross-reference target="DRAWINGS">FIG. 11</cross-reference>, in some embodiments, the zero copy parser <highlight><bold>110</bold></highlight> may include one or more state machines, timer(s) and counter(s) to perform the following functions to transfer the packet data directly to the buffers <highlight><bold>304</bold></highlight>. First, the zero copy parser <highlight><bold>110</bold></highlight> may determine if control of the transfer needs to be synchronized between the zero copy parser <highlight><bold>110</bold></highlight> and the stack. In this context, the term &ldquo;synchronization&rdquo; generally refers to communication between the stack and the zero copy parser <highlight><bold>110</bold></highlight> for purposes of determining a transition point at which one of the entities (the stack or the zero copy parser <highlight><bold>110</bold></highlight>) takes control from the other and begins transferring data into the buffers <highlight><bold>304</bold></highlight>. Without synchronization, missing packets may not be detected. Therefore, when control passes from the stack to the parser <highlight><bold>110</bold></highlight> (and vice versa), synchronization may need to occur, as depicted in block <highlight><bold>254</bold></highlight>. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> Thus, one scenario where synchronization may be needed is when the zero copy parser <highlight><bold>110</bold></highlight> initially takes over the function of directly transferring the data portions into the buffers <highlight><bold>304</bold></highlight>. As shown in <cross-reference target="DRAWINGS">FIG. 12</cross-reference>, in this manner, if the zero copy parser <highlight><bold>110</bold></highlight> determines (diamond <highlight><bold>250</bold></highlight>) that the current packet is the first packet being handled by the zero copy parser <highlight><bold>110</bold></highlight>, then the parser <highlight><bold>110</bold></highlight> synchronizes the packet storage, as depicted by block <highlight><bold>254</bold></highlight>. For purposes of determining when the transition occurs, the zero copy parser <highlight><bold>110</bold></highlight> may continually monitor the status of a bit that may be selectively set by the driver program <highlight><bold>57</bold></highlight>, for example. Another scenario where synchronization is needed is when an error occurs when the zero copy parser <highlight><bold>110</bold></highlight> is copying the packet data into the buffers <highlight><bold>304</bold></highlight>. For example, as a result of the error, the stack may temporarily resume control of the transfer before the zero copy parser <highlight><bold>110</bold></highlight> regains control. Thus, if the zero copy parser <highlight><bold>110</bold></highlight> determines (diamond <highlight><bold>252</bold></highlight>) that an error has occurred, the zero copy parser <highlight><bold>110</bold></highlight> may transition to the block <highlight><bold>254</bold></highlight>. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> Synchronization may occur in numerous ways. For example, the zero copy parser <highlight><bold>110</bold></highlight> may embed a predetermined code into a particular packet to indicate to the stack that the zero copy parser <highlight><bold>110</bold></highlight> handles the transfer of subsequent packets. The stack may do the same. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> Occasionally, the incoming packets of a particular flow may be received out of sequence. This may create a problem because the zero copy parser <highlight><bold>110</bold></highlight> may store the data from sequential packets one after the other in a particular buffer <highlight><bold>304</bold></highlight>. For example, packet number &ldquo;267&rdquo; may be received before packet number &ldquo;266,&rdquo; an event that may cause problems if the data for packet number &ldquo;267&rdquo; is stored immediately after the data for packet number &ldquo;265.&rdquo; To prevent this scenario from occurring, in some embodiments, the zero copy parser <highlight><bold>110</bold></highlight> may reserve a region <highlight><bold>308</bold></highlight> (see <cross-reference target="DRAWINGS">FIG. 7</cross-reference>) in the particular buffer <highlight><bold>304</bold></highlight> for the missing packet data, as indicated in block <highlight><bold>260</bold></highlight> (<cross-reference target="DRAWINGS">FIG. 11</cross-reference>). For purposes of determining the size of the missing packet (and thus, the amount of memory space to reserve), the zero copy parser <highlight><bold>110</bold></highlight> may use the sequence numbers that are indicated by the adjacent packets in the sequence. In this manner, the sequence number indicates the byte number of the next successive packet. Thus, for the example described above, the acknowledgment numbers indicated by the packet numbers &ldquo;265&rdquo; and &ldquo;267&rdquo; may be used to determine the boundaries of the region <highlight><bold>308</bold></highlight>. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> The zero copy parser <highlight><bold>110</bold></highlight> subsequently interacts with the PCI interface <highlight><bold>130</bold></highlight> to set up the appropriate DMA channel to perform a zero copy (step <highlight><bold>262</bold></highlight>) of the packet data into the appropriate buffer <highlight><bold>304</bold></highlight>. The zero copy parser <highlight><bold>110</bold></highlight> determines the appropriate buffer <highlight><bold>304</bold></highlight> via the destination port that is provided by the receive parser <highlight><bold>98</bold></highlight>. </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> Referring back to <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, besides the network controller <highlight><bold>52</bold></highlight>, the computer system <highlight><bold>50</bold></highlight> may include a processor <highlight><bold>54</bold></highlight> that is coupled to a host bus <highlight><bold>58</bold></highlight>. In this context, the term &ldquo;processor&rdquo; may generally refer to one or more central processing units (CPUs), microcontrollers or microprocessors (an X86 microprocessor, a Pentium microprocessor or an Advanced RISC Controller (ARM), as examples), as just a few examples. Furthermore, the phase &ldquo;computer system&rdquo; may refer to any type of processor-based system that may include a desktop computer, a laptop computer, an appliance or a set-top box, as just a few examples. Thus, the invention is not intended to be limited to the illustrated computer system <highlight><bold>50</bold></highlight> but rather, the computer system <highlight><bold>50</bold></highlight> is an example of one of many embodiments of the invention. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> The host bus <highlight><bold>58</bold></highlight> may be coupled by a bridge, or memory hub <highlight><bold>60</bold></highlight>, to an Advanced Graphics Port (AGP) bus <highlight><bold>62</bold></highlight>. The AGP is described in detail in the Accelerated Graphics Port Interface Specification, Revision 1.0, published in Jul. 31, 1996, by Intel Corporation of Santa Clara, Calif. The AGP bus <highlight><bold>62</bold></highlight> may be coupled to, for example, a video controller <highlight><bold>64</bold></highlight> that controls a display <highlight><bold>65</bold></highlight>. The memory hub <highlight><bold>60</bold></highlight> may also couple the AGP bus <highlight><bold>62</bold></highlight> and the host bus <highlight><bold>58</bold></highlight> to a memory bus <highlight><bold>61</bold></highlight>. The memory bus <highlight><bold>61</bold></highlight>, in turn, may be coupled to a system memory <highlight><bold>56</bold></highlight> that may, as examples, store the buffers <highlight><bold>304</bold></highlight> and a copy of the driver program <highlight><bold>57</bold></highlight>. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> The memory hub <highlight><bold>60</bold></highlight> may also be coupled (via a hub link <highlight><bold>66</bold></highlight>) to another bridge, or input/output (I/O) hub <highlight><bold>68</bold></highlight>, that is coupled to an I/O expansion bus <highlight><bold>70</bold></highlight> and the PCI bus <highlight><bold>72</bold></highlight>. The I/O hub <highlight><bold>68</bold></highlight> may also be coupled to, as examples, a CD-ROM drive <highlight><bold>82</bold></highlight> and a hard disk drive <highlight><bold>84</bold></highlight>. The I/O expansion bus <highlight><bold>70</bold></highlight> may be coupled to an I/O controller <highlight><bold>74</bold></highlight> that controls operation of a floppy disk drive <highlight><bold>76</bold></highlight> and receives input data from a keyboard <highlight><bold>78</bold></highlight> and a mouse <highlight><bold>80</bold></highlight>, as examples. </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> Other embodiments are within the scope of the following claims. For example, a peripheral device other than a network controller may implement the above-described techniques. Other network protocols and other protocol stacks may be used. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> While the invention has been disclosed with respect to a limited number of embodiments, those skilled in the art, having the benefit of this disclosure, will appreciate numerous modifications and variations therefrom. It is intended that the appended claims cover all such modifications and variations as fall within the true spirit and scope of the invention.</paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method for use with a computer system, comprising: 
<claim-text>receiving output data from the computer system; </claim-text>
<claim-text>extracting a header associated with the data; </claim-text>
<claim-text>storing the header in a header memory; </claim-text>
<claim-text>retrieving the header from header memory; and </claim-text>
<claim-text>parsing the header to add additional information to the header. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> further including determining if said data exceeds the maximal transmit unit. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference> further including determining the beginning and end of the header of the first frame of said data. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference> wherein storing a header includes storing the header at a location other than system memory. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00004">claim 4</dependent-claim-reference> further including detecting the next frame of said data and developing the header of said next frame. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference> further including adding checksum information to said header. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference> further including adding a sequence number to said header. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. An apparatus for use with a computer system comprising: 
<claim-text>an interface adapted to receive packets; and </claim-text>
<claim-text>a circuit including a header memory said circuit adapted to: 
<claim-text>receive output data from the computer system; </claim-text>
<claim-text>store a header from said data in said header memory; </claim-text>
<claim-text>retrieve the header from said header memory; and </claim-text>
<claim-text>process the header to add additional information to the header of outgoing data. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference> said circuit further adapted to determine if said data exceeds the maximal transmit unit. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00009">claim 9</dependent-claim-reference> said circuit further adapted to determine the beginning and end of the header of the first frame of said data. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference> wherein said circuit is adapted to store the header at a location other than system memory. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference>, said circuit further adapted to detect the next frame of said data and develop the header of said next frame. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, said circuit further adapted to add checksum information to said header. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The apparatus of <dependent-claim-reference depends_on="CLM-00011">claim 12</dependent-claim-reference>, said circuit further adapted to add a sequence number to said header. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. A method of developing a checksum comprising: 
<claim-text>aggregating an initial header checksum with a data checksum to develop an overall checksum; </claim-text>
<claim-text>computing a sum of the initial header including a plurality of fields and a pseudoheader; and </claim-text>
<claim-text>performing a one&apos;s complement. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference> further including using a driver to compute the sum of the prototype header and a pseudoheader. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference> further including using hardware to compute the data checksum and to perform the one&apos;s complement. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference> including performing the one&apos;s complement after all of the header fields have been added. </claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. A method of implementing a large send including security packets comprising: 
<claim-text>storing a trailer for security packets having a trailer; and </claim-text>
<claim-text>transmitting security packets and nonsecurity packets using a large send. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference> wherein storing a trailer includes storing an encapsulating security payload trailer. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. An apparatus for use with a computer system comprising: 
<claim-text>an interface to receive packets; </claim-text>
<claim-text>a memory for storing a trailer for security packets having a trailer, and </claim-text>
<claim-text>a circuit to transmit security and non-security packets using a large send.</claim-text>
</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>9</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005142A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005142A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005142A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005142A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005142A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005142A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030005142A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030005142A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030005142A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00009">
<image id="EMI-D00009" file="US20030005142A1-20030102-D00009.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00010">
<image id="EMI-D00010" file="US20030005142A1-20030102-D00010.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00011">
<image id="EMI-D00011" file="US20030005142A1-20030102-D00011.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00012">
<image id="EMI-D00012" file="US20030005142A1-20030102-D00012.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
