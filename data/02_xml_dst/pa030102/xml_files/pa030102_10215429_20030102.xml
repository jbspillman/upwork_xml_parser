<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005424A1-20030102-D00000.TIF SYSTEM "US20030005424A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005424A1-20030102-D00001.TIF SYSTEM "US20030005424A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005424A1-20030102-D00002.TIF SYSTEM "US20030005424A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005424A1-20030102-D00003.TIF SYSTEM "US20030005424A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005424A1-20030102-D00004.TIF SYSTEM "US20030005424A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030005424A1-20030102-D00005.TIF SYSTEM "US20030005424A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030005424A1-20030102-D00006.TIF SYSTEM "US20030005424A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030005424A1-20030102-D00007.TIF SYSTEM "US20030005424A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030005424A1-20030102-D00008.TIF SYSTEM "US20030005424A1-20030102-D00008.TIF" NDATA TIF>
<!ENTITY US20030005424A1-20030102-D00009.TIF SYSTEM "US20030005424A1-20030102-D00009.TIF" NDATA TIF>
<!ENTITY US20030005424A1-20030102-D00010.TIF SYSTEM "US20030005424A1-20030102-D00010.TIF" NDATA TIF>
<!ENTITY US20030005424A1-20030102-D00011.TIF SYSTEM "US20030005424A1-20030102-D00011.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005424</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10215429</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20020809</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F009/45</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>717</class>
<subclass>154000</subclass>
</uspc>
</classification-us-primary>
<classification-us-secondary>
<uspc>
<class>717</class>
<subclass>152000</subclass>
</uspc>
</classification-us-secondary>
<classification-us-secondary>
<uspc>
<class>717</class>
<subclass>146000</subclass>
</uspc>
</classification-us-secondary>
</classification-us>
<title-of-invention>Method and apparatus for generating multiple processor-specific code segments in a single executable</title-of-invention>
</technical-information>
<continuity-data>
<continuations>
<continuation-of>
<parent-child>
<child>
<document-id>
<doc-number>10215429</doc-number>
<kind-code>A1</kind-code>
<document-date>20020809</document-date>
</document-id>
</child>
<parent>
<document-id>
<doc-number>09474714</doc-number>
<document-date>19991229</document-date>
<country-code>US</country-code>
</document-id>
</parent>
<parent-status>GRANTED</parent-status>
<parent-patent>
<document-id>
<doc-number>6473897</doc-number>
<country-code>US</country-code>
</document-id>
</parent-patent>
</parent-child>
</continuation-of>
</continuations>
<continuations>
<continuation-in-part-of>
<parent-child>
<child>
<document-id>
<doc-number>09474714</doc-number>
<document-date>19991229</document-date>
<country-code>US</country-code>
</document-id>
</child>
<parent>
<document-id>
<doc-number>09059601</doc-number>
<document-date>19980413</document-date>
<country-code>US</country-code>
</document-id>
</parent>
<parent-status>GRANTED</parent-status>
<parent-patent>
<document-id>
<doc-number>6049668</doc-number>
<country-code>US</country-code>
</document-id>
</parent-patent>
</parent-child>
</continuation-in-part-of>
</continuations>
</continuity-data>
<inventors>
<first-named-inventor>
<name>
<given-name>Zia</given-name>
<family-name>Ansari</family-name>
</name>
<residence>
<residence-us>
<city>Hillsboro</city>
<state>OR</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Kevin</given-name>
<middle-name>B.</middle-name>
<family-name>Smith</family-name>
</name>
<residence>
<residence-us>
<city>Hillsboro</city>
<state>OR</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Seth</given-name>
<family-name>Abraham</family-name>
</name>
<residence>
<residence-us>
<city>Gilbert</city>
<state>AZ</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<assignee>
<organization-name>Intel Corporation</organization-name>
<assignee-type>02</assignee-type>
</assignee>
<correspondence-address>
<name-1>SCHWEGMAN, LUNDBERG, WOESSNER &amp; KLUTH, P.A.</name-1>
<name-2></name-2>
<address>
<address-1>P.O. BOX 2938</address-1>
<city>MINNEAPOLIS</city>
<state>MN</state>
<postalcode>55402</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A computer-implemented method analyzes a source code segment which is to be compiled for execution by any one of several different processor types. The method determines whether a performance advantage would be achieved by generating a customized version of object code that can be executed by one of the processor types compared with generating a non-customized version. If a performance advantage would be achieved, the method generates at least one customized object code version and a non-customized version for the source code segment, and it generates a control section that causes one of the object code versions to be called during execution of the object code in accordance with an executing processor&apos;s processor type. If no performance advantage would be achieved, the method generates a non-customized version of the object code that can be executed by any of the different processor types. </paragraph>
</subdoc-abstract>
<subdoc-description>
<cross-reference-to-related-applications>
<heading lvl="1">RELATED APPLICATION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> This application is a continuation of U.S. patent application Ser. No. 09/474,714, filed Dec. 29, 1999, which is a continuation-in-part of U.S. patent application Ser. No. 09/059,601, filed on Apr. 13, 1998 now issued as U.S. Pat. No. 6,049,668, issued Apr. 11, 2000.</paragraph>
</cross-reference-to-related-applications>
<summary-of-invention>
<section>
<heading lvl="1">TECHNICAL FIELD </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> Embodiments of the present invention pertain to compilers and software programming and, more particularly, to generating multiple processor-specific code segments in a single executable. </paragraph>
</section>
<section>
<heading lvl="1">BACKGROUND INFORMATION </heading>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> Modern computer systems can have any of a wide range and variety of configurations. One important component of a computer system is the processor, also referred to as the central processing unit (CPU). The processor executes instructions from a software program, a process referred to as &ldquo;running&rdquo; the program. Although typically all processors perform this basic task, a wide variety of different processors are available from a number of different manufacturers. These different processors, especially those from different manufacturers, have different internal designs, also referred to as the processor &ldquo;architecture&rdquo;, and thus operate in different ways. Although the results from running a program on two different processors are typically the same, the way in which the processor obtains the result, as well as its speed, typically differ. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> Many conventional processors, such as the Pentium&reg; Pro processor and Pentium&reg; processor with MMX&trade; technology (both available from Intel Corporation of Santa Clara, Calif.) are based on an architecture referred to as &ldquo;x86&rdquo;. Software programs can be written which are executable by any x86-compatible processor. However, various changes can also be made to a software program in order to allow it to be executed faster by a particular processor type. By way of example, a Pentium&reg; processor with MMX&trade; technology is capable of executing additional instructions, i.e., those associated with the MMX&trade; technology, which a Pentium&reg; Pro processor is not capable of executing. Given the advantages of using such instructions, it would be beneficial to provide a way for a programmer to include code customized to both the Pentium&reg; processor with MMX&trade; technology and the Pentium&reg; Pro processor in the same program. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> However, a software programmer also typically wants his or her code to be executable by as many processors as possible, thereby allowing a greater share of the market to purchase his or her product. This desire, then, is balanced against the programmer&apos;s desire to write code that works efficiently and makes the best use of the processor which is executing it. One way to do so is to write a separate program for each possible processor which might execute the program. However, such a solution is problemsome in that it is time-intensive and costly, often resulting in a large amount of unnecessary duplication. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> Another solution is to write a single program which includes different routines or functions designed to take advantage of the various capabilities of the processors which may run the program. However, one problem with this solution is that most programming languages do not allow multiple functions to have the same function name. Thus, the programmer must give the different functions for the different processors different names and correctly manage these different names throughout the rest of the program. This can be particularly difficult due to the requirement that all portions of the code must correctly identify the different functions by their different names. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> Thus, a need exists for an improved way to customize programs for specific processors. </paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> Embodiments of the present invention are illustrated by way of example and not limitation in the figures of the accompanying drawings in which like references indicate similar elements and in which: </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> illustrates the generation of machine executable code according to one embodiment of the present invention; </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> illustrates multiple code segments incorporating the processor-specific and dispatch constructs according to one embodiment of the present invention; </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a flowchart illustrating the steps followed in compiling high-level language according to one embodiment of the present invention; </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> illustrates sample assembly code generated according to one embodiment of the present invention; </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> illustrates an example hardware system suitable for use with one embodiment of the present invention; </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is a block diagram illustrating a device on which one embodiment of the present invention can be implemented; </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> is a flowchart illustrating the steps followed in compiling high-level language when a compiler switch for automatic CPU dispatch is turned off, according to an alternate embodiment of the invention; </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> is a flowchart illustrating the steps followed in compiling high-level language when a compiler switch for automatic CPU dispatch is set, according to an alternate embodiment of the invention; </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference> illustrates sample source code segments that can be compiled by an automatic CPU dispatch construct according to an alternate embodiment of the invention; </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10</cross-reference> illustrates sample assembly code for CPU-dispatch testing that is generated using automatic CPU dispatch according to an alternate embodiment of the invention; </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 11</cross-reference> illustrates sample assembly code optimized for a high performance CPU that is generated using automatic CPU dispatch according to an alternate embodiment of the invention; </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 12</cross-reference> illustrates sample assembly code optimized for a medium performance CPU that is generated using automatic CPU dispatch according to an alternate embodiment of the invention; and </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 13</cross-reference> illustrates sample assembly code with no CPU-specific optimizations that is generated using automatic CPU dispatch according to an alternate embodiment of the invention.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION </heading>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> In the following detailed description numerous specific details are set forth in order to provide a thorough understanding of embodiments of the present invention. However, it will be understood by those skilled in the art that embodiments of the present invention may be practiced without these specific details. In other instances well known methods, procedures, components, and circuits have not been described in detail so as not to obscure embodiments of the present invention. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> Some portions of the detailed descriptions which follow are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here, and generally, conceived to be a self-consistent sequence of steps leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually, though not necessarily, these quantities take the form of electrical or magnetic signals capable of being stored, transferred, combined, compared, and otherwise manipulated. It has proven convenient at times, principally for reasons of common usage, to refer to these signals as bits, values, elements, symbols, characters, terms, numbers, or the like. It should be borne in mind, however, that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussions, it is appreciated that throughout the present disclosure, discussions utilizing terms such as &ldquo;processing&rdquo; or &ldquo;computing&rdquo; or &ldquo;calculating&rdquo; or &ldquo;determining&rdquo; or &ldquo;displaying&rdquo; or the like, refer to the action and processes of a computer system, or similar electronic computing device, that manipulates and transforms data represented as physical (electronic) quantities within the computer system&apos;s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage, transmission or display devices. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> Modern programmers typically write programs in what are referred to as &ldquo;high-level&rdquo; programming languages. Examples of such high-level programming languages include C, C&plus;&plus;, PASCAL, and Fortran. High-level programming languages make it easier for the programmer to write his or her code; however, they also must be converted into a form which can be interpreted by a processor in order for it to run the program. The form of a program which can be interpreted by a processor is typically referred to, and will be referred to herein, as &ldquo;object code&rdquo;. (This should not be confused with an object file which contains object code.) </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> In one embodiment, the present invention allows a programmer to create multiple code segments with the same identifier but different processor-specific instructions. These code segments are typically a &ldquo;function&rdquo; or &ldquo;procedure&rdquo; of the high-level programming language in an illustrated embodiment, but they can be larger or smaller blocks of code. As used herein, &ldquo;code segment&rdquo; refers to one or more software instructions or statements. The code segment identifiers are typically the function or procedure name, but different identifiers can be used in alternate embodiments. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> Thus a programmer is able to customize different code segments, all with the same identifier, for different processor types. The object code corresponding to a particular one of these different code segments is then executed when the program runs, with the particular one of the different code segments being based on the type of processor which is running the program. Each of the several types of processors can be a different processor architecture. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> In another embodiment, the present invention comprises a computer-implemented method that analyzes a source code segment which is to be compiled for execution by any one of several different processor types. The method determines whether a performance advantage would be achieved by generating a customized version of object code that can be executed by one of the processor types compared with generating a non-customized version. If a performance advantage would be achieved, the method generates at least one customized object code version and a non-customized version for the source code segment, and it generates a control section that causes one of the one or more object code versions to be called during execution of the object code in accordance with an executing processor&apos;s processor type. If no performance advantage would be achieved, the method generates a non-customized version of the object code that can be executed by any of the different processor types. Again, each of the several types of processors can be a different processor architecture. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> illustrates the generation of machine executable code according to one embodiment of the present invention. High-level code <highlight><bold>100</bold></highlight> is coded or code generated from an application generator in a high-level programming language and is input to a compiler <highlight><bold>110</bold></highlight>. Additional functions and procedures from libraries <highlight><bold>105</bold></highlight> may also be used by compiler <highlight><bold>110</bold></highlight> in compiling high-level code <highlight><bold>100</bold></highlight>. Such additional functions are typically identified within the high-level code <highlight><bold>100</bold></highlight> and are typically general-purpose routines (for example, input/output (I/O) routines) which many programs will use. It is to be appreciated that although embodiments of the present invention are discussed with reference to the high-level code <highlight><bold>100</bold></highlight>, they may also be used with the code in the libraries <highlight><bold>105</bold></highlight>. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> Compiler <highlight><bold>110</bold></highlight> is informed of the available processor types that will execute machine-executable object code compiled by compiler <highlight><bold>110</bold></highlight>, for example by a list or table <highlight><bold>103</bold></highlight> of available processor types such as Table I discussed below. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> Compiler <highlight><bold>110</bold></highlight> generates assembly code <highlight><bold>115</bold></highlight> from high-level code <highlight><bold>100</bold></highlight> and possibly libraries <highlight><bold>105</bold></highlight>. Assembly code <highlight><bold>115</bold></highlight> provides a more human-readable version of the architectural- or processor-dependent object code, discussed below, and is also referred to as &ldquo;assembly language&rdquo;. Assembly code <highlight><bold>115</bold></highlight> can be thought of as a mid-level programming language in relation to the high-level languages discussed above. The assembly code <highlight><bold>115</bold></highlight> can optionally be saved by compiler <highlight><bold>110</bold></highlight> as a separate file during the compilation process. Some compilers <highlight><bold>110</bold></highlight> make at least two or three &ldquo;passes&rdquo; through the high-level code <highlight><bold>100</bold></highlight> when creating the assembly code <highlight><bold>115</bold></highlight>. Various customizations may also be made by compiler <highlight><bold>110</bold></highlight> in generating the assembly code <highlight><bold>115</bold></highlight> during these passes. The customizations are compiler-specific and conventionally have been identified by the programmer. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> For example, in one embodiment of the invention, the compiler <highlight><bold>110</bold></highlight>, in one pass, analyzes the high-level code <highlight><bold>100</bold></highlight> function-by-function to determine which functions, if any, represent an opportunity to take advantage of CPU-specific instructions. Examples of such CPU-specific instructions are instructions from a particular CPU&apos;s instruction set that can execute the function faster and/or more efficiently or provide data in a unique format for further processing. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> For example, a high performance CPU such as a Pentium&reg; III processor can execute vectorizable loops using single-precision floating-point single-instruction-multiple-data (SIMD) instructions, whereas a Pentium&reg; processor cannot do so. As another example, integer floating-point SIMD instructions can be processed by a Pentium&reg; III processor, a Pentium&reg; II processor, or a Pentium&reg; processor with MMX&trade; technology, but not by a Pentium&reg; Pro processor, a Pentium&reg; processor, or an Intel &reg;486 processor. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> In yet another example, a Pentium&reg; II processor or a Pentium&reg; processor with MMX&trade; technology is capable of executing instructions associated with MMX&trade; technology, which a Pentium&reg; Pro processor is not capable of executing. One of ordinary skill in the programming arts will understand how to write compiler code that implements the analytical features of embodiments of the present invention. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> Thus, in a first pass, the compiler <highlight><bold>110</bold></highlight> identifies those functions that can be optimized. Depending upon the number of CPU types that will potentially be used to execute the object code, compiler <highlight><bold>110</bold></highlight> can identify a number N of possible optimizations for any given function up to and including the number N of CPU types. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> In a subsequent pass, compiler <highlight><bold>110</bold></highlight> compiles the high-level code <highlight><bold>100</bold></highlight> into assembly code, compiling up to N separate versions, depending upon the number of opportunities for optimization. For example, if N&equals;6, i.e. there are potentially six different types of CPU&apos;s that will be used to execute the object code, there could potentially be five different customized versions of assembly code, one for each of the CPU&apos;s that have a higher performance level than the base CPU, plus one non-customized version for the lowest performance CPU. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> If compiler <highlight><bold>110</bold></highlight> determines, regarding a particular function, that customization of assembly code would not provide a sufficient performance advantage, then it compiles a non-customized version of that particular function so that it is capable of being executed by any of the N CPU types. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> It will be apparent that some compilers convert high-level code directly to object code without first converting it to assembly language, and that embodiments of the present invention are intended to cover all types of compilers. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> Assembly code <highlight><bold>115</bold></highlight> is input to an assembler <highlight><bold>120</bold></highlight>. Assembler <highlight><bold>120</bold></highlight> converts the assembly code <highlight><bold>115</bold></highlight> into machine-executable object code <highlight><bold>125</bold></highlight>. Object code <highlight><bold>125</bold></highlight> is a stream of binary values which can be executed by a processor. Object code <highlight><bold>125</bold></highlight> is also referred to as an &ldquo;executable&rdquo;. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> Except for the incorporation of the teachings of the present disclosure, compiler <highlight><bold>110</bold></highlight> and assembler <highlight><bold>120</bold></highlight> are intended to represent a wide range of compilers and assemblers well-known to those skilled in the art. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> In one illustrated embodiment, compiler <highlight><bold>110</bold></highlight> and assembler <highlight><bold>120</bold></highlight> are implemented in software. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> In one of the illustrated embodiments, two &ldquo;constructs&rdquo; are added to the high-level programming language in order to provide support for multiple code segments with the same identifier. These constructs can be incorporated into the programming language in any of a wide variety of conventional manners, including making the constructs &ldquo;extensions&rdquo; to a pre-existing language as discussed in more detail below. The first construct is a &ldquo;processor-specific&rdquo; construct which identifies a function as being specific to a particular processor type. The syntax of this processor-specific construct is: </paragraph>
<paragraph id="P-0042" lvl="1"><number>&lsqb;0042&rsqb;</number> cpu_specific (cpu_specifier) function_definition </paragraph>
<paragraph id="P-0043" lvl="7"><number>&lsqb;0043&rsqb;</number> where the &ldquo;function definition&rdquo; is the particular function being written by the programmer and the &ldquo;cpu_specifier&rdquo; is an identifier of a particular processor type for that particular function. The processor type refers to a particular processor architecture. Examples of processor types that can be supported by one implementation of the present invention are listed below in Table I. Although specific examples are listed in Table I, it should be noted that additional processor types and cpu_specifiers can be used with embodiments of the present invention, including future processor types.  
<table-cwu id="TABLE-US-00001">
<number>1</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="49PT" align="left"/>
<colspec colname="2" colwidth="168PT" align="left"/>
<thead>
<row>
<entry namest="1" nameend="2" align="center">TABLE I</entry>
</row>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
<row>
<entry>cpu_specifier</entry>
<entry>Processor Type</entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>pentium_iii</entry>
<entry>Pentium&thinsp;&reg; III processor</entry>
</row>
<row>
<entry>pentium_ii</entry>
<entry>Pentium&thinsp;&reg; II processor</entry>
</row>
<row>
<entry>pentium_pro</entry>
<entry>Pentium&thinsp;&reg; Pro processor</entry>
</row>
<row>
<entry>pentium_mmx</entry>
<entry>Pentium&thinsp;&reg; processor with MMX&thinsp;&trade; technology</entry>
</row>
<row>
<entry>pentium</entry>
<entry>Pentium&thinsp;&reg; processor</entry>
</row>
<row>
<entry>generic</entry>
<entry>A &ldquo;generic&rdquo; processor, other than one of the Pentium&thinsp;&reg;</entry>
</row>
<row>
<entry></entry>
<entry>processor family or Pentium&thinsp;&reg; Pro processor family</entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0044" lvl="7"><number>&lsqb;0044&rsqb;</number> The second construct is a &ldquo;dispatch&rdquo; construct which is used during compilation to identify the processor-specific constructs and the different processor types to which they correspond. The syntax of this dispatch construct is: </paragraph>
<paragraph id="P-0045" lvl="1"><number>&lsqb;0045&rsqb;</number> cpu_dispatch (cpu_specifier &lsqb;, cpu_specifier &lsqb;. . .&rsqb;&rsqb;) empty_function_definition </paragraph>
<paragraph id="P-0046" lvl="7"><number>&lsqb;0046&rsqb;</number> The &ldquo;empty_function_definition&rdquo; is an empty function (no code) having the same name as the function_definition. Multiple cpu_specifier identifiers may be included in the cpu_dispatch construct, one for each cpu_specific construct for the function_definition. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> According to one embodiment of the present invention, the cpu_specific and cpu_dispatch constructs are implemented as an &ldquo;extension&rdquo; to the C and C&plus;&plus; programming languages. Although these extension constructs are not part of the original programming language, they can be added to the language and used as if they were a part of the original language, such as by using the Microsoft&trade; &ldquo;_declspec&rdquo; keyword. The &ldquo;_declspec&rdquo; keyword can be used to identify a function as an extension to the language. According to one implementation, the syntax for doing so is as follows: </paragraph>
<paragraph id="P-0048" lvl="1"><number>&lsqb;0048&rsqb;</number> _declspec (cpu_specific (cpu_specifier))function definition </paragraph>
<paragraph id="P-0049" lvl="1"><number>&lsqb;0049&rsqb;</number> _declspec (cpu_dispatch (cpu_specifier &lsqb;, cpu_specifier &lsqb;. . . &rsqb;&rsqb;) </paragraph>
<paragraph id="P-0050" lvl="2"><number>&lsqb;0050&rsqb;</number> empty_function_definition </paragraph>
<paragraph id="P-0051" lvl="7"><number>&lsqb;0051&rsqb;</number> The cpu_specifier, function definition, and empty function definition are the same as discussed above. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> illustrates multiple code segments written in the C&plus;&plus; programming language incorporating the cpu_specific and cpu_dispatch constructs. As illustrated, software program <highlight><bold>200</bold></highlight> includes a first cpu_specific construct <highlight><bold>201</bold></highlight> which identifies a print_cpu function <highlight><bold>205</bold></highlight> customized to the Pentium&reg; III processor (as indicated by cpu_specifier identifier <highlight><bold>208</bold></highlight>). Similarly, program <highlight><bold>200</bold></highlight> also includes a second cpu_specific construct <highlight><bold>211</bold></highlight> which identifies a print_cpu function <highlight><bold>215</bold></highlight> customized to a Pentium&reg; II processor, a third CPU-specific construct <highlight><bold>221</bold></highlight> which identifies a print_cpu function <highlight><bold>225</bold></highlight> customized to the Pentium&reg; Pro processor, a fourth cpu_specific construct <highlight><bold>241</bold></highlight> which identifies a print_cpu function <highlight><bold>245</bold></highlight> customized to the Pentium&reg; processor with MMX&trade; technology, and a fifth print_cpu construct <highlight><bold>261</bold></highlight> which identifies a print_cpu function <highlight><bold>265</bold></highlight> customized to the Pentium&reg; processor. As illustrated, each of the five print_cpu functions has the same function name but different instructions which are customized to particular processor types. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> Software program <highlight><bold>200</bold></highlight> also includes a cpu_dispatch construct <highlight><bold>281</bold></highlight>. The cpu_dispatch construct <highlight><bold>281</bold></highlight> includes a list of identifiers which includes each of the processor types listed in the cpu_specific constructs <highlight><bold>201</bold></highlight>, <highlight><bold>211</bold></highlight>, <highlight><bold>221</bold></highlight>, <highlight><bold>241</bold></highlight>, and <highlight><bold>261</bold></highlight>. The cpu_dispatch construct <highlight><bold>281</bold></highlight> identifies a print_cpu function <highlight><bold>287</bold></highlight>, the name of which is the same as the function in the cpu_specific constructs <highlight><bold>201</bold></highlight>, <highlight><bold>211</bold></highlight>, <highlight><bold>221</bold></highlight>, <highlight><bold>211</bold></highlight>, and <highlight><bold>261</bold></highlight> The cpu_specific constructs and the cpu_dispatch constructs allow embodiments of the present invention to be used multiple times within the same program on different function names. Thus, other processor-specific functions (not shown) can be included along with constructs <highlight><bold>201</bold></highlight>, <highlight><bold>211</bold></highlight>, <highlight><bold>221</bold></highlight>, <highlight><bold>241</bold></highlight>, <highlight><bold>261</bold></highlight>, and <highlight><bold>281</bold></highlight> in program <highlight><bold>200</bold></highlight>. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> It should be noted that the cpu_specific functions <highlight><bold>201</bold></highlight>, <highlight><bold>211</bold></highlight>, <highlight><bold>221</bold></highlight>, <highlight><bold>241</bold></highlight>, and <highlight><bold>261</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 2</cross-reference> may be located adjacent one another as illustrated in program <highlight><bold>200</bold></highlight>, or alternatively may be distributed throughout different locations of program <highlight><bold>200</bold></highlight>. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a flowchart illustrating the steps followed in compiling the high-level language according to one embodiment of the present invention. During compilation, a dispatch construct is first identified, step <highlight><bold>305</bold></highlight>. In one illustrated embodiment, this is the cpu_dispatch construct <highlight><bold>281</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 2</cross-reference>. Processor-specific constructs corresponding to the dispatch construct are then identified, step <highlight><bold>310</bold></highlight>. In one illustrated embodiment, the empty_function_definition of the cpu_dispatch construct is the same name as the function_definition of the cpu_specific construct. Thus, the compiler is able to search through the high-level program to identify each of the different processor-specific constructs which correspond to the dispatch construct, which are constructs <highlight><bold>201</bold></highlight>, <highlight><bold>211</bold></highlight>, <highlight><bold>221</bold></highlight>, <highlight><bold>241</bold></highlight>, and <highlight><bold>261</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 2</cross-reference>. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> The compiler then modifies the names of each of the processor-specific functions, step <highlight><bold>315</bold></highlight>. This is done in order for the assembler to distinguish between each of the different functions. However, this step is done by the compiler and is not visible to the high-level language programmer, who views each of the functions as having the same name. In one embodiment, this is accomplished by a &ldquo;name mangling&rdquo; algorithm, which modifies function names as necessary during compilation. In this embodiment, the compiler is pre-programmed with possible processor types and an appropriate modification for each function name based on processor type. By way of example, the characters &ldquo;$B&rdquo; can be added to the end of a function name for a Pentium&reg; processor type, while the characters &ldquo;$F&rdquo; can be added to the end of a function name for a Pentium&reg; III processor type. In one illustrated embodiment, at least one character which is an invalid character for a function name in the high-level language is added to the function name in the object code. This use of an invalid high-level language character in the object code ensures that the compiler does not modify the name to be the same as another function name created by the programmer. </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> The compiler then generates multiple assembly code processor tests corresponding to the dispatch construct, step <highlight><bold>390</bold></highlight>. These multiple tests access an intel_cpu_indicator variable to identify the processor type. According to one embodiment of the present invention, the intel_cpu_indicator is a bit vector which encodes the processor type. The bit vectors and their corresponding processor types according to one embodiment of the present invention are illustrated in Table II below. Alternate embodiments can include a lesser or greater number of bits.  
<table-cwu id="TABLE-US-00002">
<number>2</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="126PT" align="left"/>
<colspec colname="2" colwidth="91PT" align="left"/>
<thead>
<row>
<entry namest="1" nameend="2" align="center">TABLE II</entry>
</row>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
<row>
<entry>Bit Vector</entry>
<entry>Processor Type</entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>00000000000000000000000000000001</entry>
<entry>generic</entry>
</row>
<row>
<entry>00000000000000000000000000000010</entry>
<entry>Pentium&thinsp;&reg; processor</entry>
</row>
<row>
<entry>00000000000000000000000000000100</entry>
<entry>Pentium&thinsp;&reg; Pro processor</entry>
</row>
<row>
<entry>00000000000000000000000000001000</entry>
<entry>Pentium&thinsp;&reg; processor with</entry>
</row>
<row>
<entry></entry>
<entry>MMX&thinsp;&trade; technology</entry>
</row>
<row>
<entry>00000000000000000000000000010000</entry>
<entry>Pentium&thinsp;&reg; II processor</entry>
</row>
<row>
<entry>00000000000000000000000000100000</entry>
<entry>Pentium&thinsp;&reg; III processor</entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> The compiler then adds a &ldquo;call to dispatch fail function&rdquo; instruction to the assembly code, step <highlight><bold>325</bold></highlight>. This dispatch fail instruction identifies a course of action to take when the processor type is not identifiable. In one illustrated embodiment, the dispatch fail instruction is a jump instruction to a dispatch fail function which is a library function that is programmer-replaceable. Thus, the programmer is able to display, for example, an error message indicating the program cannot be executed by the current processor, or alternatively provide a &ldquo;bare minimum&rdquo; amount of code which will allow the program to continue running. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> The compiler then adds a &ldquo;call to processor identification function&rdquo; instruction to the assembly code, step <highlight><bold>330</bold></highlight>. The processor identification instruction identifies a course of action to take when the processor type has not yet been identified. In one illustrated embodiment, the processor identification instruction is a call to a cpu_indicator initialization function which loads the processor type information into the intel_cpu_indicator variable. Thus, once the processor type is loaded into the intel_cpu_indicator variable, the code will be able to access and identify the processor type. </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> The cpu_indicator initialization function obtains the processor type information using the CPUID instruction, supported by many Intel processors. The CPUID instruction identifies the processor family (e.g., Pentium&reg; processor family or Pentium&reg; Pro processor family), as well as whether the processor is enabled with MMX&trade; technology (e.g., the Pentium&reg; processor with MMX&trade; technology, the Pentium&reg; II processor, or Pentium&reg; III processor), thereby indicating whether the processor type is a Pentium&reg; processor, Pentium&reg; II processor, Pentium&reg; III processor, Pentium&reg; Pro processor, or Pentium&reg; processor with MMX&trade; technology. Additional information may also be returned by the CPUID instruction, such as the stepping of the processor. This additional information can be used in alternate embodiments of the present invention to distinguish between different processor types. By way of example, a particular stepping of a processor may have a &ldquo;bug&rdquo; which is not present in subsequent steppings, and thus different code segments can be written customized to the different steppings. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> During initialization of the program, the intel_cpu_indicator variable is initialized to zero. The processor type is then stored in the intel_cpu_indicator variable when the cpu_indicator initialization function is called. Thus, in one illustrated embodiment the cpu_indicator initialization function need not be called more than once during program execution. </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> illustrates sample assembly code generated according to one embodiment of the present invention by a compiler from the program code <highlight><bold>200</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 2</cross-reference>. The assembly code provides a series of tests for processor types. The tests are performed during execution by checking a value stored at the memory location identified by intel_cpu_indicator (i.e., the intel_cpu_indicator variable). If the test succeeds, then the code jumps to the appropriate address for the beginning of the function for the identified processor type. However, if a test fails, then the code checks for another processor type. </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> As illustrated, the code initially checks with test <highlight><bold>402</bold></highlight> whether the processor type is a Pentium&reg;III processor. If the processor type is a Pentium&reg; III processor, then the jump instruction <highlight><bold>404</bold></highlight> transfers program execution to the memory location indicated by _print_cpu$F, which is the memory address of the section of code for the _print_cpu function customized to the Pentium&reg; III processor (function <highlight><bold>205</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 2</cross-reference>). The assembly code contains similar tests for the Pentium&reg; II processor, Pentium&reg; Pro processor, Pentium&reg; processor with MMX&trade; technology, and the Pentium&reg; processor. </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> The final test <highlight><bold>412</bold></highlight> checks whether there is a non-zero value stored in the intel_cpu_indicator variable. If there is a non-zero value, then jump instruction <highlight><bold>414</bold></highlight> jumps program execution to a dispatch fail function located at the address intel_cpu_dispatch_fail. However, if there is not a non-zero value stored in the intel_cpu_indicator variable, then a call <highlight><bold>416</bold></highlight> to the cpu_indicator initialization function located at the address intel_cpu_indicator is made. Upon return from the cpu_indicator initialization function, the program execution continues in a jump to test instruction <highlight><bold>402</bold></highlight>, thereby repeating the process. However, now that the intel_cpu_indicator variable has been initialized, one of the tests for processor type will be successful, indicating either a particular processor type or a dispatch fail. </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> In one illustrated embodiment, the compiler orders the test instructions so that the program execution jumps to the most &ldquo;advanced&rdquo; function (that is, the function customized to the most advanced processor architecture) which can be executed by the processor executing the program. By way of example, if two customized functions are generated, one for a Pentium&reg; processor and one for a Pentium&reg; processor with MMX&trade; technology, and if the process processor executing the program is a Pentium&reg; II processor, then the test for the Pentium&reg; processor with MMX&trade; technology is successful, thereby causing program execution to jump to the function customized for the Pentium&reg; processor with MMX&trade; technology. </paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> Also in one illustrated embodiment, the compiler orders the test instructions in the assembly code such that the highest performance processor is tested for first. This reduces the overhead (the additional tests) of embodiments of the present invention for higher performance processors. However, alternate embodiments can use different orderings. In one such alternate embodiment, the test instructions are ordered so that the most likely processor to be executing the program is tested for first. </paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> The assembly code illustrated in <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a sample of assembly code which is generated according to one embodiment of the present invention. Alternate embodiments can generate different assembly code. By way of example, the ordering of the test instructions can be changed, the test values (&minus;32, &minus;16, &minus;8, &minus;12, and &minus;2) can be changed, different types of testing or comparing instructions can be used, etc. </paragraph>
<paragraph id="P-0068" lvl="0"><number>&lsqb;0068&rsqb;</number> For ease of explanation, embodiments of the present invention have been described in terms of the assembly code generated by the compiler. Those skilled in the art will appreciate that this assembly code is subsequently converted to object code which is executed by the processor. </paragraph>
<paragraph id="P-0069" lvl="0"><number>&lsqb;0069&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> illustrates an example hardware system suitable for use with one embodiment of the present invention. Hardware system <highlight><bold>500</bold></highlight> includes processor <highlight><bold>502</bold></highlight> and cache memory <highlight><bold>504</bold></highlight> coupled to each other as shown. Additionally, hardware system <highlight><bold>500</bold></highlight> includes high performance input/output (I/O) bus <highlight><bold>506</bold></highlight> and standard I/O bus <highlight><bold>508</bold></highlight>. Host bridge <highlight><bold>510</bold></highlight> couples processor <highlight><bold>502</bold></highlight> to high performance I/O bus <highlight><bold>506</bold></highlight>, whereas I/O bus bridge <highlight><bold>512</bold></highlight> couples the two buses <highlight><bold>506</bold></highlight> and <highlight><bold>508</bold></highlight> to each other. Coupled to bus <highlight><bold>506</bold></highlight> are network network/communication interface <highlight><bold>524</bold></highlight>, system memory <highlight><bold>514</bold></highlight>, and video memory <highlight><bold>516</bold></highlight>. In turn, display device <highlight><bold>518</bold></highlight> is coupled to video memory <highlight><bold>516</bold></highlight>. Coupled to bus <highlight><bold>508</bold></highlight> are mass storage <highlight><bold>520</bold></highlight>, keyboard and pointing device <highlight><bold>522</bold></highlight>, and I/O ports <highlight><bold>526</bold></highlight>. Collectively, these elements are intended to represent a broad category of hardware systems, including but not limited to general purpose computer systems based on the Pentium&reg; processor, Pentium&reg; Pro processor, Pentium&reg; II processor, Pentium&reg; III processor, or Pentium&reg; processor with MMX&trade; technology, available from Intel Corporation of Santa Clara, Calif. </paragraph>
<paragraph id="P-0070" lvl="0"><number>&lsqb;0070&rsqb;</number> These elements <highlight><bold>502</bold></highlight>-<highlight><bold>524</bold></highlight> perform their conventional functions known in the art. In particular, network/communication interface <highlight><bold>524</bold></highlight> is used to provide communication between system <highlight><bold>500</bold></highlight> and any of a wide range of conventional networks, such as an Ethernet, token ring, the Internet, etc. It is to be appreciated that the circuitry of interface <highlight><bold>524</bold></highlight> is dependent on the type of network the system <highlight><bold>500</bold></highlight> is being coupled to. </paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> Mass storage <highlight><bold>520</bold></highlight> is used to provide permanent storage for the data and programming instructions to implement the above described functions, whereas system memory <highlight><bold>514</bold></highlight> is used to provide temporary storage for the data and programming instructions when executed by processor <highlight><bold>502</bold></highlight>. I/O ports <highlight><bold>526</bold></highlight> are one or more serial and/or parallel communication ports used to provide communication between additional peripheral devices which may be coupled to hardware system <highlight><bold>500</bold></highlight>. </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> It is to be appreciated that various components of hardware system <highlight><bold>500</bold></highlight> may be rearranged. For example, cache <highlight><bold>504</bold></highlight> may be on-chip with processor <highlight><bold>502</bold></highlight>. Alternatively, cache <highlight><bold>504</bold></highlight> and processor <highlight><bold>502</bold></highlight> may be packed together as a &ldquo;processor module&rdquo;, with processor <highlight><bold>502</bold></highlight> being referred to as the &ldquo;processor core&rdquo;. Furthermore, certain implementations of the present invention may not require nor include all of the above components. For example, mass storage <highlight><bold>520</bold></highlight>, keyboard and pointing device <highlight><bold>522</bold></highlight>, and/or display device <highlight><bold>518</bold></highlight> and video memory <highlight><bold>516</bold></highlight> may not be included in system <highlight><bold>500</bold></highlight>. Additionally, the peripheral devices shown to standard I/O bus <highlight><bold>508</bold></highlight> may be coupled to high performance I/O bus <highlight><bold>506</bold></highlight>; in addition, in some implementations only a single bus may exist with the components of hardware system <highlight><bold>500</bold></highlight> being coupled to the single bus. Furthermore, additional components may be included in system <highlight><bold>500</bold></highlight>, such as additional processors, storage devices, or memories. </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> In one embodiment, the compiling and assembling of instructions according to the present invention is implemented as a series of software routines run by hardware system <highlight><bold>500</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 5</cross-reference>. In this embodiment, compiler <highlight><bold>110</bold></highlight> and assembler <highlight><bold>120</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 1</cross-reference> are each implemented as a series of software routines. These software routines comprise a plurality or series of instructions to be executed by a processor in a hardware system, such as processor <highlight><bold>502</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 5</cross-reference>. Initially, the series of instructions are stored on a storage device, such as mass storage <highlight><bold>520</bold></highlight>. It is to be appreciated that the series of instructions can be stored using any conventional storage medium, such as a diskette, CD-ROM, magnetic tape, DVD, laser disk, ROM, flash memory, etc. It is also to be appreciated that the series of instructions need not be stored locally, and could be received from a remote storage device, such as a server on a network, via network/communication interface <highlight><bold>524</bold></highlight>. The instructions are copied from the storage device, such as mass storage <highlight><bold>520</bold></highlight>, into memory <highlight><bold>514</bold></highlight> and then accessed and executed by processor <highlight><bold>502</bold></highlight>. In one implementation, these software routines are written in the C&plus;&plus; programming language. It is to be appreciated, however, that these routines may be implemented in any of a wide variety of programming languages. </paragraph>
<paragraph id="P-0074" lvl="0"><number>&lsqb;0074&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is a block diagram illustrating a device on which one embodiment of the present invention can be implemented. The device <highlight><bold>600</bold></highlight> is meant to represent a wide variety of devices in which embodiments of the present invention can be implemented, including conventional storage media (such as a floppy disk, hard disk, or a random access memory), as well as discrete hardware or firmware. The device <highlight><bold>600</bold></highlight> includes a compiler portion <highlight><bold>602</bold></highlight> and an assembler portion <highlight><bold>604</bold></highlight>. Compiler portion <highlight><bold>602</bold></highlight> includes the instructions, to be executed by a processor, for carrying out the process of compiling a high-level language into assembly code, whereas assembler portion <highlight><bold>604</bold></highlight> includes the instructions, to be executed by a processor, for carrying out the process of converting the assembly code into object code. </paragraph>
<paragraph id="P-0075" lvl="0"><number>&lsqb;0075&rsqb;</number> According to an alternate embodiment, referred to as &ldquo;automatic CPU dispatch&rdquo;, the compiler automatically and dynamically analyzes the source code and customizes the object code for particular processor types. In this embodiment, the compiler analyzes the source code on a code segment by code segment basis to determine whether a performance advantage can be obtained over the non-customized version of the function by customizing the function to a particular processor type. If greater than a threshold performance advantage can be obtained, then the compiler compiles the source code customized for particular processor types in addition to compiling the source code for a &ldquo;generic&rdquo; processor. Otherwise, only a &ldquo;generic&rdquo;, non-processor-specific compilation is performed. </paragraph>
<paragraph id="P-0076" lvl="0"><number>&lsqb;0076&rsqb;</number> This alternate embodiment will now be described with reference to <cross-reference target="DRAWINGS">FIGS. 7 through 13</cross-reference>. </paragraph>
<paragraph id="P-0077" lvl="0"><number>&lsqb;0077&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> is a flowchart illustrating the steps followed in compiling high-level language when a compiler switch for automatic CPU dispatch is turned off, according to an alternate embodiment of the invention. The automatic CPU dispatch embodiment is implemented by a compiler that analyzes source code written for any of a set of N potential CPU types and, depending upon whether a particular compiler switch is set or turned off, either looks for opportunities to optimize the compiled code to any or all of the set of N potential CPU types, or simply compiles in the normal way, generating generic compiled code that will execute on each CPU of the set of N CPU types. </paragraph>
<paragraph id="P-0078" lvl="0"><number>&lsqb;0078&rsqb;</number> If the compiler switch is turned off, as shown in block <highlight><bold>700</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 7</cross-reference>, the compiler analyzes each source code file function-by-function (block <highlight><bold>710</bold></highlight>), compiling a generic version of each function (block <highlight><bold>720</bold></highlight>) with no CPU-specific optimization. When all functions in the particular source code file have been analyzed (block <highlight><bold>730</bold></highlight>), the method returns to block <highlight><bold>710</bold></highlight> and analyzes another source code file, until all source code files have been analyzed (block <highlight><bold>740</bold></highlight>), and the compiling method ends. </paragraph>
<paragraph id="P-0079" lvl="0"><number>&lsqb;0079&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> is a flowchart illustrating the steps followed in compiling high-level language when a compiler switch for automatic CPU dispatch is set, according to an alternate embodiment of the invention. If the compiler switch is set, as shown in block <highlight><bold>800</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 8</cross-reference>, the compiler analyzes each source code file function-by-function (block <highlight><bold>805</bold></highlight>), and the compiler determines whether there is a performance advantage in customizing a particular source code function to a particular processor type (block <highlight><bold>810</bold></highlight>). </paragraph>
<paragraph id="P-0080" lvl="0"><number>&lsqb;0080&rsqb;</number> If so, the method generates a dispatch function (block <highlight><bold>815</bold></highlight>) that indicates which processor type(s) will execute one or more object code optimizations of the function. For example, if the compiler determines that the function could be performed faster by optimizing object code for the Pentium&reg; III processor and Pentium&reg; II processor than by merely compiling generic object code, the compiler will embed a construct in the compiled code indicating which processors types to test for and which specific compiled code to call for each of those processor types. </paragraph>
<paragraph id="P-0081" lvl="0"><number>&lsqb;0081&rsqb;</number> In block <highlight><bold>820</bold></highlight>, the compiler compiles one or more CPU-specific optimized versions of the function, depending upon how many opportunities for optimization it determined in block <highlight><bold>810</bold></highlight>. The method then proceeds to block <highlight><bold>825</bold></highlight>. </paragraph>
<paragraph id="P-0082" lvl="0"><number>&lsqb;0082&rsqb;</number> If, in block <highlight><bold>810</bold></highlight>, the compiler found no opportunities for customization, the method proceeds directly to block <highlight><bold>825</bold></highlight>. In block <highlight><bold>825</bold></highlight>, the compiler compiles a generic version of the function that will execute on any processor type in the set of N processor types. In the context of the CPU&apos;s described herein, this means that the compiled function can be executed by any CPU from a Pentium&reg; processor to a Pentium&reg; III processor. </paragraph>
<paragraph id="P-0083" lvl="0"><number>&lsqb;0083&rsqb;</number> When all functions in the particular source code file have been analyzed (block <highlight><bold>830</bold></highlight>), the method returns to block <highlight><bold>805</bold></highlight> and analyzes another source code file, until all source code files have been analyzed (block <highlight><bold>835</bold></highlight>), and the compiling method ends. </paragraph>
<paragraph id="P-0084" lvl="0"><number>&lsqb;0084&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference> illustrates sample source code segments that can be compiled by an automatic CPU dispatch construct according to an alternate embodiment of the invention. The sample source code segments in <cross-reference target="DRAWINGS">FIG. 9</cross-reference> comprise a plurality of source code files, i.e. File_A, File_B, File C, through File_N, identified by <highlight><bold>900</bold></highlight>, <highlight><bold>930</bold></highlight>, <highlight><bold>940</bold></highlight>, and <highlight><bold>950</bold></highlight> respectively. Each of files <highlight><bold>900</bold></highlight>, <highlight><bold>930</bold></highlight>, <highlight><bold>940</bold></highlight>, and <highlight><bold>950</bold></highlight> can comprise one or more functions. For example, File_A (<highlight><bold>900</bold></highlight>) can comprise Function_A<highlight><subscript>&mdash;</subscript></highlight>1 (<highlight><bold>910</bold></highlight>), Function_FOO (<highlight><bold>915</bold></highlight>), and Function_A_M (<highlight><bold>920</bold></highlight>). </paragraph>
<paragraph id="P-0085" lvl="0"><number>&lsqb;0085&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10</cross-reference> illustrates sample assembly code for CPU-dispatch testing that is generated using automatic CPU dispatch according to an alternate embodiment of the invention. As in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, the assembly code provides a series of tests for processor types. The tests are performed during execution by checking a value stored at the memory location identified by intel_cpu_indicator (i.e., the intel_cpu_indicator variable). If the test succeeds, then the code jumps to the appropriate address for the beginning of the function for the identified processor type. However, if a test fails, then the code checks for another processor type. </paragraph>
<paragraph id="P-0086" lvl="0"><number>&lsqb;0086&rsqb;</number> The operation of the sample assembly code shown in <cross-reference target="DRAWINGS">FIG. 10</cross-reference> will be explained below with reference to FIGS. <highlight><bold>11</bold></highlight>-<highlight><bold>13</bold></highlight>, each of which will first be briefly described </paragraph>
<paragraph id="P-0087" lvl="0"><number>&lsqb;0087&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 11</cross-reference> illustrates sample assembly code (<highlight><bold>1105</bold></highlight>, <highlight><bold>1110</bold></highlight>) optimized for a high performance CPU that is generated using automatic CPU dispatch according to an alternate embodiment of the invention. </paragraph>
<paragraph id="P-0088" lvl="0"><number>&lsqb;0088&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 12</cross-reference> illustrates sample assembly code (<highlight><bold>1205</bold></highlight>,<highlight><bold>1210</bold></highlight>) optimized for a medium performance CPU that is generated using automatic CPU dispatch according to an alternate embodiment of the invention. </paragraph>
<paragraph id="P-0089" lvl="0"><number>&lsqb;0089&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 13</cross-reference> illustrates sample assembly code (<highlight><bold>1305</bold></highlight>,<highlight><bold>1310</bold></highlight>) with no CPU-specific optimizations that is generated using automatic CPU dispatch according to an alternate embodiment of the invention. </paragraph>
<paragraph id="P-0090" lvl="0"><number>&lsqb;0090&rsqb;</number> With reference once again to <cross-reference target="DRAWINGS">FIG. 10</cross-reference>, the code initially checks with test <highlight><bold>1000</bold></highlight> to see whether the processor type is a Pentium&reg; III processor. If the processor type is a Pentium&reg; III processor, then the jump instruction <highlight><bold>1005</bold></highlight> transfers program execution to the memory location indicated by Function_FOO_$F (<highlight><bold>1100</bold></highlight>), which is the memory address of the section of assembly code for the Function_FOO function customized to the Pentium&reg; III processor (function <highlight><bold>915</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 9</cross-reference>). The assembly code for Function_FOO_$F comprises code which has been specifically optimized for, and requires execution on, the Pentium&reg; III processor and indicated generally for illustration purposes by <highlight><bold>1105</bold></highlight> and <highlight><bold>1110</bold></highlight>. This assembly code can also be executed on future, higher performance processors, provided that they are backward-compatible with the Pentium&reg; III processor, i.e. they can execute any code that the Pentium&reg; III processor can execute. </paragraph>
<paragraph id="P-0091" lvl="0"><number>&lsqb;0091&rsqb;</number> If the processor type is not a Pentium&reg; III processor, the code next checks with test <highlight><bold>1010</bold></highlight> to see whether the processor type is a Pentium&reg; II processor. If the processor type is a Pentium&reg; II processor, then the jump instruction <highlight><bold>1015</bold></highlight> transfers program execution to the memory location indicated by Function_Foo_$E (<highlight><bold>1200</bold></highlight>), which is the memory address of the section of assembly code for the Function_FOO function customized to the Pentium&reg; II processor (function <highlight><bold>915</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 9</cross-reference>). The assembly code for Function_FOO_$E comprises code which has been specifically optimized for, and requires execution on, the Pentium&reg; II processor and indicated generally for illustration purposes by <highlight><bold>1205</bold></highlight> and <highlight><bold>1210</bold></highlight>. This optimized code can also be executed by CPU types, including future CPU types, which are more advanced than the Pentium&reg; II processor, such as the Pentium&reg; III processor, provided that they are backward-compatible with the Pentium&reg; II processor. </paragraph>
<paragraph id="P-0092" lvl="0"><number>&lsqb;0092&rsqb;</number> The final test <highlight><bold>1020</bold></highlight> checks whether the processor type has already been determined. If so, then jump instruction <highlight><bold>1025</bold></highlight> jumps program execution to the memory location indicated by Function_FOO_$B (<highlight><bold>1300</bold></highlight>), which is the memory address of the section of assembly code for the non-customized or generic version of Function_FOO, indicated generally for illustration purposes by <highlight><bold>1305</bold></highlight> and <highlight><bold>1310</bold></highlight>. This generic code can also be executed by all CPU types, including future CPU types, provided that they are backward-compatible. </paragraph>
<paragraph id="P-0093" lvl="0"><number>&lsqb;0093&rsqb;</number> If the processor type is not yet set in the intel_cpu_indicator variable, then a call <highlight><bold>1030</bold></highlight> to the intel_cpu_indicator initialization function located at the address intel_cpu_indicator_init is made. Upon return from the intel<highlight><superscript>&minus;</superscript></highlight>cpu_indicator initialization function, the program execution continues in a jump to test instruction <highlight><bold>1000</bold></highlight>, thereby repeating the process. However, now that the intel_cpu_indicator variable has been initialized, one of the tests for processor type will be successful, and the appropriate version of the object code will be executed, depending upon the processor type. </paragraph>
<paragraph id="P-0094" lvl="0"><number>&lsqb;0094&rsqb;</number> As mentioned earlier, the compiler orders the test instructions so that the program execution jumps to the most &ldquo;advanced&rdquo; function (that is, the function customized to the most advanced processor architecture) which can be executed by the processor executing the program. Also in one illustrated embodiment, the compiler orders the test instructions in the assembly code such that the highest performance processor is tested for first. This reduces the overhead (the additional tests) of such embodiment of the present invention for higher performance processors. However, alternate embodiments can use different orderings. In one such alternate embodiment, the test instructions are ordered so that the most likely processor to be executing the program is tested for first. </paragraph>
<paragraph id="P-0095" lvl="0"><number>&lsqb;0095&rsqb;</number> Embodiments of the present invention can be implemented by a computer-readable medium containing instructions for instructing a processor. The instructions can include analyzing a source code segment, and determining whether generating a customized version of object code for the source code segment to execute on one of several types of processors would provide a performance advantage over generating a non-customized version of object code. If so, the customized version of object code is generated; otherwise, the non-customized version of object code is generated. The computer-readable medium further includes computer instructions that generate a control section that causes one of the versions of object code to be called during execution in accordance with an executing processor&apos;s type. </paragraph>
<paragraph id="P-0096" lvl="0"><number>&lsqb;0096&rsqb;</number> The computer-readable medium can also include instructions that determine whether generating two or more customized versions of object code to execute on two or more types of processors would provide performance advantages over a non-customized version of object code. If so, the two or more customized versions of object code are generated; otherwise, the non-customized version of object code is generated. </paragraph>
<paragraph id="P-0097" lvl="0"><number>&lsqb;0097&rsqb;</number> A control section is generated that causes a first customized version of object code to be called during execution if the executing processor is a first type, and that causes a second customized version of object code to be called during execution if the executing processor is a second type. The control section causes a non-customized version of object code to be called during execution if the executing processor is neither the first or second type. </paragraph>
<paragraph id="P-0098" lvl="0"><number>&lsqb;0098&rsqb;</number> If the first customized version of object code is more advanced than the second customized version of object code, the control section causes the first customized version to be executed if the control section examines the processor type variable and it corresponds to a processor type that can execute either the first or second customized versions of object code. </paragraph>
<paragraph id="P-0099" lvl="0"><number>&lsqb;0099&rsqb;</number> It should be noted that, although specific syntax for an embodiment of the present invention is discussed above, alternate embodiments can use variations on this syntax. According to one such alternate embodiment, the empty function definition of the cpu_dispatch construct is not empty, rather, it contains the code the user wishes for the compiler to make processor-specific. The compiler generates a different piece of object code for each of the different processors, based on the code of the cpu_dispatch construct. Each of these different pieces of code is optimized by the compiler for the particular processor types (e.g., by setting of specific compiler switches). </paragraph>
<paragraph id="P-0100" lvl="0"><number>&lsqb;0100&rsqb;</number> Various examples of processor types are given in the discussions above. Although different Intel-architecture processors are discussed, embodiments of the present invention may also be used to customize code different manufacturers or different processor types of another manufacturer. </paragraph>
<paragraph id="P-0101" lvl="0"><number>&lsqb;0101&rsqb;</number> Additionally, embodiments of the present invention are discussed above with reference to the C or C&plus;&plus; programming language. In alternate embodiments, the processor-specific and dispatch constructs are provided in other programming languages, such as PASCAL, Fortran, Java, etc. </paragraph>
<paragraph id="P-0102" lvl="0"><number>&lsqb;0102&rsqb;</number> Furthermore, other modifications can be made by compiler <highlight><bold>110</bold></highlight> to further enhance the processor-specific customization of embodiments of the present invention. In an alternate embodiment, one such customization is the setting and clearing of particular processor optimization switches. In this embodiment, when compiling the cpu_dispatch and cpu_specific constructs, additional switches or compiler options are set by the compiler which correspond to the processor type of the function being compiled (as identified by the cpu_specific construct). These additional switches and/or compiler options cause the compiler to further customize the source code generated for the particular processor type. </paragraph>
<paragraph id="P-0103" lvl="0"><number>&lsqb;0103&rsqb;</number> In addition, embodiments of the invention can be implemented by any suitable processor or other type of computational circuit, such as but not limited to a microprocessor, a microcontroller, a complex instruction set computing (CISC) microprocessor, a reduced instruction set computing (RISC) microprocessor, a very long instruction word (VLW) microprocessor, a graphics processor, a digital signal processor, an application-specific integrated circuit (ASIC), or any other type of processor or processing circuit, or combination thereof. </paragraph>
<paragraph id="P-0104" lvl="0"><number>&lsqb;0104&rsqb;</number> Thus, embodiments of the present invention support multiple processor-specific code segments in a single executable. In one embodiment, the present invention allows a programmer to write multiple different code segments, each customized to a particular type of processor, yet each advantageously having the same identifier. During program execution, the proper customized code segment is advantageously selected based on the type of processor that is executing the program. </paragraph>
<paragraph id="P-0105" lvl="0"><number>&lsqb;0105&rsqb;</number> Additionally, in another embodiment, the present invention allows a programmer to write a single code segment and advantageously have that single code segment analyzed and customized to different object code versions, executable by different processor types, automatically by the compiler. Again, during program execution, the proper customized code segment is advantageously selected based on the type of processor that is executing the program. When a new processor type is released that has new and/or different instructions, source code programs do not have to be rewritten. Instead, a simple re-compilation is all that is necessary, assuming that a new compiler supports the desired instructions. </paragraph>
<paragraph id="P-0106" lvl="0"><number>&lsqb;0106&rsqb;</number> One significant advantage of embodiments of the present invention is that they enable independent software vendors (ISVs) to take advantage of different high performance instructions available on different types of processors while simultaneously allowing them to generate applications that can be executed on several types of processors. ISVs are more likely to take advantage of new instructions, because their application code is readily portable. </paragraph>
<paragraph id="P-0107" lvl="0"><number>&lsqb;0107&rsqb;</number> Thus, a method and apparatus for supporting and/or generating multiple processor-specific code segments in a single executable have been described. Whereas many alterations and modifications of embodiments of the present invention will be comprehended by a person skilled in the art after having read the foregoing description, it is to be understood that the particular embodiments shown and described by way of illustration are in no way intended to be considered limiting. References to details of particular embodiments are not intended to limit the scope of the claims. </paragraph>
<paragraph id="P-0108" lvl="0"><number>&lsqb;0108&rsqb;</number> It is emphasized that the Abstract is provided to comply with 37 C.F.R. &sect;1.72(b) requiring an Abstract that will allow the reader to quickly ascertain the nature and gist of the technical disclosure. It is submitted with the understanding that it will not be used to interpret or limit the scope or meaning of the claims. </paragraph>
<paragraph id="P-0109" lvl="0"><number>&lsqb;0109&rsqb;</number> In the foregoing Detailed Description, various features are grouped together in a single embodiment for the purpose of streamlining the disclosure. This method of disclosure is not to be interpreted as reflecting an intention that the claimed embodiments of the invention require more features than are expressly recited in each claim. Rather, as the following claims reflect, inventive subject matter lies in less than all features of a single disclosed embodiment. Thus the following claims are hereby incorporated into the Detailed Description, with each claim standing on its own as a separate preferred embodiment. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method comprising: 
<claim-text>analyzing a source code segment; </claim-text>
<claim-text>determining whether generating a customized version of object code for the source code segment to execute on one of several types of processors would provide a performance advantage over generating a non-customized version of object code; and </claim-text>
<claim-text>if so, generating the customized version of object code. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> further comprising: 
<claim-text>generating a non-customized version of object code that can be executed by more than one type of processor. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference> further comprising: 
<claim-text>generating a control section to examine a processor variable and to cause a version of object code to be called during execution in accordance with an executing processor&apos;s type, and wherein the control section examines the processor variable. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein, in determining, a determination is made whether generating two or more customized versions of object code to execute on two or more types of processors would provide performance advantages over a non-customized version of object code; and 
<claim-text>if so, generating the two or more customized versions of object code and a non-customized version of object code. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00004">claim 4</dependent-claim-reference> further comprising: 
<claim-text>generating a control section that causes a first customized version of object code to be called during execution if the executing processor is a first type, the control section causing a second customized version of object code to be called during execution if the executing processor is a second type, and the control section causing the non-customized version of object code to be called during execution if the executing processor is neither the first or second type. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00005">claim 5</dependent-claim-reference> wherein the first customized version of the object code is more advanced than the second customized version of object code, and wherein the control section causes the first customized version of object code to be executed if the processor type variable corresponds to a processor type that can execute either the first or second customized versions of object code. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. A system comprising: 
<claim-text>a bus coupling elements of the system; </claim-text>
<claim-text>a memory coupled to the bus to store instructions; and </claim-text>
<claim-text>a processor coupled to the bus, the processor to execute instructions to perform operations comprising: 
<claim-text>analyzing a source code segment; </claim-text>
<claim-text>determining whether generating a customized version of object code for the source code segment to execute on one of several types of processors would provide a performance advantage over generating a non-customized version of object code; and </claim-text>
<claim-text>if so, generating the customized version of object code. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference> wherein the operations further comprise the operation of generating a non-customized version of object code that can be executed by more than one type of processor. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference> wherein the operations further comprise the operation of generating a control section to examine a processor type variable, the control section to cause a version of object code to be called during execution in accordance with an executing processor&apos;s type. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. A processor to execute a compiler program to perform operations comprising: 
<claim-text>analyzing a source code segment; </claim-text>
<claim-text>determining whether generating a customized version of object code for the source code segment to execute on one of several types of processors would provide a performance advantage over generating a non-customized version of object code; and </claim-text>
<claim-text>if so, generating the customized version of object code. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The compiler program of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference> further comprising the operation of generating a non-customized version of object code that can be executed by more than one type of processor. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The compiler program of <dependent-claim-reference depends_on="CLM-00011">claim 11</dependent-claim-reference> further comprising the operation of generating a control section that causes one of the versions of object code to be called during execution in accordance with an executing processor&apos;s type. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The compiler program of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference> wherein, in determining, a determination is made whether generating two or more customized versions of object code to execute on two or more types of processors would provide performance advantages over a non-customized version of object code; and 
<claim-text>if so, the compiler program generates the two or more customized versions of object code. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The compiler program of <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference> wherein the compiler program further comprises the operation of generating a non-customized version of object code that can be executed by more than one type of processor. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The compiler program of <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference> wherein the compiler program further comprises the operation of generating a control section that causes a first customized version of object code to be called during execution if the executing processor is a first type, the control section causing a second customized version of object code to be called during execution if the executing processor is a second type, and the control section causing the non-customized version of object code to be called during execution if the executing processor is neither the first or second type. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The compiler program of <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference> wherein the control section examines a processor type variable. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The compiler program of <dependent-claim-reference depends_on="CLM-00011">claim 16</dependent-claim-reference> wherein the first customized version of the object code is more advanced than the second customized version of object code, and wherein the control section causes the first customized version of object code to be executed if the processor type variable corresponds to a processor type that can execute either the first or second customized versions of object code. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. An article comprising a computer-accessible medium having associated instructions, wherein the instructions, when accessed, result in a machine performing a method comprising: 
<claim-text>analyzing a source code segment; </claim-text>
<claim-text>determining whether generating a customized version of object code for the source code segment to execute on one of several types of processors would provide a performance advantage over generating a non-customized version of object code; and </claim-text>
<claim-text>if so, generating the customized version of object code. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The article of <dependent-claim-reference depends_on="CLM-00011">claim 18</dependent-claim-reference> wherein the method further comprises generating a non-customized version of object code. </claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The article of <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference> wherein the non-customized version of object code can be executed by more than one type of processor. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The article of <dependent-claim-reference depends_on="CLM-00022">claim 20</dependent-claim-reference> wherein the method further comprises generating a control section that causes one of the versions of object code to be called during execution in accordance with an executing processor&apos;s type. </claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The article of <dependent-claim-reference depends_on="CLM-00011">claim 18</dependent-claim-reference> wherein the determining further comprises determining whether generating two or more customized versions of object code to execute on two or more types of processors would provide performance advantages over a non-customized version of object code; and 
<claim-text>if so, generating the two or more customized versions of object code. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The article of <dependent-claim-reference depends_on="CLM-00022">claim 22</dependent-claim-reference> wherein the method further comprises generating a non-customized version of object code. </claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The article of <dependent-claim-reference depends_on="CLM-00022">claim 23</dependent-claim-reference> wherein the method further comprises: 
<claim-text>generating a control section to examine a processor type variable and to cause a first customized version of object code to be called during execution if the executing processor is a first type, the control section causing a second customized version of object code to be called during execution if the executing processor is a second type, and the control section causing the non-customized version of object code to be called during execution if the executing processor is neither the first or second type. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. The article of <dependent-claim-reference depends_on="CLM-00022">claim 24</dependent-claim-reference> wherein the first customized version of the object code is more advanced than the second customized version of object code, and wherein the control section causes the first customized version of object code to be executed if the processor type variable corresponds to a processor type that can execute either the first or second customized versions of object code.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>8</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005424A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005424A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005424A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005424A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005424A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030005424A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030005424A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030005424A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030005424A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00009">
<image id="EMI-D00009" file="US20030005424A1-20030102-D00009.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00010">
<image id="EMI-D00010" file="US20030005424A1-20030102-D00010.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00011">
<image id="EMI-D00011" file="US20030005424A1-20030102-D00011.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
