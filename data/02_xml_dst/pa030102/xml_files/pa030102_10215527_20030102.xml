<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030002502A1-20030102-D00000.TIF SYSTEM "US20030002502A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030002502A1-20030102-D00001.TIF SYSTEM "US20030002502A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030002502A1-20030102-D00002.TIF SYSTEM "US20030002502A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030002502A1-20030102-D00003.TIF SYSTEM "US20030002502A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030002502A1-20030102-D00004.TIF SYSTEM "US20030002502A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030002502A1-20030102-D00005.TIF SYSTEM "US20030002502A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030002502A1-20030102-D00006.TIF SYSTEM "US20030002502A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030002502A1-20030102-D00007.TIF SYSTEM "US20030002502A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030002502A1-20030102-D00008.TIF SYSTEM "US20030002502A1-20030102-D00008.TIF" NDATA TIF>
<!ENTITY US20030002502A1-20030102-D00009.TIF SYSTEM "US20030002502A1-20030102-D00009.TIF" NDATA TIF>
<!ENTITY US20030002502A1-20030102-D00010.TIF SYSTEM "US20030002502A1-20030102-D00010.TIF" NDATA TIF>
<!ENTITY US20030002502A1-20030102-D00011.TIF SYSTEM "US20030002502A1-20030102-D00011.TIF" NDATA TIF>
<!ENTITY US20030002502A1-20030102-D00012.TIF SYSTEM "US20030002502A1-20030102-D00012.TIF" NDATA TIF>
<!ENTITY US20030002502A1-20030102-D00013.TIF SYSTEM "US20030002502A1-20030102-D00013.TIF" NDATA TIF>
<!ENTITY US20030002502A1-20030102-D00014.TIF SYSTEM "US20030002502A1-20030102-D00014.TIF" NDATA TIF>
<!ENTITY US20030002502A1-20030102-D00015.TIF SYSTEM "US20030002502A1-20030102-D00015.TIF" NDATA TIF>
<!ENTITY US20030002502A1-20030102-D00016.TIF SYSTEM "US20030002502A1-20030102-D00016.TIF" NDATA TIF>
<!ENTITY US20030002502A1-20030102-D00017.TIF SYSTEM "US20030002502A1-20030102-D00017.TIF" NDATA TIF>
<!ENTITY US20030002502A1-20030102-D00018.TIF SYSTEM "US20030002502A1-20030102-D00018.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030002502</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10215527</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20020809</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>H04L012/56</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>370</class>
<subclass>389000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>System for recovering lost information in a data stream by means of parity packets</title-of-invention>
</technical-information>
<continuity-data>
<continuations>
<continuation-of>
<parent-child>
<child>
<document-id>
<doc-number>10215527</doc-number>
<kind-code>A1</kind-code>
<document-date>20020809</document-date>
</document-id>
</child>
<parent>
<document-id>
<doc-number>09071103</doc-number>
<document-date>19980501</document-date>
<country-code>US</country-code>
</document-id>
</parent>
<parent-status>GRANTED</parent-status>
<parent-patent>
<document-id>
<doc-number>6445717</doc-number>
<country-code>US</country-code>
</document-id>
</parent-patent>
</parent-child>
</continuation-of>
</continuations>
</continuity-data>
<inventors>
<first-named-inventor>
<name>
<given-name>William</given-name>
<middle-name>A.</middle-name>
<family-name>Gibson</family-name>
</name>
<residence>
<residence-us>
<city>Lafayette</city>
<state>CO</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>George</given-name>
<middle-name>E.</middle-name>
<family-name>Noble</family-name>
</name>
<residence>
<residence-us>
<city>Boulder</city>
<state>CO</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
<inventor>
<name>
<given-name>Chris</given-name>
<middle-name>J.</middle-name>
<family-name>Stearns</family-name>
</name>
<residence>
<residence-us>
<city>Arvada</city>
<state>CO</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>LATHROP &amp; GAGE LC</name-1>
<name-2></name-2>
<address>
<address-1>4845 PEARL EAST CIRCLE</address-1>
<address-2>SUITE 300</address-2>
<city>BOULDER</city>
<state>CO</state>
<postalcode>80301</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">Data which is transmitted over the internet or other transmission networks is first divided up into individual information packets, transmitted and then reassembled into useful data after reception. Parity packets are included in with the information packets in the transmission of data in order to enable the regeneration of any information packets which were lost or damaged during transmission. The grouping of information packets and parity packets derived therefrom is termed a chunk. Chunk arrangements to recover from all cases of single and double lost packets are disclosed. Bursts of lost packets are recovered by interleaving the transmission of packets from different chunks. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">FIELD OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> This invention relates to a method and apparatus for transmitting a data stream, (e.g., voice, video and/or data) through a Data Transmission Network and more particularly to the generation and transmission of additional parity packets and the use of the additional parity packets to reconstruct one or more information packets which are lost between transmission and reception. </paragraph>
</section>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> In Data Transmission Networks, such as the Internet, information to be transmitted is often divided into segments. The information in each segment is combined with a header which includes source and destination addressing as well as control information. This combination of information is termed a &ldquo;packet.&rdquo; A packet is transmitted through the Internet or any type of Data Transmission Network and is either received at its destination or it is lost along the way. Some causes of packet loss include transmission line errors, collisions between packets, traffic overload at a packet store-and-forward node, traffic overload at a router, or buffer overload at the sending or receiving station. Delayed forwarding of packets may cause a packet to appear so late that it is regarded as lost. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> A number of approaches have been developed in order to recover the lost information. In the Internet context, one approach is the Transmission Control Protocol (TCP) for communications between hosts in packet switched Internet protocol networks. TCP recovers data that is damaged, lost, or duplicated or delivered out of order by assigning a sequence number to each OCTET(or Byte) and requiring a positive acknowledgment from the receiving side. If the acknowledgment is not received within a time out interval, the data is retransmitted. At the receiver, the sequence numbers are used to correctly order segments that may be received out of order and to eliminate duplicates. Damage of a packet is handled by adding a check sum to each segment transmitted, checking at the receiver, and discarding damaged segments. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> The User Datagram Protocol (UDP) was created to provided a datagram mode of communication between hosts in packet switched Internet protocol networks. Damage is handled by adding a check sum to each segment transmitted, checking at the receiver, and discarding damaged segments. UDP is transaction oriented, and delivery and duplicate protection are not guaranteed. The User Datagram Protocol (UDP) is therefore not a suitable host-to-host protocol for certain applications, but it is possible to build a reliable host-to-host protocol on UDP. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> The above described recovery systems do have drawbacks. With TCP, packet loss requires retransmission for recovery. In an Internet protocol network, packets may be lost due to congestion at any of multiple places in their journey from source to destination. When a transmission is restarted, it is restarted at the first segment which has not been acknowledged. This means that not only is the lost packet retransmitted, but all packets following the lost packet are also retransmitted. A significant portion of Internet traffic (the Internet being the largest example of an Internet protocol network), is made up of packets being retransmitted. The efficiency of systems which transmit information over the Internet is significantly impaired by the retransmission of these packets. Moreover, for certain streaming applications such as various audio and video transmissions where stream continuity is an important consideration, such retransmission based recovery systems are unreliable and can substantially impair transmission fidelity. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> The invention described herein includes a method and apparatus for transmitting information in a data network from a first node to a second node. At the first (transmitting) node, the information to be transmitted is divided up into a plurality of information packets. Based on the information contained within some or all of the information packets, at least one parity packet (sometimes referred to below as a redundant packet) is generated and is included with the transmission of the information packets. When the packets reach the second (receiving) node, a check is made as to whether any of the packets have been damaged or lost. If either of these things has occurred, the parity packets are used in conjunction with the remaining transmission packets to reconstruct the packets which had been either lost or damaged. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> The present invention entails systems and processes for generating parity packets, for transmitting information packets and parity packets (collectively, &ldquo;transmission packets&rdquo;) within a network, and for using the parity packets to recover lost or damaged packets (sometimes herein collectively referred to as &ldquo;lost packets&rdquo;). In this regard, the invention may be embodied in: logic resident on a transmitting node for inter alia packetizing a data stream, generating parity packets and transmitting the transmission packets; and logic resident on a receiving node for inter alia receiving the transmission packets, identifying lost packets, using the parity packets tor generate the lost packets and recreating a data stream from the information packets. In addition, the invention may include a network structure, such as an FTP, WEB or Gigabyte Express server, for downloading transmitter/receiver logic and/or conveying transmission packet streams including parity packets between network nodes. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> The parity packets are generated as a function of the data in the information packets. In one implementation, each bit in the payload portion of the parity packets is determined as a function of the corresponding bits in at least two information packets. In one aspect of the invention, the parity packet may be generated by an exclusive OR (XOR) operation performed on the information packets. In the event that a packet is lost during transmission, an XOR can be performed between the parity packet and the remaining packets to regenerate the lost packet. It will thus be appreciated that the parity packets, sometimes referred to herein as redundant packets, are not generally duplicate packets. It will be appreciated that duplicate packets could be sent and used to replace lost packets, thereby satisfying the objective of avoiding retransmission. However, the various parity packet systems described below reduce the total amount of extra packets that must be sent, i.e., transmission overhead. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> Numerous parity packet implementations are possible. In one implementation, one parity packet is transmitted with N information packets in order to recover one lost information packet (N&plus;1: N parity). In another implementation, N parity packets are transmitted with (2<highlight><superscript>N</superscript></highlight>&minus;1)-N information packets, where N is greater than or equal to 3, in order to recover all cases of one or two lost information packets and in many cases up to N lost information packets (2<highlight><superscript>N</superscript></highlight>&minus;1: (2<highlight><superscript>N</superscript></highlight>&minus;1)-N). In any such case, the grouping of information packets and parity packets derived therefrom is termed a &ldquo;chunk&rdquo;. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> According to another aspect of the invention, M chunks can be further combined into a superchunk in which the information and parity packets of all the chunks are interleaved in such a fashion that minimizes the effect of a burst of packets being lost during transmission. When such interleaving is implemented with N&plus;1: N parity, a block of M successive packets may be lost and successfully regenerated. When interleaving is used with 2<highlight><superscript>N</superscript></highlight>&minus;1: (2<highlight><superscript>N</superscript></highlight>&minus;1)-N parity, a block of 2M successive packets may be lost and successfully regenerated. In this regard, the size of the superchunks (i.e., the number of chunks within a superchunk) can be selected to address the largest bursts of lost packets that are expected. For example, such burst events can be monitored to allow for dynamic superchunk reconfiguration, e.g., to tune the transmission structure (chunk size, superchunk size and/or parity type) based on current or historic network conditions. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> Each of the packets transmitted may contain identifying information in a header. Included in the header may be information concerning: which chunk the packet is within, the payload length of the packet, the parity type (redtype), a unique identifier of the packet, and a unique identifier of the chunk. After the information packets are received and checked, this header information may be used in an acknowledgment which may be transmitted back to the transmitting node. The choice of the parity type, the choice of N (chunk size), and the choice of M (superchunk size) may be changed dynamically as noted above, or it may be changed manually based on empirical observations.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a system diagram which includes the transmitter, the packet switched network, and the receiver. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> discloses the configuration of the transmission packets. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> discloses the payload contents of the packets, chunks and superchunks. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 4</cross-reference><highlight><italic>a </italic></highlight>and <highlight><italic>b </italic></highlight>disclose an example of the exclusive OR process in the creation of parity packets and in the recovery of information packets. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> discloses an example of a superchunk made from a 2 to 1 interleave of 2 chunks, each of which is a chunk of 12 packets with N&plus;1:N parity. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 6</cross-reference><highlight><italic>a, b, c, d, </italic></highlight>and <highlight><italic>e </italic></highlight>disclose the generation of parity packets in a 7,4 chunk. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 7</cross-reference><highlight><italic>a, b, c, d, </italic></highlight>and <highlight><italic>e </italic></highlight>disclose the parity equations for a 7,4 chunk. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 8</cross-reference><highlight><italic>a </italic></highlight>and <highlight><italic>b </italic></highlight>are flow charts describing the reconstruction of lost packets for a 7,4 chunk. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 9</cross-reference><highlight><italic>a, b, </italic></highlight>and <highlight><italic>c </italic></highlight>disclose an example of recovered information packets in a 7,4 chunk. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10</cross-reference> discloses all the possibilities for 2 lost packets in a 7,4 chunk, and the recovery of the lost packets. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 11</cross-reference><highlight><italic>a </italic></highlight>and <highlight><italic>b </italic></highlight>disclose all the possibilities for 3 lost packets in a 7,4 chunk, and the recovery of lost packets. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 12</cross-reference> illustrates a process for interleaving chunks in a superchunk. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 13</cross-reference> illustrates a network in connection with which the present invention may be implemented. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 14</cross-reference> is a table showing possible contribution patterns for generating parity packets for a particular parity type.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION </heading>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> discloses an exemplary system for transmitting data from a first node, through a packet switched Data Transmission Network, to a second node according to the present invention. Data transmission device <highlight><bold>2</bold></highlight> receives the information to be transmitted from an external data stream (e.g., an application program&mdash;usually via computer memory) and organizes it in a format to facilitate transmission. Transmission device <highlight><bold>2</bold></highlight>, then, divides and organizes in preparation for transmission. Once the information has been organized in an appropriate manner, it is sent out over packet switched Data Transmission Network <highlight><bold>16</bold></highlight>. In the preferred embodiment of the invention this Transmission Network is an internet type system, however, one skilled in the art would recognize that many types of data transmission networks can be used with the method described herein. The data transmitted over the network is received at data receiver <highlight><bold>20</bold></highlight>. The data is then checked as to whether all information that was transmitted made it through the network. The receiver <highlight><bold>20</bold></highlight> also reorganizes the information into a desirable format and if there is detection of any lost or damaged data the receiver performs operations in order to recover such information. If the recovery is not successful then retransmission occurs in the usual (as if it were Transmission Control Protocol (TCP)) way. The receiver <highlight><bold>20</bold></highlight> delivers a Receive Data Stream which is identical to the original Send Data Stream to a receiving system such as an application program (usually via computer memory). </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> In a more detailed description of the system in <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, the transmitter first receives the data stream from an application program and forms the data into blocks called &ldquo;Super Information Blocks&rdquo; (<highlight><bold>4</bold></highlight>). The Super Information Blocks are divided (<highlight><bold>6</bold></highlight>) into one or more &ldquo;Chunk Information Blocks&rdquo;. Each Chunk Information Block (<highlight><bold>8</bold></highlight>) is further divided into &ldquo;Packet Information Blocks&rdquo;. Headers are pre-pended (<highlight><bold>10</bold></highlight>) to the Packet Information Blocks, and space is reserved (<highlight><bold>12</bold></highlight>) for &ldquo;Packet Parity Blocks&rdquo;, and headers are prepended to the Packet Parity Blocks. The creation of these Packet Parity Blocks will be described in more detail in <cross-reference target="DRAWINGS">FIG. 4</cross-reference> below. After all the chunks (and packets within the chunks) of a superchunk have been formed, packets are sent to the switch network in an interleaved fashion. The packets are in the form of User Datagram Protocol (UDP) packets and the packet switch network in the illustrated embodiment is an internet protocol network. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> After transmission of the superchunks over the network, the UDP packets are received (<highlight><bold>22</bold></highlight>) and the headers are examined to associate and order (<highlight><bold>24</bold></highlight>) the received packets with other received packets which came from the same chunk. This ordering has the additional effect of undoing the (possibly) interleaved fashion in which the original superchunk was transmitted. For this reason there is no further mention of superchunks in the receiver <highlight><bold>20</bold></highlight> disclosure. The chunks are then examined (<highlight><bold>26</bold></highlight>) to detect missing packets. The header information which applies to the entire chunk is saved (<highlight><bold>28</bold></highlight>) by the receiver <highlight><bold>20</bold></highlight>. This information includes TCP and overhead information which is described in greater detail below. An attempt is made (<highlight><bold>30</bold></highlight>) to recover The Packet Information Block(s) which were originally included in lost or damaged information packets within the chunk. This information is recovered by using the combination of the Packet Information Blocks from information packets received and Packet Parity Blocks from parity packet(s) received associated with that chunk. Particular methods of accomplishing this recovery are described in FIGS. <highlight><bold>5</bold></highlight>,<highlight><bold>6</bold></highlight>,<highlight><bold>7</bold></highlight>,<highlight><bold>8</bold></highlight>, and <highlight><bold>9</bold></highlight> below. Once Chunk processing is completed successfully, the completed Chunk Information Block is included (<highlight><bold>32</bold></highlight>) into a received data stream which matches the content of the original data stream. Once receiver chunk processing is completed (whether the chunk was completely received or recovery was attempted), an acknowledgment is sent to the transmitter <highlight><bold>2</bold></highlight>. This acknowledgment contains information used by the transmitter to decide (as in TCP) when and whether to re-transmit as well as containing other information similar to that provided in TCP and RFC1323. The acknowledgment may be in a single packet chunk or incorporated in the headers of a multi-packet chunk. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> The packets which are sent across the Transmission Network can take on many types of information and many different forms, <cross-reference target="DRAWINGS">FIG. 2</cross-reference> describes in detail the structure of the transmission packets in a preferred embodiment of the invention. One skilled in the art would know that the data in the transmission packets can be organized in a multitude of different ways and what is described below is merely one embodiment. This Figure shows the new transmission control protocol (NTCP) data block arrangement within a packet. In a preferred embodiment of the invention this NTCP data block is further encapsulated within the user data protocol (UDP) which is itself encapsulated within the internet protocol (IP) for transmission over an internet protocol network. The sequence number <highlight><bold>40</bold></highlight> is similar to that used in TCP and is the sequence number of the first payload byte within the chunk. The sequence number is the same for all the packets within the same chunk. Block <highlight><bold>42</bold></highlight>, NUDPver has the value of 1 for the present version of the implementation. Future versions of the implementation which add functionality or overcome problems will need to exchange version information to interoperate, this field may be used for that exchange. The hdrlen <highlight><bold>44</bold></highlight>, has a value of 8, but it may change in future versions. The hdrlen <highlight><bold>44</bold></highlight>, similar to TCP header length, is the size of the header in 32-bit words, including options. The packet payload length <highlight><bold>48</bold></highlight> describes the size of the data portion <highlight><bold>70</bold></highlight> of the packet in bytes. This value is the same for all packets within the same chunk. In the preferred embodiment, this is an integer multiple of four and may contain values from 0 to 1432. The redtype <highlight><bold>50</bold></highlight> specifies the number of packets within a chunk, as well as the type of parity (or redundancy) for the chunk. In the preferred embodiment, all the packets within a superchunk have the same redtype. Some examples of redtypes supported in the preferred embodiment are:  
<table-cwu id="TABLE-US-00001">
<number>1</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="98PT" align="left"/>
<colspec colname="2" colwidth="119PT" align="left"/>
<thead>
<row>
<entry></entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry>redtype equals 0, no parity</entry>
<entry>(This is used in solo acknowledgment</entry>
</row>
<row>
<entry></entry>
<entry>packets)</entry>
</row>
<row>
<entry>redtype equals 66 (01 000010)</entry>
<entry>chunk size of 3 packets, including 2</entry>
</row>
<row>
<entry></entry>
<entry>information packets and 1 parity packet.</entry>
</row>
<row>
<entry></entry>
<entry>Redundancy type N &plus; 1:N,</entry>
</row>
<row>
<entry></entry>
<entry>where N &equals; 2.</entry>
</row>
<row>
<entry>redtype equals 75 (01 001011)</entry>
<entry>chunk size of 12 packets, including 11</entry>
</row>
<row>
<entry></entry>
<entry>information packets and 1 parity packet.</entry>
</row>
<row>
<entry></entry>
<entry>Redundancy type N &plus; 1:N,</entry>
</row>
<row>
<entry></entry>
<entry>where N &equals; 11.</entry>
</row>
<row>
<entry>redtype equals 131 (10 000011)</entry>
<entry>chunk size of 7 packets, including 4</entry>
</row>
<row>
<entry></entry>
<entry>information packets and 3 parity</entry>
</row>
<row>
<entry></entry>
<entry>packets.</entry>
</row>
<row>
<entry></entry>
<entry>Redundancy type 2<highlight><superscript>N </superscript></highlight>&minus; 1:2<highlight><superscript>N </superscript></highlight>&minus; 1 &minus; N</entry>
</row>
<row>
<entry></entry>
<entry>where N &equals; 3.</entry>
</row>
<row>
<entry>redtype equals 132 (10 000100)</entry>
<entry>chunk size of 15 packets, including 11</entry>
</row>
<row>
<entry></entry>
<entry>information packets and 4 parity</entry>
</row>
<row>
<entry></entry>
<entry>packets.</entry>
</row>
<row>
<entry></entry>
<entry>Redundancy type 2<highlight><superscript>N </superscript></highlight>&minus; 1:2<highlight><superscript>N </superscript></highlight>&minus; 1 &minus; N</entry>
</row>
<row>
<entry></entry>
<entry>where N &equals; 4.</entry>
</row>
<row>
<entry>redtype equals 133, (10 000101)</entry>
<entry>chunk size of 31 packets, including 26</entry>
</row>
<row>
<entry></entry>
<entry>information packets and 5 parity</entry>
</row>
<row>
<entry></entry>
<entry>packets.</entry>
</row>
<row>
<entry></entry>
<entry>Redundancy type 2<highlight><superscript>N </superscript></highlight>&minus; 1:2<highlight><superscript>N </superscript></highlight>&minus; 1 &minus; N</entry>
</row>
<row>
<entry></entry>
<entry>where N &equals; 5.</entry>
</row>
<row><entry namest="1" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> The sending side may change redtype in response to detecting retransmissions or other feedback on the progress of the data stream&apos;s transmission. In the preferred embodiment the node initiating the connection may select an initial redtype and interleave to be used as well as select &ldquo;fixed&rdquo; or &ldquo;dynamic&rdquo;. When dynamic is selected the sender counts successfully sent and acknowledged chunks which contain data since the last retransmission or link start-up. When the count exceeds a defined value (for example 30) then the redundancy may be decreased. When a retransmission is required and the count is less than a defined value (for example 10) then the redundancy may be increased. The sending side may change redtype and interleave at a superchunk boundary. In one implementation, the redundancies used are (in increasing order): </paragraph>
<paragraph id="P-0031" lvl="2"><number>&lsqb;0031&rsqb;</number> redtype&equals;75 (Send 12 to get 11), Interleave&equals;1 (1 chunk per superchunk) </paragraph>
<paragraph id="P-0032" lvl="2"><number>&lsqb;0032&rsqb;</number> redtype&equals;75 (Send 12 to get 11), Interleave&equals;2 (2 chunks per superchunk) </paragraph>
<paragraph id="P-0033" lvl="2"><number>&lsqb;0033&rsqb;</number> redtype&equals;133 (Send 31 to get 26), Interleave&equals;1 (1 chunk per superchunk) </paragraph>
<paragraph id="P-0034" lvl="2"><number>&lsqb;0034&rsqb;</number> redtype&equals;132 (Send 15 to get 11), Interleave&equals;1 (1 chunk per superchunk) </paragraph>
<paragraph id="P-0035" lvl="2"><number>&lsqb;0035&rsqb;</number> redtype&equals;132 (Send 15 to get 11), Interleave&equals;2 (2 chunks per superchunk) </paragraph>
<paragraph id="P-0036" lvl="2"><number>&lsqb;0036&rsqb;</number> redtype&equals;131 (Send 7 to get 4), Interleave&equals;2 (2 chunks per superchunk) </paragraph>
<paragraph id="P-0037" lvl="2"><number>&lsqb;0037&rsqb;</number> redtype&equals;131 (Send 7 to get 4), Interleave&equals;3 (3 chunks per superchunk) </paragraph>
<paragraph id="P-0038" lvl="7"><number>&lsqb;0038&rsqb;</number> The current embodiment illustrates connection-by-connection selection of redundancy as well as an example of changing redundancy based on observing the progress of data stream transmission once a connection has been established. One skilled in the art would know that a multitude of redtype values may defined under this invention in addition to these illustrated, the parity or redundancy alternatives can be ordered in a multitude of different ways, that different combinations of redtype and Interleave are reasonable, and that what is described above is merely one embodiment. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> Chunk length <highlight><bold>52</bold></highlight> is the number of data stream bytes contained in the chunk. The number of information packets in a chunk(specified in red type <highlight><bold>50</bold></highlight>) times the packet payload length <highlight><bold>48</bold></highlight> is greater than or equal to the chunk length <highlight><bold>52</bold></highlight>. If the product is greater, the excess is padded with zeros. The acknowledgment number <highlight><bold>54</bold></highlight> is valid if the ACK TCP flag <highlight><bold>63</bold></highlight> is a 1, and is the next sequence number which the receiver portion of the host expects to see in the next chunk it receives. The receipt of ACK packet means that sequence numbers &ldquo;less than&rdquo; acknowledgment number <highlight><bold>54</bold></highlight> have been correctly received. &ldquo;Less than&rdquo; is calculated mod (2<highlight><superscript>32</superscript></highlight>) and the window size measured in bytes is never allowed to exceed 2<highlight><superscript>30</superscript></highlight>&minus;1. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> The window <highlight><bold>56</bold></highlight> is, as in TCP, an advertisement of available buffer size by the receiving portion of the host sending the packet. The window <highlight><bold>56</bold></highlight> in the preferred embodiment is the number of packets whose payload is MSS <highlight><bold>64</bold></highlight> or less which the receiver can accommodate starting with the chunk containing the acknowledgment number in its sequence number field. In a preferred embodiment the window is a 32 bit number. The window size measured in bytes is the value in this field multiplied by the MSS. The time stamp value <highlight><bold>58</bold></highlight> is local time on the host sending the chunk. The receiving station puts this value into time stamp echo reply <highlight><bold>60</bold></highlight> on the packet (or chunk) which it sends to acknowledge receipt of the chunk. The usage of the time stamp value and time stamp echo reply are defined in RFC 1323. In this way a round-trip time may be calculated. As in TCP, the allowed time for receipt of an acknowledgment is 1.3 to 2 times the averaged round trip time. In one implementation the allowed acknowledgment time is initially set to 6 seconds with a lower bound of 2 seconds and an upper bound of 60 seconds. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> The redwhich <highlight><bold>62</bold></highlight> in combination with redtype identifies which packet of the chunk the packet is and whether it is a parity packet or an information packet. In a preferred embodiment all of the information packets within a chunk are transmitted before the parity packets within the chunk. The TCP flags <highlight><bold>63</bold></highlight> are as defined in TCP. The MSS/urgent pointer <highlight><bold>64</bold></highlight> is a MSS maximum segment size as defined in TCP whenever the URG flag in the TCP flags <highlight><bold>63</bold></highlight> is a zero. The MSS value in bytes is the NTCP max packet payload size which the receiver can accept. In the illustrated embodiment, when connecting to an internet with an Ethernet this value is 1472 bytes. The sending host is expected to adjust the packet send size so that the packet payload length <highlight><bold>48</bold></highlight> plus header length (hdrlen (<highlight><bold>44</bold></highlight>)*4) is less than or equal to the MSS requested by the receiver. If the URG flag <highlight><bold>63</bold></highlight> is one, then the field is defined as in TCP. The actual data which is transmitted via the packet is stored in the data portion <highlight><bold>70</bold></highlight>. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> Disclosed in <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is an example of a transmission packetization and arrangement performed by the transmitter <highlight><bold>2</bold></highlight>. The data arrangement for this Figure illustrates in particular the case where the payload portion of each packet is 516 bytes in length, and where redtype&equals;131, (2<highlight><superscript>N</superscript></highlight>&minus;1) are sent to recover (2<highlight><superscript>N</superscript></highlight>&minus;1)-N with the N&equals;3 parity, is selected so that each chunk contains seven packets (three of them parity), and the superchunk interleave is 3:1 so that 3 chunks make up a superchunk. The bytes within the send data stream are sequentially numbered for this example starting at zero. The send data stream is segmented into Super Information Blocks of 6,192 bytes each, with each Super Information Block being further divided into three chunk information blocks <highlight><bold>80</bold></highlight>, <highlight><bold>82</bold></highlight>, and <highlight><bold>84</bold></highlight> of 2,064 bytes each. Each chunk information block is further divided into 4 information packets of 516 bytes each. The three chunks <highlight><bold>86</bold></highlight>, <highlight><bold>88</bold></highlight>, and <highlight><bold>90</bold></highlight> are contained within the superchunk <highlight><bold>92</bold></highlight>. The seven packets within each chunks are comprised of four information packets and three parity packets. Each packet is comprised of a header and 516 bytes of payload. For the information packets, the payload is comprised of bytes from the data stream. To aid in understanding the blocking of the data stream bytes through the process, each information packet is identified by the sequence numbers from the data stream which are contained in that packet. Each parity packet is identified by the 3 sequence numbers of the first bytes contained in the information packets from which that parity packet was formed. Thus the payload of the parity packet identified &ldquo;P 2064, 2580, 3612&rdquo; was formed from the exclusive OR of the payloads of the 3 information packets <highlight><bold>2064</bold></highlight>-<highlight><bold>2579</bold></highlight>, <highlight><bold>2580</bold></highlight>-<highlight><bold>3095</bold></highlight>, and <highlight><bold>3612</bold></highlight>-<highlight><bold>4127</bold></highlight>. The 21 packets of the superchunk <highlight><bold>92</bold></highlight> are transmitted in an interleaved fashion over the network. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> As was mentioned above, the parity bytes which are included in the chunks with the data bytes are generated by performing particular mathematical functions on all or a portion of the data bytes included in the information packets. These parity bytes are used at the receiving end of the transmission to reconstruct lost or damaged information packets. The diagrams in <cross-reference target="DRAWINGS">FIGS. 4</cross-reference><highlight><italic>a </italic></highlight>and <highlight><bold>4</bold></highlight><highlight><italic>b </italic></highlight>are examples of the creation of parity packets, and the use of parity packets to recover lost information packets. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> Described below is the exclusive or (XOR) calculation method for recovering lost or damaged information packets. In the method illustrated in <cross-reference target="DRAWINGS">FIGS. 4</cross-reference><highlight><italic>a </italic></highlight>and <highlight><bold>4</bold></highlight><highlight><italic>b, </italic></highlight>N&plus;1 packets are transmitted in order to receive N packets (N&plus;1:N parity). In other words, one parity packet is generated within each chunk in order to recover one lost or damaged information packet at the receiver. Blocks <highlight><bold>100</bold></highlight> and <highlight><bold>102</bold></highlight> shown in <cross-reference target="DRAWINGS">FIG. 4</cross-reference><highlight><italic>a </italic></highlight>are a hypothetical configuration of bits which would be included in the data portion <highlight><bold>70</bold></highlight> of each information packet which is sent. In this example, the data portion of each transmission packet is a four-by-four 16-bit array. In this embodiment, three transmission packets are included in each chunk in order to assure the receiving of two information packets. In order to create parity packet <highlight><bold>104</bold></highlight>, an XOR operation is performed between corresponding bits in transmission packets <highlight><bold>100</bold></highlight> and <highlight><bold>102</bold></highlight>. An XOR operation is merely one way in which this parity packet can be created. One skilled in the art would realize that a variety of mathematical functions could be used to generate a parity packet which would serve the same purpose. After the parity packet is created it is combined with the chunk, which is in turn transmitted over the data network. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> For N&plus;1:N parity, the chunking process simply involves dividing the data stream at each N packets and using an XOR or other operation as described above to generate a parity packet for the chunk. A slightly more complicated chunking process is required for 2<highlight><superscript>N</superscript></highlight>&minus;1:(2<highlight><superscript>N</superscript></highlight>&minus;1)-N parity. In particular, proper parity packet generation and lost packet recovery can be assured by establishing parity packets according to the following rules: 1) each information packet participates in establishing at least two parity packets; and 2) each of the parity packets is generated through the use of a unique combination of information packet participation. The possible combinations for satisfying these conditions are illustrated in <cross-reference target="DRAWINGS">FIG. 14</cross-reference> for the case of 2<highlight><superscript>N</superscript></highlight>&minus;1:(2<highlight><superscript>N</superscript></highlight>&minus;1)-N parity for N&equals;3. That is, <cross-reference target="DRAWINGS">FIG. 14</cross-reference> shows combinations for sending chunks of 7 packets (4 information packets&plus;3 parity packets) to receive 4 packets. In the figure, the rows indicate a particular packet, and columns indicate different patterns of participation. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> The rows of <cross-reference target="DRAWINGS">FIG. 14</cross-reference> are generated by base <highlight><bold>2</bold></highlight> counting from 000 to 111. The rows are examined for those which have only one &ldquo;0.&rdquo; Those rows are associated sequentially with parity packets. The rows are then examined for those which have 2 or more &ldquo;0&rdquo;&apos;s. Rows with two or more &ldquo;0&rdquo;&apos;s are associated sequentially with information packets. Each parity packet is generated from those information packets which have &ldquo;0&rdquo; in the same column as the parity packet&apos;s &ldquo;0.&rdquo; For purpose of reference, the rows are numbered (in base <highlight><bold>10</bold></highlight>) 1-8. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> It will be observed that there are 2<highlight><superscript>N </superscript></highlight>rows, one of which has no &ldquo;0&rdquo;&apos;s. Thus, there are 2<highlight><superscript>N</superscript></highlight>&minus;1 rows with at least one &ldquo;0&rdquo;. There are N rows with only one &ldquo;0&rdquo;, and there are 2<highlight><superscript>N</superscript></highlight>&minus;1-N rows with two or more &ldquo;0&rdquo;&apos;s. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> Where &oplus; indicates an XOR operation: </paragraph>
<paragraph id="P-0049" lvl="2"><number>&lsqb;0049&rsqb;</number> P<highlight><bold>1</bold></highlight> has a &ldquo;0&rdquo; in the left most column, as do I<highlight><subscript>1</subscript></highlight>, I<highlight><subscript>2</subscript></highlight>, and I<highlight><subscript>3</subscript></highlight>, giving P<highlight><bold>1</bold></highlight>&equals;I<highlight><subscript>1</subscript></highlight>&oplus;I<highlight><subscript>2</subscript></highlight>&oplus;I<highlight><subscript>3 </subscript></highlight></paragraph>
<paragraph id="P-0050" lvl="2"><number>&lsqb;0050&rsqb;</number> P<highlight><bold>2</bold></highlight> has a &ldquo;0&rdquo; in the central column, as do I<highlight><subscript>1</subscript></highlight>, I<highlight><subscript>2</subscript></highlight>, and I<highlight><subscript>4</subscript></highlight>, giving P<highlight><bold>2</bold></highlight>&equals;I<highlight><subscript>1</subscript></highlight>&oplus;I<highlight><subscript>2</subscript></highlight>&oplus;I<highlight><subscript>4 </subscript></highlight></paragraph>
<paragraph id="P-0051" lvl="2"><number>&lsqb;0051&rsqb;</number> P<highlight><bold>3</bold></highlight> has a &ldquo;0&rdquo; in the right most column, as do I<highlight><subscript>1</subscript></highlight>, I<highlight><subscript>3</subscript></highlight>, and I<highlight><subscript>4</subscript></highlight>, giving P<highlight><bold>3</bold></highlight>&equals;I<highlight><subscript>1</subscript></highlight>&oplus;I<highlight><subscript>3</subscript></highlight>&oplus;I<highlight><subscript>4 </subscript></highlight></paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> For all values of N, enumerating by base <highlight><bold>2</bold></highlight> counting of N columns, makes 2<highlight><superscript>N </superscript></highlight>unique rows, and results in one row with no zeros, N rows with one zero, and 2<highlight><superscript>N</superscript></highlight>&minus;1-N rows with a unique pattern of 2 or more zeros. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> It may also be observed that each column has half zeros and half ones, or 2<highlight><superscript>(N&minus;1) </superscript></highlight>zeros. Of those 2<highlight><superscript>(N&minus;1) </superscript></highlight>rows with zeros in them one is assigned as a parity which is then derived from the other 2<highlight><superscript>(N&minus;1)</superscript></highlight>&minus;1 which are assigned as information packets. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> When the transmission packets are received, the chunks are checked as to whether any of the transmission packets have been damaged or destroyed. As in TCP, packet loss is detected if expected packets don&apos;t arrive in the allowed time. In one implementation, the time of arrival from the first packet in a chunk to the last packet in the chunk is chunk build time, and the allowed time for receipt of all packets within a chunk is 1.2 times the averaged chunk build time. The allowed time before declaring a packet lost is initially set to 1 second with a lower bound to 0.25 seconds and an upper bound to 10 seconds. If an information packet has been lost or damaged the parity packet is used in conjunction with the remaining information packets to restore it. In the example of <cross-reference target="DRAWINGS">FIG. 4</cross-reference><highlight><italic>b, </italic></highlight>the 102 information packet has been lost. In order to restore this information packet, an XOR operation is performed between the parity packet <highlight><bold>104</bold></highlight> and the remaining information <highlight><bold>100</bold></highlight>. Through this operation, all the bits in information packet <highlight><bold>102</bold></highlight> are restored. As was mentioned previously, the N&plus;1:N process can only be used to recover a single transmission packet at the receiver. Based on the type of problems which may be encountered while transmitting data, it may be desirable to provide methods in which multiple packets can be restored. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> The types of problems in a packet switched network may be characterized by the combination of a packet loss rate (a long term count of packets lost divided by the long term count of packets transmitted) and a packet burst loss rate. A packet loss rate of 1 in 30 doesn&apos;t tell us whether the losses are evenly spread, randomly spread, or tend to occur in clumps. The superchunk 2:1 interleave disclosed in <cross-reference target="DRAWINGS">FIG. 5</cross-reference> illustrates how the low overhead N&plus;1:N parity approach can recover from lost packets occurring in pairs. Chunk <highlight><bold>106</bold></highlight> consists of 11 information packets and 1 parity packet, Chunk <highlight><bold>108</bold></highlight> also consists of 11 information packets and one parity packet. The packets from the two chunks are arranged in Superchunk <highlight><bold>110</bold></highlight> to be transmitted on the network in interleaved order. Any pair of adjacent packets may be lost in transmission but recovered by the receiver. The preferred embodiment has the same redtype for all of the chunks in the same superchunk. This simplifies the interleaving (since all of the chunks in the same superchunk have the same number of packets and the interleaving comes out even) and it simplifies the decision of when to change redtype and interleave to adjust redundancy. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> Those skilled in the art will recognize it is possible to perform interleaving in a number of ways and recover any defined number of packets lost in a burst so long as the number of chunks being interleaved exceeds the burst length to be recovered and the overall packet loss rate is acceptably low. For the interleaving to come out even on superchunk boundaries is a convenience. <cross-reference target="DRAWINGS">FIG. 12</cross-reference> illustrates how interleaving three chunks in a superchunk allows for recovery of a burst of three lost packets using, in the illustrated case, N&plus;1:N parity where N&equals;2. Block <highlight><bold>200</bold></highlight> shows an input packetized data stream. The packets are divided into three chunks <highlight><bold>202</bold></highlight>, <highlight><bold>204</bold></highlight> and <highlight><bold>206</bold></highlight>, which are then interleaved to form three interleaved chunks <highlight><bold>208</bold></highlight>, <highlight><bold>210</bold></highlight>, and <highlight><bold>212</bold></highlight> of superchunk <highlight><bold>214</bold></highlight>. Chunk <highlight><bold>202</bold></highlight> also includes a parity packet PA derived from packets A<highlight><subscript>1 </subscript></highlight>and A<highlight><subscript>2</subscript></highlight>. Chunk <highlight><bold>204</bold></highlight> also includes a parity packet PB derived from packets B<highlight><subscript>1 </subscript></highlight>and B<highlight><subscript>2</subscript></highlight>. Chunk <highlight><bold>206</bold></highlight> also includes a parity packet PC derived from packets C<highlight><subscript>1 </subscript></highlight>and C<highlight><subscript>2</subscript></highlight>. The phantom box <highlight><bold>218</bold></highlight> in block <highlight><bold>214</bold></highlight> indicates a burst of three lost packets, C<highlight><subscript>1</subscript></highlight>, A<highlight><subscript>2 </subscript></highlight>and B<highlight><subscript>2</subscript></highlight>. These packets could not be regenerated using N&plus;1:N redundancy without interleaving as more than one packet is missing. However, after interleaving, each interleaved chunk includes only one lost packet which can be regenerated using the corresponding parity packet. It will thus be appreciated that, by selecting the superchunk size so that the number of chunks per superchunk is at least as great as the anticipated maximum number of lost packets in a burst, burst events can effectively addressed. </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> Disclosed in <cross-reference target="DRAWINGS">FIGS. 6</cross-reference><highlight><italic>a, b, c, </italic></highlight>and <highlight><italic>d </italic></highlight>is the calculation of the contents of the payload portion for the three parity packets within a 7,4 Chunk. <cross-reference target="DRAWINGS">FIG. 6</cross-reference><highlight><italic>a </italic></highlight>discloses a data stream of 15 bytes which is to be transmitted over the network. This stream is divided into 4 data payloads of 4 bytes each in Information packets <highlight><bold>0</bold></highlight>, <highlight><bold>1</bold></highlight>, <highlight><bold>2</bold></highlight>, and <highlight><bold>3</bold></highlight> (one byte of padding is added to Information packet <highlight><bold>3</bold></highlight> to make the payloads match in length). <cross-reference target="DRAWINGS">FIG. 6</cross-reference><highlight><italic>b </italic></highlight>discloses the binary content of each of the information packets created from the data stream. As was described above, an XOR is performed on the information packets in order to generate the parity packets. As shown in <cross-reference target="DRAWINGS">FIG. 6</cross-reference><highlight><italic>c, </italic></highlight>the payload portion of parity packet <highlight><bold>4</bold></highlight> is calculated by performing an XOR on the payload portion of information packets <highlight><bold>0</bold></highlight>, <highlight><bold>1</bold></highlight>, and <highlight><bold>2</bold></highlight>. Similarly, in <cross-reference target="DRAWINGS">FIG. 6</cross-reference><highlight><italic>c </italic></highlight>the payload portion of parity packet <highlight><bold>5</bold></highlight> is calculated with the XOR of the payload portions of information packets <highlight><bold>0</bold></highlight>, <highlight><bold>1</bold></highlight>, and <highlight><bold>3</bold></highlight>. Finally, the payload portion of parity packet <highlight><bold>6</bold></highlight> is derived from the payload portions of information packets <highlight><bold>0</bold></highlight>, <highlight><bold>2</bold></highlight>, and <highlight><bold>3</bold></highlight>, as shown in <cross-reference target="DRAWINGS">FIG. 6</cross-reference><highlight><italic>e. </italic></highlight></paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> When the information packets are transmitted over the network and received at the data receiver, the possibility exists that some of the transmission packets may be lost (or damaged and lost by discarding). If some of the packets have been lost they may be constructed through the use of the packets which were received intact. Each information packet that was transmitted can be constructed by performing an XOR on a particular combination of the transmission packets. Shown in <cross-reference target="DRAWINGS">FIGS. 7</cross-reference><highlight><italic>a, b, c, </italic></highlight>and <highlight><italic>d </italic></highlight>are instructions for the re-writing of the parity generation described in <cross-reference target="DRAWINGS">FIGS. 6</cross-reference><highlight><italic>c, d, </italic></highlight>and <highlight><italic>e. </italic></highlight>These instructions facilitate solving for payloads from lost packets. Not all possible re-writings of the parity generation are shown, the subset chosen provides for error correction which is not inferior to other subsets which could have been chosen. The table in <cross-reference target="DRAWINGS">FIG. 7</cross-reference><highlight><italic>a </italic></highlight>discloses a combination of received transmission packets sufficient to recreate the payload of packet <highlight><bold>0</bold></highlight>. Specifically, the payload of information packet <highlight><bold>0</bold></highlight> may be recovered first if information packets <highlight><bold>1</bold></highlight> and <highlight><bold>2</bold></highlight> and parity packet <highlight><bold>4</bold></highlight> had been correctly received, second if information packets <highlight><bold>1</bold></highlight> and <highlight><bold>3</bold></highlight> and parity packet <highlight><bold>5</bold></highlight> had been correctly received, third if information packets <highlight><bold>2</bold></highlight> and <highlight><bold>3</bold></highlight> and parity packet <highlight><bold>6</bold></highlight> had been correctly received, and fourth if parity packets <highlight><bold>4</bold></highlight>,<highlight><bold>5</bold></highlight> and <highlight><bold>6</bold></highlight> had been correctly received. The table in <cross-reference target="DRAWINGS">FIG. 7</cross-reference><highlight><italic>b </italic></highlight>discloses a combination of received transmission packets sufficient to recreate the payload of packet <highlight><bold>1</bold></highlight>. Specifically, the payload of information packet <highlight><bold>1</bold></highlight> may be recovered first if information packets <highlight><bold>0</bold></highlight> and <highlight><bold>2</bold></highlight> and parity packet <highlight><bold>4</bold></highlight> had been correctly received, and second if information packets <highlight><bold>0</bold></highlight> and <highlight><bold>3</bold></highlight> and parity packet <highlight><bold>5</bold></highlight> had been correctly received. The table in <cross-reference target="DRAWINGS">FIG. 7</cross-reference><highlight><italic>c </italic></highlight>discloses a combination of received transmission packets sufficient to recreate the payload of information packet <highlight><bold>2</bold></highlight>. Specifically, the payload of information packet <highlight><bold>2</bold></highlight> may be recovered first if information packets <highlight><bold>0</bold></highlight> and <highlight><bold>1</bold></highlight> and parity packet <highlight><bold>4</bold></highlight> had been correctly received, and second if information packets <highlight><bold>0</bold></highlight> and <highlight><bold>3</bold></highlight> and parity packet <highlight><bold>6</bold></highlight> had been correctly received. The table in <cross-reference target="DRAWINGS">FIG. 7</cross-reference><highlight><italic>d </italic></highlight>discloses a combination of received transmission packets sufficient to recreate the payload of information packet <highlight><bold>3</bold></highlight>. Specifically the payload of information packet <highlight><bold>3</bold></highlight> may be recovered first if information packets <highlight><bold>0</bold></highlight> and <highlight><bold>1</bold></highlight> and parity packet <highlight><bold>5</bold></highlight> had been correctly received, and second if information packets <highlight><bold>0</bold></highlight> and <highlight><bold>2</bold></highlight> and parity packet <highlight><bold>6</bold></highlight> had been correctly received. The table in <cross-reference target="DRAWINGS">FIG. 7</cross-reference><highlight><italic>e </italic></highlight>shows a sufficient set of the parity relationships represented by the generation equations of <cross-reference target="DRAWINGS">FIGS. 6</cross-reference><highlight><italic>a, b, </italic></highlight>and <highlight><italic>c </italic></highlight>combined with the solving equations in <cross-reference target="DRAWINGS">FIGS. 7</cross-reference><highlight><italic>a,b,c, </italic></highlight>and <highlight><italic>d </italic></highlight>in a more convenient table called &ldquo;parity truths&rdquo;. There is one &ldquo;parity truths&rdquo; table for each redtype. One implementation has two columns in the parity truth table, the first parity entry in each parity truths table being 32 bits in length. The bits are numbered 0 through 31, with the least significant bit being numbered 0. Binary &ldquo;1&rdquo;&apos;s are placed in the bit position corresponding to that packet number&apos;s participation in the equation. The table in <cross-reference target="DRAWINGS">FIG. 7</cross-reference><highlight><italic>e </italic></highlight>also shows the same information in hexadecimal notation. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> is a flowchart of an algorithm which implements recovery of lost information packets for the case of redtype 131. The flowchart is derived from the parity truths in <cross-reference target="DRAWINGS">FIG. 7</cross-reference>. In one implementation there is a separate software module for each redtype which incorporates the information for recovery which is particular to that redtype. To begin the analysis, a query is made at step <highlight><bold>136</bold></highlight> as to whether packet <highlight><bold>0</bold></highlight> is present. If packet <highlight><bold>0</bold></highlight> is present, the analysis continues at step <highlight><bold>150</bold></highlight>. If packet <highlight><bold>0</bold></highlight> is not present, an attempt is then made to reconstruct the missing packet as was described above. The first step in doing this reconstruction is to determine whether the necessary packets survived transmission over the data network. To begin this determination, a query is made at step <highlight><bold>138</bold></highlight> as to whether packets <highlight><bold>1</bold></highlight>, <highlight><bold>2</bold></highlight> and <highlight><bold>4</bold></highlight> are present. These packets are one of the sets which need to be all present in order to reconstruct packet <highlight><bold>0</bold></highlight>. If any of the packets is missing, a query is made at step <highlight><bold>142</bold></highlight> as to whether packets <highlight><bold>1</bold></highlight>, <highlight><bold>3</bold></highlight> and <highlight><bold>5</bold></highlight> are present. If any of these packets in this set are not present, a further query is made at step <highlight><bold>146</bold></highlight> as to whether packets <highlight><bold>2</bold></highlight>, <highlight><bold>3</bold></highlight> and <highlight><bold>6</bold></highlight> are present. If any of these packets in this set are not present, a further query is made at step <highlight><bold>143</bold></highlight> as to whether packets <highlight><bold>4</bold></highlight>,<highlight><bold>5</bold></highlight>, and <highlight><bold>6</bold></highlight> are present. If any of the packets in this set are missing, packet <highlight><bold>0</bold></highlight> is marked as incomplete at step <highlight><bold>147</bold></highlight>. If any fill set of these packets is present, then packet <highlight><bold>0</bold></highlight> is reconstructed at either step <highlight><bold>140</bold></highlight>, <highlight><bold>144</bold></highlight>, <highlight><bold>148</bold></highlight>, or <highlight><bold>145</bold></highlight>. Once this reconstruction is complete, packet <highlight><bold>0</bold></highlight> is marked as complete at step <highlight><bold>149</bold></highlight>. After packet <highlight><bold>0</bold></highlight> has been marked as complete or incomplete, the analysis continues at <highlight><bold>150</bold></highlight>. </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> At step <highlight><bold>150</bold></highlight>, a query is made as to whether packet <highlight><bold>1</bold></highlight> is present. If packet <highlight><bold>1</bold></highlight> is present, the analysis continues at step <highlight><bold>160</bold></highlight>. If it is not present, the analysis begins to determine whether the missing packet can be reconstructed. A query is made at step <highlight><bold>152</bold></highlight> as to whether packets <highlight><bold>0</bold></highlight>, <highlight><bold>2</bold></highlight>, or <highlight><bold>4</bold></highlight> are all present. If they are not all present, a further query is made at step <highlight><bold>156</bold></highlight> as to whether packets <highlight><bold>0</bold></highlight>, <highlight><bold>3</bold></highlight> and <highlight><bold>5</bold></highlight> are all present. If any of these packets are missing, at step <highlight><bold>157</bold></highlight>, packet <highlight><bold>1</bold></highlight> is marked as incomplete. If either sets of packets had been fully present, packet <highlight><bold>1</bold></highlight> is reconstructed at step <highlight><bold>154</bold></highlight> or <highlight><bold>158</bold></highlight>, and then marked complete at step <highlight><bold>159</bold></highlight>. After packet <highlight><bold>1</bold></highlight> is marked as either complete or incomplete, the analysis moves onto packet <highlight><bold>2</bold></highlight>. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> At step <highlight><bold>160</bold></highlight>, a query is made as to whether packet <highlight><bold>2</bold></highlight> is present. If packet <highlight><bold>2</bold></highlight> is present, the analysis continues at step <highlight><bold>170</bold></highlight>. If this packet is not present, a further query is made as to whether packet <highlight><bold>0</bold></highlight>, <highlight><bold>1</bold></highlight>, and <highlight><bold>4</bold></highlight> are present at step <highlight><bold>162</bold></highlight>. If they are not, a query is made at step <highlight><bold>166</bold></highlight> as to whether packet <highlight><bold>0</bold></highlight>, <highlight><bold>3</bold></highlight>, and <highlight><bold>6</bold></highlight> are present. If none of the packets are present, packet <highlight><bold>2</bold></highlight> is marked as incomplete at step <highlight><bold>167</bold></highlight>. If either sets of packets were present, the packet <highlight><bold>2</bold></highlight> is reconstructed at either step <highlight><bold>164</bold></highlight> or <highlight><bold>168</bold></highlight>. Packet <highlight><bold>2</bold></highlight> is then marked as complete at step <highlight><bold>169</bold></highlight>. The analysis then moves on to packet <highlight><bold>3</bold></highlight>. </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> At step <highlight><bold>170</bold></highlight> a query is made as to whether packet <highlight><bold>3</bold></highlight> is present. If packet <highlight><bold>3</bold></highlight> is not present, the analysis continues at step <highlight><bold>180</bold></highlight>. If this packet is not present, a further query is made at step <highlight><bold>172</bold></highlight> as to whether packets <highlight><bold>0</bold></highlight>, <highlight><bold>1</bold></highlight> and <highlight><bold>5</bold></highlight> are all present. If they are not all present, a query is made at step <highlight><bold>176</bold></highlight> as to whether packets <highlight><bold>0</bold></highlight>, <highlight><bold>2</bold></highlight> and <highlight><bold>6</bold></highlight> are all present. If any of these packets is missing, packet <highlight><bold>3</bold></highlight> is marked as incomplete at step <highlight><bold>177</bold></highlight>. If either sets of packets had been fully present, packet <highlight><bold>3</bold></highlight> is reconstructed at step <highlight><bold>174</bold></highlight> or <highlight><bold>178</bold></highlight>. Packet <highlight><bold>3</bold></highlight> is then marked as complete at step <highlight><bold>179</bold></highlight>. </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> After the analysis is complete for all the information packets originally transmitted, a query is made at step <highlight><bold>180</bold></highlight> as to whether all the information packets have been recovered. If they all have been recovered, the analysis ends. If all the information packets have not been all recovered, a query is made at step <highlight><bold>182</bold></highlight> as to whether any of the information packets were recovered during the previous analysis. If no new information packets were recovered, the process ends. If a new information packet was recovered, the analysis begins again at step <highlight><bold>136</bold></highlight>. This loop through the analysis will continue until either all the information packets are recovered, or is determined that no more information packets are recoverable. </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> A specific example of the analysis described in <cross-reference target="DRAWINGS">FIGS. 8</cross-reference><highlight><italic>a </italic></highlight>and <highlight><italic>b </italic></highlight>is shown in <cross-reference target="DRAWINGS">FIGS. 9</cross-reference><highlight><italic>a, b </italic></highlight>and <highlight><italic>c. </italic></highlight>The example to be described is a chunk of redtype 131 which has been transmitted and received, and it is detected that packets <highlight><bold>0</bold></highlight>, <highlight><bold>2</bold></highlight>, and <highlight><bold>6</bold></highlight> were lost. With the above packets missing, it is known that packets <highlight><bold>5</bold></highlight>, <highlight><bold>4</bold></highlight>, <highlight><bold>3</bold></highlight>, and <highlight><bold>1</bold></highlight> were received. The binary content of payload for these packets is shown in <cross-reference target="DRAWINGS">FIG. 9</cross-reference><highlight><italic>a. </italic></highlight>Using this information in the flowchart in <cross-reference target="DRAWINGS">FIG. 8</cross-reference>, at step <highlight><bold>136</bold></highlight> it is detected that packet <highlight><bold>0</bold></highlight> is not present. The query is made at step <highlight><bold>138</bold></highlight> as to whether packets <highlight><bold>1</bold></highlight>,<highlight><bold>2</bold></highlight> and <highlight><bold>4</bold></highlight> are all present. It is known that packet <highlight><bold>2</bold></highlight> is missing. The analysis moves on to step <highlight><bold>142</bold></highlight> where the query is made as to whether packets <highlight><bold>1</bold></highlight>, <highlight><bold>3</bold></highlight>, and <highlight><bold>5</bold></highlight> are present. Since all these packets are present, at step <highlight><bold>144</bold></highlight>, a XOR will be performed between the three packets to reconstruct packet <highlight><bold>0</bold></highlight>. The results of the reconstruction is shown in <cross-reference target="DRAWINGS">FIG. 9</cross-reference><highlight><italic>b. </italic></highlight></paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> With packet <highlight><bold>0</bold></highlight> reconstructed, the flow chart moves on to step <highlight><bold>150</bold></highlight> where the query is made as to whether packet <highlight><bold>1</bold></highlight> is present. Because this packet is present, the analysis moves on to step <highlight><bold>160</bold></highlight> and the query is made as to whether packet <highlight><bold>2</bold></highlight> is present. Because packet <highlight><bold>2</bold></highlight> is not present, the query is made at <highlight><bold>162</bold></highlight> as to whether packets <highlight><bold>0</bold></highlight>, <highlight><bold>1</bold></highlight> and <highlight><bold>4</bold></highlight> are present. It is detected that these packets are present and packet <highlight><bold>2</bold></highlight> is reconstructed at step <highlight><bold>164</bold></highlight>. The payload portion of packets <highlight><bold>0</bold></highlight>, <highlight><bold>1</bold></highlight> and <highlight><bold>4</bold></highlight> as well as the recovered packet <highlight><bold>2</bold></highlight> is shown in <cross-reference target="DRAWINGS">FIG. 9</cross-reference><highlight><italic>c. </italic></highlight></paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> After packet <highlight><bold>2</bold></highlight> has been marked complete the analysis moves on to step <highlight><bold>170</bold></highlight> where the query is made as to whether packet <highlight><bold>3</bold></highlight> is present. Since packet <highlight><bold>3</bold></highlight> is present, query is made at step <highlight><bold>180</bold></highlight> as to whether all the information packets have been recovered. In this case they have, so the analysis ends. </paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> If all the packets had not been recovered on the first pass through the analysis, and at least one of the lost packets had been recovered, the process starts again at step <highlight><bold>136</bold></highlight>. The analysis is done again with all the packets which were originally received as well as any of the packets which were recovered. </paragraph>
<paragraph id="P-0068" lvl="0"><number>&lsqb;0068&rsqb;</number> When the information packets are transmitted over the data network, more than one of the information packets can be lost. The tables shown in <cross-reference target="DRAWINGS">FIGS. 10 and 11</cross-reference> document the recovery rate of lost information packets in a 7, 4 chunk redtype of 131. <cross-reference target="DRAWINGS">FIG. 10</cross-reference> shows specifically the case where two packets are lost during the transmission of a 7,4 chunk. In this case it should be noted that there is 100% recovery of all transmitted information packets. It should be noted that no recovery of parity packets <highlight><bold>4</bold></highlight>, <highlight><bold>5</bold></highlight> and <highlight><bold>6</bold></highlight> is attempted because the process is only interested in recovering information packets, and we have found that recovering parity packets is not required. </paragraph>
<paragraph id="P-0069" lvl="0"><number>&lsqb;0069&rsqb;</number> Shown in <cross-reference target="DRAWINGS">FIG. 11</cross-reference> is a table of cases for three lost packets in a 7, 4 chunk of redtype 131. In this case, data was recovered in 28 out of the 35 possible ways three packets can be lost. As with the previous examples, no reconstruction was necessary in the case of parity packets. Similarly in a 15,11 chunk of redtype 132 (N&equals;4) recovery is successful in over 90 percent of the ways in which three packets can be lost and over 60 percent of the ways in which 4 packets can be lost. Also, in a 31,26 chunk of redtype 133 (N&equals;5) recovery is successful in over 95 percent of the ways in which three packets can be lost, over 80 percent of the ways in which four packets can be lost, and over 45 percent of the ways in which five packets can be lost. </paragraph>
<paragraph id="P-0070" lvl="0"><number>&lsqb;0070&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 13</cross-reference> illustrates a network <highlight><bold>300</bold></highlight> in connection with which the present invention may be implemented. For purposes of illustration, the network <highlight><bold>300</bold></highlight> is shown as including two client nodes <highlight><bold>302</bold></highlight> and <highlight><bold>304</bold></highlight> and as server node <highlight><bold>306</bold></highlight> that communicate across the internet <highlight><bold>308</bold></highlight>. It will be appreciated that any number of nodes may be supported in accordance with the present invention and that various public or private network structures may be used in addition to or in place of the internet <highlight><bold>308</bold></highlight>. In addition, only one of the client nodes <highlight><bold>302</bold></highlight> is illustrated and described in detail, it being understood that the other client node <highlight><bold>304</bold></highlight> is similar in relevant respects. Moreover, it will be understood that, while the nodes are designated as being &ldquo;client nodes&rdquo; or a &ldquo;server node&rdquo; for purposes of the present illustration, a particular node utilized in connection with the present invention may be both a client and a server. </paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> The client node <highlight><bold>302</bold></highlight>, which may be a PC or other computer, generally includes memory <highlight><bold>310</bold></highlight> (e.g., computer memory, cache memory, buffer storage, etc.), a CPU<highlight><bold>312</bold></highlight> and input/output devices <highlight><bold>314</bold></highlight> (e.g., keyboard, mouse, fax modem, etc.) that communicate via a data bus <highlight><bold>16</bold></highlight>. Similarly, the server node <highlight><bold>306</bold></highlight> includes memory <highlight><bold>318</bold></highlight>, processor <highlight><bold>320</bold></highlight> and input/output devices for receiving operator inputs and supporting multiple simultaneous client connections. The server node <highlight><bold>306</bold></highlight> may be, for example, a server for a network browser service. In order to implement the teachings of the present invention, logic for implementing the transmit and receive parity packet functions described above may be stored in server memory <highlight><bold>318</bold></highlight> and run on processor <highlight><bold>320</bold></highlight>. For example, such logic may be provided on a CD or other storage unit that can be read by the server processor <highlight><bold>320</bold></highlight>. In addition, transmission packets used for communication between the server node <highlight><bold>306</bold></highlight> and one of the client nodes <highlight><bold>302</bold></highlight> and <highlight><bold>304</bold></highlight> in accordance with the present invention are at least transiently stored in server memory <highlight><bold>318</bold></highlight>. </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> As noted above, transmit logic for generating parity packets, forming superchunks, transmitting a transmission packet stream, etc. and/or receive logic for identifying lost packets, using parity packets to regenerate lost packets, etc. may be resident on the client nodes <highlight><bold>302</bold></highlight> and <highlight><bold>304</bold></highlight> to permit parity packet based packet recovery without retransmission according to the present invention. Such logic may be installed at the client nodes <highlight><bold>302</bold></highlight> and <highlight><bold>304</bold></highlight> from a disk or other storage medium. Alternatively, such logic or parts thereof may be downloaded from the service node <highlight><bold>306</bold></highlight> to the client nodes <highlight><bold>302</bold></highlight> and <highlight><bold>304</bold></highlight> via the internet <highlight><bold>308</bold></highlight> or installed on the client node computers as part of an OEM software package. For example, such logic may be included as part of tools delivered to clients by a browser service or a network audio or video service. The logic is stored in client memory <highlight><bold>310</bold></highlight> and runs on CPU <highlight><bold>312</bold></highlight>. In addition, transmission packets including parity packets for use in accordance with the present invention for communications between clients nodes <highlight><bold>302</bold></highlight> and <highlight><bold>304</bold></highlight> or between a client node <highlight><bold>302</bold></highlight> and <highlight><bold>304</bold></highlight> and server node <highlight><bold>306</bold></highlight> are at least transiently stored in client memory <highlight><bold>310</bold></highlight>. It will thus be appreciated that server memory <highlight><bold>318</bold></highlight> and client memory <highlight><bold>310</bold></highlight> are configured to store transmission packets (including parity packets) and to store transmit and/or receive logic. Such configuration is accomplished by loading/downloading the logic (e.g., addressing the associated files to the client and transmitting the files from the server node) or by transmitting or receiving a transmission packet stream including parity packets in accordance with the present invention. </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> The foregoing description of the present invention has been presented for purposes of illustration and description. Furthermore, the description is not intended to limit the invention to the form disclosed herein. Consequently, variations and modifications commensurate with the above teachings, and the skill or knowledge of the relevant art, are within the scope of the present invention. The embodiments described hereinabove are further intended to explain best modes known for practicing the invention and to enable others skilled in the art to utilize the invention in such, or other, embodiments and with various modifications required by the particular applications or uses of the present invention. It is intended that the appended claims be construed to include alternative embodiments to the extent permitted by the prior art. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method for use in transmitting information over a network from a first node to a second node, said method comprising the steps of: 
<claim-text>dividing, at said first node, a given transmission into a plurality of information packets; </claim-text>
<claim-text>generating at least one parity packet at said first node with a content based on a selected number of said plurality of information packets and transmitting the at least one parity packet with the plurality of information packets; </claim-text>
<claim-text>detecting, at said second node, arrival of said plurality of information packets as well as any problems which may exist relative to any of said plurality of information packets, said problems including one or more of packet loss and packet damage; and </claim-text>
<claim-text>based on the detection of problems relative to said plurality of information packets, regenerating at least one of said plurality of information packets using a combination of said at least one parity packet and said information transmission packets. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further including the step of creating a chunk from transmission packets, wherein the transmission packets include said plurality of information packets and said at least one parity packet. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, wherein said at least one parity packet within the chunk has a payload length at least as great as the payload length of the longest information packet in the selected number of said plurality of information packets. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein said step of generating at least one parity packet comprises determining each bit in a payload portion of said parity packet as a function of corresponding bits in at least two of said plurality of information packets. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00004">claim 4</dependent-claim-reference>, wherein the bits in the payload portion of said parity packet are determined by performing an XOR operation between the corresponding bits in at least two of said plurality of information packets. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, wherein said network comprises a packet switched network for switching protocol compliant packets including a payload portion and a header, and said method further comprises the steps of establishing a plurality of protocol compliant packets, the payload portion for each of said plurality of protocol compliant packets including a content of a corresponding one of the transmission packets in the chunk. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein said network comprises an internet protocol network. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference>, wherein said plurality of information packets and said at least one parity packet are transmitted in accordance with UDP. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein said step of detecting a problem comprises transmitting said plurality of information packets and said at least one parity packet using a transmission system which incorporates a packet integrity checking mechanism. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising the step of associating check parameters with each of said plurality of information packets and said at least one parity packet, wherein said step of detecting comprises analyzing said check parameters to identify said problems. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein the detection of any problems relative to the plurality of information packets includes determining that any of said plurality of information and parity packets has not been received within an allowed time. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein said given transmission comprises one of a video transmission and an audio transmission. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, further comprising the steps of: 
<claim-text>including in the chunk up to (2<highlight><superscript>N</superscript></highlight>&minus;1) of the plurality of information packets and the parity packets, where N is an integer greater than 2 and N packets within the chunk are the parity packets; </claim-text>
<claim-text>transmitting the chunk over said network from said first node to said second node; and </claim-text>
<claim-text>processing the chunk at said second node to obtain up to (2<highlight><superscript>N</superscript></highlight>&minus;1)-N of said plurality of information packets. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference>, wherein when N is equal to 3, full information recovery can be achieved for cases where one or two of the transmission packets within one of the chunks are lost during transmission and full recovery can be achieved for at least 77 percent of the cases in which three of the transmission packets within one of the chunks are lost during the transmission. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference>, wherein when N is equal to 4, full information recovery can achieved for all cases where two or less of the transmission packets within one of the chunks are lost during the transmission, full recovery can be achieved for at least 90 percent of the cases in which three of the transmission packets within one of the chunks are lost during the transmission, and full recovery can be achieved for at least 60 percent of the cases in which four of the transmission packets within one of the chunks are lost during the transmission. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference>, wherein when N is equal to 5, full information recovery can be achieved for all cases where two or less of the transmission packets within one of the chunks are lost during the transmission, fill recovery can be achieved for at least 95 percent of the cases in which three of the transmission packets within one of the chunks are lost during the transmission, fill recovery can be achieved for at least 80 percent of the cases in which four of the transmission packets with one of the chunks are lost during the transmission, and full information recovery can be achieved for at least 45 percent of the cases in which five of the transmission packets within one of the chunks are lost during the transmission. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00011">claim 13</dependent-claim-reference>, wherein said N parity packets are established according to the following rules: 
<claim-text>1) each of said plurality of information packets participates in establishing at least two of said N parity packets; and </claim-text>
<claim-text>2) each of said N parity packets is generated through use of a unique combination of said plurality of information packets. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, further comprising the steps of: 
<claim-text>including in the chunk N&plus;1 of the plurality of information packets and the parity packets, where N is an integer greater than 1 and one parity packet is included within the chunk; </claim-text>
<claim-text>transmitting the chunk over said network from said first node to said second node; and </claim-text>
<claim-text>processing the chunk at said second node to obtain N of said plurality of information packets. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, further comprising the step of forming one or more superchunks, each of the superchunks including a plurality of the chunks, wherein the transmission packets for all of the chunks are interleaved within the superchunk. </claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00011">claim 19</dependent-claim-reference>, wherein the transmission packets of the chunks are interleaved to form the superchunk, and the number of the chunks used to form the superchunk may be changed at the first node. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, wherein said transmission packets include a header portion and a payload portion, said header portion including identifying information sufficient to identify whether a packet is one of said information packets or said parity packets and to uniquely identify each of said information packets and each of said parity packets. </claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, wherein said at least one chunk comprises a plurality of chunks and the header portion of said transmission packets within each of the chunks includes: 
<claim-text>a sequence number to identify the chunk said transmission packet is contained within, and to identify a payload for the chunk </claim-text>
<claim-text>a packet payload length to identify a length of a payload portion of said packet; </claim-text>
<claim-text>a parity type (redtype) identifier to identify a type of parity used in the chunk, to identify a total number of packets within the chunk, and to identify a total number of the parity packets within the chunk; and </claim-text>
<claim-text>a packet number identifier which uniquely identifies a particular one of the transmission packets within the chunk. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00022">claim 22</dependent-claim-reference>, wherein said redtype identifier identifies one of the following types of parity within said chunk: 
<claim-text>a first parity where the chunk includes none of said parity packets; </claim-text>
<claim-text>a second parity where the chunk includes one of said parity packets and N of said information packets, where N is an integer equal to or greater than 2; and </claim-text>
<claim-text>a third parity where the chunk includes N of said parity packets, where N is an integer equal to or greater than 3 and the chunk includes at least 3 and at most (2<highlight><superscript>N</superscript></highlight>&minus;1)-N of the information packets. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00002">claim 2</dependent-claim-reference>, wherein said at least one chunk comprises a plurality of chunks, said method further comprising the step of transmitting an acknowledgment from the second node to the first node upon receipt of a portion of the chunk, where the acknowledgment contains information that includes retransmission requirements for the chunks previously transmitted from the first node. </claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00022">claim 24</dependent-claim-reference>, wherein the first node retransmits all or a portion of the chunk based on at least one of the information contained in the acknowledgment, and nonreceipt of the acknowledgment within an allowed amount of time. </claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00022">claim 22</dependent-claim-reference>, wherein the redtype may be changed. </claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00022">claim 20</dependent-claim-reference>, wherein the number of the transmission chunks within the superchunk may be changed. </claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00022">claim 26</dependent-claim-reference>, wherein the changing of the redtype includes switching between the first, second, and third parities. </claim-text>
</claim>
<claim id="CLM-00029">
<claim-text><highlight><bold>29</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00022">claim 26</dependent-claim-reference>, wherein the changing of the redtype includes changing the N value in the second and third parities. </claim-text>
</claim>
<claim id="CLM-00030">
<claim-text><highlight><bold>30</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00022">claim 26</dependent-claim-reference>, wherein the redtype is changed dynamically based on at least one of: the information in the acknowledgments received from the chunks previously transmitted and nonreceipt of the acknowledgment within an allowed time. </claim-text>
</claim>
<claim id="CLM-00031">
<claim-text><highlight><bold>31</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00022">claim 27</dependent-claim-reference>, wherein the number of chunks in a superchunk is changed dynamically based on at least one of: the information in the acknowledgments received from the chunks previously transmitted and nonreceipt of the acknowledgment with an allowed time. </claim-text>
</claim>
<claim id="CLM-00032">
<claim-text><highlight><bold>32</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00022">claim 23</dependent-claim-reference>, wherein said header portion of at least two of said transmission packets within each of the chunks contains: 
<claim-text>the redtype indicating the second parity; </claim-text>
<claim-text>a chunk length defining a length of information contained in the chunk; </claim-text>
<claim-text>a window size associated with an amount of available receive buffer in a node from which the chunk has been transmitted from; </claim-text>
<claim-text>an acknowledgment flag and identifier, which when the flag is ON the identifier corresponds to a sequence number of information successfully received from a node to which the chunk is being transmitted; </claim-text>
<claim-text>a time stamp value corresponding to a transmission time associated with the chunk; and </claim-text>
<claim-text>a time stamp echo value which, when said acknowledgment flag is ON, contains a time stamp value assigned by the node to which the chunk is being transmitted and associated with said acknowledgment identifier. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00033">
<claim-text><highlight><bold>33</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00022">claim 23</dependent-claim-reference>, wherein said header portion of at least three of said transmission packets within each of the chunks includes: 
<claim-text>the redtype indicating the third parity; </claim-text>
<claim-text>a chunk length defining a length of information contained in the chunk; </claim-text>
<claim-text>a window size associated with an amount of available receive buffer in a node from which the chunk has been transmitted from; </claim-text>
<claim-text>an acknowledgment flag and identifier, which when the flag is ON the identifier corresponds to a sequence number of information successfully received from a node to which the chunk is being transmitted; </claim-text>
<claim-text>a time stamp value corresponding to a transmission time associated with the chunk; and </claim-text>
<claim-text>a time stamp echo value which, when said acknowledgment flag is ON, contains a time stamp value assigned by the node to which the chunk is being transmitted and associated with said acknowledgment identifier. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00034">
<claim-text><highlight><bold>34</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising the step of restricting a number of said information and parity packets sent in a given time interval so as not to exceed a predetermined packet count. </claim-text>
</claim>
<claim id="CLM-00035">
<claim-text><highlight><bold>35</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising the step of restricting a number of said information and parity packets sent in a given time interval so as not to exceed a predetermined bit rate. </claim-text>
</claim>
<claim id="CLM-00036">
<claim-text><highlight><bold>36</bold></highlight>. A method for transmitting information over a data network comprising the steps of: 
<claim-text>dividing a given transmission into a plurality of information packets; </claim-text>
<claim-text>generating at least one parity packet with a content based on a selected number of said plurality of information packets and including the at least one parity packet with the plurality of information packets; and </claim-text>
<claim-text>transmitting the plurality of information packets and the at least one parity packet over the data network. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00037">
<claim-text><highlight><bold>37</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00033">claim 36</dependent-claim-reference>, further including the step of creating a chunk from transmission packets, wherein the transmission packets include said plurality of information packets and said at least one parity packet. </claim-text>
</claim>
<claim id="CLM-00038">
<claim-text><highlight><bold>38</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00033">claim 37</dependent-claim-reference>, wherein said at least one parity packet with the chunk has a payload as least as long as the payload of the information packet in the selected number of said plurality of information packets which is longest in length. </claim-text>
</claim>
<claim id="CLM-00039">
<claim-text><highlight><bold>39</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00033">claim 36</dependent-claim-reference>, wherein said step of generating at least one parity packet comprises determining each bit in a payload portion of said parity packet as a function of corresponding bits in at least two of said plurality of information packets. </claim-text>
</claim>
<claim id="CLM-00040">
<claim-text><highlight><bold>40</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00033">claim 39</dependent-claim-reference>, wherein the bits in the payload portion of said parity packet are determined by performing an XOR operation between the corresponding bits in at least two of said plurality of information packets. </claim-text>
</claim>
<claim id="CLM-00041">
<claim-text><highlight><bold>41</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00033">claim 37</dependent-claim-reference>, further comprising the step of including in the chunk (2<highlight><superscript>N</superscript></highlight>&minus;1) of the plurality of information packets and the parity packets, where N is an integer greater than 2 and N packets within the chunk are the parity packets. </claim-text>
</claim>
<claim id="CLM-00042">
<claim-text><highlight><bold>42</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00044">claim 41</dependent-claim-reference>, wherein said N parity packets are established according to the following rules: 
<claim-text>1) each of said plurality of information packets participates in establishing at least two of said N parity packets; and </claim-text>
<claim-text>2) each of said N parity packets is generated through use of a unique combination of said plurality of information packets. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00043">
<claim-text><highlight><bold>43</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00033">claim 37</dependent-claim-reference>, further comprising the step of including in the chunk N&plus;1 of the plurality of information packets and the parity packets, where N is an integer greater than 1 and one parity packet is included within the chunk. </claim-text>
</claim>
<claim id="CLM-00044">
<claim-text><highlight><bold>44</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00033">claim 37</dependent-claim-reference>, further comprising the step of forming one or more superchunks, each of the superchunks including a plurality of the chunks, wherein the transmission packets for all of the chunks are interleaved within the superchunk. </claim-text>
</claim>
<claim id="CLM-00045">
<claim-text><highlight><bold>45</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00044">claim 44</dependent-claim-reference> wherein the transmission packets of the chunks are interleaved to form the superchunk, and the number of the chunks used to form the superchunk may be changed. </claim-text>
</claim>
<claim id="CLM-00046">
<claim-text><highlight><bold>46</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00033">claim 37</dependent-claim-reference>, wherein said transmission packets include a header portion and a payload portion, said header portion including identifying information sufficient to identify whether a packet is one of said information packets or said parity packets and to uniquely identify each of said information packets and each of said parity packets. </claim-text>
</claim>
<claim id="CLM-00047">
<claim-text><highlight><bold>47</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00044">claim 46</dependent-claim-reference>, wherein the header portion of said transmission packets within each of the chunks includes: 
<claim-text>a sequence number to identify the chunk said transmission packet is contained within, and to identify a payload for the chunk; </claim-text>
<claim-text>a packet payload length to identify a length of a payload portion of said packet; </claim-text>
<claim-text>a parity type (redtype) identifier to identify a type of parity used in the chunk, to identify a total number of packets within the chunk, and to identify a total number of the parity packets within the chunk; and </claim-text>
<claim-text>a packet number identifier which uniquely identifies a particular one of the transmission packets within the chunk. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00048">
<claim-text><highlight><bold>48</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00044">claim 47</dependent-claim-reference>, wherein said redtype identifier identifies one of the following types of parity within said chunk: 
<claim-text>a first parity where the chunk includes none of said parity packets; </claim-text>
<claim-text>a second parity where the chunk includes one of said parity packets and N of said information packets, where N is an integer equal to or greater than 2; and </claim-text>
<claim-text>a third parity where the chunk includes N of said parity packets, where N is an integer equal to or greater than 3 and the chunk includes at least 3 and at most (2<highlight><superscript>N</superscript></highlight>&minus;1)-N of the information packets. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00049">
<claim-text><highlight><bold>49</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00044">claim 48</dependent-claim-reference>, wherein the redtype may be changed. </claim-text>
</claim>
<claim id="CLM-00050">
<claim-text><highlight><bold>50</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00044">claim 48</dependent-claim-reference>, further comprising the step of forming one or more superchunks, each of the superchunks including a plurality of the chunks, wherein the transmission packets for all of the chunks are interleaved within the superchunk and wherein the number of the transmission chunks within the superchunk may be changed. </claim-text>
</claim>
<claim id="CLM-00051">
<claim-text><highlight><bold>51</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00044">claim 48</dependent-claim-reference>, wherein the redtype is changed dynamically based on at least one of: the information in the acknowledgments received from the chunks previously transmitted and nonreceipt of the acknowledgment within an allowed time. </claim-text>
</claim>
<claim id="CLM-00052">
<claim-text><highlight><bold>52</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00055">claim 50</dependent-claim-reference>, wherein the number of chunks in a superchunk is changed dynamically based on at least one of: the information in the acknowledgments received from the chunks previously transmitted and nonreceipt of the acknowledgment with an allowed time. </claim-text>
</claim>
<claim id="CLM-00053">
<claim-text><highlight><bold>53</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00044">claim 48</dependent-claim-reference>, wherein said header portion of at least two of said transmission packets within each of the chunks contains: 
<claim-text>the redtype indicating the second parity; </claim-text>
<claim-text>a chunk length defining a length of information contained in the chunk; </claim-text>
<claim-text>a window size associated with an amount of available receive buffer in a node from which the chunk has been transmitted from; </claim-text>
<claim-text>an acknowledgment flag and identifier, which when the flag is ON the identifier corresponds to a sequence number of information successfully received from a node to which the chunk is being transmitted; </claim-text>
<claim-text>a time stamp value corresponding to a transmission time associated with the chunk; and </claim-text>
<claim-text>a time stamp echo value which, when said acknowledgment flag is ON, contains a time stamp value assigned by the node to which the chunk is being transmitted and associated with said acknowledgment identifier. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00054">
<claim-text><highlight><bold>54</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00044">claim 48</dependent-claim-reference>, wherein said header portion of at least three of said transmission packets within each of the chunks includes: 
<claim-text>the redtype indicating the third parity; </claim-text>
<claim-text>a chunk length defining a length of information contained in the chunk; </claim-text>
<claim-text>a window size associated with an amount of available receive buffer in a node from which the chunk has been transmitted from; </claim-text>
<claim-text>an acknowledgment flag and identifier, which when the flag is ON the identifier corresponds to a sequence number of information successfully received from a node to which the chunk is being transmitted; </claim-text>
<claim-text>a time stamp value corresponding to a transmission time associated with the chunk; and </claim-text>
<claim-text>a time stamp echo value which, when said acknowledgment flag is ON, contains a time stamp value assigned by the node to which the chunk is being transmitted and associated with said acknowledgment identifier. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00055">
<claim-text><highlight><bold>55</bold></highlight>. A method for regenerating at least one information packet transmitted over a data network, comprising: 
<claim-text>receiving a plurality of information packets and at least one parity packet, said parity packet having a content based on said information packets; </claim-text>
<claim-text>detecting any problems which may exist relative to any of said plurality of information packets which were originally transmitted, said problems including one of packet loss and packet damage; and </claim-text>
<claim-text>based on the detection of problems relative to said plurality of information packets, regenerating at least one of said plurality of information packets using a to combination of said at least one parity packet and said information transmission packets. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00056">
<claim-text><highlight><bold>56</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00055">claim 55</dependent-claim-reference>, wherein said step of detecting comprises analyzing check parameters associated with said information packets to identify said problems. </claim-text>
</claim>
<claim id="CLM-00057">
<claim-text><highlight><bold>57</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00055">claim 55</dependent-claim-reference>, wherein the detection of any problems relative to the plurality of information packets includes determining that any of said plurality of information and parity packets has not been received within an allowed time. </claim-text>
</claim>
<claim id="CLM-00058">
<claim-text><highlight><bold>58</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00055">claim 55</dependent-claim-reference>, wherein said information packets and at least one parity packet (collectively &ldquo;transmission packets&rdquo;) define a chunk including 2<highlight><superscript>N</superscript></highlight>&minus;1 transmission packets of which N packets are parity packets, and said method further includes the step of processing the chunk to obtain up to (2<highlight><superscript>N</superscript></highlight>&minus;1)-N of said plurality of information packets. </claim-text>
</claim>
<claim id="CLM-00059">
<claim-text><highlight><bold>59</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00055">claim 58</dependent-claim-reference>, wherein when N is equal to 3, full information recovery can be achieved for cases where one or two of the transmission packets within one of the chunks are lost during transmission and full recovery can be achieved for at least 77 percent of the cases in which three of the transmission packets within one of the chunks are lost during the transmission. </claim-text>
</claim>
<claim id="CLM-00060">
<claim-text><highlight><bold>60</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00055">claim 58</dependent-claim-reference>, wherein when N is equal to 4, full information recovery can be achieved for all cases where two or less of the transmission packets within one of the chunks are lost during the transmission, full recovery can be achieved for at least 90 percent of the cases in which three of the transmission packets within one of the chunks are lost during the transmission, and full recovery can be achieved for at least 60 percent of the cases in which four of the transmission packets within one of the chunks are lost during the transmission. </claim-text>
</claim>
<claim id="CLM-00061">
<claim-text><highlight><bold>61</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00055">claim 58</dependent-claim-reference>, wherein when N is equal to 5, full recovery is achieved for all cases where two or less of the transmission packets within one of the chunks are lost during the transmission, full recovery can be achieved for at least 95 percent of the cases in which three of the transmission packets within one of the chunks are lost during the transmission, full recovery can be achieved for at least 80 percent of the cases in which four of the transmission packets with one of the chunks are lost during the transmission, and full recovery can be achieved for at least 45 percent of the cases in which five of the transmission packets within one of the chunks are lost during the transmission. </claim-text>
</claim>
<claim id="CLM-00062">
<claim-text><highlight><bold>62</bold></highlight>. A method as set forth in <dependent-claim-reference depends_on="CLM-00055">claim 55</dependent-claim-reference>, wherein the step of regenerating includes performing an XOR operation between corresponding bits in a payload portion of the received information and parity packets. </claim-text>
</claim>
<claim id="CLM-00063">
<claim-text><highlight><bold>63</bold></highlight>. An apparatus for transmitting information over a data network comprising: 
<claim-text>means for dividing a given transmission into a plurality of information packets; </claim-text>
<claim-text>means for generating at least one parity packet with a content generated from a selected number of said plurality of information packets, and including the at least one parity packet with the plurality of information packets; and </claim-text>
<claim-text>means for transmitting the plurality of information packets and the at least one parity packet over the data network. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00064">
<claim-text><highlight><bold>64</bold></highlight>. An apparatus as set forth in <dependent-claim-reference depends_on="CLM-00066">claim 63</dependent-claim-reference>, further including a means for creating a chunk from transmission packets, wherein the transmission packets include said plurality of information packets and said at least one parity packet. </claim-text>
</claim>
<claim id="CLM-00065">
<claim-text><highlight><bold>65</bold></highlight>. An apparatus as set forth in <dependent-claim-reference depends_on="CLM-00066">claim 63</dependent-claim-reference>, wherein said means for generating at least one parity packet includes means for determining each bit in a payload portion of said parity packet as a function of corresponding bits in at least two of said plurality of information packets. </claim-text>
</claim>
<claim id="CLM-00066">
<claim-text><highlight><bold>66</bold></highlight>. An apparatus as set forth in <dependent-claim-reference depends_on="CLM-00066">claim 63</dependent-claim-reference>, wherein the means for generating at least one parity packet includes means for determining the bits in the payload portion of said parity packet by performing an XOR operation between the corresponding bits in at least two of said plurality of information packets. </claim-text>
</claim>
<claim id="CLM-00067">
<claim-text><highlight><bold>67</bold></highlight>. An apparatus as set forth in <dependent-claim-reference depends_on="CLM-00066">claim 64</dependent-claim-reference>, wherein the means for creating the chunk includes means for combining up to (2<highlight><superscript>N</superscript></highlight>&minus;1) of the plurality of information packets and the parity packets in the chunk, where N is an integer greater than 2 and N packets within the chunk are the parity packets. </claim-text>
</claim>
<claim id="CLM-00068">
<claim-text><highlight><bold>68</bold></highlight>. An apparatus as set forth in <dependent-claim-reference depends_on="CLM-00066">claim 67</dependent-claim-reference>, wherein said means for generating at least one parity packet comprises processing means for generating said N parity packets according to the following rules: 
<claim-text>1) each of said plurality of information packets participates in establishing at least two of said N parity packets; and </claim-text>
<claim-text>2) each of said N parity packets is generated through use of a unique combination of said plurality of information packets. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00069">
<claim-text><highlight><bold>69</bold></highlight>. An apparatus as set forth in <dependent-claim-reference depends_on="CLM-00066">claim 64</dependent-claim-reference>, wherein the means for creating a chunk comprises means for combining N&plus;1 of the plurality of information packets and the parity packets in the chunk, where N is an integer greater than 1 and one parity packet is included within the chunk; </claim-text>
</claim>
<claim id="CLM-00070">
<claim-text><highlight><bold>70</bold></highlight>. An apparatus as set forth in <dependent-claim-reference depends_on="CLM-00066">claim 64</dependent-claim-reference>, further including means for forming one or more superchunks, where each of the superchunks includes a plurality of the chunks and the transmission packets for all of the chunks are interleaved within the superchunk. </claim-text>
</claim>
<claim id="CLM-00071">
<claim-text><highlight><bold>71</bold></highlight>. An apparatus as set forth in <dependent-claim-reference depends_on="CLM-00066">claim 64</dependent-claim-reference>, further including means for adding a header portion to said transmission packets wherein said header portion includes identifying information sufficient to identify whether a packet is one of said information packets or said parity packets and to uniquely identify each of said information packets and each of said parity packets. </claim-text>
</claim>
<claim id="CLM-00072">
<claim-text><highlight><bold>72</bold></highlight>. An apparatus as set forth in <dependent-claim-reference depends_on="CLM-00077">claim 71</dependent-claim-reference>, wherein the header portion of said transmission packets within each of the chunks includes: 
<claim-text>a sequence number to identify the chunk said transmission packet is contained within, and to identify a payload for the chunk; </claim-text>
<claim-text>a packet payload length to identify a length of a payload portion of said packet; </claim-text>
<claim-text>a parity type (redtype) identifier to identify a type of parity used in the chunk, to identify a total number of packets within the chunk, and to identify a total number of the parity packets within the chunk; and </claim-text>
<claim-text>a packet number identifier which uniquely identifies a particular one of the transmission packets within the chunk. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00073">
<claim-text><highlight><bold>73</bold></highlight>. An apparatus as set forth in <dependent-claim-reference depends_on="CLM-00077">claim 72</dependent-claim-reference>, wherein said redtype identifier identifies one of the following types of parity within said chunk: 
<claim-text>a first parity where the chunk includes none of said parity packets; </claim-text>
<claim-text>a second parity where the chunk includes one of said parity packets and N of said information packets, where N is an integer equal to or greater than 2; and </claim-text>
<claim-text>a third parity where the chunk includes N of said parity packets, where N is an integer equal to or greater than 3 and the chunk includes at least 3 and at most (2<highlight><superscript>N</superscript></highlight>&minus;1)-N of the information packets. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00074">
<claim-text><highlight><bold>74</bold></highlight>. An apparatus as set forth in <dependent-claim-reference depends_on="CLM-00077">claim 73</dependent-claim-reference>, wherein the means for transmitting further includes means for receiving and processing acknowledgments from the data network. </claim-text>
</claim>
<claim id="CLM-00075">
<claim-text><highlight><bold>75</bold></highlight>. An apparatus as set forth in <dependent-claim-reference depends_on="CLM-00077">claim 74</dependent-claim-reference>, wherein the means for transmitting is operative for retransmitting all or a portion of the chunk based on at least one of: the information contained in the acknowledgment, and nonreceipt of the acknowledgment within an allowed amount of time. </claim-text>
</claim>
<claim id="CLM-00076">
<claim-text><highlight><bold>76</bold></highlight>. An apparatus as set forth in <dependent-claim-reference depends_on="CLM-00077">claim 72</dependent-claim-reference>, wherein means for transmitting further includes means for changing the redtype of the chunks and transmission packets to be transmitted. </claim-text>
</claim>
<claim id="CLM-00077">
<claim-text><highlight><bold>77</bold></highlight>. An apparatus as set forth in <dependent-claim-reference depends_on="CLM-00077">claim 70</dependent-claim-reference>, wherein the means for transmitting is operative for changing the number of the transmission chunks within the superchunk. </claim-text>
</claim>
<claim id="CLM-00078">
<claim-text><highlight><bold>78</bold></highlight>. An apparatus as set forth in <dependent-claim-reference depends_on="CLM-00077">claim 76</dependent-claim-reference>, wherein the redtype is changed dynamically based on at least one of: the information in the acknowledgments received from the chunks previously transmitted and nonreceipt of the acknowledgment within an allowed time. </claim-text>
</claim>
<claim id="CLM-00079">
<claim-text><highlight><bold>79</bold></highlight>. An apparatus as set forth in <dependent-claim-reference depends_on="CLM-00077">claim 77</dependent-claim-reference>, wherein the number of chunks in a superchunk is changed dynamically based on at least one of: information in acknowledgments received from the chunks previously transmitted and nonreceipt of an acknowledgment within an allowed time. </claim-text>
</claim>
<claim id="CLM-00080">
<claim-text><highlight><bold>80</bold></highlight>. An apparatus for regenerating at least one information packet transmitted over a data network, comprising: 
<claim-text>means for receiving a plurality of information packets and at least one parity packet (collectively &ldquo;transmission packets&rdquo;), said parity packet having a content based on said information packets; </claim-text>
<claim-text>means for detecting any problems which may exist relative to any of said plurality of information packets which were originally transmitted, said problems including one of packet loss and packet damage; and </claim-text>
<claim-text>means for regenerating at least one of said plurality of information packets using said at least one parity packet, wherein the regeneration of said information packets is based on the detection of problems relative to said plurality of information packets. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00081">
<claim-text><highlight><bold>81</bold></highlight>. An apparatus as set forth in <dependent-claim-reference depends_on="CLM-00088">claim 80</dependent-claim-reference>, wherein said means for detecting comprises means for analyzing check parameters associated with said information packets to identify said problems. </claim-text>
</claim>
<claim id="CLM-00082">
<claim-text><highlight><bold>82</bold></highlight>. An apparatus as set forth in <dependent-claim-reference depends_on="CLM-00088">claim 80</dependent-claim-reference>, wherein the means for detecting includes means for determining whether any of said plurality of information and parity packets has not been received within an allowed time. </claim-text>
</claim>
<claim id="CLM-00083">
<claim-text><highlight><bold>83</bold></highlight>. An apparatus as set forth in <dependent-claim-reference depends_on="CLM-00088">claim 80</dependent-claim-reference>, wherein the received transmission packets comprise up to 2<highlight><superscript>N</superscript></highlight>&minus;1 packets including N parity packets and said means for regenerating comprises processing means for processing said up to 2<highlight><superscript>N</superscript></highlight>&minus;1 packets to obtain up to (2N&minus;1)-N information packets. </claim-text>
</claim>
<claim id="CLM-00084">
<claim-text><highlight><bold>84</bold></highlight>. An apparatus as set forth in <dependent-claim-reference depends_on="CLM-00088">claim 80</dependent-claim-reference>, further including means for transmitting an acknowledgment upon receipt of a portion of the plurality of information packets, where the acknowledgment contains information that includes retransmission requirements for information packets previously transmitted. </claim-text>
</claim>
<claim id="CLM-00085">
<claim-text><highlight><bold>85</bold></highlight>. An apparatus as set forth in <dependent-claim-reference depends_on="CLM-00088">claim 80</dependent-claim-reference> wherein the means for regenerating comprises means for performing an XOR operation between corresponding bits in a payload portion of the information and parity packets received from the data network. </claim-text>
</claim>
<claim id="CLM-00086">
<claim-text><highlight><bold>86</bold></highlight>. An apparatus for use in configuring network node equipment to transmit parity packets in addition to information packets, comprising: 
<claim-text>storage means configured to store logic for receiving a data stream, dividing said stream into information packets and generating parity packets having a content based on said information packets, wherein said parity packets can be used at a receiving node to regenerate information packets lost during a network transmission; and </claim-text>
<claim-text>downloading means for use in downloading said logic to said network node equipment. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00087">
<claim-text><highlight><bold>87</bold></highlight>. An apparatus as set forth in <dependent-claim-reference depends_on="CLM-00088">claim 86</dependent-claim-reference>, wherein said storage means is configured to store logic for dividing at least a portion said data stream into N packets and generating one parity packet having a content based on said N packets. </claim-text>
</claim>
<claim id="CLM-00088">
<claim-text><highlight><bold>88</bold></highlight>. An apparatus as set forth in <dependent-claim-reference depends_on="CLM-00088">claim 86</dependent-claim-reference>, wherein said storage means is configured to store logic for dividing said data stream into up to 2<highlight><superscript>N</superscript></highlight>&minus;1 information packets and generate N parity packets based on said information packets, where N is an integer of at least 3. </claim-text>
</claim>
<claim id="CLM-00089">
<claim-text><highlight><bold>89</bold></highlight>. An apparatus as set forth in <dependent-claim-reference depends_on="CLM-00088">claim 86</dependent-claim-reference>, wherein said downloading means comprises a communications port for use in receiving and transmitting data in a network. </claim-text>
</claim>
<claim id="CLM-00090">
<claim-text><highlight><bold>90</bold></highlight>. An apparatus for use in configuring network node equipment to regenerate data packets lost in a network transmission, comprising: 
<claim-text>storage means configured to store logic for receiving a stream of information packets and parity packets where the parity packets have a content based on said information packets, for identifying a lost information packet and for using at least one of said parity packets to regenerate said lost information packet and </claim-text>
<claim-text>downloading means for use in downloading said logic to said network node equipment. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00091">
<claim-text><highlight><bold>91</bold></highlight>. An apparatus as set forth in claim <highlight><bold>90</bold></highlight>, wherein said downloading means comprises a communications port for use in receiving and transmitting data in a network. </claim-text>
</claim>
<claim id="CLM-00092">
<claim-text><highlight><bold>92</bold></highlight>. A method for constructing a system for transmitting information over a data network comprising: 
<claim-text>identifying a transmitting node on the data network, wherein the transmitting node includes a first processing means which receives a data stream containing the information to be transmitted; </claim-text>
<claim-text>providing to the first processing means: 
<claim-text>means for dividing a the data stream into a plurality of information packets; </claim-text>
<claim-text>means for generating at least one parity packet with a content generated from a selected number of said plurality of information packets, and including the at least one parity packet with the plurality of information packets; and </claim-text>
<claim-text>means for transmitting the plurality of information packets and the at least one parity packet over the data network; </claim-text>
</claim-text>
<claim-text>identifying a receiving node on the data network, wherein the receiving node includes a second processing means which reconstructs the information transmitted over the network into the data stream; and </claim-text>
<claim-text>providing to the second processing means: 
<claim-text>means for detecting arrival of a plurality of the information packets, at least one parity packet with a content generated from a selected number of said information packets, and any problems which may exist relative to any of said plurality of information packets which were originally transmitted; and </claim-text>
<claim-text>means for regenerating at least one of said plurality of information packets using a combination of said at least one parity packet, wherein the regeneration of said information transmission packets is based on the detection of problems relative to said plurality of information packets.</claim-text>
</claim-text>
</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>1</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030002502A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030002502A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030002502A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030002502A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030002502A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030002502A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030002502A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030002502A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030002502A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00009">
<image id="EMI-D00009" file="US20030002502A1-20030102-D00009.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00010">
<image id="EMI-D00010" file="US20030002502A1-20030102-D00010.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00011">
<image id="EMI-D00011" file="US20030002502A1-20030102-D00011.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00012">
<image id="EMI-D00012" file="US20030002502A1-20030102-D00012.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00013">
<image id="EMI-D00013" file="US20030002502A1-20030102-D00013.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00014">
<image id="EMI-D00014" file="US20030002502A1-20030102-D00014.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00015">
<image id="EMI-D00015" file="US20030002502A1-20030102-D00015.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00016">
<image id="EMI-D00016" file="US20030002502A1-20030102-D00016.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00017">
<image id="EMI-D00017" file="US20030002502A1-20030102-D00017.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00018">
<image id="EMI-D00018" file="US20030002502A1-20030102-D00018.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
