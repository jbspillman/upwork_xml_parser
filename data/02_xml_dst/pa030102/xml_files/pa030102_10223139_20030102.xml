<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030005158A1-20030102-D00000.TIF SYSTEM "US20030005158A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030005158A1-20030102-D00001.TIF SYSTEM "US20030005158A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030005158A1-20030102-D00002.TIF SYSTEM "US20030005158A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030005158A1-20030102-D00003.TIF SYSTEM "US20030005158A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030005158A1-20030102-D00004.TIF SYSTEM "US20030005158A1-20030102-D00004.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030005158</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10223139</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20020819</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G06F015/16</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>709</class>
<subclass>245000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Distributed program relocation for a computer system</title-of-invention>
</technical-information>
<continuity-data>
<continuations>
<continuation-of>
<parent-child>
<child>
<document-id>
<doc-number>10223139</doc-number>
<kind-code>A1</kind-code>
<document-date>20020819</document-date>
</document-id>
</child>
<parent>
<document-id>
<doc-number>09465475</doc-number>
<document-date>19991216</document-date>
<country-code>US</country-code>
</document-id>
</parent>
<parent-status>GRANTED</parent-status>
<parent-patent>
<document-id>
<doc-number>6467084</doc-number>
<country-code>US</country-code>
</document-id>
</parent-patent>
</parent-child>
</continuation-of>
</continuations>
</continuity-data>
<inventors>
<first-named-inventor>
<name>
<given-name>Michael</given-name>
<middle-name>L.</middle-name>
<family-name>Howard</family-name>
</name>
<residence>
<residence-us>
<city>Sandy</city>
<state>UT</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Stephen</given-name>
<middle-name>C.</middle-name>
<family-name>Coffin</family-name>
</name>
<residence>
<residence-us>
<city>Layton</city>
<state>UT</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>MADSON &amp; METCALF</name-1>
<name-2>GATEWAY TOWER WEST</name-2>
<address>
<address-1>SUITE 900</address-1>
<address-2>15 WEST SOUTH TEMPLE</address-2>
<city>SALT LAKE CITY</city>
<state>UT</state>
<postalcode>84101</postalcode>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">Systems and methods are disclosed for preparing program code for a first computer, wherein the systems and methods are implemented on a second computer. The systems include a relocating module that is adapted to relocate program code by modifying locations in the program code identified by location data. The modifications made by the relocating module are based on a memory address. The systems operate on program code for the first computer, where the program code is stored on the second computer. The relocating module is provided the memory address that identifies a memory location in the first computer. The memory address is suitable as a basis for modifying the program code. The relocating module is also provided with location data that identifies locations in the program code to be adjusted based on the memory address. A method practiced in accordance with the disclosed embodiments includes the steps of obtaining the program code; obtaining the memory address; obtaining the location data; and modifying the locations in the program code identified by the location data, by using the memory address and by using the location data, where the modifying step is accomplished at the second computer. One or more computer programs for implementing the described systems and/or methods may be embodied in a computer-readable medium. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">BACKGROUND </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> 1. The Field of the Invention </paragraph>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> This invention relates to computer software and, more particularly, to novel systems and methods for distributing and relocating computer software and data across a computer network. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> 2. The Background Art </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> In recent years there has been a great increase in the amount of computer technology that is involved in daily life. In today&apos;s world, computer technology is involved in many aspects of a person&apos;s day. Many devices being used today by consumers have a small computer inside of the device. These small computers come in varying sizes and degrees of sophistication. These small computers include everything from one microcontroller to a fully-functional complete computer system. For example, these small computers may be a one-chip computer, such as a microcontroller, a one-board type of computer, such as a controller, a typical desktop computer, such as an IBM-PC compatible, etc. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> The small computers, (which can be rather large computers depending on the particular need which is being met by the computer), almost always have one or more processors at the heart of the computer. The processor(s) usually are interconnected to different external inputs and outputs and function to manage the particular device. For example, a processor in a vending machine for soda pop may be connected to the buttons used to select the pop, to the switch that allows a pop to drop down to a user, and to lights to indicate that the machine does not have any more pop of a particular variety. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> Computer technology is involved in many aspects of daily life. Many appliances, devices, etc., include one or more small computers. For example, refrigerators, telephones, typewriters, automobiles, vending machines, and many different types of industrial equipment all have small computers or processors inside of them. Computer software runs the processors of these computers and tells the processors what to do to carry out certain tasks. For example, the computer software running on a processor in a vending machine may cause a soda pop to drop to a user when the correct change has been entered by a user. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> These types of small computers that are a part of a device, appliance, tool, etc., are often referred to as embedded systems. The term &ldquo;embedded system&rdquo; usually refers to computer hardware and software that is part of a larger system. Embedded systems usually do not have typical input and output devices such as a keyboard, mouse, and/or monitor. Usually, at the heart of each embedded system is one or more processor(s). </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> Typically the embedded systems used today with various appliances, devices, etc., do not have a lot of storage capability. As a result, the amount of data that can be stored on the embedded systems is limited. With only limited storage, an embedded system may not have as many features and capabilities as it could have if it had more available storage. Memory is often conserved in these embedded systems that monitor, control and otherwise use electronic devices. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> Almost all desktop computer systems include memory management capabilities at the processor level (hardware), firmware level (the software embedded into the hardware), and at the operating system level. However, in many embedded devices, these types of memory management capabilities are not available. For example, many of the embedded environments include an 8-bit or 16-bit microcontroller, where no substantial operating system or memory management features are present. In these types of environments, any program code is typically developed and loaded onto the embedded device by the manufacture before the device is shipped, after which software upgrades are rarely if ever even contemplated. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> Because many embedded devices do not have extensive memory management capabilities, it is often difficult to easily upgrade the software, upgrade modules, upgrade components and/or to add new software, new components, new modules, new features, new extensions, etc. </paragraph>
</section>
<section>
<heading lvl="1">BRIEF SUMMARY AND OBJECTS OF THE INVENTION </heading>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> In view of the foregoing, it is an object of the present invention to provide a system and methods for preparing software for a computer. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> Consistent with the foregoing object, and in accordance with the embodiments as embodied and broadly described herein, a system for preparing program code for a first computer, wherein the system is implemented on a second computer, includes a relocating module that is adapted to relocate program code by modifying locations in the program code identified by location data. The modifications made by the relocating module are based on a memory address. The system will operate on program code for the first computer, where the program code is stored on the second computer. The relocating module is provided the memory address that identifies a memory location in the first computer. The memory address is suitable as a basis for modifying the program code. The relocating module is also provided with location data that identifies locations in the program code to be adjusted based on the memory address. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> A system made in accordance with the disclosed embodiments may optionally include memory usage information of the first computer from which the memory address can be derived. In addition, the system may also include a list that includes the location data. Optionally, the memory address may be obtained from the first computer. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> The second computer may also include a communication module for obtaining the memory address and for communicating the modified program code to the first computer. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> A method practiced in accordance with the disclosed embodiments may include the steps of obtaining the program code from a storage device in electronic communication with the second computer; obtaining a memory address identifying a memory location in the first computer, where the memory address is suitable as a basis for modifying the program code; obtaining location data that identifies locations in the program code to be adjusted based on the memory address; and modifying the locations in the program code identified by the location data, by using the memory address and by using the location data, where the modifying step is accomplished at the second computer. </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> One or more computer programs for implementing the described systems and/or methods may be embodied in a computer-readable medium. The computer-readable medium may be a data transmission medium. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> The embodiments disclosed provide systems and methods for preparing program code for a first computer where the system and/or methods are implemented on a second computer. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> The presently preferred embodiments use a minimal set of software routines for accessing storage on an embedded device (EEPROM, FLASH, battery backed-up RAM, etc.), while providing a substantial portion of the higher-level (and larger) memory-management software components on a computer connected to the embedded device(s). Thus, the preferred embodiments allow an embedded device, its capabilities and/or its features to be upgraded or enhanced.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> The foregoing and other objects and features of the present embodiments will become more fully apparent from the following description and appended claims, taken in conjunction with the accompanying drawings. Understanding that these drawings depict only typical embodiments and are, therefore, not to be considered limiting of the invention&apos;s scope, the embodiments will be described with additional specificity and detail through use of the accompanying drawings in which: </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is block diagram of the major hardware components included in the presently preferred embodiments; </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is block diagram of the initial processing accomplished in the presently preferred embodiments; </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> is a block diagram of the major computer program and data components of the presently preferred embodiments; </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a flow diagram of the initial processing accomplished in the presently preferred embodiments; and </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a flow diagram illustrating steps that are followed in the presently preferred embodiments.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION </heading>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> It will be readily understood that the components of the embodiments, as generally described and illustrated in the Figures herein, could be arranged and designed in a wide variety of different configurations. Thus, the following more detailed description of the embodiments of the systems and methods disclosed, as represented in <cross-reference target="DRAWINGS">FIGS. 1 through 5</cross-reference>, is not intended to limit the scope of the invention, as claimed, but is merely representative of the presently preferred embodiments. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> The presently preferred embodiments will be best understood by reference to the drawings, wherein like parts are designated by like numerals throughout. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> A system for preparing program code for a first computer, wherein the system is implemented on a second computer, includes a relocating module that is adapted to relocate program code by modifying locations in the program code identified by location data. The modifications made by the relocating module are based on a memory address. The system will operate on program code for the first computer, where the program code is stored on the second computer. The relocating module is provided the memory address that identifies a memory location in the first computer. The memory address is suitable as a basis for modifying the program code. The relocating module is also provided with location data that identifies locations in the program code to be adjusted based on the memory address. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> A system made in accordance with the disclosed embodiments may optionally include memory usage information of the first computer from which the memory address can be derived. In addition, the system may also include a list that includes the location data. Optionally, the memory address may be obtained from the first computer. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> The second computer may also include a communication module for obtaining the memory address and for communicating the modified program code to the first computer. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> A method practiced in accordance with the disclosed embodiments may include the steps of obtaining the program code from a storage device in electronic communication with the second computer; obtaining a memory address identifying a memory location in the first computer, where the memory address is suitable as a basis for modifying the program code; obtaining location data that identifies locations in the program code to be adjusted based on the memory address; and modifying the locations in the program code identified by the location data, by using the memory address and by using the location data, where the modifying step is accomplished at the second computer. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> One or more computer programs for implementing the described systems and/or methods may be embodied in a computer-readable medium. The computer-readable medium may be a data transmission medium. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is block diagram illustrating the major hardware components typically utilized in the presently preferred embodiments. The presently preferred embodiments are used in a networked computer system <highlight><bold>10</bold></highlight> where a host computer <highlight><bold>12</bold></highlight> is connected to an embedded device <highlight><bold>14</bold></highlight>. Typically the embedded device <highlight><bold>14</bold></highlight> includes a computer <highlight><bold>16</bold></highlight> connected to input and output devices <highlight><bold>18</bold></highlight>, <highlight><bold>20</bold></highlight>. The computer <highlight><bold>16</bold></highlight>, in the presently preferred embodiments, is an embedded computer <highlight><bold>16</bold></highlight>. Particularly, in the presently preferred embodiments, the computer <highlight><bold>16</bold></highlight> comprises a microcontroller (not shown). However, it will be appreciated by one skilled in the art that the functions and processing normally carried out by a microcontroller could be carried out by larger processors, whether they are part of a larger controller or part of a typical computer system. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> In the presently preferred embodiments, the embedded computer <highlight><bold>16</bold></highlight> is remote from the host computer <highlight><bold>12</bold></highlight> in that the embedded computer <highlight><bold>16</bold></highlight> and host computer <highlight><bold>12</bold></highlight> are each computers capable of functioning on their own. The term remote does not necessarily mean that the embedded computer <highlight><bold>16</bold></highlight> is at a different location than the host computer <highlight><bold>12</bold></highlight>, although in many embodiments the host computer <highlight><bold>12</bold></highlight> is at a different location than the embedded computer <highlight><bold>16</bold></highlight>. The terms embedded computer <highlight><bold>16</bold></highlight> and remote computer <highlight><bold>16</bold></highlight> may be used interchangeably herein. Those elements discussed as being stored and/or implemented by the remote computer <highlight><bold>16</bold></highlight> could be stored and/or implemented at the host computer <highlight><bold>12</bold></highlight>, in some circumstances. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> The present embodiments have a broad application to many kinds of computer networks <highlight><bold>10</bold></highlight> and to many kinds of computers. Generally, the computer system <highlight><bold>10</bold></highlight> of the presently preferred embodiments also includes one or more client computers <highlight><bold>22</bold></highlight> for monitoring and/or controlling the embedded device <highlight><bold>14</bold></highlight>. The remote computer <highlight><bold>16</bold></highlight> is operably connected to input and/or output devices <highlight><bold>18</bold></highlight>, <highlight><bold>20</bold></highlight> capable of electronic communication with the remote computer <highlight><bold>16</bold></highlight>, or, in other words, to devices <highlight><bold>18</bold></highlight>, <highlight><bold>20</bold></highlight> capable of input and/or output in the form of an electrical signal. Sometimes the input and output device(s) <highlight><bold>18</bold></highlight>, <highlight><bold>20</bold></highlight> and the remote computer <highlight><bold>16</bold></highlight> are both housed within the same physical structure. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> The host computer <highlight><bold>12</bold></highlight> and the remote computer <highlight><bold>16</bold></highlight> are both broadly defined digital computers. A computer, as used herein, is any device that includes a digital processor capable of receiving and processing data. A computer includes the broad range of digital computers including microcontrollers, hand-held computers, personal computers, servers, mainframes, supercomputers, and any variation or related device thereof. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> The input and output devices <highlight><bold>18</bold></highlight>, <highlight><bold>20</bold></highlight> include any component, element, mechanism, appliance, or the like capable of receiving and/or generating an electronic signal. Examples of devices within the scope of the term device includes a vending machine, a telephone, a door lock, a temperature sensor, a relay, an optical sensor, a motor, a switch, a light, etc. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> In current design, the host computer <highlight><bold>12</bold></highlight> is typically an IBM-compatible personal computer running the Linux operating system or the Microsoft Windows NT operating system. In addition, the host computer <highlight><bold>12</bold></highlight> may also be running the Microsoft Windows 95/98 operating system. The remote computer <highlight><bold>16</bold></highlight> typically includes an embedded processor (not shown), and, as stated, often includes a microcontroller. The devices <highlight><bold>18</bold></highlight>, <highlight><bold>20</bold></highlight> can be any devices with electronic interfaces of which a processor could directly or indirectly interface and interact with. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> One possible item that may be used with the present embodiments is a vending machine (not shown). Many vending machines include one or more microcontrollers for controlling different parts of the vending machines. These microcontrollers fall within the scope of remote computer <highlight><bold>16</bold></highlight>. The input and output devices <highlight><bold>18</bold></highlight>, <highlight><bold>20</bold></highlight> include the buttons for selecting items from the vending machine, switches for allowing those items to be dropped down to the user, lights for indicating which items are gone, the change release for releasing any change, etc. As known in the art, this vending machine embodiment includes the input and output devices <highlight><bold>18</bold></highlight>, <highlight><bold>20</bold></highlight> and the remote computer(s) <highlight><bold>16</bold></highlight> integrated within the same structure. The present embodiments, therefore, may be implemented in such an environment. Those skilled in the art will also realize that the remote computer <highlight><bold>16</bold></highlight> may be in a separate structure from its attached input and output device(s) <highlight><bold>18</bold></highlight>, <highlight><bold>20</bold></highlight>. Many of the modern devices do come with embedded microcontrollers, for example, many cellular phones, pagers, copy machines, printers and the like come with embedded microcontrollers. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> The host computer <highlight><bold>12</bold></highlight> may be connected to the remote computer <highlight><bold>16</bold></highlight> through a variety of connections, including RS-323, RS-485, modem, power line, wired connection, wireless connection, etc. Similarly, the remote computer <highlight><bold>16</bold></highlight> may be connected to various input and output devices <highlight><bold>18</bold></highlight>, <highlight><bold>20</bold></highlight> through a variety of ways. As stated, typically the remote computer <highlight><bold>16</bold></highlight> comprises a microcontroller (not shown). Microcontrollers often have input/output ports for communicating with external devices. These specifications of the particular microcontroller often dictate how a device is connected to the microcontroller. Those skilled in the art appreciate how different devices may be connected to computers, whether they are embedded computers, standard desktop computers, mainframes, etc. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> As stated, client computers <highlight><bold>22</bold></highlight> may also be included within the computer system <highlight><bold>10</bold></highlight>. Such a configuration allows users to access services at the remote computer <highlight><bold>14</bold></highlight> through the host computer <highlight><bold>12</bold></highlight>, even over great distances. The host computer <highlight><bold>12</bold></highlight> and the client computers <highlight><bold>22</bold></highlight> may all be connected together on a computer network <highlight><bold>24</bold></highlight>, such as a LAN, WAN, etc. In addition, the client computer <highlight><bold>22</bold></highlight> may connect from a remote location to the host computer <highlight><bold>12</bold></highlight> via a dial up connection, via an intranet, or via the Internet. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is an illustration depicting the initial processing that occurs in the presently preferred embodiments. As shown, a compiler <highlight><bold>26</bold></highlight> and/or linker <highlight><bold>26</bold></highlight> processes input files <highlight><bold>28</bold></highlight> to create a relocatable program module <highlight><bold>31</bold></highlight>. In current design, the relocatable program module <highlight><bold>31</bold></highlight> includes a relocation table <highlight><bold>30</bold></highlight> and relocatable program code <highlight><bold>32</bold></highlight>. The relocation table <highlight><bold>30</bold></highlight> is used by the presently preferred embodiment to modify the relocatable program code <highlight><bold>32</bold></highlight> so that it can be properly loaded onto the remote computer <highlight><bold>16</bold></highlight> and properly run thereon. Although in current design the relocatable program module <highlight><bold>31</bold></highlight> is typically one file that includes both the relocation table <highlight><bold>30</bold></highlight> and the relocatable program code <highlight><bold>32</bold></highlight>, it will be appreciated by those skilled in the art that the components of the relocatable program module <highlight><bold>31</bold></highlight> may be stored in a variety of ways, including multiple data structures, multiple files, etc. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> The input files <highlight><bold>28</bold></highlight> are those files that are taken as input by the compiler <highlight><bold>26</bold></highlight> and/or linker <highlight><bold>26</bold></highlight>. Thus, the input files <highlight><bold>28</bold></highlight> of the presently preferred embodiments may be typical source files created by software engineers in developing software. Those skilled in the art will appreciate that many different kinds of source files may be used. Typically the source files used in the presently preferred embodiments are C source files (e.g., file<highlight><bold>1</bold></highlight>.c), C&plus;&plus; source files (e.g., file2. cpp), along with their associated header files (e.g., file1.h) and/or assembly source files (e.g., file3. asm). </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> The input files <highlight><bold>28</bold></highlight> may also be object files and/or libraries. Object files and/or libraries are typical input files <highlight><bold>28</bold></highlight> to a linker <highlight><bold>26</bold></highlight>. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> Those skilled in the art will appreciate what a compiler accomplishes and what a linker accomplishes. Compilers and linkers are readily available. Generally, a compiler/linker <highlight><bold>26</bold></highlight> is a piece of software that translates a program written in a high-level programming language (i.e., the source files and other needed files) into machine language of the target computer. In most cases, the compiler/linker <highlight><bold>26</bold></highlight> actually accomplishes its tasks in two stages: a compiling stage and a linking stage. The compiling stage occurs first wherein the source files are translated into machine language of the target computer. Then the linker, sometimes referred to as linkage editor, converts the output from the compiler into a form that can actually be loaded and executed by a computer. The linker&apos;s main function is to resolve or unite references between program modules and libraries of subroutines. Its output is a load module which is a program that is typically ready to run in the computer. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> In the present embodiments the compiler/linker <highlight><bold>26</bold></highlight> is used to generate the relocatable program module <highlight><bold>31</bold></highlight>. There are commercially available compilers/linkers <highlight><bold>26</bold></highlight> that can be used to generate the relocatable program module. For example, the gcc compiler from the Free Software Foundation can be used to generate a relocatable program module. In addition, the Watcom compiler from Sybase can be used. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> Typical desktop computers include processors that include memory management hardware and firmware. In addition, the operating system running on the desktop also includes memory management facilities. For example, Intel&apos;s Pentium CPU includes memory management hardware and firmware, and Microsoft&apos;s Windows operating systems include memory management components as well. The combination of these memory management tools facilitates computer programs being able to run wherever the operating system properly places it in memory. Because of these memory management tools, computer programs for desktop computers can be compiled and linked with little or no knowledge of the specific location in memory it will be placed when it is executed. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> Many of the embedded devices being used today use 8-bit and 16-bit microcontrollers that either do not have memory management hardware and firmware, or only have very limited memory management capabilities. In addition, typically where these types of microcontrollers are used, the embedded system has very little memory. In many cases in such resource constrained environments, and because there is limited memory resources, there is no operating system provided. Accordingly, there is no operating system to provide memory management functionality in these types of systems. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> For these resource constrained embedded environments, as just described, in order for program code to be linked together so that it can be loaded and executed by the embedded environment, the compiler/linker <highlight><bold>26</bold></highlight> would need to know the addresses in the memory of the remote computer where the program code was going to be placed. The present embodiments overcome this requirement by allowing the program code for the remote computer to be compiled and linked first into a relocatable program format. Then, at a later time and when the particular addresses of where the program code is to be placed on the remote computer are known, the program code can be relocated and loaded onto the remote computer. An initial step in practicing the presently preferred embodiments is to compile and/or link the program code into relocatable code. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> The compiler/linker <highlight><bold>26</bold></highlight> is used to translate the input files <highlight><bold>28</bold></highlight> into relocatable program code <highlight><bold>32</bold></highlight>. The compiler/linker <highlight><bold>26</bold></highlight> also generates a relocation table <highlight><bold>30</bold></highlight>. In the presently preferred embodiment, the relocatable program code <highlight><bold>32</bold></highlight> is machine language for the remote computer <highlight><bold>16</bold></highlight> that would be ready to load and run on the remote computer <highlight><bold>16</bold></highlight> if any existing unresolved address references were resolved. The relocation table <highlight><bold>30</bold></highlight> of the preferred embodiment contains a list of references in the relocatable program code <highlight><bold>32</bold></highlight> that need to be resolved once it is known where in the remote computer <highlight><bold>16</bold></highlight> memory the program code <highlight><bold>32</bold></highlight> is to be loaded. In current design, the relocation table <highlight><bold>30</bold></highlight> identifies the location of the reference and the size of the reference that needs to be adjusted. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> Those skilled in the art have authored computer programs including writing the source code, compiling and linking it, and then executing the program on the target computer. Thus, those skilled in the art understand the contents and significance of input files <highlight><bold>28</bold></highlight>, compiled code and linked code. Accordingly, the following examples included in Tables 1-6 are meant to illustrate the principles of the presently preferred embodiments and are not meant to show actual program code source files, compiled code or the like. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> Table 1 illustrates in skeletal form and in pseudocode form a source file.  
<table-cwu id="TABLE-US-00001">
<number>1</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="42PT" align="left"/>
<colspec colname="1" colwidth="56PT" align="left"/>
<colspec colname="2" colwidth="119PT" align="left"/>
<thead>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center">TABLE 1</entry>
</row>
<row>
<entry></entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
<entry>1A</entry>
<entry>main program</entry>
</row>
<row>
<entry></entry>
<entry>1B</entry>
<entry>&lt;program instructions&gt;</entry>
</row>
<row>
<entry></entry>
<entry>1C</entry>
<entry>call to functionA</entry>
</row>
<row>
<entry></entry>
<entry>1D</entry>
<entry>&lt;program instructions&gt;</entry>
</row>
<row>
<entry></entry>
<entry>1E</entry>
<entry>call to functionB</entry>
</row>
<row>
<entry></entry>
<entry>1F</entry>
<entry>&lt;program instructions&gt;</entry>
</row>
<row>
<entry></entry>
<entry>1G</entry>
<entry>jump to placeC</entry>
</row>
<row>
<entry></entry>
<entry>1H</entry>
<entry>&lt;program instructions&gt;</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> As illustrated in Table 1, a source file may include a function or procedure entitled main <highlight><bold>1</bold></highlight>A. The main function <highlight><bold>1</bold></highlight>A may include various program instructions, illustrated at <highlight><bold>1</bold></highlight>B, <highlight><bold>1</bold></highlight>D, <highlight><bold>1</bold></highlight>F and <highlight><bold>1</bold></highlight>H. Included in the instructions of the function may be calls to other functions or procedures, illustrated by a call to functionA <highlight><bold>1</bold></highlight>C and a call to functionB <highlight><bold>1</bold></highlight>E. The instructions may also include a jump to placeC <highlight><bold>1</bold></highlight>G. After compiling the source file there may be various addresses needed in order to completely link the code together. For example, various function calls and jumps may need to have addresses in order to be resolved. In the presently preferred embodiment, a list, table, file or other data structure is used to track what references in the compiled program code need to be resolved before it can be loaded and executed on the remote computer <highlight><bold>16</bold></highlight>. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> Table 2 contains pseudocode illustrating what types of information may be stored in the relocation table <highlight><bold>30</bold></highlight>. Following the example of Table 1, a relocation table <highlight><bold>30</bold></highlight> may contain the information necessary to identify the addresses that need to be resolved or updated when the specific memory location is known, and also the information necessary to know what size the address is that needs to be updated. Table 2 includes the offset address for the call to functionA <highlight><bold>2</bold></highlight>A. In addition, Table 2 illustrates the storage of the size of the address <highlight><bold>2</bold></highlight>A that needs to be resolved or updated. Thus, the program code <highlight><bold>32</bold></highlight> can be linked and be made ready for the remote computer, once the memory addresses are known, by cycling through the relocation table <highlight><bold>30</bold></highlight>, going to each indicated offset address and adjusting the address according to the newly found memory information of exactly where in memory the functionA code will be found. The information <highlight><bold>2</bold></highlight>B for functionB is also stored in the relocation table. Similarly, the reference to the jump is also stored in the relocation table so that it can be updated according to the memory information to be obtained.  
<table-cwu id="TABLE-US-00002">
<number>2</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="154PT" align="left"/>
<thead>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center">TABLE 2</entry>
</row>
<row>
<entry></entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
<entry>2A</entry>
<entry>functionA call offset address, size of address</entry>
</row>
<row>
<entry></entry>
<entry>2B</entry>
<entry>functionB call offset address, size of address</entry>
</row>
<row>
<entry></entry>
<entry>2C</entry>
<entry>jump to placeC offset, size of address</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> In the preferred embodiment, the information contained in the relocation table <highlight><bold>30</bold></highlight> is used to update the relocatable program code <highlight><bold>32</bold></highlight> so that it can be loaded and executed on the remote computer. Table 3 illustrates what the relocatable program code may contain, following the example illustrated in Tables 1 and 2. The relocatable program code <highlight><bold>32</bold></highlight> contains machine language <highlight><bold>3</bold></highlight>A-<highlight><bold>3</bold></highlight>H for the remote computer. Included in these machine language instructions <highlight><bold>3</bold></highlight>A-<highlight><bold>3</bold></highlight>H are instructions that include addresses that are not yet resolved or finalized.  
<table-cwu id="TABLE-US-00003">
<number>3</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="168PT" align="left"/>
<thead>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center">TABLE 3</entry>
</row>
<row>
<entry></entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
<entry>3A</entry>
<entry>&lt;machine language&gt;</entry>
</row>
<row>
<entry></entry>
<entry>3B</entry>
<entry>&lt;machine language&gt;</entry>
</row>
<row>
<entry></entry>
<entry>3C</entry>
<entry>&lt;machine language-call to functionA at XXXX&gt;</entry>
</row>
<row>
<entry></entry>
<entry>3D</entry>
<entry>&lt;machine language&gt;</entry>
</row>
<row>
<entry></entry>
<entry>3E</entry>
<entry>&lt;machine language-call to functionB at YYYY&gt;</entry>
</row>
<row>
<entry></entry>
<entry>3F</entry>
<entry>&lt;machine language&gt;</entry>
</row>
<row>
<entry></entry>
<entry>3G</entry>
<entry>&lt;machine language-jump to placeC at ZZZZ&gt;</entry>
</row>
<row>
<entry></entry>
<entry>3H</entry>
<entry>&lt;machine language&gt;</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> The example of the call fo functionA is illustrated in machine language <highlight><bold>3</bold></highlight>C. Because this call is in relocatable format, the address to go to, indicated at XXXX, is not yet finalized. Once the memory addresses for the program code are known from the remote computer, the address XXXX may be updated to reflect the location where the code is to be loaded into the remote computer&apos;s memory. Similar to the machine language call to functionA <highlight><bold>3</bold></highlight>C, the machine language call to functionB <highlight><bold>3</bold></highlight>E can be resolved by updating the address of YYYY. The address ZZZZ included in the machine language jump to placeC <highlight><bold>3</bold></highlight>G can also be updated. Once the various unresolved addresses have been updated or resolved, the modified program code is ready to be loaded onto the remote computer. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> The following examples included in Tables 4-6 are also meant to illustrate the principles of the presently preferred embodiments and are not meant to show actual program code source files, compiled code or the like. In the examples of Tables 4-6, references to both program memory and data memory will be illustrated. It will be appreciated by those skilled in the art that in certain systems program memory and data memory will be in separate spaces. If they are in separate spaces, references to program memory may be updated based on a program memory address, and references to data program memory may be updated based on a data memory address. </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> Table 4 illustrates in skeletal form and in pseudocode form a source file.  
<table-cwu id="TABLE-US-00004">
<number>4</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="28PT" align="left"/>
<colspec colname="2" colwidth="168PT" align="left"/>
<thead>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center">TABLE 4</entry>
</row>
<row>
<entry></entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
<entry>4A</entry>
<entry>main program</entry>
</row>
<row>
<entry></entry>
<entry>4B</entry>
<entry>&lt;program instructions&gt;</entry>
</row>
<row>
<entry></entry>
<entry>4C</entry>
<entry>call to functionA</entry>
</row>
<row>
<entry></entry>
<entry>4D</entry>
<entry>&lt;program instructions&gt;</entry>
</row>
<row>
<entry></entry>
<entry>4E</entry>
<entry>&lt;instruction&gt; reference to dataA in data memory</entry>
</row>
<row>
<entry></entry>
<entry>4F</entry>
<entry>&lt;instruction&gt; reference to dataB in data memory</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> As illustrated in Table 4, a source file may include a function or procedure entitled main <highlight><bold>4</bold></highlight>A. The main function <highlight><bold>4</bold></highlight>A may include various program instructions, illustrated at <highlight><bold>4</bold></highlight>B and <highlight><bold>4</bold></highlight>D. Included in the instructions of the function may be calls to other functions or procedures, and instructions with data references, illustrated by a call to functionA <highlight><bold>4</bold></highlight>C and instructions with data references <highlight><bold>4</bold></highlight>E, <highlight><bold>4</bold></highlight>F. After compiling the source file there may be various addresses needed in order to completely link the code together. For example, various function calls, jumps and/or data references may need to have addresses in order to be resolved. In the presently preferred embodiments, a list, table, file or other data structure is used to track what references in the compiled/linked program code need to be resolved before it can be loaded and executed on the remote computer <highlight><bold>16</bold></highlight>. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> Table 5 contains pseudocode illustrating what types of information may be stored in the relocation table <highlight><bold>30</bold></highlight>. Following the example of Table 4, a relocation table <highlight><bold>30</bold></highlight> may contain the information necessary to identify the addresses that need to be resolved or updated when the specific memory locations are known, and also the information necessary to know what size the address is that needs to be updated. Table 5 includes the offset address for the call to functionA <highlight><bold>5</bold></highlight>A. In addition, Table 5 illustrates the storage of the size of the address <highlight><bold>5</bold></highlight>A that needs to be resolved or updated. Thus, the program code <highlight><bold>32</bold></highlight> can be relocated and be made ready for the remote computer, once the memory addresses are known, by cycling through the relocation table <highlight><bold>30</bold></highlight>, going to each indicated offset address and adjusting the address according to the newly found memory information of exactly where in memory the functionA code will be found. </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> Table 5 also includes the address for the reference to dataA <highlight><bold>5</bold></highlight>B in data memory. It also includes the size <highlight><bold>5</bold></highlight>B of the address that needs to be resolved or updated. Similarly, the address for the reference to dataB <highlight><bold>5</bold></highlight>C in data memory is also included, with the size of its address <highlight><bold>5</bold></highlight>C.  
<table-cwu id="TABLE-US-00005">
<number>5</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="21PT" align="left"/>
<colspec colname="1" colwidth="42PT" align="left"/>
<colspec colname="2" colwidth="154PT" align="left"/>
<thead>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center">TABLE 5</entry>
</row>
<row>
<entry></entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
<entry>5A</entry>
<entry>functionA call offset address, size of address</entry>
</row>
<row>
<entry></entry>
<entry>5B</entry>
<entry>reference to dataA address, size of address</entry>
</row>
<row>
<entry></entry>
<entry>5C</entry>
<entry>reference to dataB address, size of address</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> In the preferred embodiments, the information contained in the relocation table <highlight><bold>30</bold></highlight> is used to update and relocate the relocatable program code <highlight><bold>32</bold></highlight> so that it can be loaded and executed on the remote computer. Table <highlight><bold>6</bold></highlight> illustrates what the relocatable program code may contain, following the example illustrated in Tables 4 and 5. The relocatable program code <highlight><bold>32</bold></highlight> contains machine language <highlight><bold>6</bold></highlight>A-<highlight><bold>6</bold></highlight>F for the remote computer. Included in these machine language instructions <highlight><bold>6</bold></highlight>A-<highlight><bold>6</bold></highlight>F are instructions that include addresses that are not yet resolved or finalized.  
<table-cwu id="TABLE-US-00006">
<number>6</number>
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="OFFSET" colwidth="14PT" align="left"/>
<colspec colname="1" colwidth="35PT" align="left"/>
<colspec colname="2" colwidth="168PT" align="left"/>
<thead>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center">TABLE 6</entry>
</row>
<row>
<entry></entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry></entry>
<entry>6A</entry>
<entry>&lt;machine language&gt;</entry>
</row>
<row>
<entry></entry>
<entry>6B</entry>
<entry>&lt;machine language&gt;</entry>
</row>
<row>
<entry></entry>
<entry>6C</entry>
<entry>&lt;machine language-call to functionA at PXXXX&gt;</entry>
</row>
<row>
<entry></entry>
<entry>6D</entry>
<entry>&lt;machine language&gt;</entry>
</row>
<row>
<entry></entry>
<entry>6E</entry>
<entry>&lt;machine language-reference to dataA at DYYYY&gt;</entry>
</row>
<row>
<entry></entry>
<entry>6F</entry>
<entry>&lt;machine language-reference to dataB at DZZZZ&gt;</entry>
</row>
<row>
<entry></entry>
<entry namest="OFFSET" nameend="2" align="center" rowsep="1"></entry>
</row>
</tbody>
</tgroup>
</table>
</table-cwu>
</paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> The example of the call fo functionA is illustrated in machine language <highlight><bold>6</bold></highlight>C. Because this call is in relocatable format, the address to go to, indicated at PXXXX, is not yet finalized. Once the memory addresses for the program area are known from the remote computer, the address PXXXX may be updated to reflect the location where the code is to be loaded into the remote computer&apos;s memory. Thus, the program code can be relocated. </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> The machine language that includes a reference to dataA <highlight><bold>6</bold></highlight>E also needs to be resolved. Once the memory addresses for the data areas are known from the remote computer, the address at DYYYY may be updated. Similarly, when the data areas are known, the reference to dataB at DZZZZ <highlight><bold>6</bold></highlight>F may be updated. Thus, the data references to data memory can be relocated. Once the various unresolved addresses have been updated or resolved, the program code, including items to be placed in data memory as well as items to be placed in program memory, is ready to be loaded onto the remote computer. </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> Although the foregoing example illustrates when the program memory may be separate from the data memory, generally as used herein, the term program code refers to all data that makes up the code to be loaded onto the remote computer, including both items to be placed in program memory and items to be placed in data memory. The foregoing example was only meant to illustrate an embodiment where there are separate program and data areas on the remote computer, and it was not meant to limit the broad application of the present embodiments. </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> illustrates the major computer program and data components of the presently preferred embodiments. In current design, the relocatable program module <highlight><bold>31</bold></highlight>, comprising the relocation table <highlight><bold>30</bold></highlight> and the relocatable program code <highlight><bold>32</bold></highlight>, are stored on the host computer <highlight><bold>12</bold></highlight>. In addition, information <highlight><bold>34</bold></highlight> about the memory of the remote computer <highlight><bold>16</bold></highlight> is stored on the host computer <highlight><bold>12</bold></highlight>. The memory information <highlight><bold>34</bold></highlight> may be simply an address, it may include multiple starting addresses and sizes available, it may be a memory map <highlight><bold>34</bold></highlight> of the remote computer <highlight><bold>16</bold></highlight>, or it may include other information that somehow describes the memory layout of the remote computer <highlight><bold>16</bold></highlight>. In the preferred embodiments, the memory information <highlight><bold>34</bold></highlight> indicates what memory is being used and what memory is available for use at the remote computer <highlight><bold>16</bold></highlight>. In addition, in current design the memory information <highlight><bold>34</bold></highlight> indicates what specifically is being stored at each memory location in the remote computer <highlight><bold>16</bold></highlight>. This enables software developers to more precisely target particular memory locations to be updated or changed without necessary rewriting all the data to the entire memory <highlight><bold>36</bold></highlight> of the remote computer <highlight><bold>16</bold></highlight>. </paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> The remote computer <highlight><bold>16</bold></highlight> communicates with the host computer <highlight><bold>12</bold></highlight> through an embedded communications port <highlight><bold>36</bold></highlight>. In current design, a communications module <highlight><bold>40</bold></highlight> provides communication using the communications port <highlight><bold>38</bold></highlight>. The communications module <highlight><bold>40</bold></highlight> relays data to and from a write module <highlight><bold>42</bold></highlight>. The write module <highlight><bold>42</bold></highlight> may also include additional functionality. For example, the write module <highlight><bold>42</bold></highlight> may also be able to read data. The write module <highlight><bold>42</bold></highlight> may read data from and may write data to the memory <highlight><bold>36</bold></highlight> of the remote computer <highlight><bold>16</bold></highlight>. One skilled in the art will appreciate that the write module <highlight><bold>42</bold></highlight> may include the code necessary to directly interface with the communications port <highlight><bold>38</bold></highlight> at the remote computer <highlight><bold>16</bold></highlight>. Thus, the write module <highlight><bold>42</bold></highlight> may receive data directly from the communications port <highlight><bold>38</bold></highlight>. </paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> The optional communications module <highlight><bold>40</bold></highlight> or code <highlight><bold>40</bold></highlight> provides access to the communications port <highlight><bold>38</bold></highlight>, and ensures that data relayed to and from the communications port <highlight><bold>38</bold></highlight> is in appropriately sized and formatted pieces, and that data received from the communications port <highlight><bold>38</bold></highlight> is correctly read from the port <highlight><bold>38</bold></highlight>. </paragraph>
<paragraph id="P-0068" lvl="0"><number>&lsqb;0068&rsqb;</number> The host computer <highlight><bold>12</bold></highlight> includes a communication port <highlight><bold>44</bold></highlight> in electronic communication with the communications port <highlight><bold>38</bold></highlight> of the remote computer <highlight><bold>16</bold></highlight>. As discussed earlier, there are a variety of such ports available with computers that are capable of interfacing with a remote and/or embedded computer port <highlight><bold>38</bold></highlight>. An optional communication module <highlight><bold>46</bold></highlight> provides features similar to those provided by the communications module <highlight><bold>40</bold></highlight> of the remote computer <highlight><bold>16</bold></highlight>. The communications module <highlight><bold>46</bold></highlight> correctly formats data that is written to and read from the communications port <highlight><bold>44</bold></highlight>. </paragraph>
<paragraph id="P-0069" lvl="0"><number>&lsqb;0069&rsqb;</number> In the presently preferred embodiments, a relocating module <highlight><bold>48</bold></highlight> that manages the relocating of the program code and the loading of program code onto the remote computer <highlight><bold>16</bold></highlight> links and resolves any unresolved addresses in the relocatable program code <highlight><bold>32</bold></highlight> and loads it onto the remote computer <highlight><bold>16</bold></highlight>. Before the relocating module <highlight><bold>48</bold></highlight> accomplishes this task, the relocating module <highlight><bold>48</bold></highlight> obtains the needed memory insertion address(es). The relocating module <highlight><bold>48</bold></highlight> may obtain the necessary memory insertion address(es) from either examining the memory information <highlight><bold>34</bold></highlight> or from querying the remote computer <highlight><bold>16</bold></highlight>. Of course, if the relocating module <highlight><bold>48</bold></highlight> is to obtain the necessary address(es) from the remote computer <highlight><bold>16</bold></highlight>, the remote computer <highlight><bold>16</bold></highlight> would need to have the capability to respond to such a query. </paragraph>
<paragraph id="P-0070" lvl="0"><number>&lsqb;0070&rsqb;</number> If the relocating module <highlight><bold>48</bold></highlight> is to obtain the necessary address(es) from the remote computer <highlight><bold>16</bold></highlight>, the remote computer <highlight><bold>16</bold></highlight> would need to have the necessary software module to enable it to respond to such a query. A memory usage data structure (not shown) could be placed on the remote computer <highlight><bold>16</bold></highlight> to track where in memory <highlight><bold>36</bold></highlight> new program code can be placed. It will be appreciated by those skilled in the art that the more program code that is placed on the remoter computer <highlight><bold>16</bold></highlight>, the less space is left for revisions, updates and extensions. Thus, for resource constrained systems, any memory usage data structure (not shown) at the remoter computer <highlight><bold>16</bold></highlight> should be kept as small as possible. Of course, to the extent memory is not as critical an issue in the system, the memory usage data structure size may vary accordingly. </paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> Once the relocating module <highlight><bold>48</bold></highlight> obtains the needed memory address(es), it examines the relocation table <highlight><bold>30</bold></highlight> to find the instructions in the relocatable program code <highlight><bold>32</bold></highlight> that need to be updated. Then, by using the information in the relocation table <highlight><bold>30</bold></highlight>, the relocating module <highlight><bold>48</bold></highlight> resolves the unresolved addresses in the relocatable program code <highlight><bold>32</bold></highlight> and then loads the updated program code <highlight><bold>32</bold></highlight> onto the remote computer <highlight><bold>16</bold></highlight>. The relocating module <highlight><bold>48</bold></highlight> may load the updated code onto the remote computer <highlight><bold>16</bold></highlight> via the communication modules <highlight><bold>40</bold></highlight>, <highlight><bold>46</bold></highlight> and the interfacing ports <highlight><bold>38</bold></highlight>, <highlight><bold>44</bold></highlight>. In current design, through the aforementioned communication pathway the relocating module <highlight><bold>48</bold></highlight> directs the write module <highlight><bold>42</bold></highlight> to write the updated program code to the memory <highlight><bold>36</bold></highlight> of the remote computer <highlight><bold>16</bold></highlight>. </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a flow diagram illustrating the initial steps that take place in the presently preferred embodiments before the updated program code is loaded onto the remote computer <highlight><bold>16</bold></highlight>. First, a user of the presently preferred embodiment compiles and links <highlight><bold>50</bold></highlight> the program into the relocatable program code <highlight><bold>32</bold></highlight>. The user also creates <highlight><bold>52</bold></highlight> a relocation table <highlight><bold>30</bold></highlight> identifying the locations in the relocatable program code <highlight><bold>32</bold></highlight> that need to be adjusted. These steps can be accomplished through commercially available compilers, linkers and/or tools, as mentioned above. </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a flow diagram illustrating the steps that take place in the presently preferred embodiment to load the updated program code onto the remote computer <highlight><bold>16</bold></highlight>. Once the relocatable program code <highlight><bold>32</bold></highlight> and relocatable table <highlight><bold>30</bold></highlight> have been created, in current design the steps of <cross-reference target="DRAWINGS">FIG. 5</cross-reference> are performed. The preferred embodiments identify <highlight><bold>54</bold></highlight> the one or more memory locations or areas of the remote computer <highlight><bold>16</bold></highlight> where the updated program code may be placed. From these memory locations, the preferred embodiments obtain <highlight><bold>56</bold></highlight> the starting address(es), which is/are the memory address(es) of the remote computer <highlight><bold>16</bold></highlight> where the program code will begin. The relocating module <highlight><bold>48</bold></highlight> then, with this known information, uses <highlight><bold>58</bold></highlight> the relocation table <highlight><bold>30</bold></highlight> to identify the instructions and/or memory references of the relocatable program code <highlight><bold>32</bold></highlight> that need to be adjusted. Then the relocating module <highlight><bold>48</bold></highlight> modifies <highlight><bold>60</bold></highlight> the program code <highlight><bold>32</bold></highlight> for placement in the remote computer <highlight><bold>16</bold></highlight>. After the code has been modified <highlight><bold>60</bold></highlight> for placement, the modified program code is sent <highlight><bold>62</bold></highlight> to the remote computer <highlight><bold>16</bold></highlight> via the communication pathway as previously described. It will be appreciated by those skilled in the art that the relocating module <highlight><bold>48</bold></highlight> may store the modified program code to a storage device before the modified program code is sent <highlight><bold>62</bold></highlight> to the remote computer. </paragraph>
<paragraph id="P-0074" lvl="0"><number>&lsqb;0074&rsqb;</number> In the presently preferred embodiments commercially available software from emWare, Inc. is used in implementing the embodiments. emWare, Inc. may be contacted through its web site at http://www.emware.com. One skilled in the art will appreciate how the commercially availably software items from emWare can be used with the present embodiments. The following is a general and basic description of technology of emWare that is used in the presently preferred embodiments. </paragraph>
<paragraph id="P-0075" lvl="0"><number>&lsqb;0075&rsqb;</number> emWare&apos;s business centers around microcontrollers that manage many electronic devices used in today&apos;s world, including telephones, home appliances, office equipment. ATMs, security systems, VCRs, automobiles, etc. These microcontrollers are embedded into millions of intelligent electronic devices. </paragraph>
<paragraph id="P-0076" lvl="0"><number>&lsqb;0076&rsqb;</number> emWare has developed technology and software which provide distributed network-based device control. emWare&apos;s Embedded Micro Internetworking Technology (EMIT&reg;) software is designed to move the majority of software off of the embedded microcontroller and distribute it to more capable computers over a network. EMIT&reg; software has also been developed to leverage existing Internet technologies. </paragraph>
<paragraph id="P-0077" lvl="0"><number>&lsqb;0077&rsqb;</number> Use of EMIT&reg; software involves various components including the following: a customer&apos;s embedded application (which is the program already on the remote computer <highlight><bold>16</bold></highlight> or the program to be placed on the remote computer <highlight><bold>16</bold></highlight>), emMicro software (which correlates to the communication module <highlight><bold>40</bold></highlight> and read/write module <highlight><bold>42</bold></highlight>), emGateway software, emNet software (which correlates to the communication modules <highlight><bold>40</bold></highlight> and <highlight><bold>46</bold></highlight>), and the customer&apos;s monitoring/controlling application (which is loaded onto the client computers <highlight><bold>22</bold></highlight> for monitoring and controlling the embedded device <highlight><bold>14</bold></highlight>). Typically, potential customers of emWare already have embedded environments in which they plan to deploy emWare&apos;s EMIT&reg; software to enhance their monitoring and controlling capabilities. These embedded environments typically include the embedded system <highlight><bold>14</bold></highlight>, the host computer <highlight><bold>12</bold></highlight>, and client computers <highlight><bold>22</bold></highlight>. </paragraph>
<paragraph id="P-0078" lvl="0"><number>&lsqb;0078&rsqb;</number> emMicro is used in the presently preferred embodiments on the remote computer <highlight><bold>16</bold></highlight> for relaying information from the remote computer <highlight><bold>16</bold></highlight> to the host computer <highlight><bold>12</bold></highlight>. Service information is information about the functions, variables, events and files of the embedded application running on the remote computer <highlight><bold>16</bold></highlight>. </paragraph>
<paragraph id="P-0079" lvl="0"><number>&lsqb;0079&rsqb;</number> The communications between the host computer <highlight><bold>12</bold></highlight> and the remote computer <highlight><bold>16</bold></highlight> running emMicro are usually accomplished via a lightweight network such as RS-232, RS-485, RF, or IR. The emNet component is responsible for handling communications between emMicro and the software on the host computer <highlight><bold>12</bold></highlight>. </paragraph>
<paragraph id="P-0080" lvl="0"><number>&lsqb;0080&rsqb;</number> From the above discussion, it will be appreciated that the present embodiments disclosed provide systems and methods for preparing program code for a first computer where the system and/or methods are implemented on a second computer. </paragraph>
<paragraph id="P-0081" lvl="0"><number>&lsqb;0081&rsqb;</number> The present embodiments may be embodied in other specific forms without departing from their spirit or essential characteristics. The described embodiments are to be considered in all respects only as illustrative, and not restrictive. The scope of the invention is, therefore, indicated by the appended claims, rather than by the foregoing description. All changes which come within the meaning and range of equivalency of the claims are to be embraced within their scope. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A system for preparing program code for a first computer wherein the system is implemented on a second computer, the system comprising: 
<claim-text>program code for the first computer, the program code being stored on the second computer; </claim-text>
<claim-text>a memory address identifying a memory location in the first computer, the memory address being suitable as a basis for modifying the program code; </claim-text>
<claim-text>location data, the location data identifying locations in the program code to be adjusted based on the memory address; </claim-text>
<claim-text>a relocating module on the second computer, the relocating module adapted to relocate the program code by modifying the locations in the program code identified by the location data, the modifications being based on the memory address. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, the system further comprising information regarding memory usage of the first computer from which the memory address is derived. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, further comprising a list that includes the location data. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein the memory address is obtained from the first computer. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> further comprising a communication module at the second computer for obtaining the memory address and for communicating the modified program code to the first computer. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. A system for preparing program code for a first computer wherein the system is implemented on a second computer, the system comprising: 
<claim-text>a first computer, the first computer having a first computer processor, and the first computer also having a first computer memory; </claim-text>
<claim-text>a second computer, the second computer having a second computer processor, the second computer also having a second computer memory, the second computer being in electronic communication with the first computer; </claim-text>
<claim-text>program code for the first computer, the program code being stored on the second computer; </claim-text>
<claim-text>a memory address identifying a memory location in the first computer memory, the memory address being suitable as a basis for modifying memory references within the program code; </claim-text>
<claim-text>a list of the memory references in the program code to be adjusted based on the memory address; </claim-text>
<claim-text>a relocating module on the second computer, the relocating module adapted to relocate the program code by modifying the memory references in the program code identified by the list, the modifications being based on the memory address, the relocating module thereby creating modified program code. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference>, the system further comprising information regarding memory usage of the first computer from which the memory address is derived. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00006">claim 6</dependent-claim-reference> wherein the memory address is obtained from the first computer. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The system of <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference> further comprising a communication module at the second computer for obtaining the memory address and for communicating the modified program code to the first computer. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. A computer-readable medium containing instructions for preparing program code for a first computer wherein the instructions will be implemented on a second computer, wherein the instructions comprise executable instructions for implementing a method comprised of the steps of: 
<claim-text>obtaining the program code from a storage device in electronic communication with the second computer; </claim-text>
<claim-text>obtaining a memory address identifying a memory location in the first computer, the memory address being suitable as a basis for modifying the program code; </claim-text>
<claim-text>obtaining location data, the location data identifying locations in the program code to be adjusted based on the memory address; and </claim-text>
<claim-text>modifying the locations in the program code identified by the location data, by using the memory address and by using the location data, the modifying step to be accomplished at the second computer. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein the method further comprises the step of obtaining information regarding memory usage of the first computer from which the memory address can be derived. </claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein the method further comprises the step of obtaining a list that includes the location data. </claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein the memory address is obtained from the first computer. </claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein the method further comprises the step of communicating the modified program code to the first computer. </claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein the memory address obtained is suitable as a basis for modifying memory references within the program code. </claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference>, wherein the modifying step of the method further comprises the step of modifying the memory references in the program code, by using the memory address and by using the location data. </claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. The computer-readable medium of <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, wherein the medium is a data transmission medium. </claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. In a computer system including a first computer and a second computer, the first computer being in electronic communication with the second computer, a method for preparing program code for the first computer wherein the method will be implemented on the second computer, the method comprising the steps of: 
<claim-text>obtaining the program code from a storage device in electronic communication with the second computer; </claim-text>
<claim-text>obtaining a memory address identifying a memory location in the first computer, the memory address being suitable as a basis for modifying the program code; </claim-text>
<claim-text>obtaining location data, the location data identifying locations in the program code to be adjusted based on the memory address; and </claim-text>
<claim-text>modifying the locations in the program code identified by the location data, by using the memory address and by using the location data, the modifying step to be accomplished at the second computer. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 18</dependent-claim-reference> further comprising the step of obtaining information regarding memory usage of the first computer from which the memory address can be derived. </claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 18</dependent-claim-reference> further comprising the step of obtaining a list that includes the location data. </claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 18</dependent-claim-reference> wherein the memory address is obtained from the first computer. </claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 18</dependent-claim-reference> further comprising the step of communicating the modified program code to the first computer. </claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00011">claim 18</dependent-claim-reference> wherein the memory address obtained is suitable as a basis for modifying memory references within the program code. </claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00022">claim 23</dependent-claim-reference> wherein the modifying step further comprises the step of modifying the memory references in the program code, by using the memory address and by using the location data.</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>5</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030005158A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030005158A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030005158A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030005158A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030005158A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
