<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030002586A1-20030102-D00000.TIF SYSTEM "US20030002586A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030002586A1-20030102-D00001.TIF SYSTEM "US20030002586A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030002586A1-20030102-D00002.TIF SYSTEM "US20030002586A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030002586A1-20030102-D00003.TIF SYSTEM "US20030002586A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030002586A1-20030102-D00004.TIF SYSTEM "US20030002586A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030002586A1-20030102-D00005.TIF SYSTEM "US20030002586A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030002586A1-20030102-D00006.TIF SYSTEM "US20030002586A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030002586A1-20030102-D00007.TIF SYSTEM "US20030002586A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030002586A1-20030102-D00008.TIF SYSTEM "US20030002586A1-20030102-D00008.TIF" NDATA TIF>
<!ENTITY US20030002586A1-20030102-D00009.TIF SYSTEM "US20030002586A1-20030102-D00009.TIF" NDATA TIF>
<!ENTITY US20030002586A1-20030102-D00010.TIF SYSTEM "US20030002586A1-20030102-D00010.TIF" NDATA TIF>
<!ENTITY US20030002586A1-20030102-D00011.TIF SYSTEM "US20030002586A1-20030102-D00011.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030002586</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10223149</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20020819</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>H04N007/12</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>375</class>
<subclass>240260</subclass>
</uspc>
</classification-us-primary>
<classification-us-secondary>
<uspc>
<class>725</class>
<subclass>093000</subclass>
</uspc>
</classification-us-secondary>
</classification-us>
<title-of-invention>Data structure, method and apparatus providing efficient retrieval of data from a segmented information stream</title-of-invention>
</technical-information>
<continuity-data>
<continuations>
<continuation-of>
<parent-child>
<child>
<document-id>
<doc-number>10223149</doc-number>
<kind-code>A1</kind-code>
<document-date>20020819</document-date>
</document-id>
</child>
<parent>
<document-id>
<doc-number>09196297</doc-number>
<document-date>19981119</document-date>
<country-code>US</country-code>
</document-id>
</parent>
<parent-status>GRANTED</parent-status>
<parent-patent>
<document-id>
<doc-number>6438140</doc-number>
<country-code>US</country-code>
</document-id>
</parent-patent>
</parent-child>
</continuation-of>
</continuations>
</continuity-data>
<inventors>
<first-named-inventor>
<name>
<given-name>Patricia</given-name>
<middle-name>D.</middle-name>
<family-name>Jungers</family-name>
</name>
<residence>
<residence-us>
<city>San Mateo</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
<inventor>
<name>
<given-name>Dru</given-name>
<family-name>Nelson</family-name>
</name>
<residence>
<residence-us>
<city>Redwood City</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</inventor>
</inventors>
<correspondence-address>
<name-1>MOSER, PATTERSON &amp; SHERIDAN L.L.P.</name-1>
<name-2></name-2>
<address>
<address-1>595 SHREWSBURY AVE</address-1>
<address-2>FIRST FLOOR</address-2>
<city>SHREWSBURY</city>
<state>NJ</state>
<postalcode>07702</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A data structure, method and apparatus providing efficient retrieval of data from a segmented information stream. The invention utilizes a segmented data stream having an initial directory payload portion and a following payload portion including one or more object tables. The directory includes table descriptors associated with each object table including various field indicative of parameters of the respective object table. One of the fields comprises a bit array having at least one bit corresponding to each of the segments in the respective object table. By changing a state of a corresponding bit upon receiving a table segment, the memory and processing resources required to read the segments associated with a table are decreased. </paragraph>
</subdoc-abstract>
<subdoc-description>
<cross-reference-to-related-applications>
<heading lvl="1">CROSS-REFERENCE TO RELATED APPLICATION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> This application is a continuation of commonly assigned U.S. patent application Ser. No. 09/196,297, filed on Nov. 19, 1998.</paragraph>
</cross-reference-to-related-applications>
<summary-of-invention>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> The invention relates to communications systems generally and, more particularly, the invention relates to an efficient scheme for acquiring desired data, such as table or sequence data, from a packetized data stream. </paragraph>
<section>
<heading lvl="1">BACKGROUND OF THE DISCLOSURE </heading>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> In several communications systems the data to be transmitted is compressed so that the available bandwidth is used more efficiently. For example, the Moving Pictures Experts Group (MPEG) has promulgated several standards relating to digital data delivery systems. The first, known as MPEG-1 refers to ISO/IEC standards 11172 and is incorporated herein by reference. The second, known as MPEG-2, refers to ISO/IEC standards 13818 and is incorporated herein by reference. A compressed digital video system is described in the Advanced Television Systems Committee (ATSC) digital television standard document A/53, and is incorporated herein by reference. </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> Information distribution systems utilizing information streams conforming to the above standards or subsets of the above standards are known. For example, an interactive digital video on demand (VOD) service known as the OnSet&trade; system is manufactured by DIVA Systems Corporation of Menlo Park, Calif. The OnSet&trade; system distributes audio-visual information to individual subscribers utilizing MPEG-like information streams. The OnSet&trade; system also allows subscribers to interactively control the delivery of audio-visual information using consumer-friendly commands, such as fast-forward (FF), rewind (REW), pause (PAUSE), play (PLAY) and the like. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> The above-referenced standards, and other similar standards, provide for the delivery of proprietary data in addition to audio, video and other data to receiving and decoding devices, such as set top terminal (STTs). The proprietary data may be formatted into, e.g., an MPEG-2 standard private section format or the similar DigiCipher&reg;II (DCII) format, which is used in STTs manufactured by General Instrument Corporation of Horsham, Pa. Using DCII terminology, proprietary data may be organized as one or more tables (i.e., logical groupings of data), where each table comprises one or more messages or segments. The messages or segments are then transport encoded in a known manner to produce a transport stream that is coupled to one or more STTs. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> A STT decodes the transport stream in a known manner to extract the messages or segments. During the decoding process an error check, such as a circular redundancy check (CRC), is performed for each message or segment. If the message or segment is error-free, then it is passed to a controller for further processing (e.g., table re-assembly) by an application running within the STT. If the message or segment is not error-free, then an error handler is invoked. The typical error handler discards a message or segment having errors without notifying the application expecting to receive the message or segment. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> Therefore, it is seen to be desirable to provide a method and apparatus that is able to compensate for the tendency of some STTs to discard or miss data segments without application notification. Specifically, it is seen to be desirable to provide a method and apparatus for tracking the delivery and re-assembly of received messages or segments into complete tables or sections, such that applications may readily ascertain whether necessary data structures have been received by, e.g., a STT or other information receiver. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> The invention comprises a data structure, method and apparatus providing efficient retrieval of data from a segmented information stream. The invention utilizes a segmented data stream having an initial directory payload portion and a following payload portion including one or more object tables. The directory includes table descriptors associated with each object table including various fields indicative of parameters of the respective object table. One of the fields comprises a bit array having at least one bit corresponding to each of the segments in the respective object table. By changing a state of a corresponding bit upon receiving a table segment, the memory and processing resources required to read the segments associated with a table are decreased. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> Specifically, a data structure according to the invention for providing at least one table within a segmented information stream comprising: a header portion, including a stream type identifier; and a payload portion, including a directory and the at least one table; the directory occupying at least a first segment within the payload portion of the information stream and including, for each of the at least one tables, a respective table description record, the table description record including indicia of table type and number of table segments, the table description record also including a segment bit array field, the segment bit array field including at least one bit corresponding to each of the number of table segments; the at least one table occupying one or more contiguous segments within the payload portion of the information stream.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> The teachings of the present invention can be readily understood by considering the following detailed description in conjunction with the accompanying drawings, in which: </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> depicts a graphical representation of a data structure according to the invention; </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> depicts a high level block diagram of an information receiver; </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> depicts a high level block diagram of a processing system suitable for generating a data stream according to the invention; </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> depicts a segment processing method according to the invention; </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> depicts a stream request processing method suitable for use in the segment processing method of <cross-reference target="DRAWINGS">FIG. 4</cross-reference>; </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6A</cross-reference> depicts a high level block diagram of a method for forming an object-representative table and suitable for use in the processing system of <cross-reference target="DRAWINGS">FIG. 3</cross-reference>; </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6B</cross-reference> depicts a flow diagram of the method of <cross-reference target="DRAWINGS">FIG. 6A</cross-reference>; </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7A</cross-reference> depicts a high level block diagram of a method for forming an a data stream according to the invention and suitable for use in the processing system of <cross-reference target="DRAWINGS">FIG. 3</cross-reference>; and </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7B</cross-reference> depicts a flow diagram of the method of <cross-reference target="DRAWINGS">FIG. 7A</cross-reference>. </paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> To facilitate understanding, identical reference numerals have been used, where possible, to designate identical elements that are common to the figures. </paragraph>
<section>
<heading lvl="1">DETAILED DESCRIPTION </heading>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> The invention will be primarily described using the terminology and language found in the DCII specification, and within the context of a set top terminal (STT). It will be appreciated by those skilled in the art that corresponding terminology and language exists in the MPEG-2 standard and in other standards. For example, the DCII concept of a message or segment is similar to the MPEG-2 concept of a sequence. Additionally, while the following description will focus on an embodiment of the invention utilizing a transport stream adapted to a particular data structure, it is important to note that the data structure provided by the invention may be practiced within the context of any packetized information stream utilizing a layered approach to information delivery. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> depicts a graphical representation of a data structure according to the invention. Specifically, <cross-reference target="DRAWINGS">FIG. 1</cross-reference> depicts a data stream format <highlight><bold>100</bold></highlight>. The data stream comprises a stream header <highlight><bold>110</bold></highlight>, a directory structure <highlight><bold>120</bold></highlight> and one or more tables <highlight><bold>140</bold></highlight>. It is important to note that the stream header <highlight><bold>110</bold></highlight> and the directory structure <highlight><bold>120</bold></highlight> are shown within the same segment (i.e., a first segment) of the data stream <highlight><bold>100</bold></highlight>. However, if data stream <highlight><bold>100</bold></highlight> includes a large number of tables, then the directory may get too large to be contained within a single segment (e.g., 1024 bytes). In this case the directory will extend to one or more additional segments. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> Stream header <highlight><bold>110</bold></highlight> comprises a stream type identifier field <highlight><bold>111</bold></highlight>, a major version field <highlight><bold>112</bold></highlight>, a minor version field <highlight><bold>113</bold></highlight>, a content ID field <highlight><bold>114</bold></highlight> and a creation date field <highlight><bold>115</bold></highlight>. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> The stream type identifier field <highlight><bold>111</bold></highlight> is used to indicate the type of stream, illustratively, a bit map object having one of several possible resolutions (i.e., appropriate for one or more set top terminals). The stream type identifier field <highlight><bold>111</bold></highlight> is used by a receiving platform, such as a set top terminal, to reject unrecognized stream types. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> The major version number <highlight><bold>112</bold></highlight> is used by the platform to reject streams with greater version numbers than the existing platform code. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> The minor version number <highlight><bold>113</bold></highlight> is used to track minor differences in software versions. A platform may except streams with different minor version numbers than the platform code. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> The content ID <highlight><bold>114</bold></highlight> is used by the platform to detect a stream change. Such a stream change may be due to, e.g., an updating of old data (i.e., an updated stock ticker) or an entirely new set of data. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> The creation date <highlight><bold>115</bold></highlight> is used by, e.g., asset tracking systems optionally included within a platform to reference the creation date of the tables included within the data stream. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> The directory structure <highlight><bold>120</bold></highlight> comprises a number of tables field <highlight><bold>121</bold></highlight>, indicative of a number of table records within the directory structure, and a plurality of table records <highlight><bold>130</bold></highlight> and <highlight><bold>123</bold></highlight>-<highlight><bold>12</bold></highlight>N, where N is the number of tables indicated in the number of tables field <highlight><bold>121</bold></highlight>. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> A table record, e.g., table record <highlight><bold>130</bold></highlight>, comprises a table type field <highlight><bold>131</bold></highlight>, a table identification number (ID) field <highlight><bold>132</bold></highlight>, a number of messages field <highlight><bold>133</bold></highlight>, a message length field <highlight><bold>134</bold></highlight>, a number of bytes in table record field <highlight><bold>135</bold></highlight>, a bit array of received segments field <highlight><bold>136</bold></highlight> and a pointer to an application object <highlight><bold>137</bold></highlight>. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> The table type field <highlight><bold>131</bold></highlight> indicates the type of data contained in the table. This information may be used by a platform such as a receiver or set top terminal to select or deselect tables from the stream. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> The table ID field <highlight><bold>132</bold></highlight> corresponds to both the record index into the directory and to a field in the message header. This corresponds to the table number contained in the DCII message header. The platform uses this number to link a received message to a table. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> The number of segments field <highlight><bold>133</bold></highlight> is used to initialize the number of remaining segments variable used by a platform receiving for the data stream. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> The message length field <highlight><bold>134</bold></highlight> is used to place a message payload into an allocated portion of memory within the platform. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> The number of bytes in a table record field <highlight><bold>135</bold></highlight> is used by the platform to allocate application heap memory which will be used to store the DCII message or segment payload (or the MPEG-2 equivalent). </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> The bit array of received segments field <highlight><bold>136</bold></highlight> facilitates message bookkeeping for the table represented by the table record. The received message header contains fields for the number of messages and current message received. Each message in the table is represented by a set bit in the bit array. When a message for the table is received the bit is reset. When an entire table is complete the bit arrays value is zero. The use of the bit array field is discussed with greater detail below with respect to <cross-reference target="DRAWINGS">FIG. 4</cross-reference>. </paragraph>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> The pointer to allocated memory field <highlight><bold>137</bold></highlight> is used by the set top terminals to store the memory location allocated in the application heap. That is, in response to the number of bytes in a table description record field <highlight><bold>135</bold></highlight>, the platform will allocate heap memory to store an object. The pointer is simply a indicia of the location within heap memory of the stored table. </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> A table contains a logical grouping of data. For example, a table may be used to store feature or format information that is used by a STT to execute a particular application. The table type stored in the directory record of each table is used by the individual set top to determine which tables it will received. When requesting a stream, the application for a given set top model indicates which table types it supports. When processing the directory message, the system compares the table type for each record against the supported table types. If a table is not supported, the bit array in its directory record is cleared to zero indicating that no segments are to be acquired for that table. This prevents segments from unsupported tables from being stored in set top memory. </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> depicts a high level block diagram of an information receiver. Specifically, <cross-reference target="DRAWINGS">FIG. 2</cross-reference> depicts a set top terminal (STT) comprising a tuner <highlight><bold>210</bold></highlight>, a demodulator <highlight><bold>220</bold></highlight>, a transport demultiplexer <highlight><bold>230</bold></highlight>, an audio decoder <highlight><bold>240</bold></highlight>, a video decoder <highlight><bold>250</bold></highlight> and a controller <highlight><bold>270</bold></highlight>. The STT includes various functionality useful in practicing the invention, as will be described below. Tuner <highlight><bold>210</bold></highlight> receiver, e.g., a radio frequency (RF) signal comprising a plurality of quadrature amplitude modulated (QAM) information signals from a channel such as a hybrid fiber optic cable television system. Tuner <highlight><bold>210</bold></highlight>, in response to a control signal TUNE, tunes a particular one of the QAM information signals to produce an intermediate frequency (IF) information signal. Demodulator <highlight><bold>220</bold></highlight> receives and demodulates the intermediate frequency QAM information signal to produce an information stream, illustratively an MPEG transport stream. The MPEG transport stream is coupled to a transport stream demultiplexer <highlight><bold>230</bold></highlight>. </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> Transport stream demultiplexer <highlight><bold>230</bold></highlight>, in response to a control signal TD produced by controller <highlight><bold>270</bold></highlight>, demultiplexes (i.e., extracts) at least one of a compressed audio information stream AE, a compressed video information stream VE and a data stream DATA. </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> The compressed audio information stream AE is coupled to audio decoder <highlight><bold>240</bold></highlight>, which decodes the compressed audio information stream AE to produce an uncompressed audio information stream AD that is coupled to an audio processor (not shown) for subsequent presentation. </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> The compressed video stream VE is coupled to the video decoder <highlight><bold>250</bold></highlight>, which decodes the compressed video stream VE to produce an uncompressed video stream VD that is coupled to a video processor (not shown) for subsequent processing and presentation on a display device. </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> The data stream DATA, illustratively an ancillary data stream or private data stream according to, e.g., the MPEG or DCII standards, is coupled to the controller <highlight><bold>270</bold></highlight> for further processing. It is important to note that, at least for the data stream DATA, transport stream demultiplexer <highlight><bold>230</bold></highlight> operates to discard those messages or segments that are found to contain errors (e.g., those messages or error that do not pass a CRC checksum test). Thus, the data stream DATA comprises only those messages or segments that were not discarded by the transport demultiplexer <highlight><bold>230</bold></highlight>. </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> Controller <highlight><bold>270</bold></highlight> comprises a microprocessor <highlight><bold>272</bold></highlight>, an input output module <highlight><bold>274</bold></highlight>, a memory module <highlight><bold>276</bold></highlight>and support circuitry <highlight><bold>278</bold></highlight>. The microprocessor <highlight><bold>272</bold></highlight> cooperates with conventional support circuitry <highlight><bold>278</bold></highlight> such as power supplies, clock circuits, cache memory and the like as well as circuits that assist in executing the software routines. The controller <highlight><bold>270</bold></highlight> also contains input/output circuitry <highlight><bold>274</bold></highlight> that forms an interface between the controller <highlight><bold>270</bold></highlight> and the tuner <highlight><bold>210</bold></highlight> and the transport demultiplexer <highlight><bold>230</bold></highlight>. Although the controller <highlight><bold>270</bold></highlight> is depicted as a general purpose computer that is programmed to perform specific functions in accordance with the present invention, the invention can be implemented in hardware as an application specific integrated circuit (ASIC). As such, the process steps described herein are intended to be broadly interpreted as being equivalently performed by software, hardware, or a combination thereof. </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> Other set top terminals suitable for use with the present invention are the General Instrument Corporation Models DCT-1000 and DCT-1200 Digital Interactive Consumer Terminals. </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> depicts a segment processing method <highlight><bold>400</bold></highlight> according to the invention. Specifically, <cross-reference target="DRAWINGS">FIG. 4</cross-reference> depicts a method for processing a message or segment received from, e.g., transport demultiplexer <highlight><bold>230</bold></highlight> via the DATA stream path. It must be noted that <cross-reference target="DRAWINGS">FIG. 4</cross-reference> comprises <cross-reference target="DRAWINGS">FIG. 4</cross-reference>A and <cross-reference target="DRAWINGS">FIG. 4</cross-reference>B, which are intended to be viewed together, per the diagram included within <cross-reference target="DRAWINGS">FIG. 4A</cross-reference>. </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> The segment processing method <highlight><bold>400</bold></highlight> is entered at step <highlight><bold>402</bold></highlight> and proceeds to step <highlight><bold>500</bold></highlight>. At step <highlight><bold>500</bold></highlight> the method processes a stream request received from an application program and allocates a buffer for storing a received stream segment or message. After receiving a segment and storing the received segment in the allocated buffer, the method <highlight><bold>400</bold></highlight> proceeds to step <highlight><bold>404</bold></highlight>. </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> At step <highlight><bold>404</bold></highlight> the received message stored in the allocated buffer is examined. The method <highlight><bold>400</bold></highlight> then proceeds to step <highlight><bold>406</bold></highlight>, where a query is made as to whether the received segment contains a directory. If the query at step <highlight><bold>406</bold></highlight> is answered negatively, then the method <highlight><bold>400</bold></highlight> proceeds to step <highlight><bold>440</bold></highlight>. If the query at step <highlight><bold>406</bold></highlight> is answered affirmatively, then the method <highlight><bold>400</bold></highlight> proceeds to step <highlight><bold>408</bold></highlight>. </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> At step <highlight><bold>408</bold></highlight> several validity checks are performed on the received segment. Specifically, the repeated content ID is checked to determine if the received directory is merely a second or even third copy of a previously processed directory. Additionally, the stream type field is checked to determine if the received stream is of the type that can be processed by the receiver (e.g., a set top terminal, receiver platform and the like). Finally, the major version field <highlight><bold>112</bold></highlight> is checked to determine whether the stream version is compatible with the version of software or firmware running on the platform. The method <highlight><bold>400</bold></highlight> then proceeds to step <highlight><bold>410</bold></highlight>, where a query is made as to whether the received stream is valid for this platform. If the query at step <highlight><bold>410</bold></highlight> is answered negatively, then the method <highlight><bold>400</bold></highlight> proceeds to step <highlight><bold>414</bold></highlight>. If the query at step <highlight><bold>410</bold></highlight> is answered affirmatively, then the method <highlight><bold>400</bold></highlight> proceeds to step <highlight><bold>412</bold></highlight>. </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> At step <highlight><bold>412</bold></highlight> a query is made as to whether the received directory comprises a null directory. That is, a quire is made as to whether the received directory is one of several directories defined as null directories that are used by the set top terminal to indicate a stream change. For example, in one embodiment of the invention the data stream format is adapted such that the header portion of the format includes three null directory streams, where each null directory stream includes a content ID of zero. If the query at step <highlight><bold>412</bold></highlight> is answered affirmatively, then the method <highlight><bold>400</bold></highlight> proceeds to step <highlight><bold>414</bold></highlight>. If the query at step <highlight><bold>412</bold></highlight> is answered negatively, then the method <highlight><bold>400</bold></highlight> proceeds to step <highlight><bold>417</bold></highlight>, where a variable REMAIN_SEGS is initialized to zero. REMAIN_SEGS is used to store the total number of segments to be processed, e.g., the total number of segments contained in each of the tables. The REMAIN_SEGS variable does not include the segment(s) used for the directory itself. The method <highlight><bold>400</bold></highlight> then proceeds to step <highlight><bold>418</bold></highlight>. </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> At step <highlight><bold>414</bold></highlight> the buffer containing the received segment is resubmitted to the transport receiver for processing. That is, the memory allocated to the segment input buffer function is allowed to be overwritten by the next received segment. The method <highlight><bold>400</bold></highlight> then proceeds to step <highlight><bold>416</bold></highlight>, where it waits for the next segment to be received. Upon receiving the next segment, the method <highlight><bold>400</bold></highlight> proceeds to step <highlight><bold>404</bold></highlight>, where the segment is examined. </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> At step <highlight><bold>418</bold></highlight> a query is made as to the table type requested by the application program. Specifically, a query is made as to whether the first table record within the directory is of the type requested by the application program. If the query at step <highlight><bold>418</bold></highlight> is answered negatively, then the method proceeds to step <highlight><bold>422</bold></highlight>, where the bit array field <highlight><bold>136</bold></highlight> in the present table description record <highlight><bold>130</bold></highlight> is set to zero. The method <highlight><bold>400</bold></highlight> then proceeds to step <highlight><bold>428</bold></highlight>. </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> If the query at step <highlight><bold>418</bold></highlight> is answered affirmatively, then the method <highlight><bold>400</bold></highlight> proceeds to step <highlight><bold>420</bold></highlight>, where memory is allocated for the table. Specifically, at step <highlight><bold>420</bold></highlight> the table record is examined to determine the amount of memory necessary to store the table information. This amount of memory is then allocated to the table. The memory typically comprises heap within a stack or other variable memory arrangement utilized by the application program requesting the table. The method <highlight><bold>400</bold></highlight> then proceeds to step <highlight><bold>424</bold></highlight>, where a pointer to the allocated memory location (e.g., a pointer into the application heap) is stored in the pointer to allocated memory field <highlight><bold>137</bold></highlight> of the table record <highlight><bold>130</bold></highlight>. The method <highlight><bold>400</bold></highlight> then proceeds to step <highlight><bold>426</bold></highlight>. </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> At step <highlight><bold>426</bold></highlight>, a remaining segment (REMAIN_SEGS) variable, which was initialized to zero at step <highlight><bold>217</bold></highlight>, is incremented by the quantity contained within the number of segments field <highlight><bold>131</bold></highlight> of the table description record <highlight><bold>130</bold></highlight> associated with the present table being processed in the received directory. The method <highlight><bold>400</bold></highlight> then proceeds to step <highlight><bold>428</bold></highlight>. At step <highlight><bold>428</bold></highlight> a query is made as to whether more table description records remain to be processed within the received directory. That is, a query is made to determine whether steps <highlight><bold>418</bold></highlight> through <highlight><bold>426</bold></highlight> have been processed for each of the table description records contained within the received directory. If the query at step <highlight><bold>428</bold></highlight> is answered affirmatively, (i.e., more table description records remain to be processed), then the method <highlight><bold>400</bold></highlight> proceeds to step <highlight><bold>430</bold></highlight>, where the next table descriptor record is retrieved from the received directory. The method <highlight><bold>400</bold></highlight> then proceeds to step <highlight><bold>418</bold></highlight>. If the query at step <highlight><bold>428</bold></highlight> is answered negatively, then the method <highlight><bold>400</bold></highlight> proceeds to step <highlight><bold>432</bold></highlight>. </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> At step <highlight><bold>432</bold></highlight> a request state field within a request record is modified to indicate that the directory processing is complete. The method <highlight><bold>400</bold></highlight> then proceeds to step <highlight><bold>434</bold></highlight>. At step <highlight><bold>434</bold></highlight> a new buffer from the buffer pool is retrieved. That is, a new buffer is formed from a pool of memory resources available for such use, thereby preserving the previous buffer which includes the previous received segment (e.g., a received directory). The method <highlight><bold>400</bold></highlight> then proceeds to step <highlight><bold>414</bold></highlight>, where the new buffer is submitted to the transport receiver process, and, the method <highlight><bold>400</bold></highlight> proceeds to step <highlight><bold>416</bold></highlight> to wait for the next segment. </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> In the exemplary embodiment, a fixed number of static buffers (8) are allocated for the purpose of storing, e.g., DCII messages or segments received by the transport processor. While servicing a data request, a subset of these buffers are submitted to the transport processor. Buffers containing valid, non-redundant directories are removed from circulation and replaced by other buffers from the buffer pool. All messages containing non-directory data are processed (i.e., data copied or ignored) and resubmitted to the transport processor for reuse. When a directory is no longer needed, it is returned to the buffer pool. In this manner, only data used by the application is copied. The copy operation is also used to reassemble the necessary data. The copy operation does not copy data used for facilitating the process (i.e., Stream header and directory). </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> It is important to note that by allocating additional buffers each time a valid, non redundant directory or table segment is retrieved, the amount of memory resources within a set top terminal or other (typically) memory resource constrained device may be preserved. This architecture is entirely different than architectures which utilize an array or other large memory structure for storing received segments or other information stream components. This buffer allocation structure essentially grows as needed to accommodate only the information that is both useful, valid and not redundant. Thus, upon processing an entire data stream the memory allocated to store that stream is only that amount of memory necessary to store those portions (or the entirety) of the stream that are required by the application or capable of being processed on the platform or set top terminal receiving this stream. </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> As previously noted, a query was made at step <highlight><bold>406</bold></highlight> to determine if a received segment contained a directory. If the query at step <highlight><bold>406</bold></highlight> was answered negatively, then the method <highlight><bold>400</bold></highlight> proceeds to step <highlight><bold>439</bold></highlight>. At step <highlight><bold>439</bold></highlight> a query is made as to whether a directory has been previously acquired. If the query at step <highlight><bold>439</bold></highlight> is answered affirmatively, then the routine <highlight><bold>400</bold></highlight> proceeds to step <highlight><bold>440</bold></highlight>. If the query at step <highlight><bold>439</bold></highlight> is answered negatively, then the routine <highlight><bold>400</bold></highlight> proceeds to step <highlight><bold>414</bold></highlight>. </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> At step <highlight><bold>440</bold></highlight> the method <highlight><bold>400</bold></highlight> checks to see if the table extension is less than or equal to the number of tables in a previously received directory. That is, a query is made as to whether the table extension number of the received table segment is such that the table cannot be one of the tables having a table description record <highlight><bold>130</bold></highlight> in the directory structure <highlight><bold>120</bold></highlight> of the previously retrieved directory. This condition may occur in the case of a data creation error or directory from one stream applied to another stream. The method <highlight><bold>400</bold></highlight> then proceeds to step <highlight><bold>442</bold></highlight>. </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> At step <highlight><bold>442</bold></highlight> the method checks to see if the segment number of the received segment is less than the number of segments field <highlight><bold>133</bold></highlight> of the table description record <highlight><bold>130</bold></highlight> of the presently received table. That is, a query is made as to whether the received non-directory segment (i.e., a table segment) is part of the table being presently received. The method <highlight><bold>400</bold></highlight> then proceeds to step <highlight><bold>444</bold></highlight>. </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> At step <highlight><bold>444</bold></highlight> acquire is made as to whether segment is valid. That is, a query is made as to whether the table extension in the segment header is less than or equal to the number of tables listed in the directory, and, additionally, the segment number of the received segment in the segment header is less than the number of segments listed in the corresponding table description record (per steps <highlight><bold>440</bold></highlight> and <highlight><bold>442</bold></highlight>). If the query at step <highlight><bold>444</bold></highlight> is answered negatively, i.e., an invalid segment) then the method <highlight><bold>400</bold></highlight> proceeds to step <highlight><bold>448</bold></highlight>. At step <highlight><bold>448</bold></highlight> an &ldquo;object load fail&rdquo; message is sent to the application, and the method <highlight><bold>400</bold></highlight> proceeds to step <highlight><bold>450</bold></highlight> where it is exited. If the query at step <highlight><bold>444</bold></highlight> is answered affirmatively, then the method <highlight><bold>400</bold></highlight> proceeds to step <highlight><bold>446</bold></highlight>. </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> At step <highlight><bold>446</bold></highlight> the segment number of the received segment is compared to a corresponding bit in the bit array field <highlight><bold>136</bold></highlight> of the table descriptor record <highlight><bold>130</bold></highlight>. As previously noted, the bit array field includes one bit for each segment associated with the corresponding table. Thus, in the case of a table comprising 30 segments (as indicated by the number of segments field <highlight><bold>133</bold></highlight>), the bit array of received segments field will comprise a 30 bit field, where each of the 30 bits is associated with a corresponding segment of the table. Prior to reading or receiving any of the table segments, the bit array of received segments field is set to a first logical state, illustratively all ones. As each segment of the table is received, the bit within the bit array of received segments field corresponding to the successfully received segment is set to zero. In this manner it is quickly and easily determined whether or not a received segment has been received and processed previously. Thus, at step <highlight><bold>446</bold></highlight> the method <highlight><bold>400</bold></highlight> compares the segment number of the received segment to the corresponding bit in the bit array of received segments field <highlight><bold>136</bold></highlight> of the table descriptor record <highlight><bold>130</bold></highlight>. The method <highlight><bold>400</bold></highlight> then proceeds to step <highlight><bold>452</bold></highlight>. </paragraph>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> At step <highlight><bold>452</bold></highlight> a query is made as to whether the received segment is redundant. That is, a query is made as to whether the bit within the bit array of received segments field <highlight><bold>136</bold></highlight> of the table descriptor record <highlight><bold>130</bold></highlight> corresponding to the received segment has been set to zero. If the query at step <highlight><bold>452</bold></highlight> is answered affirmatively (i.e., the received segment is redundant), then the method <highlight><bold>400</bold></highlight> proceeds to step <highlight><bold>414</bold></highlight>. If the query at step <highlight><bold>452</bold></highlight> is answered negatively, then the method <highlight><bold>400</bold></highlight> proceeds to step <highlight><bold>454</bold></highlight>. </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> At step <highlight><bold>454</bold></highlight> the segment payload is copied to the memory allocated at step <highlight><bold>420</bold></highlight> for storing the segment. As previously noted, this allocated memory comprises (typically) a portion of heap or stack memory associated with the application program. Moreover, since the application program is receiving one or more tables, the actual memory allocation comprises an index memory allocation. Thus, at step <highlight><bold>454</bold></highlight>, the received segment payload is copied to the allocated memory based upon the memory address pointer field <highlight><bold>137</bold></highlight>, the segment length field <highlight><bold>134</bold></highlight>, the particular segment number of the received segment and the table extension. The method <highlight><bold>400</bold></highlight> then proceeds to step <highlight><bold>456</bold></highlight>. </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> At step <highlight><bold>456</bold></highlight> the bit within the bit array of received segments field corresponding to the received segment is reset (i.e., set to zero), thereby indicating that the received segment has been received and processed and that any further reception of this segment may be ignored as being redundant. The method <highlight><bold>400</bold></highlight> then proceeds to step <highlight><bold>458</bold></highlight>. </paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> At step <highlight><bold>458</bold></highlight> the REMAIN_SEGS variable is decremented by one. That is, the variable indicative of the remaining number of segments within the stream to be processed is decremented by one. The method <highlight><bold>400</bold></highlight> then proceeds to step <highlight><bold>460</bold></highlight>. </paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> At step <highlight><bold>460</bold></highlight> a query is made as to whether the bit array of received segments field <highlight><bold>136</bold></highlight> of the table descriptor record <highlight><bold>130</bold></highlight> is equal to zero. That is, a query is made as to whether all of the bits corresponding to segments to be received have been set to zero, thereby indicating that all of the segments have in fact been received. If the quire at step <highlight><bold>460</bold></highlight> is answered affirmatively, then the method <highlight><bold>400</bold></highlight> proceeds to step <highlight><bold>462</bold></highlight>, where a &ldquo;object completion message&rdquo; is set to the application. The method <highlight><bold>400</bold></highlight> then proceeds to step <highlight><bold>464</bold></highlight>. </paragraph>
<paragraph id="P-0068" lvl="0"><number>&lsqb;0068&rsqb;</number> At step <highlight><bold>464</bold></highlight> a query is made as to whether the REMAIN_SEGS variable is equal to zero. That is, a query is made as to whether all of the segments within the data stream have been processed. It should be noted that the total number of segments to be processed comprise the one directory segment and the sum of the one directory segment and the number of segments associated with each of the tables referenced within the directory. Thus, in the case of four tables comprised of 30 segments each, the total number of segments to be processed will be 121 segments <highlight><bold>120</bold></highlight> excluding the directory). If the query at step <highlight><bold>464</bold></highlight> is answered affirmatively, then the method <highlight><bold>400</bold></highlight> proceeds to step <highlight><bold>466</bold></highlight>. If the query at step <highlight><bold>464</bold></highlight> is answered negatively, then the method <highlight><bold>400</bold></highlight> proceeds to step <highlight><bold>414</bold></highlight> where the buffer is resubmitted to the transport receiver process and the method <highlight><bold>400</bold></highlight> waits for reception of the next segment. </paragraph>
<paragraph id="P-0069" lvl="0"><number>&lsqb;0069&rsqb;</number> At step <highlight><bold>466</bold></highlight>, the method <highlight><bold>400</bold></highlight> sends a &ldquo;object load complete&rdquo; message to the application. The method <highlight><bold>400</bold></highlight> then proceeds to step <highlight><bold>468</bold></highlight> where the application stream request is de-activated. Among the various housekeeping activities of the request deactivation step <highlight><bold>468</bold></highlight>, all outstanding buffers are returned to the buffer pool thereby preventing memory leaks. Additional housekeeping activities are readily known to those skilled in the art. The method <highlight><bold>400</bold></highlight> then proceeds to step <highlight><bold>470</bold></highlight> where it is exited. </paragraph>
<paragraph id="P-0070" lvl="0"><number>&lsqb;0070&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> depicts a stream request processing method <highlight><bold>500</bold></highlight> suitable for use in the segment processing method <highlight><bold>400</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 4</cross-reference>. Specifically, <cross-reference target="DRAWINGS">FIG. 5</cross-reference> depicts a method for initially responding to a stream request by, e.g., an application running within a set top terminal or other platform. </paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> The method <highlight><bold>500</bold></highlight> is entered at step <highlight><bold>505</bold></highlight> and proceeds to step <highlight><bold>510</bold></highlight> where an application request for a table or tables is received. The method <highlight><bold>500</bold></highlight> then proceeds to step <highlight><bold>515</bold></highlight>, where a query is made as to whether the received request is a new request. That is, a query is made as to whether the received request has been made before and remains unfulfilled for some reason. If the query at step <highlight><bold>515</bold></highlight> is answered negatively, then the method <highlight><bold>500</bold></highlight> proceeds to step <highlight><bold>540</bold></highlight>. If the query at step <highlight><bold>515</bold></highlight> is answered affirmatively, then the method <highlight><bold>500</bold></highlight> proceeds to step <highlight><bold>520</bold></highlight>. </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> At step <highlight><bold>520</bold></highlight> a request record is retrieved from a request pool and initialized. Additionally, a request state is reset to look for a new directory. The request state is used to determine whether the request needs a directory, is acquiring tables, or has been completed and is in cleanup mode. Once a directory has been acquired the state will change to running mode. Thus, at step <highlight><bold>520</bold></highlight> the request state is reset from running mode to, essentially, &ldquo;need a directory mode.&rdquo; The buffer containing the previously acquired directory is released to the buffer pool and a new directory must be acquired. The method <highlight><bold>500</bold></highlight> then proceeds to step <highlight><bold>525</bold></highlight>. </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> At step <highlight><bold>525</bold></highlight> a program map table (PMT) is retrieved and examined to determine which packetized elementary stream (PES) or program specific information stream (PSI) contains the data associated with the desired table or tables requested. The method <highlight><bold>500</bold></highlight> then proceeds to step <highlight><bold>530</bold></highlight>. At step <highlight><bold>530</bold></highlight> packet identification (PID) filters are set to capture the identified PES or private data stream, that is, the controller <highlight><bold>270</bold></highlight>, via the control signal TD, causes the transport demultiplexer <highlight><bold>230</bold></highlight> to demultiplex the data stream DATA including the identified PES or private data stream. The method <highlight><bold>500</bold></highlight> then proceeds to step <highlight><bold>535</bold></highlight>. </paragraph>
<paragraph id="P-0074" lvl="0"><number>&lsqb;0074&rsqb;</number> At step <highlight><bold>535</bold></highlight> buffer resources are allocated for the segments to be received. That is, as previously described with respect to the buffer management functions of the present invention, a portion of random access memory <highlight><bold>276</bold></highlight>-<highlight><bold>1</bold></highlight> within memory unit <highlight><bold>276</bold></highlight> is allocated to receiving the data stream DATA produced by transport demultiplexer <highlight><bold>230</bold></highlight>. The method <highlight><bold>500</bold></highlight> then proceeds to step <highlight><bold>555</bold></highlight>, where it waits for a message to be received. That is, at step <highlight><bold>555</bold></highlight> the method <highlight><bold>500</bold></highlight> waits for an allocated buffer to be filled by the received data stream DATA such that the allocated buffer includes a message or segment. </paragraph>
<paragraph id="P-0075" lvl="0"><number>&lsqb;0075&rsqb;</number> At step <highlight><bold>554</bold></highlight> an existing request record is updated with new parameters. That is, since the application request received at step <highlight><bold>510</bold></highlight> is, in this case, an existing application request, the existing application request record is updated with parameters included within the received application request. The method <highlight><bold>500</bold></highlight> then proceeds to step <highlight><bold>545</bold></highlight>. </paragraph>
<paragraph id="P-0076" lvl="0"><number>&lsqb;0076&rsqb;</number> At step <highlight><bold>545</bold></highlight> the request state is reset such that the retrieved data stream DATA is examined to find a new directory (i.e., a new directory segment or directory message). The method <highlight><bold>500</bold></highlight> then proceeds to step <highlight><bold>550</bold></highlight>. </paragraph>
<paragraph id="P-0077" lvl="0"><number>&lsqb;0077&rsqb;</number> At step <highlight><bold>555</bold></highlight> an allocated buffer presently containing a currently received directory is released to the buffer pool. That is, a buffer allocated to the old request during step <highlight><bold>535</bold></highlight> is released to the buffer pool since a new buffer already allocated will be used to store the next received directory segment. The method <highlight><bold>500</bold></highlight> then proceeds to step <highlight><bold>555</bold></highlight> where it waits for the next ;message or segment to be received. </paragraph>
<paragraph id="P-0078" lvl="0"><number>&lsqb;0078&rsqb;</number> After receiving the next message or segment (step <highlight><bold>555</bold></highlight>), the method <highlight><bold>500</bold></highlight> proceeds to <highlight><bold>556</bold></highlight>, where a query is made as to whether an error has occurred. That is, at step <highlight><bold>556</bold></highlight> a query is made as to whether a DCII (or MPEG2 or other standard) transport error has occurred. If the query at step <highlight><bold>556</bold></highlight> is answered negatively, the method <highlight><bold>500</bold></highlight> proceeds to step <highlight><bold>557</bold></highlight> where it is exited. In the case of no error the received message or segment is suitable for further processing by, e.g., the segment processing method <highlight><bold>400</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 4</cross-reference>. If the query at step <highlight><bold>556</bold></highlight> is answered affirmatively, then the method <highlight><bold>500</bold></highlight> proceeds to step <highlight><bold>560</bold></highlight>. </paragraph>
<paragraph id="P-0079" lvl="0"><number>&lsqb;0079&rsqb;</number> At step <highlight><bold>560</bold></highlight> a query is made as to whether the request corresponding to the received segment is active. That is, a query is made as to whether a previous request from an application received at <highlight><bold>510</bold></highlight> and further processed by steps <highlight><bold>515</bold></highlight> through <highlight><bold>550</bold></highlight> that resulted in a received message or segment is still, in fact, active (i.e., not canceled, invalid or expired). If the query at step <highlight><bold>560</bold></highlight> is answered negatively (i.e., the received message or segment is associated with an inactive request), then the method <highlight><bold>500</bold></highlight> proceeds to step <highlight><bold>565</bold></highlight>. At step <highlight><bold>565</bold></highlight> the buffer including the received message or segment is released to the buffer pool, and the method <highlight><bold>500</bold></highlight> proceeds to step <highlight><bold>570</bold></highlight> where it is exited. </paragraph>
<paragraph id="P-0080" lvl="0"><number>&lsqb;0080&rsqb;</number> If the query at step <highlight><bold>560</bold></highlight> is answered affirmatively (the received segment corresponds to an active request), then the method <highlight><bold>500</bold></highlight> proceeds to step <highlight><bold>575</bold></highlight>, where the buffer including the received message or segment is released to the buffer pool. The method <highlight><bold>500</bold></highlight> then proceeds to step <highlight><bold>580</bold></highlight>, where an error message is returned to the requesting application. The method <highlight><bold>500</bold></highlight> then proceeds to step <highlight><bold>585</bold></highlight> where it is exited. </paragraph>
<paragraph id="P-0081" lvl="0"><number>&lsqb;0081&rsqb;</number> Step <highlight><bold>560</bold></highlight> is used to process corrupted or otherwise error compromised received messages or segments. In a case of a corrupted received segment that is not associated with an active request, the buffer including the received segment is simply released and the routine continues on without signaling any error condition. However, in the case of corrupted received a segment that is associated with an active request, it is important to signal to the application that an error has in fact occurred, as well as releasing the buffer to the buffer pool. It is important to note that many set top terminals, information stream receivers and other platforms do not provide an indication of error such as is queried for in step <highlight><bold>556</bold></highlight>. That is, many such platforms or set top terminals simply discard corrupted or erroneous messages prior to coupling them to the controller. For example, where transport demultiplexer <highlight><bold>230</bold></highlight> discards corrupted messages, there will likely never be an affirmative answer to the query at step <highlight><bold>556</bold></highlight>, since all erroneous messages or segments are discarded prior to being coupled to a controller <highlight><bold>270</bold></highlight>. However, there will be a discontinuity in terms of segment order that may be noted. </paragraph>
<paragraph id="P-0082" lvl="0"><number>&lsqb;0082&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> depicts a high level block diagram of a processing system suitable for generating a data stream according to the invention. Specifically, <cross-reference target="DRAWINGS">FIG. 3</cross-reference> depicts a processing system <highlight><bold>300</bold></highlight> that is used to generate a data stream according to the invention in response to object data or other data. The processing system is responsive to a control signal C that provides various parameters for adapting the processing functions of the processing system (e.g., output bitrate, type of stream to produce and the like). </paragraph>
<paragraph id="P-0083" lvl="0"><number>&lsqb;0083&rsqb;</number> The processing system <highlight><bold>300</bold></highlight> comprises a mass storage device <highlight><bold>310</bold></highlight> including an object file <highlight><bold>602</bold></highlight>, and a controller <highlight><bold>370</bold></highlight> including a microprocessor <highlight><bold>372</bold></highlight>, an input/output module <highlight><bold>374</bold></highlight>, a memory module <highlight><bold>376</bold></highlight> and support circuitry <highlight><bold>378</bold></highlight>. The microprocessor <highlight><bold>372</bold></highlight> cooperates with conventional support circuitry <highlight><bold>378</bold></highlight> such as power supplies, clock circuits, cache memory and the like as well as circuits that assist in executing the software routines. The controller <highlight><bold>370</bold></highlight> also contains input/output circuitry <highlight><bold>374</bold></highlight> that forms an interface between the controller <highlight><bold>370</bold></highlight> and a transport system or network (not shown). </paragraph>
<paragraph id="P-0084" lvl="0"><number>&lsqb;0084&rsqb;</number> The controller <highlight><bold>370</bold></highlight> retrieves object file information form the mass storage device <highlight><bold>310</bold></highlight> or from an optional data input signal OBJECT INFO. The retrieved object of other data is then processed according to the methods of <cross-reference target="DRAWINGS">FIG. 6</cross-reference> and <cross-reference target="DRAWINGS">FIG. 7</cross-reference>, which will be discussed in more detail below. A resulting data stream TRANSPORT STREAM is coupled to a transport system (not shown) as a data stream or to other processing equipment (not shown) as, e.g., a DCII message or segment stream OBJECT STREAM. </paragraph>
<paragraph id="P-0085" lvl="0"><number>&lsqb;0085&rsqb;</number> Although the processing system <highlight><bold>300</bold></highlight> is depicted as a general purpose computer that is programmed to perform specific functions in accordance with the present invention, the invention can be implemented in hardware as an application specific integrated circuit (ASIC). As such, the process steps described herein are intended to be broadly interpreted as being equivalently performed by software, hardware, or a combination thereof. </paragraph>
<paragraph id="P-0086" lvl="0"><number>&lsqb;0086&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6A</cross-reference> depicts a high level block diagram of a method for forming an object-representative table and suitable for use in the processing system of <cross-reference target="DRAWINGS">FIG. 3</cross-reference>. <cross-reference target="DRAWINGS">FIG. 6B</cross-reference> depicts a flow diagram of the method of <cross-reference target="DRAWINGS">FIG. 6A</cross-reference>. It should be noted that <cross-reference target="DRAWINGS">FIG. 6</cross-reference>A and <cross-reference target="DRAWINGS">FIG. 6B</cross-reference> are different depictions of substantially the same method for forming an object table. Specifically, <cross-reference target="DRAWINGS">FIG. 6</cross-reference>A and <cross-reference target="DRAWINGS">FIG. 6B</cross-reference> include common reference designators indicative of common steps for forming the object table. Thus, while the following discussion will refer primarily to <cross-reference target="DRAWINGS">FIG. 6</cross-reference>B, the cited reference designators will be applicable to <cross-reference target="DRAWINGS">FIG. 6</cross-reference>A and <cross-reference target="DRAWINGS">FIG. 6B</cross-reference>. </paragraph>
<paragraph id="P-0087" lvl="0"><number>&lsqb;0087&rsqb;</number> It must also be noted that <cross-reference target="DRAWINGS">FIGS. 6A and 6B</cross-reference> describe a method for generating a bit map table object from a bit map file (i.e., a &ldquo;.bmp&rdquo; file). However, the method of <cross-reference target="DRAWINGS">FIGS. 6A and 6B</cross-reference> may be readily adapted to generate object tables from any type of object, such as a relational data base object, an onscreen object, a dynamic memory or linked list object and the like. </paragraph>
<paragraph id="P-0088" lvl="0"><number>&lsqb;0088&rsqb;</number> The method <highlight><bold>600</bold></highlight> of <cross-reference target="DRAWINGS">FIGS. 6A and 6B</cross-reference> is entered at step <highlight><bold>605</bold></highlight> and proceeds to step <highlight><bold>610</bold></highlight>. At step <highlight><bold>610</bold></highlight> a palette asset is generated. That is, a palette attribute of the bit map file comprising indicia of the colors necessary to form the bit map image within the bit mat file is extracted from the bit map file as a separate object, attribute or asset. The method <highlight><bold>600</bold></highlight> then proceeds to step <highlight><bold>615</bold></highlight>. </paragraph>
<paragraph id="P-0089" lvl="0"><number>&lsqb;0089&rsqb;</number> At step <highlight><bold>615</bold></highlight> a bit map asset header is generated from the bit map file <highlight><bold>602</bold></highlight>. The bit map asset header includes information that will be used to reconstruct the bit map object at, e.g., a set top terminal, information receiver or other platform eventually receiving and constructing the bit map file from a received object table. The bit map asset header comprises information such as ID, type, number of bytes, name of bitmap and the like. The method <highlight><bold>600</bold></highlight> then proceeds to step <highlight><bold>620</bold></highlight>. </paragraph>
<paragraph id="P-0090" lvl="0"><number>&lsqb;0090&rsqb;</number> At step <highlight><bold>620</bold></highlight> the bit map data from the bit map file <highlight><bold>602</bold></highlight> is processed to form bitmap asset data. Specifically, the data formed in the bit map file is modified to allow subsequent packaging as, e.g., DCII messages or segments. For example, image information from the bit map file may be extracted from the file and segmented according to the DCII message or segment size (i.e., less than 1024 bytes), including position information or other information useful in reconstructing the process data to form the bit map image once again. The method <highlight><bold>600</bold></highlight> then proceeds to step <highlight><bold>625</bold></highlight>. </paragraph>
<paragraph id="P-0091" lvl="0"><number>&lsqb;0091&rsqb;</number> At step <highlight><bold>625</bold></highlight> the palette asset and bit map asset are packaged into messages or segments according to the DCII message/segment format or MPEG2 sequence format. That is, the combined asset header and bit map asset is packaged, along with the palette asset, into a plurality (i.e., N) of segments according to a standard segment length. The method <highlight><bold>600</bold></highlight> then proceeds to step <highlight><bold>630</bold></highlight>. </paragraph>
<paragraph id="P-0092" lvl="0"><number>&lsqb;0092&rsqb;</number> At step <highlight><bold>630</bold></highlight> the messages or segments produced at step <highlight><bold>625</bold></highlight> are associated with an object table (e.g., a bit map object table). In <cross-reference target="DRAWINGS">FIG. 6A</cross-reference> the packaged assets are represented as segments <highlight><bold>1</bold></highlight>-<highlight><bold>5</bold></highlight> of N (628). The method <highlight><bold>600</bold></highlight> then proceeds to step <highlight><bold>635</bold></highlight> where it is exited. </paragraph>
<paragraph id="P-0093" lvl="0"><number>&lsqb;0093&rsqb;</number> In the case of a set top terminal receiving a plurality of objects formed according to the method <highlight><bold>600</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 6</cross-reference>A and <cross-reference target="DRAWINGS">FIG. 6</cross-reference>B, it is likely that many objects will be required to implement functions necessary within the STT. For example, different set top terminals may be capable of displaying or utilizing bitmap objects having different resolutions. A set top terminal capable of a high resolution bit map will not be fully utilized if provided with a low resolution bit map. Similarly, a set top terminal capable of displaying only low resolution format bit map objects will be unable to display a high resolution bit map object. </paragraph>
<paragraph id="P-0094" lvl="0"><number>&lsqb;0094&rsqb;</number> In one embodiment of the invention, individual bitmap objects for high and low resolution are provided within the same table. However, in a preferred embodiment of the invention, individual bitmap objects for high and low resolution are provided within two respective tables, each table having a distinct table type. In this manner a non-used bitmap (i.e., inappropriate bitmap for a receiving platform) is not stored in memory. Therefore, both low and high resolution bit map objects may be generated as distinct bit map table objects and provided to a set top terminal. Information indicative of, e.g., the resolution of the bit map objects will be located within the asset header generated at step <highlight><bold>615</bold></highlight>. In this manner, a set top terminal may examine header information associated with the received object to determine if the received object to determine if the received object may be advantageously utilized by the set top terminal. Since memory considerations are paramount in designing set top terminals, such object selectivity is critical to providing a seamless, cross-platform &ldquo;look and feel&rdquo; to an application running on a plurality of set top terminals having different operating parameters, capabilities and functions. </paragraph>
<paragraph id="P-0095" lvl="0"><number>&lsqb;0095&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7A</cross-reference> depicts a high level block diagram of a method for forming an a data stream according to the invention and suitable for use in the processing system of <cross-reference target="DRAWINGS">FIG. 3</cross-reference>. <cross-reference target="DRAWINGS">FIG. 7B</cross-reference> depicts a flow diagram of the method of <cross-reference target="DRAWINGS">FIG. 7A</cross-reference>. It should be noted that <cross-reference target="DRAWINGS">FIG. 7</cross-reference>A and <cross-reference target="DRAWINGS">FIG. 7B</cross-reference> are different depictions of substantially the same method forming an a data stream. Specifically, <cross-reference target="DRAWINGS">FIG. 7</cross-reference>A and <cross-reference target="DRAWINGS">FIG. 7B</cross-reference> include common reference designators indicative of common steps for forming the data stream. Thus, while the following discussion will refer primarily to <cross-reference target="DRAWINGS">FIG. 7</cross-reference>B, the cited reference designators will be applicable to <cross-reference target="DRAWINGS">FIG. 7</cross-reference>A and <cross-reference target="DRAWINGS">FIG. 7B</cross-reference>. </paragraph>
<paragraph id="P-0096" lvl="0"><number>&lsqb;0096&rsqb;</number> The method <highlight><bold>700</bold></highlight> is entered at step <highlight><bold>705</bold></highlight> and proceeds to step <highlight><bold>710</bold></highlight>. At step <highlight><bold>710</bold></highlight> one or more object tables are received by, e.g., a controller or other processing entity implementing the method <highlight><bold>700</bold></highlight> of <cross-reference target="DRAWINGS">FIG. 7</cross-reference>. An exemplary processing entity will be described below with respect to <cross-reference target="DRAWINGS">FIG. 8</cross-reference>. The method <highlight><bold>700</bold></highlight> then proceeds to step <highlight><bold>715</bold></highlight>. </paragraph>
<paragraph id="P-0097" lvl="0"><number>&lsqb;0097&rsqb;</number> At step <highlight><bold>715</bold></highlight> a stream header is constructed. That is, at step <highlight><bold>715</bold></highlight> header information such as stream type <highlight><bold>111</bold></highlight>, major version <highlight><bold>112</bold></highlight>, minor version <highlight><bold>113</bold></highlight>, content ID <highlight><bold>114</bold></highlight> and creation date <highlight><bold>115</bold></highlight> is determined and used to construct a stream header. The method <highlight><bold>700</bold></highlight> then proceeds to step <highlight><bold>720</bold></highlight>. </paragraph>
<paragraph id="P-0098" lvl="0"><number>&lsqb;0098&rsqb;</number> At step <highlight><bold>720</bold></highlight> the number of tables field <highlight><bold>121</bold></highlight> within the directory <highlight><bold>120</bold></highlight> is set equal to the number of received tables. The method <highlight><bold>700</bold></highlight> then proceeds to step <highlight><bold>725</bold></highlight>. At step <highlight><bold>725</bold></highlight> the first table is examined to identify parameters and/or quantities necessary to form a table record within the directory structure to be associated with the examined table. The method <highlight><bold>700</bold></highlight> then proceeds to step <highlight><bold>730</bold></highlight>. </paragraph>
<paragraph id="P-0099" lvl="0"><number>&lsqb;0099&rsqb;</number> At step <highlight><bold>730</bold></highlight> the table type field <highlight><bold>131</bold></highlight>, table ID field <highlight><bold>132</bold></highlight>, segment length field <highlight><bold>134</bold></highlight>, number of bytes in table record field <highlight><bold>135</bold></highlight>, and bit array field <highlight><bold>136</bold></highlight> of the table record <highlight><bold>130</bold></highlight> associated with the table examined at step <highlight><bold>725</bold></highlight> are set. That is, at step <highlight><bold>730</bold></highlight> all the necessary parameters that may be ascertained by examining a received table are determined and inserted into a table record (e.g., 121) associated with the table examined at step <highlight><bold>725</bold></highlight>. The method <highlight><bold>700</bold></highlight> then proceeds to step <highlight><bold>735</bold></highlight>. </paragraph>
<paragraph id="P-0100" lvl="0"><number>&lsqb;0100&rsqb;</number> At step <highlight><bold>735</bold></highlight> a query is made as to whether more tables are to be examined. That is, a query is made as to whether additional tables have been received at step <highlight><bold>710</bold></highlight> but not yet examined. If the query at step <highlight><bold>735</bold></highlight> is answered affirmatively, then the method <highlight><bold>700</bold></highlight> proceeds to step <highlight><bold>740</bold></highlight> where the next table is examined, and to step <highlight><bold>730</bold></highlight> where the table record information associated with the examined table is set. If the query at step <highlight><bold>735</bold></highlight> is answered negatively, then the method <highlight><bold>700</bold></highlight> proceeds to step <highlight><bold>745</bold></highlight>. At step <highlight><bold>745</bold></highlight> the directory formed by steps <highlight><bold>725</bold></highlight> through <highlight><bold>740</bold></highlight> is packaged as a message or segment. The message <highlight><bold>700</bold></highlight> then proceeds to step <highlight><bold>750</bold></highlight>. </paragraph>
<paragraph id="P-0101" lvl="0"><number>&lsqb;0101&rsqb;</number> At step <highlight><bold>750</bold></highlight> the packaged directory segment is located in a first payload portion of a data stream. The method <highlight><bold>700</bold></highlight> then proceeds to step <highlight><bold>755</bold></highlight>. </paragraph>
<paragraph id="P-0102" lvl="0"><number>&lsqb;0102&rsqb;</number> At step <highlight><bold>755</bold></highlight> each of the received object tables are located in the payload portion of the data stream following the directory. The order in which the object tables are inserted into the payload portion following the directory is preferably the same as the order in which the objects are referenced by table description records within the directory. The method <highlight><bold>700</bold></highlight> then proceeds to step <highlight><bold>760</bold></highlight>. </paragraph>
<paragraph id="P-0103" lvl="0"><number>&lsqb;0103&rsqb;</number> At step <highlight><bold>760</bold></highlight> the stream header constructed at step <highlight><bold>715</bold></highlight> is prepended to the payload portion formed at steps <highlight><bold>750</bold></highlight> and <highlight><bold>755</bold></highlight> to form a data structure (i.e., a data stream). The method <highlight><bold>700</bold></highlight> then proceeds to step <highlight><bold>765</bold></highlight>. </paragraph>
<paragraph id="P-0104" lvl="0"><number>&lsqb;0104&rsqb;</number> At step <highlight><bold>765</bold></highlight> the data structure or data stream formed at step <highlight><bold>760</bold></highlight> is converted into a transport stream, illustratively, an MPEG2 transport stream or other suitable transport stream. The method <highlight><bold>700</bold></highlight> then proceeds to step <highlight><bold>770</bold></highlight> where it is exited. </paragraph>
<paragraph id="P-0105" lvl="0"><number>&lsqb;0105&rsqb;</number> The above-described methods and apparatus efficiently determine whether or not a message has been previously received and whether a table is complete. Non-selected tables and redundant messages are quickly discarded and require no additional memory storage. </paragraph>
<paragraph id="P-0106" lvl="0"><number>&lsqb;0106&rsqb;</number> In anticipation of operating on a variety of set tops, the data structure includes provisions that allow for the selection of tables based on table type. Application features or set top terminal dependent formats may correlate to table types. Each set top determines which table types it is capable of receiving. For example, two different set top types may retrieve different tables containing on-screen display (OSD) data formatted especially for each box&apos;s OSD hardware. In addition, this feature may be used to differentiate between the performance capabilities of different boxes by allowing more advanced set tops to retrieve tables for implementing advanced features. Segments from non-selected tables are immediately discarded and therefore consume no memory resources in the set top. </paragraph>
<paragraph id="P-0107" lvl="0"><number>&lsqb;0107&rsqb;</number> A data stream created at the head-end (e.g., by processing system <highlight><bold>300</bold></highlight>) that contains one or more tables also contains a directory describing the content of each table within the data stream. In one embodiment of the invention the data stream is sent multiple times to enable the recovery of missed messages. In another embodiment of the invention, a relatively long data stream is used containing three NULL directory streams and followed by 4 copies of a standard stream. The standard stream contains 1 table containing stream header and directory information and 1 copy of each of the other tables. The non-NULL directory and plurality of object tables are repeated several times. A receiver or STT utilizes the NULL directories to identify the start of a new data stream including object tables. </paragraph>
<paragraph id="P-0108" lvl="0"><number>&lsqb;0108&rsqb;</number> As previously noted, when acquiring a new stream, a receiver first acquires the directory which has a fixed known identification number (e.g., 255). From this directory, the system allocates memory for each of the tables it expects to receive. Then, for each received message, it looks up in the record corresponding to the message&apos;s table identification number the bit in the record&apos;s bit array corresponding to the message&apos;s segment. If that bit is set, then the message has not been received and so the system used segment length and number to copy the message payload into the pre-allocated memory location. If the bit is not set indicating that the message has already been received, the message is discarded. When the bit array for a given table is zero, then all segments of that table have been received and the table can be made available to the application. </paragraph>
<paragraph id="P-0109" lvl="0"><number>&lsqb;0109&rsqb;</number> The individual selection of tables by type is enabled by the table and table type fields. A table contains a logical grouping of data. This can be used to store feature or format information that is used by a set top to execute the application. The table type stored in the directory record of each table is used by the individual set top to determine which tables it will received. When requesting a stream, the application for a given set top model indicates which table types it supports. When processing the directory message, the system compares the table type for each record against the supported table types. If a table is not supported, the bit array in its directory record is cleared to zero indicating that no segments are to be acquired for that table. This prevents segments from unsupported tables from being stored in set top memory. </paragraph>
<paragraph id="P-0110" lvl="0"><number>&lsqb;0110&rsqb;</number> It must be noted that the terms &ldquo;set top terminal,&rdquo; &ldquo;receiver,&rdquo; &ldquo;information receiver&rdquo; and &ldquo;platform&rdquo; as used in the above description are used to describe apparatus providing the functionality of any information receiver (e.g., a video, audio or data information receiver), illustratively, a receiver integrated within a television set or provided as an audio-video-data component within an information receiver system. Thus, the terms should not in any way be construed as limiting the scope of the present invention. Similarly, the terms &ldquo;subscriber,&rdquo; &ldquo;viewer,&rdquo; &ldquo;information consumer&rdquo; and other like terms are intended to broadly describe any end user entity receiving information streams, including those information streams formed and/or delivered according to the teachings of the invention. </paragraph>
<paragraph id="P-0111" lvl="0"><number>&lsqb;0111&rsqb;</number> Although various embodiments which incorporate the teachings of the present invention have been shown and described in detail herein, those skilled in the art can readily devise many other varied embodiments that still incorporate these teachings. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A data structure for providing at least one table within a segmented information stream, comprising: 
<claim-text>a header portion, including a stream type identifier; and </claim-text>
<claim-text>a payload portion, including a directory and said at least one table; </claim-text>
<claim-text>said directory occupying at least a first segment within said payload portion of said information stream and including, for each of said at least one tables, a respective table description record, said table description record including indicia of table type and number of table segments, said table description record also including a segment bit array field, said segment bit array field including at least one bit corresponding to each of said number of table segments; </claim-text>
<claim-text>said at least one table occupying one or more contiguous segments within said payload portion of said information stream. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. In an information stream receiver, a method for processing a received information stream formed according to the data structure of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> to determine if a desired table has been received, comprising the steps of: 
<claim-text>receiving a directory including a table description record associated with said desired table, said at least one bit within said segment bit array corresponding to each of said number of table segments being set to a first state; </claim-text>
<claim-text>iteratively performing the following steps until each corresponding bit within said segment bit array is set to a second state: 
<claim-text>receiving a plurality of segments, including segments associated with said desired table; and </claim-text>
<claim-text>changing to a second state, in response to receiving a segment associated with said desired table, said bit within said segment bit array corresponding to said received segment.</claim-text>
</claim-text>
</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>1</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030002586A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030002586A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030002586A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030002586A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030002586A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030002586A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030002586A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030002586A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030002586A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00009">
<image id="EMI-D00009" file="US20030002586A1-20030102-D00009.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00010">
<image id="EMI-D00010" file="US20030002586A1-20030102-D00010.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00011">
<image id="EMI-D00011" file="US20030002586A1-20030102-D00011.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
