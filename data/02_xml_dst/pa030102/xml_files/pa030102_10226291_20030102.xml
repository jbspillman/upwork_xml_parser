<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030001759A1-20030102-D00000.TIF SYSTEM "US20030001759A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030001759A1-20030102-D00001.TIF SYSTEM "US20030001759A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030001759A1-20030102-D00002.TIF SYSTEM "US20030001759A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030001759A1-20030102-D00003.TIF SYSTEM "US20030001759A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030001759A1-20030102-D00004.TIF SYSTEM "US20030001759A1-20030102-D00004.TIF" NDATA TIF>
<!ENTITY US20030001759A1-20030102-D00005.TIF SYSTEM "US20030001759A1-20030102-D00005.TIF" NDATA TIF>
<!ENTITY US20030001759A1-20030102-D00006.TIF SYSTEM "US20030001759A1-20030102-D00006.TIF" NDATA TIF>
<!ENTITY US20030001759A1-20030102-D00007.TIF SYSTEM "US20030001759A1-20030102-D00007.TIF" NDATA TIF>
<!ENTITY US20030001759A1-20030102-D00008.TIF SYSTEM "US20030001759A1-20030102-D00008.TIF" NDATA TIF>
<!ENTITY US20030001759A1-20030102-D00009.TIF SYSTEM "US20030001759A1-20030102-D00009.TIF" NDATA TIF>
<!ENTITY US20030001759A1-20030102-D00010.TIF SYSTEM "US20030001759A1-20030102-D00010.TIF" NDATA TIF>
<!ENTITY US20030001759A1-20030102-D00011.TIF SYSTEM "US20030001759A1-20030102-D00011.TIF" NDATA TIF>
<!ENTITY US20030001759A1-20030102-D00012.TIF SYSTEM "US20030001759A1-20030102-D00012.TIF" NDATA TIF>
<!ENTITY US20030001759A1-20030102-D00013.TIF SYSTEM "US20030001759A1-20030102-D00013.TIF" NDATA TIF>
<!ENTITY US20030001759A1-20030102-D00014.TIF SYSTEM "US20030001759A1-20030102-D00014.TIF" NDATA TIF>
<!ENTITY US20030001759A1-20030102-D00015.TIF SYSTEM "US20030001759A1-20030102-D00015.TIF" NDATA TIF>
<!ENTITY US20030001759A1-20030102-D00016.TIF SYSTEM "US20030001759A1-20030102-D00016.TIF" NDATA TIF>
<!ENTITY US20030001759A1-20030102-D00017.TIF SYSTEM "US20030001759A1-20030102-D00017.TIF" NDATA TIF>
<!ENTITY US20030001759A1-20030102-D00018.TIF SYSTEM "US20030001759A1-20030102-D00018.TIF" NDATA TIF>
<!ENTITY US20030001759A1-20030102-D00019.TIF SYSTEM "US20030001759A1-20030102-D00019.TIF" NDATA TIF>
<!ENTITY US20030001759A1-20030102-D00020.TIF SYSTEM "US20030001759A1-20030102-D00020.TIF" NDATA TIF>
<!ENTITY US20030001759A1-20030102-D00021.TIF SYSTEM "US20030001759A1-20030102-D00021.TIF" NDATA TIF>
<!ENTITY US20030001759A1-20030102-D00022.TIF SYSTEM "US20030001759A1-20030102-D00022.TIF" NDATA TIF>
<!ENTITY US20030001759A1-20030102-D00023.TIF SYSTEM "US20030001759A1-20030102-D00023.TIF" NDATA TIF>
<!ENTITY US20030001759A1-20030102-D00024.TIF SYSTEM "US20030001759A1-20030102-D00024.TIF" NDATA TIF>
<!ENTITY US20030001759A1-20030102-D00025.TIF SYSTEM "US20030001759A1-20030102-D00025.TIF" NDATA TIF>
<!ENTITY US20030001759A1-20030102-D00026.TIF SYSTEM "US20030001759A1-20030102-D00026.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030001759</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10226291</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20020823</filing-date>
</domestic-filing-data>
<foreign-priority-data>
<priority-application-number>
<doc-number>10-229094</doc-number>
</priority-application-number>
<filing-date>19980813</filing-date>
<country-code>JP</country-code>
</foreign-priority-data>
<foreign-priority-data>
<priority-application-number>
<doc-number>11-050500</doc-number>
</priority-application-number>
<filing-date>19990226</filing-date>
<country-code>JP</country-code>
</foreign-priority-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>H03M007/34</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>341</class>
<subclass>051000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>ENCODING AND DECODING APPARATUS WITH MATCHING LENGTH MEANS FOR SYMBOL STRINGS</title-of-invention>
</technical-information>
<continuity-data>
<division-of>
<parent-child>
<child>
<document-id>
<doc-number>10226291</doc-number>
<kind-code>A1</kind-code>
<document-date>20020823</document-date>
</document-id>
</child>
<parent>
<document-id>
<doc-number>09950783</doc-number>
<document-date>20010913</document-date>
<country-code>US</country-code>
</document-id>
</parent>
<parent-status>PENDING</parent-status>
</parent-child>
</division-of>
<division-of>
<parent-child>
<child>
<document-id>
<doc-number>09950783</doc-number>
<document-date>20010913</document-date>
<country-code>US</country-code>
</document-id>
</child>
<parent>
<document-id>
<doc-number>09372040</doc-number>
<document-date>19990811</document-date>
<country-code>US</country-code>
</document-id>
</parent>
<parent-status>GRANTED</parent-status>
<parent-patent>
<document-id>
<doc-number>6320522</doc-number>
<country-code>US</country-code>
</document-id>
</parent-patent>
</parent-child>
</division-of>
</continuity-data>
<inventors>
<first-named-inventor>
<name>
<given-name>Noriko</given-name>
<family-name>Satoh</family-name>
</name>
<residence>
<residence-non-us>
<city>Kanagawa</city>
<country-code>JP</country-code>
</residence-non-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
</inventors>
<assignee>
<organization-name>Fujitsu Limited</organization-name>
<address>
<city>Kawasaki</city>
<country>
<country-code>JP</country-code>
</country>
</address>
<assignee-type>03</assignee-type>
</assignee>
<correspondence-address>
<name-1>STAAS &amp; HALSEY LLP</name-1>
<name-2></name-2>
<address>
<address-1>700 11TH STREET, NW</address-1>
<address-2>SUITE 500</address-2>
<city>WASHINGTON</city>
<state>DC</state>
<postalcode>20001</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A symbol string detection unit detects the second symbol string matching the first symbol string having a predetermined length n from input character strings. A matching length detection unit detects a matching length k between the third symbol string following the first symbol string and the fourth symbol string following the second symbol string. A coding unit codes an input symbol string based on the symbol string detected by the symbol string detection unit and the matching length k detected by the matching length detection unit. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> 1. Field of the Invention </paragraph>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> The present invention relates to a coding apparatus and a decoding apparatus which can be optimally applied in compressing and reconstructing various data such as CAD data, document data, etc. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> 2. Description of the Related Art </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> Recently, an increasing volume of various types of data such as character codes, image data, etc. have been processed in a computer. When such large volume of data is stored and transmitted to a distant destination, it is common to compress the data with the redundant portion of the data removed to reduce the storage capacity and improve the transmission speed. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> There are two common data compressing systems. They are a dictionary type coding system based on the similarity in data sequences; and a probability statistic type coding system based on the frequency of occurrences of data strings. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> A typical example of the dictionary type coding system is an LZ77 system and an LZ78 system. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> In the LZ77 system, a predetermined buffer is provided, the position of the previous data matching in longest length is retrieved from the previously input data in the buffer, and the matching position and the matching length are used as codes. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> shows the coding method in the conventional LZ77 system. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 1</cross-reference>, assume that &lsquo;a b a b c d e f a b c d e f g h . . . &rsquo; is input as data to be compressed, and each character of the data to be compressed is assigned an input number indicating an occurrence position. </paragraph>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> First, if &lsquo;a&rsquo; having the input number 1 is input, then the character &lsquo;a&rsquo; is coded as is because it has no preceding characters. Then, when a character &lsquo;b&rsquo; having the input number 2 is input, it is compared with the previously input characters. However, there are no characters matching the character &lsquo;b&rsquo;, the character &lsquo;b&rsquo; is coded as is. Furthermore, when a character string &lsquo;a b&rsquo; having the input numbers 3 and 4 is input, it is compared with the previously input character strings. As a result, since the character string matches a character string &lsquo;a b&rsquo; having the input numbers 1 and 2, the character string &lsquo;a b&rsquo; having the input numbers 3 and 4 is coded using the matching position and matching length. In this example, since the matching position is the position of the character &lsquo;a&rsquo; having the input number 1, and the matching length is 2, &lsquo;(1, 2)&rsquo; is coded as the code of the character string &lsquo;a b&rsquo; having the input numbers 3 and 4. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> Next, when a character &lsquo;c&rsquo; having the input number 5 is input, it does not match any of the previously input characters. Therefore, the character &lsquo;c&rsquo; is coded as is. When a character &lsquo;d&rsquo; having the input number 6 is input, it does not match any of the previously input characters. Therefore, the character &lsquo;d&rsquo; is coded as is. When a character &lsquo;e&rsquo; having the input number 7 is input, it does not match any of the previously input characters. Therefore, the character &lsquo;e&rsquo; is coded as is. When a character &lsquo;f&rsquo; having the input number 8 is input, it does not match any of the previously input characters. Therefore, the character &lsquo;f&rsquo; is coded as is. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> Then, when a character string &lsquo;a b c d e f&rsquo; having the input numbers 9 through 14 is input, it matches a character string &lsquo;a b c d e f&rsquo; having the input numbers 3 through 8. Therefore, the character string &lsquo;a b c d e f&rsquo; having the input numbers 9 through 14 is coded using the matching position and the matching length. In this example, since the matching position is position of the character &lsquo;a&rsquo; having the input number 3, and the matching length is 6, &lsquo;(3, 6)&rsquo; is coded as the code of the character string &lsquo;a b c d e f&rsquo; having the input numbers 9 through 14. </paragraph>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> When a character &lsquo;g&rsquo; having the input number 15 is input, it does not match any of the previously input characters. Therefore, the character &lsquo;g&rsquo; is coded as is. When a character &lsquo;h&rsquo; having the input number 16 is input, it does not match any of the previously input characters. Therefore, the character &lsquo;h&rsquo; is coded as is. On the other hand, in the LZ78 system, a previously input character string is entered in a dictionary, and an entered input number is coded. </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> The LZ77 system has higher compression performance than the LZ78 system for data containing a repetition of a long character string. On the other hand, the LZ78 system has higher compression performance than the LZ77 system for data containing a repetition of a comparatively short character string. The LZ77 system and the LZ78 system are described in, for example, the document &ldquo;The Introduction to the Document Data Compression Algorithm&rdquo; by Tomohiko Uematsu published by CQ Publishing Company. </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> A typical system of the probability statistic type coding system can be the arithmetic coding system and the Huffman coding system. Both arithmetic coding system and Huffman coding system obtain a compression effect by allotting a short code length to a character having a high occurrence probability according to the statistic occurrence frequency of each character </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> The arithmetic coding system is described in, for example, the document &ldquo;Arithmetic coding revisited&rdquo; by Alister Moffat et al., 1995, IEEE Data Compression Conference, p202-211. The Huffman coding system is described in, for example, the document &ldquo;The Introduction to the Document Data Compression Algorithm&rdquo; by Tomohiko Uematsu published by CQ Publishing Company. </paragraph>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> To obtain a higher compression effect, a variable length coding method has been suggested based on the conditional occurrence probability (P&lsqb;Xt&verbar;Xt&minus;1&rsqb;) in which not the occurrence probability (P(Xt)) of a single character but the dependence (hereinafter referred to as a context) between an input character and its previous is taken into account. This method is described in, for example, the document &ldquo;Unbounded Length Contexts for PPM&rdquo; by John G. Cleary et al., 1995, IEEE Data Compression Conference, p52-61. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> The probability statistic type coding system as well as the LZ78 system has higher compression performance for data containing a repetition of a comparatively short character string. Normally, the LZ78 system has a higher processing speed than the probability statistic type coding system. On the other hand, the probability statistic type coding system has a higher compression rate than the LZ78 system. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> However, the LZ78 system and the probability statistic type coding system have high compression rate for data containing a repetition of a comparatively short character string, but cannot have sufficient compression rate for data containing a repetition of a long character string. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> On the other hand, the LZ77 system has high compression rate for data containing a repetition of a long character string, but cannot have sufficient compression rate for data containing a repetition of a comparatively short string. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> Therefore, the conventional compression systems have difficulty in obtaining high compression rate for data containing a repetition of long character strings and comparatively short character strings. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> The present invention aims at providing a data coding apparatus capable of efficiently compressing both long and short character strings. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> To solve the above described problem, the present invention includes a symbol string detection unit for detecting a second symbol string matching a first symbol string having a predetermined length from an input symbol string; a matching length detection unit for detecting a matching length between a third symbol string following the first symbol string and a fourth symbol string following the second symbol string; and a coding unit for coding the input symbol string based on the symbol string detected by the symbol string detection unit and the matching length detected by the matching length detection unit. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> Thus, for input data having a repetition of long symbol strings, a part of matching symbol string can be coded based on the matching length. Accordingly, the input data having a repetition of long symbol strings can be efficiently compressed. In addition, since a remaining portion of a matching symbol string is used as a code for use in detecting a matching position, the matching position can be detected without newly inserting a code for use in detecting the matching position. As a result, even when input data having a repetition of short symbol strings is coded using a matching length, the deterioration of a compression rate can be prevented from being caused by a large number of new codes inserted for detection of a matching position. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> Furthermore, according to an aspect of the present invention, when a first symbol string matching a second symbol string having a predetermined length occurs, a third symbol string following the first symbol string is coded based on the matching length between the third symbol string and a fourth symbol string following the second symbol string. The portion not coded based on the matching length is coded using the code of a symbol immediately succeeding a symbol string which is a context. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> Thus, for input data having a repetition of long symbol strings, a matching symbol string can be coded based on a matching string. Input data having a repetition of short symbol strings can be coded by allotting a shorter code length to a symbol string having a higher occurrence probability. As a result, a high compression rate can be attained for both data having a repetition of long symbol strings and data having a repetition of short symbol strings. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> Furthermore, according to another aspect of the present invention, when a first symbol string matching a second symbol string having a predetermined length occurs, a third symbol string following the first symbol string is coded based on the matching length between the third symbol string and a fourth symbol string following the second symbol string. The portion not coded based on the matching length is coded by retrieving a coded word corresponding to the current symbol string from the dictionary in which the symbol strings occurred previously are entered in association with coded words. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> Thus, for input data having a repetition of long symbol strings, a matching symbol string can be coded based on a matching string, and input data having a, repetition of short symbol strings can be coded by the LZ 78 system. As a result, a high compression rate can be attained for both data having a repetition of long symbol strings and data having a repetition of short symbol strings. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> According to a further aspect of the present invention, when a first symbol string matching a second symbol string having a predetermined length occurs, a third symbol string following the first symbol string is coded based on the matching length between the third symbol string and a fourth symbol string following the second symbol string. The data coded based on the matching length is further coded using the code of a symbol immediately succeeding a symbol string which is a context. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> Thus, for input data having a repetition of long symbol strings, a matching symbol string can be coded based on the matching length. Accordingly, the input data having a repetition of long symbol strings can be efficiently compressed. In addition, when a short symbol string repeatedly occurs in compressed data coded based on a matching length, the compressed data coded based on the matching length can be furthermore compressed by allotting a short code length to a symbol string having a high occurrence probability, thereby attaining a high compression rate. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> According to a further aspect of the present invention, when a first symbol string matching a second symbol string having a predetermined length occurs, a third symbol string following the first symbol string is coded based on the matching length between the third symbol string and a fourth symbol string following the second symbol string. The data coded based on the matching length is further coded by retrieving a coded word corresponding to the current symbol string from the dictionary in which the symbol strings occurred previously are entered in association with coded words. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> Thus, for input data having a repetition of long symbol strings, a matching symbol string can be coded based on the matching length. Accordingly, the input data having a repetition of long symbol strings can be efficiently compressed. In addition, the compressed data coded based on the matching length can be further compressed by the LZ78 system. Therefore, a high compression rate can be attained for both data having a repetition of long symbol strings and data having a repetition of short symbol strings. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> According to a further aspect of the present invention, the occurrence position of a symbol string which previously occurred is stored in association with a predetermined code, and it is checked whether or not a code corresponding to a symbol string immediately before a symbol string coded based on a matching length is stored, thereby detecting the occurrence position of a previous symbol string to be compared when the symbol string is coded based on the matching length. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> Thus, when the occurrence position of the previous symbol string to be compared based on the matching length is checked, it is not necessary to check back one by one the previous symbol strings until a symbol string matching in a previous symbol string can be detected, thereby performing a process at a higher speed. </paragraph>
<paragraph id="P-0035" lvl="0"><number>&lsqb;0035&rsqb;</number> Furthermore, according to a further aspect of the present invention, when a matching length is shorter than a predetermined value, the symbol string is not coded based on the matching length. </paragraph>
<paragraph id="P-0036" lvl="0"><number>&lsqb;0036&rsqb;</number> Thus, when a matching length is short, the deterioration of a compression rate caused by adding a code indicating a matching length can be successfully avoided, thereby improving the compression rate in a coding process.</paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0037" lvl="0"><number>&lsqb;0037&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> shows the encoding method using the conventional LZ77 code; </paragraph>
<paragraph id="P-0038" lvl="0"><number>&lsqb;0038&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a block diagram of the configuration of the coding apparatus according to the first embodiment of the present invention; </paragraph>
<paragraph id="P-0039" lvl="0"><number>&lsqb;0039&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> shows the coding method and the decoding method according to the first embodiment of the present invention; </paragraph>
<paragraph id="P-0040" lvl="0"><number>&lsqb;0040&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> shows the data compressing method according to the second embodiment of the present invention; </paragraph>
<paragraph id="P-0041" lvl="0"><number>&lsqb;0041&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a block diagram of the configuration of the data compression apparatus according to the second embodiment of the present invention; </paragraph>
<paragraph id="P-0042" lvl="0"><number>&lsqb;0042&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is a block diagram of the configuration of the data reconstruction apparatus according to the second embodiment of the present invention; </paragraph>
<paragraph id="P-0043" lvl="0"><number>&lsqb;0043&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> shows the data compressing method according to the third embodiment of the present invention; </paragraph>
<paragraph id="P-0044" lvl="0"><number>&lsqb;0044&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> is a block diagram of the configuration of the data compression apparatus according to the third embodiment of the present invention; </paragraph>
<paragraph id="P-0045" lvl="0"><number>&lsqb;0045&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference> is a block diagram of the configuration of the data reconstruction apparatus according to the third embodiment of the present invention; </paragraph>
<paragraph id="P-0046" lvl="0"><number>&lsqb;0046&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10</cross-reference> shows the data compressing method according to the fourth embodiment of the present invention; </paragraph>
<paragraph id="P-0047" lvl="0"><number>&lsqb;0047&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 11</cross-reference> is a block diagram of the configuration of the data compression apparatus according to the fourth embodiment of the present invention; </paragraph>
<paragraph id="P-0048" lvl="0"><number>&lsqb;0048&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 12</cross-reference> is a block diagram of the configuration of the data reconstruction apparatus according to the fourth embodiment of the present invention; </paragraph>
<paragraph id="P-0049" lvl="0"><number>&lsqb;0049&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 13</cross-reference> shows the coding method and decoding method according to the fifth embodiment of the present invention; </paragraph>
<paragraph id="P-0050" lvl="0"><number>&lsqb;0050&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 14</cross-reference> is a block diagram of the configuration of the data compression apparatus according to the sixth embodiment of the present invention; </paragraph>
<paragraph id="P-0051" lvl="0"><number>&lsqb;0051&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 15</cross-reference> is a block diagram of the configuration of the data reconstruction apparatus according to the sixth embodiment of the present invention; </paragraph>
<paragraph id="P-0052" lvl="0"><number>&lsqb;0052&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 16</cross-reference> is a block diagram of the configuration of the data compression apparatus according to the seventh embodiment of the present invention; </paragraph>
<paragraph id="P-0053" lvl="0"><number>&lsqb;0053&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 17</cross-reference> is a block diagram of the configuration of the data reconstruction apparatus according to the seventh embodiment of the present invention; </paragraph>
<paragraph id="P-0054" lvl="0"><number>&lsqb;0054&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 18</cross-reference> is a block diagram of the configuration of the coding apparatus according to the eighth embodiment of the present invention; </paragraph>
<paragraph id="P-0055" lvl="0"><number>&lsqb;0055&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 19</cross-reference> shows the encoding method according to the eighth embodiment of the present invention; </paragraph>
<paragraph id="P-0056" lvl="0"><number>&lsqb;0056&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 20</cross-reference> shows the data compressing method according to the ninth embodiment of the present invention; </paragraph>
<paragraph id="P-0057" lvl="0"><number>&lsqb;0057&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 21</cross-reference> is a flowchart of the data compressing method according to the tenth embodiment of the present invention; </paragraph>
<paragraph id="P-0058" lvl="0"><number>&lsqb;0058&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 22</cross-reference> is a flowchart of the data compressing method according to the eleventh embodiment of the present invention; </paragraph>
<paragraph id="P-0059" lvl="0"><number>&lsqb;0059&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 23</cross-reference> is a flowchart of the data compressing method according to the twelfth embodiment of the present invention; </paragraph>
<paragraph id="P-0060" lvl="0"><number>&lsqb;0060&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 24</cross-reference> is a flowchart of the data compressing method according to the thirteenth embodiment of the present invention; </paragraph>
<paragraph id="P-0061" lvl="0"><number>&lsqb;0061&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 25</cross-reference> is a block diagram of the configuration of the data compression apparatus according to the fourteenth embodiment of the present invention; and </paragraph>
<paragraph id="P-0062" lvl="0"><number>&lsqb;0062&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 26</cross-reference> is a block diagram of the system configuration of the coding apparatus and the decoding apparatus according to an embodiment of the present invention.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS </heading>
<paragraph id="P-0063" lvl="0"><number>&lsqb;0063&rsqb;</number> The coding apparatus according to an embodiment of the present invention is described below by referring to the attached drawings. </paragraph>
<paragraph id="P-0064" lvl="0"><number>&lsqb;0064&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2</cross-reference> is a block diagram of the configuration of the coding apparatus according to the first embodiment of the present invention. </paragraph>
<paragraph id="P-0065" lvl="0"><number>&lsqb;0065&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 2, a</cross-reference> symbol string detection unit <highlight><bold>1</bold></highlight> detects a second symbol string matching a first symbol string having a predetermined length of n from input symbol strings. A matching length detection unit <highlight><bold>2</bold></highlight> detects a matching length k between a third symbol string following the first symbol string and a fourth symbol string following the second symbol string. A coding unit <highlight><bold>3</bold></highlight> codes an input symbol string based on the symbol string detected by the symbol string detection unit <highlight><bold>1</bold></highlight> and the matching length k detected by the matching length detection unit <highlight><bold>2</bold></highlight>. </paragraph>
<paragraph id="P-0066" lvl="0"><number>&lsqb;0066&rsqb;</number> As a result, when the third symbol string is coded based on the matching length k, the occurrence position of the fourth symbol string corresponding to the third symbol string can be detected based on the first symbol string, and it is not necessary to insert an excess code indicating the occurrence position of the fourth symbol string. Therefore, a high compression rate can be maintained for a repetition of long symbol strings while the reduction of the compression rate for a repetition of short symbol strings can be avoided. </paragraph>
<paragraph id="P-0067" lvl="0"><number>&lsqb;0067&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 3</cross-reference> shows the coding method and the decoding method according to the first embodiment of the present invention. </paragraph>
<paragraph id="P-0068" lvl="0"><number>&lsqb;0068&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 3, a</cross-reference> second symbol string having the length of n is input as input data. Assuming that, after the second symbol string is input, a first symbol string having the length of n is input. Assuming that the first symbol string matches the second symbol string, the first symbol string is sequentially compared with the symbol strings input previously to detect the second symbol string matching the first symbol string, thereby specifying the occurrence position of the second symbol string. </paragraph>
<paragraph id="P-0069" lvl="0"><number>&lsqb;0069&rsqb;</number> When the occurrence position of the second symbol string can be specified, the matching length k between the third symbol string following the first symbol string and the fourth symbol string following the second symbol string is checked, and the third symbol string is coded base on the matching length k. </paragraph>
<paragraph id="P-0070" lvl="0"><number>&lsqb;0070&rsqb;</number> As a result, a code corresponding to the first symbol string of the input data, a code corresponding to the third symbol string of the input data, a code of the second symbol string of the input data, and a code of the matching length k can be generated as coded data. </paragraph>
<paragraph id="P-0071" lvl="0"><number>&lsqb;0071&rsqb;</number> When the coded data are decoded, the code corresponding to the second symbol string, the code corresponding to the fourth symbol string, and the code corresponding to the first symbol string are decoded. Then, a symbol string matching the first symbol string is retrieved from the decoding result. If the second symbol string is detected as a symbol string matching the first symbol string, then the code of the matching length k following the code of the first symbol string is decoded to obtain the matching length k. If the matching length k is obtained, the fourth symbol string having the matching length k and following the second symbol string is output as a decoding result of the third symbol string. </paragraph>
<paragraph id="P-0072" lvl="0"><number>&lsqb;0072&rsqb;</number> Thus, when the first and second symbol strings match each other, the third symbol string is coded based on the matching length k. As a result, when long symbol strings repeatedly occur, the repetition of the long symbol strings can be coded based on the matching length k, thereby efficiently compressing data. In addition, since the first symbol string is coded based on the symbol string, the fourth symbol string required when the third symbol string coded based on the matching length k is decoded can be detected using the first symbol string. As a result, it is not necessary to insert an identification code for use in detecting the fourth symbol string into coded data. Accordingly, data can also be efficiently compressed when short symbol strings repeatedly occurs. </paragraph>
<paragraph id="P-0073" lvl="0"><number>&lsqb;0073&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> shows the data compressing method according to the second embodiment of the present invention. According to the second embodiment, an n-character string is retrieved from the previously input data, and the currently input data is coded based on the matching length k of the matching portion from the (n&plus;1)th character. According to the embodiment described below, a character is input. However, the present invention is not limited to the compression of character codes, but can be applied to various data. That is, based on an information logic, one work unit of data is referred to as a character (alphabet), and a string of any number of words is referred to as a character string. </paragraph>
<paragraph id="P-0074" lvl="0"><number>&lsqb;0074&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, assume that a character string &lsquo;a b a b c d e f a b c d e f g h . . . &rsquo; is input as data to be compressed, and an input number indicating an occurrence position is assigned to each character of the data to be compressed. In addition, assume that n&equals;3, a 3-character string is retrieved from the previously input data, and the currently input data is coded based on the matching length k of the matching portion from the fourth character. </paragraph>
<paragraph id="P-0075" lvl="0"><number>&lsqb;0075&rsqb;</number> First if &lsquo;a&rsquo; having the input number 1 is input, then the character &lsquo;a&rsquo; is coded as is because it has no preceding characters. Then, when a character &lsquo;b&rsquo; having the input number 2 is input, it is compared with the previously input characters. However, there are no characters matching the character &lsquo;b&rsquo;, the character &lsquo;b&rsquo; is coded as is. Furthermore, when a character string &lsquo;a b&rsquo; having the input numbers 3 and 4 is input, it is compared with the previously input character strings. As a result, the character string matches a character string &lsquo;a b&rsquo; having the input numbers 1 and 2. However, since the length of the character string &lsquo;a b&rsquo; is 2, and is smaller than n&equals;3, the character string &lsquo;a b&rsquo; having the input numbers 3 and 4 are coded as is. </paragraph>
<paragraph id="P-0076" lvl="0"><number>&lsqb;0076&rsqb;</number> Next, when a character &lsquo;c&rsquo; having the input number 5 is input, it does not match any of the previously input characters. Therefore, the character &lsquo;c&rsquo; is coded as is. When a character &lsquo;d&rsquo; having the input number 6 is input, it does not match any of the previously input characters. Therefore, the character &lsquo;d&rsquo; is coded as is. When a character &lsquo;e&rsquo; having the input number 7 is input, it does not match any of the previously input characters. Therefore, the character &lsquo;e&rsquo; is coded as is. When a character &lsquo;f&rsquo; having the input number 8 is input, it does not match any of the previously input characters. Therefore, the character &lsquo;f&rsquo; is coded as is. </paragraph>
<paragraph id="P-0077" lvl="0"><number>&lsqb;0077&rsqb;</number> When a character string &lsquo;a b c&rsquo; having the input numbers 9 through 11 is input, it matches the character string &lsquo;a b c&rsquo; having the input numbers 3 through 5, and n&equals;3. Therefore, the character string &lsquo;a b c&rsquo; having the input numbers 9 through 11 is coded as is, and the character string having the input numbers of and after 12 is coded based on the matching length k of the character string having the input numbers of and after 6. Since the character string &lsquo;d e f&rsquo; having the input numbers 6 through 8 matches the character string &lsquo;d e f&rsquo; having the input numbers 12 through 14, and the matching length k&equals;3, the character string &lsquo;d e f&rsquo; having the input numbers 12 through 14 is coded based on the matching length of 3. </paragraph>
<paragraph id="P-0078" lvl="0"><number>&lsqb;0078&rsqb;</number> Next, when a character &lsquo;g&rsquo; having the input number 15 is input, it does not match any of the previously input characters. Therefore, the character &lsquo;g&rsquo; is coded as is. When a character &lsquo;h&rsquo; having the input number 16 is input, it does not match any of the previously input characters. Therefore, the character &lsquo;h&rsquo; is coded as is. </paragraph>
<paragraph id="P-0079" lvl="0"><number>&lsqb;0079&rsqb;</number> As a result, coded data &lsquo;a b a b c d e f a b c 3 g h . . . &rsquo; is obtained for the data &lsquo;a b a b c d e f a b c d e f g h . . . &rsquo; to be compressed. </paragraph>
<paragraph id="P-0080" lvl="0"><number>&lsqb;0080&rsqb;</number> Thus, the character string &lsquo;a b c&rsquo; having the input numbers 9 through 11 is not coded based on a matching length even if it matches the character string &lsquo;abc&rsquo; having the input numbers 3 through 5. In this case, the character string &lsquo;a b c&rsquo; having the input numbers 9 through 11 is coded, and the character string &lsquo;d e f&rsquo; having the input numbers 12 through 14 following the character string &lsquo;a b c&rsquo; having the input numbers 9 through 11 is coded based on a matching length. </paragraph>
<paragraph id="P-0081" lvl="0"><number>&lsqb;0081&rsqb;</number> Next, when the coded data &lsquo;a b a b c d e f a b c 3 g h . . . &rsquo; is decoded, the character string &lsquo;a b a b c d e f&rsquo; is first decoded. Then, after the character string &lsquo;a b a b c d e f&rsquo; is decoded, the character string &lsquo;a b c&rsquo; immediately before the code indicating the matching length of 3 is decoded. When the code indicating the matching length of 3 following the character string &lsquo;a b c&rsquo; is decoded, the previous character string matching the character string &lsquo;a b c&rsquo; is retrieved from the previously decoded character string &lsquo;a b a b c d e f&rsquo;. When the previous character string &lsquo;a b c&rsquo; is detected from the character string &lsquo;a b a b c d e f&rsquo;, the next code indicates a matching length. Thus, the 3-character string &lsquo;d e f&rsquo; following the previous character string &lsquo;a b c&rsquo; can be obtained, and the character string &lsquo;d e f&rsquo; is output as a decoding result of a code indicating the matching length of 3 following the character string &lsquo;a b c&rsquo;. </paragraph>
<paragraph id="P-0082" lvl="0"><number>&lsqb;0082&rsqb;</number> As described above, unlike the LZ77 system, only a matching length is used as a code according to the fourth embodiment of the present invention. Therefore, a code indicating a matching position is not required, thereby realizing efficient data compression even when short character strings repeatedly occur. </paragraph>
<paragraph id="P-0083" lvl="0"><number>&lsqb;0083&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 5</cross-reference> is a block diagram of the configuration of the data compression apparatus according to the second embodiment of the present invention. </paragraph>
<paragraph id="P-0084" lvl="0"><number>&lsqb;0084&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 5</cross-reference>A, an input buffer <highlight><bold>11</bold></highlight> is provided with a Lempel buffer <highlight><bold>18</bold></highlight> for storing an already compressed portion of the data to be compressed shown in <cross-reference target="DRAWINGS">FIG. 5B</cross-reference>; and a Ziv buffer <highlight><bold>19</bold></highlight> for storing a portion to be compressed of the data to be compressed. An occurrence position holding unit <highlight><bold>13</bold></highlight> stores a part or all of the occurrence position of the character string having the length of n (hereinafter referred to as an n-character string) in the Lempel buffer <highlight><bold>18</bold></highlight>. </paragraph>
<paragraph id="P-0085" lvl="0"><number>&lsqb;0085&rsqb;</number> An occurrence/non-occurrence check unit <highlight><bold>14</bold></highlight> checks whether or not the occurrence position of the previous n-character string which is the same as the n-character string immediately before the Ziv buffer <highlight><bold>19</bold></highlight> is stored in the occurrence position holding unit <highlight><bold>13</bold></highlight>, and notifies a switch unit <highlight><bold>12</bold></highlight> of the check result. When the switch unit <highlight><bold>12</bold></highlight> receives a notification that the occurrence position of the previous n-character string which is the same as the n-character string immediately before the Ziv buffer <highlight><bold>19</bold></highlight> is stored, the switch unit <highlight><bold>12</bold></highlight> instructs an occurrence position obtaining unit <highlight><bold>15</bold></highlight> to obtain the occurrence position of the previous n-character string which is the same as the n-character string immediately before the Ziv buffer <highlight><bold>19</bold></highlight>. </paragraph>
<paragraph id="P-0086" lvl="0"><number>&lsqb;0086&rsqb;</number> When the occurrence position obtaining unit <highlight><bold>15</bold></highlight> obtains the occurrence position of the previous n-character string which is the same as the n-character string immediately before the Ziv buffer <highlight><bold>19</bold></highlight>, a matching length obtaining unit <highlight><bold>16</bold></highlight> obtains the matching length k between the character string after the occurrence position of the previous n-character string in the Lempel buffer <highlight><bold>18</bold></highlight> and the character string at and after the start of the Ziv buffer <highlight><bold>19</bold></highlight>. When the matching length k is obtained, a matching length coding unit <highlight><bold>17</bold></highlight> codes based on the matching length k the portion, in the character string at and after the start of the Ziv buffer <highlight><bold>19</bold></highlight>, matching the character string at and after the occurrence position of the previous n-character string in the Lempel buffer <highlight><bold>18</bold></highlight>. </paragraph>
<paragraph id="P-0087" lvl="0"><number>&lsqb;0087&rsqb;</number> On the other hand, when the switch unit <highlight><bold>12</bold></highlight> receives a notification that the occurrence position of the previous n-character string which is the same as the n-character string immediately before the Ziv buffer <highlight><bold>19</bold></highlight> is not stored, the character string at and after the start of the Ziv buffer <highlight><bold>19</bold></highlight> is coded as is, and output to the output buffer. </paragraph>
<paragraph id="P-0088" lvl="0"><number>&lsqb;0088&rsqb;</number> The occurrence position holding unit <highlight><bold>13</bold></highlight> can be designed to hold only the latest occurrence position in the same n-character string in the Lempel buffer <highlight><bold>18</bold></highlight>. </paragraph>
<paragraph id="P-0089" lvl="0"><number>&lsqb;0089&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 6</cross-reference> is a block diagram of the configuration of the data reconstruction apparatus according to the second embodiment of the present invention. </paragraph>
<paragraph id="P-0090" lvl="0"><number>&lsqb;0090&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 6</cross-reference>A, an output buffer <highlight><bold>27</bold></highlight> is provided with a Lempel buffer <highlight><bold>28</bold></highlight> for storing an already reconstructed portion of the compressed data shown in <cross-reference target="DRAWINGS">FIG. 6B</cross-reference>; and a Ziv buffer <highlight><bold>29</bold></highlight> for storing a portion to be reconstructed in the compressed data. An occurrence position holding unit <highlight><bold>23</bold></highlight> stores a part or all of the occurrence position of the n-character string in the Lempel buffer <highlight><bold>28</bold></highlight>. </paragraph>
<paragraph id="P-0091" lvl="0"><number>&lsqb;0091&rsqb;</number> An occurrence/non-occurrence check unit <highlight><bold>22</bold></highlight> checks whether or not the occurrence position of the previous n-character string which is the same as the n-character string immediately before the Ziv buffer <highlight><bold>29</bold></highlight> is stored in the occurrence position holding unit <highlight><bold>23</bold></highlight>, and notifies a switch unit <highlight><bold>21</bold></highlight> of the check result. When the switch unit <highlight><bold>21</bold></highlight> receives a notification that the occurrence position of the previous n-character string which is the same as the n-character string immediately before the Ziv buffer <highlight><bold>29</bold></highlight> is stored, the switch unit <highlight><bold>21</bold></highlight> instructs an occurrence position obtaining unit <highlight><bold>24</bold></highlight> to obtain the occurrence position of the previous n-character string which is the same as the n-character string immediately before the Ziv buffer <highlight><bold>29</bold></highlight>. </paragraph>
<paragraph id="P-0092" lvl="0"><number>&lsqb;0092&rsqb;</number> When an occurrence position obtaining unit <highlight><bold>24</bold></highlight> obtains the occurrence position of the previous n-character string which is the same as the n-character string immediately before the Ziv buffer <highlight><bold>29</bold></highlight>, a matching length reconstruction unit <highlight><bold>25</bold></highlight> reconstructs the matching length k from the code after the n-character string immediately before the Ziv buffer <highlight><bold>29</bold></highlight>. When the matching length k is reconstructed, a copy unit <highlight><bold>26</bold></highlight> copies a character string having the matching length k following the previous n-character string in the Lempel buffer <highlight><bold>28</bold></highlight>, and outputs the copy result as a result of reconstructing the code after the n-character string immediately before the Ziv buffer <highlight><bold>29</bold></highlight>. </paragraph>
<paragraph id="P-0093" lvl="0"><number>&lsqb;0093&rsqb;</number> On the other hand, when the switch unit <highlight><bold>21</bold></highlight> receives a notification that the occurrence position of the previous n-character string which is the same as the n-character string immediately before the Ziv buffer <highlight><bold>29</bold></highlight> is not stored, the input coded data is output as is to the output buffer. </paragraph>
<paragraph id="P-0094" lvl="0"><number>&lsqb;0094&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 7</cross-reference> shows the data compressing method according to the third embodiment of the present invention. According to the third embodiment, data to be compressed is coded by the method shown in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, and the portion not replaced with a matching length is coded by the probability statistic type coding system using context. </paragraph>
<paragraph id="P-0095" lvl="0"><number>&lsqb;0095&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 7</cross-reference>, assume that a character string &lsquo;a b a b c d e f a b c d e f g h . . . &rsquo; is input as data to be compressed, and an input number indicating an occurrence position is assigned to each character of the data to be compressed. In addition, assume that n&equals;3, a 3-character string is retrieved from the previously input data, and the currently input data is coded based on the matching length k of the matching portion from the fourth character. </paragraph>
<paragraph id="P-0096" lvl="0"><number>&lsqb;0096&rsqb;</number> Furthermore, assume that there are a code table <highlight><bold>31</bold></highlight> of characters; a code table <highlight><bold>32</bold></highlight> of characters occurring after a context a; a code table <highlight><bold>33</bold></highlight> of characters occurring after a context b; a code table <highlight><bold>34</bold></highlight> of characters occurring after a context c; and a code table <highlight><bold>35</bold></highlight> of characters occurring after a context &lsquo;a b&rsquo;. </paragraph>
<paragraph id="P-0097" lvl="0"><number>&lsqb;0097&rsqb;</number> Also assume that, in the code table <highlight><bold>31</bold></highlight>, a code 111 is assigned to a character &lsquo;a&rsquo;, a code &lsquo;110&rsquo; is assigned to a character &lsquo;b&rsquo;, a code &lsquo;101&rsquo; is assigned to a character &lsquo;c&rsquo;, a code &lsquo;100&rsquo; is assigned to a character &lsquo;d&rsquo;, a code &lsquo;011&rsquo; is assigned to a character &lsquo;e&rsquo;, a code &lsquo;010&rsquo; is assigned to a character &lsquo;f&rsquo;, a code &lsquo;001&rsquo; is assigned to a character &lsquo;g&rsquo;, and a code &lsquo;000&rsquo; is assigned to a character &lsquo;h&rsquo;, </paragraph>
<paragraph id="P-0098" lvl="0"><number>&lsqb;0098&rsqb;</number> In addition, assume that, in the code table <highlight><bold>32</bold></highlight>, a code &lsquo;1&rsquo; is assigned when the character &lsquo;b&rsquo; occurs after the context &lsquo;a&rsquo;, and a code &lsquo;0&rsquo; is assigned when a character other than the character &lsquo;b&rsquo; occurs after the context &lsquo;a&rsquo;; in the code table <highlight><bold>33</bold></highlight>, a code &lsquo;11&rsquo; is assigned when the character &lsquo;a&rsquo; occurs after the context &lsquo;b&rsquo;, a code &lsquo;10&rsquo; is assigned when the character &lsquo;c&rsquo; occurs after the context &lsquo;b&rsquo;, and a code &lsquo;01&rsquo; is assigned when a character other than the characters &lsquo;a&rsquo; and &lsquo;c&rsquo; occurs after the context &lsquo;b&rsquo;;in the code table <highlight><bold>34</bold></highlight>, a code &lsquo;1&rsquo; is assigned when the character &lsquo;d&rsquo; occurs after the context &lsquo;c&rsquo;, a code &lsquo;0&rsquo; is assigned when a character other than the character &lsquo;d&rsquo; occurs after the context &lsquo;c&rsquo;; and in the code table <highlight><bold>35</bold></highlight>, a code &lsquo;11&rsquo; is assigned when the character &lsquo;a&rsquo; occurs after the context &lsquo;a b&rsquo;, a code &lsquo;10&rsquo; is assigned when the character &lsquo;c&rsquo; occurs after the context &lsquo;a b&rsquo;, and a code &lsquo;01&rsquo; is assigned when a character other than the characters &lsquo;a&rsquo; and &lsquo;c&rsquo; occurs after the context &lsquo;a b&rsquo;. </paragraph>
<paragraph id="P-0099" lvl="0"><number>&lsqb;0099&rsqb;</number> First, when the character &lsquo;a&rsquo; having the input number 1 is input, &lsquo;111&rsquo; is output as a code corresponding to the character &lsquo;a&rsquo; by referring to the code table <highlight><bold>31</bold></highlight>. Next, when the character &lsquo;b&rsquo; having the input number 2 is input, the code table <highlight><bold>32</bold></highlight> is referred to using as a context the character &lsquo;a&rsquo; immediately before the character &lsquo;b&rsquo; having the input number 2, and &lsquo;1&rsquo; is output as a code corresponding to the character &lsquo;b&rsquo; having the input number 2. Then, when the character &lsquo;a&rsquo; having the input number 3 is input, the code table <highlight><bold>33</bold></highlight> is referred to using as a context the character &lsquo;b&rsquo; immediately before the character &lsquo;a&rsquo; having the input number 3, and &lsquo;11&rsquo; is output as a code corresponding to the character &lsquo;a&rsquo; having the input number 3. Next, when the character &lsquo;b&rsquo; having the input number 4 is input, the code table <highlight><bold>32</bold></highlight> is referred to using as a context the character &lsquo;a&rsquo; immediately before the character &lsquo;b&rsquo; having the input number 4, and &lsquo;1&rsquo; is output as a code corresponding to the character &lsquo;b&rsquo; having the input number 4. Then, when the character &lsquo;c&rsquo; having the input number 5 is input, the code table <highlight><bold>35</bold></highlight> is referred to using as a context the character string &lsquo;a b&rsquo; immediately before the character &lsquo;c&rsquo; having the input number 5, and &lsquo;10&rsquo; is output as a code corresponding to the character &lsquo;c&rsquo; having the input number 5. Next, when the character &lsquo;d&rsquo; having the input number 6 is input, the code table <highlight><bold>34</bold></highlight> is referred to using as a context the character &lsquo;c&rsquo; immediately before the character &lsquo;d&rsquo; having the input number 6, and &lsquo;1&rsquo; is output as a code corresponding to the character &lsquo;d&rsquo; having the input number 6. </paragraph>
<paragraph id="P-0100" lvl="0"><number>&lsqb;0100&rsqb;</number> Next, when the character &lsquo;e&rsquo; having the input number 7 is input, &lsquo;011&rsquo; is output as a code corresponding to the character &lsquo;e&rsquo; by referring to the code table <highlight><bold>31</bold></highlight>. Then, when the character &lsquo;f&rsquo; having the input number 8 is input, &lsquo;010&rsquo; is output as a code corresponding to the character &lsquo;f&rsquo; by referring to the code table <highlight><bold>31</bold></highlight>. Next, when the character &lsquo;a&rsquo; having the input number 9 is input, &lsquo;111&rsquo; is output as a code corresponding to the character &lsquo;a&rsquo; by referring to the code table <highlight><bold>31</bold></highlight>. When the character &lsquo;b&rsquo; having the input number 10 is input, the code table <highlight><bold>32</bold></highlight> is referred to using as a context the character &lsquo;a&rsquo; immediately before the character &lsquo;b&rsquo; having the input number 10, and &lsquo;1&rsquo; is output as a code corresponding to the character &lsquo;b&rsquo; having the input number 10. Next, when the character &lsquo;c&rsquo; having the input number 11 is input, the code table <highlight><bold>35</bold></highlight> is referred to using as a context the character string &lsquo;a b&rsquo; immediately before the character &lsquo;c&rsquo; having the input number 11, and &lsquo;10&rsquo; is output as a code corresponding to the character &lsquo;c&rsquo; having the input number 11. </paragraph>
<paragraph id="P-0101" lvl="0"><number>&lsqb;0101&rsqb;</number> Since the character string &lsquo;a b c&rsquo; having the input numbers 9 through 11 matches the character string &lsquo;abc&rsquo; having the input numbers 3 through 5, and n&equals;3, the character strings having the input numbers equal to and larger than 12 are coded based on the matching length with the character strings having the input numbers equal to and larger than 6. Since the character string &lsquo;d e f&rsquo; having the input numbers 6 through 8 matches the character string &lsquo;d e f&rsquo; having the input numbers 12 through 14, and the matching length is 3, the character string &lsquo;d e f&rsquo; having the input numbers 12 through 14 is coded based on the matching length of 3, and &lsquo;0011&rsquo; is output as a code corresponding to the matching length of 3. </paragraph>
<paragraph id="P-0102" lvl="0"><number>&lsqb;0102&rsqb;</number> Next, when the character &lsquo;g&rsquo; having the input number 15 is input, &lsquo;001&rsquo; is output as a code corresponding to the character &lsquo;g&rsquo; by referring to the code table <highlight><bold>31</bold></highlight>. Then, when the character &lsquo;h&rsquo; having the input number 16 is input, &lsquo;000&rsquo; is output as a code corresponding to the character &lsquo;h&rsquo; by referring to the code table <highlight><bold>31</bold></highlight>. </paragraph>
<paragraph id="P-0103" lvl="0"><number>&lsqb;0103&rsqb;</number> According to the above described embodiment, a matching length code is expressed by 4 bits, but can be expressed by any number, of bits. In addition, a code table can be prepared for a matching length, and a matching length can be coded based on the code table. </paragraph>
<paragraph id="P-0104" lvl="0"><number>&lsqb;0104&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 8</cross-reference> is a block diagram of the configuration of the data compression apparatus according to the third embodiment of the present invention In <cross-reference target="DRAWINGS">FIG. 8</cross-reference>, an input buffer <highlight><bold>41</bold></highlight> comprises a Lempel buffer for storing an already compressed portion of the data to be compressed; and a Ziv buffer for storing a portion to be compressed of the data to be compressed. An occurrence position holding unit <highlight><bold>43</bold></highlight> stores a part or all of the occurrence position of the n-character string in the Lempel buffer. </paragraph>
<paragraph id="P-0105" lvl="0"><number>&lsqb;0105&rsqb;</number> An occurrence/non-occurrence check unit <highlight><bold>44</bold></highlight> checks whether or not the occurrence position of the same character string as the n-character string immediately before the Ziv buffer is stored in the occurrence position holding unit <highlight><bold>43</bold></highlight>, and notifies a switch unit <highlight><bold>42</bold></highlight> of the check result. When the switch unit <highlight><bold>42</bold></highlight> receives a notification that the occurrence position of the same character string as the n-character string immediately before the Ziv buffer is stored, it instructs an occurrence position obtaining unit <highlight><bold>45</bold></highlight> to obtain the occurrence position of the same character string as the n-character string immediately before the Ziv buffer. </paragraph>
<paragraph id="P-0106" lvl="0"><number>&lsqb;0106&rsqb;</number> When the occurrence position obtaining unit <highlight><bold>45</bold></highlight> obtains the occurrence position of the same character string as the n-character string immediately before the Ziv buffer, a matching length obtaining unit <highlight><bold>46</bold></highlight> obtains the matching length k between the character string at and after the occurrence position in the Lempel buffer and the character string at and after the start of the Ziv buffer. When the matching length k is obtained, a matching length coding unit <highlight><bold>47</bold></highlight> codes a portion matching the character strings at and after the occurrence position in the character strings at and after the start of the Ziv buffer. </paragraph>
<paragraph id="P-0107" lvl="0"><number>&lsqb;0107&rsqb;</number> On the other hand, when the switch unit <highlight><bold>42</bold></highlight> receives a notification that the occurrence position of the same character string as the n-character string immediately before the Ziv buffer is not stored, it instructs a character-with-context retrieval unit <highlight><bold>48</bold></highlight> to receive the next character from the data to be compressed using the immediately previous character string 0 through (m&minus;1) as a context, and retrieve it from a character-with-context code holding unit <highlight><bold>49</bold></highlight>. The character-with-context code holding unit <highlight><bold>49</bold></highlight> holds a code corresponding to each type of next occurring character using the immediately previous 0 through (m&minus;1)(m&gE;1) character string as a context, When the character-with-context retrieval unit <highlight><bold>48</bold></highlight> retrieves a character with a context, a character-with-context coding unit <highlight><bold>50</bold></highlight> obtains a code corresponding to the character with a context from the character-with-context code holding unit <highlight><bold>49</bold></highlight>. </paragraph>
<paragraph id="P-0108" lvl="0"><number>&lsqb;0108&rsqb;</number> If an n-character string obtained by combining a context having the length of (n&minus;1) with the following character is linked to the occurrence position of the n-character string in the occurrence position holding unit <highlight><bold>43</bold></highlight>, and the length of the context checked by the character-with-context retrieval unit <highlight><bold>48</bold></highlight> is (n&minus;1), then the notification that the occurrence position of the same character string as the n-character string immediately before the Ziv buffer is stored can be provided for the occurrence/non-occurrence check unit <highlight><bold>44</bold></highlight>. </paragraph>
<paragraph id="P-0109" lvl="0"><number>&lsqb;0109&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 9</cross-reference> is a block diagram of the configuration of the data reconstruction apparatus according to the third embodiment of the present invention. </paragraph>
<paragraph id="P-0110" lvl="0"><number>&lsqb;0110&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 9</cross-reference>, an output buffer <highlight><bold>70</bold></highlight> comprises a Lempel buffer for storing an already reconstructed portion of compressed data and a Ziv buffer for storing a portion to be reconstructed of the compressed data. An occurrence position holding unit <highlight><bold>63</bold></highlight> holds a part or all of the occurrence position of an n-character string in the Lempel buffer. </paragraph>
<paragraph id="P-0111" lvl="0"><number>&lsqb;0111&rsqb;</number> An occurrence/non-occurrence check unit <highlight><bold>62</bold></highlight> checks whether or not the occurrence position of the same character string as the n-character string immediately before the Ziv buffer is held by the occurrence position holding unit <highlight><bold>63</bold></highlight>, and notifies a switch unit <highlight><bold>61</bold></highlight> of the check result. When the switch unit <highlight><bold>61</bold></highlight> receives a notification that the occurrence position of the same character string as the n-character string immediately before the Ziv buffer is stored, it instructs an occurrence position obtaining unit <highlight><bold>64</bold></highlight> to obtain the occurrence position of the same character string as the n-character string immediately before the Ziv buffer. </paragraph>
<paragraph id="P-0112" lvl="0"><number>&lsqb;0112&rsqb;</number> When the occurrence position obtaining unit <highlight><bold>64</bold></highlight> obtains the occurrence position of the same character string as the n-character string immediately before the Ziv buffer, a matching length reconstruction unit <highlight><bold>65</bold></highlight> reconstructs the matching length k from an input code. When the matching length k is reconstructed, a copy unit <highlight><bold>66</bold></highlight> copies a character string of the matching length k following the n-character string in the Lempel buffer, and outputs the copy result to the output buffer as the reconstruction result of the code after the n-character string immediately before the Ziv buffer. </paragraph>
<paragraph id="P-0113" lvl="0"><number>&lsqb;0113&rsqb;</number> On the other hand, when the switch unit <highlight><bold>61</bold></highlight> receives a notification that the occurrence position of the same character string as the n-character string immediately before the Ziv buffer is not stored, it instructs a context retrieval unit <highlight><bold>67</bold></highlight> to retrieve a code with the immediately previous 0 through (m&minus;1) character string as a context from a character-with-context code holding unit <highlight><bold>68</bold></highlight>. The character-with-context code holding unit <highlight><bold>68</bold></highlight> holds a code of the next character using the immediately previous 0 through (m&minus;1) character string as a context. A character-with-context reconstruction unit <highlight><bold>69</bold></highlight> reconstructs a character from the code retrieved by the context retrieval unit <highlight><bold>67</bold></highlight>. </paragraph>
<paragraph id="P-0114" lvl="0"><number>&lsqb;0114&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 10</cross-reference> shows the data compressing method according to the fourth embodiment of the present invention. In the fourth embodiment, data to be compressed is coded in the method shown in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>, and a portion not replaced with a matching length is coded by the LZ 78 system. </paragraph>
<paragraph id="P-0115" lvl="0"><number>&lsqb;0115&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 10</cross-reference>, assume that a character string &lsquo;a b a b c d e f a b c d e f g h . . . &rsquo; is input as data to be compressed, and an input number indicating an occurrence position is assigned to each character of the data to be compressed. In addition, assume that n&equals;3, a 3-character string is retrieved from the previously input data, and the currently input data is coded based on the matching length k of the matching portion from the fourth character. </paragraph>
<paragraph id="P-0116" lvl="0"><number>&lsqb;0116&rsqb;</number> In addition, assume that a dictionary <highlight><bold>81</bold></highlight> in which characters &lsquo;a&rsquo; through &lsquo;h&rsquo; are entered is provided, and the characters &lsquo;a&rsquo; through &lsquo;h&rsquo; are respectively assigned the reference numbers 1 through 8. </paragraph>
<paragraph id="P-0117" lvl="0"><number>&lsqb;0117&rsqb;</number> First, when a character &lsquo;a&rsquo; having the input number 1 is entered, a reference number 1 is output as a code corresponding to the character &lsquo;a&rsquo; having the input number 1 by referring to the dictionary <highlight><bold>81</bold></highlight>. Next, when a character &lsquo;b&rsquo; having the input number 2 is entered, a reference number 2 is output as a code corresponding to the character &lsquo;b&rsquo; having the input number 2 by referring to the dictionary <highlight><bold>81</bold></highlight>. A character string &lsquo;a b&rsquo; having the input numbers 1 and 2 is entered in the dictionary <highlight><bold>81</bold></highlight>, and the dictionary <highlight><bold>81</bold></highlight> is updated into a dictionary <highlight><bold>82</bold></highlight>. Then, 9 is entered as a reference number of the character string &lsquo;a b&rsquo;. </paragraph>
<paragraph id="P-0118" lvl="0"><number>&lsqb;0118&rsqb;</number> Next, when a character string &lsquo;a b&rsquo; having the input numbers 3 and 4 is entered, the dictionary <highlight><bold>82</bold></highlight> is referred to, and the reference number 9 is output as a code corresponding to the character string &lsquo;a b&rsquo; having the input numbers 3 and 4. </paragraph>
<paragraph id="P-0119" lvl="0"><number>&lsqb;0119&rsqb;</number> Next, when a character &lsquo;c&rsquo; having the input number 5 is entered, a reference number 3 is output as a code corresponding to the character &lsquo;c&rsquo; having the input number 5 by referring to the dictionary <highlight><bold>82</bold></highlight>. A character string &lsquo;a b c&rsquo; having the input numbers 3 through 5 is entered in the dictionary <highlight><bold>83</bold></highlight>, and 10 is entered as a reference number of the character string &lsquo;a b c&rsquo;. </paragraph>
<paragraph id="P-0120" lvl="0"><number>&lsqb;0120&rsqb;</number> Next, when a character &lsquo;d&rsquo; having the input number 6 is entered, a reference number 4 is output as a code corresponding to the character &lsquo;d&rsquo; having the input number 6 by referring to the dictionary <highlight><bold>82</bold></highlight>. Then, when a character &lsquo;e&rsquo; having the input number 7 is entered, a reference number 5 is output as a code corresponding to the character &lsquo;e&rsquo; having the input number 7 by referring to the dictionary <highlight><bold>82</bold></highlight>. A character string &lsquo;d e&rsquo; is entered in the dictionary <highlight><bold>83</bold></highlight>, and 11 is entered as a reference number. When a character &lsquo;f&rsquo; having the input number 8 is entered, the dictionary <highlight><bold>82</bold></highlight> is referred to, and the reference number 6 is output as a code corresponding to the character &lsquo;f &rsquo; having the input number 8. Then, a character string &lsquo;e f&rsquo; is entered in the dictionary <highlight><bold>83</bold></highlight>, and 12 is entered as a reference number. </paragraph>
<paragraph id="P-0121" lvl="0"><number>&lsqb;0121&rsqb;</number> Next, when a character string &lsquo;a b c&rsquo; having the input numbers 9 through 11 is input, the character string &lsquo;a b c&rsquo; having the input numbers 9 through 11 is coded using the reference number 10 entered in the dictionary <highlight><bold>83</bold></highlight>. The character string &lsquo;a b c&rsquo; having the input numbers 9 through 11 matches the previous character string &lsquo;a b c&rsquo; having the input numbers 3 through 5, and n&equals;3, the character strings having the input numbers equal to and larger than 12 are coded based on the matching length with the character strings having the input numbers equal to and larger than 6. As a result, the character string &lsquo;d e f&rsquo; having the input numbers 6 through 8 matches the character string &lsquo;d e f&rsquo; having the input numbers 12 through 14, and the matching length k is equal to 3. Therefore, the character string &lsquo;d e f&rsquo; having the input numbers 12 through 14 is coded based on the matching length of 3. </paragraph>
<paragraph id="P-0122" lvl="0"><number>&lsqb;0122&rsqb;</number> When a character &lsquo;g&rsquo; having the input number 15 is input, it does not match any of the previously input characters. Therefore, the dictionary <highlight><bold>83</bold></highlight> is referred to, and the reference number 7 is output as a code corresponding to the character &lsquo;g&rsquo; having the input number 15. Next, when a character &lsquo;h&rsquo; having the input number 16 is input, it does not match any of the previously input characters. Therefore, the dictionary <highlight><bold>83</bold></highlight> is referred to, and the reference number 8 is output as a code corresponding to the character &lsquo;h&rsquo; having the input number 16. </paragraph>
<paragraph id="P-0123" lvl="0"><number>&lsqb;0123&rsqb;</number> Thus, an initial dictionary has all characters that possibly occur and are assigned respective codes, and the characters are sequentially coded and entered in the dictionary to output a code which is assigned to characters/character strings entered in the dictionary and match each other based on the longest matching length (LZ78 code). In addition, when the same character string as the previous n-character string occurs (point 3), the matching length at and after the (n&plus;1) character string is coded and output, and then back to the LZ78 code. By processing the matching starting portion as the character string as is, and coding it by the LZ 78 system or the probability statistic type coding system, a code indicating whether or not the subsequent code is a matching length code is not required. As a result, a high compression rate can be attained using a matching length code for a repetition of long character strings while a high compression rate by the LZ78 system and the probability statistic type coding system can be utilized as is for a repetition of short character strings. </paragraph>
<paragraph id="P-0124" lvl="0"><number>&lsqb;0124&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 11</cross-reference> is a block diagram of the configuration of the data compression apparatus according to the fourth embodiment of the present invention </paragraph>
<paragraph id="P-0125" lvl="0"><number>&lsqb;0125&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 11</cross-reference>, an input buffer <highlight><bold>91</bold></highlight> comprises a Lempel buffer for storing an already compressed portion of the data to be compressed; and a Ziv buffer for storing a portion to be compressed of the data to be compressed. An occurrence position holding unit <highlight><bold>93</bold></highlight> stores a part or all of the occurrence position of the n-character string in the Lempel buffer. </paragraph>
<paragraph id="P-0126" lvl="0"><number>&lsqb;0126&rsqb;</number> An occurrence/non-occurrence check unit <highlight><bold>94</bold></highlight> checks whether or not the occurrence position of the same character string as the n-character string immediately before the Ziv buffer is stored in the occurrence position holding unit <highlight><bold>93</bold></highlight>, and notifies a switch unit <highlight><bold>92</bold></highlight> of the check result. When the switch unit <highlight><bold>92</bold></highlight> receives a notification that the occurrence position of the same character string as the n-character string immediately before the Ziv buffer is stored, it instructs an occurrence position obtaining unit <highlight><bold>95</bold></highlight> to obtain the occurrence position of the same character string as the n-character string immediately before the Ziv buffer. </paragraph>
<paragraph id="P-0127" lvl="0"><number>&lsqb;0127&rsqb;</number> When the occurrence position obtaining unit <highlight><bold>95</bold></highlight> obtains the occurrence position of the same character string as the n-character string immediately before the Ziv buffer, a matching length obtaining unit <highlight><bold>96</bold></highlight> obtains the matching length k between the character string at and after the occurrence position in the Lempel buffer and the character string at and after the start of the Ziv buffer. When the matching length k is obtained, a matching length coding unit <highlight><bold>97</bold></highlight> codes a portion matching the character strings at and after the occurrence position in the character strings at and after the start of the Ziv buffer. </paragraph>
<paragraph id="P-0128" lvl="0"><number>&lsqb;0128&rsqb;</number> When a character/character string holding unit <highlight><bold>99</bold></highlight> holds a code corresponding to a character or a character string having the length of 1 through m, and the switch unit <highlight><bold>92</bold></highlight> receives a notification that the occurrence position of the same character as the n-character string immediately before the Ziv buffer is not held, it instructs a character/character string retrieval unit <highlight><bold>98</bold></highlight> to retrieve a character or a character string matching the data to be compressed based on the longest matching length from the character or the character string hold in the character/character string holding unit <highlight><bold>99</bold></highlight>. A character/character string coding unit <highlight><bold>100</bold></highlight> then codes the character or the character string retrieved by the character/character string retrieval unit <highlight><bold>98</bold></highlight> using the code held by the character/character string holding unit <highlight><bold>99</bold></highlight>. </paragraph>
<paragraph id="P-0129" lvl="0"><number>&lsqb;0129&rsqb;</number> If the character string having the length of n held in the character/character string holding unit <highlight><bold>99</bold></highlight> is linked to the occurrence position of the n-character string in the occurrence position holding unit <highlight><bold>93</bold></highlight>, and the length of the character or the character string coded by the character/character string coding unit <highlight><bold>100</bold></highlight> is n, then the occurrence/nonoccurrence check unit <highlight><bold>94</bold></highlight> can be informed that the occurrence position of the same character string as the n-character string immediately before the Ziv buffer is held. </paragraph>
<paragraph id="P-0130" lvl="0"><number>&lsqb;0130&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 12</cross-reference> is a block diagram of the configuration of the data reconstruction apparatus according to the fourth embodiment of the present invention. </paragraph>
<paragraph id="P-0131" lvl="0"><number>&lsqb;0131&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 12</cross-reference>, an output buffer <highlight><bold>119</bold></highlight> comprises a Lempel buffer for storing an already reconstructed portion of compressed data and a Ziv buffer for storing a portion to be reconstructed of the compressed data. An occurrence position holding unit <highlight><bold>113</bold></highlight> holds a part or all of the occurrence position of an n-character string in the Lempel buffer. </paragraph>
<paragraph id="P-0132" lvl="0"><number>&lsqb;0132&rsqb;</number> An occurrence/non-occurrence check unit <highlight><bold>112</bold></highlight> checks whether or not the occurrence position of the same character string as the n-character string immediately before the Ziv buffer is held by the occurrence position holding unit <highlight><bold>113</bold></highlight>, and notifies a switch unit <highlight><bold>111</bold></highlight> of the check result. When the switch unit <highlight><bold>111</bold></highlight> receives a notification that the occurrence position of the same character string as the n-character string immediately before the Ziv buffer is stored, it instructs an occurrence position obtaining unit <highlight><bold>114</bold></highlight> to obtain the occurrence position of the same character string as the n-character string immediately before the Ziv buffer. </paragraph>
<paragraph id="P-0133" lvl="0"><number>&lsqb;0133&rsqb;</number> When the occurrence position obtaining unit <highlight><bold>114</bold></highlight> obtains the occurrence position of the same character string as the n-character string immediately before the Ziv buffer, a matching length reconstruction unit <highlight><bold>115</bold></highlight> reconstructs the matching length k from an input code. When the matching length k is reconstructed, a copy unit <highlight><bold>116</bold></highlight> copies a character string of the matching length k following the n-character string in the Lempel buffer, and outputs the copy result to the output buffer <highlight><bold>119</bold></highlight> as the reconstruction result of the code after the n-character string immediately before the Ziv buffer. </paragraph>
<paragraph id="P-0134" lvl="0"><number>&lsqb;0134&rsqb;</number> When a character/character string holding unit <highlight><bold>117</bold></highlight> holds a code corresponding to a character or a character string having the length of 1 through m, and the switch unit <highlight><bold>111</bold></highlight> receives a notification that the occurrence position of the same character as the n-character string immediately before the Ziv buffer is not held, it instructs a character/character string reconstruction unit <highlight><bold>118</bold></highlight> to reconstruct a character or a character string based on the code held by the character/character string code holding unit <highlight><bold>117</bold></highlight>. </paragraph>
<paragraph id="P-0135" lvl="0"><number>&lsqb;0135&rsqb;</number> Thus, if the occurrence position holding unit <highlight><bold>113</bold></highlight> does not hold the immediately previous n-character string, it is not output as is, but is coded by the probability statistic type coding system or the LZ78 system. As a result, a high compression rate of the LZ78 system or the probability statistic type coding system can be obtained for a repetition of short character strings in a data string to be compressed, and a high compression rate can be obtained based on a matching length code for a repetition of long character strings. </paragraph>
<paragraph id="P-0136" lvl="0"><number>&lsqb;0136&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 13A</cross-reference> shows the coding method according to the fifth embodiment of the present invention. </paragraph>
<paragraph id="P-0137" lvl="0"><number>&lsqb;0137&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 13A, a</cross-reference> first coding process <highlight><bold>121</bold></highlight> is performed on input data, and then a second coding process <highlight><bold>122</bold></highlight> is performed on the input data, thereby performing a 2-step coding process on the input data. </paragraph>
<paragraph id="P-0138" lvl="0"><number>&lsqb;0138&rsqb;</number> In this example, the first coding process <highlight><bold>121</bold></highlight> codes a part of a matching symbol string based on a matching length, and the second coding process <highlight><bold>122</bold></highlight> furthermore codes by the probability statistic type coding system the symbol string coded in the first coding process <highlight><bold>121</bold></highlight>. In addition, as a probability statistic type code, a Shannon Fanno code, a Huffman code, an arithmetic code, a Jones code, an adaptive Huffman code, an adaptive arithmetic code, a code using a context model, etc. can be used. </paragraph>
<paragraph id="P-0139" lvl="0"><number>&lsqb;0139&rsqb;</number> Furthermore, the first coding process <highlight><bold>121</bold></highlight> codes a part of a matching symbol string based on a matching length, and the second coding process <highlight><bold>122</bold></highlight> furthermore codes by the dictionary type coding system the symbol string coded in the first coding process <highlight><bold>121</bold></highlight>. In addition, as a dictionary type code, an LZ78 code, an LZW code, an LZC code, an LZY code, an LZT code, an LZFG code, etc. can be used. </paragraph>
<paragraph id="P-0140" lvl="0"><number>&lsqb;0140&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 13B</cross-reference> shows the decoding method according to the fifth embodiment of the present invention. </paragraph>
<paragraph id="P-0141" lvl="0"><number>&lsqb;0141&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 13B, a</cross-reference> first decoding process <highlight><bold>123</bold></highlight> is performed on coded data, and then a second decoding process <highlight><bold>124</bold></highlight> is performed on the coded data, thereby performing a 2-step decoding process on coded data. </paragraph>
<paragraph id="P-0142" lvl="0"><number>&lsqb;0142&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 14</cross-reference> is a block diagram of the configuration of the data compression apparatus according to the sixth embodiment of the present invention. In this sixth embodiment, data to be compressed is coded by the method shown in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, and the data coded by the method shown in <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is furthermore coded by the probability statistic type coding system using a context. </paragraph>
<paragraph id="P-0143" lvl="0"><number>&lsqb;0143&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 14</cross-reference>, an input buffer <highlight><bold>131</bold></highlight> comprises a Lempel buffer for storing an already compressed portion of the data to be compressed; and a Ziv buffer for storing a portion to be compressed of the data to be compressed. An occurrence position holding unit <highlight><bold>133</bold></highlight> stores a part or all of the occurrence position of the n-character string in the Lempel buffer. </paragraph>
<paragraph id="P-0144" lvl="0"><number>&lsqb;0144&rsqb;</number> An occurrence/non-occurrence check unit <highlight><bold>134</bold></highlight> checks whether or not the occurrence position of the same character string as the n-character string immediately before the Ziv buffer is stored in the occurrence position holding unit <highlight><bold>133</bold></highlight>, and notifies a switch unit <highlight><bold>132</bold></highlight> of the check result. When the switch unit <highlight><bold>132</bold></highlight> receives a notification that the occurrence position of the same character string as the n-character string immediately before the Ziv buffer is stored, it instructs an occurrence position obtaining unit <highlight><bold>135</bold></highlight> to obtain the occurrence position of the same character string as the n-character string immediately before the Ziv buffer. </paragraph>
<paragraph id="P-0145" lvl="0"><number>&lsqb;0145&rsqb;</number> When the occurrence position obtaining unit <highlight><bold>135</bold></highlight> obtains the occurrence position of the same character string as the n-character string immediately before the Ziv buffer, a matching length obtaining unit <highlight><bold>136</bold></highlight> obtains the matching length k between the character string at and after the occurrence position in the Lempel buffer and the character string at and after the start of the Ziv buffer. When the matching length k is obtained, a matching length coding unit <highlight><bold>137</bold></highlight> codes a portion matching the character strings at and after the occurrence position in the character strings at and after the start of the Ziv buffer, and outputs the result to an intermediate buffer <highlight><bold>138</bold></highlight>. </paragraph>
<paragraph id="P-0146" lvl="0"><number>&lsqb;0146&rsqb;</number> When the switch unit <highlight><bold>132</bold></highlight> receives a notification that the occurrence position of the same character as the n-character string immediately before the Ziv buffer is not held, it outputs the character string at and after the start of the Ziv buffer as is to the intermediate buffer <highlight><bold>138</bold></highlight>. </paragraph>
<paragraph id="P-0147" lvl="0"><number>&lsqb;0147&rsqb;</number> The intermediate buffer <highlight><bold>138</bold></highlight> holds a code indicating the matching length transmitted from the matching length coding unit <highlight><bold>137</bold></highlight>, and holds the data to be compressed and transmitted from the switch unit <highlight><bold>132</bold></highlight>. </paragraph>
<paragraph id="P-0148" lvl="0"><number>&lsqb;0148&rsqb;</number> A character-with-context code holding unit <highlight><bold>139</bold></highlight> stores a code of a character occurring next using the immediately previous character string 0 through (m&minus;1) as a context. A character-with-context retrieval unit <highlight><bold>140</bold></highlight> retrieves the subsequent character from the character-with-context code holding unit <highlight><bold>139</bold></highlight> using the immediately previous character string 0 through (m&minus;1). When the character-with-context retrieval unit <highlight><bold>140</bold></highlight> retrieves a character with a context, a character-with-context coding unit <highlight><bold>141</bold></highlight> codes the character with a context based on the code held in the character-with-context code holding unit <highlight><bold>139</bold></highlight>. </paragraph>
<paragraph id="P-0149" lvl="0"><number>&lsqb;0149&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 15</cross-reference> is a block diagram of the configuration of the data reconstruction apparatus according to the sixth embodiment of the present invention. </paragraph>
<paragraph id="P-0150" lvl="0"><number>&lsqb;0150&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 15, a</cross-reference> character-with-context code holding unit <highlight><bold>151</bold></highlight> stores a code of a character occurring next using the immediately previous character string <highlight><bold>0</bold></highlight> through (m&minus;1) as a context. A context retrieval unit <highlight><bold>152</bold></highlight> retrieves a code having the immediately previous character string 0 through (m&minus;1) as a context from the character-with-context code holding unit <highlight><bold>151</bold></highlight> using the immediately previous character string 0 through (m&minus;1). A character-with-context reconstruction unit <highlight><bold>153</bold></highlight> reconstructs a character from the code retrieved by the character-with-context code holding unit <highlight><bold>151</bold></highlight>. </paragraph>
<paragraph id="P-0151" lvl="0"><number>&lsqb;0151&rsqb;</number> An intermediate buffer <highlight><bold>154</bold></highlight> holds the data reconstructed by the character-with-context reconstruction unit <highlight><bold>153</bold></highlight>. An output buffer <highlight><bold>161</bold></highlight> comprises a Lempel buffer storing an already reconstructed portion of input data held in the intermediate buffer <highlight><bold>154</bold></highlight>; and a Ziv buffer storing a portion to be reconstructed of input data held in the intermediate buffer <highlight><bold>154</bold></highlight>. An occurrence position holding unit <highlight><bold>157</bold></highlight> holds a part or all of the occurrence position of the n-character string in the Lempel buffer. </paragraph>
<paragraph id="P-0152" lvl="0"><number>&lsqb;0152&rsqb;</number> An occurrence/non-occurrence check unit <highlight><bold>156</bold></highlight> checks whether or not the occurrence position of the same character string as the n-character string immediately before the Ziv buffer is stored in the occurrence position holding unit <highlight><bold>157</bold></highlight>, and notifies a switch unit <highlight><bold>155</bold></highlight> of the check result. When the switch unit <highlight><bold>155</bold></highlight> receives a notification that the occurrence position of the same character string as the n-character string immediately before the Ziv buffer is stored, it instructs an occurrence position obtaining unit <highlight><bold>158</bold></highlight> to obtain the occurrence position of the same character string as the n-character string immediately before the Ziv buffer. </paragraph>
<paragraph id="P-0153" lvl="0"><number>&lsqb;0153&rsqb;</number> When the occurrence position obtaining unit <highlight><bold>158</bold></highlight> obtains the occurrence position of the same character string as the n-character string immediately before the Ziv buffer, a matching length reconstruction unit <highlight><bold>159</bold></highlight> reconstructs the matching length k from the code held in the intermediate buffer <highlight><bold>154</bold></highlight>. When the matching length k is reconstructed, a copy unit <highlight><bold>160</bold></highlight> copies a character string of the matching length k following the n-character string in the Lempel buffer, and outputs the copy result to the output buffer <highlight><bold>161</bold></highlight> as a result of reconstructing the code after the n-character string immediately before the Ziv buffer. </paragraph>
<paragraph id="P-0154" lvl="0"><number>&lsqb;0154&rsqb;</number> On the other hand, when the switch unit <highlight><bold>155</bold></highlight> receives a notification that the occurrence position of the same character string as the n-character string immediately before the Ziv buffer is not held, it outputs the character string in the intermediate buffer <highlight><bold>154</bold></highlight> as is. </paragraph>
<paragraph id="P-0155" lvl="0"><number>&lsqb;0155&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 16</cross-reference> is a block diagram of the configuration of the data compression apparatus according to the seventh embodiment of the present invention. According to the seventh embodiment, data to be compressed is coded in the method shown in <cross-reference target="DRAWINGS">FIG. 4</cross-reference>, and the data coded in the method shown in <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is furthermore coded by the LZ78 system. </paragraph>
<paragraph id="P-0156" lvl="0"><number>&lsqb;0156&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 16</cross-reference>, an input buffer <highlight><bold>171</bold></highlight> comprises a Lempel buffer for storing an already compressed portion of the data to be compressed; and a Ziv buffer for storing a portion to be compressed of the data to be compressed. An occurrence position holding unit <highlight><bold>173</bold></highlight> stores a part or all of the occurrence position of the n-character string in the Lempel buffer. </paragraph>
<paragraph id="P-0157" lvl="0"><number>&lsqb;0157&rsqb;</number> An occurrence/non-occurrence check unit <highlight><bold>174</bold></highlight> checks whether or not the occurrence position of the same character string as the n-character string immediately before the Ziv buffer is stored in the occurrence position holding unit <highlight><bold>173</bold></highlight>, and notifies a switch unit <highlight><bold>172</bold></highlight> of the check result. When the switch unit <highlight><bold>172</bold></highlight> receives a notification that the occurrence position of the same character string as the n-character string immediately before the Ziv buffer is stored, it instructs an occurrence position obtaining unit <highlight><bold>175</bold></highlight> to obtain the occurrence position of the same character string as the n-character string immediately before the Ziv buffer. </paragraph>
<paragraph id="P-0158" lvl="0"><number>&lsqb;0158&rsqb;</number> When the occurrence position obtaining unit <highlight><bold>175</bold></highlight> obtains the occurrence position of the same character string as the n-character string immediately before the Ziv buffer, a matching length obtaining unit <highlight><bold>176</bold></highlight> obtains the matching length k between the character string at and after the occurrence position in the Lempel buffer and the character string at and after the start of the Ziv buffer. When the matching length k is obtained, a matching length coding unit <highlight><bold>177</bold></highlight> codes the portion matching with the character strings at and after the occurrence position in the character strings at and after the start of the Ziv buffer, and outputs the result to an intermediate buffer <highlight><bold>178</bold></highlight>. </paragraph>
<paragraph id="P-0159" lvl="0"><number>&lsqb;0159&rsqb;</number> When the switch unit <highlight><bold>172</bold></highlight> receives a notification that the occurrence position of the same character as the n-character string immediately before the Ziv buffer is not held, it outputs the character string at and after the start of the Ziv buffer as is to the intermediate buffer <highlight><bold>178</bold></highlight>. </paragraph>
<paragraph id="P-0160" lvl="0"><number>&lsqb;0160&rsqb;</number> The intermediate buffer <highlight><bold>178</bold></highlight> holds a code indicating the matching length transmitted from the matching length coding unit <highlight><bold>177</bold></highlight>, and holds the data to be compressed and transmitted from the switch unit <highlight><bold>172</bold></highlight>. </paragraph>
<paragraph id="P-0161" lvl="0"><number>&lsqb;0161&rsqb;</number> A character/character string holding unit <highlight><bold>179</bold></highlight> holds a code corresponding to a character or a character string having the length of 1 through m, and a character/character string retrieval unit <highlight><bold>180</bold></highlight> retrieves a character or a character string matching in longest length with the data stored in the intermediate buffer <highlight><bold>178</bold></highlight> from the characters or character strings stored in the character/character string code holding unit <highlight><bold>179</bold></highlight>. </paragraph>
<paragraph id="P-0162" lvl="0"><number>&lsqb;0162&rsqb;</number> A character/character string coding unit <highlight><bold>181</bold></highlight> codes the character or character string retrieved by the character/character string retrieval unit <highlight><bold>180</bold></highlight> according to the code held in the character/character string code holding unit <highlight><bold>179</bold></highlight>. </paragraph>
<paragraph id="P-0163" lvl="0"><number>&lsqb;0163&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 17</cross-reference> is a block diagram of the configuration of the data reconstruction apparatus according to the seventh embodiment of the present invention. </paragraph>
<paragraph id="P-0164" lvl="0"><number>&lsqb;0164&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 17, a</cross-reference> character/character string code holding unit <highlight><bold>191</bold></highlight> holds a code corresponding to a character or a character string having the length of 1 through m, and a character/character string reconstruction unit <highlight><bold>192</bold></highlight> reconstructs a character or a character string according to a code held in the character/character string code holding unit <highlight><bold>191</bold></highlight>. An intermediate buffer <highlight><bold>193</bold></highlight> holds the data reconstructed by the character/character string reconstruction unit <highlight><bold>192</bold></highlight>. </paragraph>
<paragraph id="P-0165" lvl="0"><number>&lsqb;0165&rsqb;</number> An output buffer <highlight><bold>200</bold></highlight> comprises a Lempel buffer storing an already reconstructed portion of input data held in the intermediate buffer <highlight><bold>193</bold></highlight>; and a Ziv buffer storing a portion to be reconstructed of input data held in the intermediate buffer <highlight><bold>193</bold></highlight>. An occurrence position holding unit <highlight><bold>196</bold></highlight> holds a part or all of the occurrence position of the n-character string in the Lempel buffer. </paragraph>
<paragraph id="P-0166" lvl="0"><number>&lsqb;0166&rsqb;</number> An occurrence/non-occurrence check unit <highlight><bold>195</bold></highlight> checks whether or not the occurrence position of the same character string as the n-character string immediately before the Ziv buffer is stored in the occurrence position holding unit <highlight><bold>196</bold></highlight>, and notifies a switch unit <highlight><bold>194</bold></highlight> of the check result. When the switch unit <highlight><bold>194</bold></highlight> receives a notification that the occurrence position of the same character string as the n-character string immediately before the Ziv buffer is stored, it instructs an occurrence position obtaining unit <highlight><bold>197</bold></highlight> to obtain the occurrence position of the same character string as the n-character string immediately before the Ziv buffer. </paragraph>
<paragraph id="P-0167" lvl="0"><number>&lsqb;0167&rsqb;</number> When the occurrence position obtaining unit <highlight><bold>197</bold></highlight> obtains the occurrence position of the same character string as the n-character string immediately before the Ziv buffer, a matching length reconstruction unit <highlight><bold>198</bold></highlight> reconstructs the matching length k from the code held in the intermediate buffer <highlight><bold>193</bold></highlight>. When the matching length k is reconstructed, a copy unit <highlight><bold>199</bold></highlight> copies a character string of the matching length k following the n-character string in the Lempel buffer, and outputs the copy result to the output buffer <highlight><bold>200</bold></highlight> as a result of reconstructing the code after the n-character string immediately before the Ziv buffer. </paragraph>
<paragraph id="P-0168" lvl="0"><number>&lsqb;0168&rsqb;</number> On the other hand, when the switch unit <highlight><bold>194</bold></highlight> receives a notification that the occurrence position of the same character string as the n-character string immediately before the Ziv buffer is not held, it outputs the character string in the intermediate buffer <highlight><bold>193</bold></highlight> as is. </paragraph>
<paragraph id="P-0169" lvl="0"><number>&lsqb;0169&rsqb;</number> Thus, when an immediately previous n-character string is held by an occurrence position holding unit <highlight><bold>196</bold></highlight>, the data coded based on a matching length is temporarily held in the intermediate buffer <highlight><bold>193</bold></highlight>, and is further coded by the probability statistic type coding system or the LZ78 system, thereby effectively assigning a code to a long character string using the existing compression application as is. </paragraph>
<paragraph id="P-0170" lvl="0"><number>&lsqb;0170&rsqb;</number> A code used in the probability statistic type coding system or the LZ78 system can be obtained in a static coding process in which a predetermined code is used from start to end, or in a dynamic coding process in which codes are sequentially updated based on coded data. </paragraph>
<paragraph id="P-0171" lvl="0"><number>&lsqb;0171&rsqb;</number> As described above, according to the above described embodiment, a code indicating whether or not the following code is a matching length code is not required. Furthermore, based on the LZ78 system and the probability statistic type coding system, a matching length between the current and previous character strings can be output as a code as in the LZ77 system only when long character strings are repeated. Therefore, a high compression rate can be attained using a matching length code when long character strings are repeated while a high compression rate can also be attained by the LZ78 system or the probability statistic type coding system for a repetition of short character strings, thereby successfully obtaining a high compression rate for both short and long character strings. </paragraph>
<paragraph id="P-0172" lvl="0"><number>&lsqb;0172&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 18</cross-reference> is a block diagram of the configuration of the coding apparatus according to the eighth embodiment of the present invention. According to the embodiment shown in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>, when the same symbol string occurred previously, the following symbol string is coded by a matching length code. In this case, the time taken in the coding process is mainly occupied by the retrieval of the occurrence position of the previous symbol string having the length of n. Therefore, in the eighth embodiment of the present invention, the occurrence position of a previous symbol string having the length of n is coded and stored, and then obtained based on the storage result. Thus, the time taken to retrieve the previous occurrence position of the symbol string having the length of n can be shortened. </paragraph>
<paragraph id="P-0173" lvl="0"><number>&lsqb;0173&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 18</cross-reference>, an occurrence position storage unit <highlight><bold>211</bold></highlight> codes and stores the occurrence position of an input symbol string. An occurrence position retrieval unit <highlight><bold>212</bold></highlight> checks whether or not the code corresponding to the first symbol string having a predetermined length of n is stored in the occurrence position storage unit <highlight><bold>211</bold></highlight>. If the code is stored, the occurrence position of the second symbol string associated with the code is obtained. It is not necessary that the first symbol string always matches the second symbol string. That is, the first symbol string can be different from the second symbol string if the occurrence position of the second symbol string can be specified from the first symbol string. However, a higher compression rate can be obtained when the first symbol string matches the second symbol string. That is, when the first symbol string matches the second symbol string, there is a higher probability that a longer matching length k can be obtained between the third symbol string following the first symbol string and the fourth symbol string following the second symbol string. </paragraph>
<paragraph id="P-0174" lvl="0"><number>&lsqb;0174&rsqb;</number> When the occurrence position of the second symbol string is detected, a matching length detection unit <highlight><bold>213</bold></highlight> detects the matching length k between the fourth symbol string and the third symbol string by comparing the fourth symbol string following the second symbol string with the third symbol string following the first symbol string. When the matching length k is detected, a matching length coding unit <highlight><bold>214</bold></highlight> codes the third symbol string based on the matching length k. </paragraph>
<paragraph id="P-0175" lvl="0"><number>&lsqb;0175&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 19</cross-reference> shows the coding method according to the eighth embodiment of the present invention. </paragraph>
<paragraph id="P-0176" lvl="0"><number>&lsqb;0176&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 19</cross-reference>, when input data is entered, a hash code is assigned to the symbol string having the length n, and the occurrence position of the symbol string is stored in a storage unit <highlight><bold>215</bold></highlight>. In this example, assume that a hash code B is assigned to the previous second symbol string having the length n, and the occurrence position A of the second symbol string is stored in the storage unit <highlight><bold>215</bold></highlight> corresponding to the hash code B. </paragraph>
<paragraph id="P-0177" lvl="0"><number>&lsqb;0177&rsqb;</number> Next, when the first symbol string having the length n is input, a hash code corresponding to the first symbol string is generated, and it is checked whether or not a hash code corresponding to the first symbol string is stored in the storage unit <highlight><bold>215</bold></highlight>. Assume that a hash code B is assigned to the first symbol string, the occurrence position A stored corresponding to the hash code B is read from the storage unit <highlight><bold>215</bold></highlight>. When the occurrence position A is obtained, a matching length k between the third symbol string following the first symbol string and the fourth symbol string at and after the occurrence position A is obtained, and the third symbol string is coded based on the matching length k. </paragraph>
<paragraph id="P-0178" lvl="0"><number>&lsqb;0178&rsqb;</number> The first and second symbol strings are used to specify the position of the fourth symbol string for use in coding the third symbol string based on the matching length k. Thus, the position of the fourth symbol string for use in coding the third symbol string based on the matching length k should be specified using the first and second symbol strings. Therefore, the first and second symbol strings do not always have to match each other. </paragraph>
<paragraph id="P-0179" lvl="0"><number>&lsqb;0179&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 20</cross-reference> shows the data compressing method according to the ninth embodiment of the present invention. In the ninth embodiment, a hash code is generated from the three characters immediately before the character string to be coded, and the occurrence position of the previous character string for use in comparison is obtained from the generated hash code. </paragraph>
<paragraph id="P-0180" lvl="0"><number>&lsqb;0180&rsqb;</number> Assume that a character string &lsquo;a b c d e f a b q a a b c d a a b d e a b c d a a a q . . . &rsquo; is input as data to be compressed, and the portion &lsquo;a b c d e f a b q a a b c d a a b d e a b c&rsquo; has already been coded as shown in <cross-reference target="DRAWINGS">FIG. 20</cross-reference>. In this case, a hash code is generated from the three characters in a window <highlight><bold>221</bold></highlight> in the already coded character string, and the occurrence position of the three-character strings is stored in a storage unit <highlight><bold>226</bold></highlight>. For example, assume that, corresponding to a character string <highlight><bold>222</bold></highlight> &lsquo;a b c&rsquo;, a hash code B is generated by a hash code generation unit <highlight><bold>224</bold></highlight>, and an occurrence position A is stored in the storage unit <highlight><bold>226</bold></highlight> corresponding to the hash code B. </paragraph>
<paragraph id="P-0181" lvl="0"><number>&lsqb;0181&rsqb;</number> Next, to code the character string &lsquo;d a a a q . . . &rsquo; after the already coded character string, a 3-character string <highlight><bold>223</bold></highlight> &lsquo;a b c&rsquo; immediately before the character string &lsquo;d a a a q . . . &rsquo; to be coded is observed, and a hash code of the 3-character string <highlight><bold>223</bold></highlight> &lsquo;a b c&rsquo; is obtained. In this example, since the 3-character string &lsquo;a b c&rsquo; is assigned the hash code B, the hash code B is generated as a hash code of the 3-character string <highlight><bold>223</bold></highlight> &lsquo;a b c&rsquo;. </paragraph>
<paragraph id="P-0182" lvl="0"><number>&lsqb;0182&rsqb;</number> Next, it is checked whether or not the hash code B is stored in the storage unit <highlight><bold>226</bold></highlight>. If the hash code B is stored in the storage unit <highlight><bold>226</bold></highlight>, then the occurrence position corresponding to the hash code B is obtained. In this example, since the hash code B has already been stored in the storage unit <highlight><bold>226</bold></highlight>, the occurrence position A is obtained as the occurrence position of the previous 3-character string <highlight><bold>222</bold></highlight> corresponding to the 3-character string <highlight><bold>223</bold></highlight> &lsquo;a b c&rsquo;. When the occurrence position A is obtained, the character string &lsquo;d a a a q . . . &rsquo; to be coded is compared with the character string &lsquo;d a a b d e a b c&rsquo; after the occurrence position A to obtain the matching length between these character strings. Since the 3-character strings &lsquo;d a a&rsquo; match, the matching length is 3. When the matching length of 3 is obtained, the portion &lsquo;d a a&rsquo; which is a character string to be coded is coded based on the matching length of 3. </paragraph>
<paragraph id="P-0183" lvl="0"><number>&lsqb;0183&rsqb;</number> Thus, the time required to retrieve the previous occurrence position of the character string <highlight><bold>222</bold></highlight> can be shortened by storing the previous occurrence position of the character string <highlight><bold>222</bold></highlight> in association with the hash code B, and obtaining the previous occurrence position of the character string <highlight><bold>222</bold></highlight> corresponding to the character string <highlight><bold>223</bold></highlight> through the hash retrieval. </paragraph>
<paragraph id="P-0184" lvl="0"><number>&lsqb;0184&rsqb;</number> In the hash retrieval, there are a plurality of character strings for which the same hash codes are allocated. That is, the character string at the previous occurrence position associated with a hash code can be different from the character string for which the hash code is originally generated (generating the same hash codes from different character strings is referred to as a conflict). Therefore, when the hash retrieval is performed, the original key is normally checked for matching. However, according to the embodiment, the hash retrieval is performed as a key for use in determining whether or not the subsequent character string is to be coded using a matching length code. Since the character string used in the hash retrieval is not contained in the matching length code, it is not necessary that the character string matches the original key. Therefore, the present invention improves the processing speed not only by the hash retrieval but also by omitting a matching check. </paragraph>
<paragraph id="P-0185" lvl="0"><number>&lsqb;0185&rsqb;</number> However, the compression rate is higher when the character string matches the original key. Therefore, a matching check can be made for the previous p characters. For example, the length n of the previous character string for use in generating a hash code can be 3 characters, and the length p of the previous character string for use in a matching check for a conflict in the hash can be 2 characters. </paragraph>
<paragraph id="P-0186" lvl="0"><number>&lsqb;0186&rsqb;</number> In addition, different hash codes can be assigned to different character strings to prevent a conflict. </paragraph>
<paragraph id="P-0187" lvl="0"><number>&lsqb;0187&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 21</cross-reference> is a flowchart of the data compressing method according to the tenth embodiment of the present invention. According to the tenth embodiment of the present invention, the occurrence position of the previous character string corresponding to the character string to be coded based on a matching length is obtained by the hash retrieval. If the hash retrieval fails, the character string is coded by a statistic type code or an LZ78 code. </paragraph>
<paragraph id="P-0188" lvl="0"><number>&lsqb;0188&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 21</cross-reference>, an array address at which the occurrence position of a previous n-character string is hash-coded and stored is initialized (step S<highlight><bold>1</bold></highlight>). Next, a hash code of the n-character string immediately before the character string to be coded is generated (step S<highlight><bold>2</bold></highlight>), and it is checked whether or not the occurrence position corresponding to the hash code is stored at the array address (step S<highlight><bold>3</bold></highlight>). If the occurrence position corresponding to the hash code is stored at the array address, then the occurrence position of the previous n-character string corresponding to the n-character string immediately before the character string to be coded is obtained from the array address. Then, the matching length of the character string after the n-character string is checked, and the character string to be coded is coded based on the matching length (step S<highlight><bold>4</bold></highlight>). </paragraph>
<paragraph id="P-0189" lvl="0"><number>&lsqb;0189&rsqb;</number> On the other hand, if the occurrence position corresponding to the hash code is not stored at an array address, then the character or the character string to be coded is coded by a statistic type code or an LZ78 code (step S<highlight><bold>5</bold></highlight>). </paragraph>
<paragraph id="P-0190" lvl="0"><number>&lsqb;0190&rsqb;</number> Then, corresponding to the hash code of the n-character string immediately before the coded character string, the occurrence position of the n-character string is stored at an array address (step S<highlight><bold>6</bold></highlight>). Then, it is determined whether or not the coding process has been completed to the end of the input data (step S<highlight><bold>7</bold></highlight>). If the coding process has not been completed, then control is returned to step S<highlight><bold>2</bold></highlight>, and the above described processes are repeated. </paragraph>
<paragraph id="P-0191" lvl="0"><number>&lsqb;0191&rsqb;</number> Thus, the time required to retrieve a character string can be shortened by hash-retrieving the occurrence position of the previous character string corresponding to the character string to be coded based on a matching length, thereby realizing a processing speed at a practical level. </paragraph>
<paragraph id="P-0192" lvl="0"><number>&lsqb;0192&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 22</cross-reference> is a flowchart of the data compressing method according to the eleventh embodiment of the present invention. According to the embodiment shown in <cross-reference target="DRAWINGS">FIG. 21, a</cross-reference> coding process is performed based on a matching length without checking the matching between the n-character string immediately before the character string to be coded and the previous n-character string corresponding to the n-character string. However, according to the embodiment shown in <cross-reference target="DRAWINGS">FIG. 22, a</cross-reference> matching check is made for the p characters immediately before the character string to be coded. Since the processes in steps S<highlight><bold>1</bold></highlight> through S<highlight><bold>7</bold></highlight> according to the embodiment shown in <cross-reference target="DRAWINGS">FIG. 22</cross-reference> are matching the processes according to the embodiment shown in <cross-reference target="DRAWINGS">FIG. 21</cross-reference>, the descriptions are omitted here, and only the portions different from those in the embodiment shown in <cross-reference target="DRAWINGS">FIG. 21</cross-reference> are described below. </paragraph>
<paragraph id="P-0193" lvl="0"><number>&lsqb;0193&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 22</cross-reference>, when the hash code of the n-character string immediately before the character string to be coded is stored at an array address (step S<highlight><bold>3</bold></highlight>), it is checked whether or not the p-character string immediately before the character string to be coded matches the previous p-character string at the occurrence position retrieved by the hash retrieval (step S<highlight><bold>11</bold></highlight>). Then, if the p-character string immediately before the character string to be coded matches the previous p-character string at the occurrence position retrieved by the hash retrieval, then the character string to be coded is coded based on a matching length (step S<highlight><bold>4</bold></highlight>). On the other hand, if the p-character string immediately before the character string to be coded does not match the previous p-character string at the occurrence position retrieved by the hash retrieval, then the character or the character string to be coded is coded by a statistic type code or an LZ78 code (step S<highlight><bold>5</bold></highlight>). </paragraph>
<paragraph id="P-0194" lvl="0"><number>&lsqb;0194&rsqb;</number> Thus, a previous character having a longer matching length can be retrieved by performing a matching check between a character string for retrieval for use in performing a coding process based on a matching length and a previous character string. As a result, a compression rate can be successfully improved. </paragraph>
<paragraph id="P-0195" lvl="0"><number>&lsqb;0195&rsqb;</number> It is desired that n is set to 3, and p is set to 2. By setting these values, the retrieval time can be prevented from being prolonged with the compression rate improved. </paragraph>
<paragraph id="P-0196" lvl="0"><number>&lsqb;0196&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 23</cross-reference> is a flowchart of the data compressing method according to the twelfth embodiment of the present invention. In the above described embodiment, a previous character string is searched for using n-character string immediately before the character string to be coded, and the portion matching the previous character string is coded based on a matching length. However, when the length of a large number of repeated character strings is n, a code indicating the matching length of 0 is frequently added, thereby lowering the compression rate. Accordingly, in the embodiment shown in <cross-reference target="DRAWINGS">FIG. 23</cross-reference>, when the character string following the n-character string used in retrieving the previous character string does not match the previous character string (in this case, the matching length&equals;0), the next occurrence of the character string does not imply the coding based on the matching length. Therefore, a code indicating the matching length of 0 is prevented from being added, thereby preventing the compression rate from being lowered. </paragraph>
<paragraph id="P-0197" lvl="0"><number>&lsqb;0197&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 23</cross-reference>, the array address at which the occurrence position of the previous n-character string is stored after being hash-coded (step S<highlight><bold>21</bold></highlight>), and the hash code of the n-character string immediately before the character string to be coded is generated (step S<highlight><bold>22</bold></highlight>). Then, it is checked whether or not the contents of the array address specified by the hash code are &lsquo;NOT_LEN&rsquo;. If the contents of the array address is &lsquo;NOT_LEN&rsquo;, then the character or the character string to be coded is coded by a statistic type code or an LZ78 code (step S<highlight><bold>24</bold></highlight>). On the other hand, when the contents of the array address are not &lsquo;NOT_LEN&rsquo;, it is checked whether or not the occurrence position corresponding to the hash code is stored at the array address (step S<highlight><bold>25</bold></highlight>). When the occurrence position corresponding to the hash code is stored at the array address, the occurrence position of the previous n-character string corresponding to the n-character string immediately before the character string to be coded is obtained from the array address. Then, the matching length of the character string after the n-character strings is checked, and the character string to be coded is coded based on the matching length (step S<highlight><bold>26</bold></highlight>). </paragraph>
<paragraph id="P-0198" lvl="0"><number>&lsqb;0198&rsqb;</number> On the other hand, the occurrence position corresponding to the hash code is not stored at the array address, the character or the character string to be coded is coded by a statistic type code or an LZ78 code (step S<highlight><bold>27</bold></highlight>). </paragraph>
<paragraph id="P-0199" lvl="0"><number>&lsqb;0199&rsqb;</number> Next, it is checked whether or not the matching length computed in step S<highlight><bold>26</bold></highlight> is 0 (step S<highlight><bold>28</bold></highlight>). If the matching length is 0, then &lsquo;NOT_LEN&rsquo; is stored at the array address specified by the hash code (step S<highlight><bold>29</bold></highlight>). On the other hand, if the matching length is not 0, then the occurrence position of the n-character string is stored at the array address specified by the hash code (step S<highlight><bold>30</bold></highlight>). Next, it is determined whether or not the coding process has been completed to the end of the input data (step S<highlight><bold>31</bold></highlight>). If the coding process has not been completed, control is returned to step S<highlight><bold>22</bold></highlight>, and the above described process is repeated. </paragraph>
<paragraph id="P-0200" lvl="0"><number>&lsqb;0200&rsqb;</number> In the above described embodiment, the coding process is not performed only when the matching length is 0, but the matching length can be any other values than 0. </paragraph>
<paragraph id="P-0201" lvl="0"><number>&lsqb;0201&rsqb;</number> In addition, when it is determined whether or not the matching length between the current character string and the previous character string indicates a value larger than a predetermined value. If the matching length between the current character string and the previous character string indicates a value larger than a predetermined value, the coding process is performed using an LZ77 code. If it indicates a value smaller than a predetermined value, the coding process is performed using an LZ78 code or a probability statistic type code. </paragraph>
<paragraph id="P-0202" lvl="0"><number>&lsqb;0202&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 24</cross-reference> is a flowchart of the data compressing method according to the thirteenth embodiment of the present invention. According to the embodiment shown in <cross-reference target="DRAWINGS">FIG. 23</cross-reference>, when the matching length after the n-character string is 0, the subsequent character string is not coded based on a matching length even if the n-character string occurs next. However, it is recommendable that the coding process based on a matching length is not limited for data which possibly contains a large number of repetitions of the same characters (for example, &lsquo;0000&rsquo;, &lsquo;FFFF&rsquo;, etc.). Therefore, according to the embodiment shown in <cross-reference target="DRAWINGS">FIG. 24</cross-reference>, when an immediately previous character string contains a repetition of the same characters, switching into a matching length code is not limited. Thus, the compression rate can be improved for data which possibly contains a large number of repetitions of the same characters. Since the processes in steps S<highlight><bold>21</bold></highlight> through S<highlight><bold>31</bold></highlight> shown in <cross-reference target="DRAWINGS">FIG. 24</cross-reference> are the same as those according to the embodiment shown in <cross-reference target="DRAWINGS">FIG. 23</cross-reference>, the detailed descriptions are omitted here, and only the portions different from those according to the embodiment shown in <cross-reference target="DRAWINGS">FIG. 23</cross-reference> are described below. </paragraph>
<paragraph id="P-0203" lvl="0"><number>&lsqb;0203&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 24</cross-reference>, when it is determined that a matching length is 0 in step S<highlight><bold>28</bold></highlight>, it is checked whether or not the character immediately before the character string to be coded matches the character before it (step S<highlight><bold>41</bold></highlight>). If they do not match each other, &lsquo;NOT_LEN&rsquo; is stored at the array address specified by the hash code of the character string (step S<highlight><bold>29</bold></highlight>). On the other hand, if they match each other, the occurrence position of the n-character string is stored at the array address specified by the hash code of the character string (step S<highlight><bold>30</bold></highlight>). </paragraph>
<paragraph id="P-0204" lvl="0"><number>&lsqb;0204&rsqb;</number> According to the embodiment shown in <cross-reference target="DRAWINGS">FIG. 24</cross-reference>, when an immediately previous character string having the length of 2 contains a repetition of the same characters, no switching into a matching length code is performed. The character string immediately before can have the length of 2 or larger. </paragraph>
<paragraph id="P-0205" lvl="0"><number>&lsqb;0205&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 25</cross-reference> is a block diagram of the configuration of the data compressing apparatus according to the fourteenth embodiment of the present invention. Normally, when data is compressed by the probability statistic type coding system, the highest compression rate can be obtained using a character string having the length of 5 as the maximum context (referred to as a 5th context) (refer to, for example, the above described document &ldquo;Unbounded Length Contexts for PPM&rdquo;). However, the 5th context makes a slow process. Therefore, a coding process is performed with a matching length code combined with the probability statistic type coding system of the fixed primary context according to the embodiment shown in <cross-reference target="DRAWINGS">FIG. 25</cross-reference>. By combining a matching length code with the probability statistic type coding system of the fixed primary context, a high compression rate can be obtained even if the process is simplified by limiting a compression target in the probability statistic type coding system to a short character string of two- or three-character string. In addition, as compared with the coding process using only a 5th context, the combination can furthermore improve the process speed. </paragraph>
<paragraph id="P-0206" lvl="0"><number>&lsqb;0206&rsqb;</number> A statistic type coding unit <highlight><bold>231</bold></highlight> and a matching length coding unit <highlight><bold>237</bold></highlight> are provided as shown in <cross-reference target="DRAWINGS">FIG. 25</cross-reference>. The statistic type coding unit <highlight><bold>231</bold></highlight> performs a coding process using a fixed primary context, and <highlight><bold>256</bold></highlight> code tables <highlight><bold>233</bold></highlight> through <highlight><bold>235</bold></highlight> corresponding to an immediately previous character are held in a code table holding unit <highlight><bold>232</bold></highlight>. </paragraph>
<paragraph id="P-0207" lvl="0"><number>&lsqb;0207&rsqb;</number> The original data is input to the statistic type coding unit <highlight><bold>231</bold></highlight> and the matching length coding unit <highlight><bold>237</bold></highlight>. When the original data is input, the statistic type coding unit <highlight><bold>231</bold></highlight> selects the code tables <highlight><bold>233</bold></highlight> through <highlight><bold>235</bold></highlight> corresponding to the character immediately before the input character string. A coding unit <highlight><bold>236</bold></highlight> codes the character string using the code entered in the selected code tables <highlight><bold>233</bold></highlight> through <highlight><bold>235</bold></highlight>, and outputs the coding result. When the original data is entered, the matching length coding unit <highlight><bold>237</bold></highlight> codes the input character string based on a matching length, and outputs the coding result. </paragraph>
<paragraph id="P-0208" lvl="0"><number>&lsqb;0208&rsqb;</number> In the example shown in <cross-reference target="DRAWINGS">FIG. 25</cross-reference>, the code tables <highlight><bold>233</bold></highlight> through <highlight><bold>235</bold></highlight> are provided corresponding to all 1-byte characters of 256 types. However, the number of code tables can be reduced by providing code tables corresponding to the features extracted from the immediately previous character. For example, a code table can be provided corresponding to, excluding the highest order bit of the character data, the remaining 7 bits of the character data. </paragraph>
<paragraph id="P-0209" lvl="0"><number>&lsqb;0209&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 26</cross-reference> is a block diagram of the system configuration of the coding apparatus and decoding apparatus (or the data compression apparatus and the data reconstruction apparatus) according to an embodiment of the present invention. </paragraph>
<paragraph id="P-0210" lvl="0"><number>&lsqb;0210&rsqb;</number> In <cross-reference target="DRAWINGS">FIG. 26, a</cross-reference> central processing unit (CPU) <highlight><bold>241</bold></highlight> performs a general process, <highlight><bold>242</bold></highlight> is read-only memory (ROM), <highlight><bold>243</bold></highlight> is random access memory (RAM), <highlight><bold>244</bold></highlight> is a communications interface, <highlight><bold>245</bold></highlight> is a communications network, <highlight><bold>246</bold></highlight> is an input/output interface, a display <highlight><bold>247</bold></highlight> displays document data, etc., a printer <highlight><bold>248</bold></highlight> prints document data, etc., memory <highlight><bold>249</bold></highlight> temporarily stores document data, etc. read by a scanner <highlight><bold>250</bold></highlight> for reading an input image, etc., <highlight><bold>251</bold></highlight> is a keyboard, <highlight><bold>252</bold></highlight> is a pointing device such as a mouse, a driver <highlight><bold>253</bold></highlight> drives a storage medium, <highlight><bold>254</bold></highlight> is a hard disk, <highlight><bold>255</bold></highlight> is an IC memory card, <highlight><bold>256</bold></highlight> is a magnetic tape, <highlight><bold>257</bold></highlight> is a floppy disk, <highlight><bold>258</bold></highlight> is an optical disk such as CD-ROM, DVD-ROM, etc., and <highlight><bold>259</bold></highlight> is a bus. </paragraph>
<paragraph id="P-0211" lvl="0"><number>&lsqb;0211&rsqb;</number> A program for compressing data, a program for reconstructing data, data to be compresses, compressed data, etc. are stored in storage media such as the hard disk <highlight><bold>254</bold></highlight>, the IC memory card <highlight><bold>255</bold></highlight>, the magnetic tape <highlight><bold>256</bold></highlight>, the floppy disk <highlight><bold>257</bold></highlight>, the optical disk <highlight><bold>258</bold></highlight>, etc. Data can be compressed by reading a program for compressing data, and data to be compressed from these storage media to the RAM <highlight><bold>243</bold></highlight>. In addition, data can be reconstructed by reading a program for reconstructing data, and data to be compressed from these storage media to the RAM <highlight><bold>243</bold></highlight>. Furthermore, a program for compressing data and a program for reconstructing data can be stored in the ROM <highlight><bold>242</bold></highlight>. </paragraph>
<paragraph id="P-0212" lvl="0"><number>&lsqb;0212&rsqb;</number> Furthermore, a program for compressing data, a program for reconstructing data, data to be compressed, compressed data, etc. can be retrieved from the communications network <highlight><bold>245</bold></highlight> through the communications interface <highlight><bold>244</bold></highlight>. The communications network <highlight><bold>245</bold></highlight> connected to the communications interface <highlight><bold>244</bold></highlight> can be, for example, a LAN (local area network), a WAN (wide area network), Internet, an analog telephone network, a digital telephone network (ISDN: integral service digital network), a PHS (personal handy system), wireless communications networks such as satellite communications, etc. </paragraph>
<paragraph id="P-0213" lvl="0"><number>&lsqb;0213&rsqb;</number> When a program for compressing data is activated, the central processing unit <highlight><bold>241</bold></highlight> obtains data to be compressed from a storage medium such as the hard disk <highlight><bold>254</bold></highlight> or the communications network <highlight><bold>245</bold></highlight>, etc. The obtained data to be compressed is compressed by the method shown in <cross-reference target="DRAWINGS">FIGS. 4, 7</cross-reference>, <highlight><bold>10</bold></highlight>, <highlight><bold>20</bold></highlight> through <highlight><bold>24</bold></highlight>, etc. The compressed data is stored in a storage medium such as the hard disk <highlight><bold>254</bold></highlight>, etc., and transmitted through the communications network <highlight><bold>245</bold></highlight>. </paragraph>
<paragraph id="P-0214" lvl="0"><number>&lsqb;0214&rsqb;</number> By compressing data, the storage capacity can be reduced when data is stored in a storage medium such as the hard disk <highlight><bold>254</bold></highlight>, or the transmission time can be shortened when data is transmitted through the communications network <highlight><bold>245</bold></highlight>. </paragraph>
<paragraph id="P-0215" lvl="0"><number>&lsqb;0215&rsqb;</number> In addition, a compressing time can be shortened by hash-coding and storing a symbol string which previously occurred in the RAM <highlight><bold>243</bold></highlight>, and by performing hash retrieval to search for the previous symbol string to be referred to when a coding process is performed based on a matching length. </paragraph>
<paragraph id="P-0216" lvl="0"><number>&lsqb;0216&rsqb;</number> Furthermore, when a program for reconstructing data is activated, the central processing unit <highlight><bold>241</bold></highlight> obtains compressed data from a storage medium such as the hard disk <highlight><bold>254</bold></highlight>, etc. or the communications network <highlight><bold>245</bold></highlight>, etc. Then, the obtained compressed data is reconstructed, and the reconstructed data is stored in a storage medium such as the hard disk <highlight><bold>254</bold></highlight>, etc., transmitted through the communications network <highlight><bold>245</bold></highlight>, displayed on the display <highlight><bold>247</bold></highlight>, and printed on the printer <highlight><bold>248</bold></highlight>. </paragraph>
<paragraph id="P-0217" lvl="0"><number>&lsqb;0217&rsqb;</number> Thus, according to the present invention, a part of matching symbol string can be coded based on the matching length. Accordingly, the input data having a repetition of long symbol strings can be efficiently compressed. In addition, since a remaining portion of a matching symbol string is used as a code for use in detecting a matching position, the matching position can be detected without newly inserting a code for use in detecting the matching position. As a result, even when input data having a repetition of short symbol strings is coded using a matching length, the deterioration of a compression rate can be prevented from being caused by a large number of new codes inserted for detection of a matching position. </paragraph>
<paragraph id="P-0218" lvl="0"><number>&lsqb;0218&rsqb;</number> According to another aspect of the present invention, a part of a matching symbol string is coded based on a matching length while a portion not coded based on the matching length is coded using the code of a symbol occurring next when a previous symbol string is a context. As a result, for input data having a repetition of long symbol strings, a matching symbol string can be coded based on a matching string. Input data having a repetition of short symbol strings can be coded by allotting a shorter code length to a symbol string having a higher occurrence probability. As a result, a high compression rate can be attained for both data having a repetition of long symbol strings and data having a repetition of short symbol strings. </paragraph>
<paragraph id="P-0219" lvl="0"><number>&lsqb;0219&rsqb;</number> According to a further aspect of the present invention, a part of a matching symbol string is coded based on a matching length, and a portion not coded based on the matching length is coded by retrieving a coded word corresponding to the current symbol string from the dictionary in which the symbol strings occurred previously are entered in association with coded words. Thus, for input data having a repetition of long symbol strings, a matching symbol string can be coded based on a matching string, and input data having a repetition of short symbol strings can be coded by the LZ78 system. As a result, a high compression rate can be attained for both data having a repetition of long symbol strings and data having a repetition of short symbol strings. </paragraph>
<paragraph id="P-0220" lvl="0"><number>&lsqb;0220&rsqb;</number> According to a further aspect of the present invention, a part of a matching symbol string is coded based on a matching length, and the data coded based on the matching length is further coded using the code of a symbol occurring next when a previous symbol string is a context. Thus, for input data having a repetition of long symbol strings, a matching symbol string can be coded based on the matching length. Accordingly, the input data having a repetition of long symbol strings can be efficiently compressed. In addition, when a short symbol string repeatedly occurs in the compressed data, the compressed data can be furthermore compressed by allotting a short code length to a symbol string having a high occurrence probability, thereby attaining a high compression rate. </paragraph>
<paragraph id="P-0221" lvl="0"><number>&lsqb;0221&rsqb;</number> According to a further aspect of the present invention, a part of a matching symbol string is coded based on a matching length, and the coded data is further coded by retrieving a coded word corresponding to the current symbol string from the dictionary in which the symbol strings occurred previously are entered in association with coded words. Thus, for input data having a repetition of long symbol strings, a matching symbol string can be coded based on the matching length. Accordingly, the input data having a repetition of long symbol strings can be efficiently compressed. In addition, the compressed data can be further compressed by the LZ78 system. Therefore, a high compression rate can be attained for both data having a repetition of long symbol strings and data having a repetition of short symbol strings. </paragraph>
<paragraph id="P-0222" lvl="0"><number>&lsqb;0222&rsqb;</number> According to a further aspect of the present invention, by storing the occurrence position of a symbol string to be used in retrieval for checking the occurrence position of a previous symbol string to be compared based on a matching length, it is not necessary to check back one by one the previous symbol strings until a matching symbol string can be detected, thereby performing a coding process and a decoding process based on a matching length at a higher speed. </paragraph>
<paragraph id="P-0223" lvl="0"><number>&lsqb;0223&rsqb;</number> According to a further aspect of the present invention, when a matching length is shorter than a predetermined value, the symbol string is not coded based on the matching length. Thus, when a matching length is short, the deterioration of a compression rate caused by performing a coding process can be successfully avoided, thereby improving the compression rate in a coding process. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A coding apparatus comprising: 
<claim-text>symbol string detection means for detecting a second symbol string matching a first symbol string having a predetermined length from symbol strings; </claim-text>
<claim-text>matching length detection means for detecting a matching length between a third symbol string following the first symbol string and a fourth symbol string following the second symbol string; and </claim-text>
<claim-text>coding means for coding input symbol strings based on the symbol string detected by said symbol string detection means and the matching length detected by said matching length detection means. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. A coding apparatus comprising: 
<claim-text>occurrence position storage means for storing an occurrence position of a symbol string; </claim-text>
<claim-text>occurrence position retrieval means for retrieving an occurrence position of a second symbol string associated with a code corresponding to a first symbol string from the occurrence position storage means; </claim-text>
<claim-text>matching length detection means for detecting a matching length between a third symbol string following the first symbol string and a fourth symbol string following the second symbol string; and </claim-text>
<claim-text>a matching length coding means for coding the third symbol string by coding the matching length detected by said matching length detection means. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The apparatus according to <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference>, wherein 
<claim-text>when said matching length is smaller than a predetermined value, a coding process is not performed on a corresponding symbol string based on a matching length. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. A decoding apparatus comprising: 
<claim-text>coded data obtaining means for obtaining data coded based on a matching length of a third symbol string following a first symbol string having a predetermined length; </claim-text>
<claim-text>symbol string detection means for detecting a second symbol string matching the first symbol string; and </claim-text>
<claim-text>decoding means for obtaining a matching length from a code following a code indicating the first symbol string, and decoding a fourth symbol string for the matching length following the second symbol string as a third symbol string. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. A decoding apparatus comprising: 
<claim-text>coded data obtaining means for obtaining data coded based on a matching length of a third symbol string following a first symbol string having a predetermined length; </claim-text>
<claim-text>occurrence position storage means for storing an occurrence position of a decoded symbol string; </claim-text>
<claim-text>occurrence position retrieval means for retrieving an occurrence position of a second symbol string associated with a code corresponding to the first symbol string from the occurrence position storage means; and </claim-text>
<claim-text>decoding means for obtaining a matching length from a code following a code indicating the first symbol string, and decoding a fourth symbol string for the matching length following the second symbol string as a third symbol string. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. A data transmission apparatus comprising: 
<claim-text>input means for inputting a symbol string; </claim-text>
<claim-text>first symbol string detection means for detecting a second symbol string matching a first symbol string having a predetermined length from input symbol strings; </claim-text>
<claim-text>matching length detection means for detecting a matching length between a third symbol string following the first symbol string and a fourth symbol string following the second symbol string; </claim-text>
<claim-text>coding means for coding input symbol strings based on the symbol string detected by said symbol string detection means and the matching length detected by said matching length detection means; </claim-text>
<claim-text>coded data transmission means for transmitting data coded by said coding means; </claim-text>
<claim-text>coded data reception means for receiving data coded based on a matching length between the first symbol string and the third symbol string; </claim-text>
<claim-text>second symbol string detection means for detecting the second symbol string matching the first symbol string from a result of decoding the coded data; and </claim-text>
<claim-text>decoding means for decoding the fourth symbol string following the second symbol string as the third symbol string. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. A data compressing apparatus having an input buffer for holding a string of data to be compressed, said input buffer comprising a Lempel buffer for storing an already compressed portion and a Ziv buffer for storing a portion to be compressed, comprising: 
<claim-text>occurrence position holding means for holding a part or all of an occurrence position of an n-character string (n&gE;1) in the Lempel buffer; </claim-text>
<claim-text>occurrence/non-occurrence check means for checking whether or not said occurrence position holding means holds an occurrence position of a character string matching the n-character string immediately before the Ziv buffer; </claim-text>
<claim-text>occurrence position obtaining means for obtaining the occurrence position of the character string matching the n-character string immediately before the Ziv buffer when the occurrence position is held by said occurrence position holding means; </claim-text>
<claim-text>matching length detection means for detecting a matching length between a character string after the occurrence position and a character string after a start of the Ziv buffer; and </claim-text>
<claim-text>matching length coding means for coding a portion matching the character string after the occurrence position based on the matching length when said occurrence/non-occurrence check means confirms that the occurrence position of the n-character string immediately before the Ziv buffer is held. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The apparatus according to <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference>, further comprising: 
<claim-text>character-with-context code holding means for holding a code of a character immediately succeeding 0 through (m&minus;1) character string (m&gE;1) as a context; </claim-text>
<claim-text>character-with-context retrieval means for retrieving a character immediately succeeding 0 through (m&minus;1) character string as a context from said character-with-context code holding means; </claim-text>
<claim-text>character-with-context coding means for coding a character retrieved by said character-with-context retrieval means based on a code held by said character-with-context code holding means; and </claim-text>
<claim-text>switch means for switching a coding process between said matching length coding means and said character-with-context coding means. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The apparatus according to <dependent-claim-reference depends_on="CLM-00008">claim 8</dependent-claim-reference>, further comprising: 
<claim-text>link means for linking an n-character string of a context having the length of n&minus;1 and a subsequent character to an occurrence position of an n-character string in said occurrence position holding means; </claim-text>
<claim-text>context length check means for checking whether or not a length of a character coded by said character-with-context coding means is n&minus;1; and </claim-text>
<claim-text>notification means for notifying said occurrence/non-occurrence check means that said occurrence position holding means holds the occurrence position when the length of the context is n&minus;1. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The apparatus according to <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference>, further comprising: 
<claim-text>character/character string code holding means for holding a code corresponding to a character or a character string having a length of 1 through m; </claim-text>
<claim-text>character/character string retrieval means for retrieving a character or a character string matching for a longest length the data to be compressed from a character or a character string held by said character/character string code holding means; </claim-text>
<claim-text>character/character string coding means for coding a character or a character string retrieved by said character/character string retrieval means according to a code held by said character/character string code holding means; and </claim-text>
<claim-text>switch means for switching a coding process between said matching length coding means and said character/character string coding means. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. The apparatus according to <dependent-claim-reference depends_on="CLM-00011">claim 10</dependent-claim-reference>, further comprising: 
<claim-text>link means for linking an n-character string held by said character/character string code holding means to an occurrence position of an n-character string in said occurrence position holding means; </claim-text>
<claim-text>context length check means for checking whether or not a length of a character or a character string coded by said character/character string coding means is n; and </claim-text>
<claim-text>notification means for notifying said occurrence/non-occurrence check means that when a length of the character or the character string is n, said occurrence position holding means holds the occurrence position. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. The apparatus according to <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference>, further comprising: 
<claim-text>an intermediate buffer for holding a matching portion after an occurrence position of a character string matching the n-character string in the lempel buffer, with the matching portion replaced with a code indicating the matching length, and with the other portions held as data to be compressed as is; </claim-text>
<claim-text>character-with-context code holding means for holding a code of a next occurring character using an immediately previous 0 through (m&minus;1) character string as a context; </claim-text>
<claim-text>character-with-context retrieval means for retrieving a subsequent character from said character-with-context code holding means using an immediately previous 0 through (m&minus;1) character string as a context; and </claim-text>
<claim-text>character-with-context coding means for coding a character-with-context retrieved by said character-with-context retrieval means according to a code held by said character-with-context code holding means. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00013">
<claim-text><highlight><bold>13</bold></highlight>. The apparatus according to <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference>, further comprising: 
<claim-text>an intermediate buffer for holding a matching portion after an occurrence position of a character string matching the n-character string in the lempel buffer, with the matching portion replaced with a code indicating the matching length, and with the other portions held as data to be compressed as is; </claim-text>
<claim-text>character/character string code holding means for holding a code corresponding to a character or a character string having a length of 1 through m; </claim-text>
<claim-text>character/character string retrieval means for retrieving a character or a character string matching for a longest length the data held in said intermediate buffer from a character or a character string held by said character/character string code holding means; and </claim-text>
<claim-text>character/character string coding means for coding a character or a character string retrieved by said character/character string retrieval means according to a code held by said character/character string code holding means. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00014">
<claim-text><highlight><bold>14</bold></highlight>. A data compressing apparatus having an input buffer for holding a string of data to be compressed, said input buffer comprising a Lempel buffer for storing an already compressed portion and a Ziv buffer for storing a portion to be compressed, comprising: 
<claim-text>hash code generation means for generating a hash code from a character string having the length n; </claim-text>
<claim-text>occurrence position holding means for holding an occurrence position of the n-character string in the Lempel buffer in association with the hash code generated from the n-character string in the Lempel buffer; </claim-text>
<claim-text>occurrence position obtaining means for obtaining an occurrence position associated with the hash code from said occurrence position holding means by retrieving the hash code generated from the character string having the length n immediately before the Ziv buffer from said occurrence position holding means; </claim-text>
<claim-text>matching length obtaining means for comparing a character string after the occurrence position with a character string after a start of the Ziv buffer, and obtaining a matching length; and </claim-text>
<claim-text>matching length coding means for coding the character string after the start of the Ziv buffer based on the matching length. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00015">
<claim-text><highlight><bold>15</bold></highlight>. The apparatus according to <dependent-claim-reference depends_on="CLM-00011">claim 14</dependent-claim-reference>, further comprising: 
<claim-text>hash conflict confirmation means for comparing a character string in the Lempel buffer specified by said occurrence position obtaining means with a character string having the length p immediately before the Ziv buffer, wherein 
<claim-text>said matching length coding means codes a character string after a start of the Ziv buffer based on the matching length only when all of p characters match the character string. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016">
<claim-text><highlight><bold>16</bold></highlight>. The apparatus according to <dependent-claim-reference depends_on="CLM-00011">claim 15</dependent-claim-reference>, wherein 
<claim-text>n&equals;3 and p&equals;0 or 2. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00017">
<claim-text><highlight><bold>17</bold></highlight>. A data compressing apparatus having an input buffer for holding a string of data to be compressed, said input buffer comprising a Lempel buffer for storing an already compressed portion and a Ziv buffer for storing a portion to be compressed, comprising: 
<claim-text>occurrence position holding means for holding a part or all of an occurrence position of a character string having a length n in the Lempel buffer; </claim-text>
<claim-text>occurrence/non-occurrence check means for checking whether or not an occurrence position in the Lempel buffer of a character string matching a character string having a length n immediately before the Ziv buffer is held; </claim-text>
<claim-text>occurrence position obtaining means for obtaining an occurrence position in the Lempel buffer of a character string matching an n-character string immediately before the Ziv buffer; </claim-text>
<claim-text>matching length obtaining means for comparing for matching a character string after the occurrence position with a character string after a start of the Ziv buffer, and obtaining a matching length; </claim-text>
<claim-text>non-matching information holding means for holding non-matching information in association with the n-character string when a matching length obtained by said matching length obtaining means is 0; and </claim-text>
<claim-text>matching length coding means for coding the character string after the start of the Ziv buffer based on the matching length when the non-matching information is not associated with the character string having the length n immediately before the Ziv buffer. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00018">
<claim-text><highlight><bold>18</bold></highlight>. The apparatus according to <dependent-claim-reference depends_on="CLM-00011">claim 17</dependent-claim-reference>, further comprising: 
<claim-text>same character sequence confirmation means for confirming whether or not all of characters in a character string having a length q immediately before the Ziv buffer are same characters, wherein 
<claim-text>when the all characters in the immediately previous character string having the length q are identical, said non-matching information holding means does not set the non-matching information for the n-character string even when the matching length is 0. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00019">
<claim-text><highlight><bold>19</bold></highlight>. The apparatus according to <dependent-claim-reference depends_on="CLM-00011">claim 18</dependent-claim-reference>, wherein 
<claim-text>q equals 2. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00020">
<claim-text><highlight><bold>20</bold></highlight>. A data compressing apparatus having an input buffer for holding a string of data to be compressed, said input buffer comprising a Lempel buffer for storing an already compressed portion and a Ziv buffer for storing a portion to be compressed, comprising: 
<claim-text>occurrence position holding means for holding a part or all of an occurrence position of a character string having a length n in the Lempel buffer; </claim-text>
<claim-text>occurrence/non-occurrence check means for checking whether or not an occurrence position in the Lempel buffer of a character string matching a character string having a length n immediately before the Ziv buffer is held; </claim-text>
<claim-text>occurrence position obtaining means for obtaining an occurrence position in the Lempel buffer of a character string matching an n-character string immediately before the Ziv buffer; </claim-text>
<claim-text>matching length obtaining means for comparing for matching a character string after the occurrence position with a character string after a start of the Ziv buffer, and obtaining a matching length; </claim-text>
<claim-text>matching length coding means for coding the character string after the start of the Ziv buffer based on the matching length when said occurrence position obtaining means holds the occurrence position in the Lempel buffer of the character string matching the n-character string immediately before the Ziv buffer; </claim-text>
<claim-text>character-with-context code holding means for holding a code of a next occurring character using an immediately previous character or a feature extracted from the immediately previous character as a context; and </claim-text>
<claim-text>character-with-context coding means for coding a character based on the code when said occurrence position obtaining means does not hold the occurrence position in the Lempel buffer of the character string matching the n-character string immediately before the Ziv buffer. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00021">
<claim-text><highlight><bold>21</bold></highlight>. A data reconstruction apparatus having an output buffer for holding original data obtained by reconstructing compressed data comprising an Lempel buffer for storing already reconstructed data and a Ziv buffer for storing data to be reconstructed, comprising: 
<claim-text>occurrence position holding means for holding a part or all of an occurrence position of an n-character string in the Lempel buffer; </claim-text>
<claim-text>occurrence/non-occurrence check means for checking whether or not said occurrence position holding means holds an occurrence position of a character string matching the n-character string immediately before the Ziv buffer; </claim-text>
<claim-text>occurrence position obtaining means for obtaining the occurrence position of the character string matching the n-character string immediately before the Ziv buffer; </claim-text>
<claim-text>matching length reconstruction means for reconstructing a matching length from compressed data; </claim-text>
<claim-text>character string reconstruction means for obtaining a character string for the matching length following the n-character string in the Lempel buffer as a next reconstruction result of the n-character string immediately before the Ziv buffer. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00022">
<claim-text><highlight><bold>22</bold></highlight>. The apparatus according to <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference>, further comprising: 
<claim-text>character-with-context code holding means for holding a code of a character next occurring with an immediately previous 0 through (m&minus;1) character string as a context; </claim-text>
<claim-text>character-with-context retrieval means for retrieving a code from said character-with-context code holding means with the immediately previous 0 through (m&minus;1) character string as a context; </claim-text>
<claim-text>character-with-context reconstruction means for reconstructing a character from the code retrieved by said character-with-context retrieval means; and </claim-text>
<claim-text>switch means for instructing said character-with-context reconstruction means to reconstruct a character when said occurrence position holding means does not hold the occurrence position of the character string matching the n-character string immediately before the Ziv buffer. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00023">
<claim-text><highlight><bold>23</bold></highlight>. The apparatus according to <dependent-claim-reference depends_on="CLM-00022">claim 21</dependent-claim-reference>, further comprising: 
<claim-text>character/character string code holding means for holding a code corresponding to a character or a character string having a length of 1 through m; </claim-text>
<claim-text>character/character string reconstruction means for reconstructing a character or a character string according to a code held by said character/character string code holding means; and </claim-text>
<claim-text>switch means for instructing said character/character string reconstruction means to reconstruct a character or a character string when said occurrence position holding means does not hold the occurrence position of the character string matching the n-character string immediately before the Ziv buffer. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00024">
<claim-text><highlight><bold>24</bold></highlight>. A data reconstruction apparatus, comprising: 
<claim-text>character-with-context code holding means for holding a code of a character next occurring with an immediately previous 0 through (m&minus;1) character string as a context; </claim-text>
<claim-text>character-with-context retrieval means for retrieving a code with the immediately previous 0 through (m&minus;1) character string as a context; </claim-text>
<claim-text>character-with-context reconstruction means for reconstructing a character from compressed data according to the code held by said character-with-context code holding means; </claim-text>
<claim-text>an intermediate code buffer for holding data reconstructed by said character-with-context reconstruction means; </claim-text>
<claim-text>an output buffer for storing already reconstructed data when data held in said intermediate code buffer defined as input data, said buffer comprising a Lempel buffer for storing already reconstructed data and a Ziv buffer for storing data to be reconstructed; </claim-text>
<claim-text>occurrence position holding means for holding a part or all of an occurrence position of an n-character string in the Lempel buffer; </claim-text>
<claim-text>occurrence/non-occurrence check means for checking whether or not said occurrence position holding means holds an occurrence position of a character string matching the n-character string immediately before the Ziv buffer; </claim-text>
<claim-text>occurrence position obtaining means for obtaining the occurrence position of the character string matching the n-character string immediately before the Ziv buffer when the occurrence position is held by said occurrence position holding means; </claim-text>
<claim-text>matching length reconstruction means for reconstructing a matching length from an intermediate code; </claim-text>
<claim-text>character string reconstruction means for obtaining a character string for the matching length following the n-character string in the Lempel buffer as a next reconstruction result of the n-character string immediately before the Ziv buffer; and </claim-text>
<claim-text>output means for outputting the intermediate code as a reconstruction result as is when said occurrence position holding means does not hold the occurrence position. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00025">
<claim-text><highlight><bold>25</bold></highlight>. A data reconstruction apparatus, comprising: 
<claim-text>character/character string code holding means for holding a code corresponding to a character or a character string having a length of 1 through m; </claim-text>
<claim-text>character/character string reconstruction means for reconstructing a character or a character string according to a code held by said character/character string code holding means; </claim-text>
<claim-text>an intermediate code buffer for holding data reconstructed by said character/character string reconstruction means; </claim-text>
<claim-text>an output buffer for storing already reconstructed data when data held in said intermediate code buffer defined as input data, said buffer comprising a Lempel buffer for storing already reconstructed data and a Ziv buffer for storing data to be reconstructed; </claim-text>
<claim-text>occurrence position holding means for holding a part or all of an occurrence position of an n-character string in the Lempel buffer; </claim-text>
<claim-text>occurrence/non-occurrence check means for checking whether or not said occurrence position holding means holds an occurrence position of a character string matching the n-character string immediately before the Ziv buffer; </claim-text>
<claim-text>occurrence position obtaining means for obtaining the occurrence position of the character string matching the n-character string immediately before the Ziv buffer when the occurrence position is held by said occurrence position holding means; </claim-text>
<claim-text>matching length reconstruction means for reconstructing a matching length from an intermediate code; </claim-text>
<claim-text>character string reconstruction means for obtaining a character string for the matching length following the n-character string in the Lempel buffer as a next reconstruction result of the n-character string immediately before the Ziv buffer; and </claim-text>
<claim-text>output means for outputting the intermediate code as a reconstruction result as is when said occurrence position holding means does not hold the occurrence position. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00026">
<claim-text><highlight><bold>26</bold></highlight>. A data reconstruction apparatus having an output buffer for holding original data reconstructed, said buffer comprising a Lempel buffer for storing an already reconstructed portion, and a Ziv buffer for storing a portion to be reconstructed, comprising: 
<claim-text>hash code generation means for generating a hash code from a character string having the length n; </claim-text>
<claim-text>occurrence position holding means for holding an occurrence position of the n-character string in the Lempel buffer in association with the hash code generated from the n-character string in the Lempel buffer; </claim-text>
<claim-text>occurrence position obtaining means for obtaining an occurrence position associated with the hash code generated from the character string having the length n immediately before the Ziv buffer; </claim-text>
<claim-text>matching length reconstruction means for reconstructing a matching length from a leading code in the Ziv buffer; and </claim-text>
<claim-text>character reconstruction means for defining a character string for the matching length after the occurrence position in the Lempel buffer as a reconstruction result of the code at the start in the Ziv buffer. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00027">
<claim-text><highlight><bold>27</bold></highlight>. The apparatus according to <dependent-claim-reference depends_on="CLM-00022">claim 26</dependent-claim-reference>, further comprising: 
<claim-text>hash conflict confirmation means for comparing a character string in the Lempel buffer specified by said occurrence position obtaining means with a character string having a length p immediately before the Ziv buffer, wherein 
<claim-text>said character string reconstruction means defines as a reconstruction result of a leading code in the Ziv buffer a character string having the matching length after the occurrence position in the Lempel buffer only when all of the p characters match the character string. </claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00028">
<claim-text><highlight><bold>28</bold></highlight>. A data reconstruction apparatus having an output buffer for holding original data reconstructed, said buffer comprising a Lempel buffer for storing an already reconstructed portion, and a Ziv buffer for storing a portion to be reconstructed, comprising: 
<claim-text>occurrence position holding means for holding a part or all of an occurrence position of an n-character string in the Lempel buffer; </claim-text>
<claim-text>occurrence/non-occurrence check means for checking whether or not said occurrence position holding means holds an occurrence position of a character string matching the n-character string immediately before the Ziv buffer; </claim-text>
<claim-text>occurrence position obtaining means for obtaining the occurrence position of the character string matching the n-character string immediately before the Ziv buffer; </claim-text>
<claim-text>matching length reconstruction means for reconstructing a matching length from a leading code in the Ziv buffer; </claim-text>
<claim-text>non-matching information holding means for holding non-matching information in association with the n-character string when a matching length obtained by said matching length obtaining means is 0; and </claim-text>
<claim-text>character reconstruction means for defining as a reconstruction result of a leading code in the Ziv buffer a character string having the matching length after the occurrence position in the Lempel buffer when the non-matching information is not associated with the character string having the length n immediately before the Ziv buffer. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00029">
<claim-text><highlight><bold>29</bold></highlight>. A data reconstruction apparatus having an output buffer for holding original data reconstructed, said buffer comprising a Lempel buffer for storing an already reconstructed portion, and a Ziv buffer for storing a portion to be reconstructed, comprising: 
<claim-text>occurrence position holding means for holding a part or all of an occurrence position of an n-character string in the Lempel buffer; </claim-text>
<claim-text>occurrence/non-occurrence check means for checking whether or not said occurrence position holding means holds an occurrence position of a character string matching the n-character string immediately before the Ziv buffer; </claim-text>
<claim-text>occurrence position obtaining means for obtaining the occurrence position of the character string matching the n-character string immediately before the Ziv buffer; </claim-text>
<claim-text>matching length reconstruction means for reconstructing a matching length from a leading code in the Ziv buffer; </claim-text>
<claim-text>character reconstruction means for defining a character string having the matching length after the occurrence position in the Lempel buffer as a reconstruction result of a leading code in the Ziv buffer when said occurrence position obtaining means holds the occurrence position in the Lempel buffer of the character string matching the n-character string immediately before the Ziv buffer; </claim-text>
<claim-text>character-with-context code holding means for holding a code of a next occurring character using an immediately previous character or a feature extracted from the immediately previous character as a context; and </claim-text>
<claim-text>character-with-context code reconstruction means for reconstructing a character based on the code when said occurrence position obtaining means does not hold the occurrence position in the Lempel buffer of the character string matching the n-character string immediately before the Ziv buffer. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00030">
<claim-text><highlight><bold>30</bold></highlight>. A data compressing method comprising the steps of: 
<claim-text>coding parts of matching symbol strings based on a matching length; and </claim-text>
<claim-text>coding a symbol string not coded based on the matching length by a probability statistic type coding system or a dictionary type coding system. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00031">
<claim-text><highlight><bold>31</bold></highlight>. A data compressing method comprising the steps of: 
<claim-text>coding parts of matching symbol strings based on a matching length; and </claim-text>
<claim-text>coding the symbol strings coded based on the matching length furthermore by a probability statistic type coding system or a dictionary type coding system. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00032">
<claim-text><highlight><bold>32</bold></highlight>. A data compressing method for coding a current character string based on a matching length with a previous character string, comprising the step of 
<claim-text>using a character string immediately before the current character string for searching an occurrence position of the previous character string. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00033">
<claim-text><highlight><bold>33</bold></highlight>. A data compressing method comprising the steps of: 
<claim-text>storing a occurrence position of a previous second character string; </claim-text>
<claim-text>detecting a first character string immediately before a third character string; </claim-text>
<claim-text>obtaining a occurrence position of the second character string matching the first character string for each character; </claim-text>
<claim-text>detecting a matching length between a fourth character string following the second character string and the third character string; and </claim-text>
<claim-text>coding the third character string based on the matching length. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00034">
<claim-text><highlight><bold>34</bold></highlight>. A data compressing method comprising the steps of: 
<claim-text>determining whether or not a matching length between a current character string and a previous character string is equal to or larger than a predetermined value; </claim-text>
<claim-text>coding the current character string by a coding method of a high compression rate on a repetition of short character strings when the matching length is equal to or smaller than the predetermined value; and </claim-text>
<claim-text>coding the current character string by a coding method of a high compression rate on a repetition of long character strings when the matching length exceeds the predetermined value. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00035">
<claim-text><highlight><bold>35</bold></highlight>. A computer-readable storage medium comprising: 
<claim-text>a data structure in which a first symbol string matching a second symbol string having a predetermined length is coded; and </claim-text>
<claim-text>a data structure in which a third symbol string following the first symbol string is coded based on a matching length with a fourth symbol string following the second symbol string. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00036">
<claim-text><highlight><bold>36</bold></highlight>. A computer-readable storage medium storing a program used to direct a computer to perform the steps of: 
<claim-text>detecting a second symbol string matching a first symbol string having a predetermined length from symbol strings; </claim-text>
<claim-text>detecting a matching length between a third symbol string following the first symbol string and a fourth symbol string following the second symbol string; and </claim-text>
<claim-text>coding the third symbol string based on a matching length between the third and fourth symbol strings.</claim-text>
</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>3</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030001759A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030001759A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030001759A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030001759A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030001759A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00005">
<image id="EMI-D00005" file="US20030001759A1-20030102-D00005.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00006">
<image id="EMI-D00006" file="US20030001759A1-20030102-D00006.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00007">
<image id="EMI-D00007" file="US20030001759A1-20030102-D00007.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00008">
<image id="EMI-D00008" file="US20030001759A1-20030102-D00008.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00009">
<image id="EMI-D00009" file="US20030001759A1-20030102-D00009.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00010">
<image id="EMI-D00010" file="US20030001759A1-20030102-D00010.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00011">
<image id="EMI-D00011" file="US20030001759A1-20030102-D00011.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00012">
<image id="EMI-D00012" file="US20030001759A1-20030102-D00012.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00013">
<image id="EMI-D00013" file="US20030001759A1-20030102-D00013.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00014">
<image id="EMI-D00014" file="US20030001759A1-20030102-D00014.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00015">
<image id="EMI-D00015" file="US20030001759A1-20030102-D00015.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00016">
<image id="EMI-D00016" file="US20030001759A1-20030102-D00016.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00017">
<image id="EMI-D00017" file="US20030001759A1-20030102-D00017.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00018">
<image id="EMI-D00018" file="US20030001759A1-20030102-D00018.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00019">
<image id="EMI-D00019" file="US20030001759A1-20030102-D00019.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00020">
<image id="EMI-D00020" file="US20030001759A1-20030102-D00020.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00021">
<image id="EMI-D00021" file="US20030001759A1-20030102-D00021.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00022">
<image id="EMI-D00022" file="US20030001759A1-20030102-D00022.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00023">
<image id="EMI-D00023" file="US20030001759A1-20030102-D00023.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00024">
<image id="EMI-D00024" file="US20030001759A1-20030102-D00024.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00025">
<image id="EMI-D00025" file="US20030001759A1-20030102-D00025.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00026">
<image id="EMI-D00026" file="US20030001759A1-20030102-D00026.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
