<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE patent-application-publication SYSTEM "pap-v16-2002-01-01.dtd" [
<!ENTITY US20030001895A1-20030102-D00000.TIF SYSTEM "US20030001895A1-20030102-D00000.TIF" NDATA TIF>
<!ENTITY US20030001895A1-20030102-D00001.TIF SYSTEM "US20030001895A1-20030102-D00001.TIF" NDATA TIF>
<!ENTITY US20030001895A1-20030102-D00002.TIF SYSTEM "US20030001895A1-20030102-D00002.TIF" NDATA TIF>
<!ENTITY US20030001895A1-20030102-D00003.TIF SYSTEM "US20030001895A1-20030102-D00003.TIF" NDATA TIF>
<!ENTITY US20030001895A1-20030102-D00004.TIF SYSTEM "US20030001895A1-20030102-D00004.TIF" NDATA TIF>
]>
<patent-application-publication>
<subdoc-bibliographic-information>
<document-id>
<doc-number>20030001895</doc-number>
<kind-code>A1</kind-code>
<document-date>20030102</document-date>
</document-id>
<publication-filing-type>new</publication-filing-type>
<domestic-filing-data>
<application-number>
<doc-number>10233551</doc-number>
</application-number>
<application-number-series-code>10</application-number-series-code>
<filing-date>20020904</filing-date>
</domestic-filing-data>
<technical-information>
<classification-ipc>
<classification-ipc-primary>
<ipc>G09G005/00</ipc>
</classification-ipc-primary>
<classification-ipc-edition>07</classification-ipc-edition>
</classification-ipc>
<classification-us>
<classification-us-primary>
<uspc>
<class>345</class>
<subclass>769000</subclass>
</uspc>
</classification-us-primary>
</classification-us>
<title-of-invention>Graphical user interface providing consistent behavior for the dragging and dropping of content objects</title-of-invention>
</technical-information>
<continuity-data>
<continuations>
<continuation-of>
<parent-child>
<child>
<document-id>
<doc-number>10233551</doc-number>
<kind-code>A1</kind-code>
<document-date>20020904</document-date>
</document-id>
</child>
<parent>
<document-id>
<doc-number>08511645</doc-number>
<document-date>19950807</document-date>
<country-code>US</country-code>
</document-id>
</parent>
<parent-status>PENDING</parent-status>
</parent-child>
</continuation-of>
</continuations>
</continuity-data>
<inventors>
<first-named-inventor>
<name>
<given-name>Tantek</given-name>
<middle-name>I.</middle-name>
<family-name>Celik</family-name>
</name>
<residence>
<residence-us>
<city>Cupertino</city>
<state>CA</state>
<country-code>US</country-code>
</residence-us>
</residence>
<authority-applicant>INV</authority-applicant>
</first-named-inventor>
</inventors>
<correspondence-address>
<name-1>BURNS, DOANE, SWECKER &amp; MATHIS, L.L.P.</name-1>
<name-2></name-2>
<address>
<address-1>P.O. BOX 1404</address-1>
<city>Alexandria</city>
<state>VA</state>
<postalcode>22313-1404</postalcode>
<country>
<country-code>US</country-code>
</country>
</address>
</correspondence-address>
</subdoc-bibliographic-information>
<subdoc-abstract>
<paragraph id="A-0001" lvl="0">A drag-and-drop operation in a graphical user interface is controlled dependence upon whether the destination for the operation is a content object or a service object. If the destination of a drag-and-drop operation is a content object, the resulting action is to move the dragged object from its original location to the destination. If the destination is a service object, the resulting action is to perform the associated service on the dragged object without affecting the perceived location of the data contained in the dragged object. If the user desires that an operation other than a move be made when dragging an object to a content object, a specified key on a keyboard is pressed, to indicate that the drag-and-drop operation should make a copy, rather than merely move the object. If the source of the dragged object does not permit the user to move the object, the user can be presented with an option to copy the object when the drag-and-drop operation is carried out. Alternatively, rather than requesting the user to indicate a choice each time such a situation occurs, the computer system can be set up to automatically make a copy if the source does not permit the object to be moved. </paragraph>
</subdoc-abstract>
<subdoc-description>
<summary-of-invention>
<section>
<heading lvl="1">FIELD OF THE INVENTION </heading>
<paragraph id="P-0001" lvl="0"><number>&lsqb;0001&rsqb;</number> The present invention is directed to graphical user interfaces that are employed in computer systems, such as personal computers, and more particularly to a graphical user interface that provides consistency of operation for the dragging and dropping of all types of objects. </paragraph>
</section>
<section>
<heading lvl="1">BACKGROUND OF THE INVENTION </heading>
<paragraph id="P-0002" lvl="0"><number>&lsqb;0002&rsqb;</number> The evolution of the computer industry is unparalleled in its rate of growth and complexity. Personal computers, for example, which began as little more than calculators having limited memory, tape-driven input capabilities and monochrome displays are now able to handle almost any data processing task with relative ease. While the ever-growing increase in computing power provided greater capabilities for application programmers and end users alike, the corresponding increase in complexity created an ease of use problem. Consequently, computer system designers were faced with a new challenge, namely to harness the available computing power in a form that was usable even by those with relatively little computer training, to ease the transition of users into a computer-based information paradigm. </paragraph>
<paragraph id="P-0003" lvl="0"><number>&lsqb;0003&rsqb;</number> In pursuit of this objective, various input/output philosophies, such as &ldquo;user friendly,&rdquo; &ldquo;wysiwig&rdquo; and &ldquo;menu driven&rdquo; became popular. These approaches to the input/output function are particularly applicable to microcomputers, also known as personal computers, which are intended to appeal to a broad audience of computer users, including those who had no previous computer experience. An important aspect of computers which employ those input/output concepts was, and continues to be, the interface which allows the user to input commands and data and receive results. One particularly prevalent form of interface is known as the graphical user interface (GUI). </paragraph>
<paragraph id="P-0004" lvl="0"><number>&lsqb;0004&rsqb;</number> One popular type of GUI display is based on a visual metaphor which defines a monitor screen as a work space known as a &ldquo;desktop,&rdquo; in which the contents of documents are presented in relocatable regions known as &ldquo;windows.&rdquo; In addition to windows, the graphical user interface typically includes icons that represent various objects in the computer system. In this context, the term &ldquo;object&rdquo; refers to any software entity that exists in the memory of the computer and constitutes a specimen of a particular class. For example, an object can be a data file which contains the contents of a document. It can also be an application program or other type of service provider, such as a hardware driver. An object can also be a container for other objects, such as a folder or a window. </paragraph>
<paragraph id="P-0005" lvl="0"><number>&lsqb;0005&rsqb;</number> One of the primary advantages offered by the graphical user interface, in terms of making the computer easier to use, is the ability for the user to effortlessly manipulate objects by moving, or otherwise acting upon, their icon representations. For example, a graphical user interface typically includes a cursor, or similar type of pointing device, that is controlled by the user to select objects. By actuating a button or key while the cursor is positioned over an icon, for example double-clicking a mouse button, the user can cause the object represented by the icon to open. If the icon represents an application program, the program can be launched. If the icon represents a data file, the application program which created that data file can be automatically launched, and the file opened within the program. </paragraph>
<paragraph id="P-0006" lvl="0"><number>&lsqb;0006&rsqb;</number> Another ease-of-use capability provided by the graphical user interface is known as &ldquo;drag-and-drop.&rdquo; This term refers to the functionality which permits a user to select an icon, or other representation of an object, and &ldquo;drag&rdquo; the icon from one location to another on the display. For example, an icon for a data file can be dragged from the desktop to a folder, to cause the data file to be stored within the folder. In another type of drag-and-drop operation, an icon for a graphic document can be dragged into a window, to cause the document to be displayed within the window. As another example, an icon for a text document can be dragged onto an icon for a printer, to cause the document to be printed. </paragraph>
<paragraph id="P-0007" lvl="0"><number>&lsqb;0007&rsqb;</number> In the past, the result of a drag-and-drop operation was dependent upon a number of factors, such as the type of object being dragged, the type of source from which the object was being dragged, and the type of destination. In some instances, the location of the source and the location of the destination were also factors that influenced the resulting action. In this context, the term &ldquo;type&rdquo; refers to an inherent characteristic or property of each object. For example, an object can be a text type of object, i.e. a data file containing textual data, a graphic type of object, which is another form of data file containing graphical information, or an application type, namely an executable program. If an action that results from any given drag-and-drop operation is dependent upon the first three independent factors noted previously, all of the possible forms of action can be represented in a three-dimensional matrix of dimensions n&times;m&times;m, where n is the number of types of objects in a system (typically on the order of 100 or more) and m is the number of types of receiving, or container, objects onto which any given object can be dropped (which may be on the order of 10 or more). If additional factors are involved, the number of possible results increases exponentially. </paragraph>
<paragraph id="P-0008" lvl="0"><number>&lsqb;0008&rsqb;</number> A typical computer user cannot reasonably be expected to remember all of these possibilities. As such, the model for drag-and-drop operations is not intuitive. Consequently, when a user performs a particular drag-and-drop operation, the resulting action may not be what was expected, or desired. For example, a user may know that the dragging of an icon from a desktop to a folder on the desktop results in the file represented by the icon being moved into that folder. However, if an icon is dragged from a window representing a removable disk to the desktop folder, the resulting action may be to make a copy of the file represented by the icon, while retaining the original version on the removable disk. The user may have intended merely to move the file from the removable disk to the desktop folder, similar to moving the icon from the desktop to the folder. Because there are two copies of the file, the user is required to go back to the removable disk and delete the original copy of the file therefrom. The need for the user to perform these extra actions, because the result of the drag-and-drop operation was not as intended, is counterproductive to the basic premise which underlies the graphical user interface, namely ease of use. </paragraph>
<paragraph id="P-0009" lvl="0"><number>&lsqb;0009&rsqb;</number> Accordingly, it is an objective of the present invention to provide a graphical user interface which ensures consistency of operation when objects are dragged to various destinations in windows and workspaces. </paragraph>
</section>
<section>
<heading lvl="1">SUMMARY OF THE INVENTION </heading>
<paragraph id="P-0010" lvl="0"><number>&lsqb;0010&rsqb;</number> In accordance with the present invention, this objective is achieved by controlling the action of a drag-and-drop operation in dependence upon a single factor, namely whether the destination for the operation is a content object or a service object. Generally speaking, a content object is any type of object that has the capability to contain another object without manipulating its data. In contrast, a service object is one which provides a computational result on data when another object is dropped on it. If the destination of a drag-and-drop operation is a content object, the resulting action is to move the dragged object from its original location to the destination. If the destination is a service object, the resulting action is to perform the associated service on the dragged object without affecting the perceived location of the data contained in the dragged object. </paragraph>
<paragraph id="P-0011" lvl="0"><number>&lsqb;0011&rsqb;</number> If the user desires that a copy of an object be made when dragging it to a content object, rather than moving the object, such intention can be indicated through an appropriate action during the drag-and-drop operation. For example, the user may press a specified key on a keyboard, to indicate that the drag-and-drop operation should make a copy, rather than merely move the object. If the source of the dragged object does not permit the user to move the object, for example it is a locked disk, the user can be presented with an option to copy the object when the drag-and-drop operation is carried out. Alternatively, rather than requesting the user to indicate a choice each time such a situation occurs, the computer system can be set up to automatically make a copy if the source does not permit the object to be moved therefrom. </paragraph>
<paragraph id="P-0012" lvl="0"><number>&lsqb;0012&rsqb;</number> Further features of the invention, and the advantages offered thereby, are explained in detail hereinafter with reference to preferred embodiments illustrated in the accompanying drawings. </paragraph>
</section>
</summary-of-invention>
<brief-description-of-drawings>
<section>
<heading lvl="1">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<paragraph id="P-0013" lvl="0"><number>&lsqb;0013&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 1</cross-reference> is a general block diagram of an exemplary computer system of the type in which the present invention can be implemented; </paragraph>
<paragraph id="P-0014" lvl="0"><number>&lsqb;0014&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 2A and 2B</cross-reference> are illustrations of a desktop in a graphical user interface; </paragraph>
<paragraph id="P-0015" lvl="0"><number>&lsqb;0015&rsqb;</number> <cross-reference target="DRAWINGS">FIGS. 3A and 3B</cross-reference> are illustrations of different types of drag and drop operations; and </paragraph>
<paragraph id="P-0016" lvl="0"><number>&lsqb;0016&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 4</cross-reference> is a flowchart of the operation of a user interface in accordance with the present invention.</paragraph>
</section>
</brief-description-of-drawings>
<detailed-description>
<section>
<heading lvl="1">DETAILED DESCRIPTION </heading>
<paragraph id="P-0017" lvl="0"><number>&lsqb;0017&rsqb;</number> To facilitate an understanding of the present invention, its underlying principles are described hereinafter with reference to their implementation in a specific embodiment. In particular, certain references are made to features and terminology associated with the Macintosh&reg; Operating System provided by Apple Computer, Inc. It will be apparent, however, that the practical applications of the present invention are not limited to this particular embodiment. Rather, it can be utilized in any type of computer system that provides a drag-and-drop type of operation that permits users to easily manipulate objects within the system. </paragraph>
<paragraph id="P-0018" lvl="0"><number>&lsqb;0018&rsqb;</number> While the particular hardware components of a computer system do not form part of the invention itself, they are briefly described herein to provide a thorough understanding of the manner in which the features of the invention cooperate with various components of a computer system, to produce the desired results. Referring to <cross-reference target="DRAWINGS">FIG. 1, a</cross-reference> typical computer system includes a computer <highlight><bold>10</bold></highlight> having a variety of external peripheral devices <highlight><bold>12</bold></highlight> connected thereto. The computer <highlight><bold>10</bold></highlight> includes a central processing unit <highlight><bold>14</bold></highlight> and associated memory. This memory generally includes a main memory which is typically implemented in the form of a random access memory <highlight><bold>16</bold></highlight>, a nonvolatile memory that can comprise a read only memory <highlight><bold>18</bold></highlight>, and a permanent storage device, such as a magnetic or optical disk <highlight><bold>20</bold></highlight>. The CPU <highlight><bold>14</bold></highlight> communicates with each of these forms of memory through an internal bus <highlight><bold>22</bold></highlight>. The peripheral devices <highlight><bold>12</bold></highlight> include a data entry device such as a keyboard <highlight><bold>24</bold></highlight>, and a pointing or cursor control device <highlight><bold>26</bold></highlight> such as a mouse, trackball, pen or the like. A display device <highlight><bold>28</bold></highlight>, such a CRT monitor or an LCD screen, provides a visual display of the information that is being processed within the computer, for example, the contents of a document being created by the user. A hard copy of this information can be provided through a printer <highlight><bold>30</bold></highlight>, or similar such device. Each of these external peripheral devices communicates with the CPU <highlight><bold>14</bold></highlight> by means of one or more input/output ports <highlight><bold>32</bold></highlight> on the computer. </paragraph>
<paragraph id="P-0019" lvl="0"><number>&lsqb;0019&rsqb;</number> The present invention is particularly directed to a system which controls the manner in which the CPU <highlight><bold>14</bold></highlight> handles information that is manipulated by the keyboard <highlight><bold>24</bold></highlight> and the cursor control device <highlight><bold>26</bold></highlight>, as well as the manner in which that manipulated information is portrayed to the user through the display device <highlight><bold>30</bold></highlight>. An example of an interface which employs the principles of the present invention is illustrated in <cross-reference target="DRAWINGS">FIGS. 2A and 2B</cross-reference>. These figures illustrate a desktop <highlight><bold>34</bold></highlight> which defines a workspace <highlight><bold>36</bold></highlight>. Also included on the desktop is a menu bar <highlight><bold>38</bold></highlight>. Within the workspace <highlight><bold>36</bold></highlight> are two windows, <highlight><bold>40</bold></highlight> and <highlight><bold>42</bold></highlight>. The left-hand window <highlight><bold>40</bold></highlight> is a folder window which contains icons representing various objects. As shown in <cross-reference target="DRAWINGS">FIG. 2</cross-reference>A, three icons <highlight><bold>44</bold></highlight> pertain to text objects, a fourth icon <highlight><bold>45</bold></highlight> represents a graphic object and another icon <highlight><bold>46</bold></highlight> represents a spreadsheet object. A sixth icon <highlight><bold>48</bold></highlight> is a stationary icon representing an object that can be used for the creation of presentation slides. In <cross-reference target="DRAWINGS">FIG. 2A</cross-reference> the right-hand window <highlight><bold>42</bold></highlight> contains a document which includes text <highlight><bold>50</bold></highlight>. </paragraph>
<paragraph id="P-0020" lvl="0"><number>&lsqb;0020&rsqb;</number> <cross-reference target="DRAWINGS">FIG. 2B</cross-reference> illustrates the result of an operation in which the graphic icon <highlight><bold>45</bold></highlight> has been dragged from the folder in the left window <highlight><bold>40</bold></highlight> to the text document in the right window <highlight><bold>42</bold></highlight>. As is known in interfaces which provide a desktop metaphor, such as that shown in <cross-reference target="DRAWINGS">FIGS. 2A and 2B</cross-reference>, dragging is an operation in which objects can be moved or copied on the desktop and within windows through the actuation of the cursor control device <highlight><bold>26</bold></highlight>. When the graphic icon is placed within the document, its contents can be displayed, as illustrated in <cross-reference target="DRAWINGS">FIG. 2B</cross-reference>. </paragraph>
<paragraph id="P-0021" lvl="0"><number>&lsqb;0021&rsqb;</number> Generally speaking, an object can be dragged to a variety of different types of destinations. <cross-reference target="DRAWINGS">FIG. 3A</cross-reference> illustrates some examples of different types of container objects that can serve as destinations for a drag-and-drop operation. Referring thereto, a window <highlight><bold>52</bold></highlight> contains a file <highlight><bold>54</bold></highlight> which the user has selected with a cursor. This file can be dragged to another window <highlight><bold>56</bold></highlight> on the desktop. Alternatively, it can be dragged to a folder <highlight><bold>58</bold></highlight>, which could reside within a window or on the desktop itself. As a third alternative, the file <highlight><bold>54</bold></highlight> can be dragged into a text document <highlight><bold>60</bold></highlight> which might be displayed in another window. Each of the objects to which the file <highlight><bold>54</bold></highlight> is moved in the examples of <cross-reference target="DRAWINGS">FIG. 3</cross-reference>A, namely the window <highlight><bold>56</bold></highlight>, the folder <highlight><bold>58</bold></highlight> and the document <highlight><bold>60</bold></highlight>, is a &ldquo;container&rdquo; object. These objects have the ability to embed objects within their contents. For example, when an object contains another object, it may include a pointer or other analogous type of reference to the location of the embedded object in the computer&apos;s memory. </paragraph>
<paragraph id="P-0022" lvl="0"><number>&lsqb;0022&rsqb;</number> In a preferred implementation, the present invention is incorporated in a component-software based user interface of the type disclosed in U.S. patent application Ser No. 08/175,549, filed Dec. 30, 1993. In this type of user interface, objects exist in the form of parts, where each part consists of intrinsic contents and an associated editor or handler. One of the fundamental properties of parts is that any part can function as a container for any other part, or be contained within any other part. Thus, any part can be dragged and dropped onto any other part, and become a portion of the contents of the receiving part. </paragraph>
<paragraph id="P-0023" lvl="0"><number>&lsqb;0023&rsqb;</number> In addition to container objects, a given object can also be dragged to a service object. Referring to <cross-reference target="DRAWINGS">FIG. 3</cross-reference>B, the file <highlight><bold>54</bold></highlight> can be dragged onto an icon <highlight><bold>62</bold></highlight> which represents a printer. As an alternative, the file <highlight><bold>54</bold></highlight> can be dragged onto an icon <highlight><bold>64</bold></highlight> that represents a word count service. When the file is dropped onto the printer icon <highlight><bold>62</bold></highlight>, it causes the contents of the file to be printed at a particular printer associated with the icon. When it is dropped on the word count service icon <highlight><bold>64</bold></highlight>, an application is launched which counts the number of words in the file, and reports the results of the count to the user. Whenever either of these services is performed, the dropped object remains intact, i.e. it is not consumed by the service. Consequently, the icon <highlight><bold>54</bold></highlight> returns to its original state, within the window <highlight><bold>52</bold></highlight>, after the user has dropped it onto one of the service icons <highlight><bold>62</bold></highlight> or <highlight><bold>64</bold></highlight>. </paragraph>
<paragraph id="P-0024" lvl="0"><number>&lsqb;0024&rsqb;</number> In accordance with the present invention, the user interface provides a consistent form of action whenever the user carries out a drag-and-drop operation. The specific action that is performed is determined by the destination for the dragged object. If the destination is a container object, such as any of the examples illustrated in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>A, the dragged object is moved from its original location to the destination object. Alternatively, if the destination object is a service provider, as illustrated in <cross-reference target="DRAWINGS">FIG. 3</cross-reference>B, the associated service is carried out with respect to the dragged object, but the perceived location of the object does not change. In other words, in the example of <cross-reference target="DRAWINGS">FIG. 3</cross-reference>B, the icon <highlight><bold>54</bold></highlight> returns to its original location in the window <highlight><bold>52</bold></highlight>. With this approach, the user is not required to remember a number of different types of actions that could result from a drag-and-drop operation. Rather, only two different actions are normally provided, namely moving the object or performing a service, and are determined solely by the nature of the destination object. </paragraph>
<paragraph id="P-0025" lvl="0"><number>&lsqb;0025&rsqb;</number> Of course, there may be instances when the user desires to place a copy of a selected object at the destination, and leave the original version of the object intact, rather than move it. For example, referring to <cross-reference target="DRAWINGS">FIG. 3</cross-reference>A, the user may desire to place a copy of the file <highlight><bold>54</bold></highlight> in the folder <highlight><bold>58</bold></highlight>. In this situation, the user can indicate the desire to make a copy by performing a specified action during the drag-and-drop operation. For example, the user can press a particular key on the computer keyboard, such as a shift or control key, while carrying out the drag-and-drop operation. As another example, if the cursor control device is a mouse, or the like, which has two or more buttons, one of the buttons can be designated as the &ldquo;primary&rdquo; button which is employed for default operations, such as selecting files and dragging icons, and one of the other buttons can be designated as a modifier button which indicates alternative operations, such as copying rather than moving an object. </paragraph>
<paragraph id="P-0026" lvl="0"><number>&lsqb;0026&rsqb;</number> If desired, the user interface can also provide a visual distinction between moving and copying operations. For example, during a normal drag-and-drop onto to a container object, the representation of the icon can move on the display with the cursor during the dragging operation. However, when a copying action is indicated, the image of the icon can remain in its original location, and a &ldquo;ghost&rdquo; or outline image of the icon can follow the cursor, to indicate that the original object is remaining intact. </paragraph>
<paragraph id="P-0027" lvl="0"><number>&lsqb;0027&rsqb;</number> In addition to copying, other types of modified actions may be desirable in response to a drag-and-drop operation. For example, the user may wish to create a link between two objects, or create a reference object which refers to the original object, e.g., an alias. In such a case, other modifier keys can be designated for these other types of actions. </paragraph>
<paragraph id="P-0028" lvl="0"><number>&lsqb;0028&rsqb;</number> In some cases, it may not be possible for the user to move an object from the source location as part of the drag-and-drop operation. For example, if a folder or disk which contains the object has been locked, the user does not normally have the option to make changes to the object. Rather, the user&apos;s capabilities may be limited to reading the object. In such a case, if the user attempts to perform a drag-and-drop operation with respect to a locked object, a warning can be displayed, to indicate that the user does not have the necessary authority to move the object. As part of the warning, the user can be provided with the option to make a copy of the object, instead of moving it. In this case, the original version of the object remains intact, so that its write-access privilege is not violated, but the user can still place a copy of the object at a desired new destination. </paragraph>
<paragraph id="P-0029" lvl="0"><number>&lsqb;0029&rsqb;</number> As an alternative to providing the user with an option to copy the dragged object, the user can set a system preference which automatically carries out a desired operation whenever an object cannot be moved through a drag-and-drop operation. For example, the user may set a parameter in the system which causes it to automatically copy the dragged object, or to automatically cancel the move when the user drags an object from a non-changeable source. </paragraph>
<paragraph id="P-0030" lvl="0"><number>&lsqb;0030&rsqb;</number> The foregoing functionality of the graphical user interface is illustrated in the flow chart of <cross-reference target="DRAWINGS">FIG. 4</cross-reference>. Referring thereto, at step <highlight><bold>70</bold></highlight> a user drags one or more objects from a source location A to a destination object B. At step <highlight><bold>72</bold></highlight> at determination is made whether the destination object B is a service. If so, the service is performed on the dragged object(s) at step <highlight><bold>74</bold></highlight>, and the process ends. </paragraph>
<paragraph id="P-0031" lvl="0"><number>&lsqb;0031&rsqb;</number> If the destination is not a service, a determination is made at step <highlight><bold>76</bold></highlight> whether the user has pressed a modifier key or button. If so, the appropriate modified action is carried out, e.g., a copy of the object is made and stored in the destination object B, at step <highlight><bold>78</bold></highlight>. Otherwise, a determination is made at step <highlight><bold>80</bold></highlight> whether the user has write access for the source location A, i.e. whether the user is permitted to move the object from its current location. If so, the object is moved from its source location A to the destination object B, at step <highlight><bold>82</bold></highlight> e.g. a pointer which refers to the object is created in the destination object B and removed from the source object A. In addition, the image of the dragged object&apos;s icon is moved to the destination. </paragraph>
<paragraph id="P-0032" lvl="0"><number>&lsqb;0032&rsqb;</number> If a determination is made at step <highlight><bold>80</bold></highlight> that the user does not have write access for the source location A, an inquiry is made at step <highlight><bold>84</bold></highlight> whether a system preference has been established for read-only sources. If so, a determination of that preference is made at step <highlight><bold>86</bold></highlight>. If the user has indicated that the object should be automatically copied, this action is carried out at step <highlight><bold>78</bold></highlight>. Otherwise, the move is cancelled and the process ends. If the user has not indicated a specific preference, a dialog box can be displayed at step <highlight><bold>88</bold></highlight>, asking the user whether he desires to copy the dragged object or cancel the move operation. If the user indicates cancel, the process ends. Otherwise, the object is copied at step <highlight><bold>78</bold></highlight>, and the process then ends. </paragraph>
<paragraph id="P-0033" lvl="0"><number>&lsqb;0033&rsqb;</number> From the foregoing, it can be seen that the present invention provides a consistent action in response to a drag-and-drop operation, thereby enhancing the ease of use of the graphical user interface. The dragging action is independent of both the source of the object being dragged and the type of object being dragged. The resulting action is a binary decision that is based exclusively on whether the destination is a service object or a container object, thereby reducing the knowledge that is required of the user to successfully manipulate objects. </paragraph>
<paragraph id="P-0034" lvl="0"><number>&lsqb;0034&rsqb;</number> It will be appreciated by those of ordinary skill in the art that the present invention can be embodied in other specific forms without departing from the spirit or essential characteristics thereof. The presently disclosed embodiments are considered in all respects to be illustrative, and not restrictive. The scope of the invention is indicated by the appended claims rather than the foregoing description, and all changes that come within the meaning and range of equivalents thereof are intended to be embraced therein. </paragraph>
</section>
</detailed-description>
</subdoc-description>
<subdoc-claims>
<heading lvl="1">What is claimed is: </heading>
<claim id="CLM-00001">
<claim-text><highlight><bold>1</bold></highlight>. A method for manipulating objects in a graphical user interface for a computer, of the type in which representations of objects stored in a memory are displayed to a user on a display, comprising the steps of: 
<claim-text>selecting a first object whose representation is displayed on said display; </claim-text>
<claim-text>dragging the representation of the first object from a first location on the display to a second location associated with a second object; </claim-text>
<claim-text>determining whether said second object is either a service object which performs a service that provides a computational result on data or a container object; </claim-text>
<claim-text>performing a service with respect to said first object if said second object is a service object; and </claim-text>
<claim-text>moving the representation of the first object from said first location to a new location associated with said second object if said second object is a container object. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00002">
<claim-text><highlight><bold>2</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> further including the step of displaying the representation of the first object at said first location after said service is performed, when the second object is a service object. </claim-text>
</claim>
<claim id="CLM-00003">
<claim-text><highlight><bold>3</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> further including the step of detecting an indication for a modified operation, and performing an operation other than moving the representation of the first object. </claim-text>
</claim>
<claim id="CLM-00004">
<claim-text><highlight><bold>4</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference> wherein said indication is the actuation of a predetermined key during said dragging step. </claim-text>
</claim>
<claim id="CLM-00005">
<claim-text><highlight><bold>5</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference> wherein said other operation comprises the steps of making a copy of the first object and displaying a representation of the copy at said new location, and displaying the representation of the first object at said first location. </claim-text>
</claim>
<claim id="CLM-00006">
<claim-text><highlight><bold>6</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00003">claim 3</dependent-claim-reference> wherein said other operation comprises the step of creating a link between said first and second objects. </claim-text>
</claim>
<claim id="CLM-00007">
<claim-text><highlight><bold>7</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> further including the steps of detecting whether said first location limits access to said first object, and if so determining whether the first object is to be copied. </claim-text>
</claim>
<claim id="CLM-00008">
<claim-text><highlight><bold>8</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference> wherein said determining step includes the step of detecting whether a copy operation is stored as a default operation in the computer. </claim-text>
</claim>
<claim id="CLM-00009">
<claim-text><highlight><bold>9</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00007">claim 7</dependent-claim-reference> wherein said determining step includes the steps of displaying a message which permits a user to indicate a choice, and selectively copying the first object in dependence upon the choice indicated by the user. </claim-text>
</claim>
<claim id="CLM-00010">
<claim-text><highlight><bold>10</bold></highlight>. The method of <dependent-claim-reference depends_on="CLM-00001">claim 1</dependent-claim-reference> wherein the representation of the first object comprises an icon. </claim-text>
</claim>
<claim id="CLM-00011">
<claim-text><highlight><bold>11</bold></highlight>. A computer-readable medium containing a program which performs the steps of: 
<claim-text>detecting the dragging of a representation of a first object from a first location on a display to a second location associated with a second object; </claim-text>
<claim-text>determining whether said second object is a service object which performs a service that provides a computational result on data; </claim-text>
<claim-text>performing a service with respect to said first object if said second object is a service object; and </claim-text>
<claim-text>moving the representation of the first object from said first location to a new location associated with said second object if said second object is not a service object. </claim-text>
</claim-text>
</claim>
<claim id="CLM-00012">
<claim-text><highlight><bold>12</bold></highlight>. A graphical user interface for a computer having a display device, comprising: 
<claim-text>a user-controlled component for selecting and moving representations of objects displayed on said display device; </claim-text>
<claim-text>means for detecting that a representation of a first object displayed at a first location on said display device is moved to a location associated with a second object; </claim-text>
<claim-text>means for determining whether said second object is a service object which performs a service that provides a computation result on data; </claim-text>
<claim-text>means for causing said second object to perform said service on the data of said first object when said second object is determined to be a service object; and </claim-text>
<claim-text>means for moving the representation of the first object from said first location to said second location when said second object is not a service object.</claim-text>
</claim-text>
</claim>
</subdoc-claims>
<subdoc-drawings id="DRAWINGS">
<heading lvl="0" align="CENTER">Drawings</heading>
<representative-figure>4</representative-figure>
<figure id="figure-D00000">
<image id="EMI-D00000" file="US20030001895A1-20030102-D00000.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00001">
<image id="EMI-D00001" file="US20030001895A1-20030102-D00001.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00002">
<image id="EMI-D00002" file="US20030001895A1-20030102-D00002.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00003">
<image id="EMI-D00003" file="US20030001895A1-20030102-D00003.TIF" imf="TIFF" ti="DR"/>
</figure>
<figure id="figure-D00004">
<image id="EMI-D00004" file="US20030001895A1-20030102-D00004.TIF" imf="TIFF" ti="DR"/>
</figure>
</subdoc-drawings>
</patent-application-publication>
